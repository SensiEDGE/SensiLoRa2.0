
SensiLora2.0.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001eb04  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00001308  0801ebc4  0801ebc4  0002ebc4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0801fecc  0801fecc  0002fecc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0801fed4  0801fed4  0002fed4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0801fed8  0801fed8  0002fed8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000334  20000000  0801fedc  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00001508  20000334  08020210  00030334  2**2
                  ALLOC
  8 ._user_heap_stack 00000604  2000183c  08020210  0003183c  2**0
                  ALLOC
  9 .ARM.attributes 00000028  00000000  00000000  00030334  2**0
                  CONTENTS, READONLY
 10 .debug_line   0003d96f  00000000  00000000  0003035c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_info   0004cacb  00000000  00000000  0006dccb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_abbrev 0000992b  00000000  00000000  000ba796  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 00002be0  00000000  00000000  000c40c8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    000aea7b  00000000  00000000  000c6ca8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00002848  00000000  00000000  00175728  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00025774  00000000  00000000  00177f70  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .comment      00000053  00000000  00000000  0019d6e4  2**0
                  CONTENTS, READONLY
 18 .debug_frame  0000aad0  00000000  00000000  0019d738  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .stab         0000009c  00000000  00000000  001a8208  2**2
                  CONTENTS, READONLY, DEBUGGING
 20 .stabstr      0000014d  00000000  00000000  001a82a4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000334 	.word	0x20000334
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0801ebac 	.word	0x0801ebac

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000338 	.word	0x20000338
 8000104:	0801ebac 	.word	0x0801ebac

08000108 <__gnu_thumb1_case_shi>:
 8000108:	b403      	push	{r0, r1}
 800010a:	4671      	mov	r1, lr
 800010c:	0849      	lsrs	r1, r1, #1
 800010e:	0040      	lsls	r0, r0, #1
 8000110:	0049      	lsls	r1, r1, #1
 8000112:	5e09      	ldrsh	r1, [r1, r0]
 8000114:	0049      	lsls	r1, r1, #1
 8000116:	448e      	add	lr, r1
 8000118:	bc03      	pop	{r0, r1}
 800011a:	4770      	bx	lr

0800011c <__udivsi3>:
 800011c:	2200      	movs	r2, #0
 800011e:	0843      	lsrs	r3, r0, #1
 8000120:	428b      	cmp	r3, r1
 8000122:	d374      	bcc.n	800020e <__udivsi3+0xf2>
 8000124:	0903      	lsrs	r3, r0, #4
 8000126:	428b      	cmp	r3, r1
 8000128:	d35f      	bcc.n	80001ea <__udivsi3+0xce>
 800012a:	0a03      	lsrs	r3, r0, #8
 800012c:	428b      	cmp	r3, r1
 800012e:	d344      	bcc.n	80001ba <__udivsi3+0x9e>
 8000130:	0b03      	lsrs	r3, r0, #12
 8000132:	428b      	cmp	r3, r1
 8000134:	d328      	bcc.n	8000188 <__udivsi3+0x6c>
 8000136:	0c03      	lsrs	r3, r0, #16
 8000138:	428b      	cmp	r3, r1
 800013a:	d30d      	bcc.n	8000158 <__udivsi3+0x3c>
 800013c:	22ff      	movs	r2, #255	; 0xff
 800013e:	0209      	lsls	r1, r1, #8
 8000140:	ba12      	rev	r2, r2
 8000142:	0c03      	lsrs	r3, r0, #16
 8000144:	428b      	cmp	r3, r1
 8000146:	d302      	bcc.n	800014e <__udivsi3+0x32>
 8000148:	1212      	asrs	r2, r2, #8
 800014a:	0209      	lsls	r1, r1, #8
 800014c:	d065      	beq.n	800021a <__udivsi3+0xfe>
 800014e:	0b03      	lsrs	r3, r0, #12
 8000150:	428b      	cmp	r3, r1
 8000152:	d319      	bcc.n	8000188 <__udivsi3+0x6c>
 8000154:	e000      	b.n	8000158 <__udivsi3+0x3c>
 8000156:	0a09      	lsrs	r1, r1, #8
 8000158:	0bc3      	lsrs	r3, r0, #15
 800015a:	428b      	cmp	r3, r1
 800015c:	d301      	bcc.n	8000162 <__udivsi3+0x46>
 800015e:	03cb      	lsls	r3, r1, #15
 8000160:	1ac0      	subs	r0, r0, r3
 8000162:	4152      	adcs	r2, r2
 8000164:	0b83      	lsrs	r3, r0, #14
 8000166:	428b      	cmp	r3, r1
 8000168:	d301      	bcc.n	800016e <__udivsi3+0x52>
 800016a:	038b      	lsls	r3, r1, #14
 800016c:	1ac0      	subs	r0, r0, r3
 800016e:	4152      	adcs	r2, r2
 8000170:	0b43      	lsrs	r3, r0, #13
 8000172:	428b      	cmp	r3, r1
 8000174:	d301      	bcc.n	800017a <__udivsi3+0x5e>
 8000176:	034b      	lsls	r3, r1, #13
 8000178:	1ac0      	subs	r0, r0, r3
 800017a:	4152      	adcs	r2, r2
 800017c:	0b03      	lsrs	r3, r0, #12
 800017e:	428b      	cmp	r3, r1
 8000180:	d301      	bcc.n	8000186 <__udivsi3+0x6a>
 8000182:	030b      	lsls	r3, r1, #12
 8000184:	1ac0      	subs	r0, r0, r3
 8000186:	4152      	adcs	r2, r2
 8000188:	0ac3      	lsrs	r3, r0, #11
 800018a:	428b      	cmp	r3, r1
 800018c:	d301      	bcc.n	8000192 <__udivsi3+0x76>
 800018e:	02cb      	lsls	r3, r1, #11
 8000190:	1ac0      	subs	r0, r0, r3
 8000192:	4152      	adcs	r2, r2
 8000194:	0a83      	lsrs	r3, r0, #10
 8000196:	428b      	cmp	r3, r1
 8000198:	d301      	bcc.n	800019e <__udivsi3+0x82>
 800019a:	028b      	lsls	r3, r1, #10
 800019c:	1ac0      	subs	r0, r0, r3
 800019e:	4152      	adcs	r2, r2
 80001a0:	0a43      	lsrs	r3, r0, #9
 80001a2:	428b      	cmp	r3, r1
 80001a4:	d301      	bcc.n	80001aa <__udivsi3+0x8e>
 80001a6:	024b      	lsls	r3, r1, #9
 80001a8:	1ac0      	subs	r0, r0, r3
 80001aa:	4152      	adcs	r2, r2
 80001ac:	0a03      	lsrs	r3, r0, #8
 80001ae:	428b      	cmp	r3, r1
 80001b0:	d301      	bcc.n	80001b6 <__udivsi3+0x9a>
 80001b2:	020b      	lsls	r3, r1, #8
 80001b4:	1ac0      	subs	r0, r0, r3
 80001b6:	4152      	adcs	r2, r2
 80001b8:	d2cd      	bcs.n	8000156 <__udivsi3+0x3a>
 80001ba:	09c3      	lsrs	r3, r0, #7
 80001bc:	428b      	cmp	r3, r1
 80001be:	d301      	bcc.n	80001c4 <__udivsi3+0xa8>
 80001c0:	01cb      	lsls	r3, r1, #7
 80001c2:	1ac0      	subs	r0, r0, r3
 80001c4:	4152      	adcs	r2, r2
 80001c6:	0983      	lsrs	r3, r0, #6
 80001c8:	428b      	cmp	r3, r1
 80001ca:	d301      	bcc.n	80001d0 <__udivsi3+0xb4>
 80001cc:	018b      	lsls	r3, r1, #6
 80001ce:	1ac0      	subs	r0, r0, r3
 80001d0:	4152      	adcs	r2, r2
 80001d2:	0943      	lsrs	r3, r0, #5
 80001d4:	428b      	cmp	r3, r1
 80001d6:	d301      	bcc.n	80001dc <__udivsi3+0xc0>
 80001d8:	014b      	lsls	r3, r1, #5
 80001da:	1ac0      	subs	r0, r0, r3
 80001dc:	4152      	adcs	r2, r2
 80001de:	0903      	lsrs	r3, r0, #4
 80001e0:	428b      	cmp	r3, r1
 80001e2:	d301      	bcc.n	80001e8 <__udivsi3+0xcc>
 80001e4:	010b      	lsls	r3, r1, #4
 80001e6:	1ac0      	subs	r0, r0, r3
 80001e8:	4152      	adcs	r2, r2
 80001ea:	08c3      	lsrs	r3, r0, #3
 80001ec:	428b      	cmp	r3, r1
 80001ee:	d301      	bcc.n	80001f4 <__udivsi3+0xd8>
 80001f0:	00cb      	lsls	r3, r1, #3
 80001f2:	1ac0      	subs	r0, r0, r3
 80001f4:	4152      	adcs	r2, r2
 80001f6:	0883      	lsrs	r3, r0, #2
 80001f8:	428b      	cmp	r3, r1
 80001fa:	d301      	bcc.n	8000200 <__udivsi3+0xe4>
 80001fc:	008b      	lsls	r3, r1, #2
 80001fe:	1ac0      	subs	r0, r0, r3
 8000200:	4152      	adcs	r2, r2
 8000202:	0843      	lsrs	r3, r0, #1
 8000204:	428b      	cmp	r3, r1
 8000206:	d301      	bcc.n	800020c <__udivsi3+0xf0>
 8000208:	004b      	lsls	r3, r1, #1
 800020a:	1ac0      	subs	r0, r0, r3
 800020c:	4152      	adcs	r2, r2
 800020e:	1a41      	subs	r1, r0, r1
 8000210:	d200      	bcs.n	8000214 <__udivsi3+0xf8>
 8000212:	4601      	mov	r1, r0
 8000214:	4152      	adcs	r2, r2
 8000216:	4610      	mov	r0, r2
 8000218:	4770      	bx	lr
 800021a:	e7ff      	b.n	800021c <__udivsi3+0x100>
 800021c:	b501      	push	{r0, lr}
 800021e:	2000      	movs	r0, #0
 8000220:	f000 f8f0 	bl	8000404 <__aeabi_idiv0>
 8000224:	bd02      	pop	{r1, pc}
 8000226:	46c0      	nop			; (mov r8, r8)

08000228 <__aeabi_uidivmod>:
 8000228:	2900      	cmp	r1, #0
 800022a:	d0f7      	beq.n	800021c <__udivsi3+0x100>
 800022c:	e776      	b.n	800011c <__udivsi3>
 800022e:	4770      	bx	lr

08000230 <__divsi3>:
 8000230:	4603      	mov	r3, r0
 8000232:	430b      	orrs	r3, r1
 8000234:	d47f      	bmi.n	8000336 <__divsi3+0x106>
 8000236:	2200      	movs	r2, #0
 8000238:	0843      	lsrs	r3, r0, #1
 800023a:	428b      	cmp	r3, r1
 800023c:	d374      	bcc.n	8000328 <__divsi3+0xf8>
 800023e:	0903      	lsrs	r3, r0, #4
 8000240:	428b      	cmp	r3, r1
 8000242:	d35f      	bcc.n	8000304 <__divsi3+0xd4>
 8000244:	0a03      	lsrs	r3, r0, #8
 8000246:	428b      	cmp	r3, r1
 8000248:	d344      	bcc.n	80002d4 <__divsi3+0xa4>
 800024a:	0b03      	lsrs	r3, r0, #12
 800024c:	428b      	cmp	r3, r1
 800024e:	d328      	bcc.n	80002a2 <__divsi3+0x72>
 8000250:	0c03      	lsrs	r3, r0, #16
 8000252:	428b      	cmp	r3, r1
 8000254:	d30d      	bcc.n	8000272 <__divsi3+0x42>
 8000256:	22ff      	movs	r2, #255	; 0xff
 8000258:	0209      	lsls	r1, r1, #8
 800025a:	ba12      	rev	r2, r2
 800025c:	0c03      	lsrs	r3, r0, #16
 800025e:	428b      	cmp	r3, r1
 8000260:	d302      	bcc.n	8000268 <__divsi3+0x38>
 8000262:	1212      	asrs	r2, r2, #8
 8000264:	0209      	lsls	r1, r1, #8
 8000266:	d065      	beq.n	8000334 <__divsi3+0x104>
 8000268:	0b03      	lsrs	r3, r0, #12
 800026a:	428b      	cmp	r3, r1
 800026c:	d319      	bcc.n	80002a2 <__divsi3+0x72>
 800026e:	e000      	b.n	8000272 <__divsi3+0x42>
 8000270:	0a09      	lsrs	r1, r1, #8
 8000272:	0bc3      	lsrs	r3, r0, #15
 8000274:	428b      	cmp	r3, r1
 8000276:	d301      	bcc.n	800027c <__divsi3+0x4c>
 8000278:	03cb      	lsls	r3, r1, #15
 800027a:	1ac0      	subs	r0, r0, r3
 800027c:	4152      	adcs	r2, r2
 800027e:	0b83      	lsrs	r3, r0, #14
 8000280:	428b      	cmp	r3, r1
 8000282:	d301      	bcc.n	8000288 <__divsi3+0x58>
 8000284:	038b      	lsls	r3, r1, #14
 8000286:	1ac0      	subs	r0, r0, r3
 8000288:	4152      	adcs	r2, r2
 800028a:	0b43      	lsrs	r3, r0, #13
 800028c:	428b      	cmp	r3, r1
 800028e:	d301      	bcc.n	8000294 <__divsi3+0x64>
 8000290:	034b      	lsls	r3, r1, #13
 8000292:	1ac0      	subs	r0, r0, r3
 8000294:	4152      	adcs	r2, r2
 8000296:	0b03      	lsrs	r3, r0, #12
 8000298:	428b      	cmp	r3, r1
 800029a:	d301      	bcc.n	80002a0 <__divsi3+0x70>
 800029c:	030b      	lsls	r3, r1, #12
 800029e:	1ac0      	subs	r0, r0, r3
 80002a0:	4152      	adcs	r2, r2
 80002a2:	0ac3      	lsrs	r3, r0, #11
 80002a4:	428b      	cmp	r3, r1
 80002a6:	d301      	bcc.n	80002ac <__divsi3+0x7c>
 80002a8:	02cb      	lsls	r3, r1, #11
 80002aa:	1ac0      	subs	r0, r0, r3
 80002ac:	4152      	adcs	r2, r2
 80002ae:	0a83      	lsrs	r3, r0, #10
 80002b0:	428b      	cmp	r3, r1
 80002b2:	d301      	bcc.n	80002b8 <__divsi3+0x88>
 80002b4:	028b      	lsls	r3, r1, #10
 80002b6:	1ac0      	subs	r0, r0, r3
 80002b8:	4152      	adcs	r2, r2
 80002ba:	0a43      	lsrs	r3, r0, #9
 80002bc:	428b      	cmp	r3, r1
 80002be:	d301      	bcc.n	80002c4 <__divsi3+0x94>
 80002c0:	024b      	lsls	r3, r1, #9
 80002c2:	1ac0      	subs	r0, r0, r3
 80002c4:	4152      	adcs	r2, r2
 80002c6:	0a03      	lsrs	r3, r0, #8
 80002c8:	428b      	cmp	r3, r1
 80002ca:	d301      	bcc.n	80002d0 <__divsi3+0xa0>
 80002cc:	020b      	lsls	r3, r1, #8
 80002ce:	1ac0      	subs	r0, r0, r3
 80002d0:	4152      	adcs	r2, r2
 80002d2:	d2cd      	bcs.n	8000270 <__divsi3+0x40>
 80002d4:	09c3      	lsrs	r3, r0, #7
 80002d6:	428b      	cmp	r3, r1
 80002d8:	d301      	bcc.n	80002de <__divsi3+0xae>
 80002da:	01cb      	lsls	r3, r1, #7
 80002dc:	1ac0      	subs	r0, r0, r3
 80002de:	4152      	adcs	r2, r2
 80002e0:	0983      	lsrs	r3, r0, #6
 80002e2:	428b      	cmp	r3, r1
 80002e4:	d301      	bcc.n	80002ea <__divsi3+0xba>
 80002e6:	018b      	lsls	r3, r1, #6
 80002e8:	1ac0      	subs	r0, r0, r3
 80002ea:	4152      	adcs	r2, r2
 80002ec:	0943      	lsrs	r3, r0, #5
 80002ee:	428b      	cmp	r3, r1
 80002f0:	d301      	bcc.n	80002f6 <__divsi3+0xc6>
 80002f2:	014b      	lsls	r3, r1, #5
 80002f4:	1ac0      	subs	r0, r0, r3
 80002f6:	4152      	adcs	r2, r2
 80002f8:	0903      	lsrs	r3, r0, #4
 80002fa:	428b      	cmp	r3, r1
 80002fc:	d301      	bcc.n	8000302 <__divsi3+0xd2>
 80002fe:	010b      	lsls	r3, r1, #4
 8000300:	1ac0      	subs	r0, r0, r3
 8000302:	4152      	adcs	r2, r2
 8000304:	08c3      	lsrs	r3, r0, #3
 8000306:	428b      	cmp	r3, r1
 8000308:	d301      	bcc.n	800030e <__divsi3+0xde>
 800030a:	00cb      	lsls	r3, r1, #3
 800030c:	1ac0      	subs	r0, r0, r3
 800030e:	4152      	adcs	r2, r2
 8000310:	0883      	lsrs	r3, r0, #2
 8000312:	428b      	cmp	r3, r1
 8000314:	d301      	bcc.n	800031a <__divsi3+0xea>
 8000316:	008b      	lsls	r3, r1, #2
 8000318:	1ac0      	subs	r0, r0, r3
 800031a:	4152      	adcs	r2, r2
 800031c:	0843      	lsrs	r3, r0, #1
 800031e:	428b      	cmp	r3, r1
 8000320:	d301      	bcc.n	8000326 <__divsi3+0xf6>
 8000322:	004b      	lsls	r3, r1, #1
 8000324:	1ac0      	subs	r0, r0, r3
 8000326:	4152      	adcs	r2, r2
 8000328:	1a41      	subs	r1, r0, r1
 800032a:	d200      	bcs.n	800032e <__divsi3+0xfe>
 800032c:	4601      	mov	r1, r0
 800032e:	4152      	adcs	r2, r2
 8000330:	4610      	mov	r0, r2
 8000332:	4770      	bx	lr
 8000334:	e05d      	b.n	80003f2 <__divsi3+0x1c2>
 8000336:	0fca      	lsrs	r2, r1, #31
 8000338:	d000      	beq.n	800033c <__divsi3+0x10c>
 800033a:	4249      	negs	r1, r1
 800033c:	1003      	asrs	r3, r0, #32
 800033e:	d300      	bcc.n	8000342 <__divsi3+0x112>
 8000340:	4240      	negs	r0, r0
 8000342:	4053      	eors	r3, r2
 8000344:	2200      	movs	r2, #0
 8000346:	469c      	mov	ip, r3
 8000348:	0903      	lsrs	r3, r0, #4
 800034a:	428b      	cmp	r3, r1
 800034c:	d32d      	bcc.n	80003aa <__divsi3+0x17a>
 800034e:	0a03      	lsrs	r3, r0, #8
 8000350:	428b      	cmp	r3, r1
 8000352:	d312      	bcc.n	800037a <__divsi3+0x14a>
 8000354:	22fc      	movs	r2, #252	; 0xfc
 8000356:	0189      	lsls	r1, r1, #6
 8000358:	ba12      	rev	r2, r2
 800035a:	0a03      	lsrs	r3, r0, #8
 800035c:	428b      	cmp	r3, r1
 800035e:	d30c      	bcc.n	800037a <__divsi3+0x14a>
 8000360:	0189      	lsls	r1, r1, #6
 8000362:	1192      	asrs	r2, r2, #6
 8000364:	428b      	cmp	r3, r1
 8000366:	d308      	bcc.n	800037a <__divsi3+0x14a>
 8000368:	0189      	lsls	r1, r1, #6
 800036a:	1192      	asrs	r2, r2, #6
 800036c:	428b      	cmp	r3, r1
 800036e:	d304      	bcc.n	800037a <__divsi3+0x14a>
 8000370:	0189      	lsls	r1, r1, #6
 8000372:	d03a      	beq.n	80003ea <__divsi3+0x1ba>
 8000374:	1192      	asrs	r2, r2, #6
 8000376:	e000      	b.n	800037a <__divsi3+0x14a>
 8000378:	0989      	lsrs	r1, r1, #6
 800037a:	09c3      	lsrs	r3, r0, #7
 800037c:	428b      	cmp	r3, r1
 800037e:	d301      	bcc.n	8000384 <__divsi3+0x154>
 8000380:	01cb      	lsls	r3, r1, #7
 8000382:	1ac0      	subs	r0, r0, r3
 8000384:	4152      	adcs	r2, r2
 8000386:	0983      	lsrs	r3, r0, #6
 8000388:	428b      	cmp	r3, r1
 800038a:	d301      	bcc.n	8000390 <__divsi3+0x160>
 800038c:	018b      	lsls	r3, r1, #6
 800038e:	1ac0      	subs	r0, r0, r3
 8000390:	4152      	adcs	r2, r2
 8000392:	0943      	lsrs	r3, r0, #5
 8000394:	428b      	cmp	r3, r1
 8000396:	d301      	bcc.n	800039c <__divsi3+0x16c>
 8000398:	014b      	lsls	r3, r1, #5
 800039a:	1ac0      	subs	r0, r0, r3
 800039c:	4152      	adcs	r2, r2
 800039e:	0903      	lsrs	r3, r0, #4
 80003a0:	428b      	cmp	r3, r1
 80003a2:	d301      	bcc.n	80003a8 <__divsi3+0x178>
 80003a4:	010b      	lsls	r3, r1, #4
 80003a6:	1ac0      	subs	r0, r0, r3
 80003a8:	4152      	adcs	r2, r2
 80003aa:	08c3      	lsrs	r3, r0, #3
 80003ac:	428b      	cmp	r3, r1
 80003ae:	d301      	bcc.n	80003b4 <__divsi3+0x184>
 80003b0:	00cb      	lsls	r3, r1, #3
 80003b2:	1ac0      	subs	r0, r0, r3
 80003b4:	4152      	adcs	r2, r2
 80003b6:	0883      	lsrs	r3, r0, #2
 80003b8:	428b      	cmp	r3, r1
 80003ba:	d301      	bcc.n	80003c0 <__divsi3+0x190>
 80003bc:	008b      	lsls	r3, r1, #2
 80003be:	1ac0      	subs	r0, r0, r3
 80003c0:	4152      	adcs	r2, r2
 80003c2:	d2d9      	bcs.n	8000378 <__divsi3+0x148>
 80003c4:	0843      	lsrs	r3, r0, #1
 80003c6:	428b      	cmp	r3, r1
 80003c8:	d301      	bcc.n	80003ce <__divsi3+0x19e>
 80003ca:	004b      	lsls	r3, r1, #1
 80003cc:	1ac0      	subs	r0, r0, r3
 80003ce:	4152      	adcs	r2, r2
 80003d0:	1a41      	subs	r1, r0, r1
 80003d2:	d200      	bcs.n	80003d6 <__divsi3+0x1a6>
 80003d4:	4601      	mov	r1, r0
 80003d6:	4663      	mov	r3, ip
 80003d8:	4152      	adcs	r2, r2
 80003da:	105b      	asrs	r3, r3, #1
 80003dc:	4610      	mov	r0, r2
 80003de:	d301      	bcc.n	80003e4 <__divsi3+0x1b4>
 80003e0:	4240      	negs	r0, r0
 80003e2:	2b00      	cmp	r3, #0
 80003e4:	d500      	bpl.n	80003e8 <__divsi3+0x1b8>
 80003e6:	4249      	negs	r1, r1
 80003e8:	4770      	bx	lr
 80003ea:	4663      	mov	r3, ip
 80003ec:	105b      	asrs	r3, r3, #1
 80003ee:	d300      	bcc.n	80003f2 <__divsi3+0x1c2>
 80003f0:	4240      	negs	r0, r0
 80003f2:	b501      	push	{r0, lr}
 80003f4:	2000      	movs	r0, #0
 80003f6:	f000 f805 	bl	8000404 <__aeabi_idiv0>
 80003fa:	bd02      	pop	{r1, pc}

080003fc <__aeabi_idivmod>:
 80003fc:	2900      	cmp	r1, #0
 80003fe:	d0f8      	beq.n	80003f2 <__divsi3+0x1c2>
 8000400:	e716      	b.n	8000230 <__divsi3>
 8000402:	4770      	bx	lr

08000404 <__aeabi_idiv0>:
 8000404:	4770      	bx	lr
 8000406:	46c0      	nop			; (mov r8, r8)

08000408 <__aeabi_cdrcmple>:
 8000408:	4684      	mov	ip, r0
 800040a:	1c10      	adds	r0, r2, #0
 800040c:	4662      	mov	r2, ip
 800040e:	468c      	mov	ip, r1
 8000410:	1c19      	adds	r1, r3, #0
 8000412:	4663      	mov	r3, ip
 8000414:	e000      	b.n	8000418 <__aeabi_cdcmpeq>
 8000416:	46c0      	nop			; (mov r8, r8)

08000418 <__aeabi_cdcmpeq>:
 8000418:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800041a:	f001 ff79 	bl	8002310 <__ledf2>
 800041e:	2800      	cmp	r0, #0
 8000420:	d401      	bmi.n	8000426 <__aeabi_cdcmpeq+0xe>
 8000422:	2100      	movs	r1, #0
 8000424:	42c8      	cmn	r0, r1
 8000426:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08000428 <__aeabi_dcmpeq>:
 8000428:	b510      	push	{r4, lr}
 800042a:	f001 fec3 	bl	80021b4 <__eqdf2>
 800042e:	4240      	negs	r0, r0
 8000430:	3001      	adds	r0, #1
 8000432:	bd10      	pop	{r4, pc}

08000434 <__aeabi_dcmplt>:
 8000434:	b510      	push	{r4, lr}
 8000436:	f001 ff6b 	bl	8002310 <__ledf2>
 800043a:	2800      	cmp	r0, #0
 800043c:	db01      	blt.n	8000442 <__aeabi_dcmplt+0xe>
 800043e:	2000      	movs	r0, #0
 8000440:	bd10      	pop	{r4, pc}
 8000442:	2001      	movs	r0, #1
 8000444:	bd10      	pop	{r4, pc}
 8000446:	46c0      	nop			; (mov r8, r8)

08000448 <__aeabi_dcmple>:
 8000448:	b510      	push	{r4, lr}
 800044a:	f001 ff61 	bl	8002310 <__ledf2>
 800044e:	2800      	cmp	r0, #0
 8000450:	dd01      	ble.n	8000456 <__aeabi_dcmple+0xe>
 8000452:	2000      	movs	r0, #0
 8000454:	bd10      	pop	{r4, pc}
 8000456:	2001      	movs	r0, #1
 8000458:	bd10      	pop	{r4, pc}
 800045a:	46c0      	nop			; (mov r8, r8)

0800045c <__aeabi_dcmpgt>:
 800045c:	b510      	push	{r4, lr}
 800045e:	f001 fee5 	bl	800222c <__gedf2>
 8000462:	2800      	cmp	r0, #0
 8000464:	dc01      	bgt.n	800046a <__aeabi_dcmpgt+0xe>
 8000466:	2000      	movs	r0, #0
 8000468:	bd10      	pop	{r4, pc}
 800046a:	2001      	movs	r0, #1
 800046c:	bd10      	pop	{r4, pc}
 800046e:	46c0      	nop			; (mov r8, r8)

08000470 <__aeabi_dcmpge>:
 8000470:	b510      	push	{r4, lr}
 8000472:	f001 fedb 	bl	800222c <__gedf2>
 8000476:	2800      	cmp	r0, #0
 8000478:	da01      	bge.n	800047e <__aeabi_dcmpge+0xe>
 800047a:	2000      	movs	r0, #0
 800047c:	bd10      	pop	{r4, pc}
 800047e:	2001      	movs	r0, #1
 8000480:	bd10      	pop	{r4, pc}
 8000482:	46c0      	nop			; (mov r8, r8)

08000484 <__aeabi_cfrcmple>:
 8000484:	4684      	mov	ip, r0
 8000486:	1c08      	adds	r0, r1, #0
 8000488:	4661      	mov	r1, ip
 800048a:	e7ff      	b.n	800048c <__aeabi_cfcmpeq>

0800048c <__aeabi_cfcmpeq>:
 800048c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800048e:	f000 fc71 	bl	8000d74 <__lesf2>
 8000492:	2800      	cmp	r0, #0
 8000494:	d401      	bmi.n	800049a <__aeabi_cfcmpeq+0xe>
 8000496:	2100      	movs	r1, #0
 8000498:	42c8      	cmn	r0, r1
 800049a:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

0800049c <__aeabi_fcmpeq>:
 800049c:	b510      	push	{r4, lr}
 800049e:	f000 fbf5 	bl	8000c8c <__eqsf2>
 80004a2:	4240      	negs	r0, r0
 80004a4:	3001      	adds	r0, #1
 80004a6:	bd10      	pop	{r4, pc}

080004a8 <__aeabi_fcmplt>:
 80004a8:	b510      	push	{r4, lr}
 80004aa:	f000 fc63 	bl	8000d74 <__lesf2>
 80004ae:	2800      	cmp	r0, #0
 80004b0:	db01      	blt.n	80004b6 <__aeabi_fcmplt+0xe>
 80004b2:	2000      	movs	r0, #0
 80004b4:	bd10      	pop	{r4, pc}
 80004b6:	2001      	movs	r0, #1
 80004b8:	bd10      	pop	{r4, pc}
 80004ba:	46c0      	nop			; (mov r8, r8)

080004bc <__aeabi_fcmple>:
 80004bc:	b510      	push	{r4, lr}
 80004be:	f000 fc59 	bl	8000d74 <__lesf2>
 80004c2:	2800      	cmp	r0, #0
 80004c4:	dd01      	ble.n	80004ca <__aeabi_fcmple+0xe>
 80004c6:	2000      	movs	r0, #0
 80004c8:	bd10      	pop	{r4, pc}
 80004ca:	2001      	movs	r0, #1
 80004cc:	bd10      	pop	{r4, pc}
 80004ce:	46c0      	nop			; (mov r8, r8)

080004d0 <__aeabi_fcmpgt>:
 80004d0:	b510      	push	{r4, lr}
 80004d2:	f000 fc03 	bl	8000cdc <__gesf2>
 80004d6:	2800      	cmp	r0, #0
 80004d8:	dc01      	bgt.n	80004de <__aeabi_fcmpgt+0xe>
 80004da:	2000      	movs	r0, #0
 80004dc:	bd10      	pop	{r4, pc}
 80004de:	2001      	movs	r0, #1
 80004e0:	bd10      	pop	{r4, pc}
 80004e2:	46c0      	nop			; (mov r8, r8)

080004e4 <__aeabi_fcmpge>:
 80004e4:	b510      	push	{r4, lr}
 80004e6:	f000 fbf9 	bl	8000cdc <__gesf2>
 80004ea:	2800      	cmp	r0, #0
 80004ec:	da01      	bge.n	80004f2 <__aeabi_fcmpge+0xe>
 80004ee:	2000      	movs	r0, #0
 80004f0:	bd10      	pop	{r4, pc}
 80004f2:	2001      	movs	r0, #1
 80004f4:	bd10      	pop	{r4, pc}
 80004f6:	46c0      	nop			; (mov r8, r8)

080004f8 <__aeabi_uldivmod>:
 80004f8:	2b00      	cmp	r3, #0
 80004fa:	d111      	bne.n	8000520 <__aeabi_uldivmod+0x28>
 80004fc:	2a00      	cmp	r2, #0
 80004fe:	d10f      	bne.n	8000520 <__aeabi_uldivmod+0x28>
 8000500:	2900      	cmp	r1, #0
 8000502:	d100      	bne.n	8000506 <__aeabi_uldivmod+0xe>
 8000504:	2800      	cmp	r0, #0
 8000506:	d002      	beq.n	800050e <__aeabi_uldivmod+0x16>
 8000508:	2100      	movs	r1, #0
 800050a:	43c9      	mvns	r1, r1
 800050c:	1c08      	adds	r0, r1, #0
 800050e:	b407      	push	{r0, r1, r2}
 8000510:	4802      	ldr	r0, [pc, #8]	; (800051c <__aeabi_uldivmod+0x24>)
 8000512:	a102      	add	r1, pc, #8	; (adr r1, 800051c <__aeabi_uldivmod+0x24>)
 8000514:	1840      	adds	r0, r0, r1
 8000516:	9002      	str	r0, [sp, #8]
 8000518:	bd03      	pop	{r0, r1, pc}
 800051a:	46c0      	nop			; (mov r8, r8)
 800051c:	fffffee9 	.word	0xfffffee9
 8000520:	b403      	push	{r0, r1}
 8000522:	4668      	mov	r0, sp
 8000524:	b501      	push	{r0, lr}
 8000526:	9802      	ldr	r0, [sp, #8]
 8000528:	f000 f83c 	bl	80005a4 <__udivmoddi4>
 800052c:	9b01      	ldr	r3, [sp, #4]
 800052e:	469e      	mov	lr, r3
 8000530:	b002      	add	sp, #8
 8000532:	bc0c      	pop	{r2, r3}
 8000534:	4770      	bx	lr
 8000536:	46c0      	nop			; (mov r8, r8)

08000538 <__aeabi_f2uiz>:
 8000538:	219e      	movs	r1, #158	; 0x9e
 800053a:	b510      	push	{r4, lr}
 800053c:	05c9      	lsls	r1, r1, #23
 800053e:	1c04      	adds	r4, r0, #0
 8000540:	f7ff ffd0 	bl	80004e4 <__aeabi_fcmpge>
 8000544:	2800      	cmp	r0, #0
 8000546:	d103      	bne.n	8000550 <__aeabi_f2uiz+0x18>
 8000548:	1c20      	adds	r0, r4, #0
 800054a:	f000 ff3f 	bl	80013cc <__aeabi_f2iz>
 800054e:	bd10      	pop	{r4, pc}
 8000550:	219e      	movs	r1, #158	; 0x9e
 8000552:	1c20      	adds	r0, r4, #0
 8000554:	05c9      	lsls	r1, r1, #23
 8000556:	f000 fd71 	bl	800103c <__aeabi_fsub>
 800055a:	f000 ff37 	bl	80013cc <__aeabi_f2iz>
 800055e:	2380      	movs	r3, #128	; 0x80
 8000560:	061b      	lsls	r3, r3, #24
 8000562:	469c      	mov	ip, r3
 8000564:	4460      	add	r0, ip
 8000566:	e7f2      	b.n	800054e <__aeabi_f2uiz+0x16>

08000568 <__aeabi_d2uiz>:
 8000568:	b570      	push	{r4, r5, r6, lr}
 800056a:	2200      	movs	r2, #0
 800056c:	4b0c      	ldr	r3, [pc, #48]	; (80005a0 <__aeabi_d2uiz+0x38>)
 800056e:	0004      	movs	r4, r0
 8000570:	000d      	movs	r5, r1
 8000572:	f7ff ff7d 	bl	8000470 <__aeabi_dcmpge>
 8000576:	2800      	cmp	r0, #0
 8000578:	d104      	bne.n	8000584 <__aeabi_d2uiz+0x1c>
 800057a:	0020      	movs	r0, r4
 800057c:	0029      	movs	r1, r5
 800057e:	f002 fd35 	bl	8002fec <__aeabi_d2iz>
 8000582:	bd70      	pop	{r4, r5, r6, pc}
 8000584:	4b06      	ldr	r3, [pc, #24]	; (80005a0 <__aeabi_d2uiz+0x38>)
 8000586:	2200      	movs	r2, #0
 8000588:	0020      	movs	r0, r4
 800058a:	0029      	movs	r1, r5
 800058c:	f002 f99c 	bl	80028c8 <__aeabi_dsub>
 8000590:	f002 fd2c 	bl	8002fec <__aeabi_d2iz>
 8000594:	2380      	movs	r3, #128	; 0x80
 8000596:	061b      	lsls	r3, r3, #24
 8000598:	469c      	mov	ip, r3
 800059a:	4460      	add	r0, ip
 800059c:	e7f1      	b.n	8000582 <__aeabi_d2uiz+0x1a>
 800059e:	46c0      	nop			; (mov r8, r8)
 80005a0:	41e00000 	.word	0x41e00000

080005a4 <__udivmoddi4>:
 80005a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80005a6:	4657      	mov	r7, sl
 80005a8:	464e      	mov	r6, r9
 80005aa:	4645      	mov	r5, r8
 80005ac:	46de      	mov	lr, fp
 80005ae:	b5e0      	push	{r5, r6, r7, lr}
 80005b0:	0004      	movs	r4, r0
 80005b2:	000d      	movs	r5, r1
 80005b4:	4692      	mov	sl, r2
 80005b6:	4699      	mov	r9, r3
 80005b8:	b083      	sub	sp, #12
 80005ba:	428b      	cmp	r3, r1
 80005bc:	d830      	bhi.n	8000620 <__udivmoddi4+0x7c>
 80005be:	d02d      	beq.n	800061c <__udivmoddi4+0x78>
 80005c0:	4649      	mov	r1, r9
 80005c2:	4650      	mov	r0, sl
 80005c4:	f002 fe04 	bl	80031d0 <__clzdi2>
 80005c8:	0029      	movs	r1, r5
 80005ca:	0006      	movs	r6, r0
 80005cc:	0020      	movs	r0, r4
 80005ce:	f002 fdff 	bl	80031d0 <__clzdi2>
 80005d2:	1a33      	subs	r3, r6, r0
 80005d4:	4698      	mov	r8, r3
 80005d6:	3b20      	subs	r3, #32
 80005d8:	469b      	mov	fp, r3
 80005da:	d433      	bmi.n	8000644 <__udivmoddi4+0xa0>
 80005dc:	465a      	mov	r2, fp
 80005de:	4653      	mov	r3, sl
 80005e0:	4093      	lsls	r3, r2
 80005e2:	4642      	mov	r2, r8
 80005e4:	001f      	movs	r7, r3
 80005e6:	4653      	mov	r3, sl
 80005e8:	4093      	lsls	r3, r2
 80005ea:	001e      	movs	r6, r3
 80005ec:	42af      	cmp	r7, r5
 80005ee:	d83a      	bhi.n	8000666 <__udivmoddi4+0xc2>
 80005f0:	42af      	cmp	r7, r5
 80005f2:	d100      	bne.n	80005f6 <__udivmoddi4+0x52>
 80005f4:	e078      	b.n	80006e8 <__udivmoddi4+0x144>
 80005f6:	465b      	mov	r3, fp
 80005f8:	1ba4      	subs	r4, r4, r6
 80005fa:	41bd      	sbcs	r5, r7
 80005fc:	2b00      	cmp	r3, #0
 80005fe:	da00      	bge.n	8000602 <__udivmoddi4+0x5e>
 8000600:	e075      	b.n	80006ee <__udivmoddi4+0x14a>
 8000602:	2200      	movs	r2, #0
 8000604:	2300      	movs	r3, #0
 8000606:	9200      	str	r2, [sp, #0]
 8000608:	9301      	str	r3, [sp, #4]
 800060a:	2301      	movs	r3, #1
 800060c:	465a      	mov	r2, fp
 800060e:	4093      	lsls	r3, r2
 8000610:	9301      	str	r3, [sp, #4]
 8000612:	2301      	movs	r3, #1
 8000614:	4642      	mov	r2, r8
 8000616:	4093      	lsls	r3, r2
 8000618:	9300      	str	r3, [sp, #0]
 800061a:	e028      	b.n	800066e <__udivmoddi4+0xca>
 800061c:	4282      	cmp	r2, r0
 800061e:	d9cf      	bls.n	80005c0 <__udivmoddi4+0x1c>
 8000620:	2200      	movs	r2, #0
 8000622:	2300      	movs	r3, #0
 8000624:	9200      	str	r2, [sp, #0]
 8000626:	9301      	str	r3, [sp, #4]
 8000628:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800062a:	2b00      	cmp	r3, #0
 800062c:	d001      	beq.n	8000632 <__udivmoddi4+0x8e>
 800062e:	601c      	str	r4, [r3, #0]
 8000630:	605d      	str	r5, [r3, #4]
 8000632:	9800      	ldr	r0, [sp, #0]
 8000634:	9901      	ldr	r1, [sp, #4]
 8000636:	b003      	add	sp, #12
 8000638:	bcf0      	pop	{r4, r5, r6, r7}
 800063a:	46bb      	mov	fp, r7
 800063c:	46b2      	mov	sl, r6
 800063e:	46a9      	mov	r9, r5
 8000640:	46a0      	mov	r8, r4
 8000642:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000644:	4642      	mov	r2, r8
 8000646:	2320      	movs	r3, #32
 8000648:	1a9b      	subs	r3, r3, r2
 800064a:	4652      	mov	r2, sl
 800064c:	40da      	lsrs	r2, r3
 800064e:	4641      	mov	r1, r8
 8000650:	0013      	movs	r3, r2
 8000652:	464a      	mov	r2, r9
 8000654:	408a      	lsls	r2, r1
 8000656:	0017      	movs	r7, r2
 8000658:	4642      	mov	r2, r8
 800065a:	431f      	orrs	r7, r3
 800065c:	4653      	mov	r3, sl
 800065e:	4093      	lsls	r3, r2
 8000660:	001e      	movs	r6, r3
 8000662:	42af      	cmp	r7, r5
 8000664:	d9c4      	bls.n	80005f0 <__udivmoddi4+0x4c>
 8000666:	2200      	movs	r2, #0
 8000668:	2300      	movs	r3, #0
 800066a:	9200      	str	r2, [sp, #0]
 800066c:	9301      	str	r3, [sp, #4]
 800066e:	4643      	mov	r3, r8
 8000670:	2b00      	cmp	r3, #0
 8000672:	d0d9      	beq.n	8000628 <__udivmoddi4+0x84>
 8000674:	07fb      	lsls	r3, r7, #31
 8000676:	0872      	lsrs	r2, r6, #1
 8000678:	431a      	orrs	r2, r3
 800067a:	4646      	mov	r6, r8
 800067c:	087b      	lsrs	r3, r7, #1
 800067e:	e00e      	b.n	800069e <__udivmoddi4+0xfa>
 8000680:	42ab      	cmp	r3, r5
 8000682:	d101      	bne.n	8000688 <__udivmoddi4+0xe4>
 8000684:	42a2      	cmp	r2, r4
 8000686:	d80c      	bhi.n	80006a2 <__udivmoddi4+0xfe>
 8000688:	1aa4      	subs	r4, r4, r2
 800068a:	419d      	sbcs	r5, r3
 800068c:	2001      	movs	r0, #1
 800068e:	1924      	adds	r4, r4, r4
 8000690:	416d      	adcs	r5, r5
 8000692:	2100      	movs	r1, #0
 8000694:	3e01      	subs	r6, #1
 8000696:	1824      	adds	r4, r4, r0
 8000698:	414d      	adcs	r5, r1
 800069a:	2e00      	cmp	r6, #0
 800069c:	d006      	beq.n	80006ac <__udivmoddi4+0x108>
 800069e:	42ab      	cmp	r3, r5
 80006a0:	d9ee      	bls.n	8000680 <__udivmoddi4+0xdc>
 80006a2:	3e01      	subs	r6, #1
 80006a4:	1924      	adds	r4, r4, r4
 80006a6:	416d      	adcs	r5, r5
 80006a8:	2e00      	cmp	r6, #0
 80006aa:	d1f8      	bne.n	800069e <__udivmoddi4+0xfa>
 80006ac:	9800      	ldr	r0, [sp, #0]
 80006ae:	9901      	ldr	r1, [sp, #4]
 80006b0:	465b      	mov	r3, fp
 80006b2:	1900      	adds	r0, r0, r4
 80006b4:	4169      	adcs	r1, r5
 80006b6:	2b00      	cmp	r3, #0
 80006b8:	db24      	blt.n	8000704 <__udivmoddi4+0x160>
 80006ba:	002b      	movs	r3, r5
 80006bc:	465a      	mov	r2, fp
 80006be:	4644      	mov	r4, r8
 80006c0:	40d3      	lsrs	r3, r2
 80006c2:	002a      	movs	r2, r5
 80006c4:	40e2      	lsrs	r2, r4
 80006c6:	001c      	movs	r4, r3
 80006c8:	465b      	mov	r3, fp
 80006ca:	0015      	movs	r5, r2
 80006cc:	2b00      	cmp	r3, #0
 80006ce:	db2a      	blt.n	8000726 <__udivmoddi4+0x182>
 80006d0:	0026      	movs	r6, r4
 80006d2:	409e      	lsls	r6, r3
 80006d4:	0033      	movs	r3, r6
 80006d6:	0026      	movs	r6, r4
 80006d8:	4647      	mov	r7, r8
 80006da:	40be      	lsls	r6, r7
 80006dc:	0032      	movs	r2, r6
 80006de:	1a80      	subs	r0, r0, r2
 80006e0:	4199      	sbcs	r1, r3
 80006e2:	9000      	str	r0, [sp, #0]
 80006e4:	9101      	str	r1, [sp, #4]
 80006e6:	e79f      	b.n	8000628 <__udivmoddi4+0x84>
 80006e8:	42a3      	cmp	r3, r4
 80006ea:	d8bc      	bhi.n	8000666 <__udivmoddi4+0xc2>
 80006ec:	e783      	b.n	80005f6 <__udivmoddi4+0x52>
 80006ee:	4642      	mov	r2, r8
 80006f0:	2320      	movs	r3, #32
 80006f2:	2100      	movs	r1, #0
 80006f4:	1a9b      	subs	r3, r3, r2
 80006f6:	2200      	movs	r2, #0
 80006f8:	9100      	str	r1, [sp, #0]
 80006fa:	9201      	str	r2, [sp, #4]
 80006fc:	2201      	movs	r2, #1
 80006fe:	40da      	lsrs	r2, r3
 8000700:	9201      	str	r2, [sp, #4]
 8000702:	e786      	b.n	8000612 <__udivmoddi4+0x6e>
 8000704:	4642      	mov	r2, r8
 8000706:	2320      	movs	r3, #32
 8000708:	1a9b      	subs	r3, r3, r2
 800070a:	002a      	movs	r2, r5
 800070c:	4646      	mov	r6, r8
 800070e:	409a      	lsls	r2, r3
 8000710:	0023      	movs	r3, r4
 8000712:	40f3      	lsrs	r3, r6
 8000714:	4644      	mov	r4, r8
 8000716:	4313      	orrs	r3, r2
 8000718:	002a      	movs	r2, r5
 800071a:	40e2      	lsrs	r2, r4
 800071c:	001c      	movs	r4, r3
 800071e:	465b      	mov	r3, fp
 8000720:	0015      	movs	r5, r2
 8000722:	2b00      	cmp	r3, #0
 8000724:	dad4      	bge.n	80006d0 <__udivmoddi4+0x12c>
 8000726:	4642      	mov	r2, r8
 8000728:	002f      	movs	r7, r5
 800072a:	2320      	movs	r3, #32
 800072c:	0026      	movs	r6, r4
 800072e:	4097      	lsls	r7, r2
 8000730:	1a9b      	subs	r3, r3, r2
 8000732:	40de      	lsrs	r6, r3
 8000734:	003b      	movs	r3, r7
 8000736:	4333      	orrs	r3, r6
 8000738:	e7cd      	b.n	80006d6 <__udivmoddi4+0x132>
 800073a:	46c0      	nop			; (mov r8, r8)

0800073c <__aeabi_fadd>:
 800073c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800073e:	4646      	mov	r6, r8
 8000740:	46d6      	mov	lr, sl
 8000742:	464f      	mov	r7, r9
 8000744:	024d      	lsls	r5, r1, #9
 8000746:	0242      	lsls	r2, r0, #9
 8000748:	b5c0      	push	{r6, r7, lr}
 800074a:	0a52      	lsrs	r2, r2, #9
 800074c:	0a6e      	lsrs	r6, r5, #9
 800074e:	0047      	lsls	r7, r0, #1
 8000750:	46b0      	mov	r8, r6
 8000752:	0e3f      	lsrs	r7, r7, #24
 8000754:	004e      	lsls	r6, r1, #1
 8000756:	0fc4      	lsrs	r4, r0, #31
 8000758:	00d0      	lsls	r0, r2, #3
 800075a:	4694      	mov	ip, r2
 800075c:	003b      	movs	r3, r7
 800075e:	4682      	mov	sl, r0
 8000760:	0e36      	lsrs	r6, r6, #24
 8000762:	0fc9      	lsrs	r1, r1, #31
 8000764:	09ad      	lsrs	r5, r5, #6
 8000766:	428c      	cmp	r4, r1
 8000768:	d06d      	beq.n	8000846 <__aeabi_fadd+0x10a>
 800076a:	1bb8      	subs	r0, r7, r6
 800076c:	4681      	mov	r9, r0
 800076e:	2800      	cmp	r0, #0
 8000770:	dd4d      	ble.n	800080e <__aeabi_fadd+0xd2>
 8000772:	2e00      	cmp	r6, #0
 8000774:	d100      	bne.n	8000778 <__aeabi_fadd+0x3c>
 8000776:	e088      	b.n	800088a <__aeabi_fadd+0x14e>
 8000778:	2fff      	cmp	r7, #255	; 0xff
 800077a:	d05a      	beq.n	8000832 <__aeabi_fadd+0xf6>
 800077c:	2380      	movs	r3, #128	; 0x80
 800077e:	04db      	lsls	r3, r3, #19
 8000780:	431d      	orrs	r5, r3
 8000782:	464b      	mov	r3, r9
 8000784:	2201      	movs	r2, #1
 8000786:	2b1b      	cmp	r3, #27
 8000788:	dc0a      	bgt.n	80007a0 <__aeabi_fadd+0x64>
 800078a:	002b      	movs	r3, r5
 800078c:	464a      	mov	r2, r9
 800078e:	4649      	mov	r1, r9
 8000790:	40d3      	lsrs	r3, r2
 8000792:	2220      	movs	r2, #32
 8000794:	1a52      	subs	r2, r2, r1
 8000796:	4095      	lsls	r5, r2
 8000798:	002a      	movs	r2, r5
 800079a:	1e55      	subs	r5, r2, #1
 800079c:	41aa      	sbcs	r2, r5
 800079e:	431a      	orrs	r2, r3
 80007a0:	4653      	mov	r3, sl
 80007a2:	1a9a      	subs	r2, r3, r2
 80007a4:	0153      	lsls	r3, r2, #5
 80007a6:	d400      	bmi.n	80007aa <__aeabi_fadd+0x6e>
 80007a8:	e0b9      	b.n	800091e <__aeabi_fadd+0x1e2>
 80007aa:	0192      	lsls	r2, r2, #6
 80007ac:	0996      	lsrs	r6, r2, #6
 80007ae:	0030      	movs	r0, r6
 80007b0:	f002 fcf0 	bl	8003194 <__clzsi2>
 80007b4:	3805      	subs	r0, #5
 80007b6:	4086      	lsls	r6, r0
 80007b8:	4287      	cmp	r7, r0
 80007ba:	dd00      	ble.n	80007be <__aeabi_fadd+0x82>
 80007bc:	e0d4      	b.n	8000968 <__aeabi_fadd+0x22c>
 80007be:	0033      	movs	r3, r6
 80007c0:	1bc7      	subs	r7, r0, r7
 80007c2:	2020      	movs	r0, #32
 80007c4:	3701      	adds	r7, #1
 80007c6:	40fb      	lsrs	r3, r7
 80007c8:	1bc7      	subs	r7, r0, r7
 80007ca:	40be      	lsls	r6, r7
 80007cc:	0032      	movs	r2, r6
 80007ce:	1e56      	subs	r6, r2, #1
 80007d0:	41b2      	sbcs	r2, r6
 80007d2:	2700      	movs	r7, #0
 80007d4:	431a      	orrs	r2, r3
 80007d6:	0753      	lsls	r3, r2, #29
 80007d8:	d004      	beq.n	80007e4 <__aeabi_fadd+0xa8>
 80007da:	230f      	movs	r3, #15
 80007dc:	4013      	ands	r3, r2
 80007de:	2b04      	cmp	r3, #4
 80007e0:	d000      	beq.n	80007e4 <__aeabi_fadd+0xa8>
 80007e2:	3204      	adds	r2, #4
 80007e4:	0153      	lsls	r3, r2, #5
 80007e6:	d400      	bmi.n	80007ea <__aeabi_fadd+0xae>
 80007e8:	e09c      	b.n	8000924 <__aeabi_fadd+0x1e8>
 80007ea:	1c7b      	adds	r3, r7, #1
 80007ec:	2ffe      	cmp	r7, #254	; 0xfe
 80007ee:	d100      	bne.n	80007f2 <__aeabi_fadd+0xb6>
 80007f0:	e09a      	b.n	8000928 <__aeabi_fadd+0x1ec>
 80007f2:	0192      	lsls	r2, r2, #6
 80007f4:	0a52      	lsrs	r2, r2, #9
 80007f6:	4694      	mov	ip, r2
 80007f8:	b2db      	uxtb	r3, r3
 80007fa:	05d8      	lsls	r0, r3, #23
 80007fc:	4663      	mov	r3, ip
 80007fe:	07e4      	lsls	r4, r4, #31
 8000800:	4318      	orrs	r0, r3
 8000802:	4320      	orrs	r0, r4
 8000804:	bce0      	pop	{r5, r6, r7}
 8000806:	46ba      	mov	sl, r7
 8000808:	46b1      	mov	r9, r6
 800080a:	46a8      	mov	r8, r5
 800080c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800080e:	2800      	cmp	r0, #0
 8000810:	d049      	beq.n	80008a6 <__aeabi_fadd+0x16a>
 8000812:	1bf3      	subs	r3, r6, r7
 8000814:	2f00      	cmp	r7, #0
 8000816:	d000      	beq.n	800081a <__aeabi_fadd+0xde>
 8000818:	e0b6      	b.n	8000988 <__aeabi_fadd+0x24c>
 800081a:	4652      	mov	r2, sl
 800081c:	2a00      	cmp	r2, #0
 800081e:	d060      	beq.n	80008e2 <__aeabi_fadd+0x1a6>
 8000820:	3b01      	subs	r3, #1
 8000822:	2b00      	cmp	r3, #0
 8000824:	d100      	bne.n	8000828 <__aeabi_fadd+0xec>
 8000826:	e0fc      	b.n	8000a22 <__aeabi_fadd+0x2e6>
 8000828:	2eff      	cmp	r6, #255	; 0xff
 800082a:	d000      	beq.n	800082e <__aeabi_fadd+0xf2>
 800082c:	e0b4      	b.n	8000998 <__aeabi_fadd+0x25c>
 800082e:	000c      	movs	r4, r1
 8000830:	4642      	mov	r2, r8
 8000832:	2a00      	cmp	r2, #0
 8000834:	d078      	beq.n	8000928 <__aeabi_fadd+0x1ec>
 8000836:	2080      	movs	r0, #128	; 0x80
 8000838:	03c0      	lsls	r0, r0, #15
 800083a:	4310      	orrs	r0, r2
 800083c:	0242      	lsls	r2, r0, #9
 800083e:	0a53      	lsrs	r3, r2, #9
 8000840:	469c      	mov	ip, r3
 8000842:	23ff      	movs	r3, #255	; 0xff
 8000844:	e7d9      	b.n	80007fa <__aeabi_fadd+0xbe>
 8000846:	1bb9      	subs	r1, r7, r6
 8000848:	2900      	cmp	r1, #0
 800084a:	dd71      	ble.n	8000930 <__aeabi_fadd+0x1f4>
 800084c:	2e00      	cmp	r6, #0
 800084e:	d03f      	beq.n	80008d0 <__aeabi_fadd+0x194>
 8000850:	2fff      	cmp	r7, #255	; 0xff
 8000852:	d0ee      	beq.n	8000832 <__aeabi_fadd+0xf6>
 8000854:	2380      	movs	r3, #128	; 0x80
 8000856:	04db      	lsls	r3, r3, #19
 8000858:	431d      	orrs	r5, r3
 800085a:	2201      	movs	r2, #1
 800085c:	291b      	cmp	r1, #27
 800085e:	dc07      	bgt.n	8000870 <__aeabi_fadd+0x134>
 8000860:	002a      	movs	r2, r5
 8000862:	2320      	movs	r3, #32
 8000864:	40ca      	lsrs	r2, r1
 8000866:	1a59      	subs	r1, r3, r1
 8000868:	408d      	lsls	r5, r1
 800086a:	1e6b      	subs	r3, r5, #1
 800086c:	419d      	sbcs	r5, r3
 800086e:	432a      	orrs	r2, r5
 8000870:	4452      	add	r2, sl
 8000872:	0153      	lsls	r3, r2, #5
 8000874:	d553      	bpl.n	800091e <__aeabi_fadd+0x1e2>
 8000876:	3701      	adds	r7, #1
 8000878:	2fff      	cmp	r7, #255	; 0xff
 800087a:	d055      	beq.n	8000928 <__aeabi_fadd+0x1ec>
 800087c:	2301      	movs	r3, #1
 800087e:	497b      	ldr	r1, [pc, #492]	; (8000a6c <__aeabi_fadd+0x330>)
 8000880:	4013      	ands	r3, r2
 8000882:	0852      	lsrs	r2, r2, #1
 8000884:	400a      	ands	r2, r1
 8000886:	431a      	orrs	r2, r3
 8000888:	e7a5      	b.n	80007d6 <__aeabi_fadd+0x9a>
 800088a:	2d00      	cmp	r5, #0
 800088c:	d02c      	beq.n	80008e8 <__aeabi_fadd+0x1ac>
 800088e:	2301      	movs	r3, #1
 8000890:	425b      	negs	r3, r3
 8000892:	469c      	mov	ip, r3
 8000894:	44e1      	add	r9, ip
 8000896:	464b      	mov	r3, r9
 8000898:	2b00      	cmp	r3, #0
 800089a:	d100      	bne.n	800089e <__aeabi_fadd+0x162>
 800089c:	e0ad      	b.n	80009fa <__aeabi_fadd+0x2be>
 800089e:	2fff      	cmp	r7, #255	; 0xff
 80008a0:	d000      	beq.n	80008a4 <__aeabi_fadd+0x168>
 80008a2:	e76e      	b.n	8000782 <__aeabi_fadd+0x46>
 80008a4:	e7c5      	b.n	8000832 <__aeabi_fadd+0xf6>
 80008a6:	20fe      	movs	r0, #254	; 0xfe
 80008a8:	1c7e      	adds	r6, r7, #1
 80008aa:	4230      	tst	r0, r6
 80008ac:	d160      	bne.n	8000970 <__aeabi_fadd+0x234>
 80008ae:	2f00      	cmp	r7, #0
 80008b0:	d000      	beq.n	80008b4 <__aeabi_fadd+0x178>
 80008b2:	e093      	b.n	80009dc <__aeabi_fadd+0x2a0>
 80008b4:	4652      	mov	r2, sl
 80008b6:	2a00      	cmp	r2, #0
 80008b8:	d100      	bne.n	80008bc <__aeabi_fadd+0x180>
 80008ba:	e0b6      	b.n	8000a2a <__aeabi_fadd+0x2ee>
 80008bc:	2d00      	cmp	r5, #0
 80008be:	d09c      	beq.n	80007fa <__aeabi_fadd+0xbe>
 80008c0:	1b52      	subs	r2, r2, r5
 80008c2:	0150      	lsls	r0, r2, #5
 80008c4:	d400      	bmi.n	80008c8 <__aeabi_fadd+0x18c>
 80008c6:	e0c3      	b.n	8000a50 <__aeabi_fadd+0x314>
 80008c8:	4653      	mov	r3, sl
 80008ca:	000c      	movs	r4, r1
 80008cc:	1aea      	subs	r2, r5, r3
 80008ce:	e782      	b.n	80007d6 <__aeabi_fadd+0x9a>
 80008d0:	2d00      	cmp	r5, #0
 80008d2:	d009      	beq.n	80008e8 <__aeabi_fadd+0x1ac>
 80008d4:	3901      	subs	r1, #1
 80008d6:	2900      	cmp	r1, #0
 80008d8:	d100      	bne.n	80008dc <__aeabi_fadd+0x1a0>
 80008da:	e08b      	b.n	80009f4 <__aeabi_fadd+0x2b8>
 80008dc:	2fff      	cmp	r7, #255	; 0xff
 80008de:	d1bc      	bne.n	800085a <__aeabi_fadd+0x11e>
 80008e0:	e7a7      	b.n	8000832 <__aeabi_fadd+0xf6>
 80008e2:	000c      	movs	r4, r1
 80008e4:	4642      	mov	r2, r8
 80008e6:	0037      	movs	r7, r6
 80008e8:	2fff      	cmp	r7, #255	; 0xff
 80008ea:	d0a2      	beq.n	8000832 <__aeabi_fadd+0xf6>
 80008ec:	0252      	lsls	r2, r2, #9
 80008ee:	0a53      	lsrs	r3, r2, #9
 80008f0:	469c      	mov	ip, r3
 80008f2:	b2fb      	uxtb	r3, r7
 80008f4:	e781      	b.n	80007fa <__aeabi_fadd+0xbe>
 80008f6:	21fe      	movs	r1, #254	; 0xfe
 80008f8:	3701      	adds	r7, #1
 80008fa:	4239      	tst	r1, r7
 80008fc:	d165      	bne.n	80009ca <__aeabi_fadd+0x28e>
 80008fe:	2b00      	cmp	r3, #0
 8000900:	d17e      	bne.n	8000a00 <__aeabi_fadd+0x2c4>
 8000902:	2800      	cmp	r0, #0
 8000904:	d100      	bne.n	8000908 <__aeabi_fadd+0x1cc>
 8000906:	e0aa      	b.n	8000a5e <__aeabi_fadd+0x322>
 8000908:	2d00      	cmp	r5, #0
 800090a:	d100      	bne.n	800090e <__aeabi_fadd+0x1d2>
 800090c:	e775      	b.n	80007fa <__aeabi_fadd+0xbe>
 800090e:	002a      	movs	r2, r5
 8000910:	4452      	add	r2, sl
 8000912:	2700      	movs	r7, #0
 8000914:	0153      	lsls	r3, r2, #5
 8000916:	d502      	bpl.n	800091e <__aeabi_fadd+0x1e2>
 8000918:	4b55      	ldr	r3, [pc, #340]	; (8000a70 <__aeabi_fadd+0x334>)
 800091a:	3701      	adds	r7, #1
 800091c:	401a      	ands	r2, r3
 800091e:	0753      	lsls	r3, r2, #29
 8000920:	d000      	beq.n	8000924 <__aeabi_fadd+0x1e8>
 8000922:	e75a      	b.n	80007da <__aeabi_fadd+0x9e>
 8000924:	08d2      	lsrs	r2, r2, #3
 8000926:	e7df      	b.n	80008e8 <__aeabi_fadd+0x1ac>
 8000928:	2200      	movs	r2, #0
 800092a:	23ff      	movs	r3, #255	; 0xff
 800092c:	4694      	mov	ip, r2
 800092e:	e764      	b.n	80007fa <__aeabi_fadd+0xbe>
 8000930:	2900      	cmp	r1, #0
 8000932:	d0e0      	beq.n	80008f6 <__aeabi_fadd+0x1ba>
 8000934:	1bf3      	subs	r3, r6, r7
 8000936:	2f00      	cmp	r7, #0
 8000938:	d03e      	beq.n	80009b8 <__aeabi_fadd+0x27c>
 800093a:	2eff      	cmp	r6, #255	; 0xff
 800093c:	d100      	bne.n	8000940 <__aeabi_fadd+0x204>
 800093e:	e777      	b.n	8000830 <__aeabi_fadd+0xf4>
 8000940:	2280      	movs	r2, #128	; 0x80
 8000942:	0001      	movs	r1, r0
 8000944:	04d2      	lsls	r2, r2, #19
 8000946:	4311      	orrs	r1, r2
 8000948:	468a      	mov	sl, r1
 800094a:	2201      	movs	r2, #1
 800094c:	2b1b      	cmp	r3, #27
 800094e:	dc08      	bgt.n	8000962 <__aeabi_fadd+0x226>
 8000950:	4652      	mov	r2, sl
 8000952:	2120      	movs	r1, #32
 8000954:	4650      	mov	r0, sl
 8000956:	40da      	lsrs	r2, r3
 8000958:	1acb      	subs	r3, r1, r3
 800095a:	4098      	lsls	r0, r3
 800095c:	1e43      	subs	r3, r0, #1
 800095e:	4198      	sbcs	r0, r3
 8000960:	4302      	orrs	r2, r0
 8000962:	0037      	movs	r7, r6
 8000964:	1952      	adds	r2, r2, r5
 8000966:	e784      	b.n	8000872 <__aeabi_fadd+0x136>
 8000968:	4a41      	ldr	r2, [pc, #260]	; (8000a70 <__aeabi_fadd+0x334>)
 800096a:	1a3f      	subs	r7, r7, r0
 800096c:	4032      	ands	r2, r6
 800096e:	e732      	b.n	80007d6 <__aeabi_fadd+0x9a>
 8000970:	4653      	mov	r3, sl
 8000972:	1b5e      	subs	r6, r3, r5
 8000974:	0173      	lsls	r3, r6, #5
 8000976:	d42d      	bmi.n	80009d4 <__aeabi_fadd+0x298>
 8000978:	2e00      	cmp	r6, #0
 800097a:	d000      	beq.n	800097e <__aeabi_fadd+0x242>
 800097c:	e717      	b.n	80007ae <__aeabi_fadd+0x72>
 800097e:	2200      	movs	r2, #0
 8000980:	2400      	movs	r4, #0
 8000982:	2300      	movs	r3, #0
 8000984:	4694      	mov	ip, r2
 8000986:	e738      	b.n	80007fa <__aeabi_fadd+0xbe>
 8000988:	2eff      	cmp	r6, #255	; 0xff
 800098a:	d100      	bne.n	800098e <__aeabi_fadd+0x252>
 800098c:	e74f      	b.n	800082e <__aeabi_fadd+0xf2>
 800098e:	2280      	movs	r2, #128	; 0x80
 8000990:	4650      	mov	r0, sl
 8000992:	04d2      	lsls	r2, r2, #19
 8000994:	4310      	orrs	r0, r2
 8000996:	4682      	mov	sl, r0
 8000998:	2201      	movs	r2, #1
 800099a:	2b1b      	cmp	r3, #27
 800099c:	dc08      	bgt.n	80009b0 <__aeabi_fadd+0x274>
 800099e:	4652      	mov	r2, sl
 80009a0:	2420      	movs	r4, #32
 80009a2:	4650      	mov	r0, sl
 80009a4:	40da      	lsrs	r2, r3
 80009a6:	1ae3      	subs	r3, r4, r3
 80009a8:	4098      	lsls	r0, r3
 80009aa:	1e43      	subs	r3, r0, #1
 80009ac:	4198      	sbcs	r0, r3
 80009ae:	4302      	orrs	r2, r0
 80009b0:	000c      	movs	r4, r1
 80009b2:	0037      	movs	r7, r6
 80009b4:	1aaa      	subs	r2, r5, r2
 80009b6:	e6f5      	b.n	80007a4 <__aeabi_fadd+0x68>
 80009b8:	2800      	cmp	r0, #0
 80009ba:	d093      	beq.n	80008e4 <__aeabi_fadd+0x1a8>
 80009bc:	3b01      	subs	r3, #1
 80009be:	2b00      	cmp	r3, #0
 80009c0:	d04f      	beq.n	8000a62 <__aeabi_fadd+0x326>
 80009c2:	2eff      	cmp	r6, #255	; 0xff
 80009c4:	d1c1      	bne.n	800094a <__aeabi_fadd+0x20e>
 80009c6:	4642      	mov	r2, r8
 80009c8:	e733      	b.n	8000832 <__aeabi_fadd+0xf6>
 80009ca:	2fff      	cmp	r7, #255	; 0xff
 80009cc:	d0ac      	beq.n	8000928 <__aeabi_fadd+0x1ec>
 80009ce:	4455      	add	r5, sl
 80009d0:	086a      	lsrs	r2, r5, #1
 80009d2:	e7a4      	b.n	800091e <__aeabi_fadd+0x1e2>
 80009d4:	4653      	mov	r3, sl
 80009d6:	000c      	movs	r4, r1
 80009d8:	1aee      	subs	r6, r5, r3
 80009da:	e6e8      	b.n	80007ae <__aeabi_fadd+0x72>
 80009dc:	4653      	mov	r3, sl
 80009de:	2b00      	cmp	r3, #0
 80009e0:	d128      	bne.n	8000a34 <__aeabi_fadd+0x2f8>
 80009e2:	2d00      	cmp	r5, #0
 80009e4:	d000      	beq.n	80009e8 <__aeabi_fadd+0x2ac>
 80009e6:	e722      	b.n	800082e <__aeabi_fadd+0xf2>
 80009e8:	2380      	movs	r3, #128	; 0x80
 80009ea:	03db      	lsls	r3, r3, #15
 80009ec:	469c      	mov	ip, r3
 80009ee:	2400      	movs	r4, #0
 80009f0:	23ff      	movs	r3, #255	; 0xff
 80009f2:	e702      	b.n	80007fa <__aeabi_fadd+0xbe>
 80009f4:	002a      	movs	r2, r5
 80009f6:	4452      	add	r2, sl
 80009f8:	e73b      	b.n	8000872 <__aeabi_fadd+0x136>
 80009fa:	4653      	mov	r3, sl
 80009fc:	1b5a      	subs	r2, r3, r5
 80009fe:	e6d1      	b.n	80007a4 <__aeabi_fadd+0x68>
 8000a00:	2800      	cmp	r0, #0
 8000a02:	d100      	bne.n	8000a06 <__aeabi_fadd+0x2ca>
 8000a04:	e714      	b.n	8000830 <__aeabi_fadd+0xf4>
 8000a06:	2d00      	cmp	r5, #0
 8000a08:	d100      	bne.n	8000a0c <__aeabi_fadd+0x2d0>
 8000a0a:	e712      	b.n	8000832 <__aeabi_fadd+0xf6>
 8000a0c:	2380      	movs	r3, #128	; 0x80
 8000a0e:	03db      	lsls	r3, r3, #15
 8000a10:	421a      	tst	r2, r3
 8000a12:	d100      	bne.n	8000a16 <__aeabi_fadd+0x2da>
 8000a14:	e70d      	b.n	8000832 <__aeabi_fadd+0xf6>
 8000a16:	4641      	mov	r1, r8
 8000a18:	4219      	tst	r1, r3
 8000a1a:	d000      	beq.n	8000a1e <__aeabi_fadd+0x2e2>
 8000a1c:	e709      	b.n	8000832 <__aeabi_fadd+0xf6>
 8000a1e:	4642      	mov	r2, r8
 8000a20:	e707      	b.n	8000832 <__aeabi_fadd+0xf6>
 8000a22:	000c      	movs	r4, r1
 8000a24:	0037      	movs	r7, r6
 8000a26:	1aaa      	subs	r2, r5, r2
 8000a28:	e6bc      	b.n	80007a4 <__aeabi_fadd+0x68>
 8000a2a:	2d00      	cmp	r5, #0
 8000a2c:	d013      	beq.n	8000a56 <__aeabi_fadd+0x31a>
 8000a2e:	000c      	movs	r4, r1
 8000a30:	46c4      	mov	ip, r8
 8000a32:	e6e2      	b.n	80007fa <__aeabi_fadd+0xbe>
 8000a34:	2d00      	cmp	r5, #0
 8000a36:	d100      	bne.n	8000a3a <__aeabi_fadd+0x2fe>
 8000a38:	e6fb      	b.n	8000832 <__aeabi_fadd+0xf6>
 8000a3a:	2380      	movs	r3, #128	; 0x80
 8000a3c:	03db      	lsls	r3, r3, #15
 8000a3e:	421a      	tst	r2, r3
 8000a40:	d100      	bne.n	8000a44 <__aeabi_fadd+0x308>
 8000a42:	e6f6      	b.n	8000832 <__aeabi_fadd+0xf6>
 8000a44:	4640      	mov	r0, r8
 8000a46:	4218      	tst	r0, r3
 8000a48:	d000      	beq.n	8000a4c <__aeabi_fadd+0x310>
 8000a4a:	e6f2      	b.n	8000832 <__aeabi_fadd+0xf6>
 8000a4c:	000c      	movs	r4, r1
 8000a4e:	e6ef      	b.n	8000830 <__aeabi_fadd+0xf4>
 8000a50:	2a00      	cmp	r2, #0
 8000a52:	d000      	beq.n	8000a56 <__aeabi_fadd+0x31a>
 8000a54:	e763      	b.n	800091e <__aeabi_fadd+0x1e2>
 8000a56:	2200      	movs	r2, #0
 8000a58:	2400      	movs	r4, #0
 8000a5a:	4694      	mov	ip, r2
 8000a5c:	e6cd      	b.n	80007fa <__aeabi_fadd+0xbe>
 8000a5e:	46c4      	mov	ip, r8
 8000a60:	e6cb      	b.n	80007fa <__aeabi_fadd+0xbe>
 8000a62:	002a      	movs	r2, r5
 8000a64:	0037      	movs	r7, r6
 8000a66:	4452      	add	r2, sl
 8000a68:	e703      	b.n	8000872 <__aeabi_fadd+0x136>
 8000a6a:	46c0      	nop			; (mov r8, r8)
 8000a6c:	7dffffff 	.word	0x7dffffff
 8000a70:	fbffffff 	.word	0xfbffffff

08000a74 <__aeabi_fdiv>:
 8000a74:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a76:	464f      	mov	r7, r9
 8000a78:	4646      	mov	r6, r8
 8000a7a:	46d6      	mov	lr, sl
 8000a7c:	0245      	lsls	r5, r0, #9
 8000a7e:	b5c0      	push	{r6, r7, lr}
 8000a80:	0047      	lsls	r7, r0, #1
 8000a82:	1c0c      	adds	r4, r1, #0
 8000a84:	0a6d      	lsrs	r5, r5, #9
 8000a86:	0e3f      	lsrs	r7, r7, #24
 8000a88:	0fc6      	lsrs	r6, r0, #31
 8000a8a:	2f00      	cmp	r7, #0
 8000a8c:	d066      	beq.n	8000b5c <__aeabi_fdiv+0xe8>
 8000a8e:	2fff      	cmp	r7, #255	; 0xff
 8000a90:	d06c      	beq.n	8000b6c <__aeabi_fdiv+0xf8>
 8000a92:	2300      	movs	r3, #0
 8000a94:	00ea      	lsls	r2, r5, #3
 8000a96:	2580      	movs	r5, #128	; 0x80
 8000a98:	4699      	mov	r9, r3
 8000a9a:	469a      	mov	sl, r3
 8000a9c:	04ed      	lsls	r5, r5, #19
 8000a9e:	4315      	orrs	r5, r2
 8000aa0:	3f7f      	subs	r7, #127	; 0x7f
 8000aa2:	0260      	lsls	r0, r4, #9
 8000aa4:	0061      	lsls	r1, r4, #1
 8000aa6:	0a43      	lsrs	r3, r0, #9
 8000aa8:	4698      	mov	r8, r3
 8000aaa:	0e09      	lsrs	r1, r1, #24
 8000aac:	0fe4      	lsrs	r4, r4, #31
 8000aae:	2900      	cmp	r1, #0
 8000ab0:	d048      	beq.n	8000b44 <__aeabi_fdiv+0xd0>
 8000ab2:	29ff      	cmp	r1, #255	; 0xff
 8000ab4:	d010      	beq.n	8000ad8 <__aeabi_fdiv+0x64>
 8000ab6:	2280      	movs	r2, #128	; 0x80
 8000ab8:	00d8      	lsls	r0, r3, #3
 8000aba:	04d2      	lsls	r2, r2, #19
 8000abc:	4302      	orrs	r2, r0
 8000abe:	4690      	mov	r8, r2
 8000ac0:	2000      	movs	r0, #0
 8000ac2:	397f      	subs	r1, #127	; 0x7f
 8000ac4:	464a      	mov	r2, r9
 8000ac6:	0033      	movs	r3, r6
 8000ac8:	1a7f      	subs	r7, r7, r1
 8000aca:	4302      	orrs	r2, r0
 8000acc:	496c      	ldr	r1, [pc, #432]	; (8000c80 <__aeabi_fdiv+0x20c>)
 8000ace:	0092      	lsls	r2, r2, #2
 8000ad0:	588a      	ldr	r2, [r1, r2]
 8000ad2:	4063      	eors	r3, r4
 8000ad4:	b2db      	uxtb	r3, r3
 8000ad6:	4697      	mov	pc, r2
 8000ad8:	2b00      	cmp	r3, #0
 8000ada:	d16d      	bne.n	8000bb8 <__aeabi_fdiv+0x144>
 8000adc:	2002      	movs	r0, #2
 8000ade:	3fff      	subs	r7, #255	; 0xff
 8000ae0:	e033      	b.n	8000b4a <__aeabi_fdiv+0xd6>
 8000ae2:	2300      	movs	r3, #0
 8000ae4:	4698      	mov	r8, r3
 8000ae6:	0026      	movs	r6, r4
 8000ae8:	4645      	mov	r5, r8
 8000aea:	4682      	mov	sl, r0
 8000aec:	4653      	mov	r3, sl
 8000aee:	2b02      	cmp	r3, #2
 8000af0:	d100      	bne.n	8000af4 <__aeabi_fdiv+0x80>
 8000af2:	e07f      	b.n	8000bf4 <__aeabi_fdiv+0x180>
 8000af4:	2b03      	cmp	r3, #3
 8000af6:	d100      	bne.n	8000afa <__aeabi_fdiv+0x86>
 8000af8:	e094      	b.n	8000c24 <__aeabi_fdiv+0x1b0>
 8000afa:	2b01      	cmp	r3, #1
 8000afc:	d017      	beq.n	8000b2e <__aeabi_fdiv+0xba>
 8000afe:	0038      	movs	r0, r7
 8000b00:	307f      	adds	r0, #127	; 0x7f
 8000b02:	2800      	cmp	r0, #0
 8000b04:	dd5f      	ble.n	8000bc6 <__aeabi_fdiv+0x152>
 8000b06:	076b      	lsls	r3, r5, #29
 8000b08:	d004      	beq.n	8000b14 <__aeabi_fdiv+0xa0>
 8000b0a:	230f      	movs	r3, #15
 8000b0c:	402b      	ands	r3, r5
 8000b0e:	2b04      	cmp	r3, #4
 8000b10:	d000      	beq.n	8000b14 <__aeabi_fdiv+0xa0>
 8000b12:	3504      	adds	r5, #4
 8000b14:	012b      	lsls	r3, r5, #4
 8000b16:	d503      	bpl.n	8000b20 <__aeabi_fdiv+0xac>
 8000b18:	0038      	movs	r0, r7
 8000b1a:	4b5a      	ldr	r3, [pc, #360]	; (8000c84 <__aeabi_fdiv+0x210>)
 8000b1c:	3080      	adds	r0, #128	; 0x80
 8000b1e:	401d      	ands	r5, r3
 8000b20:	28fe      	cmp	r0, #254	; 0xfe
 8000b22:	dc67      	bgt.n	8000bf4 <__aeabi_fdiv+0x180>
 8000b24:	01ad      	lsls	r5, r5, #6
 8000b26:	0a6d      	lsrs	r5, r5, #9
 8000b28:	b2c0      	uxtb	r0, r0
 8000b2a:	e002      	b.n	8000b32 <__aeabi_fdiv+0xbe>
 8000b2c:	001e      	movs	r6, r3
 8000b2e:	2000      	movs	r0, #0
 8000b30:	2500      	movs	r5, #0
 8000b32:	05c0      	lsls	r0, r0, #23
 8000b34:	4328      	orrs	r0, r5
 8000b36:	07f6      	lsls	r6, r6, #31
 8000b38:	4330      	orrs	r0, r6
 8000b3a:	bce0      	pop	{r5, r6, r7}
 8000b3c:	46ba      	mov	sl, r7
 8000b3e:	46b1      	mov	r9, r6
 8000b40:	46a8      	mov	r8, r5
 8000b42:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b44:	2b00      	cmp	r3, #0
 8000b46:	d12b      	bne.n	8000ba0 <__aeabi_fdiv+0x12c>
 8000b48:	2001      	movs	r0, #1
 8000b4a:	464a      	mov	r2, r9
 8000b4c:	0033      	movs	r3, r6
 8000b4e:	494e      	ldr	r1, [pc, #312]	; (8000c88 <__aeabi_fdiv+0x214>)
 8000b50:	4302      	orrs	r2, r0
 8000b52:	0092      	lsls	r2, r2, #2
 8000b54:	588a      	ldr	r2, [r1, r2]
 8000b56:	4063      	eors	r3, r4
 8000b58:	b2db      	uxtb	r3, r3
 8000b5a:	4697      	mov	pc, r2
 8000b5c:	2d00      	cmp	r5, #0
 8000b5e:	d113      	bne.n	8000b88 <__aeabi_fdiv+0x114>
 8000b60:	2304      	movs	r3, #4
 8000b62:	4699      	mov	r9, r3
 8000b64:	3b03      	subs	r3, #3
 8000b66:	2700      	movs	r7, #0
 8000b68:	469a      	mov	sl, r3
 8000b6a:	e79a      	b.n	8000aa2 <__aeabi_fdiv+0x2e>
 8000b6c:	2d00      	cmp	r5, #0
 8000b6e:	d105      	bne.n	8000b7c <__aeabi_fdiv+0x108>
 8000b70:	2308      	movs	r3, #8
 8000b72:	4699      	mov	r9, r3
 8000b74:	3b06      	subs	r3, #6
 8000b76:	27ff      	movs	r7, #255	; 0xff
 8000b78:	469a      	mov	sl, r3
 8000b7a:	e792      	b.n	8000aa2 <__aeabi_fdiv+0x2e>
 8000b7c:	230c      	movs	r3, #12
 8000b7e:	4699      	mov	r9, r3
 8000b80:	3b09      	subs	r3, #9
 8000b82:	27ff      	movs	r7, #255	; 0xff
 8000b84:	469a      	mov	sl, r3
 8000b86:	e78c      	b.n	8000aa2 <__aeabi_fdiv+0x2e>
 8000b88:	0028      	movs	r0, r5
 8000b8a:	f002 fb03 	bl	8003194 <__clzsi2>
 8000b8e:	2776      	movs	r7, #118	; 0x76
 8000b90:	1f43      	subs	r3, r0, #5
 8000b92:	409d      	lsls	r5, r3
 8000b94:	2300      	movs	r3, #0
 8000b96:	427f      	negs	r7, r7
 8000b98:	4699      	mov	r9, r3
 8000b9a:	469a      	mov	sl, r3
 8000b9c:	1a3f      	subs	r7, r7, r0
 8000b9e:	e780      	b.n	8000aa2 <__aeabi_fdiv+0x2e>
 8000ba0:	0018      	movs	r0, r3
 8000ba2:	f002 faf7 	bl	8003194 <__clzsi2>
 8000ba6:	4642      	mov	r2, r8
 8000ba8:	1f43      	subs	r3, r0, #5
 8000baa:	2176      	movs	r1, #118	; 0x76
 8000bac:	409a      	lsls	r2, r3
 8000bae:	4249      	negs	r1, r1
 8000bb0:	1a09      	subs	r1, r1, r0
 8000bb2:	4690      	mov	r8, r2
 8000bb4:	2000      	movs	r0, #0
 8000bb6:	e785      	b.n	8000ac4 <__aeabi_fdiv+0x50>
 8000bb8:	21ff      	movs	r1, #255	; 0xff
 8000bba:	2003      	movs	r0, #3
 8000bbc:	e782      	b.n	8000ac4 <__aeabi_fdiv+0x50>
 8000bbe:	001e      	movs	r6, r3
 8000bc0:	20ff      	movs	r0, #255	; 0xff
 8000bc2:	2500      	movs	r5, #0
 8000bc4:	e7b5      	b.n	8000b32 <__aeabi_fdiv+0xbe>
 8000bc6:	2301      	movs	r3, #1
 8000bc8:	1a1b      	subs	r3, r3, r0
 8000bca:	2b1b      	cmp	r3, #27
 8000bcc:	dcaf      	bgt.n	8000b2e <__aeabi_fdiv+0xba>
 8000bce:	379e      	adds	r7, #158	; 0x9e
 8000bd0:	0029      	movs	r1, r5
 8000bd2:	40bd      	lsls	r5, r7
 8000bd4:	40d9      	lsrs	r1, r3
 8000bd6:	1e6a      	subs	r2, r5, #1
 8000bd8:	4195      	sbcs	r5, r2
 8000bda:	430d      	orrs	r5, r1
 8000bdc:	076b      	lsls	r3, r5, #29
 8000bde:	d004      	beq.n	8000bea <__aeabi_fdiv+0x176>
 8000be0:	230f      	movs	r3, #15
 8000be2:	402b      	ands	r3, r5
 8000be4:	2b04      	cmp	r3, #4
 8000be6:	d000      	beq.n	8000bea <__aeabi_fdiv+0x176>
 8000be8:	3504      	adds	r5, #4
 8000bea:	016b      	lsls	r3, r5, #5
 8000bec:	d544      	bpl.n	8000c78 <__aeabi_fdiv+0x204>
 8000bee:	2001      	movs	r0, #1
 8000bf0:	2500      	movs	r5, #0
 8000bf2:	e79e      	b.n	8000b32 <__aeabi_fdiv+0xbe>
 8000bf4:	20ff      	movs	r0, #255	; 0xff
 8000bf6:	2500      	movs	r5, #0
 8000bf8:	e79b      	b.n	8000b32 <__aeabi_fdiv+0xbe>
 8000bfa:	2580      	movs	r5, #128	; 0x80
 8000bfc:	2600      	movs	r6, #0
 8000bfe:	20ff      	movs	r0, #255	; 0xff
 8000c00:	03ed      	lsls	r5, r5, #15
 8000c02:	e796      	b.n	8000b32 <__aeabi_fdiv+0xbe>
 8000c04:	2300      	movs	r3, #0
 8000c06:	4698      	mov	r8, r3
 8000c08:	2080      	movs	r0, #128	; 0x80
 8000c0a:	03c0      	lsls	r0, r0, #15
 8000c0c:	4205      	tst	r5, r0
 8000c0e:	d009      	beq.n	8000c24 <__aeabi_fdiv+0x1b0>
 8000c10:	4643      	mov	r3, r8
 8000c12:	4203      	tst	r3, r0
 8000c14:	d106      	bne.n	8000c24 <__aeabi_fdiv+0x1b0>
 8000c16:	4645      	mov	r5, r8
 8000c18:	4305      	orrs	r5, r0
 8000c1a:	026d      	lsls	r5, r5, #9
 8000c1c:	0026      	movs	r6, r4
 8000c1e:	20ff      	movs	r0, #255	; 0xff
 8000c20:	0a6d      	lsrs	r5, r5, #9
 8000c22:	e786      	b.n	8000b32 <__aeabi_fdiv+0xbe>
 8000c24:	2080      	movs	r0, #128	; 0x80
 8000c26:	03c0      	lsls	r0, r0, #15
 8000c28:	4305      	orrs	r5, r0
 8000c2a:	026d      	lsls	r5, r5, #9
 8000c2c:	20ff      	movs	r0, #255	; 0xff
 8000c2e:	0a6d      	lsrs	r5, r5, #9
 8000c30:	e77f      	b.n	8000b32 <__aeabi_fdiv+0xbe>
 8000c32:	4641      	mov	r1, r8
 8000c34:	016a      	lsls	r2, r5, #5
 8000c36:	0148      	lsls	r0, r1, #5
 8000c38:	4282      	cmp	r2, r0
 8000c3a:	d219      	bcs.n	8000c70 <__aeabi_fdiv+0x1fc>
 8000c3c:	211b      	movs	r1, #27
 8000c3e:	2500      	movs	r5, #0
 8000c40:	3f01      	subs	r7, #1
 8000c42:	2601      	movs	r6, #1
 8000c44:	0014      	movs	r4, r2
 8000c46:	006d      	lsls	r5, r5, #1
 8000c48:	0052      	lsls	r2, r2, #1
 8000c4a:	2c00      	cmp	r4, #0
 8000c4c:	db01      	blt.n	8000c52 <__aeabi_fdiv+0x1de>
 8000c4e:	4290      	cmp	r0, r2
 8000c50:	d801      	bhi.n	8000c56 <__aeabi_fdiv+0x1e2>
 8000c52:	1a12      	subs	r2, r2, r0
 8000c54:	4335      	orrs	r5, r6
 8000c56:	3901      	subs	r1, #1
 8000c58:	2900      	cmp	r1, #0
 8000c5a:	d1f3      	bne.n	8000c44 <__aeabi_fdiv+0x1d0>
 8000c5c:	1e50      	subs	r0, r2, #1
 8000c5e:	4182      	sbcs	r2, r0
 8000c60:	0038      	movs	r0, r7
 8000c62:	307f      	adds	r0, #127	; 0x7f
 8000c64:	001e      	movs	r6, r3
 8000c66:	4315      	orrs	r5, r2
 8000c68:	2800      	cmp	r0, #0
 8000c6a:	dd00      	ble.n	8000c6e <__aeabi_fdiv+0x1fa>
 8000c6c:	e74b      	b.n	8000b06 <__aeabi_fdiv+0x92>
 8000c6e:	e7aa      	b.n	8000bc6 <__aeabi_fdiv+0x152>
 8000c70:	211a      	movs	r1, #26
 8000c72:	2501      	movs	r5, #1
 8000c74:	1a12      	subs	r2, r2, r0
 8000c76:	e7e4      	b.n	8000c42 <__aeabi_fdiv+0x1ce>
 8000c78:	01ad      	lsls	r5, r5, #6
 8000c7a:	2000      	movs	r0, #0
 8000c7c:	0a6d      	lsrs	r5, r5, #9
 8000c7e:	e758      	b.n	8000b32 <__aeabi_fdiv+0xbe>
 8000c80:	0801fcf4 	.word	0x0801fcf4
 8000c84:	f7ffffff 	.word	0xf7ffffff
 8000c88:	0801fd34 	.word	0x0801fd34

08000c8c <__eqsf2>:
 8000c8c:	b570      	push	{r4, r5, r6, lr}
 8000c8e:	0042      	lsls	r2, r0, #1
 8000c90:	024e      	lsls	r6, r1, #9
 8000c92:	004c      	lsls	r4, r1, #1
 8000c94:	0245      	lsls	r5, r0, #9
 8000c96:	0a6d      	lsrs	r5, r5, #9
 8000c98:	0e12      	lsrs	r2, r2, #24
 8000c9a:	0fc3      	lsrs	r3, r0, #31
 8000c9c:	0a76      	lsrs	r6, r6, #9
 8000c9e:	0e24      	lsrs	r4, r4, #24
 8000ca0:	0fc9      	lsrs	r1, r1, #31
 8000ca2:	2aff      	cmp	r2, #255	; 0xff
 8000ca4:	d00f      	beq.n	8000cc6 <__eqsf2+0x3a>
 8000ca6:	2cff      	cmp	r4, #255	; 0xff
 8000ca8:	d011      	beq.n	8000cce <__eqsf2+0x42>
 8000caa:	2001      	movs	r0, #1
 8000cac:	42a2      	cmp	r2, r4
 8000cae:	d000      	beq.n	8000cb2 <__eqsf2+0x26>
 8000cb0:	bd70      	pop	{r4, r5, r6, pc}
 8000cb2:	42b5      	cmp	r5, r6
 8000cb4:	d1fc      	bne.n	8000cb0 <__eqsf2+0x24>
 8000cb6:	428b      	cmp	r3, r1
 8000cb8:	d00d      	beq.n	8000cd6 <__eqsf2+0x4a>
 8000cba:	2a00      	cmp	r2, #0
 8000cbc:	d1f8      	bne.n	8000cb0 <__eqsf2+0x24>
 8000cbe:	0028      	movs	r0, r5
 8000cc0:	1e45      	subs	r5, r0, #1
 8000cc2:	41a8      	sbcs	r0, r5
 8000cc4:	e7f4      	b.n	8000cb0 <__eqsf2+0x24>
 8000cc6:	2001      	movs	r0, #1
 8000cc8:	2d00      	cmp	r5, #0
 8000cca:	d1f1      	bne.n	8000cb0 <__eqsf2+0x24>
 8000ccc:	e7eb      	b.n	8000ca6 <__eqsf2+0x1a>
 8000cce:	2001      	movs	r0, #1
 8000cd0:	2e00      	cmp	r6, #0
 8000cd2:	d1ed      	bne.n	8000cb0 <__eqsf2+0x24>
 8000cd4:	e7e9      	b.n	8000caa <__eqsf2+0x1e>
 8000cd6:	2000      	movs	r0, #0
 8000cd8:	e7ea      	b.n	8000cb0 <__eqsf2+0x24>
 8000cda:	46c0      	nop			; (mov r8, r8)

08000cdc <__gesf2>:
 8000cdc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000cde:	0042      	lsls	r2, r0, #1
 8000ce0:	0246      	lsls	r6, r0, #9
 8000ce2:	024d      	lsls	r5, r1, #9
 8000ce4:	004c      	lsls	r4, r1, #1
 8000ce6:	0fc3      	lsrs	r3, r0, #31
 8000ce8:	0a76      	lsrs	r6, r6, #9
 8000cea:	0e12      	lsrs	r2, r2, #24
 8000cec:	0a6d      	lsrs	r5, r5, #9
 8000cee:	0e24      	lsrs	r4, r4, #24
 8000cf0:	0fc8      	lsrs	r0, r1, #31
 8000cf2:	2aff      	cmp	r2, #255	; 0xff
 8000cf4:	d01f      	beq.n	8000d36 <__gesf2+0x5a>
 8000cf6:	2cff      	cmp	r4, #255	; 0xff
 8000cf8:	d010      	beq.n	8000d1c <__gesf2+0x40>
 8000cfa:	2a00      	cmp	r2, #0
 8000cfc:	d11f      	bne.n	8000d3e <__gesf2+0x62>
 8000cfe:	4271      	negs	r1, r6
 8000d00:	4171      	adcs	r1, r6
 8000d02:	2c00      	cmp	r4, #0
 8000d04:	d101      	bne.n	8000d0a <__gesf2+0x2e>
 8000d06:	2d00      	cmp	r5, #0
 8000d08:	d01e      	beq.n	8000d48 <__gesf2+0x6c>
 8000d0a:	2900      	cmp	r1, #0
 8000d0c:	d10e      	bne.n	8000d2c <__gesf2+0x50>
 8000d0e:	4283      	cmp	r3, r0
 8000d10:	d01e      	beq.n	8000d50 <__gesf2+0x74>
 8000d12:	2102      	movs	r1, #2
 8000d14:	1e58      	subs	r0, r3, #1
 8000d16:	4008      	ands	r0, r1
 8000d18:	3801      	subs	r0, #1
 8000d1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000d1c:	2d00      	cmp	r5, #0
 8000d1e:	d126      	bne.n	8000d6e <__gesf2+0x92>
 8000d20:	2a00      	cmp	r2, #0
 8000d22:	d1f4      	bne.n	8000d0e <__gesf2+0x32>
 8000d24:	4271      	negs	r1, r6
 8000d26:	4171      	adcs	r1, r6
 8000d28:	2900      	cmp	r1, #0
 8000d2a:	d0f0      	beq.n	8000d0e <__gesf2+0x32>
 8000d2c:	2800      	cmp	r0, #0
 8000d2e:	d1f4      	bne.n	8000d1a <__gesf2+0x3e>
 8000d30:	2001      	movs	r0, #1
 8000d32:	4240      	negs	r0, r0
 8000d34:	e7f1      	b.n	8000d1a <__gesf2+0x3e>
 8000d36:	2e00      	cmp	r6, #0
 8000d38:	d119      	bne.n	8000d6e <__gesf2+0x92>
 8000d3a:	2cff      	cmp	r4, #255	; 0xff
 8000d3c:	d0ee      	beq.n	8000d1c <__gesf2+0x40>
 8000d3e:	2c00      	cmp	r4, #0
 8000d40:	d1e5      	bne.n	8000d0e <__gesf2+0x32>
 8000d42:	2d00      	cmp	r5, #0
 8000d44:	d1e3      	bne.n	8000d0e <__gesf2+0x32>
 8000d46:	e7e4      	b.n	8000d12 <__gesf2+0x36>
 8000d48:	2000      	movs	r0, #0
 8000d4a:	2e00      	cmp	r6, #0
 8000d4c:	d0e5      	beq.n	8000d1a <__gesf2+0x3e>
 8000d4e:	e7e0      	b.n	8000d12 <__gesf2+0x36>
 8000d50:	42a2      	cmp	r2, r4
 8000d52:	dc05      	bgt.n	8000d60 <__gesf2+0x84>
 8000d54:	dbea      	blt.n	8000d2c <__gesf2+0x50>
 8000d56:	42ae      	cmp	r6, r5
 8000d58:	d802      	bhi.n	8000d60 <__gesf2+0x84>
 8000d5a:	d3e7      	bcc.n	8000d2c <__gesf2+0x50>
 8000d5c:	2000      	movs	r0, #0
 8000d5e:	e7dc      	b.n	8000d1a <__gesf2+0x3e>
 8000d60:	4241      	negs	r1, r0
 8000d62:	4141      	adcs	r1, r0
 8000d64:	4248      	negs	r0, r1
 8000d66:	2102      	movs	r1, #2
 8000d68:	4008      	ands	r0, r1
 8000d6a:	3801      	subs	r0, #1
 8000d6c:	e7d5      	b.n	8000d1a <__gesf2+0x3e>
 8000d6e:	2002      	movs	r0, #2
 8000d70:	4240      	negs	r0, r0
 8000d72:	e7d2      	b.n	8000d1a <__gesf2+0x3e>

08000d74 <__lesf2>:
 8000d74:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000d76:	0042      	lsls	r2, r0, #1
 8000d78:	0246      	lsls	r6, r0, #9
 8000d7a:	024d      	lsls	r5, r1, #9
 8000d7c:	004c      	lsls	r4, r1, #1
 8000d7e:	0fc3      	lsrs	r3, r0, #31
 8000d80:	0a76      	lsrs	r6, r6, #9
 8000d82:	0e12      	lsrs	r2, r2, #24
 8000d84:	0a6d      	lsrs	r5, r5, #9
 8000d86:	0e24      	lsrs	r4, r4, #24
 8000d88:	0fc8      	lsrs	r0, r1, #31
 8000d8a:	2aff      	cmp	r2, #255	; 0xff
 8000d8c:	d00d      	beq.n	8000daa <__lesf2+0x36>
 8000d8e:	2cff      	cmp	r4, #255	; 0xff
 8000d90:	d00f      	beq.n	8000db2 <__lesf2+0x3e>
 8000d92:	2a00      	cmp	r2, #0
 8000d94:	d123      	bne.n	8000dde <__lesf2+0x6a>
 8000d96:	4271      	negs	r1, r6
 8000d98:	4171      	adcs	r1, r6
 8000d9a:	2c00      	cmp	r4, #0
 8000d9c:	d10f      	bne.n	8000dbe <__lesf2+0x4a>
 8000d9e:	2d00      	cmp	r5, #0
 8000da0:	d10d      	bne.n	8000dbe <__lesf2+0x4a>
 8000da2:	2000      	movs	r0, #0
 8000da4:	2e00      	cmp	r6, #0
 8000da6:	d014      	beq.n	8000dd2 <__lesf2+0x5e>
 8000da8:	e00d      	b.n	8000dc6 <__lesf2+0x52>
 8000daa:	2e00      	cmp	r6, #0
 8000dac:	d110      	bne.n	8000dd0 <__lesf2+0x5c>
 8000dae:	2cff      	cmp	r4, #255	; 0xff
 8000db0:	d115      	bne.n	8000dde <__lesf2+0x6a>
 8000db2:	2d00      	cmp	r5, #0
 8000db4:	d10c      	bne.n	8000dd0 <__lesf2+0x5c>
 8000db6:	2a00      	cmp	r2, #0
 8000db8:	d103      	bne.n	8000dc2 <__lesf2+0x4e>
 8000dba:	4271      	negs	r1, r6
 8000dbc:	4171      	adcs	r1, r6
 8000dbe:	2900      	cmp	r1, #0
 8000dc0:	d108      	bne.n	8000dd4 <__lesf2+0x60>
 8000dc2:	4283      	cmp	r3, r0
 8000dc4:	d010      	beq.n	8000de8 <__lesf2+0x74>
 8000dc6:	2102      	movs	r1, #2
 8000dc8:	1e58      	subs	r0, r3, #1
 8000dca:	4008      	ands	r0, r1
 8000dcc:	3801      	subs	r0, #1
 8000dce:	e000      	b.n	8000dd2 <__lesf2+0x5e>
 8000dd0:	2002      	movs	r0, #2
 8000dd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000dd4:	2800      	cmp	r0, #0
 8000dd6:	d1fc      	bne.n	8000dd2 <__lesf2+0x5e>
 8000dd8:	2001      	movs	r0, #1
 8000dda:	4240      	negs	r0, r0
 8000ddc:	e7f9      	b.n	8000dd2 <__lesf2+0x5e>
 8000dde:	2c00      	cmp	r4, #0
 8000de0:	d1ef      	bne.n	8000dc2 <__lesf2+0x4e>
 8000de2:	2d00      	cmp	r5, #0
 8000de4:	d1ed      	bne.n	8000dc2 <__lesf2+0x4e>
 8000de6:	e7ee      	b.n	8000dc6 <__lesf2+0x52>
 8000de8:	42a2      	cmp	r2, r4
 8000dea:	dc05      	bgt.n	8000df8 <__lesf2+0x84>
 8000dec:	dbf2      	blt.n	8000dd4 <__lesf2+0x60>
 8000dee:	42ae      	cmp	r6, r5
 8000df0:	d802      	bhi.n	8000df8 <__lesf2+0x84>
 8000df2:	d3ef      	bcc.n	8000dd4 <__lesf2+0x60>
 8000df4:	2000      	movs	r0, #0
 8000df6:	e7ec      	b.n	8000dd2 <__lesf2+0x5e>
 8000df8:	4241      	negs	r1, r0
 8000dfa:	4141      	adcs	r1, r0
 8000dfc:	4248      	negs	r0, r1
 8000dfe:	2102      	movs	r1, #2
 8000e00:	4008      	ands	r0, r1
 8000e02:	3801      	subs	r0, #1
 8000e04:	e7e5      	b.n	8000dd2 <__lesf2+0x5e>
 8000e06:	46c0      	nop			; (mov r8, r8)

08000e08 <__aeabi_fmul>:
 8000e08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000e0a:	4657      	mov	r7, sl
 8000e0c:	464e      	mov	r6, r9
 8000e0e:	4645      	mov	r5, r8
 8000e10:	46de      	mov	lr, fp
 8000e12:	0244      	lsls	r4, r0, #9
 8000e14:	b5e0      	push	{r5, r6, r7, lr}
 8000e16:	0045      	lsls	r5, r0, #1
 8000e18:	1c0f      	adds	r7, r1, #0
 8000e1a:	0a64      	lsrs	r4, r4, #9
 8000e1c:	0e2d      	lsrs	r5, r5, #24
 8000e1e:	0fc6      	lsrs	r6, r0, #31
 8000e20:	2d00      	cmp	r5, #0
 8000e22:	d047      	beq.n	8000eb4 <__aeabi_fmul+0xac>
 8000e24:	2dff      	cmp	r5, #255	; 0xff
 8000e26:	d04d      	beq.n	8000ec4 <__aeabi_fmul+0xbc>
 8000e28:	2300      	movs	r3, #0
 8000e2a:	2080      	movs	r0, #128	; 0x80
 8000e2c:	469a      	mov	sl, r3
 8000e2e:	469b      	mov	fp, r3
 8000e30:	00e4      	lsls	r4, r4, #3
 8000e32:	04c0      	lsls	r0, r0, #19
 8000e34:	4304      	orrs	r4, r0
 8000e36:	3d7f      	subs	r5, #127	; 0x7f
 8000e38:	0278      	lsls	r0, r7, #9
 8000e3a:	0a43      	lsrs	r3, r0, #9
 8000e3c:	4699      	mov	r9, r3
 8000e3e:	007a      	lsls	r2, r7, #1
 8000e40:	0ffb      	lsrs	r3, r7, #31
 8000e42:	4698      	mov	r8, r3
 8000e44:	0e12      	lsrs	r2, r2, #24
 8000e46:	464b      	mov	r3, r9
 8000e48:	d044      	beq.n	8000ed4 <__aeabi_fmul+0xcc>
 8000e4a:	2aff      	cmp	r2, #255	; 0xff
 8000e4c:	d011      	beq.n	8000e72 <__aeabi_fmul+0x6a>
 8000e4e:	00d8      	lsls	r0, r3, #3
 8000e50:	2380      	movs	r3, #128	; 0x80
 8000e52:	04db      	lsls	r3, r3, #19
 8000e54:	4303      	orrs	r3, r0
 8000e56:	4699      	mov	r9, r3
 8000e58:	2000      	movs	r0, #0
 8000e5a:	3a7f      	subs	r2, #127	; 0x7f
 8000e5c:	18ad      	adds	r5, r5, r2
 8000e5e:	4647      	mov	r7, r8
 8000e60:	4653      	mov	r3, sl
 8000e62:	4077      	eors	r7, r6
 8000e64:	1c69      	adds	r1, r5, #1
 8000e66:	2b0f      	cmp	r3, #15
 8000e68:	d83f      	bhi.n	8000eea <__aeabi_fmul+0xe2>
 8000e6a:	4a72      	ldr	r2, [pc, #456]	; (8001034 <__aeabi_fmul+0x22c>)
 8000e6c:	009b      	lsls	r3, r3, #2
 8000e6e:	58d3      	ldr	r3, [r2, r3]
 8000e70:	469f      	mov	pc, r3
 8000e72:	35ff      	adds	r5, #255	; 0xff
 8000e74:	2b00      	cmp	r3, #0
 8000e76:	d000      	beq.n	8000e7a <__aeabi_fmul+0x72>
 8000e78:	e079      	b.n	8000f6e <__aeabi_fmul+0x166>
 8000e7a:	4652      	mov	r2, sl
 8000e7c:	2302      	movs	r3, #2
 8000e7e:	431a      	orrs	r2, r3
 8000e80:	4692      	mov	sl, r2
 8000e82:	2002      	movs	r0, #2
 8000e84:	e7eb      	b.n	8000e5e <__aeabi_fmul+0x56>
 8000e86:	4647      	mov	r7, r8
 8000e88:	464c      	mov	r4, r9
 8000e8a:	4683      	mov	fp, r0
 8000e8c:	465b      	mov	r3, fp
 8000e8e:	2b02      	cmp	r3, #2
 8000e90:	d028      	beq.n	8000ee4 <__aeabi_fmul+0xdc>
 8000e92:	2b03      	cmp	r3, #3
 8000e94:	d100      	bne.n	8000e98 <__aeabi_fmul+0x90>
 8000e96:	e0c6      	b.n	8001026 <__aeabi_fmul+0x21e>
 8000e98:	2b01      	cmp	r3, #1
 8000e9a:	d14f      	bne.n	8000f3c <__aeabi_fmul+0x134>
 8000e9c:	2000      	movs	r0, #0
 8000e9e:	2400      	movs	r4, #0
 8000ea0:	05c0      	lsls	r0, r0, #23
 8000ea2:	07ff      	lsls	r7, r7, #31
 8000ea4:	4320      	orrs	r0, r4
 8000ea6:	4338      	orrs	r0, r7
 8000ea8:	bcf0      	pop	{r4, r5, r6, r7}
 8000eaa:	46bb      	mov	fp, r7
 8000eac:	46b2      	mov	sl, r6
 8000eae:	46a9      	mov	r9, r5
 8000eb0:	46a0      	mov	r8, r4
 8000eb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000eb4:	2c00      	cmp	r4, #0
 8000eb6:	d171      	bne.n	8000f9c <__aeabi_fmul+0x194>
 8000eb8:	2304      	movs	r3, #4
 8000eba:	469a      	mov	sl, r3
 8000ebc:	3b03      	subs	r3, #3
 8000ebe:	2500      	movs	r5, #0
 8000ec0:	469b      	mov	fp, r3
 8000ec2:	e7b9      	b.n	8000e38 <__aeabi_fmul+0x30>
 8000ec4:	2c00      	cmp	r4, #0
 8000ec6:	d163      	bne.n	8000f90 <__aeabi_fmul+0x188>
 8000ec8:	2308      	movs	r3, #8
 8000eca:	469a      	mov	sl, r3
 8000ecc:	3b06      	subs	r3, #6
 8000ece:	25ff      	movs	r5, #255	; 0xff
 8000ed0:	469b      	mov	fp, r3
 8000ed2:	e7b1      	b.n	8000e38 <__aeabi_fmul+0x30>
 8000ed4:	2b00      	cmp	r3, #0
 8000ed6:	d150      	bne.n	8000f7a <__aeabi_fmul+0x172>
 8000ed8:	4652      	mov	r2, sl
 8000eda:	3301      	adds	r3, #1
 8000edc:	431a      	orrs	r2, r3
 8000ede:	4692      	mov	sl, r2
 8000ee0:	2001      	movs	r0, #1
 8000ee2:	e7bc      	b.n	8000e5e <__aeabi_fmul+0x56>
 8000ee4:	20ff      	movs	r0, #255	; 0xff
 8000ee6:	2400      	movs	r4, #0
 8000ee8:	e7da      	b.n	8000ea0 <__aeabi_fmul+0x98>
 8000eea:	4648      	mov	r0, r9
 8000eec:	0c26      	lsrs	r6, r4, #16
 8000eee:	0424      	lsls	r4, r4, #16
 8000ef0:	0c22      	lsrs	r2, r4, #16
 8000ef2:	0404      	lsls	r4, r0, #16
 8000ef4:	0c24      	lsrs	r4, r4, #16
 8000ef6:	464b      	mov	r3, r9
 8000ef8:	0020      	movs	r0, r4
 8000efa:	0c1b      	lsrs	r3, r3, #16
 8000efc:	4350      	muls	r0, r2
 8000efe:	4374      	muls	r4, r6
 8000f00:	435a      	muls	r2, r3
 8000f02:	435e      	muls	r6, r3
 8000f04:	1912      	adds	r2, r2, r4
 8000f06:	0c03      	lsrs	r3, r0, #16
 8000f08:	189b      	adds	r3, r3, r2
 8000f0a:	429c      	cmp	r4, r3
 8000f0c:	d903      	bls.n	8000f16 <__aeabi_fmul+0x10e>
 8000f0e:	2280      	movs	r2, #128	; 0x80
 8000f10:	0252      	lsls	r2, r2, #9
 8000f12:	4694      	mov	ip, r2
 8000f14:	4466      	add	r6, ip
 8000f16:	0400      	lsls	r0, r0, #16
 8000f18:	041a      	lsls	r2, r3, #16
 8000f1a:	0c00      	lsrs	r0, r0, #16
 8000f1c:	1812      	adds	r2, r2, r0
 8000f1e:	0194      	lsls	r4, r2, #6
 8000f20:	1e60      	subs	r0, r4, #1
 8000f22:	4184      	sbcs	r4, r0
 8000f24:	0c1b      	lsrs	r3, r3, #16
 8000f26:	0e92      	lsrs	r2, r2, #26
 8000f28:	199b      	adds	r3, r3, r6
 8000f2a:	4314      	orrs	r4, r2
 8000f2c:	019b      	lsls	r3, r3, #6
 8000f2e:	431c      	orrs	r4, r3
 8000f30:	011b      	lsls	r3, r3, #4
 8000f32:	d572      	bpl.n	800101a <__aeabi_fmul+0x212>
 8000f34:	2001      	movs	r0, #1
 8000f36:	0863      	lsrs	r3, r4, #1
 8000f38:	4004      	ands	r4, r0
 8000f3a:	431c      	orrs	r4, r3
 8000f3c:	0008      	movs	r0, r1
 8000f3e:	307f      	adds	r0, #127	; 0x7f
 8000f40:	2800      	cmp	r0, #0
 8000f42:	dd3c      	ble.n	8000fbe <__aeabi_fmul+0x1b6>
 8000f44:	0763      	lsls	r3, r4, #29
 8000f46:	d004      	beq.n	8000f52 <__aeabi_fmul+0x14a>
 8000f48:	230f      	movs	r3, #15
 8000f4a:	4023      	ands	r3, r4
 8000f4c:	2b04      	cmp	r3, #4
 8000f4e:	d000      	beq.n	8000f52 <__aeabi_fmul+0x14a>
 8000f50:	3404      	adds	r4, #4
 8000f52:	0123      	lsls	r3, r4, #4
 8000f54:	d503      	bpl.n	8000f5e <__aeabi_fmul+0x156>
 8000f56:	3180      	adds	r1, #128	; 0x80
 8000f58:	0008      	movs	r0, r1
 8000f5a:	4b37      	ldr	r3, [pc, #220]	; (8001038 <__aeabi_fmul+0x230>)
 8000f5c:	401c      	ands	r4, r3
 8000f5e:	28fe      	cmp	r0, #254	; 0xfe
 8000f60:	dcc0      	bgt.n	8000ee4 <__aeabi_fmul+0xdc>
 8000f62:	01a4      	lsls	r4, r4, #6
 8000f64:	0a64      	lsrs	r4, r4, #9
 8000f66:	b2c0      	uxtb	r0, r0
 8000f68:	e79a      	b.n	8000ea0 <__aeabi_fmul+0x98>
 8000f6a:	0037      	movs	r7, r6
 8000f6c:	e78e      	b.n	8000e8c <__aeabi_fmul+0x84>
 8000f6e:	4652      	mov	r2, sl
 8000f70:	2303      	movs	r3, #3
 8000f72:	431a      	orrs	r2, r3
 8000f74:	4692      	mov	sl, r2
 8000f76:	2003      	movs	r0, #3
 8000f78:	e771      	b.n	8000e5e <__aeabi_fmul+0x56>
 8000f7a:	4648      	mov	r0, r9
 8000f7c:	f002 f90a 	bl	8003194 <__clzsi2>
 8000f80:	464a      	mov	r2, r9
 8000f82:	1f43      	subs	r3, r0, #5
 8000f84:	409a      	lsls	r2, r3
 8000f86:	1a2d      	subs	r5, r5, r0
 8000f88:	4691      	mov	r9, r2
 8000f8a:	2000      	movs	r0, #0
 8000f8c:	3d76      	subs	r5, #118	; 0x76
 8000f8e:	e766      	b.n	8000e5e <__aeabi_fmul+0x56>
 8000f90:	230c      	movs	r3, #12
 8000f92:	469a      	mov	sl, r3
 8000f94:	3b09      	subs	r3, #9
 8000f96:	25ff      	movs	r5, #255	; 0xff
 8000f98:	469b      	mov	fp, r3
 8000f9a:	e74d      	b.n	8000e38 <__aeabi_fmul+0x30>
 8000f9c:	0020      	movs	r0, r4
 8000f9e:	f002 f8f9 	bl	8003194 <__clzsi2>
 8000fa2:	2576      	movs	r5, #118	; 0x76
 8000fa4:	1f43      	subs	r3, r0, #5
 8000fa6:	409c      	lsls	r4, r3
 8000fa8:	2300      	movs	r3, #0
 8000faa:	426d      	negs	r5, r5
 8000fac:	469a      	mov	sl, r3
 8000fae:	469b      	mov	fp, r3
 8000fb0:	1a2d      	subs	r5, r5, r0
 8000fb2:	e741      	b.n	8000e38 <__aeabi_fmul+0x30>
 8000fb4:	2480      	movs	r4, #128	; 0x80
 8000fb6:	2700      	movs	r7, #0
 8000fb8:	20ff      	movs	r0, #255	; 0xff
 8000fba:	03e4      	lsls	r4, r4, #15
 8000fbc:	e770      	b.n	8000ea0 <__aeabi_fmul+0x98>
 8000fbe:	2301      	movs	r3, #1
 8000fc0:	1a1b      	subs	r3, r3, r0
 8000fc2:	2b1b      	cmp	r3, #27
 8000fc4:	dd00      	ble.n	8000fc8 <__aeabi_fmul+0x1c0>
 8000fc6:	e769      	b.n	8000e9c <__aeabi_fmul+0x94>
 8000fc8:	319e      	adds	r1, #158	; 0x9e
 8000fca:	0020      	movs	r0, r4
 8000fcc:	408c      	lsls	r4, r1
 8000fce:	40d8      	lsrs	r0, r3
 8000fd0:	1e63      	subs	r3, r4, #1
 8000fd2:	419c      	sbcs	r4, r3
 8000fd4:	4304      	orrs	r4, r0
 8000fd6:	0763      	lsls	r3, r4, #29
 8000fd8:	d004      	beq.n	8000fe4 <__aeabi_fmul+0x1dc>
 8000fda:	230f      	movs	r3, #15
 8000fdc:	4023      	ands	r3, r4
 8000fde:	2b04      	cmp	r3, #4
 8000fe0:	d000      	beq.n	8000fe4 <__aeabi_fmul+0x1dc>
 8000fe2:	3404      	adds	r4, #4
 8000fe4:	0163      	lsls	r3, r4, #5
 8000fe6:	d51a      	bpl.n	800101e <__aeabi_fmul+0x216>
 8000fe8:	2001      	movs	r0, #1
 8000fea:	2400      	movs	r4, #0
 8000fec:	e758      	b.n	8000ea0 <__aeabi_fmul+0x98>
 8000fee:	2080      	movs	r0, #128	; 0x80
 8000ff0:	03c0      	lsls	r0, r0, #15
 8000ff2:	4204      	tst	r4, r0
 8000ff4:	d009      	beq.n	800100a <__aeabi_fmul+0x202>
 8000ff6:	464b      	mov	r3, r9
 8000ff8:	4203      	tst	r3, r0
 8000ffa:	d106      	bne.n	800100a <__aeabi_fmul+0x202>
 8000ffc:	464c      	mov	r4, r9
 8000ffe:	4304      	orrs	r4, r0
 8001000:	0264      	lsls	r4, r4, #9
 8001002:	4647      	mov	r7, r8
 8001004:	20ff      	movs	r0, #255	; 0xff
 8001006:	0a64      	lsrs	r4, r4, #9
 8001008:	e74a      	b.n	8000ea0 <__aeabi_fmul+0x98>
 800100a:	2080      	movs	r0, #128	; 0x80
 800100c:	03c0      	lsls	r0, r0, #15
 800100e:	4304      	orrs	r4, r0
 8001010:	0264      	lsls	r4, r4, #9
 8001012:	0037      	movs	r7, r6
 8001014:	20ff      	movs	r0, #255	; 0xff
 8001016:	0a64      	lsrs	r4, r4, #9
 8001018:	e742      	b.n	8000ea0 <__aeabi_fmul+0x98>
 800101a:	0029      	movs	r1, r5
 800101c:	e78e      	b.n	8000f3c <__aeabi_fmul+0x134>
 800101e:	01a4      	lsls	r4, r4, #6
 8001020:	2000      	movs	r0, #0
 8001022:	0a64      	lsrs	r4, r4, #9
 8001024:	e73c      	b.n	8000ea0 <__aeabi_fmul+0x98>
 8001026:	2080      	movs	r0, #128	; 0x80
 8001028:	03c0      	lsls	r0, r0, #15
 800102a:	4304      	orrs	r4, r0
 800102c:	0264      	lsls	r4, r4, #9
 800102e:	20ff      	movs	r0, #255	; 0xff
 8001030:	0a64      	lsrs	r4, r4, #9
 8001032:	e735      	b.n	8000ea0 <__aeabi_fmul+0x98>
 8001034:	0801fd74 	.word	0x0801fd74
 8001038:	f7ffffff 	.word	0xf7ffffff

0800103c <__aeabi_fsub>:
 800103c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800103e:	4646      	mov	r6, r8
 8001040:	46d6      	mov	lr, sl
 8001042:	464f      	mov	r7, r9
 8001044:	0243      	lsls	r3, r0, #9
 8001046:	0a5b      	lsrs	r3, r3, #9
 8001048:	00da      	lsls	r2, r3, #3
 800104a:	4694      	mov	ip, r2
 800104c:	024a      	lsls	r2, r1, #9
 800104e:	b5c0      	push	{r6, r7, lr}
 8001050:	0044      	lsls	r4, r0, #1
 8001052:	0a56      	lsrs	r6, r2, #9
 8001054:	1c05      	adds	r5, r0, #0
 8001056:	46b0      	mov	r8, r6
 8001058:	0e24      	lsrs	r4, r4, #24
 800105a:	004e      	lsls	r6, r1, #1
 800105c:	0992      	lsrs	r2, r2, #6
 800105e:	001f      	movs	r7, r3
 8001060:	0020      	movs	r0, r4
 8001062:	4692      	mov	sl, r2
 8001064:	0fed      	lsrs	r5, r5, #31
 8001066:	0e36      	lsrs	r6, r6, #24
 8001068:	0fc9      	lsrs	r1, r1, #31
 800106a:	2eff      	cmp	r6, #255	; 0xff
 800106c:	d100      	bne.n	8001070 <__aeabi_fsub+0x34>
 800106e:	e07f      	b.n	8001170 <__aeabi_fsub+0x134>
 8001070:	2201      	movs	r2, #1
 8001072:	4051      	eors	r1, r2
 8001074:	428d      	cmp	r5, r1
 8001076:	d051      	beq.n	800111c <__aeabi_fsub+0xe0>
 8001078:	1ba2      	subs	r2, r4, r6
 800107a:	4691      	mov	r9, r2
 800107c:	2a00      	cmp	r2, #0
 800107e:	dc00      	bgt.n	8001082 <__aeabi_fsub+0x46>
 8001080:	e07e      	b.n	8001180 <__aeabi_fsub+0x144>
 8001082:	2e00      	cmp	r6, #0
 8001084:	d100      	bne.n	8001088 <__aeabi_fsub+0x4c>
 8001086:	e099      	b.n	80011bc <__aeabi_fsub+0x180>
 8001088:	2cff      	cmp	r4, #255	; 0xff
 800108a:	d100      	bne.n	800108e <__aeabi_fsub+0x52>
 800108c:	e08c      	b.n	80011a8 <__aeabi_fsub+0x16c>
 800108e:	2380      	movs	r3, #128	; 0x80
 8001090:	4652      	mov	r2, sl
 8001092:	04db      	lsls	r3, r3, #19
 8001094:	431a      	orrs	r2, r3
 8001096:	4692      	mov	sl, r2
 8001098:	464a      	mov	r2, r9
 800109a:	2301      	movs	r3, #1
 800109c:	2a1b      	cmp	r2, #27
 800109e:	dc08      	bgt.n	80010b2 <__aeabi_fsub+0x76>
 80010a0:	4653      	mov	r3, sl
 80010a2:	2120      	movs	r1, #32
 80010a4:	40d3      	lsrs	r3, r2
 80010a6:	1a89      	subs	r1, r1, r2
 80010a8:	4652      	mov	r2, sl
 80010aa:	408a      	lsls	r2, r1
 80010ac:	1e51      	subs	r1, r2, #1
 80010ae:	418a      	sbcs	r2, r1
 80010b0:	4313      	orrs	r3, r2
 80010b2:	4662      	mov	r2, ip
 80010b4:	1ad3      	subs	r3, r2, r3
 80010b6:	015a      	lsls	r2, r3, #5
 80010b8:	d400      	bmi.n	80010bc <__aeabi_fsub+0x80>
 80010ba:	e0f3      	b.n	80012a4 <__aeabi_fsub+0x268>
 80010bc:	019b      	lsls	r3, r3, #6
 80010be:	099e      	lsrs	r6, r3, #6
 80010c0:	0030      	movs	r0, r6
 80010c2:	f002 f867 	bl	8003194 <__clzsi2>
 80010c6:	3805      	subs	r0, #5
 80010c8:	4086      	lsls	r6, r0
 80010ca:	4284      	cmp	r4, r0
 80010cc:	dd00      	ble.n	80010d0 <__aeabi_fsub+0x94>
 80010ce:	e0f7      	b.n	80012c0 <__aeabi_fsub+0x284>
 80010d0:	0032      	movs	r2, r6
 80010d2:	1b04      	subs	r4, r0, r4
 80010d4:	2020      	movs	r0, #32
 80010d6:	3401      	adds	r4, #1
 80010d8:	40e2      	lsrs	r2, r4
 80010da:	1b04      	subs	r4, r0, r4
 80010dc:	40a6      	lsls	r6, r4
 80010de:	0033      	movs	r3, r6
 80010e0:	1e5e      	subs	r6, r3, #1
 80010e2:	41b3      	sbcs	r3, r6
 80010e4:	2400      	movs	r4, #0
 80010e6:	4313      	orrs	r3, r2
 80010e8:	075a      	lsls	r2, r3, #29
 80010ea:	d004      	beq.n	80010f6 <__aeabi_fsub+0xba>
 80010ec:	220f      	movs	r2, #15
 80010ee:	401a      	ands	r2, r3
 80010f0:	2a04      	cmp	r2, #4
 80010f2:	d000      	beq.n	80010f6 <__aeabi_fsub+0xba>
 80010f4:	3304      	adds	r3, #4
 80010f6:	015a      	lsls	r2, r3, #5
 80010f8:	d400      	bmi.n	80010fc <__aeabi_fsub+0xc0>
 80010fa:	e0d6      	b.n	80012aa <__aeabi_fsub+0x26e>
 80010fc:	1c62      	adds	r2, r4, #1
 80010fe:	2cfe      	cmp	r4, #254	; 0xfe
 8001100:	d100      	bne.n	8001104 <__aeabi_fsub+0xc8>
 8001102:	e0da      	b.n	80012ba <__aeabi_fsub+0x27e>
 8001104:	019b      	lsls	r3, r3, #6
 8001106:	0a5f      	lsrs	r7, r3, #9
 8001108:	b2d0      	uxtb	r0, r2
 800110a:	05c0      	lsls	r0, r0, #23
 800110c:	4338      	orrs	r0, r7
 800110e:	07ed      	lsls	r5, r5, #31
 8001110:	4328      	orrs	r0, r5
 8001112:	bce0      	pop	{r5, r6, r7}
 8001114:	46ba      	mov	sl, r7
 8001116:	46b1      	mov	r9, r6
 8001118:	46a8      	mov	r8, r5
 800111a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800111c:	1ba2      	subs	r2, r4, r6
 800111e:	4691      	mov	r9, r2
 8001120:	2a00      	cmp	r2, #0
 8001122:	dd63      	ble.n	80011ec <__aeabi_fsub+0x1b0>
 8001124:	2e00      	cmp	r6, #0
 8001126:	d100      	bne.n	800112a <__aeabi_fsub+0xee>
 8001128:	e099      	b.n	800125e <__aeabi_fsub+0x222>
 800112a:	2cff      	cmp	r4, #255	; 0xff
 800112c:	d03c      	beq.n	80011a8 <__aeabi_fsub+0x16c>
 800112e:	2380      	movs	r3, #128	; 0x80
 8001130:	4652      	mov	r2, sl
 8001132:	04db      	lsls	r3, r3, #19
 8001134:	431a      	orrs	r2, r3
 8001136:	4692      	mov	sl, r2
 8001138:	464a      	mov	r2, r9
 800113a:	2301      	movs	r3, #1
 800113c:	2a1b      	cmp	r2, #27
 800113e:	dc08      	bgt.n	8001152 <__aeabi_fsub+0x116>
 8001140:	4653      	mov	r3, sl
 8001142:	2120      	movs	r1, #32
 8001144:	40d3      	lsrs	r3, r2
 8001146:	1a89      	subs	r1, r1, r2
 8001148:	4652      	mov	r2, sl
 800114a:	408a      	lsls	r2, r1
 800114c:	1e51      	subs	r1, r2, #1
 800114e:	418a      	sbcs	r2, r1
 8001150:	4313      	orrs	r3, r2
 8001152:	4463      	add	r3, ip
 8001154:	015a      	lsls	r2, r3, #5
 8001156:	d400      	bmi.n	800115a <__aeabi_fsub+0x11e>
 8001158:	e0a4      	b.n	80012a4 <__aeabi_fsub+0x268>
 800115a:	3401      	adds	r4, #1
 800115c:	2cff      	cmp	r4, #255	; 0xff
 800115e:	d100      	bne.n	8001162 <__aeabi_fsub+0x126>
 8001160:	e0ab      	b.n	80012ba <__aeabi_fsub+0x27e>
 8001162:	2201      	movs	r2, #1
 8001164:	4997      	ldr	r1, [pc, #604]	; (80013c4 <__aeabi_fsub+0x388>)
 8001166:	401a      	ands	r2, r3
 8001168:	085b      	lsrs	r3, r3, #1
 800116a:	400b      	ands	r3, r1
 800116c:	4313      	orrs	r3, r2
 800116e:	e7bb      	b.n	80010e8 <__aeabi_fsub+0xac>
 8001170:	2a00      	cmp	r2, #0
 8001172:	d032      	beq.n	80011da <__aeabi_fsub+0x19e>
 8001174:	428d      	cmp	r5, r1
 8001176:	d035      	beq.n	80011e4 <__aeabi_fsub+0x1a8>
 8001178:	22ff      	movs	r2, #255	; 0xff
 800117a:	4252      	negs	r2, r2
 800117c:	4691      	mov	r9, r2
 800117e:	44a1      	add	r9, r4
 8001180:	464a      	mov	r2, r9
 8001182:	2a00      	cmp	r2, #0
 8001184:	d051      	beq.n	800122a <__aeabi_fsub+0x1ee>
 8001186:	1b30      	subs	r0, r6, r4
 8001188:	2c00      	cmp	r4, #0
 800118a:	d000      	beq.n	800118e <__aeabi_fsub+0x152>
 800118c:	e09c      	b.n	80012c8 <__aeabi_fsub+0x28c>
 800118e:	4663      	mov	r3, ip
 8001190:	2b00      	cmp	r3, #0
 8001192:	d100      	bne.n	8001196 <__aeabi_fsub+0x15a>
 8001194:	e0df      	b.n	8001356 <__aeabi_fsub+0x31a>
 8001196:	3801      	subs	r0, #1
 8001198:	2800      	cmp	r0, #0
 800119a:	d100      	bne.n	800119e <__aeabi_fsub+0x162>
 800119c:	e0f7      	b.n	800138e <__aeabi_fsub+0x352>
 800119e:	2eff      	cmp	r6, #255	; 0xff
 80011a0:	d000      	beq.n	80011a4 <__aeabi_fsub+0x168>
 80011a2:	e099      	b.n	80012d8 <__aeabi_fsub+0x29c>
 80011a4:	000d      	movs	r5, r1
 80011a6:	4643      	mov	r3, r8
 80011a8:	2b00      	cmp	r3, #0
 80011aa:	d100      	bne.n	80011ae <__aeabi_fsub+0x172>
 80011ac:	e085      	b.n	80012ba <__aeabi_fsub+0x27e>
 80011ae:	2780      	movs	r7, #128	; 0x80
 80011b0:	03ff      	lsls	r7, r7, #15
 80011b2:	431f      	orrs	r7, r3
 80011b4:	027f      	lsls	r7, r7, #9
 80011b6:	20ff      	movs	r0, #255	; 0xff
 80011b8:	0a7f      	lsrs	r7, r7, #9
 80011ba:	e7a6      	b.n	800110a <__aeabi_fsub+0xce>
 80011bc:	4652      	mov	r2, sl
 80011be:	2a00      	cmp	r2, #0
 80011c0:	d074      	beq.n	80012ac <__aeabi_fsub+0x270>
 80011c2:	2201      	movs	r2, #1
 80011c4:	4252      	negs	r2, r2
 80011c6:	4690      	mov	r8, r2
 80011c8:	44c1      	add	r9, r8
 80011ca:	464a      	mov	r2, r9
 80011cc:	2a00      	cmp	r2, #0
 80011ce:	d100      	bne.n	80011d2 <__aeabi_fsub+0x196>
 80011d0:	e0c8      	b.n	8001364 <__aeabi_fsub+0x328>
 80011d2:	2cff      	cmp	r4, #255	; 0xff
 80011d4:	d000      	beq.n	80011d8 <__aeabi_fsub+0x19c>
 80011d6:	e75f      	b.n	8001098 <__aeabi_fsub+0x5c>
 80011d8:	e7e6      	b.n	80011a8 <__aeabi_fsub+0x16c>
 80011da:	2201      	movs	r2, #1
 80011dc:	4051      	eors	r1, r2
 80011de:	42a9      	cmp	r1, r5
 80011e0:	d000      	beq.n	80011e4 <__aeabi_fsub+0x1a8>
 80011e2:	e749      	b.n	8001078 <__aeabi_fsub+0x3c>
 80011e4:	22ff      	movs	r2, #255	; 0xff
 80011e6:	4252      	negs	r2, r2
 80011e8:	4691      	mov	r9, r2
 80011ea:	44a1      	add	r9, r4
 80011ec:	464a      	mov	r2, r9
 80011ee:	2a00      	cmp	r2, #0
 80011f0:	d043      	beq.n	800127a <__aeabi_fsub+0x23e>
 80011f2:	1b31      	subs	r1, r6, r4
 80011f4:	2c00      	cmp	r4, #0
 80011f6:	d100      	bne.n	80011fa <__aeabi_fsub+0x1be>
 80011f8:	e08c      	b.n	8001314 <__aeabi_fsub+0x2d8>
 80011fa:	2eff      	cmp	r6, #255	; 0xff
 80011fc:	d100      	bne.n	8001200 <__aeabi_fsub+0x1c4>
 80011fe:	e092      	b.n	8001326 <__aeabi_fsub+0x2ea>
 8001200:	2380      	movs	r3, #128	; 0x80
 8001202:	4662      	mov	r2, ip
 8001204:	04db      	lsls	r3, r3, #19
 8001206:	431a      	orrs	r2, r3
 8001208:	4694      	mov	ip, r2
 800120a:	2301      	movs	r3, #1
 800120c:	291b      	cmp	r1, #27
 800120e:	dc09      	bgt.n	8001224 <__aeabi_fsub+0x1e8>
 8001210:	2020      	movs	r0, #32
 8001212:	4663      	mov	r3, ip
 8001214:	4662      	mov	r2, ip
 8001216:	40cb      	lsrs	r3, r1
 8001218:	1a41      	subs	r1, r0, r1
 800121a:	408a      	lsls	r2, r1
 800121c:	0011      	movs	r1, r2
 800121e:	1e48      	subs	r0, r1, #1
 8001220:	4181      	sbcs	r1, r0
 8001222:	430b      	orrs	r3, r1
 8001224:	0034      	movs	r4, r6
 8001226:	4453      	add	r3, sl
 8001228:	e794      	b.n	8001154 <__aeabi_fsub+0x118>
 800122a:	22fe      	movs	r2, #254	; 0xfe
 800122c:	1c66      	adds	r6, r4, #1
 800122e:	4232      	tst	r2, r6
 8001230:	d164      	bne.n	80012fc <__aeabi_fsub+0x2c0>
 8001232:	2c00      	cmp	r4, #0
 8001234:	d000      	beq.n	8001238 <__aeabi_fsub+0x1fc>
 8001236:	e082      	b.n	800133e <__aeabi_fsub+0x302>
 8001238:	4663      	mov	r3, ip
 800123a:	2b00      	cmp	r3, #0
 800123c:	d100      	bne.n	8001240 <__aeabi_fsub+0x204>
 800123e:	e0ab      	b.n	8001398 <__aeabi_fsub+0x35c>
 8001240:	4653      	mov	r3, sl
 8001242:	2b00      	cmp	r3, #0
 8001244:	d100      	bne.n	8001248 <__aeabi_fsub+0x20c>
 8001246:	e760      	b.n	800110a <__aeabi_fsub+0xce>
 8001248:	4663      	mov	r3, ip
 800124a:	4652      	mov	r2, sl
 800124c:	1a9b      	subs	r3, r3, r2
 800124e:	015a      	lsls	r2, r3, #5
 8001250:	d400      	bmi.n	8001254 <__aeabi_fsub+0x218>
 8001252:	e0aa      	b.n	80013aa <__aeabi_fsub+0x36e>
 8001254:	4663      	mov	r3, ip
 8001256:	4652      	mov	r2, sl
 8001258:	000d      	movs	r5, r1
 800125a:	1ad3      	subs	r3, r2, r3
 800125c:	e744      	b.n	80010e8 <__aeabi_fsub+0xac>
 800125e:	4652      	mov	r2, sl
 8001260:	2a00      	cmp	r2, #0
 8001262:	d023      	beq.n	80012ac <__aeabi_fsub+0x270>
 8001264:	2201      	movs	r2, #1
 8001266:	4252      	negs	r2, r2
 8001268:	4690      	mov	r8, r2
 800126a:	44c1      	add	r9, r8
 800126c:	464a      	mov	r2, r9
 800126e:	2a00      	cmp	r2, #0
 8001270:	d075      	beq.n	800135e <__aeabi_fsub+0x322>
 8001272:	2cff      	cmp	r4, #255	; 0xff
 8001274:	d000      	beq.n	8001278 <__aeabi_fsub+0x23c>
 8001276:	e75f      	b.n	8001138 <__aeabi_fsub+0xfc>
 8001278:	e796      	b.n	80011a8 <__aeabi_fsub+0x16c>
 800127a:	26fe      	movs	r6, #254	; 0xfe
 800127c:	3401      	adds	r4, #1
 800127e:	4226      	tst	r6, r4
 8001280:	d153      	bne.n	800132a <__aeabi_fsub+0x2ee>
 8001282:	2800      	cmp	r0, #0
 8001284:	d172      	bne.n	800136c <__aeabi_fsub+0x330>
 8001286:	4663      	mov	r3, ip
 8001288:	2b00      	cmp	r3, #0
 800128a:	d100      	bne.n	800128e <__aeabi_fsub+0x252>
 800128c:	e093      	b.n	80013b6 <__aeabi_fsub+0x37a>
 800128e:	4653      	mov	r3, sl
 8001290:	2b00      	cmp	r3, #0
 8001292:	d100      	bne.n	8001296 <__aeabi_fsub+0x25a>
 8001294:	e739      	b.n	800110a <__aeabi_fsub+0xce>
 8001296:	4463      	add	r3, ip
 8001298:	2400      	movs	r4, #0
 800129a:	015a      	lsls	r2, r3, #5
 800129c:	d502      	bpl.n	80012a4 <__aeabi_fsub+0x268>
 800129e:	4a4a      	ldr	r2, [pc, #296]	; (80013c8 <__aeabi_fsub+0x38c>)
 80012a0:	3401      	adds	r4, #1
 80012a2:	4013      	ands	r3, r2
 80012a4:	075a      	lsls	r2, r3, #29
 80012a6:	d000      	beq.n	80012aa <__aeabi_fsub+0x26e>
 80012a8:	e720      	b.n	80010ec <__aeabi_fsub+0xb0>
 80012aa:	08db      	lsrs	r3, r3, #3
 80012ac:	2cff      	cmp	r4, #255	; 0xff
 80012ae:	d100      	bne.n	80012b2 <__aeabi_fsub+0x276>
 80012b0:	e77a      	b.n	80011a8 <__aeabi_fsub+0x16c>
 80012b2:	025b      	lsls	r3, r3, #9
 80012b4:	0a5f      	lsrs	r7, r3, #9
 80012b6:	b2e0      	uxtb	r0, r4
 80012b8:	e727      	b.n	800110a <__aeabi_fsub+0xce>
 80012ba:	20ff      	movs	r0, #255	; 0xff
 80012bc:	2700      	movs	r7, #0
 80012be:	e724      	b.n	800110a <__aeabi_fsub+0xce>
 80012c0:	4b41      	ldr	r3, [pc, #260]	; (80013c8 <__aeabi_fsub+0x38c>)
 80012c2:	1a24      	subs	r4, r4, r0
 80012c4:	4033      	ands	r3, r6
 80012c6:	e70f      	b.n	80010e8 <__aeabi_fsub+0xac>
 80012c8:	2eff      	cmp	r6, #255	; 0xff
 80012ca:	d100      	bne.n	80012ce <__aeabi_fsub+0x292>
 80012cc:	e76a      	b.n	80011a4 <__aeabi_fsub+0x168>
 80012ce:	2380      	movs	r3, #128	; 0x80
 80012d0:	4662      	mov	r2, ip
 80012d2:	04db      	lsls	r3, r3, #19
 80012d4:	431a      	orrs	r2, r3
 80012d6:	4694      	mov	ip, r2
 80012d8:	2301      	movs	r3, #1
 80012da:	281b      	cmp	r0, #27
 80012dc:	dc09      	bgt.n	80012f2 <__aeabi_fsub+0x2b6>
 80012de:	2420      	movs	r4, #32
 80012e0:	4663      	mov	r3, ip
 80012e2:	4662      	mov	r2, ip
 80012e4:	40c3      	lsrs	r3, r0
 80012e6:	1a20      	subs	r0, r4, r0
 80012e8:	4082      	lsls	r2, r0
 80012ea:	0010      	movs	r0, r2
 80012ec:	1e44      	subs	r4, r0, #1
 80012ee:	41a0      	sbcs	r0, r4
 80012f0:	4303      	orrs	r3, r0
 80012f2:	4652      	mov	r2, sl
 80012f4:	000d      	movs	r5, r1
 80012f6:	0034      	movs	r4, r6
 80012f8:	1ad3      	subs	r3, r2, r3
 80012fa:	e6dc      	b.n	80010b6 <__aeabi_fsub+0x7a>
 80012fc:	4663      	mov	r3, ip
 80012fe:	4652      	mov	r2, sl
 8001300:	1a9e      	subs	r6, r3, r2
 8001302:	0173      	lsls	r3, r6, #5
 8001304:	d417      	bmi.n	8001336 <__aeabi_fsub+0x2fa>
 8001306:	2e00      	cmp	r6, #0
 8001308:	d000      	beq.n	800130c <__aeabi_fsub+0x2d0>
 800130a:	e6d9      	b.n	80010c0 <__aeabi_fsub+0x84>
 800130c:	2500      	movs	r5, #0
 800130e:	2000      	movs	r0, #0
 8001310:	2700      	movs	r7, #0
 8001312:	e6fa      	b.n	800110a <__aeabi_fsub+0xce>
 8001314:	4663      	mov	r3, ip
 8001316:	2b00      	cmp	r3, #0
 8001318:	d044      	beq.n	80013a4 <__aeabi_fsub+0x368>
 800131a:	3901      	subs	r1, #1
 800131c:	2900      	cmp	r1, #0
 800131e:	d04c      	beq.n	80013ba <__aeabi_fsub+0x37e>
 8001320:	2eff      	cmp	r6, #255	; 0xff
 8001322:	d000      	beq.n	8001326 <__aeabi_fsub+0x2ea>
 8001324:	e771      	b.n	800120a <__aeabi_fsub+0x1ce>
 8001326:	4643      	mov	r3, r8
 8001328:	e73e      	b.n	80011a8 <__aeabi_fsub+0x16c>
 800132a:	2cff      	cmp	r4, #255	; 0xff
 800132c:	d0c5      	beq.n	80012ba <__aeabi_fsub+0x27e>
 800132e:	4652      	mov	r2, sl
 8001330:	4462      	add	r2, ip
 8001332:	0853      	lsrs	r3, r2, #1
 8001334:	e7b6      	b.n	80012a4 <__aeabi_fsub+0x268>
 8001336:	4663      	mov	r3, ip
 8001338:	000d      	movs	r5, r1
 800133a:	1ad6      	subs	r6, r2, r3
 800133c:	e6c0      	b.n	80010c0 <__aeabi_fsub+0x84>
 800133e:	4662      	mov	r2, ip
 8001340:	2a00      	cmp	r2, #0
 8001342:	d116      	bne.n	8001372 <__aeabi_fsub+0x336>
 8001344:	4653      	mov	r3, sl
 8001346:	2b00      	cmp	r3, #0
 8001348:	d000      	beq.n	800134c <__aeabi_fsub+0x310>
 800134a:	e72b      	b.n	80011a4 <__aeabi_fsub+0x168>
 800134c:	2780      	movs	r7, #128	; 0x80
 800134e:	2500      	movs	r5, #0
 8001350:	20ff      	movs	r0, #255	; 0xff
 8001352:	03ff      	lsls	r7, r7, #15
 8001354:	e6d9      	b.n	800110a <__aeabi_fsub+0xce>
 8001356:	000d      	movs	r5, r1
 8001358:	4643      	mov	r3, r8
 800135a:	0034      	movs	r4, r6
 800135c:	e7a6      	b.n	80012ac <__aeabi_fsub+0x270>
 800135e:	4653      	mov	r3, sl
 8001360:	4463      	add	r3, ip
 8001362:	e6f7      	b.n	8001154 <__aeabi_fsub+0x118>
 8001364:	4663      	mov	r3, ip
 8001366:	4652      	mov	r2, sl
 8001368:	1a9b      	subs	r3, r3, r2
 800136a:	e6a4      	b.n	80010b6 <__aeabi_fsub+0x7a>
 800136c:	4662      	mov	r2, ip
 800136e:	2a00      	cmp	r2, #0
 8001370:	d0d9      	beq.n	8001326 <__aeabi_fsub+0x2ea>
 8001372:	4652      	mov	r2, sl
 8001374:	2a00      	cmp	r2, #0
 8001376:	d100      	bne.n	800137a <__aeabi_fsub+0x33e>
 8001378:	e716      	b.n	80011a8 <__aeabi_fsub+0x16c>
 800137a:	2280      	movs	r2, #128	; 0x80
 800137c:	03d2      	lsls	r2, r2, #15
 800137e:	4213      	tst	r3, r2
 8001380:	d100      	bne.n	8001384 <__aeabi_fsub+0x348>
 8001382:	e711      	b.n	80011a8 <__aeabi_fsub+0x16c>
 8001384:	4640      	mov	r0, r8
 8001386:	4210      	tst	r0, r2
 8001388:	d000      	beq.n	800138c <__aeabi_fsub+0x350>
 800138a:	e70d      	b.n	80011a8 <__aeabi_fsub+0x16c>
 800138c:	e70a      	b.n	80011a4 <__aeabi_fsub+0x168>
 800138e:	4652      	mov	r2, sl
 8001390:	000d      	movs	r5, r1
 8001392:	0034      	movs	r4, r6
 8001394:	1ad3      	subs	r3, r2, r3
 8001396:	e68e      	b.n	80010b6 <__aeabi_fsub+0x7a>
 8001398:	4653      	mov	r3, sl
 800139a:	2b00      	cmp	r3, #0
 800139c:	d008      	beq.n	80013b0 <__aeabi_fsub+0x374>
 800139e:	000d      	movs	r5, r1
 80013a0:	4647      	mov	r7, r8
 80013a2:	e6b2      	b.n	800110a <__aeabi_fsub+0xce>
 80013a4:	4643      	mov	r3, r8
 80013a6:	0034      	movs	r4, r6
 80013a8:	e780      	b.n	80012ac <__aeabi_fsub+0x270>
 80013aa:	2b00      	cmp	r3, #0
 80013ac:	d000      	beq.n	80013b0 <__aeabi_fsub+0x374>
 80013ae:	e779      	b.n	80012a4 <__aeabi_fsub+0x268>
 80013b0:	2500      	movs	r5, #0
 80013b2:	2700      	movs	r7, #0
 80013b4:	e6a9      	b.n	800110a <__aeabi_fsub+0xce>
 80013b6:	4647      	mov	r7, r8
 80013b8:	e6a7      	b.n	800110a <__aeabi_fsub+0xce>
 80013ba:	4653      	mov	r3, sl
 80013bc:	0034      	movs	r4, r6
 80013be:	4463      	add	r3, ip
 80013c0:	e6c8      	b.n	8001154 <__aeabi_fsub+0x118>
 80013c2:	46c0      	nop			; (mov r8, r8)
 80013c4:	7dffffff 	.word	0x7dffffff
 80013c8:	fbffffff 	.word	0xfbffffff

080013cc <__aeabi_f2iz>:
 80013cc:	0241      	lsls	r1, r0, #9
 80013ce:	0042      	lsls	r2, r0, #1
 80013d0:	0fc3      	lsrs	r3, r0, #31
 80013d2:	0a49      	lsrs	r1, r1, #9
 80013d4:	2000      	movs	r0, #0
 80013d6:	0e12      	lsrs	r2, r2, #24
 80013d8:	2a7e      	cmp	r2, #126	; 0x7e
 80013da:	d903      	bls.n	80013e4 <__aeabi_f2iz+0x18>
 80013dc:	2a9d      	cmp	r2, #157	; 0x9d
 80013de:	d902      	bls.n	80013e6 <__aeabi_f2iz+0x1a>
 80013e0:	4a09      	ldr	r2, [pc, #36]	; (8001408 <__aeabi_f2iz+0x3c>)
 80013e2:	1898      	adds	r0, r3, r2
 80013e4:	4770      	bx	lr
 80013e6:	2080      	movs	r0, #128	; 0x80
 80013e8:	0400      	lsls	r0, r0, #16
 80013ea:	4301      	orrs	r1, r0
 80013ec:	2a95      	cmp	r2, #149	; 0x95
 80013ee:	dc07      	bgt.n	8001400 <__aeabi_f2iz+0x34>
 80013f0:	2096      	movs	r0, #150	; 0x96
 80013f2:	1a82      	subs	r2, r0, r2
 80013f4:	40d1      	lsrs	r1, r2
 80013f6:	4248      	negs	r0, r1
 80013f8:	2b00      	cmp	r3, #0
 80013fa:	d1f3      	bne.n	80013e4 <__aeabi_f2iz+0x18>
 80013fc:	0008      	movs	r0, r1
 80013fe:	e7f1      	b.n	80013e4 <__aeabi_f2iz+0x18>
 8001400:	3a96      	subs	r2, #150	; 0x96
 8001402:	4091      	lsls	r1, r2
 8001404:	e7f7      	b.n	80013f6 <__aeabi_f2iz+0x2a>
 8001406:	46c0      	nop			; (mov r8, r8)
 8001408:	7fffffff 	.word	0x7fffffff

0800140c <__aeabi_i2f>:
 800140c:	b570      	push	{r4, r5, r6, lr}
 800140e:	2800      	cmp	r0, #0
 8001410:	d013      	beq.n	800143a <__aeabi_i2f+0x2e>
 8001412:	17c3      	asrs	r3, r0, #31
 8001414:	18c5      	adds	r5, r0, r3
 8001416:	405d      	eors	r5, r3
 8001418:	0fc4      	lsrs	r4, r0, #31
 800141a:	0028      	movs	r0, r5
 800141c:	f001 feba 	bl	8003194 <__clzsi2>
 8001420:	239e      	movs	r3, #158	; 0x9e
 8001422:	0001      	movs	r1, r0
 8001424:	1a1b      	subs	r3, r3, r0
 8001426:	2b96      	cmp	r3, #150	; 0x96
 8001428:	dc0f      	bgt.n	800144a <__aeabi_i2f+0x3e>
 800142a:	2808      	cmp	r0, #8
 800142c:	dd01      	ble.n	8001432 <__aeabi_i2f+0x26>
 800142e:	3908      	subs	r1, #8
 8001430:	408d      	lsls	r5, r1
 8001432:	026d      	lsls	r5, r5, #9
 8001434:	0a6d      	lsrs	r5, r5, #9
 8001436:	b2d8      	uxtb	r0, r3
 8001438:	e002      	b.n	8001440 <__aeabi_i2f+0x34>
 800143a:	2400      	movs	r4, #0
 800143c:	2000      	movs	r0, #0
 800143e:	2500      	movs	r5, #0
 8001440:	05c0      	lsls	r0, r0, #23
 8001442:	4328      	orrs	r0, r5
 8001444:	07e4      	lsls	r4, r4, #31
 8001446:	4320      	orrs	r0, r4
 8001448:	bd70      	pop	{r4, r5, r6, pc}
 800144a:	2b99      	cmp	r3, #153	; 0x99
 800144c:	dd0b      	ble.n	8001466 <__aeabi_i2f+0x5a>
 800144e:	2205      	movs	r2, #5
 8001450:	002e      	movs	r6, r5
 8001452:	1a12      	subs	r2, r2, r0
 8001454:	40d6      	lsrs	r6, r2
 8001456:	0002      	movs	r2, r0
 8001458:	321b      	adds	r2, #27
 800145a:	4095      	lsls	r5, r2
 800145c:	0028      	movs	r0, r5
 800145e:	1e45      	subs	r5, r0, #1
 8001460:	41a8      	sbcs	r0, r5
 8001462:	0035      	movs	r5, r6
 8001464:	4305      	orrs	r5, r0
 8001466:	2905      	cmp	r1, #5
 8001468:	dd01      	ble.n	800146e <__aeabi_i2f+0x62>
 800146a:	1f4a      	subs	r2, r1, #5
 800146c:	4095      	lsls	r5, r2
 800146e:	002a      	movs	r2, r5
 8001470:	4e08      	ldr	r6, [pc, #32]	; (8001494 <__aeabi_i2f+0x88>)
 8001472:	4032      	ands	r2, r6
 8001474:	0768      	lsls	r0, r5, #29
 8001476:	d009      	beq.n	800148c <__aeabi_i2f+0x80>
 8001478:	200f      	movs	r0, #15
 800147a:	4028      	ands	r0, r5
 800147c:	2804      	cmp	r0, #4
 800147e:	d005      	beq.n	800148c <__aeabi_i2f+0x80>
 8001480:	3204      	adds	r2, #4
 8001482:	0150      	lsls	r0, r2, #5
 8001484:	d502      	bpl.n	800148c <__aeabi_i2f+0x80>
 8001486:	239f      	movs	r3, #159	; 0x9f
 8001488:	4032      	ands	r2, r6
 800148a:	1a5b      	subs	r3, r3, r1
 800148c:	0192      	lsls	r2, r2, #6
 800148e:	0a55      	lsrs	r5, r2, #9
 8001490:	b2d8      	uxtb	r0, r3
 8001492:	e7d5      	b.n	8001440 <__aeabi_i2f+0x34>
 8001494:	fbffffff 	.word	0xfbffffff

08001498 <__aeabi_ui2f>:
 8001498:	b570      	push	{r4, r5, r6, lr}
 800149a:	1e05      	subs	r5, r0, #0
 800149c:	d00e      	beq.n	80014bc <__aeabi_ui2f+0x24>
 800149e:	f001 fe79 	bl	8003194 <__clzsi2>
 80014a2:	239e      	movs	r3, #158	; 0x9e
 80014a4:	0004      	movs	r4, r0
 80014a6:	1a1b      	subs	r3, r3, r0
 80014a8:	2b96      	cmp	r3, #150	; 0x96
 80014aa:	dc0c      	bgt.n	80014c6 <__aeabi_ui2f+0x2e>
 80014ac:	2808      	cmp	r0, #8
 80014ae:	dd01      	ble.n	80014b4 <__aeabi_ui2f+0x1c>
 80014b0:	3c08      	subs	r4, #8
 80014b2:	40a5      	lsls	r5, r4
 80014b4:	026d      	lsls	r5, r5, #9
 80014b6:	0a6d      	lsrs	r5, r5, #9
 80014b8:	b2d8      	uxtb	r0, r3
 80014ba:	e001      	b.n	80014c0 <__aeabi_ui2f+0x28>
 80014bc:	2000      	movs	r0, #0
 80014be:	2500      	movs	r5, #0
 80014c0:	05c0      	lsls	r0, r0, #23
 80014c2:	4328      	orrs	r0, r5
 80014c4:	bd70      	pop	{r4, r5, r6, pc}
 80014c6:	2b99      	cmp	r3, #153	; 0x99
 80014c8:	dd09      	ble.n	80014de <__aeabi_ui2f+0x46>
 80014ca:	0002      	movs	r2, r0
 80014cc:	0029      	movs	r1, r5
 80014ce:	321b      	adds	r2, #27
 80014d0:	4091      	lsls	r1, r2
 80014d2:	1e4a      	subs	r2, r1, #1
 80014d4:	4191      	sbcs	r1, r2
 80014d6:	2205      	movs	r2, #5
 80014d8:	1a12      	subs	r2, r2, r0
 80014da:	40d5      	lsrs	r5, r2
 80014dc:	430d      	orrs	r5, r1
 80014de:	2c05      	cmp	r4, #5
 80014e0:	dd01      	ble.n	80014e6 <__aeabi_ui2f+0x4e>
 80014e2:	1f62      	subs	r2, r4, #5
 80014e4:	4095      	lsls	r5, r2
 80014e6:	0029      	movs	r1, r5
 80014e8:	4e08      	ldr	r6, [pc, #32]	; (800150c <__aeabi_ui2f+0x74>)
 80014ea:	4031      	ands	r1, r6
 80014ec:	076a      	lsls	r2, r5, #29
 80014ee:	d009      	beq.n	8001504 <__aeabi_ui2f+0x6c>
 80014f0:	200f      	movs	r0, #15
 80014f2:	4028      	ands	r0, r5
 80014f4:	2804      	cmp	r0, #4
 80014f6:	d005      	beq.n	8001504 <__aeabi_ui2f+0x6c>
 80014f8:	3104      	adds	r1, #4
 80014fa:	014a      	lsls	r2, r1, #5
 80014fc:	d502      	bpl.n	8001504 <__aeabi_ui2f+0x6c>
 80014fe:	239f      	movs	r3, #159	; 0x9f
 8001500:	4031      	ands	r1, r6
 8001502:	1b1b      	subs	r3, r3, r4
 8001504:	0189      	lsls	r1, r1, #6
 8001506:	0a4d      	lsrs	r5, r1, #9
 8001508:	b2d8      	uxtb	r0, r3
 800150a:	e7d9      	b.n	80014c0 <__aeabi_ui2f+0x28>
 800150c:	fbffffff 	.word	0xfbffffff

08001510 <__aeabi_dadd>:
 8001510:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001512:	464f      	mov	r7, r9
 8001514:	46d6      	mov	lr, sl
 8001516:	4646      	mov	r6, r8
 8001518:	000d      	movs	r5, r1
 800151a:	0001      	movs	r1, r0
 800151c:	0018      	movs	r0, r3
 800151e:	b5c0      	push	{r6, r7, lr}
 8001520:	0017      	movs	r7, r2
 8001522:	032b      	lsls	r3, r5, #12
 8001524:	0a5a      	lsrs	r2, r3, #9
 8001526:	0f4b      	lsrs	r3, r1, #29
 8001528:	4313      	orrs	r3, r2
 800152a:	00ca      	lsls	r2, r1, #3
 800152c:	4691      	mov	r9, r2
 800152e:	0302      	lsls	r2, r0, #12
 8001530:	006e      	lsls	r6, r5, #1
 8001532:	0041      	lsls	r1, r0, #1
 8001534:	0a52      	lsrs	r2, r2, #9
 8001536:	0fec      	lsrs	r4, r5, #31
 8001538:	0f7d      	lsrs	r5, r7, #29
 800153a:	4315      	orrs	r5, r2
 800153c:	0d76      	lsrs	r6, r6, #21
 800153e:	0d49      	lsrs	r1, r1, #21
 8001540:	0fc0      	lsrs	r0, r0, #31
 8001542:	4682      	mov	sl, r0
 8001544:	46ac      	mov	ip, r5
 8001546:	00ff      	lsls	r7, r7, #3
 8001548:	1a72      	subs	r2, r6, r1
 800154a:	4284      	cmp	r4, r0
 800154c:	d100      	bne.n	8001550 <__aeabi_dadd+0x40>
 800154e:	e098      	b.n	8001682 <__aeabi_dadd+0x172>
 8001550:	2a00      	cmp	r2, #0
 8001552:	dc00      	bgt.n	8001556 <__aeabi_dadd+0x46>
 8001554:	e081      	b.n	800165a <__aeabi_dadd+0x14a>
 8001556:	2900      	cmp	r1, #0
 8001558:	d100      	bne.n	800155c <__aeabi_dadd+0x4c>
 800155a:	e0b6      	b.n	80016ca <__aeabi_dadd+0x1ba>
 800155c:	49c9      	ldr	r1, [pc, #804]	; (8001884 <__aeabi_dadd+0x374>)
 800155e:	428e      	cmp	r6, r1
 8001560:	d100      	bne.n	8001564 <__aeabi_dadd+0x54>
 8001562:	e172      	b.n	800184a <__aeabi_dadd+0x33a>
 8001564:	2180      	movs	r1, #128	; 0x80
 8001566:	0028      	movs	r0, r5
 8001568:	0409      	lsls	r1, r1, #16
 800156a:	4308      	orrs	r0, r1
 800156c:	4684      	mov	ip, r0
 800156e:	2a38      	cmp	r2, #56	; 0x38
 8001570:	dd00      	ble.n	8001574 <__aeabi_dadd+0x64>
 8001572:	e15e      	b.n	8001832 <__aeabi_dadd+0x322>
 8001574:	2a1f      	cmp	r2, #31
 8001576:	dd00      	ble.n	800157a <__aeabi_dadd+0x6a>
 8001578:	e1ee      	b.n	8001958 <__aeabi_dadd+0x448>
 800157a:	2020      	movs	r0, #32
 800157c:	0039      	movs	r1, r7
 800157e:	4665      	mov	r5, ip
 8001580:	1a80      	subs	r0, r0, r2
 8001582:	4087      	lsls	r7, r0
 8001584:	40d1      	lsrs	r1, r2
 8001586:	4085      	lsls	r5, r0
 8001588:	430d      	orrs	r5, r1
 800158a:	0039      	movs	r1, r7
 800158c:	1e4f      	subs	r7, r1, #1
 800158e:	41b9      	sbcs	r1, r7
 8001590:	4667      	mov	r7, ip
 8001592:	40d7      	lsrs	r7, r2
 8001594:	4329      	orrs	r1, r5
 8001596:	1bdb      	subs	r3, r3, r7
 8001598:	464a      	mov	r2, r9
 800159a:	1a55      	subs	r5, r2, r1
 800159c:	45a9      	cmp	r9, r5
 800159e:	4189      	sbcs	r1, r1
 80015a0:	4249      	negs	r1, r1
 80015a2:	1a5b      	subs	r3, r3, r1
 80015a4:	4698      	mov	r8, r3
 80015a6:	4643      	mov	r3, r8
 80015a8:	021b      	lsls	r3, r3, #8
 80015aa:	d400      	bmi.n	80015ae <__aeabi_dadd+0x9e>
 80015ac:	e0cc      	b.n	8001748 <__aeabi_dadd+0x238>
 80015ae:	4643      	mov	r3, r8
 80015b0:	025b      	lsls	r3, r3, #9
 80015b2:	0a5b      	lsrs	r3, r3, #9
 80015b4:	4698      	mov	r8, r3
 80015b6:	4643      	mov	r3, r8
 80015b8:	2b00      	cmp	r3, #0
 80015ba:	d100      	bne.n	80015be <__aeabi_dadd+0xae>
 80015bc:	e12c      	b.n	8001818 <__aeabi_dadd+0x308>
 80015be:	4640      	mov	r0, r8
 80015c0:	f001 fde8 	bl	8003194 <__clzsi2>
 80015c4:	0001      	movs	r1, r0
 80015c6:	3908      	subs	r1, #8
 80015c8:	2220      	movs	r2, #32
 80015ca:	0028      	movs	r0, r5
 80015cc:	4643      	mov	r3, r8
 80015ce:	1a52      	subs	r2, r2, r1
 80015d0:	408b      	lsls	r3, r1
 80015d2:	40d0      	lsrs	r0, r2
 80015d4:	408d      	lsls	r5, r1
 80015d6:	4303      	orrs	r3, r0
 80015d8:	428e      	cmp	r6, r1
 80015da:	dd00      	ble.n	80015de <__aeabi_dadd+0xce>
 80015dc:	e117      	b.n	800180e <__aeabi_dadd+0x2fe>
 80015de:	1b8e      	subs	r6, r1, r6
 80015e0:	1c72      	adds	r2, r6, #1
 80015e2:	2a1f      	cmp	r2, #31
 80015e4:	dd00      	ble.n	80015e8 <__aeabi_dadd+0xd8>
 80015e6:	e1a7      	b.n	8001938 <__aeabi_dadd+0x428>
 80015e8:	2120      	movs	r1, #32
 80015ea:	0018      	movs	r0, r3
 80015ec:	002e      	movs	r6, r5
 80015ee:	1a89      	subs	r1, r1, r2
 80015f0:	408d      	lsls	r5, r1
 80015f2:	4088      	lsls	r0, r1
 80015f4:	40d6      	lsrs	r6, r2
 80015f6:	40d3      	lsrs	r3, r2
 80015f8:	1e69      	subs	r1, r5, #1
 80015fa:	418d      	sbcs	r5, r1
 80015fc:	4330      	orrs	r0, r6
 80015fe:	4698      	mov	r8, r3
 8001600:	2600      	movs	r6, #0
 8001602:	4305      	orrs	r5, r0
 8001604:	076b      	lsls	r3, r5, #29
 8001606:	d009      	beq.n	800161c <__aeabi_dadd+0x10c>
 8001608:	230f      	movs	r3, #15
 800160a:	402b      	ands	r3, r5
 800160c:	2b04      	cmp	r3, #4
 800160e:	d005      	beq.n	800161c <__aeabi_dadd+0x10c>
 8001610:	1d2b      	adds	r3, r5, #4
 8001612:	42ab      	cmp	r3, r5
 8001614:	41ad      	sbcs	r5, r5
 8001616:	426d      	negs	r5, r5
 8001618:	44a8      	add	r8, r5
 800161a:	001d      	movs	r5, r3
 800161c:	4643      	mov	r3, r8
 800161e:	021b      	lsls	r3, r3, #8
 8001620:	d400      	bmi.n	8001624 <__aeabi_dadd+0x114>
 8001622:	e094      	b.n	800174e <__aeabi_dadd+0x23e>
 8001624:	4b97      	ldr	r3, [pc, #604]	; (8001884 <__aeabi_dadd+0x374>)
 8001626:	1c72      	adds	r2, r6, #1
 8001628:	429a      	cmp	r2, r3
 800162a:	d100      	bne.n	800162e <__aeabi_dadd+0x11e>
 800162c:	e09d      	b.n	800176a <__aeabi_dadd+0x25a>
 800162e:	4641      	mov	r1, r8
 8001630:	4b95      	ldr	r3, [pc, #596]	; (8001888 <__aeabi_dadd+0x378>)
 8001632:	08ed      	lsrs	r5, r5, #3
 8001634:	4019      	ands	r1, r3
 8001636:	000b      	movs	r3, r1
 8001638:	0552      	lsls	r2, r2, #21
 800163a:	0749      	lsls	r1, r1, #29
 800163c:	025b      	lsls	r3, r3, #9
 800163e:	4329      	orrs	r1, r5
 8001640:	0b1b      	lsrs	r3, r3, #12
 8001642:	0d52      	lsrs	r2, r2, #21
 8001644:	0512      	lsls	r2, r2, #20
 8001646:	4313      	orrs	r3, r2
 8001648:	07e4      	lsls	r4, r4, #31
 800164a:	4323      	orrs	r3, r4
 800164c:	0008      	movs	r0, r1
 800164e:	0019      	movs	r1, r3
 8001650:	bce0      	pop	{r5, r6, r7}
 8001652:	46ba      	mov	sl, r7
 8001654:	46b1      	mov	r9, r6
 8001656:	46a8      	mov	r8, r5
 8001658:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800165a:	2a00      	cmp	r2, #0
 800165c:	d043      	beq.n	80016e6 <__aeabi_dadd+0x1d6>
 800165e:	1b8a      	subs	r2, r1, r6
 8001660:	2e00      	cmp	r6, #0
 8001662:	d000      	beq.n	8001666 <__aeabi_dadd+0x156>
 8001664:	e12a      	b.n	80018bc <__aeabi_dadd+0x3ac>
 8001666:	464c      	mov	r4, r9
 8001668:	431c      	orrs	r4, r3
 800166a:	d100      	bne.n	800166e <__aeabi_dadd+0x15e>
 800166c:	e1d1      	b.n	8001a12 <__aeabi_dadd+0x502>
 800166e:	1e54      	subs	r4, r2, #1
 8001670:	2a01      	cmp	r2, #1
 8001672:	d100      	bne.n	8001676 <__aeabi_dadd+0x166>
 8001674:	e21f      	b.n	8001ab6 <__aeabi_dadd+0x5a6>
 8001676:	4d83      	ldr	r5, [pc, #524]	; (8001884 <__aeabi_dadd+0x374>)
 8001678:	42aa      	cmp	r2, r5
 800167a:	d100      	bne.n	800167e <__aeabi_dadd+0x16e>
 800167c:	e272      	b.n	8001b64 <__aeabi_dadd+0x654>
 800167e:	0022      	movs	r2, r4
 8001680:	e123      	b.n	80018ca <__aeabi_dadd+0x3ba>
 8001682:	2a00      	cmp	r2, #0
 8001684:	dc00      	bgt.n	8001688 <__aeabi_dadd+0x178>
 8001686:	e098      	b.n	80017ba <__aeabi_dadd+0x2aa>
 8001688:	2900      	cmp	r1, #0
 800168a:	d042      	beq.n	8001712 <__aeabi_dadd+0x202>
 800168c:	497d      	ldr	r1, [pc, #500]	; (8001884 <__aeabi_dadd+0x374>)
 800168e:	428e      	cmp	r6, r1
 8001690:	d100      	bne.n	8001694 <__aeabi_dadd+0x184>
 8001692:	e0da      	b.n	800184a <__aeabi_dadd+0x33a>
 8001694:	2180      	movs	r1, #128	; 0x80
 8001696:	0028      	movs	r0, r5
 8001698:	0409      	lsls	r1, r1, #16
 800169a:	4308      	orrs	r0, r1
 800169c:	4684      	mov	ip, r0
 800169e:	2a38      	cmp	r2, #56	; 0x38
 80016a0:	dd00      	ble.n	80016a4 <__aeabi_dadd+0x194>
 80016a2:	e129      	b.n	80018f8 <__aeabi_dadd+0x3e8>
 80016a4:	2a1f      	cmp	r2, #31
 80016a6:	dc00      	bgt.n	80016aa <__aeabi_dadd+0x19a>
 80016a8:	e187      	b.n	80019ba <__aeabi_dadd+0x4aa>
 80016aa:	0011      	movs	r1, r2
 80016ac:	4665      	mov	r5, ip
 80016ae:	3920      	subs	r1, #32
 80016b0:	40cd      	lsrs	r5, r1
 80016b2:	2a20      	cmp	r2, #32
 80016b4:	d004      	beq.n	80016c0 <__aeabi_dadd+0x1b0>
 80016b6:	2040      	movs	r0, #64	; 0x40
 80016b8:	4661      	mov	r1, ip
 80016ba:	1a82      	subs	r2, r0, r2
 80016bc:	4091      	lsls	r1, r2
 80016be:	430f      	orrs	r7, r1
 80016c0:	0039      	movs	r1, r7
 80016c2:	1e4f      	subs	r7, r1, #1
 80016c4:	41b9      	sbcs	r1, r7
 80016c6:	430d      	orrs	r5, r1
 80016c8:	e11b      	b.n	8001902 <__aeabi_dadd+0x3f2>
 80016ca:	0029      	movs	r1, r5
 80016cc:	4339      	orrs	r1, r7
 80016ce:	d100      	bne.n	80016d2 <__aeabi_dadd+0x1c2>
 80016d0:	e0b5      	b.n	800183e <__aeabi_dadd+0x32e>
 80016d2:	1e51      	subs	r1, r2, #1
 80016d4:	2a01      	cmp	r2, #1
 80016d6:	d100      	bne.n	80016da <__aeabi_dadd+0x1ca>
 80016d8:	e1ab      	b.n	8001a32 <__aeabi_dadd+0x522>
 80016da:	486a      	ldr	r0, [pc, #424]	; (8001884 <__aeabi_dadd+0x374>)
 80016dc:	4282      	cmp	r2, r0
 80016de:	d100      	bne.n	80016e2 <__aeabi_dadd+0x1d2>
 80016e0:	e1b2      	b.n	8001a48 <__aeabi_dadd+0x538>
 80016e2:	000a      	movs	r2, r1
 80016e4:	e743      	b.n	800156e <__aeabi_dadd+0x5e>
 80016e6:	4969      	ldr	r1, [pc, #420]	; (800188c <__aeabi_dadd+0x37c>)
 80016e8:	1c75      	adds	r5, r6, #1
 80016ea:	420d      	tst	r5, r1
 80016ec:	d000      	beq.n	80016f0 <__aeabi_dadd+0x1e0>
 80016ee:	e0cf      	b.n	8001890 <__aeabi_dadd+0x380>
 80016f0:	2e00      	cmp	r6, #0
 80016f2:	d000      	beq.n	80016f6 <__aeabi_dadd+0x1e6>
 80016f4:	e193      	b.n	8001a1e <__aeabi_dadd+0x50e>
 80016f6:	4649      	mov	r1, r9
 80016f8:	4319      	orrs	r1, r3
 80016fa:	d100      	bne.n	80016fe <__aeabi_dadd+0x1ee>
 80016fc:	e1d1      	b.n	8001aa2 <__aeabi_dadd+0x592>
 80016fe:	4661      	mov	r1, ip
 8001700:	4339      	orrs	r1, r7
 8001702:	d000      	beq.n	8001706 <__aeabi_dadd+0x1f6>
 8001704:	e1e3      	b.n	8001ace <__aeabi_dadd+0x5be>
 8001706:	4649      	mov	r1, r9
 8001708:	0758      	lsls	r0, r3, #29
 800170a:	08c9      	lsrs	r1, r1, #3
 800170c:	4301      	orrs	r1, r0
 800170e:	08db      	lsrs	r3, r3, #3
 8001710:	e026      	b.n	8001760 <__aeabi_dadd+0x250>
 8001712:	0029      	movs	r1, r5
 8001714:	4339      	orrs	r1, r7
 8001716:	d100      	bne.n	800171a <__aeabi_dadd+0x20a>
 8001718:	e091      	b.n	800183e <__aeabi_dadd+0x32e>
 800171a:	1e51      	subs	r1, r2, #1
 800171c:	2a01      	cmp	r2, #1
 800171e:	d005      	beq.n	800172c <__aeabi_dadd+0x21c>
 8001720:	4858      	ldr	r0, [pc, #352]	; (8001884 <__aeabi_dadd+0x374>)
 8001722:	4282      	cmp	r2, r0
 8001724:	d100      	bne.n	8001728 <__aeabi_dadd+0x218>
 8001726:	e18f      	b.n	8001a48 <__aeabi_dadd+0x538>
 8001728:	000a      	movs	r2, r1
 800172a:	e7b8      	b.n	800169e <__aeabi_dadd+0x18e>
 800172c:	003d      	movs	r5, r7
 800172e:	444d      	add	r5, r9
 8001730:	454d      	cmp	r5, r9
 8001732:	4189      	sbcs	r1, r1
 8001734:	4463      	add	r3, ip
 8001736:	4698      	mov	r8, r3
 8001738:	4249      	negs	r1, r1
 800173a:	4488      	add	r8, r1
 800173c:	4643      	mov	r3, r8
 800173e:	2602      	movs	r6, #2
 8001740:	021b      	lsls	r3, r3, #8
 8001742:	d500      	bpl.n	8001746 <__aeabi_dadd+0x236>
 8001744:	e0eb      	b.n	800191e <__aeabi_dadd+0x40e>
 8001746:	3e01      	subs	r6, #1
 8001748:	076b      	lsls	r3, r5, #29
 800174a:	d000      	beq.n	800174e <__aeabi_dadd+0x23e>
 800174c:	e75c      	b.n	8001608 <__aeabi_dadd+0xf8>
 800174e:	4643      	mov	r3, r8
 8001750:	08e9      	lsrs	r1, r5, #3
 8001752:	075a      	lsls	r2, r3, #29
 8001754:	4311      	orrs	r1, r2
 8001756:	0032      	movs	r2, r6
 8001758:	08db      	lsrs	r3, r3, #3
 800175a:	484a      	ldr	r0, [pc, #296]	; (8001884 <__aeabi_dadd+0x374>)
 800175c:	4282      	cmp	r2, r0
 800175e:	d021      	beq.n	80017a4 <__aeabi_dadd+0x294>
 8001760:	031b      	lsls	r3, r3, #12
 8001762:	0552      	lsls	r2, r2, #21
 8001764:	0b1b      	lsrs	r3, r3, #12
 8001766:	0d52      	lsrs	r2, r2, #21
 8001768:	e76c      	b.n	8001644 <__aeabi_dadd+0x134>
 800176a:	2300      	movs	r3, #0
 800176c:	2100      	movs	r1, #0
 800176e:	e769      	b.n	8001644 <__aeabi_dadd+0x134>
 8001770:	002a      	movs	r2, r5
 8001772:	433a      	orrs	r2, r7
 8001774:	d069      	beq.n	800184a <__aeabi_dadd+0x33a>
 8001776:	464a      	mov	r2, r9
 8001778:	0758      	lsls	r0, r3, #29
 800177a:	08d1      	lsrs	r1, r2, #3
 800177c:	08da      	lsrs	r2, r3, #3
 800177e:	2380      	movs	r3, #128	; 0x80
 8001780:	031b      	lsls	r3, r3, #12
 8001782:	4308      	orrs	r0, r1
 8001784:	421a      	tst	r2, r3
 8001786:	d007      	beq.n	8001798 <__aeabi_dadd+0x288>
 8001788:	0029      	movs	r1, r5
 800178a:	08ed      	lsrs	r5, r5, #3
 800178c:	421d      	tst	r5, r3
 800178e:	d103      	bne.n	8001798 <__aeabi_dadd+0x288>
 8001790:	002a      	movs	r2, r5
 8001792:	08ff      	lsrs	r7, r7, #3
 8001794:	0748      	lsls	r0, r1, #29
 8001796:	4338      	orrs	r0, r7
 8001798:	0f43      	lsrs	r3, r0, #29
 800179a:	00c1      	lsls	r1, r0, #3
 800179c:	075b      	lsls	r3, r3, #29
 800179e:	08c9      	lsrs	r1, r1, #3
 80017a0:	4319      	orrs	r1, r3
 80017a2:	0013      	movs	r3, r2
 80017a4:	000a      	movs	r2, r1
 80017a6:	431a      	orrs	r2, r3
 80017a8:	d100      	bne.n	80017ac <__aeabi_dadd+0x29c>
 80017aa:	e213      	b.n	8001bd4 <__aeabi_dadd+0x6c4>
 80017ac:	2280      	movs	r2, #128	; 0x80
 80017ae:	0312      	lsls	r2, r2, #12
 80017b0:	4313      	orrs	r3, r2
 80017b2:	031b      	lsls	r3, r3, #12
 80017b4:	4a33      	ldr	r2, [pc, #204]	; (8001884 <__aeabi_dadd+0x374>)
 80017b6:	0b1b      	lsrs	r3, r3, #12
 80017b8:	e744      	b.n	8001644 <__aeabi_dadd+0x134>
 80017ba:	2a00      	cmp	r2, #0
 80017bc:	d04b      	beq.n	8001856 <__aeabi_dadd+0x346>
 80017be:	1b8a      	subs	r2, r1, r6
 80017c0:	2e00      	cmp	r6, #0
 80017c2:	d100      	bne.n	80017c6 <__aeabi_dadd+0x2b6>
 80017c4:	e0e7      	b.n	8001996 <__aeabi_dadd+0x486>
 80017c6:	482f      	ldr	r0, [pc, #188]	; (8001884 <__aeabi_dadd+0x374>)
 80017c8:	4281      	cmp	r1, r0
 80017ca:	d100      	bne.n	80017ce <__aeabi_dadd+0x2be>
 80017cc:	e195      	b.n	8001afa <__aeabi_dadd+0x5ea>
 80017ce:	2080      	movs	r0, #128	; 0x80
 80017d0:	0400      	lsls	r0, r0, #16
 80017d2:	4303      	orrs	r3, r0
 80017d4:	2a38      	cmp	r2, #56	; 0x38
 80017d6:	dd00      	ble.n	80017da <__aeabi_dadd+0x2ca>
 80017d8:	e143      	b.n	8001a62 <__aeabi_dadd+0x552>
 80017da:	2a1f      	cmp	r2, #31
 80017dc:	dd00      	ble.n	80017e0 <__aeabi_dadd+0x2d0>
 80017de:	e1db      	b.n	8001b98 <__aeabi_dadd+0x688>
 80017e0:	2020      	movs	r0, #32
 80017e2:	001d      	movs	r5, r3
 80017e4:	464e      	mov	r6, r9
 80017e6:	1a80      	subs	r0, r0, r2
 80017e8:	4085      	lsls	r5, r0
 80017ea:	40d6      	lsrs	r6, r2
 80017ec:	4335      	orrs	r5, r6
 80017ee:	464e      	mov	r6, r9
 80017f0:	4086      	lsls	r6, r0
 80017f2:	0030      	movs	r0, r6
 80017f4:	40d3      	lsrs	r3, r2
 80017f6:	1e46      	subs	r6, r0, #1
 80017f8:	41b0      	sbcs	r0, r6
 80017fa:	449c      	add	ip, r3
 80017fc:	4305      	orrs	r5, r0
 80017fe:	19ed      	adds	r5, r5, r7
 8001800:	42bd      	cmp	r5, r7
 8001802:	419b      	sbcs	r3, r3
 8001804:	425b      	negs	r3, r3
 8001806:	4463      	add	r3, ip
 8001808:	4698      	mov	r8, r3
 800180a:	000e      	movs	r6, r1
 800180c:	e07f      	b.n	800190e <__aeabi_dadd+0x3fe>
 800180e:	4a1e      	ldr	r2, [pc, #120]	; (8001888 <__aeabi_dadd+0x378>)
 8001810:	1a76      	subs	r6, r6, r1
 8001812:	4013      	ands	r3, r2
 8001814:	4698      	mov	r8, r3
 8001816:	e6f5      	b.n	8001604 <__aeabi_dadd+0xf4>
 8001818:	0028      	movs	r0, r5
 800181a:	f001 fcbb 	bl	8003194 <__clzsi2>
 800181e:	0001      	movs	r1, r0
 8001820:	3118      	adds	r1, #24
 8001822:	291f      	cmp	r1, #31
 8001824:	dc00      	bgt.n	8001828 <__aeabi_dadd+0x318>
 8001826:	e6cf      	b.n	80015c8 <__aeabi_dadd+0xb8>
 8001828:	002b      	movs	r3, r5
 800182a:	3808      	subs	r0, #8
 800182c:	4083      	lsls	r3, r0
 800182e:	2500      	movs	r5, #0
 8001830:	e6d2      	b.n	80015d8 <__aeabi_dadd+0xc8>
 8001832:	4662      	mov	r2, ip
 8001834:	433a      	orrs	r2, r7
 8001836:	0011      	movs	r1, r2
 8001838:	1e4f      	subs	r7, r1, #1
 800183a:	41b9      	sbcs	r1, r7
 800183c:	e6ac      	b.n	8001598 <__aeabi_dadd+0x88>
 800183e:	4649      	mov	r1, r9
 8001840:	0758      	lsls	r0, r3, #29
 8001842:	08c9      	lsrs	r1, r1, #3
 8001844:	4301      	orrs	r1, r0
 8001846:	08db      	lsrs	r3, r3, #3
 8001848:	e787      	b.n	800175a <__aeabi_dadd+0x24a>
 800184a:	4649      	mov	r1, r9
 800184c:	075a      	lsls	r2, r3, #29
 800184e:	08c9      	lsrs	r1, r1, #3
 8001850:	4311      	orrs	r1, r2
 8001852:	08db      	lsrs	r3, r3, #3
 8001854:	e7a6      	b.n	80017a4 <__aeabi_dadd+0x294>
 8001856:	490d      	ldr	r1, [pc, #52]	; (800188c <__aeabi_dadd+0x37c>)
 8001858:	1c70      	adds	r0, r6, #1
 800185a:	4208      	tst	r0, r1
 800185c:	d000      	beq.n	8001860 <__aeabi_dadd+0x350>
 800185e:	e0bb      	b.n	80019d8 <__aeabi_dadd+0x4c8>
 8001860:	2e00      	cmp	r6, #0
 8001862:	d000      	beq.n	8001866 <__aeabi_dadd+0x356>
 8001864:	e114      	b.n	8001a90 <__aeabi_dadd+0x580>
 8001866:	4649      	mov	r1, r9
 8001868:	4319      	orrs	r1, r3
 800186a:	d100      	bne.n	800186e <__aeabi_dadd+0x35e>
 800186c:	e175      	b.n	8001b5a <__aeabi_dadd+0x64a>
 800186e:	0029      	movs	r1, r5
 8001870:	4339      	orrs	r1, r7
 8001872:	d000      	beq.n	8001876 <__aeabi_dadd+0x366>
 8001874:	e17e      	b.n	8001b74 <__aeabi_dadd+0x664>
 8001876:	4649      	mov	r1, r9
 8001878:	0758      	lsls	r0, r3, #29
 800187a:	08c9      	lsrs	r1, r1, #3
 800187c:	4301      	orrs	r1, r0
 800187e:	08db      	lsrs	r3, r3, #3
 8001880:	e76e      	b.n	8001760 <__aeabi_dadd+0x250>
 8001882:	46c0      	nop			; (mov r8, r8)
 8001884:	000007ff 	.word	0x000007ff
 8001888:	ff7fffff 	.word	0xff7fffff
 800188c:	000007fe 	.word	0x000007fe
 8001890:	4649      	mov	r1, r9
 8001892:	1bcd      	subs	r5, r1, r7
 8001894:	4661      	mov	r1, ip
 8001896:	1a58      	subs	r0, r3, r1
 8001898:	45a9      	cmp	r9, r5
 800189a:	4189      	sbcs	r1, r1
 800189c:	4249      	negs	r1, r1
 800189e:	4688      	mov	r8, r1
 80018a0:	0001      	movs	r1, r0
 80018a2:	4640      	mov	r0, r8
 80018a4:	1a09      	subs	r1, r1, r0
 80018a6:	4688      	mov	r8, r1
 80018a8:	0209      	lsls	r1, r1, #8
 80018aa:	d500      	bpl.n	80018ae <__aeabi_dadd+0x39e>
 80018ac:	e0a6      	b.n	80019fc <__aeabi_dadd+0x4ec>
 80018ae:	4641      	mov	r1, r8
 80018b0:	4329      	orrs	r1, r5
 80018b2:	d000      	beq.n	80018b6 <__aeabi_dadd+0x3a6>
 80018b4:	e67f      	b.n	80015b6 <__aeabi_dadd+0xa6>
 80018b6:	2300      	movs	r3, #0
 80018b8:	2400      	movs	r4, #0
 80018ba:	e751      	b.n	8001760 <__aeabi_dadd+0x250>
 80018bc:	4cc7      	ldr	r4, [pc, #796]	; (8001bdc <__aeabi_dadd+0x6cc>)
 80018be:	42a1      	cmp	r1, r4
 80018c0:	d100      	bne.n	80018c4 <__aeabi_dadd+0x3b4>
 80018c2:	e0c7      	b.n	8001a54 <__aeabi_dadd+0x544>
 80018c4:	2480      	movs	r4, #128	; 0x80
 80018c6:	0424      	lsls	r4, r4, #16
 80018c8:	4323      	orrs	r3, r4
 80018ca:	2a38      	cmp	r2, #56	; 0x38
 80018cc:	dc54      	bgt.n	8001978 <__aeabi_dadd+0x468>
 80018ce:	2a1f      	cmp	r2, #31
 80018d0:	dd00      	ble.n	80018d4 <__aeabi_dadd+0x3c4>
 80018d2:	e0cc      	b.n	8001a6e <__aeabi_dadd+0x55e>
 80018d4:	2420      	movs	r4, #32
 80018d6:	4648      	mov	r0, r9
 80018d8:	1aa4      	subs	r4, r4, r2
 80018da:	001d      	movs	r5, r3
 80018dc:	464e      	mov	r6, r9
 80018de:	40a0      	lsls	r0, r4
 80018e0:	40d6      	lsrs	r6, r2
 80018e2:	40a5      	lsls	r5, r4
 80018e4:	0004      	movs	r4, r0
 80018e6:	40d3      	lsrs	r3, r2
 80018e8:	4662      	mov	r2, ip
 80018ea:	4335      	orrs	r5, r6
 80018ec:	1e66      	subs	r6, r4, #1
 80018ee:	41b4      	sbcs	r4, r6
 80018f0:	1ad3      	subs	r3, r2, r3
 80018f2:	469c      	mov	ip, r3
 80018f4:	4325      	orrs	r5, r4
 80018f6:	e044      	b.n	8001982 <__aeabi_dadd+0x472>
 80018f8:	4662      	mov	r2, ip
 80018fa:	433a      	orrs	r2, r7
 80018fc:	0015      	movs	r5, r2
 80018fe:	1e6f      	subs	r7, r5, #1
 8001900:	41bd      	sbcs	r5, r7
 8001902:	444d      	add	r5, r9
 8001904:	454d      	cmp	r5, r9
 8001906:	4189      	sbcs	r1, r1
 8001908:	4249      	negs	r1, r1
 800190a:	4688      	mov	r8, r1
 800190c:	4498      	add	r8, r3
 800190e:	4643      	mov	r3, r8
 8001910:	021b      	lsls	r3, r3, #8
 8001912:	d400      	bmi.n	8001916 <__aeabi_dadd+0x406>
 8001914:	e718      	b.n	8001748 <__aeabi_dadd+0x238>
 8001916:	4bb1      	ldr	r3, [pc, #708]	; (8001bdc <__aeabi_dadd+0x6cc>)
 8001918:	3601      	adds	r6, #1
 800191a:	429e      	cmp	r6, r3
 800191c:	d049      	beq.n	80019b2 <__aeabi_dadd+0x4a2>
 800191e:	4642      	mov	r2, r8
 8001920:	4baf      	ldr	r3, [pc, #700]	; (8001be0 <__aeabi_dadd+0x6d0>)
 8001922:	2101      	movs	r1, #1
 8001924:	401a      	ands	r2, r3
 8001926:	0013      	movs	r3, r2
 8001928:	086a      	lsrs	r2, r5, #1
 800192a:	400d      	ands	r5, r1
 800192c:	4315      	orrs	r5, r2
 800192e:	07d9      	lsls	r1, r3, #31
 8001930:	085b      	lsrs	r3, r3, #1
 8001932:	4698      	mov	r8, r3
 8001934:	430d      	orrs	r5, r1
 8001936:	e665      	b.n	8001604 <__aeabi_dadd+0xf4>
 8001938:	0018      	movs	r0, r3
 800193a:	3e1f      	subs	r6, #31
 800193c:	40f0      	lsrs	r0, r6
 800193e:	2a20      	cmp	r2, #32
 8001940:	d003      	beq.n	800194a <__aeabi_dadd+0x43a>
 8001942:	2140      	movs	r1, #64	; 0x40
 8001944:	1a8a      	subs	r2, r1, r2
 8001946:	4093      	lsls	r3, r2
 8001948:	431d      	orrs	r5, r3
 800194a:	1e69      	subs	r1, r5, #1
 800194c:	418d      	sbcs	r5, r1
 800194e:	2300      	movs	r3, #0
 8001950:	2600      	movs	r6, #0
 8001952:	4698      	mov	r8, r3
 8001954:	4305      	orrs	r5, r0
 8001956:	e6f7      	b.n	8001748 <__aeabi_dadd+0x238>
 8001958:	0011      	movs	r1, r2
 800195a:	4665      	mov	r5, ip
 800195c:	3920      	subs	r1, #32
 800195e:	40cd      	lsrs	r5, r1
 8001960:	2a20      	cmp	r2, #32
 8001962:	d004      	beq.n	800196e <__aeabi_dadd+0x45e>
 8001964:	2040      	movs	r0, #64	; 0x40
 8001966:	4661      	mov	r1, ip
 8001968:	1a82      	subs	r2, r0, r2
 800196a:	4091      	lsls	r1, r2
 800196c:	430f      	orrs	r7, r1
 800196e:	0039      	movs	r1, r7
 8001970:	1e4f      	subs	r7, r1, #1
 8001972:	41b9      	sbcs	r1, r7
 8001974:	4329      	orrs	r1, r5
 8001976:	e60f      	b.n	8001598 <__aeabi_dadd+0x88>
 8001978:	464a      	mov	r2, r9
 800197a:	4313      	orrs	r3, r2
 800197c:	001d      	movs	r5, r3
 800197e:	1e6b      	subs	r3, r5, #1
 8001980:	419d      	sbcs	r5, r3
 8001982:	1b7d      	subs	r5, r7, r5
 8001984:	42af      	cmp	r7, r5
 8001986:	419b      	sbcs	r3, r3
 8001988:	4662      	mov	r2, ip
 800198a:	425b      	negs	r3, r3
 800198c:	1ad3      	subs	r3, r2, r3
 800198e:	4698      	mov	r8, r3
 8001990:	4654      	mov	r4, sl
 8001992:	000e      	movs	r6, r1
 8001994:	e607      	b.n	80015a6 <__aeabi_dadd+0x96>
 8001996:	4648      	mov	r0, r9
 8001998:	4318      	orrs	r0, r3
 800199a:	d100      	bne.n	800199e <__aeabi_dadd+0x48e>
 800199c:	e0b3      	b.n	8001b06 <__aeabi_dadd+0x5f6>
 800199e:	1e50      	subs	r0, r2, #1
 80019a0:	2a01      	cmp	r2, #1
 80019a2:	d100      	bne.n	80019a6 <__aeabi_dadd+0x496>
 80019a4:	e10d      	b.n	8001bc2 <__aeabi_dadd+0x6b2>
 80019a6:	4d8d      	ldr	r5, [pc, #564]	; (8001bdc <__aeabi_dadd+0x6cc>)
 80019a8:	42aa      	cmp	r2, r5
 80019aa:	d100      	bne.n	80019ae <__aeabi_dadd+0x49e>
 80019ac:	e0a5      	b.n	8001afa <__aeabi_dadd+0x5ea>
 80019ae:	0002      	movs	r2, r0
 80019b0:	e710      	b.n	80017d4 <__aeabi_dadd+0x2c4>
 80019b2:	0032      	movs	r2, r6
 80019b4:	2300      	movs	r3, #0
 80019b6:	2100      	movs	r1, #0
 80019b8:	e644      	b.n	8001644 <__aeabi_dadd+0x134>
 80019ba:	2120      	movs	r1, #32
 80019bc:	0038      	movs	r0, r7
 80019be:	1a89      	subs	r1, r1, r2
 80019c0:	4665      	mov	r5, ip
 80019c2:	408f      	lsls	r7, r1
 80019c4:	408d      	lsls	r5, r1
 80019c6:	40d0      	lsrs	r0, r2
 80019c8:	1e79      	subs	r1, r7, #1
 80019ca:	418f      	sbcs	r7, r1
 80019cc:	4305      	orrs	r5, r0
 80019ce:	433d      	orrs	r5, r7
 80019d0:	4667      	mov	r7, ip
 80019d2:	40d7      	lsrs	r7, r2
 80019d4:	19db      	adds	r3, r3, r7
 80019d6:	e794      	b.n	8001902 <__aeabi_dadd+0x3f2>
 80019d8:	4a80      	ldr	r2, [pc, #512]	; (8001bdc <__aeabi_dadd+0x6cc>)
 80019da:	4290      	cmp	r0, r2
 80019dc:	d100      	bne.n	80019e0 <__aeabi_dadd+0x4d0>
 80019de:	e0ec      	b.n	8001bba <__aeabi_dadd+0x6aa>
 80019e0:	0039      	movs	r1, r7
 80019e2:	4449      	add	r1, r9
 80019e4:	4549      	cmp	r1, r9
 80019e6:	4192      	sbcs	r2, r2
 80019e8:	4463      	add	r3, ip
 80019ea:	4252      	negs	r2, r2
 80019ec:	189b      	adds	r3, r3, r2
 80019ee:	07dd      	lsls	r5, r3, #31
 80019f0:	0849      	lsrs	r1, r1, #1
 80019f2:	085b      	lsrs	r3, r3, #1
 80019f4:	4698      	mov	r8, r3
 80019f6:	0006      	movs	r6, r0
 80019f8:	430d      	orrs	r5, r1
 80019fa:	e6a5      	b.n	8001748 <__aeabi_dadd+0x238>
 80019fc:	464a      	mov	r2, r9
 80019fe:	1abd      	subs	r5, r7, r2
 8001a00:	42af      	cmp	r7, r5
 8001a02:	4189      	sbcs	r1, r1
 8001a04:	4662      	mov	r2, ip
 8001a06:	4249      	negs	r1, r1
 8001a08:	1ad3      	subs	r3, r2, r3
 8001a0a:	1a5b      	subs	r3, r3, r1
 8001a0c:	4698      	mov	r8, r3
 8001a0e:	4654      	mov	r4, sl
 8001a10:	e5d1      	b.n	80015b6 <__aeabi_dadd+0xa6>
 8001a12:	076c      	lsls	r4, r5, #29
 8001a14:	08f9      	lsrs	r1, r7, #3
 8001a16:	4321      	orrs	r1, r4
 8001a18:	08eb      	lsrs	r3, r5, #3
 8001a1a:	0004      	movs	r4, r0
 8001a1c:	e69d      	b.n	800175a <__aeabi_dadd+0x24a>
 8001a1e:	464a      	mov	r2, r9
 8001a20:	431a      	orrs	r2, r3
 8001a22:	d175      	bne.n	8001b10 <__aeabi_dadd+0x600>
 8001a24:	4661      	mov	r1, ip
 8001a26:	4339      	orrs	r1, r7
 8001a28:	d114      	bne.n	8001a54 <__aeabi_dadd+0x544>
 8001a2a:	2380      	movs	r3, #128	; 0x80
 8001a2c:	2400      	movs	r4, #0
 8001a2e:	031b      	lsls	r3, r3, #12
 8001a30:	e6bc      	b.n	80017ac <__aeabi_dadd+0x29c>
 8001a32:	464a      	mov	r2, r9
 8001a34:	1bd5      	subs	r5, r2, r7
 8001a36:	45a9      	cmp	r9, r5
 8001a38:	4189      	sbcs	r1, r1
 8001a3a:	4662      	mov	r2, ip
 8001a3c:	4249      	negs	r1, r1
 8001a3e:	1a9b      	subs	r3, r3, r2
 8001a40:	1a5b      	subs	r3, r3, r1
 8001a42:	4698      	mov	r8, r3
 8001a44:	2601      	movs	r6, #1
 8001a46:	e5ae      	b.n	80015a6 <__aeabi_dadd+0x96>
 8001a48:	464a      	mov	r2, r9
 8001a4a:	08d1      	lsrs	r1, r2, #3
 8001a4c:	075a      	lsls	r2, r3, #29
 8001a4e:	4311      	orrs	r1, r2
 8001a50:	08db      	lsrs	r3, r3, #3
 8001a52:	e6a7      	b.n	80017a4 <__aeabi_dadd+0x294>
 8001a54:	4663      	mov	r3, ip
 8001a56:	08f9      	lsrs	r1, r7, #3
 8001a58:	075a      	lsls	r2, r3, #29
 8001a5a:	4654      	mov	r4, sl
 8001a5c:	4311      	orrs	r1, r2
 8001a5e:	08db      	lsrs	r3, r3, #3
 8001a60:	e6a0      	b.n	80017a4 <__aeabi_dadd+0x294>
 8001a62:	464a      	mov	r2, r9
 8001a64:	4313      	orrs	r3, r2
 8001a66:	001d      	movs	r5, r3
 8001a68:	1e6b      	subs	r3, r5, #1
 8001a6a:	419d      	sbcs	r5, r3
 8001a6c:	e6c7      	b.n	80017fe <__aeabi_dadd+0x2ee>
 8001a6e:	0014      	movs	r4, r2
 8001a70:	001e      	movs	r6, r3
 8001a72:	3c20      	subs	r4, #32
 8001a74:	40e6      	lsrs	r6, r4
 8001a76:	2a20      	cmp	r2, #32
 8001a78:	d005      	beq.n	8001a86 <__aeabi_dadd+0x576>
 8001a7a:	2440      	movs	r4, #64	; 0x40
 8001a7c:	1aa2      	subs	r2, r4, r2
 8001a7e:	4093      	lsls	r3, r2
 8001a80:	464a      	mov	r2, r9
 8001a82:	431a      	orrs	r2, r3
 8001a84:	4691      	mov	r9, r2
 8001a86:	464d      	mov	r5, r9
 8001a88:	1e6b      	subs	r3, r5, #1
 8001a8a:	419d      	sbcs	r5, r3
 8001a8c:	4335      	orrs	r5, r6
 8001a8e:	e778      	b.n	8001982 <__aeabi_dadd+0x472>
 8001a90:	464a      	mov	r2, r9
 8001a92:	431a      	orrs	r2, r3
 8001a94:	d000      	beq.n	8001a98 <__aeabi_dadd+0x588>
 8001a96:	e66b      	b.n	8001770 <__aeabi_dadd+0x260>
 8001a98:	076b      	lsls	r3, r5, #29
 8001a9a:	08f9      	lsrs	r1, r7, #3
 8001a9c:	4319      	orrs	r1, r3
 8001a9e:	08eb      	lsrs	r3, r5, #3
 8001aa0:	e680      	b.n	80017a4 <__aeabi_dadd+0x294>
 8001aa2:	4661      	mov	r1, ip
 8001aa4:	4339      	orrs	r1, r7
 8001aa6:	d054      	beq.n	8001b52 <__aeabi_dadd+0x642>
 8001aa8:	4663      	mov	r3, ip
 8001aaa:	08f9      	lsrs	r1, r7, #3
 8001aac:	075c      	lsls	r4, r3, #29
 8001aae:	4321      	orrs	r1, r4
 8001ab0:	08db      	lsrs	r3, r3, #3
 8001ab2:	0004      	movs	r4, r0
 8001ab4:	e654      	b.n	8001760 <__aeabi_dadd+0x250>
 8001ab6:	464a      	mov	r2, r9
 8001ab8:	1abd      	subs	r5, r7, r2
 8001aba:	42af      	cmp	r7, r5
 8001abc:	4189      	sbcs	r1, r1
 8001abe:	4662      	mov	r2, ip
 8001ac0:	4249      	negs	r1, r1
 8001ac2:	1ad3      	subs	r3, r2, r3
 8001ac4:	1a5b      	subs	r3, r3, r1
 8001ac6:	4698      	mov	r8, r3
 8001ac8:	0004      	movs	r4, r0
 8001aca:	2601      	movs	r6, #1
 8001acc:	e56b      	b.n	80015a6 <__aeabi_dadd+0x96>
 8001ace:	464a      	mov	r2, r9
 8001ad0:	1bd5      	subs	r5, r2, r7
 8001ad2:	45a9      	cmp	r9, r5
 8001ad4:	4189      	sbcs	r1, r1
 8001ad6:	4662      	mov	r2, ip
 8001ad8:	4249      	negs	r1, r1
 8001ada:	1a9a      	subs	r2, r3, r2
 8001adc:	1a52      	subs	r2, r2, r1
 8001ade:	4690      	mov	r8, r2
 8001ae0:	0212      	lsls	r2, r2, #8
 8001ae2:	d532      	bpl.n	8001b4a <__aeabi_dadd+0x63a>
 8001ae4:	464a      	mov	r2, r9
 8001ae6:	1abd      	subs	r5, r7, r2
 8001ae8:	42af      	cmp	r7, r5
 8001aea:	4189      	sbcs	r1, r1
 8001aec:	4662      	mov	r2, ip
 8001aee:	4249      	negs	r1, r1
 8001af0:	1ad3      	subs	r3, r2, r3
 8001af2:	1a5b      	subs	r3, r3, r1
 8001af4:	4698      	mov	r8, r3
 8001af6:	0004      	movs	r4, r0
 8001af8:	e584      	b.n	8001604 <__aeabi_dadd+0xf4>
 8001afa:	4663      	mov	r3, ip
 8001afc:	08f9      	lsrs	r1, r7, #3
 8001afe:	075a      	lsls	r2, r3, #29
 8001b00:	4311      	orrs	r1, r2
 8001b02:	08db      	lsrs	r3, r3, #3
 8001b04:	e64e      	b.n	80017a4 <__aeabi_dadd+0x294>
 8001b06:	08f9      	lsrs	r1, r7, #3
 8001b08:	0768      	lsls	r0, r5, #29
 8001b0a:	4301      	orrs	r1, r0
 8001b0c:	08eb      	lsrs	r3, r5, #3
 8001b0e:	e624      	b.n	800175a <__aeabi_dadd+0x24a>
 8001b10:	4662      	mov	r2, ip
 8001b12:	433a      	orrs	r2, r7
 8001b14:	d100      	bne.n	8001b18 <__aeabi_dadd+0x608>
 8001b16:	e698      	b.n	800184a <__aeabi_dadd+0x33a>
 8001b18:	464a      	mov	r2, r9
 8001b1a:	08d1      	lsrs	r1, r2, #3
 8001b1c:	075a      	lsls	r2, r3, #29
 8001b1e:	4311      	orrs	r1, r2
 8001b20:	08da      	lsrs	r2, r3, #3
 8001b22:	2380      	movs	r3, #128	; 0x80
 8001b24:	031b      	lsls	r3, r3, #12
 8001b26:	421a      	tst	r2, r3
 8001b28:	d008      	beq.n	8001b3c <__aeabi_dadd+0x62c>
 8001b2a:	4660      	mov	r0, ip
 8001b2c:	08c5      	lsrs	r5, r0, #3
 8001b2e:	421d      	tst	r5, r3
 8001b30:	d104      	bne.n	8001b3c <__aeabi_dadd+0x62c>
 8001b32:	4654      	mov	r4, sl
 8001b34:	002a      	movs	r2, r5
 8001b36:	08f9      	lsrs	r1, r7, #3
 8001b38:	0743      	lsls	r3, r0, #29
 8001b3a:	4319      	orrs	r1, r3
 8001b3c:	0f4b      	lsrs	r3, r1, #29
 8001b3e:	00c9      	lsls	r1, r1, #3
 8001b40:	075b      	lsls	r3, r3, #29
 8001b42:	08c9      	lsrs	r1, r1, #3
 8001b44:	4319      	orrs	r1, r3
 8001b46:	0013      	movs	r3, r2
 8001b48:	e62c      	b.n	80017a4 <__aeabi_dadd+0x294>
 8001b4a:	4641      	mov	r1, r8
 8001b4c:	4329      	orrs	r1, r5
 8001b4e:	d000      	beq.n	8001b52 <__aeabi_dadd+0x642>
 8001b50:	e5fa      	b.n	8001748 <__aeabi_dadd+0x238>
 8001b52:	2300      	movs	r3, #0
 8001b54:	000a      	movs	r2, r1
 8001b56:	2400      	movs	r4, #0
 8001b58:	e602      	b.n	8001760 <__aeabi_dadd+0x250>
 8001b5a:	076b      	lsls	r3, r5, #29
 8001b5c:	08f9      	lsrs	r1, r7, #3
 8001b5e:	4319      	orrs	r1, r3
 8001b60:	08eb      	lsrs	r3, r5, #3
 8001b62:	e5fd      	b.n	8001760 <__aeabi_dadd+0x250>
 8001b64:	4663      	mov	r3, ip
 8001b66:	08f9      	lsrs	r1, r7, #3
 8001b68:	075b      	lsls	r3, r3, #29
 8001b6a:	4319      	orrs	r1, r3
 8001b6c:	4663      	mov	r3, ip
 8001b6e:	0004      	movs	r4, r0
 8001b70:	08db      	lsrs	r3, r3, #3
 8001b72:	e617      	b.n	80017a4 <__aeabi_dadd+0x294>
 8001b74:	003d      	movs	r5, r7
 8001b76:	444d      	add	r5, r9
 8001b78:	4463      	add	r3, ip
 8001b7a:	454d      	cmp	r5, r9
 8001b7c:	4189      	sbcs	r1, r1
 8001b7e:	4698      	mov	r8, r3
 8001b80:	4249      	negs	r1, r1
 8001b82:	4488      	add	r8, r1
 8001b84:	4643      	mov	r3, r8
 8001b86:	021b      	lsls	r3, r3, #8
 8001b88:	d400      	bmi.n	8001b8c <__aeabi_dadd+0x67c>
 8001b8a:	e5dd      	b.n	8001748 <__aeabi_dadd+0x238>
 8001b8c:	4642      	mov	r2, r8
 8001b8e:	4b14      	ldr	r3, [pc, #80]	; (8001be0 <__aeabi_dadd+0x6d0>)
 8001b90:	2601      	movs	r6, #1
 8001b92:	401a      	ands	r2, r3
 8001b94:	4690      	mov	r8, r2
 8001b96:	e5d7      	b.n	8001748 <__aeabi_dadd+0x238>
 8001b98:	0010      	movs	r0, r2
 8001b9a:	001e      	movs	r6, r3
 8001b9c:	3820      	subs	r0, #32
 8001b9e:	40c6      	lsrs	r6, r0
 8001ba0:	2a20      	cmp	r2, #32
 8001ba2:	d005      	beq.n	8001bb0 <__aeabi_dadd+0x6a0>
 8001ba4:	2040      	movs	r0, #64	; 0x40
 8001ba6:	1a82      	subs	r2, r0, r2
 8001ba8:	4093      	lsls	r3, r2
 8001baa:	464a      	mov	r2, r9
 8001bac:	431a      	orrs	r2, r3
 8001bae:	4691      	mov	r9, r2
 8001bb0:	464d      	mov	r5, r9
 8001bb2:	1e6b      	subs	r3, r5, #1
 8001bb4:	419d      	sbcs	r5, r3
 8001bb6:	4335      	orrs	r5, r6
 8001bb8:	e621      	b.n	80017fe <__aeabi_dadd+0x2ee>
 8001bba:	0002      	movs	r2, r0
 8001bbc:	2300      	movs	r3, #0
 8001bbe:	2100      	movs	r1, #0
 8001bc0:	e540      	b.n	8001644 <__aeabi_dadd+0x134>
 8001bc2:	464a      	mov	r2, r9
 8001bc4:	19d5      	adds	r5, r2, r7
 8001bc6:	42bd      	cmp	r5, r7
 8001bc8:	4189      	sbcs	r1, r1
 8001bca:	4463      	add	r3, ip
 8001bcc:	4698      	mov	r8, r3
 8001bce:	4249      	negs	r1, r1
 8001bd0:	4488      	add	r8, r1
 8001bd2:	e5b3      	b.n	800173c <__aeabi_dadd+0x22c>
 8001bd4:	2100      	movs	r1, #0
 8001bd6:	4a01      	ldr	r2, [pc, #4]	; (8001bdc <__aeabi_dadd+0x6cc>)
 8001bd8:	000b      	movs	r3, r1
 8001bda:	e533      	b.n	8001644 <__aeabi_dadd+0x134>
 8001bdc:	000007ff 	.word	0x000007ff
 8001be0:	ff7fffff 	.word	0xff7fffff

08001be4 <__aeabi_ddiv>:
 8001be4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001be6:	4657      	mov	r7, sl
 8001be8:	464e      	mov	r6, r9
 8001bea:	4645      	mov	r5, r8
 8001bec:	46de      	mov	lr, fp
 8001bee:	b5e0      	push	{r5, r6, r7, lr}
 8001bf0:	4681      	mov	r9, r0
 8001bf2:	0005      	movs	r5, r0
 8001bf4:	030c      	lsls	r4, r1, #12
 8001bf6:	0048      	lsls	r0, r1, #1
 8001bf8:	4692      	mov	sl, r2
 8001bfa:	001f      	movs	r7, r3
 8001bfc:	b085      	sub	sp, #20
 8001bfe:	0b24      	lsrs	r4, r4, #12
 8001c00:	0d40      	lsrs	r0, r0, #21
 8001c02:	0fce      	lsrs	r6, r1, #31
 8001c04:	2800      	cmp	r0, #0
 8001c06:	d059      	beq.n	8001cbc <__aeabi_ddiv+0xd8>
 8001c08:	4b87      	ldr	r3, [pc, #540]	; (8001e28 <__aeabi_ddiv+0x244>)
 8001c0a:	4298      	cmp	r0, r3
 8001c0c:	d100      	bne.n	8001c10 <__aeabi_ddiv+0x2c>
 8001c0e:	e098      	b.n	8001d42 <__aeabi_ddiv+0x15e>
 8001c10:	0f6b      	lsrs	r3, r5, #29
 8001c12:	00e4      	lsls	r4, r4, #3
 8001c14:	431c      	orrs	r4, r3
 8001c16:	2380      	movs	r3, #128	; 0x80
 8001c18:	041b      	lsls	r3, r3, #16
 8001c1a:	4323      	orrs	r3, r4
 8001c1c:	4698      	mov	r8, r3
 8001c1e:	4b83      	ldr	r3, [pc, #524]	; (8001e2c <__aeabi_ddiv+0x248>)
 8001c20:	00ed      	lsls	r5, r5, #3
 8001c22:	469b      	mov	fp, r3
 8001c24:	2300      	movs	r3, #0
 8001c26:	4699      	mov	r9, r3
 8001c28:	4483      	add	fp, r0
 8001c2a:	9300      	str	r3, [sp, #0]
 8001c2c:	033c      	lsls	r4, r7, #12
 8001c2e:	007b      	lsls	r3, r7, #1
 8001c30:	4650      	mov	r0, sl
 8001c32:	0b24      	lsrs	r4, r4, #12
 8001c34:	0d5b      	lsrs	r3, r3, #21
 8001c36:	0fff      	lsrs	r7, r7, #31
 8001c38:	2b00      	cmp	r3, #0
 8001c3a:	d067      	beq.n	8001d0c <__aeabi_ddiv+0x128>
 8001c3c:	4a7a      	ldr	r2, [pc, #488]	; (8001e28 <__aeabi_ddiv+0x244>)
 8001c3e:	4293      	cmp	r3, r2
 8001c40:	d018      	beq.n	8001c74 <__aeabi_ddiv+0x90>
 8001c42:	497a      	ldr	r1, [pc, #488]	; (8001e2c <__aeabi_ddiv+0x248>)
 8001c44:	0f42      	lsrs	r2, r0, #29
 8001c46:	468c      	mov	ip, r1
 8001c48:	00e4      	lsls	r4, r4, #3
 8001c4a:	4659      	mov	r1, fp
 8001c4c:	4314      	orrs	r4, r2
 8001c4e:	2280      	movs	r2, #128	; 0x80
 8001c50:	4463      	add	r3, ip
 8001c52:	0412      	lsls	r2, r2, #16
 8001c54:	1acb      	subs	r3, r1, r3
 8001c56:	4314      	orrs	r4, r2
 8001c58:	469b      	mov	fp, r3
 8001c5a:	00c2      	lsls	r2, r0, #3
 8001c5c:	2000      	movs	r0, #0
 8001c5e:	0033      	movs	r3, r6
 8001c60:	407b      	eors	r3, r7
 8001c62:	469a      	mov	sl, r3
 8001c64:	464b      	mov	r3, r9
 8001c66:	2b0f      	cmp	r3, #15
 8001c68:	d900      	bls.n	8001c6c <__aeabi_ddiv+0x88>
 8001c6a:	e0ef      	b.n	8001e4c <__aeabi_ddiv+0x268>
 8001c6c:	4970      	ldr	r1, [pc, #448]	; (8001e30 <__aeabi_ddiv+0x24c>)
 8001c6e:	009b      	lsls	r3, r3, #2
 8001c70:	58cb      	ldr	r3, [r1, r3]
 8001c72:	469f      	mov	pc, r3
 8001c74:	4b6f      	ldr	r3, [pc, #444]	; (8001e34 <__aeabi_ddiv+0x250>)
 8001c76:	4652      	mov	r2, sl
 8001c78:	469c      	mov	ip, r3
 8001c7a:	4322      	orrs	r2, r4
 8001c7c:	44e3      	add	fp, ip
 8001c7e:	2a00      	cmp	r2, #0
 8001c80:	d000      	beq.n	8001c84 <__aeabi_ddiv+0xa0>
 8001c82:	e095      	b.n	8001db0 <__aeabi_ddiv+0x1cc>
 8001c84:	4649      	mov	r1, r9
 8001c86:	2302      	movs	r3, #2
 8001c88:	4319      	orrs	r1, r3
 8001c8a:	4689      	mov	r9, r1
 8001c8c:	2400      	movs	r4, #0
 8001c8e:	2002      	movs	r0, #2
 8001c90:	e7e5      	b.n	8001c5e <__aeabi_ddiv+0x7a>
 8001c92:	2300      	movs	r3, #0
 8001c94:	2400      	movs	r4, #0
 8001c96:	2500      	movs	r5, #0
 8001c98:	4652      	mov	r2, sl
 8001c9a:	051b      	lsls	r3, r3, #20
 8001c9c:	4323      	orrs	r3, r4
 8001c9e:	07d2      	lsls	r2, r2, #31
 8001ca0:	4313      	orrs	r3, r2
 8001ca2:	0028      	movs	r0, r5
 8001ca4:	0019      	movs	r1, r3
 8001ca6:	b005      	add	sp, #20
 8001ca8:	bcf0      	pop	{r4, r5, r6, r7}
 8001caa:	46bb      	mov	fp, r7
 8001cac:	46b2      	mov	sl, r6
 8001cae:	46a9      	mov	r9, r5
 8001cb0:	46a0      	mov	r8, r4
 8001cb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001cb4:	2400      	movs	r4, #0
 8001cb6:	2500      	movs	r5, #0
 8001cb8:	4b5b      	ldr	r3, [pc, #364]	; (8001e28 <__aeabi_ddiv+0x244>)
 8001cba:	e7ed      	b.n	8001c98 <__aeabi_ddiv+0xb4>
 8001cbc:	464b      	mov	r3, r9
 8001cbe:	4323      	orrs	r3, r4
 8001cc0:	4698      	mov	r8, r3
 8001cc2:	d100      	bne.n	8001cc6 <__aeabi_ddiv+0xe2>
 8001cc4:	e089      	b.n	8001dda <__aeabi_ddiv+0x1f6>
 8001cc6:	2c00      	cmp	r4, #0
 8001cc8:	d100      	bne.n	8001ccc <__aeabi_ddiv+0xe8>
 8001cca:	e1e0      	b.n	800208e <__aeabi_ddiv+0x4aa>
 8001ccc:	0020      	movs	r0, r4
 8001cce:	f001 fa61 	bl	8003194 <__clzsi2>
 8001cd2:	0001      	movs	r1, r0
 8001cd4:	0002      	movs	r2, r0
 8001cd6:	390b      	subs	r1, #11
 8001cd8:	231d      	movs	r3, #29
 8001cda:	1a5b      	subs	r3, r3, r1
 8001cdc:	4649      	mov	r1, r9
 8001cde:	0010      	movs	r0, r2
 8001ce0:	40d9      	lsrs	r1, r3
 8001ce2:	3808      	subs	r0, #8
 8001ce4:	4084      	lsls	r4, r0
 8001ce6:	000b      	movs	r3, r1
 8001ce8:	464d      	mov	r5, r9
 8001cea:	4323      	orrs	r3, r4
 8001cec:	4698      	mov	r8, r3
 8001cee:	4085      	lsls	r5, r0
 8001cf0:	4851      	ldr	r0, [pc, #324]	; (8001e38 <__aeabi_ddiv+0x254>)
 8001cf2:	033c      	lsls	r4, r7, #12
 8001cf4:	1a83      	subs	r3, r0, r2
 8001cf6:	469b      	mov	fp, r3
 8001cf8:	2300      	movs	r3, #0
 8001cfa:	4699      	mov	r9, r3
 8001cfc:	9300      	str	r3, [sp, #0]
 8001cfe:	007b      	lsls	r3, r7, #1
 8001d00:	4650      	mov	r0, sl
 8001d02:	0b24      	lsrs	r4, r4, #12
 8001d04:	0d5b      	lsrs	r3, r3, #21
 8001d06:	0fff      	lsrs	r7, r7, #31
 8001d08:	2b00      	cmp	r3, #0
 8001d0a:	d197      	bne.n	8001c3c <__aeabi_ddiv+0x58>
 8001d0c:	4652      	mov	r2, sl
 8001d0e:	4322      	orrs	r2, r4
 8001d10:	d055      	beq.n	8001dbe <__aeabi_ddiv+0x1da>
 8001d12:	2c00      	cmp	r4, #0
 8001d14:	d100      	bne.n	8001d18 <__aeabi_ddiv+0x134>
 8001d16:	e1ca      	b.n	80020ae <__aeabi_ddiv+0x4ca>
 8001d18:	0020      	movs	r0, r4
 8001d1a:	f001 fa3b 	bl	8003194 <__clzsi2>
 8001d1e:	0002      	movs	r2, r0
 8001d20:	3a0b      	subs	r2, #11
 8001d22:	231d      	movs	r3, #29
 8001d24:	0001      	movs	r1, r0
 8001d26:	1a9b      	subs	r3, r3, r2
 8001d28:	4652      	mov	r2, sl
 8001d2a:	3908      	subs	r1, #8
 8001d2c:	40da      	lsrs	r2, r3
 8001d2e:	408c      	lsls	r4, r1
 8001d30:	4314      	orrs	r4, r2
 8001d32:	4652      	mov	r2, sl
 8001d34:	408a      	lsls	r2, r1
 8001d36:	4b41      	ldr	r3, [pc, #260]	; (8001e3c <__aeabi_ddiv+0x258>)
 8001d38:	4458      	add	r0, fp
 8001d3a:	469b      	mov	fp, r3
 8001d3c:	4483      	add	fp, r0
 8001d3e:	2000      	movs	r0, #0
 8001d40:	e78d      	b.n	8001c5e <__aeabi_ddiv+0x7a>
 8001d42:	464b      	mov	r3, r9
 8001d44:	4323      	orrs	r3, r4
 8001d46:	4698      	mov	r8, r3
 8001d48:	d140      	bne.n	8001dcc <__aeabi_ddiv+0x1e8>
 8001d4a:	2308      	movs	r3, #8
 8001d4c:	4699      	mov	r9, r3
 8001d4e:	3b06      	subs	r3, #6
 8001d50:	2500      	movs	r5, #0
 8001d52:	4683      	mov	fp, r0
 8001d54:	9300      	str	r3, [sp, #0]
 8001d56:	e769      	b.n	8001c2c <__aeabi_ddiv+0x48>
 8001d58:	46b2      	mov	sl, r6
 8001d5a:	9b00      	ldr	r3, [sp, #0]
 8001d5c:	2b02      	cmp	r3, #2
 8001d5e:	d0a9      	beq.n	8001cb4 <__aeabi_ddiv+0xd0>
 8001d60:	2b03      	cmp	r3, #3
 8001d62:	d100      	bne.n	8001d66 <__aeabi_ddiv+0x182>
 8001d64:	e211      	b.n	800218a <__aeabi_ddiv+0x5a6>
 8001d66:	2b01      	cmp	r3, #1
 8001d68:	d093      	beq.n	8001c92 <__aeabi_ddiv+0xae>
 8001d6a:	4a35      	ldr	r2, [pc, #212]	; (8001e40 <__aeabi_ddiv+0x25c>)
 8001d6c:	445a      	add	r2, fp
 8001d6e:	2a00      	cmp	r2, #0
 8001d70:	dc00      	bgt.n	8001d74 <__aeabi_ddiv+0x190>
 8001d72:	e13c      	b.n	8001fee <__aeabi_ddiv+0x40a>
 8001d74:	076b      	lsls	r3, r5, #29
 8001d76:	d000      	beq.n	8001d7a <__aeabi_ddiv+0x196>
 8001d78:	e1a7      	b.n	80020ca <__aeabi_ddiv+0x4e6>
 8001d7a:	08ed      	lsrs	r5, r5, #3
 8001d7c:	4643      	mov	r3, r8
 8001d7e:	01db      	lsls	r3, r3, #7
 8001d80:	d506      	bpl.n	8001d90 <__aeabi_ddiv+0x1ac>
 8001d82:	4642      	mov	r2, r8
 8001d84:	4b2f      	ldr	r3, [pc, #188]	; (8001e44 <__aeabi_ddiv+0x260>)
 8001d86:	401a      	ands	r2, r3
 8001d88:	4690      	mov	r8, r2
 8001d8a:	2280      	movs	r2, #128	; 0x80
 8001d8c:	00d2      	lsls	r2, r2, #3
 8001d8e:	445a      	add	r2, fp
 8001d90:	4b2d      	ldr	r3, [pc, #180]	; (8001e48 <__aeabi_ddiv+0x264>)
 8001d92:	429a      	cmp	r2, r3
 8001d94:	dc8e      	bgt.n	8001cb4 <__aeabi_ddiv+0xd0>
 8001d96:	4643      	mov	r3, r8
 8001d98:	0552      	lsls	r2, r2, #21
 8001d9a:	0758      	lsls	r0, r3, #29
 8001d9c:	025c      	lsls	r4, r3, #9
 8001d9e:	4305      	orrs	r5, r0
 8001da0:	0b24      	lsrs	r4, r4, #12
 8001da2:	0d53      	lsrs	r3, r2, #21
 8001da4:	e778      	b.n	8001c98 <__aeabi_ddiv+0xb4>
 8001da6:	46ba      	mov	sl, r7
 8001da8:	46a0      	mov	r8, r4
 8001daa:	0015      	movs	r5, r2
 8001dac:	9000      	str	r0, [sp, #0]
 8001dae:	e7d4      	b.n	8001d5a <__aeabi_ddiv+0x176>
 8001db0:	464a      	mov	r2, r9
 8001db2:	2303      	movs	r3, #3
 8001db4:	431a      	orrs	r2, r3
 8001db6:	4691      	mov	r9, r2
 8001db8:	2003      	movs	r0, #3
 8001dba:	4652      	mov	r2, sl
 8001dbc:	e74f      	b.n	8001c5e <__aeabi_ddiv+0x7a>
 8001dbe:	4649      	mov	r1, r9
 8001dc0:	2301      	movs	r3, #1
 8001dc2:	4319      	orrs	r1, r3
 8001dc4:	4689      	mov	r9, r1
 8001dc6:	2400      	movs	r4, #0
 8001dc8:	2001      	movs	r0, #1
 8001dca:	e748      	b.n	8001c5e <__aeabi_ddiv+0x7a>
 8001dcc:	230c      	movs	r3, #12
 8001dce:	4699      	mov	r9, r3
 8001dd0:	3b09      	subs	r3, #9
 8001dd2:	46a0      	mov	r8, r4
 8001dd4:	4683      	mov	fp, r0
 8001dd6:	9300      	str	r3, [sp, #0]
 8001dd8:	e728      	b.n	8001c2c <__aeabi_ddiv+0x48>
 8001dda:	2304      	movs	r3, #4
 8001ddc:	4699      	mov	r9, r3
 8001dde:	2300      	movs	r3, #0
 8001de0:	469b      	mov	fp, r3
 8001de2:	3301      	adds	r3, #1
 8001de4:	2500      	movs	r5, #0
 8001de6:	9300      	str	r3, [sp, #0]
 8001de8:	e720      	b.n	8001c2c <__aeabi_ddiv+0x48>
 8001dea:	2300      	movs	r3, #0
 8001dec:	2480      	movs	r4, #128	; 0x80
 8001dee:	469a      	mov	sl, r3
 8001df0:	2500      	movs	r5, #0
 8001df2:	4b0d      	ldr	r3, [pc, #52]	; (8001e28 <__aeabi_ddiv+0x244>)
 8001df4:	0324      	lsls	r4, r4, #12
 8001df6:	e74f      	b.n	8001c98 <__aeabi_ddiv+0xb4>
 8001df8:	2380      	movs	r3, #128	; 0x80
 8001dfa:	4641      	mov	r1, r8
 8001dfc:	031b      	lsls	r3, r3, #12
 8001dfe:	4219      	tst	r1, r3
 8001e00:	d008      	beq.n	8001e14 <__aeabi_ddiv+0x230>
 8001e02:	421c      	tst	r4, r3
 8001e04:	d106      	bne.n	8001e14 <__aeabi_ddiv+0x230>
 8001e06:	431c      	orrs	r4, r3
 8001e08:	0324      	lsls	r4, r4, #12
 8001e0a:	46ba      	mov	sl, r7
 8001e0c:	0015      	movs	r5, r2
 8001e0e:	4b06      	ldr	r3, [pc, #24]	; (8001e28 <__aeabi_ddiv+0x244>)
 8001e10:	0b24      	lsrs	r4, r4, #12
 8001e12:	e741      	b.n	8001c98 <__aeabi_ddiv+0xb4>
 8001e14:	2480      	movs	r4, #128	; 0x80
 8001e16:	4643      	mov	r3, r8
 8001e18:	0324      	lsls	r4, r4, #12
 8001e1a:	431c      	orrs	r4, r3
 8001e1c:	0324      	lsls	r4, r4, #12
 8001e1e:	46b2      	mov	sl, r6
 8001e20:	4b01      	ldr	r3, [pc, #4]	; (8001e28 <__aeabi_ddiv+0x244>)
 8001e22:	0b24      	lsrs	r4, r4, #12
 8001e24:	e738      	b.n	8001c98 <__aeabi_ddiv+0xb4>
 8001e26:	46c0      	nop			; (mov r8, r8)
 8001e28:	000007ff 	.word	0x000007ff
 8001e2c:	fffffc01 	.word	0xfffffc01
 8001e30:	0801fdb4 	.word	0x0801fdb4
 8001e34:	fffff801 	.word	0xfffff801
 8001e38:	fffffc0d 	.word	0xfffffc0d
 8001e3c:	000003f3 	.word	0x000003f3
 8001e40:	000003ff 	.word	0x000003ff
 8001e44:	feffffff 	.word	0xfeffffff
 8001e48:	000007fe 	.word	0x000007fe
 8001e4c:	4544      	cmp	r4, r8
 8001e4e:	d200      	bcs.n	8001e52 <__aeabi_ddiv+0x26e>
 8001e50:	e116      	b.n	8002080 <__aeabi_ddiv+0x49c>
 8001e52:	d100      	bne.n	8001e56 <__aeabi_ddiv+0x272>
 8001e54:	e111      	b.n	800207a <__aeabi_ddiv+0x496>
 8001e56:	2301      	movs	r3, #1
 8001e58:	425b      	negs	r3, r3
 8001e5a:	469c      	mov	ip, r3
 8001e5c:	002e      	movs	r6, r5
 8001e5e:	4640      	mov	r0, r8
 8001e60:	2500      	movs	r5, #0
 8001e62:	44e3      	add	fp, ip
 8001e64:	0223      	lsls	r3, r4, #8
 8001e66:	0e14      	lsrs	r4, r2, #24
 8001e68:	431c      	orrs	r4, r3
 8001e6a:	0c1b      	lsrs	r3, r3, #16
 8001e6c:	4699      	mov	r9, r3
 8001e6e:	0423      	lsls	r3, r4, #16
 8001e70:	0c1f      	lsrs	r7, r3, #16
 8001e72:	0212      	lsls	r2, r2, #8
 8001e74:	4649      	mov	r1, r9
 8001e76:	9200      	str	r2, [sp, #0]
 8001e78:	9701      	str	r7, [sp, #4]
 8001e7a:	f7fe f9d5 	bl	8000228 <__aeabi_uidivmod>
 8001e7e:	0002      	movs	r2, r0
 8001e80:	437a      	muls	r2, r7
 8001e82:	040b      	lsls	r3, r1, #16
 8001e84:	0c31      	lsrs	r1, r6, #16
 8001e86:	4680      	mov	r8, r0
 8001e88:	4319      	orrs	r1, r3
 8001e8a:	428a      	cmp	r2, r1
 8001e8c:	d90b      	bls.n	8001ea6 <__aeabi_ddiv+0x2c2>
 8001e8e:	2301      	movs	r3, #1
 8001e90:	425b      	negs	r3, r3
 8001e92:	469c      	mov	ip, r3
 8001e94:	1909      	adds	r1, r1, r4
 8001e96:	44e0      	add	r8, ip
 8001e98:	428c      	cmp	r4, r1
 8001e9a:	d804      	bhi.n	8001ea6 <__aeabi_ddiv+0x2c2>
 8001e9c:	428a      	cmp	r2, r1
 8001e9e:	d902      	bls.n	8001ea6 <__aeabi_ddiv+0x2c2>
 8001ea0:	1e83      	subs	r3, r0, #2
 8001ea2:	4698      	mov	r8, r3
 8001ea4:	1909      	adds	r1, r1, r4
 8001ea6:	1a88      	subs	r0, r1, r2
 8001ea8:	4649      	mov	r1, r9
 8001eaa:	f7fe f9bd 	bl	8000228 <__aeabi_uidivmod>
 8001eae:	0409      	lsls	r1, r1, #16
 8001eb0:	468c      	mov	ip, r1
 8001eb2:	0431      	lsls	r1, r6, #16
 8001eb4:	4666      	mov	r6, ip
 8001eb6:	9a01      	ldr	r2, [sp, #4]
 8001eb8:	0c09      	lsrs	r1, r1, #16
 8001eba:	4342      	muls	r2, r0
 8001ebc:	0003      	movs	r3, r0
 8001ebe:	4331      	orrs	r1, r6
 8001ec0:	428a      	cmp	r2, r1
 8001ec2:	d904      	bls.n	8001ece <__aeabi_ddiv+0x2ea>
 8001ec4:	1909      	adds	r1, r1, r4
 8001ec6:	3b01      	subs	r3, #1
 8001ec8:	428c      	cmp	r4, r1
 8001eca:	d800      	bhi.n	8001ece <__aeabi_ddiv+0x2ea>
 8001ecc:	e111      	b.n	80020f2 <__aeabi_ddiv+0x50e>
 8001ece:	1a89      	subs	r1, r1, r2
 8001ed0:	4642      	mov	r2, r8
 8001ed2:	9e00      	ldr	r6, [sp, #0]
 8001ed4:	0412      	lsls	r2, r2, #16
 8001ed6:	431a      	orrs	r2, r3
 8001ed8:	0c33      	lsrs	r3, r6, #16
 8001eda:	001f      	movs	r7, r3
 8001edc:	0c10      	lsrs	r0, r2, #16
 8001ede:	4690      	mov	r8, r2
 8001ee0:	9302      	str	r3, [sp, #8]
 8001ee2:	0413      	lsls	r3, r2, #16
 8001ee4:	0432      	lsls	r2, r6, #16
 8001ee6:	0c16      	lsrs	r6, r2, #16
 8001ee8:	0032      	movs	r2, r6
 8001eea:	0c1b      	lsrs	r3, r3, #16
 8001eec:	435a      	muls	r2, r3
 8001eee:	9603      	str	r6, [sp, #12]
 8001ef0:	437b      	muls	r3, r7
 8001ef2:	4346      	muls	r6, r0
 8001ef4:	4378      	muls	r0, r7
 8001ef6:	0c17      	lsrs	r7, r2, #16
 8001ef8:	46bc      	mov	ip, r7
 8001efa:	199b      	adds	r3, r3, r6
 8001efc:	4463      	add	r3, ip
 8001efe:	429e      	cmp	r6, r3
 8001f00:	d903      	bls.n	8001f0a <__aeabi_ddiv+0x326>
 8001f02:	2680      	movs	r6, #128	; 0x80
 8001f04:	0276      	lsls	r6, r6, #9
 8001f06:	46b4      	mov	ip, r6
 8001f08:	4460      	add	r0, ip
 8001f0a:	0c1e      	lsrs	r6, r3, #16
 8001f0c:	1830      	adds	r0, r6, r0
 8001f0e:	0416      	lsls	r6, r2, #16
 8001f10:	041b      	lsls	r3, r3, #16
 8001f12:	0c36      	lsrs	r6, r6, #16
 8001f14:	199e      	adds	r6, r3, r6
 8001f16:	4281      	cmp	r1, r0
 8001f18:	d200      	bcs.n	8001f1c <__aeabi_ddiv+0x338>
 8001f1a:	e09c      	b.n	8002056 <__aeabi_ddiv+0x472>
 8001f1c:	d100      	bne.n	8001f20 <__aeabi_ddiv+0x33c>
 8001f1e:	e097      	b.n	8002050 <__aeabi_ddiv+0x46c>
 8001f20:	1bae      	subs	r6, r5, r6
 8001f22:	1a09      	subs	r1, r1, r0
 8001f24:	42b5      	cmp	r5, r6
 8001f26:	4180      	sbcs	r0, r0
 8001f28:	4240      	negs	r0, r0
 8001f2a:	1a08      	subs	r0, r1, r0
 8001f2c:	4284      	cmp	r4, r0
 8001f2e:	d100      	bne.n	8001f32 <__aeabi_ddiv+0x34e>
 8001f30:	e111      	b.n	8002156 <__aeabi_ddiv+0x572>
 8001f32:	4649      	mov	r1, r9
 8001f34:	f7fe f978 	bl	8000228 <__aeabi_uidivmod>
 8001f38:	9a01      	ldr	r2, [sp, #4]
 8001f3a:	040b      	lsls	r3, r1, #16
 8001f3c:	4342      	muls	r2, r0
 8001f3e:	0c31      	lsrs	r1, r6, #16
 8001f40:	0005      	movs	r5, r0
 8001f42:	4319      	orrs	r1, r3
 8001f44:	428a      	cmp	r2, r1
 8001f46:	d907      	bls.n	8001f58 <__aeabi_ddiv+0x374>
 8001f48:	1909      	adds	r1, r1, r4
 8001f4a:	3d01      	subs	r5, #1
 8001f4c:	428c      	cmp	r4, r1
 8001f4e:	d803      	bhi.n	8001f58 <__aeabi_ddiv+0x374>
 8001f50:	428a      	cmp	r2, r1
 8001f52:	d901      	bls.n	8001f58 <__aeabi_ddiv+0x374>
 8001f54:	1e85      	subs	r5, r0, #2
 8001f56:	1909      	adds	r1, r1, r4
 8001f58:	1a88      	subs	r0, r1, r2
 8001f5a:	4649      	mov	r1, r9
 8001f5c:	f7fe f964 	bl	8000228 <__aeabi_uidivmod>
 8001f60:	0409      	lsls	r1, r1, #16
 8001f62:	468c      	mov	ip, r1
 8001f64:	0431      	lsls	r1, r6, #16
 8001f66:	4666      	mov	r6, ip
 8001f68:	9a01      	ldr	r2, [sp, #4]
 8001f6a:	0c09      	lsrs	r1, r1, #16
 8001f6c:	4342      	muls	r2, r0
 8001f6e:	0003      	movs	r3, r0
 8001f70:	4331      	orrs	r1, r6
 8001f72:	428a      	cmp	r2, r1
 8001f74:	d907      	bls.n	8001f86 <__aeabi_ddiv+0x3a2>
 8001f76:	1909      	adds	r1, r1, r4
 8001f78:	3b01      	subs	r3, #1
 8001f7a:	428c      	cmp	r4, r1
 8001f7c:	d803      	bhi.n	8001f86 <__aeabi_ddiv+0x3a2>
 8001f7e:	428a      	cmp	r2, r1
 8001f80:	d901      	bls.n	8001f86 <__aeabi_ddiv+0x3a2>
 8001f82:	1e83      	subs	r3, r0, #2
 8001f84:	1909      	adds	r1, r1, r4
 8001f86:	9e03      	ldr	r6, [sp, #12]
 8001f88:	1a89      	subs	r1, r1, r2
 8001f8a:	0032      	movs	r2, r6
 8001f8c:	042d      	lsls	r5, r5, #16
 8001f8e:	431d      	orrs	r5, r3
 8001f90:	9f02      	ldr	r7, [sp, #8]
 8001f92:	042b      	lsls	r3, r5, #16
 8001f94:	0c1b      	lsrs	r3, r3, #16
 8001f96:	435a      	muls	r2, r3
 8001f98:	437b      	muls	r3, r7
 8001f9a:	469c      	mov	ip, r3
 8001f9c:	0c28      	lsrs	r0, r5, #16
 8001f9e:	4346      	muls	r6, r0
 8001fa0:	0c13      	lsrs	r3, r2, #16
 8001fa2:	44b4      	add	ip, r6
 8001fa4:	4463      	add	r3, ip
 8001fa6:	4378      	muls	r0, r7
 8001fa8:	429e      	cmp	r6, r3
 8001faa:	d903      	bls.n	8001fb4 <__aeabi_ddiv+0x3d0>
 8001fac:	2680      	movs	r6, #128	; 0x80
 8001fae:	0276      	lsls	r6, r6, #9
 8001fb0:	46b4      	mov	ip, r6
 8001fb2:	4460      	add	r0, ip
 8001fb4:	0c1e      	lsrs	r6, r3, #16
 8001fb6:	0412      	lsls	r2, r2, #16
 8001fb8:	041b      	lsls	r3, r3, #16
 8001fba:	0c12      	lsrs	r2, r2, #16
 8001fbc:	1830      	adds	r0, r6, r0
 8001fbe:	189b      	adds	r3, r3, r2
 8001fc0:	4281      	cmp	r1, r0
 8001fc2:	d306      	bcc.n	8001fd2 <__aeabi_ddiv+0x3ee>
 8001fc4:	d002      	beq.n	8001fcc <__aeabi_ddiv+0x3e8>
 8001fc6:	2301      	movs	r3, #1
 8001fc8:	431d      	orrs	r5, r3
 8001fca:	e6ce      	b.n	8001d6a <__aeabi_ddiv+0x186>
 8001fcc:	2b00      	cmp	r3, #0
 8001fce:	d100      	bne.n	8001fd2 <__aeabi_ddiv+0x3ee>
 8001fd0:	e6cb      	b.n	8001d6a <__aeabi_ddiv+0x186>
 8001fd2:	1861      	adds	r1, r4, r1
 8001fd4:	1e6e      	subs	r6, r5, #1
 8001fd6:	42a1      	cmp	r1, r4
 8001fd8:	d200      	bcs.n	8001fdc <__aeabi_ddiv+0x3f8>
 8001fda:	e0a4      	b.n	8002126 <__aeabi_ddiv+0x542>
 8001fdc:	4281      	cmp	r1, r0
 8001fde:	d200      	bcs.n	8001fe2 <__aeabi_ddiv+0x3fe>
 8001fe0:	e0c9      	b.n	8002176 <__aeabi_ddiv+0x592>
 8001fe2:	d100      	bne.n	8001fe6 <__aeabi_ddiv+0x402>
 8001fe4:	e0d9      	b.n	800219a <__aeabi_ddiv+0x5b6>
 8001fe6:	0035      	movs	r5, r6
 8001fe8:	e7ed      	b.n	8001fc6 <__aeabi_ddiv+0x3e2>
 8001fea:	2501      	movs	r5, #1
 8001fec:	426d      	negs	r5, r5
 8001fee:	2101      	movs	r1, #1
 8001ff0:	1a89      	subs	r1, r1, r2
 8001ff2:	2938      	cmp	r1, #56	; 0x38
 8001ff4:	dd00      	ble.n	8001ff8 <__aeabi_ddiv+0x414>
 8001ff6:	e64c      	b.n	8001c92 <__aeabi_ddiv+0xae>
 8001ff8:	291f      	cmp	r1, #31
 8001ffa:	dc00      	bgt.n	8001ffe <__aeabi_ddiv+0x41a>
 8001ffc:	e07f      	b.n	80020fe <__aeabi_ddiv+0x51a>
 8001ffe:	231f      	movs	r3, #31
 8002000:	425b      	negs	r3, r3
 8002002:	1a9a      	subs	r2, r3, r2
 8002004:	4643      	mov	r3, r8
 8002006:	40d3      	lsrs	r3, r2
 8002008:	2920      	cmp	r1, #32
 800200a:	d004      	beq.n	8002016 <__aeabi_ddiv+0x432>
 800200c:	4644      	mov	r4, r8
 800200e:	4a65      	ldr	r2, [pc, #404]	; (80021a4 <__aeabi_ddiv+0x5c0>)
 8002010:	445a      	add	r2, fp
 8002012:	4094      	lsls	r4, r2
 8002014:	4325      	orrs	r5, r4
 8002016:	1e6a      	subs	r2, r5, #1
 8002018:	4195      	sbcs	r5, r2
 800201a:	2207      	movs	r2, #7
 800201c:	432b      	orrs	r3, r5
 800201e:	0015      	movs	r5, r2
 8002020:	2400      	movs	r4, #0
 8002022:	401d      	ands	r5, r3
 8002024:	421a      	tst	r2, r3
 8002026:	d100      	bne.n	800202a <__aeabi_ddiv+0x446>
 8002028:	e0a1      	b.n	800216e <__aeabi_ddiv+0x58a>
 800202a:	220f      	movs	r2, #15
 800202c:	2400      	movs	r4, #0
 800202e:	401a      	ands	r2, r3
 8002030:	2a04      	cmp	r2, #4
 8002032:	d100      	bne.n	8002036 <__aeabi_ddiv+0x452>
 8002034:	e098      	b.n	8002168 <__aeabi_ddiv+0x584>
 8002036:	1d1a      	adds	r2, r3, #4
 8002038:	429a      	cmp	r2, r3
 800203a:	419b      	sbcs	r3, r3
 800203c:	425b      	negs	r3, r3
 800203e:	18e4      	adds	r4, r4, r3
 8002040:	0013      	movs	r3, r2
 8002042:	0222      	lsls	r2, r4, #8
 8002044:	d400      	bmi.n	8002048 <__aeabi_ddiv+0x464>
 8002046:	e08f      	b.n	8002168 <__aeabi_ddiv+0x584>
 8002048:	2301      	movs	r3, #1
 800204a:	2400      	movs	r4, #0
 800204c:	2500      	movs	r5, #0
 800204e:	e623      	b.n	8001c98 <__aeabi_ddiv+0xb4>
 8002050:	42b5      	cmp	r5, r6
 8002052:	d300      	bcc.n	8002056 <__aeabi_ddiv+0x472>
 8002054:	e764      	b.n	8001f20 <__aeabi_ddiv+0x33c>
 8002056:	4643      	mov	r3, r8
 8002058:	1e5a      	subs	r2, r3, #1
 800205a:	9b00      	ldr	r3, [sp, #0]
 800205c:	469c      	mov	ip, r3
 800205e:	4465      	add	r5, ip
 8002060:	001f      	movs	r7, r3
 8002062:	429d      	cmp	r5, r3
 8002064:	419b      	sbcs	r3, r3
 8002066:	425b      	negs	r3, r3
 8002068:	191b      	adds	r3, r3, r4
 800206a:	18c9      	adds	r1, r1, r3
 800206c:	428c      	cmp	r4, r1
 800206e:	d23a      	bcs.n	80020e6 <__aeabi_ddiv+0x502>
 8002070:	4288      	cmp	r0, r1
 8002072:	d863      	bhi.n	800213c <__aeabi_ddiv+0x558>
 8002074:	d060      	beq.n	8002138 <__aeabi_ddiv+0x554>
 8002076:	4690      	mov	r8, r2
 8002078:	e752      	b.n	8001f20 <__aeabi_ddiv+0x33c>
 800207a:	42aa      	cmp	r2, r5
 800207c:	d900      	bls.n	8002080 <__aeabi_ddiv+0x49c>
 800207e:	e6ea      	b.n	8001e56 <__aeabi_ddiv+0x272>
 8002080:	4643      	mov	r3, r8
 8002082:	07de      	lsls	r6, r3, #31
 8002084:	0858      	lsrs	r0, r3, #1
 8002086:	086b      	lsrs	r3, r5, #1
 8002088:	431e      	orrs	r6, r3
 800208a:	07ed      	lsls	r5, r5, #31
 800208c:	e6ea      	b.n	8001e64 <__aeabi_ddiv+0x280>
 800208e:	4648      	mov	r0, r9
 8002090:	f001 f880 	bl	8003194 <__clzsi2>
 8002094:	0001      	movs	r1, r0
 8002096:	0002      	movs	r2, r0
 8002098:	3115      	adds	r1, #21
 800209a:	3220      	adds	r2, #32
 800209c:	291c      	cmp	r1, #28
 800209e:	dc00      	bgt.n	80020a2 <__aeabi_ddiv+0x4be>
 80020a0:	e61a      	b.n	8001cd8 <__aeabi_ddiv+0xf4>
 80020a2:	464b      	mov	r3, r9
 80020a4:	3808      	subs	r0, #8
 80020a6:	4083      	lsls	r3, r0
 80020a8:	2500      	movs	r5, #0
 80020aa:	4698      	mov	r8, r3
 80020ac:	e620      	b.n	8001cf0 <__aeabi_ddiv+0x10c>
 80020ae:	f001 f871 	bl	8003194 <__clzsi2>
 80020b2:	0003      	movs	r3, r0
 80020b4:	001a      	movs	r2, r3
 80020b6:	3215      	adds	r2, #21
 80020b8:	3020      	adds	r0, #32
 80020ba:	2a1c      	cmp	r2, #28
 80020bc:	dc00      	bgt.n	80020c0 <__aeabi_ddiv+0x4dc>
 80020be:	e630      	b.n	8001d22 <__aeabi_ddiv+0x13e>
 80020c0:	4654      	mov	r4, sl
 80020c2:	3b08      	subs	r3, #8
 80020c4:	2200      	movs	r2, #0
 80020c6:	409c      	lsls	r4, r3
 80020c8:	e635      	b.n	8001d36 <__aeabi_ddiv+0x152>
 80020ca:	230f      	movs	r3, #15
 80020cc:	402b      	ands	r3, r5
 80020ce:	2b04      	cmp	r3, #4
 80020d0:	d100      	bne.n	80020d4 <__aeabi_ddiv+0x4f0>
 80020d2:	e652      	b.n	8001d7a <__aeabi_ddiv+0x196>
 80020d4:	2305      	movs	r3, #5
 80020d6:	425b      	negs	r3, r3
 80020d8:	42ab      	cmp	r3, r5
 80020da:	419b      	sbcs	r3, r3
 80020dc:	3504      	adds	r5, #4
 80020de:	425b      	negs	r3, r3
 80020e0:	08ed      	lsrs	r5, r5, #3
 80020e2:	4498      	add	r8, r3
 80020e4:	e64a      	b.n	8001d7c <__aeabi_ddiv+0x198>
 80020e6:	428c      	cmp	r4, r1
 80020e8:	d1c5      	bne.n	8002076 <__aeabi_ddiv+0x492>
 80020ea:	42af      	cmp	r7, r5
 80020ec:	d9c0      	bls.n	8002070 <__aeabi_ddiv+0x48c>
 80020ee:	4690      	mov	r8, r2
 80020f0:	e716      	b.n	8001f20 <__aeabi_ddiv+0x33c>
 80020f2:	428a      	cmp	r2, r1
 80020f4:	d800      	bhi.n	80020f8 <__aeabi_ddiv+0x514>
 80020f6:	e6ea      	b.n	8001ece <__aeabi_ddiv+0x2ea>
 80020f8:	1e83      	subs	r3, r0, #2
 80020fa:	1909      	adds	r1, r1, r4
 80020fc:	e6e7      	b.n	8001ece <__aeabi_ddiv+0x2ea>
 80020fe:	4a2a      	ldr	r2, [pc, #168]	; (80021a8 <__aeabi_ddiv+0x5c4>)
 8002100:	0028      	movs	r0, r5
 8002102:	445a      	add	r2, fp
 8002104:	4643      	mov	r3, r8
 8002106:	4095      	lsls	r5, r2
 8002108:	4093      	lsls	r3, r2
 800210a:	40c8      	lsrs	r0, r1
 800210c:	1e6a      	subs	r2, r5, #1
 800210e:	4195      	sbcs	r5, r2
 8002110:	4644      	mov	r4, r8
 8002112:	4303      	orrs	r3, r0
 8002114:	432b      	orrs	r3, r5
 8002116:	40cc      	lsrs	r4, r1
 8002118:	075a      	lsls	r2, r3, #29
 800211a:	d092      	beq.n	8002042 <__aeabi_ddiv+0x45e>
 800211c:	220f      	movs	r2, #15
 800211e:	401a      	ands	r2, r3
 8002120:	2a04      	cmp	r2, #4
 8002122:	d188      	bne.n	8002036 <__aeabi_ddiv+0x452>
 8002124:	e78d      	b.n	8002042 <__aeabi_ddiv+0x45e>
 8002126:	0035      	movs	r5, r6
 8002128:	4281      	cmp	r1, r0
 800212a:	d000      	beq.n	800212e <__aeabi_ddiv+0x54a>
 800212c:	e74b      	b.n	8001fc6 <__aeabi_ddiv+0x3e2>
 800212e:	9a00      	ldr	r2, [sp, #0]
 8002130:	4293      	cmp	r3, r2
 8002132:	d000      	beq.n	8002136 <__aeabi_ddiv+0x552>
 8002134:	e747      	b.n	8001fc6 <__aeabi_ddiv+0x3e2>
 8002136:	e618      	b.n	8001d6a <__aeabi_ddiv+0x186>
 8002138:	42ae      	cmp	r6, r5
 800213a:	d99c      	bls.n	8002076 <__aeabi_ddiv+0x492>
 800213c:	2302      	movs	r3, #2
 800213e:	425b      	negs	r3, r3
 8002140:	469c      	mov	ip, r3
 8002142:	9b00      	ldr	r3, [sp, #0]
 8002144:	44e0      	add	r8, ip
 8002146:	469c      	mov	ip, r3
 8002148:	4465      	add	r5, ip
 800214a:	429d      	cmp	r5, r3
 800214c:	419b      	sbcs	r3, r3
 800214e:	425b      	negs	r3, r3
 8002150:	191b      	adds	r3, r3, r4
 8002152:	18c9      	adds	r1, r1, r3
 8002154:	e6e4      	b.n	8001f20 <__aeabi_ddiv+0x33c>
 8002156:	4a15      	ldr	r2, [pc, #84]	; (80021ac <__aeabi_ddiv+0x5c8>)
 8002158:	445a      	add	r2, fp
 800215a:	2a00      	cmp	r2, #0
 800215c:	dc00      	bgt.n	8002160 <__aeabi_ddiv+0x57c>
 800215e:	e744      	b.n	8001fea <__aeabi_ddiv+0x406>
 8002160:	2301      	movs	r3, #1
 8002162:	2500      	movs	r5, #0
 8002164:	4498      	add	r8, r3
 8002166:	e609      	b.n	8001d7c <__aeabi_ddiv+0x198>
 8002168:	0765      	lsls	r5, r4, #29
 800216a:	0264      	lsls	r4, r4, #9
 800216c:	0b24      	lsrs	r4, r4, #12
 800216e:	08db      	lsrs	r3, r3, #3
 8002170:	431d      	orrs	r5, r3
 8002172:	2300      	movs	r3, #0
 8002174:	e590      	b.n	8001c98 <__aeabi_ddiv+0xb4>
 8002176:	9e00      	ldr	r6, [sp, #0]
 8002178:	3d02      	subs	r5, #2
 800217a:	0072      	lsls	r2, r6, #1
 800217c:	42b2      	cmp	r2, r6
 800217e:	41bf      	sbcs	r7, r7
 8002180:	427f      	negs	r7, r7
 8002182:	193c      	adds	r4, r7, r4
 8002184:	1909      	adds	r1, r1, r4
 8002186:	9200      	str	r2, [sp, #0]
 8002188:	e7ce      	b.n	8002128 <__aeabi_ddiv+0x544>
 800218a:	2480      	movs	r4, #128	; 0x80
 800218c:	4643      	mov	r3, r8
 800218e:	0324      	lsls	r4, r4, #12
 8002190:	431c      	orrs	r4, r3
 8002192:	0324      	lsls	r4, r4, #12
 8002194:	4b06      	ldr	r3, [pc, #24]	; (80021b0 <__aeabi_ddiv+0x5cc>)
 8002196:	0b24      	lsrs	r4, r4, #12
 8002198:	e57e      	b.n	8001c98 <__aeabi_ddiv+0xb4>
 800219a:	9a00      	ldr	r2, [sp, #0]
 800219c:	429a      	cmp	r2, r3
 800219e:	d3ea      	bcc.n	8002176 <__aeabi_ddiv+0x592>
 80021a0:	0035      	movs	r5, r6
 80021a2:	e7c4      	b.n	800212e <__aeabi_ddiv+0x54a>
 80021a4:	0000043e 	.word	0x0000043e
 80021a8:	0000041e 	.word	0x0000041e
 80021ac:	000003ff 	.word	0x000003ff
 80021b0:	000007ff 	.word	0x000007ff

080021b4 <__eqdf2>:
 80021b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80021b6:	464f      	mov	r7, r9
 80021b8:	4646      	mov	r6, r8
 80021ba:	46d6      	mov	lr, sl
 80021bc:	4694      	mov	ip, r2
 80021be:	4691      	mov	r9, r2
 80021c0:	031a      	lsls	r2, r3, #12
 80021c2:	0b12      	lsrs	r2, r2, #12
 80021c4:	4d18      	ldr	r5, [pc, #96]	; (8002228 <__eqdf2+0x74>)
 80021c6:	b5c0      	push	{r6, r7, lr}
 80021c8:	004c      	lsls	r4, r1, #1
 80021ca:	030f      	lsls	r7, r1, #12
 80021cc:	4692      	mov	sl, r2
 80021ce:	005a      	lsls	r2, r3, #1
 80021d0:	0006      	movs	r6, r0
 80021d2:	4680      	mov	r8, r0
 80021d4:	0b3f      	lsrs	r7, r7, #12
 80021d6:	2001      	movs	r0, #1
 80021d8:	0d64      	lsrs	r4, r4, #21
 80021da:	0fc9      	lsrs	r1, r1, #31
 80021dc:	0d52      	lsrs	r2, r2, #21
 80021de:	0fdb      	lsrs	r3, r3, #31
 80021e0:	42ac      	cmp	r4, r5
 80021e2:	d00a      	beq.n	80021fa <__eqdf2+0x46>
 80021e4:	42aa      	cmp	r2, r5
 80021e6:	d003      	beq.n	80021f0 <__eqdf2+0x3c>
 80021e8:	4294      	cmp	r4, r2
 80021ea:	d101      	bne.n	80021f0 <__eqdf2+0x3c>
 80021ec:	4557      	cmp	r7, sl
 80021ee:	d00d      	beq.n	800220c <__eqdf2+0x58>
 80021f0:	bce0      	pop	{r5, r6, r7}
 80021f2:	46ba      	mov	sl, r7
 80021f4:	46b1      	mov	r9, r6
 80021f6:	46a8      	mov	r8, r5
 80021f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80021fa:	003d      	movs	r5, r7
 80021fc:	4335      	orrs	r5, r6
 80021fe:	d1f7      	bne.n	80021f0 <__eqdf2+0x3c>
 8002200:	42a2      	cmp	r2, r4
 8002202:	d1f5      	bne.n	80021f0 <__eqdf2+0x3c>
 8002204:	4652      	mov	r2, sl
 8002206:	4665      	mov	r5, ip
 8002208:	432a      	orrs	r2, r5
 800220a:	d1f1      	bne.n	80021f0 <__eqdf2+0x3c>
 800220c:	2001      	movs	r0, #1
 800220e:	45c8      	cmp	r8, r9
 8002210:	d1ee      	bne.n	80021f0 <__eqdf2+0x3c>
 8002212:	4299      	cmp	r1, r3
 8002214:	d006      	beq.n	8002224 <__eqdf2+0x70>
 8002216:	2c00      	cmp	r4, #0
 8002218:	d1ea      	bne.n	80021f0 <__eqdf2+0x3c>
 800221a:	433e      	orrs	r6, r7
 800221c:	0030      	movs	r0, r6
 800221e:	1e46      	subs	r6, r0, #1
 8002220:	41b0      	sbcs	r0, r6
 8002222:	e7e5      	b.n	80021f0 <__eqdf2+0x3c>
 8002224:	2000      	movs	r0, #0
 8002226:	e7e3      	b.n	80021f0 <__eqdf2+0x3c>
 8002228:	000007ff 	.word	0x000007ff

0800222c <__gedf2>:
 800222c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800222e:	464e      	mov	r6, r9
 8002230:	4645      	mov	r5, r8
 8002232:	4657      	mov	r7, sl
 8002234:	46de      	mov	lr, fp
 8002236:	0004      	movs	r4, r0
 8002238:	0018      	movs	r0, r3
 800223a:	b5e0      	push	{r5, r6, r7, lr}
 800223c:	0016      	movs	r6, r2
 800223e:	031b      	lsls	r3, r3, #12
 8002240:	0b1b      	lsrs	r3, r3, #12
 8002242:	4d32      	ldr	r5, [pc, #200]	; (800230c <__gedf2+0xe0>)
 8002244:	030f      	lsls	r7, r1, #12
 8002246:	004a      	lsls	r2, r1, #1
 8002248:	4699      	mov	r9, r3
 800224a:	0043      	lsls	r3, r0, #1
 800224c:	46a4      	mov	ip, r4
 800224e:	46b0      	mov	r8, r6
 8002250:	0b3f      	lsrs	r7, r7, #12
 8002252:	0d52      	lsrs	r2, r2, #21
 8002254:	0fc9      	lsrs	r1, r1, #31
 8002256:	0d5b      	lsrs	r3, r3, #21
 8002258:	0fc0      	lsrs	r0, r0, #31
 800225a:	42aa      	cmp	r2, r5
 800225c:	d029      	beq.n	80022b2 <__gedf2+0x86>
 800225e:	42ab      	cmp	r3, r5
 8002260:	d018      	beq.n	8002294 <__gedf2+0x68>
 8002262:	2a00      	cmp	r2, #0
 8002264:	d12a      	bne.n	80022bc <__gedf2+0x90>
 8002266:	433c      	orrs	r4, r7
 8002268:	46a3      	mov	fp, r4
 800226a:	4265      	negs	r5, r4
 800226c:	4165      	adcs	r5, r4
 800226e:	2b00      	cmp	r3, #0
 8002270:	d102      	bne.n	8002278 <__gedf2+0x4c>
 8002272:	464c      	mov	r4, r9
 8002274:	4326      	orrs	r6, r4
 8002276:	d027      	beq.n	80022c8 <__gedf2+0x9c>
 8002278:	2d00      	cmp	r5, #0
 800227a:	d115      	bne.n	80022a8 <__gedf2+0x7c>
 800227c:	4281      	cmp	r1, r0
 800227e:	d028      	beq.n	80022d2 <__gedf2+0xa6>
 8002280:	2002      	movs	r0, #2
 8002282:	3901      	subs	r1, #1
 8002284:	4008      	ands	r0, r1
 8002286:	3801      	subs	r0, #1
 8002288:	bcf0      	pop	{r4, r5, r6, r7}
 800228a:	46bb      	mov	fp, r7
 800228c:	46b2      	mov	sl, r6
 800228e:	46a9      	mov	r9, r5
 8002290:	46a0      	mov	r8, r4
 8002292:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002294:	464d      	mov	r5, r9
 8002296:	432e      	orrs	r6, r5
 8002298:	d12f      	bne.n	80022fa <__gedf2+0xce>
 800229a:	2a00      	cmp	r2, #0
 800229c:	d1ee      	bne.n	800227c <__gedf2+0x50>
 800229e:	433c      	orrs	r4, r7
 80022a0:	4265      	negs	r5, r4
 80022a2:	4165      	adcs	r5, r4
 80022a4:	2d00      	cmp	r5, #0
 80022a6:	d0e9      	beq.n	800227c <__gedf2+0x50>
 80022a8:	2800      	cmp	r0, #0
 80022aa:	d1ed      	bne.n	8002288 <__gedf2+0x5c>
 80022ac:	2001      	movs	r0, #1
 80022ae:	4240      	negs	r0, r0
 80022b0:	e7ea      	b.n	8002288 <__gedf2+0x5c>
 80022b2:	003d      	movs	r5, r7
 80022b4:	4325      	orrs	r5, r4
 80022b6:	d120      	bne.n	80022fa <__gedf2+0xce>
 80022b8:	4293      	cmp	r3, r2
 80022ba:	d0eb      	beq.n	8002294 <__gedf2+0x68>
 80022bc:	2b00      	cmp	r3, #0
 80022be:	d1dd      	bne.n	800227c <__gedf2+0x50>
 80022c0:	464c      	mov	r4, r9
 80022c2:	4326      	orrs	r6, r4
 80022c4:	d1da      	bne.n	800227c <__gedf2+0x50>
 80022c6:	e7db      	b.n	8002280 <__gedf2+0x54>
 80022c8:	465b      	mov	r3, fp
 80022ca:	2000      	movs	r0, #0
 80022cc:	2b00      	cmp	r3, #0
 80022ce:	d0db      	beq.n	8002288 <__gedf2+0x5c>
 80022d0:	e7d6      	b.n	8002280 <__gedf2+0x54>
 80022d2:	429a      	cmp	r2, r3
 80022d4:	dc0a      	bgt.n	80022ec <__gedf2+0xc0>
 80022d6:	dbe7      	blt.n	80022a8 <__gedf2+0x7c>
 80022d8:	454f      	cmp	r7, r9
 80022da:	d8d1      	bhi.n	8002280 <__gedf2+0x54>
 80022dc:	d010      	beq.n	8002300 <__gedf2+0xd4>
 80022de:	2000      	movs	r0, #0
 80022e0:	454f      	cmp	r7, r9
 80022e2:	d2d1      	bcs.n	8002288 <__gedf2+0x5c>
 80022e4:	2900      	cmp	r1, #0
 80022e6:	d0e1      	beq.n	80022ac <__gedf2+0x80>
 80022e8:	0008      	movs	r0, r1
 80022ea:	e7cd      	b.n	8002288 <__gedf2+0x5c>
 80022ec:	4243      	negs	r3, r0
 80022ee:	4158      	adcs	r0, r3
 80022f0:	2302      	movs	r3, #2
 80022f2:	4240      	negs	r0, r0
 80022f4:	4018      	ands	r0, r3
 80022f6:	3801      	subs	r0, #1
 80022f8:	e7c6      	b.n	8002288 <__gedf2+0x5c>
 80022fa:	2002      	movs	r0, #2
 80022fc:	4240      	negs	r0, r0
 80022fe:	e7c3      	b.n	8002288 <__gedf2+0x5c>
 8002300:	45c4      	cmp	ip, r8
 8002302:	d8bd      	bhi.n	8002280 <__gedf2+0x54>
 8002304:	2000      	movs	r0, #0
 8002306:	45c4      	cmp	ip, r8
 8002308:	d2be      	bcs.n	8002288 <__gedf2+0x5c>
 800230a:	e7eb      	b.n	80022e4 <__gedf2+0xb8>
 800230c:	000007ff 	.word	0x000007ff

08002310 <__ledf2>:
 8002310:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002312:	464e      	mov	r6, r9
 8002314:	4645      	mov	r5, r8
 8002316:	4657      	mov	r7, sl
 8002318:	46de      	mov	lr, fp
 800231a:	0004      	movs	r4, r0
 800231c:	0018      	movs	r0, r3
 800231e:	b5e0      	push	{r5, r6, r7, lr}
 8002320:	0016      	movs	r6, r2
 8002322:	031b      	lsls	r3, r3, #12
 8002324:	0b1b      	lsrs	r3, r3, #12
 8002326:	4d31      	ldr	r5, [pc, #196]	; (80023ec <__ledf2+0xdc>)
 8002328:	030f      	lsls	r7, r1, #12
 800232a:	004a      	lsls	r2, r1, #1
 800232c:	4699      	mov	r9, r3
 800232e:	0043      	lsls	r3, r0, #1
 8002330:	46a4      	mov	ip, r4
 8002332:	46b0      	mov	r8, r6
 8002334:	0b3f      	lsrs	r7, r7, #12
 8002336:	0d52      	lsrs	r2, r2, #21
 8002338:	0fc9      	lsrs	r1, r1, #31
 800233a:	0d5b      	lsrs	r3, r3, #21
 800233c:	0fc0      	lsrs	r0, r0, #31
 800233e:	42aa      	cmp	r2, r5
 8002340:	d011      	beq.n	8002366 <__ledf2+0x56>
 8002342:	42ab      	cmp	r3, r5
 8002344:	d014      	beq.n	8002370 <__ledf2+0x60>
 8002346:	2a00      	cmp	r2, #0
 8002348:	d12f      	bne.n	80023aa <__ledf2+0x9a>
 800234a:	433c      	orrs	r4, r7
 800234c:	46a3      	mov	fp, r4
 800234e:	4265      	negs	r5, r4
 8002350:	4165      	adcs	r5, r4
 8002352:	2b00      	cmp	r3, #0
 8002354:	d114      	bne.n	8002380 <__ledf2+0x70>
 8002356:	464c      	mov	r4, r9
 8002358:	4326      	orrs	r6, r4
 800235a:	d111      	bne.n	8002380 <__ledf2+0x70>
 800235c:	465b      	mov	r3, fp
 800235e:	2000      	movs	r0, #0
 8002360:	2b00      	cmp	r3, #0
 8002362:	d017      	beq.n	8002394 <__ledf2+0x84>
 8002364:	e010      	b.n	8002388 <__ledf2+0x78>
 8002366:	003d      	movs	r5, r7
 8002368:	4325      	orrs	r5, r4
 800236a:	d112      	bne.n	8002392 <__ledf2+0x82>
 800236c:	4293      	cmp	r3, r2
 800236e:	d11c      	bne.n	80023aa <__ledf2+0x9a>
 8002370:	464d      	mov	r5, r9
 8002372:	432e      	orrs	r6, r5
 8002374:	d10d      	bne.n	8002392 <__ledf2+0x82>
 8002376:	2a00      	cmp	r2, #0
 8002378:	d104      	bne.n	8002384 <__ledf2+0x74>
 800237a:	433c      	orrs	r4, r7
 800237c:	4265      	negs	r5, r4
 800237e:	4165      	adcs	r5, r4
 8002380:	2d00      	cmp	r5, #0
 8002382:	d10d      	bne.n	80023a0 <__ledf2+0x90>
 8002384:	4281      	cmp	r1, r0
 8002386:	d016      	beq.n	80023b6 <__ledf2+0xa6>
 8002388:	2002      	movs	r0, #2
 800238a:	3901      	subs	r1, #1
 800238c:	4008      	ands	r0, r1
 800238e:	3801      	subs	r0, #1
 8002390:	e000      	b.n	8002394 <__ledf2+0x84>
 8002392:	2002      	movs	r0, #2
 8002394:	bcf0      	pop	{r4, r5, r6, r7}
 8002396:	46bb      	mov	fp, r7
 8002398:	46b2      	mov	sl, r6
 800239a:	46a9      	mov	r9, r5
 800239c:	46a0      	mov	r8, r4
 800239e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80023a0:	2800      	cmp	r0, #0
 80023a2:	d1f7      	bne.n	8002394 <__ledf2+0x84>
 80023a4:	2001      	movs	r0, #1
 80023a6:	4240      	negs	r0, r0
 80023a8:	e7f4      	b.n	8002394 <__ledf2+0x84>
 80023aa:	2b00      	cmp	r3, #0
 80023ac:	d1ea      	bne.n	8002384 <__ledf2+0x74>
 80023ae:	464c      	mov	r4, r9
 80023b0:	4326      	orrs	r6, r4
 80023b2:	d1e7      	bne.n	8002384 <__ledf2+0x74>
 80023b4:	e7e8      	b.n	8002388 <__ledf2+0x78>
 80023b6:	429a      	cmp	r2, r3
 80023b8:	dd06      	ble.n	80023c8 <__ledf2+0xb8>
 80023ba:	4243      	negs	r3, r0
 80023bc:	4158      	adcs	r0, r3
 80023be:	2302      	movs	r3, #2
 80023c0:	4240      	negs	r0, r0
 80023c2:	4018      	ands	r0, r3
 80023c4:	3801      	subs	r0, #1
 80023c6:	e7e5      	b.n	8002394 <__ledf2+0x84>
 80023c8:	429a      	cmp	r2, r3
 80023ca:	dbe9      	blt.n	80023a0 <__ledf2+0x90>
 80023cc:	454f      	cmp	r7, r9
 80023ce:	d8db      	bhi.n	8002388 <__ledf2+0x78>
 80023d0:	d006      	beq.n	80023e0 <__ledf2+0xd0>
 80023d2:	2000      	movs	r0, #0
 80023d4:	454f      	cmp	r7, r9
 80023d6:	d2dd      	bcs.n	8002394 <__ledf2+0x84>
 80023d8:	2900      	cmp	r1, #0
 80023da:	d0e3      	beq.n	80023a4 <__ledf2+0x94>
 80023dc:	0008      	movs	r0, r1
 80023de:	e7d9      	b.n	8002394 <__ledf2+0x84>
 80023e0:	45c4      	cmp	ip, r8
 80023e2:	d8d1      	bhi.n	8002388 <__ledf2+0x78>
 80023e4:	2000      	movs	r0, #0
 80023e6:	45c4      	cmp	ip, r8
 80023e8:	d2d4      	bcs.n	8002394 <__ledf2+0x84>
 80023ea:	e7f5      	b.n	80023d8 <__ledf2+0xc8>
 80023ec:	000007ff 	.word	0x000007ff

080023f0 <__aeabi_dmul>:
 80023f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80023f2:	4657      	mov	r7, sl
 80023f4:	464e      	mov	r6, r9
 80023f6:	4645      	mov	r5, r8
 80023f8:	46de      	mov	lr, fp
 80023fa:	b5e0      	push	{r5, r6, r7, lr}
 80023fc:	4698      	mov	r8, r3
 80023fe:	030c      	lsls	r4, r1, #12
 8002400:	004b      	lsls	r3, r1, #1
 8002402:	0006      	movs	r6, r0
 8002404:	4692      	mov	sl, r2
 8002406:	b087      	sub	sp, #28
 8002408:	0b24      	lsrs	r4, r4, #12
 800240a:	0d5b      	lsrs	r3, r3, #21
 800240c:	0fcf      	lsrs	r7, r1, #31
 800240e:	2b00      	cmp	r3, #0
 8002410:	d06c      	beq.n	80024ec <__aeabi_dmul+0xfc>
 8002412:	4add      	ldr	r2, [pc, #884]	; (8002788 <__aeabi_dmul+0x398>)
 8002414:	4293      	cmp	r3, r2
 8002416:	d100      	bne.n	800241a <__aeabi_dmul+0x2a>
 8002418:	e086      	b.n	8002528 <__aeabi_dmul+0x138>
 800241a:	0f42      	lsrs	r2, r0, #29
 800241c:	00e4      	lsls	r4, r4, #3
 800241e:	4314      	orrs	r4, r2
 8002420:	2280      	movs	r2, #128	; 0x80
 8002422:	0412      	lsls	r2, r2, #16
 8002424:	4314      	orrs	r4, r2
 8002426:	4ad9      	ldr	r2, [pc, #868]	; (800278c <__aeabi_dmul+0x39c>)
 8002428:	00c5      	lsls	r5, r0, #3
 800242a:	4694      	mov	ip, r2
 800242c:	4463      	add	r3, ip
 800242e:	9300      	str	r3, [sp, #0]
 8002430:	2300      	movs	r3, #0
 8002432:	4699      	mov	r9, r3
 8002434:	469b      	mov	fp, r3
 8002436:	4643      	mov	r3, r8
 8002438:	4642      	mov	r2, r8
 800243a:	031e      	lsls	r6, r3, #12
 800243c:	0fd2      	lsrs	r2, r2, #31
 800243e:	005b      	lsls	r3, r3, #1
 8002440:	4650      	mov	r0, sl
 8002442:	4690      	mov	r8, r2
 8002444:	0b36      	lsrs	r6, r6, #12
 8002446:	0d5b      	lsrs	r3, r3, #21
 8002448:	d100      	bne.n	800244c <__aeabi_dmul+0x5c>
 800244a:	e078      	b.n	800253e <__aeabi_dmul+0x14e>
 800244c:	4ace      	ldr	r2, [pc, #824]	; (8002788 <__aeabi_dmul+0x398>)
 800244e:	4293      	cmp	r3, r2
 8002450:	d01d      	beq.n	800248e <__aeabi_dmul+0x9e>
 8002452:	49ce      	ldr	r1, [pc, #824]	; (800278c <__aeabi_dmul+0x39c>)
 8002454:	0f42      	lsrs	r2, r0, #29
 8002456:	468c      	mov	ip, r1
 8002458:	9900      	ldr	r1, [sp, #0]
 800245a:	4463      	add	r3, ip
 800245c:	00f6      	lsls	r6, r6, #3
 800245e:	468c      	mov	ip, r1
 8002460:	4316      	orrs	r6, r2
 8002462:	2280      	movs	r2, #128	; 0x80
 8002464:	449c      	add	ip, r3
 8002466:	0412      	lsls	r2, r2, #16
 8002468:	4663      	mov	r3, ip
 800246a:	4316      	orrs	r6, r2
 800246c:	00c2      	lsls	r2, r0, #3
 800246e:	2000      	movs	r0, #0
 8002470:	9300      	str	r3, [sp, #0]
 8002472:	9900      	ldr	r1, [sp, #0]
 8002474:	4643      	mov	r3, r8
 8002476:	3101      	adds	r1, #1
 8002478:	468c      	mov	ip, r1
 800247a:	4649      	mov	r1, r9
 800247c:	407b      	eors	r3, r7
 800247e:	9301      	str	r3, [sp, #4]
 8002480:	290f      	cmp	r1, #15
 8002482:	d900      	bls.n	8002486 <__aeabi_dmul+0x96>
 8002484:	e07e      	b.n	8002584 <__aeabi_dmul+0x194>
 8002486:	4bc2      	ldr	r3, [pc, #776]	; (8002790 <__aeabi_dmul+0x3a0>)
 8002488:	0089      	lsls	r1, r1, #2
 800248a:	5859      	ldr	r1, [r3, r1]
 800248c:	468f      	mov	pc, r1
 800248e:	4652      	mov	r2, sl
 8002490:	9b00      	ldr	r3, [sp, #0]
 8002492:	4332      	orrs	r2, r6
 8002494:	d000      	beq.n	8002498 <__aeabi_dmul+0xa8>
 8002496:	e156      	b.n	8002746 <__aeabi_dmul+0x356>
 8002498:	49bb      	ldr	r1, [pc, #748]	; (8002788 <__aeabi_dmul+0x398>)
 800249a:	2600      	movs	r6, #0
 800249c:	468c      	mov	ip, r1
 800249e:	4463      	add	r3, ip
 80024a0:	4649      	mov	r1, r9
 80024a2:	9300      	str	r3, [sp, #0]
 80024a4:	2302      	movs	r3, #2
 80024a6:	4319      	orrs	r1, r3
 80024a8:	4689      	mov	r9, r1
 80024aa:	2002      	movs	r0, #2
 80024ac:	e7e1      	b.n	8002472 <__aeabi_dmul+0x82>
 80024ae:	4643      	mov	r3, r8
 80024b0:	9301      	str	r3, [sp, #4]
 80024b2:	0034      	movs	r4, r6
 80024b4:	0015      	movs	r5, r2
 80024b6:	4683      	mov	fp, r0
 80024b8:	465b      	mov	r3, fp
 80024ba:	2b02      	cmp	r3, #2
 80024bc:	d05e      	beq.n	800257c <__aeabi_dmul+0x18c>
 80024be:	2b03      	cmp	r3, #3
 80024c0:	d100      	bne.n	80024c4 <__aeabi_dmul+0xd4>
 80024c2:	e1f3      	b.n	80028ac <__aeabi_dmul+0x4bc>
 80024c4:	2b01      	cmp	r3, #1
 80024c6:	d000      	beq.n	80024ca <__aeabi_dmul+0xda>
 80024c8:	e118      	b.n	80026fc <__aeabi_dmul+0x30c>
 80024ca:	2200      	movs	r2, #0
 80024cc:	2400      	movs	r4, #0
 80024ce:	2500      	movs	r5, #0
 80024d0:	9b01      	ldr	r3, [sp, #4]
 80024d2:	0512      	lsls	r2, r2, #20
 80024d4:	4322      	orrs	r2, r4
 80024d6:	07db      	lsls	r3, r3, #31
 80024d8:	431a      	orrs	r2, r3
 80024da:	0028      	movs	r0, r5
 80024dc:	0011      	movs	r1, r2
 80024de:	b007      	add	sp, #28
 80024e0:	bcf0      	pop	{r4, r5, r6, r7}
 80024e2:	46bb      	mov	fp, r7
 80024e4:	46b2      	mov	sl, r6
 80024e6:	46a9      	mov	r9, r5
 80024e8:	46a0      	mov	r8, r4
 80024ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80024ec:	0025      	movs	r5, r4
 80024ee:	4305      	orrs	r5, r0
 80024f0:	d100      	bne.n	80024f4 <__aeabi_dmul+0x104>
 80024f2:	e141      	b.n	8002778 <__aeabi_dmul+0x388>
 80024f4:	2c00      	cmp	r4, #0
 80024f6:	d100      	bne.n	80024fa <__aeabi_dmul+0x10a>
 80024f8:	e1ad      	b.n	8002856 <__aeabi_dmul+0x466>
 80024fa:	0020      	movs	r0, r4
 80024fc:	f000 fe4a 	bl	8003194 <__clzsi2>
 8002500:	0001      	movs	r1, r0
 8002502:	0002      	movs	r2, r0
 8002504:	390b      	subs	r1, #11
 8002506:	231d      	movs	r3, #29
 8002508:	0010      	movs	r0, r2
 800250a:	1a5b      	subs	r3, r3, r1
 800250c:	0031      	movs	r1, r6
 800250e:	0035      	movs	r5, r6
 8002510:	3808      	subs	r0, #8
 8002512:	4084      	lsls	r4, r0
 8002514:	40d9      	lsrs	r1, r3
 8002516:	4085      	lsls	r5, r0
 8002518:	430c      	orrs	r4, r1
 800251a:	489e      	ldr	r0, [pc, #632]	; (8002794 <__aeabi_dmul+0x3a4>)
 800251c:	1a83      	subs	r3, r0, r2
 800251e:	9300      	str	r3, [sp, #0]
 8002520:	2300      	movs	r3, #0
 8002522:	4699      	mov	r9, r3
 8002524:	469b      	mov	fp, r3
 8002526:	e786      	b.n	8002436 <__aeabi_dmul+0x46>
 8002528:	0005      	movs	r5, r0
 800252a:	4325      	orrs	r5, r4
 800252c:	d000      	beq.n	8002530 <__aeabi_dmul+0x140>
 800252e:	e11c      	b.n	800276a <__aeabi_dmul+0x37a>
 8002530:	2208      	movs	r2, #8
 8002532:	9300      	str	r3, [sp, #0]
 8002534:	2302      	movs	r3, #2
 8002536:	2400      	movs	r4, #0
 8002538:	4691      	mov	r9, r2
 800253a:	469b      	mov	fp, r3
 800253c:	e77b      	b.n	8002436 <__aeabi_dmul+0x46>
 800253e:	4652      	mov	r2, sl
 8002540:	4332      	orrs	r2, r6
 8002542:	d100      	bne.n	8002546 <__aeabi_dmul+0x156>
 8002544:	e10a      	b.n	800275c <__aeabi_dmul+0x36c>
 8002546:	2e00      	cmp	r6, #0
 8002548:	d100      	bne.n	800254c <__aeabi_dmul+0x15c>
 800254a:	e176      	b.n	800283a <__aeabi_dmul+0x44a>
 800254c:	0030      	movs	r0, r6
 800254e:	f000 fe21 	bl	8003194 <__clzsi2>
 8002552:	0002      	movs	r2, r0
 8002554:	3a0b      	subs	r2, #11
 8002556:	231d      	movs	r3, #29
 8002558:	0001      	movs	r1, r0
 800255a:	1a9b      	subs	r3, r3, r2
 800255c:	4652      	mov	r2, sl
 800255e:	3908      	subs	r1, #8
 8002560:	40da      	lsrs	r2, r3
 8002562:	408e      	lsls	r6, r1
 8002564:	4316      	orrs	r6, r2
 8002566:	4652      	mov	r2, sl
 8002568:	408a      	lsls	r2, r1
 800256a:	9b00      	ldr	r3, [sp, #0]
 800256c:	4989      	ldr	r1, [pc, #548]	; (8002794 <__aeabi_dmul+0x3a4>)
 800256e:	1a18      	subs	r0, r3, r0
 8002570:	0003      	movs	r3, r0
 8002572:	468c      	mov	ip, r1
 8002574:	4463      	add	r3, ip
 8002576:	2000      	movs	r0, #0
 8002578:	9300      	str	r3, [sp, #0]
 800257a:	e77a      	b.n	8002472 <__aeabi_dmul+0x82>
 800257c:	2400      	movs	r4, #0
 800257e:	2500      	movs	r5, #0
 8002580:	4a81      	ldr	r2, [pc, #516]	; (8002788 <__aeabi_dmul+0x398>)
 8002582:	e7a5      	b.n	80024d0 <__aeabi_dmul+0xe0>
 8002584:	0c2f      	lsrs	r7, r5, #16
 8002586:	042d      	lsls	r5, r5, #16
 8002588:	0c2d      	lsrs	r5, r5, #16
 800258a:	002b      	movs	r3, r5
 800258c:	0c11      	lsrs	r1, r2, #16
 800258e:	0412      	lsls	r2, r2, #16
 8002590:	0c12      	lsrs	r2, r2, #16
 8002592:	4353      	muls	r3, r2
 8002594:	4698      	mov	r8, r3
 8002596:	0013      	movs	r3, r2
 8002598:	0028      	movs	r0, r5
 800259a:	437b      	muls	r3, r7
 800259c:	4699      	mov	r9, r3
 800259e:	4348      	muls	r0, r1
 80025a0:	4448      	add	r0, r9
 80025a2:	4683      	mov	fp, r0
 80025a4:	4640      	mov	r0, r8
 80025a6:	000b      	movs	r3, r1
 80025a8:	0c00      	lsrs	r0, r0, #16
 80025aa:	4682      	mov	sl, r0
 80025ac:	4658      	mov	r0, fp
 80025ae:	437b      	muls	r3, r7
 80025b0:	4450      	add	r0, sl
 80025b2:	9302      	str	r3, [sp, #8]
 80025b4:	4581      	cmp	r9, r0
 80025b6:	d906      	bls.n	80025c6 <__aeabi_dmul+0x1d6>
 80025b8:	469a      	mov	sl, r3
 80025ba:	2380      	movs	r3, #128	; 0x80
 80025bc:	025b      	lsls	r3, r3, #9
 80025be:	4699      	mov	r9, r3
 80025c0:	44ca      	add	sl, r9
 80025c2:	4653      	mov	r3, sl
 80025c4:	9302      	str	r3, [sp, #8]
 80025c6:	0c03      	lsrs	r3, r0, #16
 80025c8:	469b      	mov	fp, r3
 80025ca:	4643      	mov	r3, r8
 80025cc:	041b      	lsls	r3, r3, #16
 80025ce:	0400      	lsls	r0, r0, #16
 80025d0:	0c1b      	lsrs	r3, r3, #16
 80025d2:	4698      	mov	r8, r3
 80025d4:	0003      	movs	r3, r0
 80025d6:	4443      	add	r3, r8
 80025d8:	9304      	str	r3, [sp, #16]
 80025da:	0c33      	lsrs	r3, r6, #16
 80025dc:	4699      	mov	r9, r3
 80025de:	002b      	movs	r3, r5
 80025e0:	0436      	lsls	r6, r6, #16
 80025e2:	0c36      	lsrs	r6, r6, #16
 80025e4:	4373      	muls	r3, r6
 80025e6:	4698      	mov	r8, r3
 80025e8:	0033      	movs	r3, r6
 80025ea:	437b      	muls	r3, r7
 80025ec:	469a      	mov	sl, r3
 80025ee:	464b      	mov	r3, r9
 80025f0:	435d      	muls	r5, r3
 80025f2:	435f      	muls	r7, r3
 80025f4:	4643      	mov	r3, r8
 80025f6:	4455      	add	r5, sl
 80025f8:	0c18      	lsrs	r0, r3, #16
 80025fa:	1940      	adds	r0, r0, r5
 80025fc:	4582      	cmp	sl, r0
 80025fe:	d903      	bls.n	8002608 <__aeabi_dmul+0x218>
 8002600:	2380      	movs	r3, #128	; 0x80
 8002602:	025b      	lsls	r3, r3, #9
 8002604:	469a      	mov	sl, r3
 8002606:	4457      	add	r7, sl
 8002608:	0c05      	lsrs	r5, r0, #16
 800260a:	19eb      	adds	r3, r5, r7
 800260c:	9305      	str	r3, [sp, #20]
 800260e:	4643      	mov	r3, r8
 8002610:	041d      	lsls	r5, r3, #16
 8002612:	0c2d      	lsrs	r5, r5, #16
 8002614:	0400      	lsls	r0, r0, #16
 8002616:	1940      	adds	r0, r0, r5
 8002618:	0c25      	lsrs	r5, r4, #16
 800261a:	0424      	lsls	r4, r4, #16
 800261c:	0c24      	lsrs	r4, r4, #16
 800261e:	0027      	movs	r7, r4
 8002620:	4357      	muls	r7, r2
 8002622:	436a      	muls	r2, r5
 8002624:	4690      	mov	r8, r2
 8002626:	002a      	movs	r2, r5
 8002628:	0c3b      	lsrs	r3, r7, #16
 800262a:	469a      	mov	sl, r3
 800262c:	434a      	muls	r2, r1
 800262e:	4361      	muls	r1, r4
 8002630:	4441      	add	r1, r8
 8002632:	4451      	add	r1, sl
 8002634:	4483      	add	fp, r0
 8002636:	4588      	cmp	r8, r1
 8002638:	d903      	bls.n	8002642 <__aeabi_dmul+0x252>
 800263a:	2380      	movs	r3, #128	; 0x80
 800263c:	025b      	lsls	r3, r3, #9
 800263e:	4698      	mov	r8, r3
 8002640:	4442      	add	r2, r8
 8002642:	043f      	lsls	r7, r7, #16
 8002644:	0c0b      	lsrs	r3, r1, #16
 8002646:	0c3f      	lsrs	r7, r7, #16
 8002648:	0409      	lsls	r1, r1, #16
 800264a:	19c9      	adds	r1, r1, r7
 800264c:	0027      	movs	r7, r4
 800264e:	4698      	mov	r8, r3
 8002650:	464b      	mov	r3, r9
 8002652:	4377      	muls	r7, r6
 8002654:	435c      	muls	r4, r3
 8002656:	436e      	muls	r6, r5
 8002658:	435d      	muls	r5, r3
 800265a:	0c3b      	lsrs	r3, r7, #16
 800265c:	4699      	mov	r9, r3
 800265e:	19a4      	adds	r4, r4, r6
 8002660:	444c      	add	r4, r9
 8002662:	4442      	add	r2, r8
 8002664:	9503      	str	r5, [sp, #12]
 8002666:	42a6      	cmp	r6, r4
 8002668:	d904      	bls.n	8002674 <__aeabi_dmul+0x284>
 800266a:	2380      	movs	r3, #128	; 0x80
 800266c:	025b      	lsls	r3, r3, #9
 800266e:	4698      	mov	r8, r3
 8002670:	4445      	add	r5, r8
 8002672:	9503      	str	r5, [sp, #12]
 8002674:	9b02      	ldr	r3, [sp, #8]
 8002676:	043f      	lsls	r7, r7, #16
 8002678:	445b      	add	r3, fp
 800267a:	001e      	movs	r6, r3
 800267c:	4283      	cmp	r3, r0
 800267e:	4180      	sbcs	r0, r0
 8002680:	0423      	lsls	r3, r4, #16
 8002682:	4698      	mov	r8, r3
 8002684:	9b05      	ldr	r3, [sp, #20]
 8002686:	0c3f      	lsrs	r7, r7, #16
 8002688:	4447      	add	r7, r8
 800268a:	4698      	mov	r8, r3
 800268c:	1876      	adds	r6, r6, r1
 800268e:	428e      	cmp	r6, r1
 8002690:	4189      	sbcs	r1, r1
 8002692:	4447      	add	r7, r8
 8002694:	4240      	negs	r0, r0
 8002696:	183d      	adds	r5, r7, r0
 8002698:	46a8      	mov	r8, r5
 800269a:	4693      	mov	fp, r2
 800269c:	4249      	negs	r1, r1
 800269e:	468a      	mov	sl, r1
 80026a0:	44c3      	add	fp, r8
 80026a2:	429f      	cmp	r7, r3
 80026a4:	41bf      	sbcs	r7, r7
 80026a6:	4580      	cmp	r8, r0
 80026a8:	4180      	sbcs	r0, r0
 80026aa:	9b03      	ldr	r3, [sp, #12]
 80026ac:	44da      	add	sl, fp
 80026ae:	4698      	mov	r8, r3
 80026b0:	4653      	mov	r3, sl
 80026b2:	4240      	negs	r0, r0
 80026b4:	427f      	negs	r7, r7
 80026b6:	4307      	orrs	r7, r0
 80026b8:	0c24      	lsrs	r4, r4, #16
 80026ba:	4593      	cmp	fp, r2
 80026bc:	4192      	sbcs	r2, r2
 80026be:	458a      	cmp	sl, r1
 80026c0:	4189      	sbcs	r1, r1
 80026c2:	193f      	adds	r7, r7, r4
 80026c4:	0ddc      	lsrs	r4, r3, #23
 80026c6:	9b04      	ldr	r3, [sp, #16]
 80026c8:	0275      	lsls	r5, r6, #9
 80026ca:	431d      	orrs	r5, r3
 80026cc:	1e68      	subs	r0, r5, #1
 80026ce:	4185      	sbcs	r5, r0
 80026d0:	4653      	mov	r3, sl
 80026d2:	4252      	negs	r2, r2
 80026d4:	4249      	negs	r1, r1
 80026d6:	430a      	orrs	r2, r1
 80026d8:	18bf      	adds	r7, r7, r2
 80026da:	4447      	add	r7, r8
 80026dc:	0df6      	lsrs	r6, r6, #23
 80026de:	027f      	lsls	r7, r7, #9
 80026e0:	4335      	orrs	r5, r6
 80026e2:	025a      	lsls	r2, r3, #9
 80026e4:	433c      	orrs	r4, r7
 80026e6:	4315      	orrs	r5, r2
 80026e8:	01fb      	lsls	r3, r7, #7
 80026ea:	d400      	bmi.n	80026ee <__aeabi_dmul+0x2fe>
 80026ec:	e0c1      	b.n	8002872 <__aeabi_dmul+0x482>
 80026ee:	2101      	movs	r1, #1
 80026f0:	086a      	lsrs	r2, r5, #1
 80026f2:	400d      	ands	r5, r1
 80026f4:	4315      	orrs	r5, r2
 80026f6:	07e2      	lsls	r2, r4, #31
 80026f8:	4315      	orrs	r5, r2
 80026fa:	0864      	lsrs	r4, r4, #1
 80026fc:	4926      	ldr	r1, [pc, #152]	; (8002798 <__aeabi_dmul+0x3a8>)
 80026fe:	4461      	add	r1, ip
 8002700:	2900      	cmp	r1, #0
 8002702:	dd56      	ble.n	80027b2 <__aeabi_dmul+0x3c2>
 8002704:	076b      	lsls	r3, r5, #29
 8002706:	d009      	beq.n	800271c <__aeabi_dmul+0x32c>
 8002708:	220f      	movs	r2, #15
 800270a:	402a      	ands	r2, r5
 800270c:	2a04      	cmp	r2, #4
 800270e:	d005      	beq.n	800271c <__aeabi_dmul+0x32c>
 8002710:	1d2a      	adds	r2, r5, #4
 8002712:	42aa      	cmp	r2, r5
 8002714:	41ad      	sbcs	r5, r5
 8002716:	426d      	negs	r5, r5
 8002718:	1964      	adds	r4, r4, r5
 800271a:	0015      	movs	r5, r2
 800271c:	01e3      	lsls	r3, r4, #7
 800271e:	d504      	bpl.n	800272a <__aeabi_dmul+0x33a>
 8002720:	2180      	movs	r1, #128	; 0x80
 8002722:	4a1e      	ldr	r2, [pc, #120]	; (800279c <__aeabi_dmul+0x3ac>)
 8002724:	00c9      	lsls	r1, r1, #3
 8002726:	4014      	ands	r4, r2
 8002728:	4461      	add	r1, ip
 800272a:	4a1d      	ldr	r2, [pc, #116]	; (80027a0 <__aeabi_dmul+0x3b0>)
 800272c:	4291      	cmp	r1, r2
 800272e:	dd00      	ble.n	8002732 <__aeabi_dmul+0x342>
 8002730:	e724      	b.n	800257c <__aeabi_dmul+0x18c>
 8002732:	0762      	lsls	r2, r4, #29
 8002734:	08ed      	lsrs	r5, r5, #3
 8002736:	0264      	lsls	r4, r4, #9
 8002738:	0549      	lsls	r1, r1, #21
 800273a:	4315      	orrs	r5, r2
 800273c:	0b24      	lsrs	r4, r4, #12
 800273e:	0d4a      	lsrs	r2, r1, #21
 8002740:	e6c6      	b.n	80024d0 <__aeabi_dmul+0xe0>
 8002742:	9701      	str	r7, [sp, #4]
 8002744:	e6b8      	b.n	80024b8 <__aeabi_dmul+0xc8>
 8002746:	4a10      	ldr	r2, [pc, #64]	; (8002788 <__aeabi_dmul+0x398>)
 8002748:	2003      	movs	r0, #3
 800274a:	4694      	mov	ip, r2
 800274c:	4463      	add	r3, ip
 800274e:	464a      	mov	r2, r9
 8002750:	9300      	str	r3, [sp, #0]
 8002752:	2303      	movs	r3, #3
 8002754:	431a      	orrs	r2, r3
 8002756:	4691      	mov	r9, r2
 8002758:	4652      	mov	r2, sl
 800275a:	e68a      	b.n	8002472 <__aeabi_dmul+0x82>
 800275c:	4649      	mov	r1, r9
 800275e:	2301      	movs	r3, #1
 8002760:	4319      	orrs	r1, r3
 8002762:	4689      	mov	r9, r1
 8002764:	2600      	movs	r6, #0
 8002766:	2001      	movs	r0, #1
 8002768:	e683      	b.n	8002472 <__aeabi_dmul+0x82>
 800276a:	220c      	movs	r2, #12
 800276c:	9300      	str	r3, [sp, #0]
 800276e:	2303      	movs	r3, #3
 8002770:	0005      	movs	r5, r0
 8002772:	4691      	mov	r9, r2
 8002774:	469b      	mov	fp, r3
 8002776:	e65e      	b.n	8002436 <__aeabi_dmul+0x46>
 8002778:	2304      	movs	r3, #4
 800277a:	4699      	mov	r9, r3
 800277c:	2300      	movs	r3, #0
 800277e:	9300      	str	r3, [sp, #0]
 8002780:	3301      	adds	r3, #1
 8002782:	2400      	movs	r4, #0
 8002784:	469b      	mov	fp, r3
 8002786:	e656      	b.n	8002436 <__aeabi_dmul+0x46>
 8002788:	000007ff 	.word	0x000007ff
 800278c:	fffffc01 	.word	0xfffffc01
 8002790:	0801fdf4 	.word	0x0801fdf4
 8002794:	fffffc0d 	.word	0xfffffc0d
 8002798:	000003ff 	.word	0x000003ff
 800279c:	feffffff 	.word	0xfeffffff
 80027a0:	000007fe 	.word	0x000007fe
 80027a4:	2300      	movs	r3, #0
 80027a6:	2480      	movs	r4, #128	; 0x80
 80027a8:	2500      	movs	r5, #0
 80027aa:	4a44      	ldr	r2, [pc, #272]	; (80028bc <__aeabi_dmul+0x4cc>)
 80027ac:	9301      	str	r3, [sp, #4]
 80027ae:	0324      	lsls	r4, r4, #12
 80027b0:	e68e      	b.n	80024d0 <__aeabi_dmul+0xe0>
 80027b2:	2001      	movs	r0, #1
 80027b4:	1a40      	subs	r0, r0, r1
 80027b6:	2838      	cmp	r0, #56	; 0x38
 80027b8:	dd00      	ble.n	80027bc <__aeabi_dmul+0x3cc>
 80027ba:	e686      	b.n	80024ca <__aeabi_dmul+0xda>
 80027bc:	281f      	cmp	r0, #31
 80027be:	dd5b      	ble.n	8002878 <__aeabi_dmul+0x488>
 80027c0:	221f      	movs	r2, #31
 80027c2:	0023      	movs	r3, r4
 80027c4:	4252      	negs	r2, r2
 80027c6:	1a51      	subs	r1, r2, r1
 80027c8:	40cb      	lsrs	r3, r1
 80027ca:	0019      	movs	r1, r3
 80027cc:	2820      	cmp	r0, #32
 80027ce:	d003      	beq.n	80027d8 <__aeabi_dmul+0x3e8>
 80027d0:	4a3b      	ldr	r2, [pc, #236]	; (80028c0 <__aeabi_dmul+0x4d0>)
 80027d2:	4462      	add	r2, ip
 80027d4:	4094      	lsls	r4, r2
 80027d6:	4325      	orrs	r5, r4
 80027d8:	1e6a      	subs	r2, r5, #1
 80027da:	4195      	sbcs	r5, r2
 80027dc:	002a      	movs	r2, r5
 80027de:	430a      	orrs	r2, r1
 80027e0:	2107      	movs	r1, #7
 80027e2:	000d      	movs	r5, r1
 80027e4:	2400      	movs	r4, #0
 80027e6:	4015      	ands	r5, r2
 80027e8:	4211      	tst	r1, r2
 80027ea:	d05b      	beq.n	80028a4 <__aeabi_dmul+0x4b4>
 80027ec:	210f      	movs	r1, #15
 80027ee:	2400      	movs	r4, #0
 80027f0:	4011      	ands	r1, r2
 80027f2:	2904      	cmp	r1, #4
 80027f4:	d053      	beq.n	800289e <__aeabi_dmul+0x4ae>
 80027f6:	1d11      	adds	r1, r2, #4
 80027f8:	4291      	cmp	r1, r2
 80027fa:	4192      	sbcs	r2, r2
 80027fc:	4252      	negs	r2, r2
 80027fe:	18a4      	adds	r4, r4, r2
 8002800:	000a      	movs	r2, r1
 8002802:	0223      	lsls	r3, r4, #8
 8002804:	d54b      	bpl.n	800289e <__aeabi_dmul+0x4ae>
 8002806:	2201      	movs	r2, #1
 8002808:	2400      	movs	r4, #0
 800280a:	2500      	movs	r5, #0
 800280c:	e660      	b.n	80024d0 <__aeabi_dmul+0xe0>
 800280e:	2380      	movs	r3, #128	; 0x80
 8002810:	031b      	lsls	r3, r3, #12
 8002812:	421c      	tst	r4, r3
 8002814:	d009      	beq.n	800282a <__aeabi_dmul+0x43a>
 8002816:	421e      	tst	r6, r3
 8002818:	d107      	bne.n	800282a <__aeabi_dmul+0x43a>
 800281a:	4333      	orrs	r3, r6
 800281c:	031c      	lsls	r4, r3, #12
 800281e:	4643      	mov	r3, r8
 8002820:	0015      	movs	r5, r2
 8002822:	0b24      	lsrs	r4, r4, #12
 8002824:	4a25      	ldr	r2, [pc, #148]	; (80028bc <__aeabi_dmul+0x4cc>)
 8002826:	9301      	str	r3, [sp, #4]
 8002828:	e652      	b.n	80024d0 <__aeabi_dmul+0xe0>
 800282a:	2280      	movs	r2, #128	; 0x80
 800282c:	0312      	lsls	r2, r2, #12
 800282e:	4314      	orrs	r4, r2
 8002830:	0324      	lsls	r4, r4, #12
 8002832:	4a22      	ldr	r2, [pc, #136]	; (80028bc <__aeabi_dmul+0x4cc>)
 8002834:	0b24      	lsrs	r4, r4, #12
 8002836:	9701      	str	r7, [sp, #4]
 8002838:	e64a      	b.n	80024d0 <__aeabi_dmul+0xe0>
 800283a:	f000 fcab 	bl	8003194 <__clzsi2>
 800283e:	0003      	movs	r3, r0
 8002840:	001a      	movs	r2, r3
 8002842:	3215      	adds	r2, #21
 8002844:	3020      	adds	r0, #32
 8002846:	2a1c      	cmp	r2, #28
 8002848:	dc00      	bgt.n	800284c <__aeabi_dmul+0x45c>
 800284a:	e684      	b.n	8002556 <__aeabi_dmul+0x166>
 800284c:	4656      	mov	r6, sl
 800284e:	3b08      	subs	r3, #8
 8002850:	2200      	movs	r2, #0
 8002852:	409e      	lsls	r6, r3
 8002854:	e689      	b.n	800256a <__aeabi_dmul+0x17a>
 8002856:	f000 fc9d 	bl	8003194 <__clzsi2>
 800285a:	0001      	movs	r1, r0
 800285c:	0002      	movs	r2, r0
 800285e:	3115      	adds	r1, #21
 8002860:	3220      	adds	r2, #32
 8002862:	291c      	cmp	r1, #28
 8002864:	dc00      	bgt.n	8002868 <__aeabi_dmul+0x478>
 8002866:	e64e      	b.n	8002506 <__aeabi_dmul+0x116>
 8002868:	0034      	movs	r4, r6
 800286a:	3808      	subs	r0, #8
 800286c:	2500      	movs	r5, #0
 800286e:	4084      	lsls	r4, r0
 8002870:	e653      	b.n	800251a <__aeabi_dmul+0x12a>
 8002872:	9b00      	ldr	r3, [sp, #0]
 8002874:	469c      	mov	ip, r3
 8002876:	e741      	b.n	80026fc <__aeabi_dmul+0x30c>
 8002878:	4912      	ldr	r1, [pc, #72]	; (80028c4 <__aeabi_dmul+0x4d4>)
 800287a:	0022      	movs	r2, r4
 800287c:	4461      	add	r1, ip
 800287e:	002e      	movs	r6, r5
 8002880:	408d      	lsls	r5, r1
 8002882:	408a      	lsls	r2, r1
 8002884:	40c6      	lsrs	r6, r0
 8002886:	1e69      	subs	r1, r5, #1
 8002888:	418d      	sbcs	r5, r1
 800288a:	4332      	orrs	r2, r6
 800288c:	432a      	orrs	r2, r5
 800288e:	40c4      	lsrs	r4, r0
 8002890:	0753      	lsls	r3, r2, #29
 8002892:	d0b6      	beq.n	8002802 <__aeabi_dmul+0x412>
 8002894:	210f      	movs	r1, #15
 8002896:	4011      	ands	r1, r2
 8002898:	2904      	cmp	r1, #4
 800289a:	d1ac      	bne.n	80027f6 <__aeabi_dmul+0x406>
 800289c:	e7b1      	b.n	8002802 <__aeabi_dmul+0x412>
 800289e:	0765      	lsls	r5, r4, #29
 80028a0:	0264      	lsls	r4, r4, #9
 80028a2:	0b24      	lsrs	r4, r4, #12
 80028a4:	08d2      	lsrs	r2, r2, #3
 80028a6:	4315      	orrs	r5, r2
 80028a8:	2200      	movs	r2, #0
 80028aa:	e611      	b.n	80024d0 <__aeabi_dmul+0xe0>
 80028ac:	2280      	movs	r2, #128	; 0x80
 80028ae:	0312      	lsls	r2, r2, #12
 80028b0:	4314      	orrs	r4, r2
 80028b2:	0324      	lsls	r4, r4, #12
 80028b4:	4a01      	ldr	r2, [pc, #4]	; (80028bc <__aeabi_dmul+0x4cc>)
 80028b6:	0b24      	lsrs	r4, r4, #12
 80028b8:	e60a      	b.n	80024d0 <__aeabi_dmul+0xe0>
 80028ba:	46c0      	nop			; (mov r8, r8)
 80028bc:	000007ff 	.word	0x000007ff
 80028c0:	0000043e 	.word	0x0000043e
 80028c4:	0000041e 	.word	0x0000041e

080028c8 <__aeabi_dsub>:
 80028c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80028ca:	4657      	mov	r7, sl
 80028cc:	464e      	mov	r6, r9
 80028ce:	4645      	mov	r5, r8
 80028d0:	46de      	mov	lr, fp
 80028d2:	0004      	movs	r4, r0
 80028d4:	b5e0      	push	{r5, r6, r7, lr}
 80028d6:	001f      	movs	r7, r3
 80028d8:	0010      	movs	r0, r2
 80028da:	030b      	lsls	r3, r1, #12
 80028dc:	0f62      	lsrs	r2, r4, #29
 80028de:	004e      	lsls	r6, r1, #1
 80028e0:	0fcd      	lsrs	r5, r1, #31
 80028e2:	0a5b      	lsrs	r3, r3, #9
 80028e4:	0339      	lsls	r1, r7, #12
 80028e6:	4313      	orrs	r3, r2
 80028e8:	0a49      	lsrs	r1, r1, #9
 80028ea:	00e2      	lsls	r2, r4, #3
 80028ec:	0f44      	lsrs	r4, r0, #29
 80028ee:	4321      	orrs	r1, r4
 80028f0:	4cc2      	ldr	r4, [pc, #776]	; (8002bfc <__aeabi_dsub+0x334>)
 80028f2:	4691      	mov	r9, r2
 80028f4:	4692      	mov	sl, r2
 80028f6:	00c0      	lsls	r0, r0, #3
 80028f8:	007a      	lsls	r2, r7, #1
 80028fa:	4680      	mov	r8, r0
 80028fc:	0d76      	lsrs	r6, r6, #21
 80028fe:	0d52      	lsrs	r2, r2, #21
 8002900:	0fff      	lsrs	r7, r7, #31
 8002902:	42a2      	cmp	r2, r4
 8002904:	d100      	bne.n	8002908 <__aeabi_dsub+0x40>
 8002906:	e0b4      	b.n	8002a72 <__aeabi_dsub+0x1aa>
 8002908:	2401      	movs	r4, #1
 800290a:	4067      	eors	r7, r4
 800290c:	46bb      	mov	fp, r7
 800290e:	42bd      	cmp	r5, r7
 8002910:	d100      	bne.n	8002914 <__aeabi_dsub+0x4c>
 8002912:	e088      	b.n	8002a26 <__aeabi_dsub+0x15e>
 8002914:	1ab4      	subs	r4, r6, r2
 8002916:	46a4      	mov	ip, r4
 8002918:	2c00      	cmp	r4, #0
 800291a:	dc00      	bgt.n	800291e <__aeabi_dsub+0x56>
 800291c:	e0b2      	b.n	8002a84 <__aeabi_dsub+0x1bc>
 800291e:	2a00      	cmp	r2, #0
 8002920:	d100      	bne.n	8002924 <__aeabi_dsub+0x5c>
 8002922:	e0c5      	b.n	8002ab0 <__aeabi_dsub+0x1e8>
 8002924:	4ab5      	ldr	r2, [pc, #724]	; (8002bfc <__aeabi_dsub+0x334>)
 8002926:	4296      	cmp	r6, r2
 8002928:	d100      	bne.n	800292c <__aeabi_dsub+0x64>
 800292a:	e28b      	b.n	8002e44 <__aeabi_dsub+0x57c>
 800292c:	2280      	movs	r2, #128	; 0x80
 800292e:	0412      	lsls	r2, r2, #16
 8002930:	4311      	orrs	r1, r2
 8002932:	4662      	mov	r2, ip
 8002934:	2a38      	cmp	r2, #56	; 0x38
 8002936:	dd00      	ble.n	800293a <__aeabi_dsub+0x72>
 8002938:	e1a1      	b.n	8002c7e <__aeabi_dsub+0x3b6>
 800293a:	2a1f      	cmp	r2, #31
 800293c:	dd00      	ble.n	8002940 <__aeabi_dsub+0x78>
 800293e:	e216      	b.n	8002d6e <__aeabi_dsub+0x4a6>
 8002940:	2720      	movs	r7, #32
 8002942:	000c      	movs	r4, r1
 8002944:	1abf      	subs	r7, r7, r2
 8002946:	40bc      	lsls	r4, r7
 8002948:	0002      	movs	r2, r0
 800294a:	46a0      	mov	r8, r4
 800294c:	4664      	mov	r4, ip
 800294e:	40b8      	lsls	r0, r7
 8002950:	40e2      	lsrs	r2, r4
 8002952:	4644      	mov	r4, r8
 8002954:	4314      	orrs	r4, r2
 8002956:	0002      	movs	r2, r0
 8002958:	1e50      	subs	r0, r2, #1
 800295a:	4182      	sbcs	r2, r0
 800295c:	4660      	mov	r0, ip
 800295e:	40c1      	lsrs	r1, r0
 8002960:	4322      	orrs	r2, r4
 8002962:	1a5b      	subs	r3, r3, r1
 8002964:	4649      	mov	r1, r9
 8002966:	1a8c      	subs	r4, r1, r2
 8002968:	45a1      	cmp	r9, r4
 800296a:	4192      	sbcs	r2, r2
 800296c:	4252      	negs	r2, r2
 800296e:	1a9b      	subs	r3, r3, r2
 8002970:	4698      	mov	r8, r3
 8002972:	4643      	mov	r3, r8
 8002974:	021b      	lsls	r3, r3, #8
 8002976:	d400      	bmi.n	800297a <__aeabi_dsub+0xb2>
 8002978:	e117      	b.n	8002baa <__aeabi_dsub+0x2e2>
 800297a:	4643      	mov	r3, r8
 800297c:	025b      	lsls	r3, r3, #9
 800297e:	0a5b      	lsrs	r3, r3, #9
 8002980:	4698      	mov	r8, r3
 8002982:	4643      	mov	r3, r8
 8002984:	2b00      	cmp	r3, #0
 8002986:	d100      	bne.n	800298a <__aeabi_dsub+0xc2>
 8002988:	e16c      	b.n	8002c64 <__aeabi_dsub+0x39c>
 800298a:	4640      	mov	r0, r8
 800298c:	f000 fc02 	bl	8003194 <__clzsi2>
 8002990:	0002      	movs	r2, r0
 8002992:	3a08      	subs	r2, #8
 8002994:	2120      	movs	r1, #32
 8002996:	0020      	movs	r0, r4
 8002998:	4643      	mov	r3, r8
 800299a:	1a89      	subs	r1, r1, r2
 800299c:	4093      	lsls	r3, r2
 800299e:	40c8      	lsrs	r0, r1
 80029a0:	4094      	lsls	r4, r2
 80029a2:	4303      	orrs	r3, r0
 80029a4:	4296      	cmp	r6, r2
 80029a6:	dd00      	ble.n	80029aa <__aeabi_dsub+0xe2>
 80029a8:	e157      	b.n	8002c5a <__aeabi_dsub+0x392>
 80029aa:	1b96      	subs	r6, r2, r6
 80029ac:	1c71      	adds	r1, r6, #1
 80029ae:	291f      	cmp	r1, #31
 80029b0:	dd00      	ble.n	80029b4 <__aeabi_dsub+0xec>
 80029b2:	e1cb      	b.n	8002d4c <__aeabi_dsub+0x484>
 80029b4:	2220      	movs	r2, #32
 80029b6:	0018      	movs	r0, r3
 80029b8:	0026      	movs	r6, r4
 80029ba:	1a52      	subs	r2, r2, r1
 80029bc:	4094      	lsls	r4, r2
 80029be:	4090      	lsls	r0, r2
 80029c0:	40ce      	lsrs	r6, r1
 80029c2:	40cb      	lsrs	r3, r1
 80029c4:	1e62      	subs	r2, r4, #1
 80029c6:	4194      	sbcs	r4, r2
 80029c8:	4330      	orrs	r0, r6
 80029ca:	4698      	mov	r8, r3
 80029cc:	2600      	movs	r6, #0
 80029ce:	4304      	orrs	r4, r0
 80029d0:	0763      	lsls	r3, r4, #29
 80029d2:	d009      	beq.n	80029e8 <__aeabi_dsub+0x120>
 80029d4:	230f      	movs	r3, #15
 80029d6:	4023      	ands	r3, r4
 80029d8:	2b04      	cmp	r3, #4
 80029da:	d005      	beq.n	80029e8 <__aeabi_dsub+0x120>
 80029dc:	1d23      	adds	r3, r4, #4
 80029de:	42a3      	cmp	r3, r4
 80029e0:	41a4      	sbcs	r4, r4
 80029e2:	4264      	negs	r4, r4
 80029e4:	44a0      	add	r8, r4
 80029e6:	001c      	movs	r4, r3
 80029e8:	4643      	mov	r3, r8
 80029ea:	021b      	lsls	r3, r3, #8
 80029ec:	d400      	bmi.n	80029f0 <__aeabi_dsub+0x128>
 80029ee:	e0df      	b.n	8002bb0 <__aeabi_dsub+0x2e8>
 80029f0:	4b82      	ldr	r3, [pc, #520]	; (8002bfc <__aeabi_dsub+0x334>)
 80029f2:	3601      	adds	r6, #1
 80029f4:	429e      	cmp	r6, r3
 80029f6:	d100      	bne.n	80029fa <__aeabi_dsub+0x132>
 80029f8:	e0fb      	b.n	8002bf2 <__aeabi_dsub+0x32a>
 80029fa:	4642      	mov	r2, r8
 80029fc:	4b80      	ldr	r3, [pc, #512]	; (8002c00 <__aeabi_dsub+0x338>)
 80029fe:	08e4      	lsrs	r4, r4, #3
 8002a00:	401a      	ands	r2, r3
 8002a02:	0013      	movs	r3, r2
 8002a04:	0571      	lsls	r1, r6, #21
 8002a06:	0752      	lsls	r2, r2, #29
 8002a08:	025b      	lsls	r3, r3, #9
 8002a0a:	4322      	orrs	r2, r4
 8002a0c:	0b1b      	lsrs	r3, r3, #12
 8002a0e:	0d49      	lsrs	r1, r1, #21
 8002a10:	0509      	lsls	r1, r1, #20
 8002a12:	07ed      	lsls	r5, r5, #31
 8002a14:	4319      	orrs	r1, r3
 8002a16:	4329      	orrs	r1, r5
 8002a18:	0010      	movs	r0, r2
 8002a1a:	bcf0      	pop	{r4, r5, r6, r7}
 8002a1c:	46bb      	mov	fp, r7
 8002a1e:	46b2      	mov	sl, r6
 8002a20:	46a9      	mov	r9, r5
 8002a22:	46a0      	mov	r8, r4
 8002a24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002a26:	1ab4      	subs	r4, r6, r2
 8002a28:	46a4      	mov	ip, r4
 8002a2a:	2c00      	cmp	r4, #0
 8002a2c:	dd58      	ble.n	8002ae0 <__aeabi_dsub+0x218>
 8002a2e:	2a00      	cmp	r2, #0
 8002a30:	d100      	bne.n	8002a34 <__aeabi_dsub+0x16c>
 8002a32:	e09e      	b.n	8002b72 <__aeabi_dsub+0x2aa>
 8002a34:	4a71      	ldr	r2, [pc, #452]	; (8002bfc <__aeabi_dsub+0x334>)
 8002a36:	4296      	cmp	r6, r2
 8002a38:	d100      	bne.n	8002a3c <__aeabi_dsub+0x174>
 8002a3a:	e13b      	b.n	8002cb4 <__aeabi_dsub+0x3ec>
 8002a3c:	2280      	movs	r2, #128	; 0x80
 8002a3e:	0412      	lsls	r2, r2, #16
 8002a40:	4311      	orrs	r1, r2
 8002a42:	4662      	mov	r2, ip
 8002a44:	2a38      	cmp	r2, #56	; 0x38
 8002a46:	dd00      	ble.n	8002a4a <__aeabi_dsub+0x182>
 8002a48:	e0c1      	b.n	8002bce <__aeabi_dsub+0x306>
 8002a4a:	2a1f      	cmp	r2, #31
 8002a4c:	dc00      	bgt.n	8002a50 <__aeabi_dsub+0x188>
 8002a4e:	e1bb      	b.n	8002dc8 <__aeabi_dsub+0x500>
 8002a50:	000c      	movs	r4, r1
 8002a52:	3a20      	subs	r2, #32
 8002a54:	40d4      	lsrs	r4, r2
 8002a56:	0022      	movs	r2, r4
 8002a58:	4664      	mov	r4, ip
 8002a5a:	2c20      	cmp	r4, #32
 8002a5c:	d004      	beq.n	8002a68 <__aeabi_dsub+0x1a0>
 8002a5e:	2740      	movs	r7, #64	; 0x40
 8002a60:	1b3f      	subs	r7, r7, r4
 8002a62:	40b9      	lsls	r1, r7
 8002a64:	4308      	orrs	r0, r1
 8002a66:	4680      	mov	r8, r0
 8002a68:	4644      	mov	r4, r8
 8002a6a:	1e61      	subs	r1, r4, #1
 8002a6c:	418c      	sbcs	r4, r1
 8002a6e:	4314      	orrs	r4, r2
 8002a70:	e0b1      	b.n	8002bd6 <__aeabi_dsub+0x30e>
 8002a72:	000c      	movs	r4, r1
 8002a74:	4304      	orrs	r4, r0
 8002a76:	d02a      	beq.n	8002ace <__aeabi_dsub+0x206>
 8002a78:	46bb      	mov	fp, r7
 8002a7a:	42bd      	cmp	r5, r7
 8002a7c:	d02d      	beq.n	8002ada <__aeabi_dsub+0x212>
 8002a7e:	4c61      	ldr	r4, [pc, #388]	; (8002c04 <__aeabi_dsub+0x33c>)
 8002a80:	46a4      	mov	ip, r4
 8002a82:	44b4      	add	ip, r6
 8002a84:	4664      	mov	r4, ip
 8002a86:	2c00      	cmp	r4, #0
 8002a88:	d05c      	beq.n	8002b44 <__aeabi_dsub+0x27c>
 8002a8a:	1b94      	subs	r4, r2, r6
 8002a8c:	46a4      	mov	ip, r4
 8002a8e:	2e00      	cmp	r6, #0
 8002a90:	d000      	beq.n	8002a94 <__aeabi_dsub+0x1cc>
 8002a92:	e115      	b.n	8002cc0 <__aeabi_dsub+0x3f8>
 8002a94:	464d      	mov	r5, r9
 8002a96:	431d      	orrs	r5, r3
 8002a98:	d100      	bne.n	8002a9c <__aeabi_dsub+0x1d4>
 8002a9a:	e1c3      	b.n	8002e24 <__aeabi_dsub+0x55c>
 8002a9c:	1e65      	subs	r5, r4, #1
 8002a9e:	2c01      	cmp	r4, #1
 8002aa0:	d100      	bne.n	8002aa4 <__aeabi_dsub+0x1dc>
 8002aa2:	e20c      	b.n	8002ebe <__aeabi_dsub+0x5f6>
 8002aa4:	4e55      	ldr	r6, [pc, #340]	; (8002bfc <__aeabi_dsub+0x334>)
 8002aa6:	42b4      	cmp	r4, r6
 8002aa8:	d100      	bne.n	8002aac <__aeabi_dsub+0x1e4>
 8002aaa:	e1f8      	b.n	8002e9e <__aeabi_dsub+0x5d6>
 8002aac:	46ac      	mov	ip, r5
 8002aae:	e10e      	b.n	8002cce <__aeabi_dsub+0x406>
 8002ab0:	000a      	movs	r2, r1
 8002ab2:	4302      	orrs	r2, r0
 8002ab4:	d100      	bne.n	8002ab8 <__aeabi_dsub+0x1f0>
 8002ab6:	e136      	b.n	8002d26 <__aeabi_dsub+0x45e>
 8002ab8:	0022      	movs	r2, r4
 8002aba:	3a01      	subs	r2, #1
 8002abc:	2c01      	cmp	r4, #1
 8002abe:	d100      	bne.n	8002ac2 <__aeabi_dsub+0x1fa>
 8002ac0:	e1c6      	b.n	8002e50 <__aeabi_dsub+0x588>
 8002ac2:	4c4e      	ldr	r4, [pc, #312]	; (8002bfc <__aeabi_dsub+0x334>)
 8002ac4:	45a4      	cmp	ip, r4
 8002ac6:	d100      	bne.n	8002aca <__aeabi_dsub+0x202>
 8002ac8:	e0f4      	b.n	8002cb4 <__aeabi_dsub+0x3ec>
 8002aca:	4694      	mov	ip, r2
 8002acc:	e731      	b.n	8002932 <__aeabi_dsub+0x6a>
 8002ace:	2401      	movs	r4, #1
 8002ad0:	4067      	eors	r7, r4
 8002ad2:	46bb      	mov	fp, r7
 8002ad4:	42bd      	cmp	r5, r7
 8002ad6:	d000      	beq.n	8002ada <__aeabi_dsub+0x212>
 8002ad8:	e71c      	b.n	8002914 <__aeabi_dsub+0x4c>
 8002ada:	4c4a      	ldr	r4, [pc, #296]	; (8002c04 <__aeabi_dsub+0x33c>)
 8002adc:	46a4      	mov	ip, r4
 8002ade:	44b4      	add	ip, r6
 8002ae0:	4664      	mov	r4, ip
 8002ae2:	2c00      	cmp	r4, #0
 8002ae4:	d100      	bne.n	8002ae8 <__aeabi_dsub+0x220>
 8002ae6:	e0cf      	b.n	8002c88 <__aeabi_dsub+0x3c0>
 8002ae8:	1b94      	subs	r4, r2, r6
 8002aea:	46a4      	mov	ip, r4
 8002aec:	2e00      	cmp	r6, #0
 8002aee:	d100      	bne.n	8002af2 <__aeabi_dsub+0x22a>
 8002af0:	e15c      	b.n	8002dac <__aeabi_dsub+0x4e4>
 8002af2:	4e42      	ldr	r6, [pc, #264]	; (8002bfc <__aeabi_dsub+0x334>)
 8002af4:	42b2      	cmp	r2, r6
 8002af6:	d100      	bne.n	8002afa <__aeabi_dsub+0x232>
 8002af8:	e1ec      	b.n	8002ed4 <__aeabi_dsub+0x60c>
 8002afa:	2680      	movs	r6, #128	; 0x80
 8002afc:	0436      	lsls	r6, r6, #16
 8002afe:	4333      	orrs	r3, r6
 8002b00:	4664      	mov	r4, ip
 8002b02:	2c38      	cmp	r4, #56	; 0x38
 8002b04:	dd00      	ble.n	8002b08 <__aeabi_dsub+0x240>
 8002b06:	e1b3      	b.n	8002e70 <__aeabi_dsub+0x5a8>
 8002b08:	2c1f      	cmp	r4, #31
 8002b0a:	dd00      	ble.n	8002b0e <__aeabi_dsub+0x246>
 8002b0c:	e238      	b.n	8002f80 <__aeabi_dsub+0x6b8>
 8002b0e:	2620      	movs	r6, #32
 8002b10:	1b36      	subs	r6, r6, r4
 8002b12:	001c      	movs	r4, r3
 8002b14:	40b4      	lsls	r4, r6
 8002b16:	464f      	mov	r7, r9
 8002b18:	46a0      	mov	r8, r4
 8002b1a:	4664      	mov	r4, ip
 8002b1c:	40e7      	lsrs	r7, r4
 8002b1e:	4644      	mov	r4, r8
 8002b20:	433c      	orrs	r4, r7
 8002b22:	464f      	mov	r7, r9
 8002b24:	40b7      	lsls	r7, r6
 8002b26:	003e      	movs	r6, r7
 8002b28:	1e77      	subs	r7, r6, #1
 8002b2a:	41be      	sbcs	r6, r7
 8002b2c:	4334      	orrs	r4, r6
 8002b2e:	4666      	mov	r6, ip
 8002b30:	40f3      	lsrs	r3, r6
 8002b32:	18c9      	adds	r1, r1, r3
 8002b34:	1824      	adds	r4, r4, r0
 8002b36:	4284      	cmp	r4, r0
 8002b38:	419b      	sbcs	r3, r3
 8002b3a:	425b      	negs	r3, r3
 8002b3c:	4698      	mov	r8, r3
 8002b3e:	0016      	movs	r6, r2
 8002b40:	4488      	add	r8, r1
 8002b42:	e04e      	b.n	8002be2 <__aeabi_dsub+0x31a>
 8002b44:	4a30      	ldr	r2, [pc, #192]	; (8002c08 <__aeabi_dsub+0x340>)
 8002b46:	1c74      	adds	r4, r6, #1
 8002b48:	4214      	tst	r4, r2
 8002b4a:	d000      	beq.n	8002b4e <__aeabi_dsub+0x286>
 8002b4c:	e0d6      	b.n	8002cfc <__aeabi_dsub+0x434>
 8002b4e:	464a      	mov	r2, r9
 8002b50:	431a      	orrs	r2, r3
 8002b52:	2e00      	cmp	r6, #0
 8002b54:	d000      	beq.n	8002b58 <__aeabi_dsub+0x290>
 8002b56:	e15b      	b.n	8002e10 <__aeabi_dsub+0x548>
 8002b58:	2a00      	cmp	r2, #0
 8002b5a:	d100      	bne.n	8002b5e <__aeabi_dsub+0x296>
 8002b5c:	e1a5      	b.n	8002eaa <__aeabi_dsub+0x5e2>
 8002b5e:	000a      	movs	r2, r1
 8002b60:	4302      	orrs	r2, r0
 8002b62:	d000      	beq.n	8002b66 <__aeabi_dsub+0x29e>
 8002b64:	e1bb      	b.n	8002ede <__aeabi_dsub+0x616>
 8002b66:	464a      	mov	r2, r9
 8002b68:	0759      	lsls	r1, r3, #29
 8002b6a:	08d2      	lsrs	r2, r2, #3
 8002b6c:	430a      	orrs	r2, r1
 8002b6e:	08db      	lsrs	r3, r3, #3
 8002b70:	e027      	b.n	8002bc2 <__aeabi_dsub+0x2fa>
 8002b72:	000a      	movs	r2, r1
 8002b74:	4302      	orrs	r2, r0
 8002b76:	d100      	bne.n	8002b7a <__aeabi_dsub+0x2b2>
 8002b78:	e174      	b.n	8002e64 <__aeabi_dsub+0x59c>
 8002b7a:	0022      	movs	r2, r4
 8002b7c:	3a01      	subs	r2, #1
 8002b7e:	2c01      	cmp	r4, #1
 8002b80:	d005      	beq.n	8002b8e <__aeabi_dsub+0x2c6>
 8002b82:	4c1e      	ldr	r4, [pc, #120]	; (8002bfc <__aeabi_dsub+0x334>)
 8002b84:	45a4      	cmp	ip, r4
 8002b86:	d100      	bne.n	8002b8a <__aeabi_dsub+0x2c2>
 8002b88:	e094      	b.n	8002cb4 <__aeabi_dsub+0x3ec>
 8002b8a:	4694      	mov	ip, r2
 8002b8c:	e759      	b.n	8002a42 <__aeabi_dsub+0x17a>
 8002b8e:	4448      	add	r0, r9
 8002b90:	4548      	cmp	r0, r9
 8002b92:	4192      	sbcs	r2, r2
 8002b94:	185b      	adds	r3, r3, r1
 8002b96:	4698      	mov	r8, r3
 8002b98:	0004      	movs	r4, r0
 8002b9a:	4252      	negs	r2, r2
 8002b9c:	4490      	add	r8, r2
 8002b9e:	4643      	mov	r3, r8
 8002ba0:	2602      	movs	r6, #2
 8002ba2:	021b      	lsls	r3, r3, #8
 8002ba4:	d500      	bpl.n	8002ba8 <__aeabi_dsub+0x2e0>
 8002ba6:	e0c4      	b.n	8002d32 <__aeabi_dsub+0x46a>
 8002ba8:	3e01      	subs	r6, #1
 8002baa:	0763      	lsls	r3, r4, #29
 8002bac:	d000      	beq.n	8002bb0 <__aeabi_dsub+0x2e8>
 8002bae:	e711      	b.n	80029d4 <__aeabi_dsub+0x10c>
 8002bb0:	4643      	mov	r3, r8
 8002bb2:	46b4      	mov	ip, r6
 8002bb4:	0759      	lsls	r1, r3, #29
 8002bb6:	08e2      	lsrs	r2, r4, #3
 8002bb8:	430a      	orrs	r2, r1
 8002bba:	08db      	lsrs	r3, r3, #3
 8002bbc:	490f      	ldr	r1, [pc, #60]	; (8002bfc <__aeabi_dsub+0x334>)
 8002bbe:	458c      	cmp	ip, r1
 8002bc0:	d040      	beq.n	8002c44 <__aeabi_dsub+0x37c>
 8002bc2:	4661      	mov	r1, ip
 8002bc4:	031b      	lsls	r3, r3, #12
 8002bc6:	0549      	lsls	r1, r1, #21
 8002bc8:	0b1b      	lsrs	r3, r3, #12
 8002bca:	0d49      	lsrs	r1, r1, #21
 8002bcc:	e720      	b.n	8002a10 <__aeabi_dsub+0x148>
 8002bce:	4301      	orrs	r1, r0
 8002bd0:	000c      	movs	r4, r1
 8002bd2:	1e61      	subs	r1, r4, #1
 8002bd4:	418c      	sbcs	r4, r1
 8002bd6:	444c      	add	r4, r9
 8002bd8:	454c      	cmp	r4, r9
 8002bda:	4192      	sbcs	r2, r2
 8002bdc:	4252      	negs	r2, r2
 8002bde:	4690      	mov	r8, r2
 8002be0:	4498      	add	r8, r3
 8002be2:	4643      	mov	r3, r8
 8002be4:	021b      	lsls	r3, r3, #8
 8002be6:	d5e0      	bpl.n	8002baa <__aeabi_dsub+0x2e2>
 8002be8:	4b04      	ldr	r3, [pc, #16]	; (8002bfc <__aeabi_dsub+0x334>)
 8002bea:	3601      	adds	r6, #1
 8002bec:	429e      	cmp	r6, r3
 8002bee:	d000      	beq.n	8002bf2 <__aeabi_dsub+0x32a>
 8002bf0:	e09f      	b.n	8002d32 <__aeabi_dsub+0x46a>
 8002bf2:	0031      	movs	r1, r6
 8002bf4:	2300      	movs	r3, #0
 8002bf6:	2200      	movs	r2, #0
 8002bf8:	e70a      	b.n	8002a10 <__aeabi_dsub+0x148>
 8002bfa:	46c0      	nop			; (mov r8, r8)
 8002bfc:	000007ff 	.word	0x000007ff
 8002c00:	ff7fffff 	.word	0xff7fffff
 8002c04:	fffff801 	.word	0xfffff801
 8002c08:	000007fe 	.word	0x000007fe
 8002c0c:	2a00      	cmp	r2, #0
 8002c0e:	d100      	bne.n	8002c12 <__aeabi_dsub+0x34a>
 8002c10:	e160      	b.n	8002ed4 <__aeabi_dsub+0x60c>
 8002c12:	000a      	movs	r2, r1
 8002c14:	4302      	orrs	r2, r0
 8002c16:	d04d      	beq.n	8002cb4 <__aeabi_dsub+0x3ec>
 8002c18:	464a      	mov	r2, r9
 8002c1a:	075c      	lsls	r4, r3, #29
 8002c1c:	08d2      	lsrs	r2, r2, #3
 8002c1e:	4322      	orrs	r2, r4
 8002c20:	2480      	movs	r4, #128	; 0x80
 8002c22:	08db      	lsrs	r3, r3, #3
 8002c24:	0324      	lsls	r4, r4, #12
 8002c26:	4223      	tst	r3, r4
 8002c28:	d007      	beq.n	8002c3a <__aeabi_dsub+0x372>
 8002c2a:	08ce      	lsrs	r6, r1, #3
 8002c2c:	4226      	tst	r6, r4
 8002c2e:	d104      	bne.n	8002c3a <__aeabi_dsub+0x372>
 8002c30:	465d      	mov	r5, fp
 8002c32:	0033      	movs	r3, r6
 8002c34:	08c2      	lsrs	r2, r0, #3
 8002c36:	0749      	lsls	r1, r1, #29
 8002c38:	430a      	orrs	r2, r1
 8002c3a:	0f51      	lsrs	r1, r2, #29
 8002c3c:	00d2      	lsls	r2, r2, #3
 8002c3e:	08d2      	lsrs	r2, r2, #3
 8002c40:	0749      	lsls	r1, r1, #29
 8002c42:	430a      	orrs	r2, r1
 8002c44:	0011      	movs	r1, r2
 8002c46:	4319      	orrs	r1, r3
 8002c48:	d100      	bne.n	8002c4c <__aeabi_dsub+0x384>
 8002c4a:	e1c8      	b.n	8002fde <__aeabi_dsub+0x716>
 8002c4c:	2180      	movs	r1, #128	; 0x80
 8002c4e:	0309      	lsls	r1, r1, #12
 8002c50:	430b      	orrs	r3, r1
 8002c52:	031b      	lsls	r3, r3, #12
 8002c54:	49d5      	ldr	r1, [pc, #852]	; (8002fac <__aeabi_dsub+0x6e4>)
 8002c56:	0b1b      	lsrs	r3, r3, #12
 8002c58:	e6da      	b.n	8002a10 <__aeabi_dsub+0x148>
 8002c5a:	49d5      	ldr	r1, [pc, #852]	; (8002fb0 <__aeabi_dsub+0x6e8>)
 8002c5c:	1ab6      	subs	r6, r6, r2
 8002c5e:	400b      	ands	r3, r1
 8002c60:	4698      	mov	r8, r3
 8002c62:	e6b5      	b.n	80029d0 <__aeabi_dsub+0x108>
 8002c64:	0020      	movs	r0, r4
 8002c66:	f000 fa95 	bl	8003194 <__clzsi2>
 8002c6a:	0002      	movs	r2, r0
 8002c6c:	3218      	adds	r2, #24
 8002c6e:	2a1f      	cmp	r2, #31
 8002c70:	dc00      	bgt.n	8002c74 <__aeabi_dsub+0x3ac>
 8002c72:	e68f      	b.n	8002994 <__aeabi_dsub+0xcc>
 8002c74:	0023      	movs	r3, r4
 8002c76:	3808      	subs	r0, #8
 8002c78:	4083      	lsls	r3, r0
 8002c7a:	2400      	movs	r4, #0
 8002c7c:	e692      	b.n	80029a4 <__aeabi_dsub+0xdc>
 8002c7e:	4308      	orrs	r0, r1
 8002c80:	0002      	movs	r2, r0
 8002c82:	1e50      	subs	r0, r2, #1
 8002c84:	4182      	sbcs	r2, r0
 8002c86:	e66d      	b.n	8002964 <__aeabi_dsub+0x9c>
 8002c88:	4cca      	ldr	r4, [pc, #808]	; (8002fb4 <__aeabi_dsub+0x6ec>)
 8002c8a:	1c72      	adds	r2, r6, #1
 8002c8c:	4222      	tst	r2, r4
 8002c8e:	d000      	beq.n	8002c92 <__aeabi_dsub+0x3ca>
 8002c90:	e0ad      	b.n	8002dee <__aeabi_dsub+0x526>
 8002c92:	464a      	mov	r2, r9
 8002c94:	431a      	orrs	r2, r3
 8002c96:	2e00      	cmp	r6, #0
 8002c98:	d1b8      	bne.n	8002c0c <__aeabi_dsub+0x344>
 8002c9a:	2a00      	cmp	r2, #0
 8002c9c:	d100      	bne.n	8002ca0 <__aeabi_dsub+0x3d8>
 8002c9e:	e158      	b.n	8002f52 <__aeabi_dsub+0x68a>
 8002ca0:	000a      	movs	r2, r1
 8002ca2:	4302      	orrs	r2, r0
 8002ca4:	d000      	beq.n	8002ca8 <__aeabi_dsub+0x3e0>
 8002ca6:	e159      	b.n	8002f5c <__aeabi_dsub+0x694>
 8002ca8:	464a      	mov	r2, r9
 8002caa:	0759      	lsls	r1, r3, #29
 8002cac:	08d2      	lsrs	r2, r2, #3
 8002cae:	430a      	orrs	r2, r1
 8002cb0:	08db      	lsrs	r3, r3, #3
 8002cb2:	e786      	b.n	8002bc2 <__aeabi_dsub+0x2fa>
 8002cb4:	464a      	mov	r2, r9
 8002cb6:	0759      	lsls	r1, r3, #29
 8002cb8:	08d2      	lsrs	r2, r2, #3
 8002cba:	430a      	orrs	r2, r1
 8002cbc:	08db      	lsrs	r3, r3, #3
 8002cbe:	e7c1      	b.n	8002c44 <__aeabi_dsub+0x37c>
 8002cc0:	4dba      	ldr	r5, [pc, #744]	; (8002fac <__aeabi_dsub+0x6e4>)
 8002cc2:	42aa      	cmp	r2, r5
 8002cc4:	d100      	bne.n	8002cc8 <__aeabi_dsub+0x400>
 8002cc6:	e11e      	b.n	8002f06 <__aeabi_dsub+0x63e>
 8002cc8:	2580      	movs	r5, #128	; 0x80
 8002cca:	042d      	lsls	r5, r5, #16
 8002ccc:	432b      	orrs	r3, r5
 8002cce:	4664      	mov	r4, ip
 8002cd0:	2c38      	cmp	r4, #56	; 0x38
 8002cd2:	dc5d      	bgt.n	8002d90 <__aeabi_dsub+0x4c8>
 8002cd4:	2c1f      	cmp	r4, #31
 8002cd6:	dd00      	ble.n	8002cda <__aeabi_dsub+0x412>
 8002cd8:	e0d0      	b.n	8002e7c <__aeabi_dsub+0x5b4>
 8002cda:	2520      	movs	r5, #32
 8002cdc:	4667      	mov	r7, ip
 8002cde:	1b2d      	subs	r5, r5, r4
 8002ce0:	464e      	mov	r6, r9
 8002ce2:	001c      	movs	r4, r3
 8002ce4:	40fe      	lsrs	r6, r7
 8002ce6:	40ac      	lsls	r4, r5
 8002ce8:	4334      	orrs	r4, r6
 8002cea:	464e      	mov	r6, r9
 8002cec:	40ae      	lsls	r6, r5
 8002cee:	0035      	movs	r5, r6
 8002cf0:	40fb      	lsrs	r3, r7
 8002cf2:	1e6e      	subs	r6, r5, #1
 8002cf4:	41b5      	sbcs	r5, r6
 8002cf6:	1ac9      	subs	r1, r1, r3
 8002cf8:	432c      	orrs	r4, r5
 8002cfa:	e04e      	b.n	8002d9a <__aeabi_dsub+0x4d2>
 8002cfc:	464a      	mov	r2, r9
 8002cfe:	1a14      	subs	r4, r2, r0
 8002d00:	45a1      	cmp	r9, r4
 8002d02:	4192      	sbcs	r2, r2
 8002d04:	4252      	negs	r2, r2
 8002d06:	4690      	mov	r8, r2
 8002d08:	1a5f      	subs	r7, r3, r1
 8002d0a:	003a      	movs	r2, r7
 8002d0c:	4647      	mov	r7, r8
 8002d0e:	1bd2      	subs	r2, r2, r7
 8002d10:	4690      	mov	r8, r2
 8002d12:	0212      	lsls	r2, r2, #8
 8002d14:	d500      	bpl.n	8002d18 <__aeabi_dsub+0x450>
 8002d16:	e08b      	b.n	8002e30 <__aeabi_dsub+0x568>
 8002d18:	4642      	mov	r2, r8
 8002d1a:	4322      	orrs	r2, r4
 8002d1c:	d000      	beq.n	8002d20 <__aeabi_dsub+0x458>
 8002d1e:	e630      	b.n	8002982 <__aeabi_dsub+0xba>
 8002d20:	2300      	movs	r3, #0
 8002d22:	2500      	movs	r5, #0
 8002d24:	e74d      	b.n	8002bc2 <__aeabi_dsub+0x2fa>
 8002d26:	464a      	mov	r2, r9
 8002d28:	0759      	lsls	r1, r3, #29
 8002d2a:	08d2      	lsrs	r2, r2, #3
 8002d2c:	430a      	orrs	r2, r1
 8002d2e:	08db      	lsrs	r3, r3, #3
 8002d30:	e744      	b.n	8002bbc <__aeabi_dsub+0x2f4>
 8002d32:	4642      	mov	r2, r8
 8002d34:	4b9e      	ldr	r3, [pc, #632]	; (8002fb0 <__aeabi_dsub+0x6e8>)
 8002d36:	0861      	lsrs	r1, r4, #1
 8002d38:	401a      	ands	r2, r3
 8002d3a:	0013      	movs	r3, r2
 8002d3c:	2201      	movs	r2, #1
 8002d3e:	4014      	ands	r4, r2
 8002d40:	430c      	orrs	r4, r1
 8002d42:	07da      	lsls	r2, r3, #31
 8002d44:	085b      	lsrs	r3, r3, #1
 8002d46:	4698      	mov	r8, r3
 8002d48:	4314      	orrs	r4, r2
 8002d4a:	e641      	b.n	80029d0 <__aeabi_dsub+0x108>
 8002d4c:	001a      	movs	r2, r3
 8002d4e:	3e1f      	subs	r6, #31
 8002d50:	40f2      	lsrs	r2, r6
 8002d52:	0016      	movs	r6, r2
 8002d54:	2920      	cmp	r1, #32
 8002d56:	d003      	beq.n	8002d60 <__aeabi_dsub+0x498>
 8002d58:	2240      	movs	r2, #64	; 0x40
 8002d5a:	1a51      	subs	r1, r2, r1
 8002d5c:	408b      	lsls	r3, r1
 8002d5e:	431c      	orrs	r4, r3
 8002d60:	1e62      	subs	r2, r4, #1
 8002d62:	4194      	sbcs	r4, r2
 8002d64:	2300      	movs	r3, #0
 8002d66:	4334      	orrs	r4, r6
 8002d68:	4698      	mov	r8, r3
 8002d6a:	2600      	movs	r6, #0
 8002d6c:	e71d      	b.n	8002baa <__aeabi_dsub+0x2e2>
 8002d6e:	000c      	movs	r4, r1
 8002d70:	3a20      	subs	r2, #32
 8002d72:	40d4      	lsrs	r4, r2
 8002d74:	0022      	movs	r2, r4
 8002d76:	4664      	mov	r4, ip
 8002d78:	2c20      	cmp	r4, #32
 8002d7a:	d004      	beq.n	8002d86 <__aeabi_dsub+0x4be>
 8002d7c:	2740      	movs	r7, #64	; 0x40
 8002d7e:	1b3f      	subs	r7, r7, r4
 8002d80:	40b9      	lsls	r1, r7
 8002d82:	4308      	orrs	r0, r1
 8002d84:	4680      	mov	r8, r0
 8002d86:	4644      	mov	r4, r8
 8002d88:	1e61      	subs	r1, r4, #1
 8002d8a:	418c      	sbcs	r4, r1
 8002d8c:	4322      	orrs	r2, r4
 8002d8e:	e5e9      	b.n	8002964 <__aeabi_dsub+0x9c>
 8002d90:	464c      	mov	r4, r9
 8002d92:	4323      	orrs	r3, r4
 8002d94:	001c      	movs	r4, r3
 8002d96:	1e63      	subs	r3, r4, #1
 8002d98:	419c      	sbcs	r4, r3
 8002d9a:	1b04      	subs	r4, r0, r4
 8002d9c:	42a0      	cmp	r0, r4
 8002d9e:	419b      	sbcs	r3, r3
 8002da0:	425b      	negs	r3, r3
 8002da2:	1acb      	subs	r3, r1, r3
 8002da4:	4698      	mov	r8, r3
 8002da6:	465d      	mov	r5, fp
 8002da8:	0016      	movs	r6, r2
 8002daa:	e5e2      	b.n	8002972 <__aeabi_dsub+0xaa>
 8002dac:	464e      	mov	r6, r9
 8002dae:	431e      	orrs	r6, r3
 8002db0:	d100      	bne.n	8002db4 <__aeabi_dsub+0x4ec>
 8002db2:	e0ae      	b.n	8002f12 <__aeabi_dsub+0x64a>
 8002db4:	1e66      	subs	r6, r4, #1
 8002db6:	2c01      	cmp	r4, #1
 8002db8:	d100      	bne.n	8002dbc <__aeabi_dsub+0x4f4>
 8002dba:	e0fd      	b.n	8002fb8 <__aeabi_dsub+0x6f0>
 8002dbc:	4f7b      	ldr	r7, [pc, #492]	; (8002fac <__aeabi_dsub+0x6e4>)
 8002dbe:	42bc      	cmp	r4, r7
 8002dc0:	d100      	bne.n	8002dc4 <__aeabi_dsub+0x4fc>
 8002dc2:	e107      	b.n	8002fd4 <__aeabi_dsub+0x70c>
 8002dc4:	46b4      	mov	ip, r6
 8002dc6:	e69b      	b.n	8002b00 <__aeabi_dsub+0x238>
 8002dc8:	4664      	mov	r4, ip
 8002dca:	2220      	movs	r2, #32
 8002dcc:	1b12      	subs	r2, r2, r4
 8002dce:	000c      	movs	r4, r1
 8002dd0:	4094      	lsls	r4, r2
 8002dd2:	0007      	movs	r7, r0
 8002dd4:	4090      	lsls	r0, r2
 8002dd6:	46a0      	mov	r8, r4
 8002dd8:	4664      	mov	r4, ip
 8002dda:	1e42      	subs	r2, r0, #1
 8002ddc:	4190      	sbcs	r0, r2
 8002dde:	4662      	mov	r2, ip
 8002de0:	40e7      	lsrs	r7, r4
 8002de2:	4644      	mov	r4, r8
 8002de4:	40d1      	lsrs	r1, r2
 8002de6:	433c      	orrs	r4, r7
 8002de8:	4304      	orrs	r4, r0
 8002dea:	185b      	adds	r3, r3, r1
 8002dec:	e6f3      	b.n	8002bd6 <__aeabi_dsub+0x30e>
 8002dee:	4c6f      	ldr	r4, [pc, #444]	; (8002fac <__aeabi_dsub+0x6e4>)
 8002df0:	42a2      	cmp	r2, r4
 8002df2:	d100      	bne.n	8002df6 <__aeabi_dsub+0x52e>
 8002df4:	e0d5      	b.n	8002fa2 <__aeabi_dsub+0x6da>
 8002df6:	4448      	add	r0, r9
 8002df8:	185b      	adds	r3, r3, r1
 8002dfa:	4548      	cmp	r0, r9
 8002dfc:	4189      	sbcs	r1, r1
 8002dfe:	4249      	negs	r1, r1
 8002e00:	185b      	adds	r3, r3, r1
 8002e02:	07dc      	lsls	r4, r3, #31
 8002e04:	0840      	lsrs	r0, r0, #1
 8002e06:	085b      	lsrs	r3, r3, #1
 8002e08:	4698      	mov	r8, r3
 8002e0a:	0016      	movs	r6, r2
 8002e0c:	4304      	orrs	r4, r0
 8002e0e:	e6cc      	b.n	8002baa <__aeabi_dsub+0x2e2>
 8002e10:	2a00      	cmp	r2, #0
 8002e12:	d000      	beq.n	8002e16 <__aeabi_dsub+0x54e>
 8002e14:	e082      	b.n	8002f1c <__aeabi_dsub+0x654>
 8002e16:	000a      	movs	r2, r1
 8002e18:	4302      	orrs	r2, r0
 8002e1a:	d140      	bne.n	8002e9e <__aeabi_dsub+0x5d6>
 8002e1c:	2380      	movs	r3, #128	; 0x80
 8002e1e:	2500      	movs	r5, #0
 8002e20:	031b      	lsls	r3, r3, #12
 8002e22:	e713      	b.n	8002c4c <__aeabi_dsub+0x384>
 8002e24:	074b      	lsls	r3, r1, #29
 8002e26:	08c2      	lsrs	r2, r0, #3
 8002e28:	431a      	orrs	r2, r3
 8002e2a:	465d      	mov	r5, fp
 8002e2c:	08cb      	lsrs	r3, r1, #3
 8002e2e:	e6c5      	b.n	8002bbc <__aeabi_dsub+0x2f4>
 8002e30:	464a      	mov	r2, r9
 8002e32:	1a84      	subs	r4, r0, r2
 8002e34:	42a0      	cmp	r0, r4
 8002e36:	4192      	sbcs	r2, r2
 8002e38:	1acb      	subs	r3, r1, r3
 8002e3a:	4252      	negs	r2, r2
 8002e3c:	1a9b      	subs	r3, r3, r2
 8002e3e:	4698      	mov	r8, r3
 8002e40:	465d      	mov	r5, fp
 8002e42:	e59e      	b.n	8002982 <__aeabi_dsub+0xba>
 8002e44:	464a      	mov	r2, r9
 8002e46:	0759      	lsls	r1, r3, #29
 8002e48:	08d2      	lsrs	r2, r2, #3
 8002e4a:	430a      	orrs	r2, r1
 8002e4c:	08db      	lsrs	r3, r3, #3
 8002e4e:	e6f9      	b.n	8002c44 <__aeabi_dsub+0x37c>
 8002e50:	464a      	mov	r2, r9
 8002e52:	1a14      	subs	r4, r2, r0
 8002e54:	45a1      	cmp	r9, r4
 8002e56:	4192      	sbcs	r2, r2
 8002e58:	1a5b      	subs	r3, r3, r1
 8002e5a:	4252      	negs	r2, r2
 8002e5c:	1a9b      	subs	r3, r3, r2
 8002e5e:	4698      	mov	r8, r3
 8002e60:	2601      	movs	r6, #1
 8002e62:	e586      	b.n	8002972 <__aeabi_dsub+0xaa>
 8002e64:	464a      	mov	r2, r9
 8002e66:	0759      	lsls	r1, r3, #29
 8002e68:	08d2      	lsrs	r2, r2, #3
 8002e6a:	430a      	orrs	r2, r1
 8002e6c:	08db      	lsrs	r3, r3, #3
 8002e6e:	e6a5      	b.n	8002bbc <__aeabi_dsub+0x2f4>
 8002e70:	464c      	mov	r4, r9
 8002e72:	4323      	orrs	r3, r4
 8002e74:	001c      	movs	r4, r3
 8002e76:	1e63      	subs	r3, r4, #1
 8002e78:	419c      	sbcs	r4, r3
 8002e7a:	e65b      	b.n	8002b34 <__aeabi_dsub+0x26c>
 8002e7c:	4665      	mov	r5, ip
 8002e7e:	001e      	movs	r6, r3
 8002e80:	3d20      	subs	r5, #32
 8002e82:	40ee      	lsrs	r6, r5
 8002e84:	2c20      	cmp	r4, #32
 8002e86:	d005      	beq.n	8002e94 <__aeabi_dsub+0x5cc>
 8002e88:	2540      	movs	r5, #64	; 0x40
 8002e8a:	1b2d      	subs	r5, r5, r4
 8002e8c:	40ab      	lsls	r3, r5
 8002e8e:	464c      	mov	r4, r9
 8002e90:	431c      	orrs	r4, r3
 8002e92:	46a2      	mov	sl, r4
 8002e94:	4654      	mov	r4, sl
 8002e96:	1e63      	subs	r3, r4, #1
 8002e98:	419c      	sbcs	r4, r3
 8002e9a:	4334      	orrs	r4, r6
 8002e9c:	e77d      	b.n	8002d9a <__aeabi_dsub+0x4d2>
 8002e9e:	074b      	lsls	r3, r1, #29
 8002ea0:	08c2      	lsrs	r2, r0, #3
 8002ea2:	431a      	orrs	r2, r3
 8002ea4:	465d      	mov	r5, fp
 8002ea6:	08cb      	lsrs	r3, r1, #3
 8002ea8:	e6cc      	b.n	8002c44 <__aeabi_dsub+0x37c>
 8002eaa:	000a      	movs	r2, r1
 8002eac:	4302      	orrs	r2, r0
 8002eae:	d100      	bne.n	8002eb2 <__aeabi_dsub+0x5ea>
 8002eb0:	e736      	b.n	8002d20 <__aeabi_dsub+0x458>
 8002eb2:	074b      	lsls	r3, r1, #29
 8002eb4:	08c2      	lsrs	r2, r0, #3
 8002eb6:	431a      	orrs	r2, r3
 8002eb8:	465d      	mov	r5, fp
 8002eba:	08cb      	lsrs	r3, r1, #3
 8002ebc:	e681      	b.n	8002bc2 <__aeabi_dsub+0x2fa>
 8002ebe:	464a      	mov	r2, r9
 8002ec0:	1a84      	subs	r4, r0, r2
 8002ec2:	42a0      	cmp	r0, r4
 8002ec4:	4192      	sbcs	r2, r2
 8002ec6:	1acb      	subs	r3, r1, r3
 8002ec8:	4252      	negs	r2, r2
 8002eca:	1a9b      	subs	r3, r3, r2
 8002ecc:	4698      	mov	r8, r3
 8002ece:	465d      	mov	r5, fp
 8002ed0:	2601      	movs	r6, #1
 8002ed2:	e54e      	b.n	8002972 <__aeabi_dsub+0xaa>
 8002ed4:	074b      	lsls	r3, r1, #29
 8002ed6:	08c2      	lsrs	r2, r0, #3
 8002ed8:	431a      	orrs	r2, r3
 8002eda:	08cb      	lsrs	r3, r1, #3
 8002edc:	e6b2      	b.n	8002c44 <__aeabi_dsub+0x37c>
 8002ede:	464a      	mov	r2, r9
 8002ee0:	1a14      	subs	r4, r2, r0
 8002ee2:	45a1      	cmp	r9, r4
 8002ee4:	4192      	sbcs	r2, r2
 8002ee6:	1a5f      	subs	r7, r3, r1
 8002ee8:	4252      	negs	r2, r2
 8002eea:	1aba      	subs	r2, r7, r2
 8002eec:	4690      	mov	r8, r2
 8002eee:	0212      	lsls	r2, r2, #8
 8002ef0:	d56b      	bpl.n	8002fca <__aeabi_dsub+0x702>
 8002ef2:	464a      	mov	r2, r9
 8002ef4:	1a84      	subs	r4, r0, r2
 8002ef6:	42a0      	cmp	r0, r4
 8002ef8:	4192      	sbcs	r2, r2
 8002efa:	1acb      	subs	r3, r1, r3
 8002efc:	4252      	negs	r2, r2
 8002efe:	1a9b      	subs	r3, r3, r2
 8002f00:	4698      	mov	r8, r3
 8002f02:	465d      	mov	r5, fp
 8002f04:	e564      	b.n	80029d0 <__aeabi_dsub+0x108>
 8002f06:	074b      	lsls	r3, r1, #29
 8002f08:	08c2      	lsrs	r2, r0, #3
 8002f0a:	431a      	orrs	r2, r3
 8002f0c:	465d      	mov	r5, fp
 8002f0e:	08cb      	lsrs	r3, r1, #3
 8002f10:	e698      	b.n	8002c44 <__aeabi_dsub+0x37c>
 8002f12:	074b      	lsls	r3, r1, #29
 8002f14:	08c2      	lsrs	r2, r0, #3
 8002f16:	431a      	orrs	r2, r3
 8002f18:	08cb      	lsrs	r3, r1, #3
 8002f1a:	e64f      	b.n	8002bbc <__aeabi_dsub+0x2f4>
 8002f1c:	000a      	movs	r2, r1
 8002f1e:	4302      	orrs	r2, r0
 8002f20:	d090      	beq.n	8002e44 <__aeabi_dsub+0x57c>
 8002f22:	464a      	mov	r2, r9
 8002f24:	075c      	lsls	r4, r3, #29
 8002f26:	08d2      	lsrs	r2, r2, #3
 8002f28:	4314      	orrs	r4, r2
 8002f2a:	2280      	movs	r2, #128	; 0x80
 8002f2c:	08db      	lsrs	r3, r3, #3
 8002f2e:	0312      	lsls	r2, r2, #12
 8002f30:	4213      	tst	r3, r2
 8002f32:	d008      	beq.n	8002f46 <__aeabi_dsub+0x67e>
 8002f34:	08ce      	lsrs	r6, r1, #3
 8002f36:	4216      	tst	r6, r2
 8002f38:	d105      	bne.n	8002f46 <__aeabi_dsub+0x67e>
 8002f3a:	08c0      	lsrs	r0, r0, #3
 8002f3c:	0749      	lsls	r1, r1, #29
 8002f3e:	4308      	orrs	r0, r1
 8002f40:	0004      	movs	r4, r0
 8002f42:	465d      	mov	r5, fp
 8002f44:	0033      	movs	r3, r6
 8002f46:	0f61      	lsrs	r1, r4, #29
 8002f48:	00e2      	lsls	r2, r4, #3
 8002f4a:	0749      	lsls	r1, r1, #29
 8002f4c:	08d2      	lsrs	r2, r2, #3
 8002f4e:	430a      	orrs	r2, r1
 8002f50:	e678      	b.n	8002c44 <__aeabi_dsub+0x37c>
 8002f52:	074b      	lsls	r3, r1, #29
 8002f54:	08c2      	lsrs	r2, r0, #3
 8002f56:	431a      	orrs	r2, r3
 8002f58:	08cb      	lsrs	r3, r1, #3
 8002f5a:	e632      	b.n	8002bc2 <__aeabi_dsub+0x2fa>
 8002f5c:	4448      	add	r0, r9
 8002f5e:	185b      	adds	r3, r3, r1
 8002f60:	4548      	cmp	r0, r9
 8002f62:	4192      	sbcs	r2, r2
 8002f64:	4698      	mov	r8, r3
 8002f66:	4252      	negs	r2, r2
 8002f68:	4490      	add	r8, r2
 8002f6a:	4643      	mov	r3, r8
 8002f6c:	0004      	movs	r4, r0
 8002f6e:	021b      	lsls	r3, r3, #8
 8002f70:	d400      	bmi.n	8002f74 <__aeabi_dsub+0x6ac>
 8002f72:	e61a      	b.n	8002baa <__aeabi_dsub+0x2e2>
 8002f74:	4642      	mov	r2, r8
 8002f76:	4b0e      	ldr	r3, [pc, #56]	; (8002fb0 <__aeabi_dsub+0x6e8>)
 8002f78:	2601      	movs	r6, #1
 8002f7a:	401a      	ands	r2, r3
 8002f7c:	4690      	mov	r8, r2
 8002f7e:	e614      	b.n	8002baa <__aeabi_dsub+0x2e2>
 8002f80:	4666      	mov	r6, ip
 8002f82:	001f      	movs	r7, r3
 8002f84:	3e20      	subs	r6, #32
 8002f86:	40f7      	lsrs	r7, r6
 8002f88:	2c20      	cmp	r4, #32
 8002f8a:	d005      	beq.n	8002f98 <__aeabi_dsub+0x6d0>
 8002f8c:	2640      	movs	r6, #64	; 0x40
 8002f8e:	1b36      	subs	r6, r6, r4
 8002f90:	40b3      	lsls	r3, r6
 8002f92:	464c      	mov	r4, r9
 8002f94:	431c      	orrs	r4, r3
 8002f96:	46a2      	mov	sl, r4
 8002f98:	4654      	mov	r4, sl
 8002f9a:	1e63      	subs	r3, r4, #1
 8002f9c:	419c      	sbcs	r4, r3
 8002f9e:	433c      	orrs	r4, r7
 8002fa0:	e5c8      	b.n	8002b34 <__aeabi_dsub+0x26c>
 8002fa2:	0011      	movs	r1, r2
 8002fa4:	2300      	movs	r3, #0
 8002fa6:	2200      	movs	r2, #0
 8002fa8:	e532      	b.n	8002a10 <__aeabi_dsub+0x148>
 8002faa:	46c0      	nop			; (mov r8, r8)
 8002fac:	000007ff 	.word	0x000007ff
 8002fb0:	ff7fffff 	.word	0xff7fffff
 8002fb4:	000007fe 	.word	0x000007fe
 8002fb8:	464a      	mov	r2, r9
 8002fba:	1814      	adds	r4, r2, r0
 8002fbc:	4284      	cmp	r4, r0
 8002fbe:	4192      	sbcs	r2, r2
 8002fc0:	185b      	adds	r3, r3, r1
 8002fc2:	4698      	mov	r8, r3
 8002fc4:	4252      	negs	r2, r2
 8002fc6:	4490      	add	r8, r2
 8002fc8:	e5e9      	b.n	8002b9e <__aeabi_dsub+0x2d6>
 8002fca:	4642      	mov	r2, r8
 8002fcc:	4322      	orrs	r2, r4
 8002fce:	d100      	bne.n	8002fd2 <__aeabi_dsub+0x70a>
 8002fd0:	e6a6      	b.n	8002d20 <__aeabi_dsub+0x458>
 8002fd2:	e5ea      	b.n	8002baa <__aeabi_dsub+0x2e2>
 8002fd4:	074b      	lsls	r3, r1, #29
 8002fd6:	08c2      	lsrs	r2, r0, #3
 8002fd8:	431a      	orrs	r2, r3
 8002fda:	08cb      	lsrs	r3, r1, #3
 8002fdc:	e632      	b.n	8002c44 <__aeabi_dsub+0x37c>
 8002fde:	2200      	movs	r2, #0
 8002fe0:	4901      	ldr	r1, [pc, #4]	; (8002fe8 <__aeabi_dsub+0x720>)
 8002fe2:	0013      	movs	r3, r2
 8002fe4:	e514      	b.n	8002a10 <__aeabi_dsub+0x148>
 8002fe6:	46c0      	nop			; (mov r8, r8)
 8002fe8:	000007ff 	.word	0x000007ff

08002fec <__aeabi_d2iz>:
 8002fec:	000a      	movs	r2, r1
 8002fee:	b530      	push	{r4, r5, lr}
 8002ff0:	4c13      	ldr	r4, [pc, #76]	; (8003040 <__aeabi_d2iz+0x54>)
 8002ff2:	0053      	lsls	r3, r2, #1
 8002ff4:	0309      	lsls	r1, r1, #12
 8002ff6:	0005      	movs	r5, r0
 8002ff8:	0b09      	lsrs	r1, r1, #12
 8002ffa:	2000      	movs	r0, #0
 8002ffc:	0d5b      	lsrs	r3, r3, #21
 8002ffe:	0fd2      	lsrs	r2, r2, #31
 8003000:	42a3      	cmp	r3, r4
 8003002:	dd04      	ble.n	800300e <__aeabi_d2iz+0x22>
 8003004:	480f      	ldr	r0, [pc, #60]	; (8003044 <__aeabi_d2iz+0x58>)
 8003006:	4283      	cmp	r3, r0
 8003008:	dd02      	ble.n	8003010 <__aeabi_d2iz+0x24>
 800300a:	4b0f      	ldr	r3, [pc, #60]	; (8003048 <__aeabi_d2iz+0x5c>)
 800300c:	18d0      	adds	r0, r2, r3
 800300e:	bd30      	pop	{r4, r5, pc}
 8003010:	2080      	movs	r0, #128	; 0x80
 8003012:	0340      	lsls	r0, r0, #13
 8003014:	4301      	orrs	r1, r0
 8003016:	480d      	ldr	r0, [pc, #52]	; (800304c <__aeabi_d2iz+0x60>)
 8003018:	1ac0      	subs	r0, r0, r3
 800301a:	281f      	cmp	r0, #31
 800301c:	dd08      	ble.n	8003030 <__aeabi_d2iz+0x44>
 800301e:	480c      	ldr	r0, [pc, #48]	; (8003050 <__aeabi_d2iz+0x64>)
 8003020:	1ac3      	subs	r3, r0, r3
 8003022:	40d9      	lsrs	r1, r3
 8003024:	000b      	movs	r3, r1
 8003026:	4258      	negs	r0, r3
 8003028:	2a00      	cmp	r2, #0
 800302a:	d1f0      	bne.n	800300e <__aeabi_d2iz+0x22>
 800302c:	0018      	movs	r0, r3
 800302e:	e7ee      	b.n	800300e <__aeabi_d2iz+0x22>
 8003030:	4c08      	ldr	r4, [pc, #32]	; (8003054 <__aeabi_d2iz+0x68>)
 8003032:	40c5      	lsrs	r5, r0
 8003034:	46a4      	mov	ip, r4
 8003036:	4463      	add	r3, ip
 8003038:	4099      	lsls	r1, r3
 800303a:	000b      	movs	r3, r1
 800303c:	432b      	orrs	r3, r5
 800303e:	e7f2      	b.n	8003026 <__aeabi_d2iz+0x3a>
 8003040:	000003fe 	.word	0x000003fe
 8003044:	0000041d 	.word	0x0000041d
 8003048:	7fffffff 	.word	0x7fffffff
 800304c:	00000433 	.word	0x00000433
 8003050:	00000413 	.word	0x00000413
 8003054:	fffffbed 	.word	0xfffffbed

08003058 <__aeabi_i2d>:
 8003058:	b570      	push	{r4, r5, r6, lr}
 800305a:	2800      	cmp	r0, #0
 800305c:	d016      	beq.n	800308c <__aeabi_i2d+0x34>
 800305e:	17c3      	asrs	r3, r0, #31
 8003060:	18c5      	adds	r5, r0, r3
 8003062:	405d      	eors	r5, r3
 8003064:	0fc4      	lsrs	r4, r0, #31
 8003066:	0028      	movs	r0, r5
 8003068:	f000 f894 	bl	8003194 <__clzsi2>
 800306c:	4a11      	ldr	r2, [pc, #68]	; (80030b4 <__aeabi_i2d+0x5c>)
 800306e:	1a12      	subs	r2, r2, r0
 8003070:	280a      	cmp	r0, #10
 8003072:	dc16      	bgt.n	80030a2 <__aeabi_i2d+0x4a>
 8003074:	0003      	movs	r3, r0
 8003076:	002e      	movs	r6, r5
 8003078:	3315      	adds	r3, #21
 800307a:	409e      	lsls	r6, r3
 800307c:	230b      	movs	r3, #11
 800307e:	1a18      	subs	r0, r3, r0
 8003080:	40c5      	lsrs	r5, r0
 8003082:	0553      	lsls	r3, r2, #21
 8003084:	032d      	lsls	r5, r5, #12
 8003086:	0b2d      	lsrs	r5, r5, #12
 8003088:	0d5b      	lsrs	r3, r3, #21
 800308a:	e003      	b.n	8003094 <__aeabi_i2d+0x3c>
 800308c:	2400      	movs	r4, #0
 800308e:	2300      	movs	r3, #0
 8003090:	2500      	movs	r5, #0
 8003092:	2600      	movs	r6, #0
 8003094:	051b      	lsls	r3, r3, #20
 8003096:	432b      	orrs	r3, r5
 8003098:	07e4      	lsls	r4, r4, #31
 800309a:	4323      	orrs	r3, r4
 800309c:	0030      	movs	r0, r6
 800309e:	0019      	movs	r1, r3
 80030a0:	bd70      	pop	{r4, r5, r6, pc}
 80030a2:	380b      	subs	r0, #11
 80030a4:	4085      	lsls	r5, r0
 80030a6:	0553      	lsls	r3, r2, #21
 80030a8:	032d      	lsls	r5, r5, #12
 80030aa:	2600      	movs	r6, #0
 80030ac:	0b2d      	lsrs	r5, r5, #12
 80030ae:	0d5b      	lsrs	r3, r3, #21
 80030b0:	e7f0      	b.n	8003094 <__aeabi_i2d+0x3c>
 80030b2:	46c0      	nop			; (mov r8, r8)
 80030b4:	0000041e 	.word	0x0000041e

080030b8 <__aeabi_ui2d>:
 80030b8:	b510      	push	{r4, lr}
 80030ba:	1e04      	subs	r4, r0, #0
 80030bc:	d010      	beq.n	80030e0 <__aeabi_ui2d+0x28>
 80030be:	f000 f869 	bl	8003194 <__clzsi2>
 80030c2:	4b0f      	ldr	r3, [pc, #60]	; (8003100 <__aeabi_ui2d+0x48>)
 80030c4:	1a1b      	subs	r3, r3, r0
 80030c6:	280a      	cmp	r0, #10
 80030c8:	dc11      	bgt.n	80030ee <__aeabi_ui2d+0x36>
 80030ca:	220b      	movs	r2, #11
 80030cc:	0021      	movs	r1, r4
 80030ce:	1a12      	subs	r2, r2, r0
 80030d0:	40d1      	lsrs	r1, r2
 80030d2:	3015      	adds	r0, #21
 80030d4:	030a      	lsls	r2, r1, #12
 80030d6:	055b      	lsls	r3, r3, #21
 80030d8:	4084      	lsls	r4, r0
 80030da:	0b12      	lsrs	r2, r2, #12
 80030dc:	0d5b      	lsrs	r3, r3, #21
 80030de:	e001      	b.n	80030e4 <__aeabi_ui2d+0x2c>
 80030e0:	2300      	movs	r3, #0
 80030e2:	2200      	movs	r2, #0
 80030e4:	051b      	lsls	r3, r3, #20
 80030e6:	4313      	orrs	r3, r2
 80030e8:	0020      	movs	r0, r4
 80030ea:	0019      	movs	r1, r3
 80030ec:	bd10      	pop	{r4, pc}
 80030ee:	0022      	movs	r2, r4
 80030f0:	380b      	subs	r0, #11
 80030f2:	4082      	lsls	r2, r0
 80030f4:	055b      	lsls	r3, r3, #21
 80030f6:	0312      	lsls	r2, r2, #12
 80030f8:	2400      	movs	r4, #0
 80030fa:	0b12      	lsrs	r2, r2, #12
 80030fc:	0d5b      	lsrs	r3, r3, #21
 80030fe:	e7f1      	b.n	80030e4 <__aeabi_ui2d+0x2c>
 8003100:	0000041e 	.word	0x0000041e

08003104 <__aeabi_f2d>:
 8003104:	b570      	push	{r4, r5, r6, lr}
 8003106:	0043      	lsls	r3, r0, #1
 8003108:	0246      	lsls	r6, r0, #9
 800310a:	0fc4      	lsrs	r4, r0, #31
 800310c:	20fe      	movs	r0, #254	; 0xfe
 800310e:	0e1b      	lsrs	r3, r3, #24
 8003110:	1c59      	adds	r1, r3, #1
 8003112:	0a75      	lsrs	r5, r6, #9
 8003114:	4208      	tst	r0, r1
 8003116:	d00c      	beq.n	8003132 <__aeabi_f2d+0x2e>
 8003118:	22e0      	movs	r2, #224	; 0xe0
 800311a:	0092      	lsls	r2, r2, #2
 800311c:	4694      	mov	ip, r2
 800311e:	076d      	lsls	r5, r5, #29
 8003120:	0b36      	lsrs	r6, r6, #12
 8003122:	4463      	add	r3, ip
 8003124:	051b      	lsls	r3, r3, #20
 8003126:	4333      	orrs	r3, r6
 8003128:	07e4      	lsls	r4, r4, #31
 800312a:	4323      	orrs	r3, r4
 800312c:	0028      	movs	r0, r5
 800312e:	0019      	movs	r1, r3
 8003130:	bd70      	pop	{r4, r5, r6, pc}
 8003132:	2b00      	cmp	r3, #0
 8003134:	d114      	bne.n	8003160 <__aeabi_f2d+0x5c>
 8003136:	2d00      	cmp	r5, #0
 8003138:	d01b      	beq.n	8003172 <__aeabi_f2d+0x6e>
 800313a:	0028      	movs	r0, r5
 800313c:	f000 f82a 	bl	8003194 <__clzsi2>
 8003140:	280a      	cmp	r0, #10
 8003142:	dc1c      	bgt.n	800317e <__aeabi_f2d+0x7a>
 8003144:	230b      	movs	r3, #11
 8003146:	002a      	movs	r2, r5
 8003148:	1a1b      	subs	r3, r3, r0
 800314a:	40da      	lsrs	r2, r3
 800314c:	0003      	movs	r3, r0
 800314e:	3315      	adds	r3, #21
 8003150:	409d      	lsls	r5, r3
 8003152:	4b0e      	ldr	r3, [pc, #56]	; (800318c <__aeabi_f2d+0x88>)
 8003154:	0312      	lsls	r2, r2, #12
 8003156:	1a1b      	subs	r3, r3, r0
 8003158:	055b      	lsls	r3, r3, #21
 800315a:	0b16      	lsrs	r6, r2, #12
 800315c:	0d5b      	lsrs	r3, r3, #21
 800315e:	e7e1      	b.n	8003124 <__aeabi_f2d+0x20>
 8003160:	2d00      	cmp	r5, #0
 8003162:	d009      	beq.n	8003178 <__aeabi_f2d+0x74>
 8003164:	0b32      	lsrs	r2, r6, #12
 8003166:	2680      	movs	r6, #128	; 0x80
 8003168:	0336      	lsls	r6, r6, #12
 800316a:	4b09      	ldr	r3, [pc, #36]	; (8003190 <__aeabi_f2d+0x8c>)
 800316c:	076d      	lsls	r5, r5, #29
 800316e:	4316      	orrs	r6, r2
 8003170:	e7d8      	b.n	8003124 <__aeabi_f2d+0x20>
 8003172:	2300      	movs	r3, #0
 8003174:	2600      	movs	r6, #0
 8003176:	e7d5      	b.n	8003124 <__aeabi_f2d+0x20>
 8003178:	2600      	movs	r6, #0
 800317a:	4b05      	ldr	r3, [pc, #20]	; (8003190 <__aeabi_f2d+0x8c>)
 800317c:	e7d2      	b.n	8003124 <__aeabi_f2d+0x20>
 800317e:	0003      	movs	r3, r0
 8003180:	002a      	movs	r2, r5
 8003182:	3b0b      	subs	r3, #11
 8003184:	409a      	lsls	r2, r3
 8003186:	2500      	movs	r5, #0
 8003188:	e7e3      	b.n	8003152 <__aeabi_f2d+0x4e>
 800318a:	46c0      	nop			; (mov r8, r8)
 800318c:	00000389 	.word	0x00000389
 8003190:	000007ff 	.word	0x000007ff

08003194 <__clzsi2>:
 8003194:	211c      	movs	r1, #28
 8003196:	2301      	movs	r3, #1
 8003198:	041b      	lsls	r3, r3, #16
 800319a:	4298      	cmp	r0, r3
 800319c:	d301      	bcc.n	80031a2 <__clzsi2+0xe>
 800319e:	0c00      	lsrs	r0, r0, #16
 80031a0:	3910      	subs	r1, #16
 80031a2:	0a1b      	lsrs	r3, r3, #8
 80031a4:	4298      	cmp	r0, r3
 80031a6:	d301      	bcc.n	80031ac <__clzsi2+0x18>
 80031a8:	0a00      	lsrs	r0, r0, #8
 80031aa:	3908      	subs	r1, #8
 80031ac:	091b      	lsrs	r3, r3, #4
 80031ae:	4298      	cmp	r0, r3
 80031b0:	d301      	bcc.n	80031b6 <__clzsi2+0x22>
 80031b2:	0900      	lsrs	r0, r0, #4
 80031b4:	3904      	subs	r1, #4
 80031b6:	a202      	add	r2, pc, #8	; (adr r2, 80031c0 <__clzsi2+0x2c>)
 80031b8:	5c10      	ldrb	r0, [r2, r0]
 80031ba:	1840      	adds	r0, r0, r1
 80031bc:	4770      	bx	lr
 80031be:	46c0      	nop			; (mov r8, r8)
 80031c0:	02020304 	.word	0x02020304
 80031c4:	01010101 	.word	0x01010101
	...

080031d0 <__clzdi2>:
 80031d0:	b510      	push	{r4, lr}
 80031d2:	2900      	cmp	r1, #0
 80031d4:	d103      	bne.n	80031de <__clzdi2+0xe>
 80031d6:	f7ff ffdd 	bl	8003194 <__clzsi2>
 80031da:	3020      	adds	r0, #32
 80031dc:	e002      	b.n	80031e4 <__clzdi2+0x14>
 80031de:	1c08      	adds	r0, r1, #0
 80031e0:	f7ff ffd8 	bl	8003194 <__clzsi2>
 80031e4:	bd10      	pop	{r4, pc}
 80031e6:	46c0      	nop			; (mov r8, r8)

080031e8 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
 80031e8:	480d      	ldr	r0, [pc, #52]	; (8003220 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
 80031ea:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 80031ec:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80031ee:	e003      	b.n	80031f8 <LoopCopyDataInit>

080031f0 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80031f0:	4b0c      	ldr	r3, [pc, #48]	; (8003224 <LoopForever+0x6>)
  ldr  r3, [r3, r1]
 80031f2:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80031f4:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80031f6:	3104      	adds	r1, #4

080031f8 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
 80031f8:	480b      	ldr	r0, [pc, #44]	; (8003228 <LoopForever+0xa>)
  ldr  r3, =_edata
 80031fa:	4b0c      	ldr	r3, [pc, #48]	; (800322c <LoopForever+0xe>)
  adds  r2, r0, r1
 80031fc:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80031fe:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8003200:	d3f6      	bcc.n	80031f0 <CopyDataInit>
  ldr  r2, =_sbss
 8003202:	4a0b      	ldr	r2, [pc, #44]	; (8003230 <LoopForever+0x12>)
  b  LoopFillZerobss
 8003204:	e002      	b.n	800320c <LoopFillZerobss>

08003206 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 8003206:	2300      	movs	r3, #0
  str  r3, [r2]
 8003208:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800320a:	3204      	adds	r2, #4

0800320c <LoopFillZerobss>:


LoopFillZerobss:
  ldr  r3, = _ebss
 800320c:	4b09      	ldr	r3, [pc, #36]	; (8003234 <LoopForever+0x16>)
  cmp  r2, r3
 800320e:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8003210:	d3f9      	bcc.n	8003206 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8003212:	f005 ff2b 	bl	800906c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8003216:	f01a f979 	bl	801d50c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800321a:	f019 f8fd 	bl	801c418 <main>

0800321e <LoopForever>:

LoopForever:
    b LoopForever
 800321e:	e7fe      	b.n	800321e <LoopForever>
   ldr   r0, =_estack
 8003220:	20005000 	.word	0x20005000
  ldr  r3, =_sidata
 8003224:	0801fedc 	.word	0x0801fedc
  ldr  r0, =_sdata
 8003228:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800322c:	20000334 	.word	0x20000334
  ldr  r2, =_sbss
 8003230:	20000334 	.word	0x20000334
  ldr  r3, = _ebss
 8003234:	2000183c 	.word	0x2000183c

08003238 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8003238:	e7fe      	b.n	8003238 <ADC1_COMP_IRQHandler>
	...

0800323c <BSP_LED_Init>:
  *   This parameter can be one of following parameters:
  *            @arg  LED2
  * @retval None
  */
void BSP_LED_Init(Led_TypeDef Led)
{
 800323c:	b580      	push	{r7, lr}
 800323e:	b08c      	sub	sp, #48	; 0x30
 8003240:	af00      	add	r7, sp, #0
 8003242:	0002      	movs	r2, r0
 8003244:	1dfb      	adds	r3, r7, #7
 8003246:	701a      	strb	r2, [r3, #0]
  GPIO_InitTypeDef  GPIO_InitStruct;
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE( Led );
 8003248:	1dfb      	adds	r3, r7, #7
 800324a:	781b      	ldrb	r3, [r3, #0]
 800324c:	2b03      	cmp	r3, #3
 800324e:	d02f      	beq.n	80032b0 <BSP_LED_Init+0x74>
 8003250:	dc3a      	bgt.n	80032c8 <BSP_LED_Init+0x8c>
 8003252:	2b02      	cmp	r3, #2
 8003254:	d01f      	beq.n	8003296 <BSP_LED_Init+0x5a>
 8003256:	dc37      	bgt.n	80032c8 <BSP_LED_Init+0x8c>
 8003258:	2b00      	cmp	r3, #0
 800325a:	d002      	beq.n	8003262 <BSP_LED_Init+0x26>
 800325c:	2b01      	cmp	r3, #1
 800325e:	d00d      	beq.n	800327c <BSP_LED_Init+0x40>
 8003260:	e032      	b.n	80032c8 <BSP_LED_Init+0x8c>
 8003262:	4b2a      	ldr	r3, [pc, #168]	; (800330c <BSP_LED_Init+0xd0>)
 8003264:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003266:	4b29      	ldr	r3, [pc, #164]	; (800330c <BSP_LED_Init+0xd0>)
 8003268:	2102      	movs	r1, #2
 800326a:	430a      	orrs	r2, r1
 800326c:	62da      	str	r2, [r3, #44]	; 0x2c
 800326e:	4b27      	ldr	r3, [pc, #156]	; (800330c <BSP_LED_Init+0xd0>)
 8003270:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003272:	2202      	movs	r2, #2
 8003274:	4013      	ands	r3, r2
 8003276:	61bb      	str	r3, [r7, #24]
 8003278:	69bb      	ldr	r3, [r7, #24]
 800327a:	e025      	b.n	80032c8 <BSP_LED_Init+0x8c>
 800327c:	4b23      	ldr	r3, [pc, #140]	; (800330c <BSP_LED_Init+0xd0>)
 800327e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003280:	4b22      	ldr	r3, [pc, #136]	; (800330c <BSP_LED_Init+0xd0>)
 8003282:	2101      	movs	r1, #1
 8003284:	430a      	orrs	r2, r1
 8003286:	62da      	str	r2, [r3, #44]	; 0x2c
 8003288:	4b20      	ldr	r3, [pc, #128]	; (800330c <BSP_LED_Init+0xd0>)
 800328a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800328c:	2201      	movs	r2, #1
 800328e:	4013      	ands	r3, r2
 8003290:	617b      	str	r3, [r7, #20]
 8003292:	697b      	ldr	r3, [r7, #20]
 8003294:	e018      	b.n	80032c8 <BSP_LED_Init+0x8c>
 8003296:	4b1d      	ldr	r3, [pc, #116]	; (800330c <BSP_LED_Init+0xd0>)
 8003298:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800329a:	4b1c      	ldr	r3, [pc, #112]	; (800330c <BSP_LED_Init+0xd0>)
 800329c:	2102      	movs	r1, #2
 800329e:	430a      	orrs	r2, r1
 80032a0:	62da      	str	r2, [r3, #44]	; 0x2c
 80032a2:	4b1a      	ldr	r3, [pc, #104]	; (800330c <BSP_LED_Init+0xd0>)
 80032a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80032a6:	2202      	movs	r2, #2
 80032a8:	4013      	ands	r3, r2
 80032aa:	613b      	str	r3, [r7, #16]
 80032ac:	693b      	ldr	r3, [r7, #16]
 80032ae:	e00b      	b.n	80032c8 <BSP_LED_Init+0x8c>
 80032b0:	4b16      	ldr	r3, [pc, #88]	; (800330c <BSP_LED_Init+0xd0>)
 80032b2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80032b4:	4b15      	ldr	r3, [pc, #84]	; (800330c <BSP_LED_Init+0xd0>)
 80032b6:	2102      	movs	r1, #2
 80032b8:	430a      	orrs	r2, r1
 80032ba:	62da      	str	r2, [r3, #44]	; 0x2c
 80032bc:	4b13      	ldr	r3, [pc, #76]	; (800330c <BSP_LED_Init+0xd0>)
 80032be:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80032c0:	2202      	movs	r2, #2
 80032c2:	4013      	ands	r3, r2
 80032c4:	60fb      	str	r3, [r7, #12]
 80032c6:	68fb      	ldr	r3, [r7, #12]
 80032c8:	46c0      	nop			; (mov r8, r8)

  /* Configure the GPIO_LED pin */
  GPIO_InitStruct.Pin = LED_PIN[Led];
 80032ca:	1dfb      	adds	r3, r7, #7
 80032cc:	781a      	ldrb	r2, [r3, #0]
 80032ce:	4b10      	ldr	r3, [pc, #64]	; (8003310 <BSP_LED_Init+0xd4>)
 80032d0:	0052      	lsls	r2, r2, #1
 80032d2:	5ad3      	ldrh	r3, [r2, r3]
 80032d4:	001a      	movs	r2, r3
 80032d6:	211c      	movs	r1, #28
 80032d8:	187b      	adds	r3, r7, r1
 80032da:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80032dc:	187b      	adds	r3, r7, r1
 80032de:	2201      	movs	r2, #1
 80032e0:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80032e2:	187b      	adds	r3, r7, r1
 80032e4:	2200      	movs	r2, #0
 80032e6:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80032e8:	187b      	adds	r3, r7, r1
 80032ea:	2203      	movs	r2, #3
 80032ec:	60da      	str	r2, [r3, #12]
  
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_InitStruct);
 80032ee:	1dfb      	adds	r3, r7, #7
 80032f0:	781a      	ldrb	r2, [r3, #0]
 80032f2:	4b08      	ldr	r3, [pc, #32]	; (8003314 <BSP_LED_Init+0xd8>)
 80032f4:	0092      	lsls	r2, r2, #2
 80032f6:	58d3      	ldr	r3, [r2, r3]
 80032f8:	187a      	adds	r2, r7, r1
 80032fa:	0011      	movs	r1, r2
 80032fc:	0018      	movs	r0, r3
 80032fe:	f006 fe11 	bl	8009f24 <HAL_GPIO_Init>
}
 8003302:	46c0      	nop			; (mov r8, r8)
 8003304:	46bd      	mov	sp, r7
 8003306:	b00c      	add	sp, #48	; 0x30
 8003308:	bd80      	pop	{r7, pc}
 800330a:	46c0      	nop			; (mov r8, r8)
 800330c:	40021000 	.word	0x40021000
 8003310:	0801ebc4 	.word	0x0801ebc4
 8003314:	20000000 	.word	0x20000000

08003318 <BSP_LED_On>:
  *   This parameter can be one of following parameters:
  *            @arg  LED2
  * @retval None
  */
void BSP_LED_On(Led_TypeDef Led)
{
 8003318:	b580      	push	{r7, lr}
 800331a:	b082      	sub	sp, #8
 800331c:	af00      	add	r7, sp, #0
 800331e:	0002      	movs	r2, r0
 8003320:	1dfb      	adds	r3, r7, #7
 8003322:	701a      	strb	r2, [r3, #0]
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
 8003324:	1dfb      	adds	r3, r7, #7
 8003326:	781a      	ldrb	r2, [r3, #0]
 8003328:	4b07      	ldr	r3, [pc, #28]	; (8003348 <BSP_LED_On+0x30>)
 800332a:	0092      	lsls	r2, r2, #2
 800332c:	58d0      	ldr	r0, [r2, r3]
 800332e:	1dfb      	adds	r3, r7, #7
 8003330:	781a      	ldrb	r2, [r3, #0]
 8003332:	4b06      	ldr	r3, [pc, #24]	; (800334c <BSP_LED_On+0x34>)
 8003334:	0052      	lsls	r2, r2, #1
 8003336:	5ad3      	ldrh	r3, [r2, r3]
 8003338:	2201      	movs	r2, #1
 800333a:	0019      	movs	r1, r3
 800333c:	f006 ff70 	bl	800a220 <HAL_GPIO_WritePin>
}
 8003340:	46c0      	nop			; (mov r8, r8)
 8003342:	46bd      	mov	sp, r7
 8003344:	b002      	add	sp, #8
 8003346:	bd80      	pop	{r7, pc}
 8003348:	20000000 	.word	0x20000000
 800334c:	0801ebc4 	.word	0x0801ebc4

08003350 <BSP_LED_Off>:
  *   This parameter can be one of following parameters:
  *            @arg  LED2
  * @retval None
  */
void BSP_LED_Off(Led_TypeDef Led)
{
 8003350:	b580      	push	{r7, lr}
 8003352:	b082      	sub	sp, #8
 8003354:	af00      	add	r7, sp, #0
 8003356:	0002      	movs	r2, r0
 8003358:	1dfb      	adds	r3, r7, #7
 800335a:	701a      	strb	r2, [r3, #0]
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
 800335c:	1dfb      	adds	r3, r7, #7
 800335e:	781a      	ldrb	r2, [r3, #0]
 8003360:	4b07      	ldr	r3, [pc, #28]	; (8003380 <BSP_LED_Off+0x30>)
 8003362:	0092      	lsls	r2, r2, #2
 8003364:	58d0      	ldr	r0, [r2, r3]
 8003366:	1dfb      	adds	r3, r7, #7
 8003368:	781a      	ldrb	r2, [r3, #0]
 800336a:	4b06      	ldr	r3, [pc, #24]	; (8003384 <BSP_LED_Off+0x34>)
 800336c:	0052      	lsls	r2, r2, #1
 800336e:	5ad3      	ldrh	r3, [r2, r3]
 8003370:	2200      	movs	r2, #0
 8003372:	0019      	movs	r1, r3
 8003374:	f006 ff54 	bl	800a220 <HAL_GPIO_WritePin>
}
 8003378:	46c0      	nop			; (mov r8, r8)
 800337a:	46bd      	mov	sp, r7
 800337c:	b002      	add	sp, #8
 800337e:	bd80      	pop	{r7, pc}
 8003380:	20000000 	.word	0x20000000
 8003384:	0801ebc4 	.word	0x0801ebc4

08003388 <SX1276GetWakeTime>:
    SX1276SetPublicNetwork,
    SX1276GetWakeupTime
};

uint32_t SX1276GetWakeTime( void )
{
 8003388:	b580      	push	{r7, lr}
 800338a:	af00      	add	r7, sp, #0
  return  BOARD_WAKEUP_TIME;
 800338c:	2305      	movs	r3, #5
}
 800338e:	0018      	movs	r0, r3
 8003390:	46bd      	mov	sp, r7
 8003392:	bd80      	pop	{r7, pc}

08003394 <SX1276SetXO>:

void SX1276SetXO( uint8_t state )
{
 8003394:	b580      	push	{r7, lr}
 8003396:	b082      	sub	sp, #8
 8003398:	af00      	add	r7, sp, #0
 800339a:	0002      	movs	r2, r0
 800339c:	1dfb      	adds	r3, r7, #7
 800339e:	701a      	strb	r2, [r3, #0]

  if (state == SET )
 80033a0:	1dfb      	adds	r3, r7, #7
 80033a2:	781b      	ldrb	r3, [r3, #0]
 80033a4:	2b01      	cmp	r3, #1
 80033a6:	d10b      	bne.n	80033c0 <SX1276SetXO+0x2c>
  {
    TCXO_ON(); 
 80033a8:	2380      	movs	r3, #128	; 0x80
 80033aa:	00d9      	lsls	r1, r3, #3
 80033ac:	23a0      	movs	r3, #160	; 0xa0
 80033ae:	05db      	lsls	r3, r3, #23
 80033b0:	2201      	movs	r2, #1
 80033b2:	0018      	movs	r0, r3
 80033b4:	f018 fac8 	bl	801b948 <HW_GPIO_Write>
    
    DelayMs( BOARD_WAKEUP_TIME ); //start up time of TCXO
 80033b8:	2005      	movs	r0, #5
 80033ba:	f019 fb6d 	bl	801ca98 <HAL_Delay>
  }
  else
  {
    TCXO_OFF(); 
  }
}
 80033be:	e007      	b.n	80033d0 <SX1276SetXO+0x3c>
    TCXO_OFF(); 
 80033c0:	2380      	movs	r3, #128	; 0x80
 80033c2:	00d9      	lsls	r1, r3, #3
 80033c4:	23a0      	movs	r3, #160	; 0xa0
 80033c6:	05db      	lsls	r3, r3, #23
 80033c8:	2200      	movs	r2, #0
 80033ca:	0018      	movs	r0, r3
 80033cc:	f018 fabc 	bl	801b948 <HW_GPIO_Write>
}
 80033d0:	46c0      	nop			; (mov r8, r8)
 80033d2:	46bd      	mov	sp, r7
 80033d4:	b002      	add	sp, #8
 80033d6:	bd80      	pop	{r7, pc}

080033d8 <SX1276IoInit>:
void SX1276IoInit( void )
{
 80033d8:	b580      	push	{r7, lr}
 80033da:	b086      	sub	sp, #24
 80033dc:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef initStruct={0};
 80033de:	1d3b      	adds	r3, r7, #4
 80033e0:	0018      	movs	r0, r3
 80033e2:	2314      	movs	r3, #20
 80033e4:	001a      	movs	r2, r3
 80033e6:	2100      	movs	r1, #0
 80033e8:	f01a f8b4 	bl	801d554 <memset>
  
  SX1276BoardInit( &BoardCallbacks );
 80033ec:	4b1b      	ldr	r3, [pc, #108]	; (800345c <SX1276IoInit+0x84>)
 80033ee:	0018      	movs	r0, r3
 80033f0:	f002 fe02 	bl	8005ff8 <SX1276BoardInit>
  
  initStruct.Mode =GPIO_MODE_IT_RISING;
 80033f4:	1d3b      	adds	r3, r7, #4
 80033f6:	4a1a      	ldr	r2, [pc, #104]	; (8003460 <SX1276IoInit+0x88>)
 80033f8:	605a      	str	r2, [r3, #4]
  initStruct.Pull = GPIO_PULLDOWN;
 80033fa:	1d3b      	adds	r3, r7, #4
 80033fc:	2202      	movs	r2, #2
 80033fe:	609a      	str	r2, [r3, #8]
  initStruct.Speed = GPIO_SPEED_HIGH;
 8003400:	1d3b      	adds	r3, r7, #4
 8003402:	2203      	movs	r2, #3
 8003404:	60da      	str	r2, [r3, #12]

  HW_GPIO_Init( RADIO_DIO_0_PORT, RADIO_DIO_0_PIN, &initStruct );
 8003406:	1d3b      	adds	r3, r7, #4
 8003408:	4816      	ldr	r0, [pc, #88]	; (8003464 <SX1276IoInit+0x8c>)
 800340a:	001a      	movs	r2, r3
 800340c:	2110      	movs	r1, #16
 800340e:	f018 f9c9 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Init( RADIO_DIO_1_PORT, RADIO_DIO_1_PIN, &initStruct );
 8003412:	1d3b      	adds	r3, r7, #4
 8003414:	4813      	ldr	r0, [pc, #76]	; (8003464 <SX1276IoInit+0x8c>)
 8003416:	001a      	movs	r2, r3
 8003418:	2102      	movs	r1, #2
 800341a:	f018 f9c3 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Init( RADIO_DIO_2_PORT, RADIO_DIO_2_PIN, &initStruct );
 800341e:	1d3b      	adds	r3, r7, #4
 8003420:	4810      	ldr	r0, [pc, #64]	; (8003464 <SX1276IoInit+0x8c>)
 8003422:	001a      	movs	r2, r3
 8003424:	2101      	movs	r1, #1
 8003426:	f018 f9bd 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Init( RADIO_DIO_3_PORT, RADIO_DIO_3_PIN, &initStruct );
 800342a:	1d3a      	adds	r2, r7, #4
 800342c:	2380      	movs	r3, #128	; 0x80
 800342e:	019b      	lsls	r3, r3, #6
 8003430:	480d      	ldr	r0, [pc, #52]	; (8003468 <SX1276IoInit+0x90>)
 8003432:	0019      	movs	r1, r3
 8003434:	f018 f9b6 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Init( RADIO_DIO_4_PORT, RADIO_DIO_4_PIN, &initStruct );
#endif
#ifdef RADIO_DIO_5
  HW_GPIO_Init( RADIO_DIO_5_PORT, RADIO_DIO_5_PIN, &initStruct );
#endif
  initStruct.Mode =GPIO_MODE_OUTPUT_PP;
 8003438:	1d3b      	adds	r3, r7, #4
 800343a:	2201      	movs	r2, #1
 800343c:	605a      	str	r2, [r3, #4]
  initStruct.Pull = GPIO_NOPULL;  
 800343e:	1d3b      	adds	r3, r7, #4
 8003440:	2200      	movs	r2, #0
 8003442:	609a      	str	r2, [r3, #8]
  HW_GPIO_Init( RADIO_TCXO_VCC_PORT, RADIO_TCXO_VCC_PIN, &initStruct );
 8003444:	1d3a      	adds	r2, r7, #4
 8003446:	2380      	movs	r3, #128	; 0x80
 8003448:	00d9      	lsls	r1, r3, #3
 800344a:	23a0      	movs	r3, #160	; 0xa0
 800344c:	05db      	lsls	r3, r3, #23
 800344e:	0018      	movs	r0, r3
 8003450:	f018 f9a8 	bl	801b7a4 <HW_GPIO_Init>
}
 8003454:	46c0      	nop			; (mov r8, r8)
 8003456:	46bd      	mov	sp, r7
 8003458:	b006      	add	sp, #24
 800345a:	bd80      	pop	{r7, pc}
 800345c:	2000000c 	.word	0x2000000c
 8003460:	10110000 	.word	0x10110000
 8003464:	50000400 	.word	0x50000400
 8003468:	50000800 	.word	0x50000800

0800346c <SX1276IoIrqInit>:

void SX1276IoIrqInit( DioIrqHandler **irqHandlers )
{
 800346c:	b580      	push	{r7, lr}
 800346e:	b082      	sub	sp, #8
 8003470:	af00      	add	r7, sp, #0
 8003472:	6078      	str	r0, [r7, #4]
  HW_GPIO_SetIrq( RADIO_DIO_0_PORT, RADIO_DIO_0_PIN, IRQ_HIGH_PRIORITY, irqHandlers[0] );
 8003474:	687b      	ldr	r3, [r7, #4]
 8003476:	681b      	ldr	r3, [r3, #0]
 8003478:	4810      	ldr	r0, [pc, #64]	; (80034bc <SX1276IoIrqInit+0x50>)
 800347a:	2200      	movs	r2, #0
 800347c:	2110      	movs	r1, #16
 800347e:	f018 fa07 	bl	801b890 <HW_GPIO_SetIrq>
  HW_GPIO_SetIrq( RADIO_DIO_1_PORT, RADIO_DIO_1_PIN, IRQ_HIGH_PRIORITY, irqHandlers[1] );
 8003482:	687b      	ldr	r3, [r7, #4]
 8003484:	3304      	adds	r3, #4
 8003486:	681b      	ldr	r3, [r3, #0]
 8003488:	480c      	ldr	r0, [pc, #48]	; (80034bc <SX1276IoIrqInit+0x50>)
 800348a:	2200      	movs	r2, #0
 800348c:	2102      	movs	r1, #2
 800348e:	f018 f9ff 	bl	801b890 <HW_GPIO_SetIrq>
  HW_GPIO_SetIrq( RADIO_DIO_2_PORT, RADIO_DIO_2_PIN, IRQ_HIGH_PRIORITY, irqHandlers[2] );
 8003492:	687b      	ldr	r3, [r7, #4]
 8003494:	3308      	adds	r3, #8
 8003496:	681b      	ldr	r3, [r3, #0]
 8003498:	4808      	ldr	r0, [pc, #32]	; (80034bc <SX1276IoIrqInit+0x50>)
 800349a:	2200      	movs	r2, #0
 800349c:	2101      	movs	r1, #1
 800349e:	f018 f9f7 	bl	801b890 <HW_GPIO_SetIrq>
  HW_GPIO_SetIrq( RADIO_DIO_3_PORT, RADIO_DIO_3_PIN, IRQ_HIGH_PRIORITY, irqHandlers[3] );
 80034a2:	687b      	ldr	r3, [r7, #4]
 80034a4:	330c      	adds	r3, #12
 80034a6:	681b      	ldr	r3, [r3, #0]
 80034a8:	2280      	movs	r2, #128	; 0x80
 80034aa:	0191      	lsls	r1, r2, #6
 80034ac:	4804      	ldr	r0, [pc, #16]	; (80034c0 <SX1276IoIrqInit+0x54>)
 80034ae:	2200      	movs	r2, #0
 80034b0:	f018 f9ee 	bl	801b890 <HW_GPIO_SetIrq>
}
 80034b4:	46c0      	nop			; (mov r8, r8)
 80034b6:	46bd      	mov	sp, r7
 80034b8:	b002      	add	sp, #8
 80034ba:	bd80      	pop	{r7, pc}
 80034bc:	50000400 	.word	0x50000400
 80034c0:	50000800 	.word	0x50000800

080034c4 <SX1276IoDeInit>:

void SX1276IoDeInit( void )
{
 80034c4:	b580      	push	{r7, lr}
 80034c6:	b086      	sub	sp, #24
 80034c8:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef initStruct={0};
 80034ca:	1d3b      	adds	r3, r7, #4
 80034cc:	0018      	movs	r0, r3
 80034ce:	2314      	movs	r3, #20
 80034d0:	001a      	movs	r2, r3
 80034d2:	2100      	movs	r1, #0
 80034d4:	f01a f83e 	bl	801d554 <memset>

  initStruct.Mode = GPIO_MODE_IT_RISING ; //GPIO_MODE_ANALOG;
 80034d8:	1d3b      	adds	r3, r7, #4
 80034da:	4a11      	ldr	r2, [pc, #68]	; (8003520 <SX1276IoDeInit+0x5c>)
 80034dc:	605a      	str	r2, [r3, #4]
  initStruct.Pull = GPIO_PULLDOWN;
 80034de:	1d3b      	adds	r3, r7, #4
 80034e0:	2202      	movs	r2, #2
 80034e2:	609a      	str	r2, [r3, #8]
  
  HW_GPIO_Init( RADIO_DIO_0_PORT, RADIO_DIO_0_PIN, &initStruct );
 80034e4:	1d3b      	adds	r3, r7, #4
 80034e6:	480f      	ldr	r0, [pc, #60]	; (8003524 <SX1276IoDeInit+0x60>)
 80034e8:	001a      	movs	r2, r3
 80034ea:	2110      	movs	r1, #16
 80034ec:	f018 f95a 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Init( RADIO_DIO_1_PORT, RADIO_DIO_1_PIN, &initStruct );
 80034f0:	1d3b      	adds	r3, r7, #4
 80034f2:	480c      	ldr	r0, [pc, #48]	; (8003524 <SX1276IoDeInit+0x60>)
 80034f4:	001a      	movs	r2, r3
 80034f6:	2102      	movs	r1, #2
 80034f8:	f018 f954 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Init( RADIO_DIO_2_PORT, RADIO_DIO_2_PIN, &initStruct );
 80034fc:	1d3b      	adds	r3, r7, #4
 80034fe:	4809      	ldr	r0, [pc, #36]	; (8003524 <SX1276IoDeInit+0x60>)
 8003500:	001a      	movs	r2, r3
 8003502:	2101      	movs	r1, #1
 8003504:	f018 f94e 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Init( RADIO_DIO_3_PORT, RADIO_DIO_3_PIN, &initStruct );
 8003508:	1d3a      	adds	r2, r7, #4
 800350a:	2380      	movs	r3, #128	; 0x80
 800350c:	019b      	lsls	r3, r3, #6
 800350e:	4806      	ldr	r0, [pc, #24]	; (8003528 <SX1276IoDeInit+0x64>)
 8003510:	0019      	movs	r1, r3
 8003512:	f018 f947 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Init( RADIO_DIO_4_PORT, RADIO_DIO_4_PIN, &initStruct );
#endif
#ifdef RADIO_DIO_5
  HW_GPIO_Init( RADIO_DIO_5_PORT, RADIO_DIO_5_PIN, &initStruct );
#endif
}
 8003516:	46c0      	nop			; (mov r8, r8)
 8003518:	46bd      	mov	sp, r7
 800351a:	b006      	add	sp, #24
 800351c:	bd80      	pop	{r7, pc}
 800351e:	46c0      	nop			; (mov r8, r8)
 8003520:	10110000 	.word	0x10110000
 8003524:	50000400 	.word	0x50000400
 8003528:	50000800 	.word	0x50000800

0800352c <SX1276SetRfTxPower>:

void SX1276SetRfTxPower( int8_t power )
{
 800352c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800352e:	b085      	sub	sp, #20
 8003530:	af00      	add	r7, sp, #0
 8003532:	0002      	movs	r2, r0
 8003534:	1dfb      	adds	r3, r7, #7
 8003536:	701a      	strb	r2, [r3, #0]
    uint8_t paConfig = 0;
 8003538:	250f      	movs	r5, #15
 800353a:	197b      	adds	r3, r7, r5
 800353c:	2200      	movs	r2, #0
 800353e:	701a      	strb	r2, [r3, #0]
    uint8_t paDac = 0;
 8003540:	260e      	movs	r6, #14
 8003542:	19bb      	adds	r3, r7, r6
 8003544:	2200      	movs	r2, #0
 8003546:	701a      	strb	r2, [r3, #0]

    paConfig = SX1276Read( REG_PACONFIG );
 8003548:	197c      	adds	r4, r7, r5
 800354a:	2009      	movs	r0, #9
 800354c:	f004 faa4 	bl	8007a98 <SX1276Read>
 8003550:	0003      	movs	r3, r0
 8003552:	7023      	strb	r3, [r4, #0]
    paDac = SX1276Read( REG_PADAC );
 8003554:	19bc      	adds	r4, r7, r6
 8003556:	204d      	movs	r0, #77	; 0x4d
 8003558:	f004 fa9e 	bl	8007a98 <SX1276Read>
 800355c:	0003      	movs	r3, r0
 800355e:	7023      	strb	r3, [r4, #0]

    paConfig = ( paConfig & RF_PACONFIG_PASELECT_MASK ) | SX1276GetPaSelect( power );
 8003560:	197b      	adds	r3, r7, r5
 8003562:	781b      	ldrb	r3, [r3, #0]
 8003564:	b25b      	sxtb	r3, r3
 8003566:	227f      	movs	r2, #127	; 0x7f
 8003568:	4013      	ands	r3, r2
 800356a:	b25c      	sxtb	r4, r3
 800356c:	1dfb      	adds	r3, r7, #7
 800356e:	781b      	ldrb	r3, [r3, #0]
 8003570:	b25b      	sxtb	r3, r3
 8003572:	0018      	movs	r0, r3
 8003574:	f000 f8ba 	bl	80036ec <SX1276GetPaSelect>
 8003578:	0003      	movs	r3, r0
 800357a:	b25b      	sxtb	r3, r3
 800357c:	4323      	orrs	r3, r4
 800357e:	b25a      	sxtb	r2, r3
 8003580:	197b      	adds	r3, r7, r5
 8003582:	701a      	strb	r2, [r3, #0]

    if( ( paConfig & RF_PACONFIG_PASELECT_PABOOST ) == RF_PACONFIG_PASELECT_PABOOST )
 8003584:	197b      	adds	r3, r7, r5
 8003586:	781b      	ldrb	r3, [r3, #0]
 8003588:	b25b      	sxtb	r3, r3
 800358a:	2b00      	cmp	r3, #0
 800358c:	da66      	bge.n	800365c <SX1276SetRfTxPower+0x130>
    {
        if( power > 17 )
 800358e:	1dfb      	adds	r3, r7, #7
 8003590:	781b      	ldrb	r3, [r3, #0]
 8003592:	b25b      	sxtb	r3, r3
 8003594:	2b11      	cmp	r3, #17
 8003596:	dd06      	ble.n	80035a6 <SX1276SetRfTxPower+0x7a>
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_ON;
 8003598:	19bb      	adds	r3, r7, r6
 800359a:	19ba      	adds	r2, r7, r6
 800359c:	7812      	ldrb	r2, [r2, #0]
 800359e:	2107      	movs	r1, #7
 80035a0:	430a      	orrs	r2, r1
 80035a2:	701a      	strb	r2, [r3, #0]
 80035a4:	e00b      	b.n	80035be <SX1276SetRfTxPower+0x92>
        }
        else
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_OFF;
 80035a6:	210e      	movs	r1, #14
 80035a8:	187b      	adds	r3, r7, r1
 80035aa:	781b      	ldrb	r3, [r3, #0]
 80035ac:	b25b      	sxtb	r3, r3
 80035ae:	2207      	movs	r2, #7
 80035b0:	4393      	bics	r3, r2
 80035b2:	b25b      	sxtb	r3, r3
 80035b4:	2204      	movs	r2, #4
 80035b6:	4313      	orrs	r3, r2
 80035b8:	b25a      	sxtb	r2, r3
 80035ba:	187b      	adds	r3, r7, r1
 80035bc:	701a      	strb	r2, [r3, #0]
        }
        if( ( paDac & RF_PADAC_20DBM_ON ) == RF_PADAC_20DBM_ON )
 80035be:	230e      	movs	r3, #14
 80035c0:	18fb      	adds	r3, r7, r3
 80035c2:	781b      	ldrb	r3, [r3, #0]
 80035c4:	2207      	movs	r2, #7
 80035c6:	4013      	ands	r3, r2
 80035c8:	2b07      	cmp	r3, #7
 80035ca:	d123      	bne.n	8003614 <SX1276SetRfTxPower+0xe8>
        {
            if( power < 5 )
 80035cc:	1dfb      	adds	r3, r7, #7
 80035ce:	781b      	ldrb	r3, [r3, #0]
 80035d0:	b25b      	sxtb	r3, r3
 80035d2:	2b04      	cmp	r3, #4
 80035d4:	dc02      	bgt.n	80035dc <SX1276SetRfTxPower+0xb0>
            {
                power = 5;
 80035d6:	1dfb      	adds	r3, r7, #7
 80035d8:	2205      	movs	r2, #5
 80035da:	701a      	strb	r2, [r3, #0]
            }
            if( power > 20 )
 80035dc:	1dfb      	adds	r3, r7, #7
 80035de:	781b      	ldrb	r3, [r3, #0]
 80035e0:	b25b      	sxtb	r3, r3
 80035e2:	2b14      	cmp	r3, #20
 80035e4:	dd02      	ble.n	80035ec <SX1276SetRfTxPower+0xc0>
            {
                power = 20;
 80035e6:	1dfb      	adds	r3, r7, #7
 80035e8:	2214      	movs	r2, #20
 80035ea:	701a      	strb	r2, [r3, #0]
            }
            paConfig = ( paConfig & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( uint8_t )( ( uint16_t )( power - 5 ) & 0x0F );
 80035ec:	200f      	movs	r0, #15
 80035ee:	183b      	adds	r3, r7, r0
 80035f0:	781b      	ldrb	r3, [r3, #0]
 80035f2:	b25b      	sxtb	r3, r3
 80035f4:	220f      	movs	r2, #15
 80035f6:	4393      	bics	r3, r2
 80035f8:	b25a      	sxtb	r2, r3
 80035fa:	1dfb      	adds	r3, r7, #7
 80035fc:	781b      	ldrb	r3, [r3, #0]
 80035fe:	3b05      	subs	r3, #5
 8003600:	b2db      	uxtb	r3, r3
 8003602:	b25b      	sxtb	r3, r3
 8003604:	210f      	movs	r1, #15
 8003606:	400b      	ands	r3, r1
 8003608:	b25b      	sxtb	r3, r3
 800360a:	4313      	orrs	r3, r2
 800360c:	b25a      	sxtb	r2, r3
 800360e:	183b      	adds	r3, r7, r0
 8003610:	701a      	strb	r2, [r3, #0]
 8003612:	e059      	b.n	80036c8 <SX1276SetRfTxPower+0x19c>
        }
        else
        {
            if( power < 2 )
 8003614:	1dfb      	adds	r3, r7, #7
 8003616:	781b      	ldrb	r3, [r3, #0]
 8003618:	b25b      	sxtb	r3, r3
 800361a:	2b01      	cmp	r3, #1
 800361c:	dc02      	bgt.n	8003624 <SX1276SetRfTxPower+0xf8>
            {
                power = 2;
 800361e:	1dfb      	adds	r3, r7, #7
 8003620:	2202      	movs	r2, #2
 8003622:	701a      	strb	r2, [r3, #0]
            }
            if( power > 17 )
 8003624:	1dfb      	adds	r3, r7, #7
 8003626:	781b      	ldrb	r3, [r3, #0]
 8003628:	b25b      	sxtb	r3, r3
 800362a:	2b11      	cmp	r3, #17
 800362c:	dd02      	ble.n	8003634 <SX1276SetRfTxPower+0x108>
            {
                power = 17;
 800362e:	1dfb      	adds	r3, r7, #7
 8003630:	2211      	movs	r2, #17
 8003632:	701a      	strb	r2, [r3, #0]
            }
            paConfig = ( paConfig & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( uint8_t )( ( uint16_t )( power - 2 ) & 0x0F );
 8003634:	200f      	movs	r0, #15
 8003636:	183b      	adds	r3, r7, r0
 8003638:	781b      	ldrb	r3, [r3, #0]
 800363a:	b25b      	sxtb	r3, r3
 800363c:	220f      	movs	r2, #15
 800363e:	4393      	bics	r3, r2
 8003640:	b25a      	sxtb	r2, r3
 8003642:	1dfb      	adds	r3, r7, #7
 8003644:	781b      	ldrb	r3, [r3, #0]
 8003646:	3b02      	subs	r3, #2
 8003648:	b2db      	uxtb	r3, r3
 800364a:	b25b      	sxtb	r3, r3
 800364c:	210f      	movs	r1, #15
 800364e:	400b      	ands	r3, r1
 8003650:	b25b      	sxtb	r3, r3
 8003652:	4313      	orrs	r3, r2
 8003654:	b25a      	sxtb	r2, r3
 8003656:	183b      	adds	r3, r7, r0
 8003658:	701a      	strb	r2, [r3, #0]
 800365a:	e035      	b.n	80036c8 <SX1276SetRfTxPower+0x19c>
        }
    }
    else
    {
        if( power > 0 )
 800365c:	1dfb      	adds	r3, r7, #7
 800365e:	781b      	ldrb	r3, [r3, #0]
 8003660:	b25b      	sxtb	r3, r3
 8003662:	2b00      	cmp	r3, #0
 8003664:	dd18      	ble.n	8003698 <SX1276SetRfTxPower+0x16c>
        {
            if( power > 15 )
 8003666:	1dfb      	adds	r3, r7, #7
 8003668:	781b      	ldrb	r3, [r3, #0]
 800366a:	b25b      	sxtb	r3, r3
 800366c:	2b0f      	cmp	r3, #15
 800366e:	dd02      	ble.n	8003676 <SX1276SetRfTxPower+0x14a>
            {
                power = 15;
 8003670:	1dfb      	adds	r3, r7, #7
 8003672:	220f      	movs	r2, #15
 8003674:	701a      	strb	r2, [r3, #0]
            }
            paConfig = ( paConfig & RF_PACONFIG_MAX_POWER_MASK & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( 7 << 4 ) | ( power );
 8003676:	210f      	movs	r1, #15
 8003678:	187b      	adds	r3, r7, r1
 800367a:	781b      	ldrb	r3, [r3, #0]
 800367c:	b25b      	sxtb	r3, r3
 800367e:	227f      	movs	r2, #127	; 0x7f
 8003680:	4393      	bics	r3, r2
 8003682:	b25b      	sxtb	r3, r3
 8003684:	2270      	movs	r2, #112	; 0x70
 8003686:	4313      	orrs	r3, r2
 8003688:	b25a      	sxtb	r2, r3
 800368a:	1dfb      	adds	r3, r7, #7
 800368c:	781b      	ldrb	r3, [r3, #0]
 800368e:	4313      	orrs	r3, r2
 8003690:	b25a      	sxtb	r2, r3
 8003692:	187b      	adds	r3, r7, r1
 8003694:	701a      	strb	r2, [r3, #0]
 8003696:	e017      	b.n	80036c8 <SX1276SetRfTxPower+0x19c>
        }
        else
        {
            if( power < -4 )
 8003698:	1dfb      	adds	r3, r7, #7
 800369a:	781b      	ldrb	r3, [r3, #0]
 800369c:	b25b      	sxtb	r3, r3
 800369e:	3304      	adds	r3, #4
 80036a0:	da02      	bge.n	80036a8 <SX1276SetRfTxPower+0x17c>
            {
                power = -4;
 80036a2:	1dfb      	adds	r3, r7, #7
 80036a4:	22fc      	movs	r2, #252	; 0xfc
 80036a6:	701a      	strb	r2, [r3, #0]
            }
            paConfig = ( paConfig & RF_PACONFIG_MAX_POWER_MASK & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( 0 << 4 ) | ( power + 4 );
 80036a8:	210f      	movs	r1, #15
 80036aa:	187b      	adds	r3, r7, r1
 80036ac:	781b      	ldrb	r3, [r3, #0]
 80036ae:	b25b      	sxtb	r3, r3
 80036b0:	227f      	movs	r2, #127	; 0x7f
 80036b2:	4393      	bics	r3, r2
 80036b4:	b25a      	sxtb	r2, r3
 80036b6:	1dfb      	adds	r3, r7, #7
 80036b8:	781b      	ldrb	r3, [r3, #0]
 80036ba:	3304      	adds	r3, #4
 80036bc:	b2db      	uxtb	r3, r3
 80036be:	b25b      	sxtb	r3, r3
 80036c0:	4313      	orrs	r3, r2
 80036c2:	b25a      	sxtb	r2, r3
 80036c4:	187b      	adds	r3, r7, r1
 80036c6:	701a      	strb	r2, [r3, #0]
        }
    }
    SX1276Write( REG_PACONFIG, paConfig );
 80036c8:	230f      	movs	r3, #15
 80036ca:	18fb      	adds	r3, r7, r3
 80036cc:	781b      	ldrb	r3, [r3, #0]
 80036ce:	0019      	movs	r1, r3
 80036d0:	2009      	movs	r0, #9
 80036d2:	f004 f9cd 	bl	8007a70 <SX1276Write>
    SX1276Write( REG_PADAC, paDac );
 80036d6:	230e      	movs	r3, #14
 80036d8:	18fb      	adds	r3, r7, r3
 80036da:	781b      	ldrb	r3, [r3, #0]
 80036dc:	0019      	movs	r1, r3
 80036de:	204d      	movs	r0, #77	; 0x4d
 80036e0:	f004 f9c6 	bl	8007a70 <SX1276Write>
}
 80036e4:	46c0      	nop			; (mov r8, r8)
 80036e6:	46bd      	mov	sp, r7
 80036e8:	b005      	add	sp, #20
 80036ea:	bdf0      	pop	{r4, r5, r6, r7, pc}

080036ec <SX1276GetPaSelect>:

uint8_t SX1276GetPaSelect( int8_t power )
{
 80036ec:	b580      	push	{r7, lr}
 80036ee:	b082      	sub	sp, #8
 80036f0:	af00      	add	r7, sp, #0
 80036f2:	0002      	movs	r2, r0
 80036f4:	1dfb      	adds	r3, r7, #7
 80036f6:	701a      	strb	r2, [r3, #0]
    if (power >14)
 80036f8:	1dfb      	adds	r3, r7, #7
 80036fa:	781b      	ldrb	r3, [r3, #0]
 80036fc:	b25b      	sxtb	r3, r3
 80036fe:	2b0e      	cmp	r3, #14
 8003700:	dd01      	ble.n	8003706 <SX1276GetPaSelect+0x1a>
    {
        return RF_PACONFIG_PASELECT_PABOOST;
 8003702:	2380      	movs	r3, #128	; 0x80
 8003704:	e000      	b.n	8003708 <SX1276GetPaSelect+0x1c>
    }
    else
    {
        return RF_PACONFIG_PASELECT_RFO;
 8003706:	2300      	movs	r3, #0
    }
}
 8003708:	0018      	movs	r0, r3
 800370a:	46bd      	mov	sp, r7
 800370c:	b002      	add	sp, #8
 800370e:	bd80      	pop	{r7, pc}

08003710 <SX1276SetAntSwLowPower>:

void SX1276SetAntSwLowPower( bool status )
{
 8003710:	b580      	push	{r7, lr}
 8003712:	b082      	sub	sp, #8
 8003714:	af00      	add	r7, sp, #0
 8003716:	0002      	movs	r2, r0
 8003718:	1dfb      	adds	r3, r7, #7
 800371a:	701a      	strb	r2, [r3, #0]
    if( status == false )
 800371c:	1dfb      	adds	r3, r7, #7
 800371e:	781b      	ldrb	r3, [r3, #0]
 8003720:	2201      	movs	r2, #1
 8003722:	4053      	eors	r3, r2
 8003724:	b2db      	uxtb	r3, r3
 8003726:	2b00      	cmp	r3, #0
 8003728:	d002      	beq.n	8003730 <SX1276SetAntSwLowPower+0x20>
    {
      SX1276AntSwInit( );
 800372a:	f000 f807 	bl	800373c <SX1276AntSwInit>
    }
    else 
    {
      SX1276AntSwDeInit( );
    }
}
 800372e:	e001      	b.n	8003734 <SX1276SetAntSwLowPower+0x24>
      SX1276AntSwDeInit( );
 8003730:	f000 f844 	bl	80037bc <SX1276AntSwDeInit>
}
 8003734:	46c0      	nop			; (mov r8, r8)
 8003736:	46bd      	mov	sp, r7
 8003738:	b002      	add	sp, #8
 800373a:	bd80      	pop	{r7, pc}

0800373c <SX1276AntSwInit>:

static void SX1276AntSwInit( void )
{
 800373c:	b580      	push	{r7, lr}
 800373e:	b086      	sub	sp, #24
 8003740:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef initStruct={0};
 8003742:	1d3b      	adds	r3, r7, #4
 8003744:	0018      	movs	r0, r3
 8003746:	2314      	movs	r3, #20
 8003748:	001a      	movs	r2, r3
 800374a:	2100      	movs	r1, #0
 800374c:	f019 ff02 	bl	801d554 <memset>

  initStruct.Mode =GPIO_MODE_OUTPUT_PP;
 8003750:	1d3b      	adds	r3, r7, #4
 8003752:	2201      	movs	r2, #1
 8003754:	605a      	str	r2, [r3, #4]
  initStruct.Pull = GPIO_NOPULL; 
 8003756:	1d3b      	adds	r3, r7, #4
 8003758:	2200      	movs	r2, #0
 800375a:	609a      	str	r2, [r3, #8]
  initStruct.Speed = GPIO_SPEED_HIGH;
 800375c:	1d3b      	adds	r3, r7, #4
 800375e:	2203      	movs	r2, #3
 8003760:	60da      	str	r2, [r3, #12]
  
  HW_GPIO_Init( RADIO_ANT_SWITCH_PORT_RX, RADIO_ANT_SWITCH_PIN_RX, &initStruct  ); 
 8003762:	1d3a      	adds	r2, r7, #4
 8003764:	23a0      	movs	r3, #160	; 0xa0
 8003766:	05db      	lsls	r3, r3, #23
 8003768:	2102      	movs	r1, #2
 800376a:	0018      	movs	r0, r3
 800376c:	f018 f81a 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Write( RADIO_ANT_SWITCH_PORT_RX, RADIO_ANT_SWITCH_PIN_RX, 0);
 8003770:	23a0      	movs	r3, #160	; 0xa0
 8003772:	05db      	lsls	r3, r3, #23
 8003774:	2200      	movs	r2, #0
 8003776:	2102      	movs	r1, #2
 8003778:	0018      	movs	r0, r3
 800377a:	f018 f8e5 	bl	801b948 <HW_GPIO_Write>
  
  HW_GPIO_Init( RADIO_ANT_SWITCH_PORT_TX_BOOST, RADIO_ANT_SWITCH_PIN_TX_BOOST, &initStruct  ); 
 800377e:	1d3b      	adds	r3, r7, #4
 8003780:	480d      	ldr	r0, [pc, #52]	; (80037b8 <SX1276AntSwInit+0x7c>)
 8003782:	001a      	movs	r2, r3
 8003784:	2102      	movs	r1, #2
 8003786:	f018 f80d 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Write( RADIO_ANT_SWITCH_PORT_TX_BOOST, RADIO_ANT_SWITCH_PIN_TX_BOOST, 0);
 800378a:	4b0b      	ldr	r3, [pc, #44]	; (80037b8 <SX1276AntSwInit+0x7c>)
 800378c:	2200      	movs	r2, #0
 800378e:	2102      	movs	r1, #2
 8003790:	0018      	movs	r0, r3
 8003792:	f018 f8d9 	bl	801b948 <HW_GPIO_Write>
  
  HW_GPIO_Init( RADIO_ANT_SWITCH_PORT_TX_RFO, RADIO_ANT_SWITCH_PIN_TX_RFO, &initStruct  ); 
 8003796:	1d3b      	adds	r3, r7, #4
 8003798:	4807      	ldr	r0, [pc, #28]	; (80037b8 <SX1276AntSwInit+0x7c>)
 800379a:	001a      	movs	r2, r3
 800379c:	2104      	movs	r1, #4
 800379e:	f018 f801 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Write( RADIO_ANT_SWITCH_PORT_TX_RFO, RADIO_ANT_SWITCH_PIN_TX_RFO, 0);
 80037a2:	4b05      	ldr	r3, [pc, #20]	; (80037b8 <SX1276AntSwInit+0x7c>)
 80037a4:	2200      	movs	r2, #0
 80037a6:	2104      	movs	r1, #4
 80037a8:	0018      	movs	r0, r3
 80037aa:	f018 f8cd 	bl	801b948 <HW_GPIO_Write>
}
 80037ae:	46c0      	nop			; (mov r8, r8)
 80037b0:	46bd      	mov	sp, r7
 80037b2:	b006      	add	sp, #24
 80037b4:	bd80      	pop	{r7, pc}
 80037b6:	46c0      	nop			; (mov r8, r8)
 80037b8:	50000800 	.word	0x50000800

080037bc <SX1276AntSwDeInit>:

static void SX1276AntSwDeInit( void )
{
 80037bc:	b580      	push	{r7, lr}
 80037be:	b086      	sub	sp, #24
 80037c0:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef initStruct={0};
 80037c2:	1d3b      	adds	r3, r7, #4
 80037c4:	0018      	movs	r0, r3
 80037c6:	2314      	movs	r3, #20
 80037c8:	001a      	movs	r2, r3
 80037ca:	2100      	movs	r1, #0
 80037cc:	f019 fec2 	bl	801d554 <memset>

  initStruct.Mode = GPIO_MODE_ANALOG ;
 80037d0:	1d3b      	adds	r3, r7, #4
 80037d2:	2203      	movs	r2, #3
 80037d4:	605a      	str	r2, [r3, #4]
  
  initStruct.Pull = GPIO_NOPULL;
 80037d6:	1d3b      	adds	r3, r7, #4
 80037d8:	2200      	movs	r2, #0
 80037da:	609a      	str	r2, [r3, #8]
  initStruct.Speed = GPIO_SPEED_HIGH;
 80037dc:	1d3b      	adds	r3, r7, #4
 80037de:	2203      	movs	r2, #3
 80037e0:	60da      	str	r2, [r3, #12]

  HW_GPIO_Init( RADIO_ANT_SWITCH_PORT_RX, RADIO_ANT_SWITCH_PIN_RX, &initStruct  ); 
 80037e2:	1d3a      	adds	r2, r7, #4
 80037e4:	23a0      	movs	r3, #160	; 0xa0
 80037e6:	05db      	lsls	r3, r3, #23
 80037e8:	2102      	movs	r1, #2
 80037ea:	0018      	movs	r0, r3
 80037ec:	f017 ffda 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Write( RADIO_ANT_SWITCH_PORT_RX, RADIO_ANT_SWITCH_PIN_RX, 0);
 80037f0:	23a0      	movs	r3, #160	; 0xa0
 80037f2:	05db      	lsls	r3, r3, #23
 80037f4:	2200      	movs	r2, #0
 80037f6:	2102      	movs	r1, #2
 80037f8:	0018      	movs	r0, r3
 80037fa:	f018 f8a5 	bl	801b948 <HW_GPIO_Write>
  
  HW_GPIO_Init( RADIO_ANT_SWITCH_PORT_TX_BOOST, RADIO_ANT_SWITCH_PIN_TX_BOOST, &initStruct  ); 
 80037fe:	1d3b      	adds	r3, r7, #4
 8003800:	480d      	ldr	r0, [pc, #52]	; (8003838 <SX1276AntSwDeInit+0x7c>)
 8003802:	001a      	movs	r2, r3
 8003804:	2102      	movs	r1, #2
 8003806:	f017 ffcd 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Write( RADIO_ANT_SWITCH_PORT_TX_BOOST, RADIO_ANT_SWITCH_PIN_TX_BOOST, 0);
 800380a:	4b0b      	ldr	r3, [pc, #44]	; (8003838 <SX1276AntSwDeInit+0x7c>)
 800380c:	2200      	movs	r2, #0
 800380e:	2102      	movs	r1, #2
 8003810:	0018      	movs	r0, r3
 8003812:	f018 f899 	bl	801b948 <HW_GPIO_Write>
  
  HW_GPIO_Init( RADIO_ANT_SWITCH_PORT_TX_RFO, RADIO_ANT_SWITCH_PIN_TX_RFO, &initStruct  ); 
 8003816:	1d3b      	adds	r3, r7, #4
 8003818:	4807      	ldr	r0, [pc, #28]	; (8003838 <SX1276AntSwDeInit+0x7c>)
 800381a:	001a      	movs	r2, r3
 800381c:	2104      	movs	r1, #4
 800381e:	f017 ffc1 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Write( RADIO_ANT_SWITCH_PORT_TX_RFO, RADIO_ANT_SWITCH_PIN_TX_RFO, 0);
 8003822:	4b05      	ldr	r3, [pc, #20]	; (8003838 <SX1276AntSwDeInit+0x7c>)
 8003824:	2200      	movs	r2, #0
 8003826:	2104      	movs	r1, #4
 8003828:	0018      	movs	r0, r3
 800382a:	f018 f88d 	bl	801b948 <HW_GPIO_Write>
}
 800382e:	46c0      	nop			; (mov r8, r8)
 8003830:	46bd      	mov	sp, r7
 8003832:	b006      	add	sp, #24
 8003834:	bd80      	pop	{r7, pc}
 8003836:	46c0      	nop			; (mov r8, r8)
 8003838:	50000800 	.word	0x50000800

0800383c <SX1276SetAntSw>:

void SX1276SetAntSw( uint8_t opMode )
{
 800383c:	b5b0      	push	{r4, r5, r7, lr}
 800383e:	b084      	sub	sp, #16
 8003840:	af00      	add	r7, sp, #0
 8003842:	0002      	movs	r2, r0
 8003844:	1dfb      	adds	r3, r7, #7
 8003846:	701a      	strb	r2, [r3, #0]
 uint8_t paConfig =  SX1276Read( REG_PACONFIG );
 8003848:	250f      	movs	r5, #15
 800384a:	197c      	adds	r4, r7, r5
 800384c:	2009      	movs	r0, #9
 800384e:	f004 f923 	bl	8007a98 <SX1276Read>
 8003852:	0003      	movs	r3, r0
 8003854:	7023      	strb	r3, [r4, #0]
    switch( opMode )
 8003856:	1dfb      	adds	r3, r7, #7
 8003858:	781b      	ldrb	r3, [r3, #0]
 800385a:	2b03      	cmp	r3, #3
 800385c:	d115      	bne.n	800388a <SX1276SetAntSw+0x4e>
    {
    case RFLR_OPMODE_TRANSMITTER:
      if( ( paConfig & RF_PACONFIG_PASELECT_PABOOST ) == RF_PACONFIG_PASELECT_PABOOST )
 800385e:	197b      	adds	r3, r7, r5
 8003860:	781b      	ldrb	r3, [r3, #0]
 8003862:	b25b      	sxtb	r3, r3
 8003864:	2b00      	cmp	r3, #0
 8003866:	da06      	bge.n	8003876 <SX1276SetAntSw+0x3a>
      {
        HW_GPIO_Write( RADIO_ANT_SWITCH_PORT_TX_BOOST, RADIO_ANT_SWITCH_PIN_TX_BOOST, 1 );
 8003868:	4b0f      	ldr	r3, [pc, #60]	; (80038a8 <SX1276SetAntSw+0x6c>)
 800386a:	2201      	movs	r2, #1
 800386c:	2102      	movs	r1, #2
 800386e:	0018      	movs	r0, r3
 8003870:	f018 f86a 	bl	801b948 <HW_GPIO_Write>
 8003874:	e005      	b.n	8003882 <SX1276SetAntSw+0x46>
      }
      else
      {
        HW_GPIO_Write( RADIO_ANT_SWITCH_PORT_TX_RFO, RADIO_ANT_SWITCH_PIN_TX_RFO, 1 );
 8003876:	4b0c      	ldr	r3, [pc, #48]	; (80038a8 <SX1276SetAntSw+0x6c>)
 8003878:	2201      	movs	r2, #1
 800387a:	2104      	movs	r1, #4
 800387c:	0018      	movs	r0, r3
 800387e:	f018 f863 	bl	801b948 <HW_GPIO_Write>
      }
      SX1276.RxTx = 1;
 8003882:	4b0a      	ldr	r3, [pc, #40]	; (80038ac <SX1276SetAntSw+0x70>)
 8003884:	2201      	movs	r2, #1
 8003886:	701a      	strb	r2, [r3, #0]
        break;
 8003888:	e00a      	b.n	80038a0 <SX1276SetAntSw+0x64>
    case RFLR_OPMODE_RECEIVER:
    case RFLR_OPMODE_RECEIVER_SINGLE:
    case RFLR_OPMODE_CAD:
    default:
     SX1276.RxTx = 0;
 800388a:	4b08      	ldr	r3, [pc, #32]	; (80038ac <SX1276SetAntSw+0x70>)
 800388c:	2200      	movs	r2, #0
 800388e:	701a      	strb	r2, [r3, #0]
     HW_GPIO_Write( RADIO_ANT_SWITCH_PORT_RX, RADIO_ANT_SWITCH_PIN_RX, 1 );
 8003890:	23a0      	movs	r3, #160	; 0xa0
 8003892:	05db      	lsls	r3, r3, #23
 8003894:	2201      	movs	r2, #1
 8003896:	2102      	movs	r1, #2
 8003898:	0018      	movs	r0, r3
 800389a:	f018 f855 	bl	801b948 <HW_GPIO_Write>
     break;
 800389e:	46c0      	nop			; (mov r8, r8)
    }
}
 80038a0:	46c0      	nop			; (mov r8, r8)
 80038a2:	46bd      	mov	sp, r7
 80038a4:	b004      	add	sp, #16
 80038a6:	bdb0      	pop	{r4, r5, r7, pc}
 80038a8:	50000800 	.word	0x50000800
 80038ac:	2000175c 	.word	0x2000175c

080038b0 <SX1276CheckRfFrequency>:

bool SX1276CheckRfFrequency( uint32_t frequency )
{
 80038b0:	b580      	push	{r7, lr}
 80038b2:	b082      	sub	sp, #8
 80038b4:	af00      	add	r7, sp, #0
 80038b6:	6078      	str	r0, [r7, #4]
    // Implement check. Currently all frequencies are supported
    return true;
 80038b8:	2301      	movs	r3, #1
}
 80038ba:	0018      	movs	r0, r3
 80038bc:	46bd      	mov	sp, r7
 80038be:	b002      	add	sp, #8
 80038c0:	bd80      	pop	{r7, pc}

080038c2 <HTS221_ReadReg>:
* Input       : Register Address
* Output      : Data Read
* Return      : None
*******************************************************************************/
HTS221_Error_et HTS221_ReadReg( void *handle, uint8_t RegAddr, uint16_t NumByteToRead, uint8_t *Data )
{
 80038c2:	b590      	push	{r4, r7, lr}
 80038c4:	b085      	sub	sp, #20
 80038c6:	af00      	add	r7, sp, #0
 80038c8:	60f8      	str	r0, [r7, #12]
 80038ca:	0008      	movs	r0, r1
 80038cc:	0011      	movs	r1, r2
 80038ce:	607b      	str	r3, [r7, #4]
 80038d0:	240b      	movs	r4, #11
 80038d2:	193b      	adds	r3, r7, r4
 80038d4:	1c02      	adds	r2, r0, #0
 80038d6:	701a      	strb	r2, [r3, #0]
 80038d8:	2008      	movs	r0, #8
 80038da:	183b      	adds	r3, r7, r0
 80038dc:	1c0a      	adds	r2, r1, #0
 80038de:	801a      	strh	r2, [r3, #0]

  if ( NumByteToRead > 1 ) RegAddr |= 0x80;
 80038e0:	183b      	adds	r3, r7, r0
 80038e2:	881b      	ldrh	r3, [r3, #0]
 80038e4:	2b01      	cmp	r3, #1
 80038e6:	d906      	bls.n	80038f6 <HTS221_ReadReg+0x34>
 80038e8:	193b      	adds	r3, r7, r4
 80038ea:	193a      	adds	r2, r7, r4
 80038ec:	7812      	ldrb	r2, [r2, #0]
 80038ee:	2180      	movs	r1, #128	; 0x80
 80038f0:	4249      	negs	r1, r1
 80038f2:	430a      	orrs	r2, r1
 80038f4:	701a      	strb	r2, [r3, #0]

  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80038f6:	2308      	movs	r3, #8
 80038f8:	18fb      	adds	r3, r7, r3
 80038fa:	881c      	ldrh	r4, [r3, #0]
 80038fc:	687a      	ldr	r2, [r7, #4]
 80038fe:	230b      	movs	r3, #11
 8003900:	18fb      	adds	r3, r7, r3
 8003902:	7819      	ldrb	r1, [r3, #0]
 8003904:	68f8      	ldr	r0, [r7, #12]
 8003906:	0023      	movs	r3, r4
 8003908:	f004 ff2c 	bl	8008764 <Sensor_IO_Read>
 800390c:	1e03      	subs	r3, r0, #0
 800390e:	d001      	beq.n	8003914 <HTS221_ReadReg+0x52>
    return HTS221_ERROR;
 8003910:	2301      	movs	r3, #1
 8003912:	e000      	b.n	8003916 <HTS221_ReadReg+0x54>
  else
    return HTS221_OK;
 8003914:	2300      	movs	r3, #0
}
 8003916:	0018      	movs	r0, r3
 8003918:	46bd      	mov	sp, r7
 800391a:	b005      	add	sp, #20
 800391c:	bd90      	pop	{r4, r7, pc}

0800391e <HTS221_WriteReg>:
* Input       : Register Address, Data to be written
* Output      : None
* Return      : None
*******************************************************************************/
HTS221_Error_et HTS221_WriteReg( void *handle, uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t *Data )
{
 800391e:	b590      	push	{r4, r7, lr}
 8003920:	b085      	sub	sp, #20
 8003922:	af00      	add	r7, sp, #0
 8003924:	60f8      	str	r0, [r7, #12]
 8003926:	0008      	movs	r0, r1
 8003928:	0011      	movs	r1, r2
 800392a:	607b      	str	r3, [r7, #4]
 800392c:	240b      	movs	r4, #11
 800392e:	193b      	adds	r3, r7, r4
 8003930:	1c02      	adds	r2, r0, #0
 8003932:	701a      	strb	r2, [r3, #0]
 8003934:	2008      	movs	r0, #8
 8003936:	183b      	adds	r3, r7, r0
 8003938:	1c0a      	adds	r2, r1, #0
 800393a:	801a      	strh	r2, [r3, #0]

  if ( NumByteToWrite > 1 ) RegAddr |= 0x80;
 800393c:	183b      	adds	r3, r7, r0
 800393e:	881b      	ldrh	r3, [r3, #0]
 8003940:	2b01      	cmp	r3, #1
 8003942:	d906      	bls.n	8003952 <HTS221_WriteReg+0x34>
 8003944:	193b      	adds	r3, r7, r4
 8003946:	193a      	adds	r2, r7, r4
 8003948:	7812      	ldrb	r2, [r2, #0]
 800394a:	2180      	movs	r1, #128	; 0x80
 800394c:	4249      	negs	r1, r1
 800394e:	430a      	orrs	r2, r1
 8003950:	701a      	strb	r2, [r3, #0]

  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8003952:	2308      	movs	r3, #8
 8003954:	18fb      	adds	r3, r7, r3
 8003956:	881c      	ldrh	r4, [r3, #0]
 8003958:	687a      	ldr	r2, [r7, #4]
 800395a:	230b      	movs	r3, #11
 800395c:	18fb      	adds	r3, r7, r3
 800395e:	7819      	ldrb	r1, [r3, #0]
 8003960:	68f8      	ldr	r0, [r7, #12]
 8003962:	0023      	movs	r3, r4
 8003964:	f004 feda 	bl	800871c <Sensor_IO_Write>
 8003968:	1e03      	subs	r3, r0, #0
 800396a:	d001      	beq.n	8003970 <HTS221_WriteReg+0x52>
    return HTS221_ERROR;
 800396c:	2301      	movs	r3, #1
 800396e:	e000      	b.n	8003972 <HTS221_WriteReg+0x54>
  else
    return HTS221_OK;
 8003970:	2300      	movs	r3, #0
}
 8003972:	0018      	movs	r0, r3
 8003974:	46bd      	mov	sp, r7
 8003976:	b005      	add	sp, #20
 8003978:	bd90      	pop	{r4, r7, pc}

0800397a <HTS221_Get_DeviceID>:
* @param  *handle Device handle.
* @param  deviceid pointer to the returned device type ID.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_DeviceID(void *handle, uint8_t* deviceid)
{
 800397a:	b580      	push	{r7, lr}
 800397c:	b082      	sub	sp, #8
 800397e:	af00      	add	r7, sp, #0
 8003980:	6078      	str	r0, [r7, #4]
 8003982:	6039      	str	r1, [r7, #0]
  if(HTS221_ReadReg(handle, HTS221_WHO_AM_I_REG, 1, deviceid))
 8003984:	683b      	ldr	r3, [r7, #0]
 8003986:	6878      	ldr	r0, [r7, #4]
 8003988:	2201      	movs	r2, #1
 800398a:	210f      	movs	r1, #15
 800398c:	f7ff ff99 	bl	80038c2 <HTS221_ReadReg>
 8003990:	1e03      	subs	r3, r0, #0
 8003992:	d001      	beq.n	8003998 <HTS221_Get_DeviceID+0x1e>
    return HTS221_ERROR;
 8003994:	2301      	movs	r3, #1
 8003996:	e000      	b.n	800399a <HTS221_Get_DeviceID+0x20>

  return HTS221_OK;
 8003998:	2300      	movs	r3, #0
}
 800399a:	0018      	movs	r0, r3
 800399c:	46bd      	mov	sp, r7
 800399e:	b002      	add	sp, #8
 80039a0:	bd80      	pop	{r7, pc}
	...

080039a4 <HTS221_Get_Humidity>:
* @param  *handle Device handle.
* @param  Pointer to the returned humidity value that must be divided by 10 to get the value in [%].
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_Humidity(void *handle, uint16_t* value)
{
 80039a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80039a6:	b089      	sub	sp, #36	; 0x24
 80039a8:	af00      	add	r7, sp, #0
 80039aa:	6078      	str	r0, [r7, #4]
 80039ac:	6039      	str	r1, [r7, #0]
  int16_t H0_T0_out, H1_T0_out, H_T_out;
  int16_t H0_rh, H1_rh;
  uint8_t buffer[2];
  float   tmp_f;

  if(HTS221_ReadReg(handle, HTS221_H0_RH_X2, 2, buffer))
 80039ae:	230c      	movs	r3, #12
 80039b0:	18fb      	adds	r3, r7, r3
 80039b2:	6878      	ldr	r0, [r7, #4]
 80039b4:	2202      	movs	r2, #2
 80039b6:	2130      	movs	r1, #48	; 0x30
 80039b8:	f7ff ff83 	bl	80038c2 <HTS221_ReadReg>
 80039bc:	1e03      	subs	r3, r0, #0
 80039be:	d001      	beq.n	80039c4 <HTS221_Get_Humidity+0x20>
    return HTS221_ERROR;
 80039c0:	2301      	movs	r3, #1
 80039c2:	e0ad      	b.n	8003b20 <HTS221_Get_Humidity+0x17c>
  H0_rh = buffer[0] >> 1;
 80039c4:	210c      	movs	r1, #12
 80039c6:	187b      	adds	r3, r7, r1
 80039c8:	781b      	ldrb	r3, [r3, #0]
 80039ca:	085b      	lsrs	r3, r3, #1
 80039cc:	b2da      	uxtb	r2, r3
 80039ce:	231e      	movs	r3, #30
 80039d0:	18fb      	adds	r3, r7, r3
 80039d2:	801a      	strh	r2, [r3, #0]
  H1_rh = buffer[1] >> 1;
 80039d4:	187b      	adds	r3, r7, r1
 80039d6:	785b      	ldrb	r3, [r3, #1]
 80039d8:	085b      	lsrs	r3, r3, #1
 80039da:	b2da      	uxtb	r2, r3
 80039dc:	231c      	movs	r3, #28
 80039de:	18fb      	adds	r3, r7, r3
 80039e0:	801a      	strh	r2, [r3, #0]

  if(HTS221_ReadReg(handle, HTS221_H0_T0_OUT_L, 2, buffer))
 80039e2:	187b      	adds	r3, r7, r1
 80039e4:	6878      	ldr	r0, [r7, #4]
 80039e6:	2202      	movs	r2, #2
 80039e8:	2136      	movs	r1, #54	; 0x36
 80039ea:	f7ff ff6a 	bl	80038c2 <HTS221_ReadReg>
 80039ee:	1e03      	subs	r3, r0, #0
 80039f0:	d001      	beq.n	80039f6 <HTS221_Get_Humidity+0x52>
    return HTS221_ERROR;
 80039f2:	2301      	movs	r3, #1
 80039f4:	e094      	b.n	8003b20 <HTS221_Get_Humidity+0x17c>
  H0_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 80039f6:	200c      	movs	r0, #12
 80039f8:	183b      	adds	r3, r7, r0
 80039fa:	785b      	ldrb	r3, [r3, #1]
 80039fc:	021b      	lsls	r3, r3, #8
 80039fe:	b219      	sxth	r1, r3
 8003a00:	183b      	adds	r3, r7, r0
 8003a02:	781b      	ldrb	r3, [r3, #0]
 8003a04:	b21a      	sxth	r2, r3
 8003a06:	231a      	movs	r3, #26
 8003a08:	18fb      	adds	r3, r7, r3
 8003a0a:	430a      	orrs	r2, r1
 8003a0c:	801a      	strh	r2, [r3, #0]

  if(HTS221_ReadReg(handle, HTS221_H1_T0_OUT_L, 2, buffer))
 8003a0e:	183b      	adds	r3, r7, r0
 8003a10:	6878      	ldr	r0, [r7, #4]
 8003a12:	2202      	movs	r2, #2
 8003a14:	213a      	movs	r1, #58	; 0x3a
 8003a16:	f7ff ff54 	bl	80038c2 <HTS221_ReadReg>
 8003a1a:	1e03      	subs	r3, r0, #0
 8003a1c:	d001      	beq.n	8003a22 <HTS221_Get_Humidity+0x7e>
    return HTS221_ERROR;
 8003a1e:	2301      	movs	r3, #1
 8003a20:	e07e      	b.n	8003b20 <HTS221_Get_Humidity+0x17c>
  H1_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8003a22:	200c      	movs	r0, #12
 8003a24:	183b      	adds	r3, r7, r0
 8003a26:	785b      	ldrb	r3, [r3, #1]
 8003a28:	021b      	lsls	r3, r3, #8
 8003a2a:	b219      	sxth	r1, r3
 8003a2c:	183b      	adds	r3, r7, r0
 8003a2e:	781b      	ldrb	r3, [r3, #0]
 8003a30:	b21a      	sxth	r2, r3
 8003a32:	2318      	movs	r3, #24
 8003a34:	18fb      	adds	r3, r7, r3
 8003a36:	430a      	orrs	r2, r1
 8003a38:	801a      	strh	r2, [r3, #0]

  if(HTS221_ReadReg(handle, HTS221_HR_OUT_L_REG, 2, buffer))
 8003a3a:	183b      	adds	r3, r7, r0
 8003a3c:	6878      	ldr	r0, [r7, #4]
 8003a3e:	2202      	movs	r2, #2
 8003a40:	2128      	movs	r1, #40	; 0x28
 8003a42:	f7ff ff3e 	bl	80038c2 <HTS221_ReadReg>
 8003a46:	1e03      	subs	r3, r0, #0
 8003a48:	d001      	beq.n	8003a4e <HTS221_Get_Humidity+0xaa>
    return HTS221_ERROR;
 8003a4a:	2301      	movs	r3, #1
 8003a4c:	e068      	b.n	8003b20 <HTS221_Get_Humidity+0x17c>
  H_T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8003a4e:	220c      	movs	r2, #12
 8003a50:	18bb      	adds	r3, r7, r2
 8003a52:	785b      	ldrb	r3, [r3, #1]
 8003a54:	021b      	lsls	r3, r3, #8
 8003a56:	b219      	sxth	r1, r3
 8003a58:	18bb      	adds	r3, r7, r2
 8003a5a:	781b      	ldrb	r3, [r3, #0]
 8003a5c:	b21a      	sxth	r2, r3
 8003a5e:	2016      	movs	r0, #22
 8003a60:	183b      	adds	r3, r7, r0
 8003a62:	430a      	orrs	r2, r1
 8003a64:	801a      	strh	r2, [r3, #0]

  tmp_f = (float)(H_T_out - H0_T0_out) * (float)(H1_rh - H0_rh) / (float)(H1_T0_out - H0_T0_out)  +  H0_rh;
 8003a66:	183b      	adds	r3, r7, r0
 8003a68:	2200      	movs	r2, #0
 8003a6a:	5e9a      	ldrsh	r2, [r3, r2]
 8003a6c:	251a      	movs	r5, #26
 8003a6e:	197b      	adds	r3, r7, r5
 8003a70:	2100      	movs	r1, #0
 8003a72:	5e5b      	ldrsh	r3, [r3, r1]
 8003a74:	1ad3      	subs	r3, r2, r3
 8003a76:	0018      	movs	r0, r3
 8003a78:	f7fd fcc8 	bl	800140c <__aeabi_i2f>
 8003a7c:	1c04      	adds	r4, r0, #0
 8003a7e:	231c      	movs	r3, #28
 8003a80:	18fb      	adds	r3, r7, r3
 8003a82:	2200      	movs	r2, #0
 8003a84:	5e9a      	ldrsh	r2, [r3, r2]
 8003a86:	261e      	movs	r6, #30
 8003a88:	19bb      	adds	r3, r7, r6
 8003a8a:	2100      	movs	r1, #0
 8003a8c:	5e5b      	ldrsh	r3, [r3, r1]
 8003a8e:	1ad3      	subs	r3, r2, r3
 8003a90:	0018      	movs	r0, r3
 8003a92:	f7fd fcbb 	bl	800140c <__aeabi_i2f>
 8003a96:	1c03      	adds	r3, r0, #0
 8003a98:	1c19      	adds	r1, r3, #0
 8003a9a:	1c20      	adds	r0, r4, #0
 8003a9c:	f7fd f9b4 	bl	8000e08 <__aeabi_fmul>
 8003aa0:	1c03      	adds	r3, r0, #0
 8003aa2:	1c1c      	adds	r4, r3, #0
 8003aa4:	2318      	movs	r3, #24
 8003aa6:	18fb      	adds	r3, r7, r3
 8003aa8:	2200      	movs	r2, #0
 8003aaa:	5e9a      	ldrsh	r2, [r3, r2]
 8003aac:	197b      	adds	r3, r7, r5
 8003aae:	2100      	movs	r1, #0
 8003ab0:	5e5b      	ldrsh	r3, [r3, r1]
 8003ab2:	1ad3      	subs	r3, r2, r3
 8003ab4:	0018      	movs	r0, r3
 8003ab6:	f7fd fca9 	bl	800140c <__aeabi_i2f>
 8003aba:	1c03      	adds	r3, r0, #0
 8003abc:	1c19      	adds	r1, r3, #0
 8003abe:	1c20      	adds	r0, r4, #0
 8003ac0:	f7fc ffd8 	bl	8000a74 <__aeabi_fdiv>
 8003ac4:	1c03      	adds	r3, r0, #0
 8003ac6:	1c1c      	adds	r4, r3, #0
 8003ac8:	19bb      	adds	r3, r7, r6
 8003aca:	2200      	movs	r2, #0
 8003acc:	5e9b      	ldrsh	r3, [r3, r2]
 8003ace:	0018      	movs	r0, r3
 8003ad0:	f7fd fc9c 	bl	800140c <__aeabi_i2f>
 8003ad4:	1c03      	adds	r3, r0, #0
 8003ad6:	1c19      	adds	r1, r3, #0
 8003ad8:	1c20      	adds	r0, r4, #0
 8003ada:	f7fc fe2f 	bl	800073c <__aeabi_fadd>
 8003ade:	1c03      	adds	r3, r0, #0
 8003ae0:	613b      	str	r3, [r7, #16]
  tmp_f *= 10.0f;
 8003ae2:	4911      	ldr	r1, [pc, #68]	; (8003b28 <HTS221_Get_Humidity+0x184>)
 8003ae4:	6938      	ldr	r0, [r7, #16]
 8003ae6:	f7fd f98f 	bl	8000e08 <__aeabi_fmul>
 8003aea:	1c03      	adds	r3, r0, #0
 8003aec:	613b      	str	r3, [r7, #16]

  *value = ( tmp_f > 1000.0f ) ? 1000
 8003aee:	490f      	ldr	r1, [pc, #60]	; (8003b2c <HTS221_Get_Humidity+0x188>)
 8003af0:	6938      	ldr	r0, [r7, #16]
 8003af2:	f7fc fced 	bl	80004d0 <__aeabi_fcmpgt>
 8003af6:	1e03      	subs	r3, r0, #0
 8003af8:	d002      	beq.n	8003b00 <HTS221_Get_Humidity+0x15c>
 8003afa:	23fa      	movs	r3, #250	; 0xfa
 8003afc:	009b      	lsls	r3, r3, #2
 8003afe:	e00c      	b.n	8003b1a <HTS221_Get_Humidity+0x176>
 8003b00:	2100      	movs	r1, #0
 8003b02:	6938      	ldr	r0, [r7, #16]
 8003b04:	f7fc fcd0 	bl	80004a8 <__aeabi_fcmplt>
 8003b08:	1e03      	subs	r3, r0, #0
 8003b0a:	d001      	beq.n	8003b10 <HTS221_Get_Humidity+0x16c>
 8003b0c:	2300      	movs	r3, #0
 8003b0e:	e004      	b.n	8003b1a <HTS221_Get_Humidity+0x176>
 8003b10:	6938      	ldr	r0, [r7, #16]
 8003b12:	f7fc fd11 	bl	8000538 <__aeabi_f2uiz>
 8003b16:	0003      	movs	r3, r0
 8003b18:	b29b      	uxth	r3, r3
 8003b1a:	683a      	ldr	r2, [r7, #0]
 8003b1c:	8013      	strh	r3, [r2, #0]
           : ( tmp_f <    0.0f ) ?    0
           : ( uint16_t )tmp_f;

  return HTS221_OK;
 8003b1e:	2300      	movs	r3, #0
}
 8003b20:	0018      	movs	r0, r3
 8003b22:	46bd      	mov	sp, r7
 8003b24:	b009      	add	sp, #36	; 0x24
 8003b26:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b28:	41200000 	.word	0x41200000
 8003b2c:	447a0000 	.word	0x447a0000

08003b30 <HTS221_Get_Temperature>:
* @param  *handle Device handle.
* @param  Pointer to the returned temperature value that must be divided by 10 to get the value in ['C].
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_Temperature(void *handle, int16_t *value)
{
 8003b30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003b32:	b08b      	sub	sp, #44	; 0x2c
 8003b34:	af00      	add	r7, sp, #0
 8003b36:	6078      	str	r0, [r7, #4]
 8003b38:	6039      	str	r1, [r7, #0]
  int16_t T0_out, T1_out, T_out, T0_degC_x8_u16, T1_degC_x8_u16;
  int16_t T0_degC, T1_degC;
  uint8_t buffer[4], tmp;
  float   tmp_f;

  if(HTS221_ReadReg(handle, HTS221_T0_DEGC_X8, 2, buffer))
 8003b3a:	2310      	movs	r3, #16
 8003b3c:	18fb      	adds	r3, r7, r3
 8003b3e:	6878      	ldr	r0, [r7, #4]
 8003b40:	2202      	movs	r2, #2
 8003b42:	2132      	movs	r1, #50	; 0x32
 8003b44:	f7ff febd 	bl	80038c2 <HTS221_ReadReg>
 8003b48:	1e03      	subs	r3, r0, #0
 8003b4a:	d001      	beq.n	8003b50 <HTS221_Get_Temperature+0x20>
    return HTS221_ERROR;
 8003b4c:	2301      	movs	r3, #1
 8003b4e:	e0bb      	b.n	8003cc8 <HTS221_Get_Temperature+0x198>
  if(HTS221_ReadReg(handle, HTS221_T0_T1_DEGC_H2, 1, &tmp))
 8003b50:	230f      	movs	r3, #15
 8003b52:	18fb      	adds	r3, r7, r3
 8003b54:	6878      	ldr	r0, [r7, #4]
 8003b56:	2201      	movs	r2, #1
 8003b58:	2135      	movs	r1, #53	; 0x35
 8003b5a:	f7ff feb2 	bl	80038c2 <HTS221_ReadReg>
 8003b5e:	1e03      	subs	r3, r0, #0
 8003b60:	d001      	beq.n	8003b66 <HTS221_Get_Temperature+0x36>
    return HTS221_ERROR;
 8003b62:	2301      	movs	r3, #1
 8003b64:	e0b0      	b.n	8003cc8 <HTS221_Get_Temperature+0x198>

  T0_degC_x8_u16 = (((uint16_t)(tmp & 0x03)) << 8) | ((uint16_t)buffer[0]);
 8003b66:	240f      	movs	r4, #15
 8003b68:	193b      	adds	r3, r7, r4
 8003b6a:	781b      	ldrb	r3, [r3, #0]
 8003b6c:	021b      	lsls	r3, r3, #8
 8003b6e:	b21a      	sxth	r2, r3
 8003b70:	23c0      	movs	r3, #192	; 0xc0
 8003b72:	009b      	lsls	r3, r3, #2
 8003b74:	4013      	ands	r3, r2
 8003b76:	b219      	sxth	r1, r3
 8003b78:	2010      	movs	r0, #16
 8003b7a:	183b      	adds	r3, r7, r0
 8003b7c:	781b      	ldrb	r3, [r3, #0]
 8003b7e:	b21a      	sxth	r2, r3
 8003b80:	2526      	movs	r5, #38	; 0x26
 8003b82:	197b      	adds	r3, r7, r5
 8003b84:	430a      	orrs	r2, r1
 8003b86:	801a      	strh	r2, [r3, #0]
  T1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_t)buffer[1]);
 8003b88:	193b      	adds	r3, r7, r4
 8003b8a:	781b      	ldrb	r3, [r3, #0]
 8003b8c:	019b      	lsls	r3, r3, #6
 8003b8e:	b21a      	sxth	r2, r3
 8003b90:	23c0      	movs	r3, #192	; 0xc0
 8003b92:	009b      	lsls	r3, r3, #2
 8003b94:	4013      	ands	r3, r2
 8003b96:	b219      	sxth	r1, r3
 8003b98:	183b      	adds	r3, r7, r0
 8003b9a:	785b      	ldrb	r3, [r3, #1]
 8003b9c:	b21a      	sxth	r2, r3
 8003b9e:	2424      	movs	r4, #36	; 0x24
 8003ba0:	193b      	adds	r3, r7, r4
 8003ba2:	430a      	orrs	r2, r1
 8003ba4:	801a      	strh	r2, [r3, #0]
  T0_degC = T0_degC_x8_u16 >> 3;
 8003ba6:	2322      	movs	r3, #34	; 0x22
 8003ba8:	18fb      	adds	r3, r7, r3
 8003baa:	197a      	adds	r2, r7, r5
 8003bac:	2100      	movs	r1, #0
 8003bae:	5e52      	ldrsh	r2, [r2, r1]
 8003bb0:	10d2      	asrs	r2, r2, #3
 8003bb2:	801a      	strh	r2, [r3, #0]
  T1_degC = T1_degC_x8_u16 >> 3;
 8003bb4:	2320      	movs	r3, #32
 8003bb6:	18fb      	adds	r3, r7, r3
 8003bb8:	193a      	adds	r2, r7, r4
 8003bba:	2100      	movs	r1, #0
 8003bbc:	5e52      	ldrsh	r2, [r2, r1]
 8003bbe:	10d2      	asrs	r2, r2, #3
 8003bc0:	801a      	strh	r2, [r3, #0]

  if(HTS221_ReadReg(handle, HTS221_T0_OUT_L, 4, buffer))
 8003bc2:	183b      	adds	r3, r7, r0
 8003bc4:	6878      	ldr	r0, [r7, #4]
 8003bc6:	2204      	movs	r2, #4
 8003bc8:	213c      	movs	r1, #60	; 0x3c
 8003bca:	f7ff fe7a 	bl	80038c2 <HTS221_ReadReg>
 8003bce:	1e03      	subs	r3, r0, #0
 8003bd0:	d001      	beq.n	8003bd6 <HTS221_Get_Temperature+0xa6>
    return HTS221_ERROR;
 8003bd2:	2301      	movs	r3, #1
 8003bd4:	e078      	b.n	8003cc8 <HTS221_Get_Temperature+0x198>

  T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8003bd6:	2010      	movs	r0, #16
 8003bd8:	183b      	adds	r3, r7, r0
 8003bda:	785b      	ldrb	r3, [r3, #1]
 8003bdc:	021b      	lsls	r3, r3, #8
 8003bde:	b219      	sxth	r1, r3
 8003be0:	183b      	adds	r3, r7, r0
 8003be2:	781b      	ldrb	r3, [r3, #0]
 8003be4:	b21a      	sxth	r2, r3
 8003be6:	231e      	movs	r3, #30
 8003be8:	18fb      	adds	r3, r7, r3
 8003bea:	430a      	orrs	r2, r1
 8003bec:	801a      	strh	r2, [r3, #0]
  T1_out = (((uint16_t)buffer[3]) << 8) | (uint16_t)buffer[2];
 8003bee:	183b      	adds	r3, r7, r0
 8003bf0:	78db      	ldrb	r3, [r3, #3]
 8003bf2:	021b      	lsls	r3, r3, #8
 8003bf4:	b219      	sxth	r1, r3
 8003bf6:	183b      	adds	r3, r7, r0
 8003bf8:	789b      	ldrb	r3, [r3, #2]
 8003bfa:	b21a      	sxth	r2, r3
 8003bfc:	231c      	movs	r3, #28
 8003bfe:	18fb      	adds	r3, r7, r3
 8003c00:	430a      	orrs	r2, r1
 8003c02:	801a      	strh	r2, [r3, #0]

  if(HTS221_ReadReg(handle, HTS221_TEMP_OUT_L_REG, 2, buffer))
 8003c04:	183b      	adds	r3, r7, r0
 8003c06:	6878      	ldr	r0, [r7, #4]
 8003c08:	2202      	movs	r2, #2
 8003c0a:	212a      	movs	r1, #42	; 0x2a
 8003c0c:	f7ff fe59 	bl	80038c2 <HTS221_ReadReg>
 8003c10:	1e03      	subs	r3, r0, #0
 8003c12:	d001      	beq.n	8003c18 <HTS221_Get_Temperature+0xe8>
    return HTS221_ERROR;
 8003c14:	2301      	movs	r3, #1
 8003c16:	e057      	b.n	8003cc8 <HTS221_Get_Temperature+0x198>

  T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8003c18:	2210      	movs	r2, #16
 8003c1a:	18bb      	adds	r3, r7, r2
 8003c1c:	785b      	ldrb	r3, [r3, #1]
 8003c1e:	021b      	lsls	r3, r3, #8
 8003c20:	b219      	sxth	r1, r3
 8003c22:	18bb      	adds	r3, r7, r2
 8003c24:	781b      	ldrb	r3, [r3, #0]
 8003c26:	b21a      	sxth	r2, r3
 8003c28:	201a      	movs	r0, #26
 8003c2a:	183b      	adds	r3, r7, r0
 8003c2c:	430a      	orrs	r2, r1
 8003c2e:	801a      	strh	r2, [r3, #0]

  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 8003c30:	183b      	adds	r3, r7, r0
 8003c32:	2200      	movs	r2, #0
 8003c34:	5e9a      	ldrsh	r2, [r3, r2]
 8003c36:	251e      	movs	r5, #30
 8003c38:	197b      	adds	r3, r7, r5
 8003c3a:	2100      	movs	r1, #0
 8003c3c:	5e5b      	ldrsh	r3, [r3, r1]
 8003c3e:	1ad3      	subs	r3, r2, r3
 8003c40:	0018      	movs	r0, r3
 8003c42:	f7fd fbe3 	bl	800140c <__aeabi_i2f>
 8003c46:	1c04      	adds	r4, r0, #0
 8003c48:	2320      	movs	r3, #32
 8003c4a:	18fb      	adds	r3, r7, r3
 8003c4c:	2200      	movs	r2, #0
 8003c4e:	5e9a      	ldrsh	r2, [r3, r2]
 8003c50:	2622      	movs	r6, #34	; 0x22
 8003c52:	19bb      	adds	r3, r7, r6
 8003c54:	2100      	movs	r1, #0
 8003c56:	5e5b      	ldrsh	r3, [r3, r1]
 8003c58:	1ad3      	subs	r3, r2, r3
 8003c5a:	0018      	movs	r0, r3
 8003c5c:	f7fd fbd6 	bl	800140c <__aeabi_i2f>
 8003c60:	1c03      	adds	r3, r0, #0
 8003c62:	1c19      	adds	r1, r3, #0
 8003c64:	1c20      	adds	r0, r4, #0
 8003c66:	f7fd f8cf 	bl	8000e08 <__aeabi_fmul>
 8003c6a:	1c03      	adds	r3, r0, #0
 8003c6c:	1c1c      	adds	r4, r3, #0
 8003c6e:	231c      	movs	r3, #28
 8003c70:	18fb      	adds	r3, r7, r3
 8003c72:	2200      	movs	r2, #0
 8003c74:	5e9a      	ldrsh	r2, [r3, r2]
 8003c76:	197b      	adds	r3, r7, r5
 8003c78:	2100      	movs	r1, #0
 8003c7a:	5e5b      	ldrsh	r3, [r3, r1]
 8003c7c:	1ad3      	subs	r3, r2, r3
 8003c7e:	0018      	movs	r0, r3
 8003c80:	f7fd fbc4 	bl	800140c <__aeabi_i2f>
 8003c84:	1c03      	adds	r3, r0, #0
 8003c86:	1c19      	adds	r1, r3, #0
 8003c88:	1c20      	adds	r0, r4, #0
 8003c8a:	f7fc fef3 	bl	8000a74 <__aeabi_fdiv>
 8003c8e:	1c03      	adds	r3, r0, #0
 8003c90:	1c1c      	adds	r4, r3, #0
 8003c92:	19bb      	adds	r3, r7, r6
 8003c94:	2200      	movs	r2, #0
 8003c96:	5e9b      	ldrsh	r3, [r3, r2]
 8003c98:	0018      	movs	r0, r3
 8003c9a:	f7fd fbb7 	bl	800140c <__aeabi_i2f>
 8003c9e:	1c03      	adds	r3, r0, #0
 8003ca0:	1c19      	adds	r1, r3, #0
 8003ca2:	1c20      	adds	r0, r4, #0
 8003ca4:	f7fc fd4a 	bl	800073c <__aeabi_fadd>
 8003ca8:	1c03      	adds	r3, r0, #0
 8003caa:	617b      	str	r3, [r7, #20]
  tmp_f *= 10.0f;
 8003cac:	4908      	ldr	r1, [pc, #32]	; (8003cd0 <HTS221_Get_Temperature+0x1a0>)
 8003cae:	6978      	ldr	r0, [r7, #20]
 8003cb0:	f7fd f8aa 	bl	8000e08 <__aeabi_fmul>
 8003cb4:	1c03      	adds	r3, r0, #0
 8003cb6:	617b      	str	r3, [r7, #20]

  *value = ( int16_t )tmp_f;
 8003cb8:	6978      	ldr	r0, [r7, #20]
 8003cba:	f7fd fb87 	bl	80013cc <__aeabi_f2iz>
 8003cbe:	0003      	movs	r3, r0
 8003cc0:	b21a      	sxth	r2, r3
 8003cc2:	683b      	ldr	r3, [r7, #0]
 8003cc4:	801a      	strh	r2, [r3, #0]

  return HTS221_OK;
 8003cc6:	2300      	movs	r3, #0
}
 8003cc8:	0018      	movs	r0, r3
 8003cca:	46bd      	mov	sp, r7
 8003ccc:	b00b      	add	sp, #44	; 0x2c
 8003cce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003cd0:	41200000 	.word	0x41200000

08003cd4 <HTS221_Get_DataStatus>:
* @param  temperature pointer to the returned temperature data status [HTS221_SET/HTS221_RESET].
*         This parameter is a pointer to @ref HTS221_BitStatus_et.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_DataStatus(void *handle, HTS221_BitStatus_et* humidity, HTS221_BitStatus_et* temperature)
{
 8003cd4:	b580      	push	{r7, lr}
 8003cd6:	b086      	sub	sp, #24
 8003cd8:	af00      	add	r7, sp, #0
 8003cda:	60f8      	str	r0, [r7, #12]
 8003cdc:	60b9      	str	r1, [r7, #8]
 8003cde:	607a      	str	r2, [r7, #4]
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_STATUS_REG, 1, &tmp))
 8003ce0:	2317      	movs	r3, #23
 8003ce2:	18fb      	adds	r3, r7, r3
 8003ce4:	68f8      	ldr	r0, [r7, #12]
 8003ce6:	2201      	movs	r2, #1
 8003ce8:	2127      	movs	r1, #39	; 0x27
 8003cea:	f7ff fdea 	bl	80038c2 <HTS221_ReadReg>
 8003cee:	1e03      	subs	r3, r0, #0
 8003cf0:	d001      	beq.n	8003cf6 <HTS221_Get_DataStatus+0x22>
    return HTS221_ERROR;
 8003cf2:	2301      	movs	r3, #1
 8003cf4:	e010      	b.n	8003d18 <HTS221_Get_DataStatus+0x44>

  *humidity = (HTS221_BitStatus_et)((tmp & HTS221_HDA_MASK) >> HTS221_H_DA_BIT);
 8003cf6:	2117      	movs	r1, #23
 8003cf8:	187b      	adds	r3, r7, r1
 8003cfa:	781b      	ldrb	r3, [r3, #0]
 8003cfc:	105b      	asrs	r3, r3, #1
 8003cfe:	2201      	movs	r2, #1
 8003d00:	4013      	ands	r3, r2
 8003d02:	b2da      	uxtb	r2, r3
 8003d04:	68bb      	ldr	r3, [r7, #8]
 8003d06:	701a      	strb	r2, [r3, #0]
  *temperature = (HTS221_BitStatus_et)(tmp & HTS221_TDA_MASK);
 8003d08:	187b      	adds	r3, r7, r1
 8003d0a:	781b      	ldrb	r3, [r3, #0]
 8003d0c:	2201      	movs	r2, #1
 8003d0e:	4013      	ands	r3, r2
 8003d10:	b2da      	uxtb	r2, r3
 8003d12:	687b      	ldr	r3, [r7, #4]
 8003d14:	701a      	strb	r2, [r3, #0]

  return HTS221_OK;
 8003d16:	2300      	movs	r3, #0
}
 8003d18:	0018      	movs	r0, r3
 8003d1a:	46bd      	mov	sp, r7
 8003d1c:	b006      	add	sp, #24
 8003d1e:	bd80      	pop	{r7, pc}

08003d20 <HTS221_Activate>:
* @param  *handle Device handle.
* @param  void.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Activate(void *handle)
{
 8003d20:	b580      	push	{r7, lr}
 8003d22:	b084      	sub	sp, #16
 8003d24:	af00      	add	r7, sp, #0
 8003d26:	6078      	str	r0, [r7, #4]
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG1, 1, &tmp))
 8003d28:	230f      	movs	r3, #15
 8003d2a:	18fb      	adds	r3, r7, r3
 8003d2c:	6878      	ldr	r0, [r7, #4]
 8003d2e:	2201      	movs	r2, #1
 8003d30:	2120      	movs	r1, #32
 8003d32:	f7ff fdc6 	bl	80038c2 <HTS221_ReadReg>
 8003d36:	1e03      	subs	r3, r0, #0
 8003d38:	d001      	beq.n	8003d3e <HTS221_Activate+0x1e>
    return HTS221_ERROR;
 8003d3a:	2301      	movs	r3, #1
 8003d3c:	e013      	b.n	8003d66 <HTS221_Activate+0x46>

  tmp |= HTS221_PD_MASK;
 8003d3e:	210f      	movs	r1, #15
 8003d40:	187b      	adds	r3, r7, r1
 8003d42:	781b      	ldrb	r3, [r3, #0]
 8003d44:	2280      	movs	r2, #128	; 0x80
 8003d46:	4252      	negs	r2, r2
 8003d48:	4313      	orrs	r3, r2
 8003d4a:	b2da      	uxtb	r2, r3
 8003d4c:	187b      	adds	r3, r7, r1
 8003d4e:	701a      	strb	r2, [r3, #0]

  if(HTS221_WriteReg(handle, HTS221_CTRL_REG1, 1, &tmp))
 8003d50:	187b      	adds	r3, r7, r1
 8003d52:	6878      	ldr	r0, [r7, #4]
 8003d54:	2201      	movs	r2, #1
 8003d56:	2120      	movs	r1, #32
 8003d58:	f7ff fde1 	bl	800391e <HTS221_WriteReg>
 8003d5c:	1e03      	subs	r3, r0, #0
 8003d5e:	d001      	beq.n	8003d64 <HTS221_Activate+0x44>
    return HTS221_ERROR;
 8003d60:	2301      	movs	r3, #1
 8003d62:	e000      	b.n	8003d66 <HTS221_Activate+0x46>

  return HTS221_OK;
 8003d64:	2300      	movs	r3, #0
}
 8003d66:	0018      	movs	r0, r3
 8003d68:	46bd      	mov	sp, r7
 8003d6a:	b004      	add	sp, #16
 8003d6c:	bd80      	pop	{r7, pc}

08003d6e <HTS221_DeActivate>:
* @brief  Put the sensor in power down mode.
* @param  *handle Device handle.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_DeActivate(void *handle)
{
 8003d6e:	b580      	push	{r7, lr}
 8003d70:	b084      	sub	sp, #16
 8003d72:	af00      	add	r7, sp, #0
 8003d74:	6078      	str	r0, [r7, #4]
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG1, 1, &tmp))
 8003d76:	230f      	movs	r3, #15
 8003d78:	18fb      	adds	r3, r7, r3
 8003d7a:	6878      	ldr	r0, [r7, #4]
 8003d7c:	2201      	movs	r2, #1
 8003d7e:	2120      	movs	r1, #32
 8003d80:	f7ff fd9f 	bl	80038c2 <HTS221_ReadReg>
 8003d84:	1e03      	subs	r3, r0, #0
 8003d86:	d001      	beq.n	8003d8c <HTS221_DeActivate+0x1e>
    return HTS221_ERROR;
 8003d88:	2301      	movs	r3, #1
 8003d8a:	e012      	b.n	8003db2 <HTS221_DeActivate+0x44>

  tmp &= ~HTS221_PD_MASK;
 8003d8c:	210f      	movs	r1, #15
 8003d8e:	187b      	adds	r3, r7, r1
 8003d90:	781b      	ldrb	r3, [r3, #0]
 8003d92:	227f      	movs	r2, #127	; 0x7f
 8003d94:	4013      	ands	r3, r2
 8003d96:	b2da      	uxtb	r2, r3
 8003d98:	187b      	adds	r3, r7, r1
 8003d9a:	701a      	strb	r2, [r3, #0]

  if(HTS221_WriteReg(handle, HTS221_CTRL_REG1, 1, &tmp))
 8003d9c:	187b      	adds	r3, r7, r1
 8003d9e:	6878      	ldr	r0, [r7, #4]
 8003da0:	2201      	movs	r2, #1
 8003da2:	2120      	movs	r1, #32
 8003da4:	f7ff fdbb 	bl	800391e <HTS221_WriteReg>
 8003da8:	1e03      	subs	r3, r0, #0
 8003daa:	d001      	beq.n	8003db0 <HTS221_DeActivate+0x42>
    return HTS221_ERROR;
 8003dac:	2301      	movs	r3, #1
 8003dae:	e000      	b.n	8003db2 <HTS221_DeActivate+0x44>

  return HTS221_OK;
 8003db0:	2300      	movs	r3, #0
}
 8003db2:	0018      	movs	r0, r3
 8003db4:	46bd      	mov	sp, r7
 8003db6:	b004      	add	sp, #16
 8003db8:	bd80      	pop	{r7, pc}
	...

08003dbc <HTS221_Set_BduMode>:
* @param  status can be HTS221_DISABLE: output data registers are continuously updated.
*         This parameter is a @ref HTS221_BitStatus_et.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Set_BduMode(void *handle, HTS221_State_et status)
{
 8003dbc:	b580      	push	{r7, lr}
 8003dbe:	b084      	sub	sp, #16
 8003dc0:	af00      	add	r7, sp, #0
 8003dc2:	6078      	str	r0, [r7, #4]
 8003dc4:	000a      	movs	r2, r1
 8003dc6:	1cfb      	adds	r3, r7, #3
 8003dc8:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;

  HTS221_assert_param(IS_HTS221_State(status));
 8003dca:	1cfb      	adds	r3, r7, #3
 8003dcc:	781b      	ldrb	r3, [r3, #0]
 8003dce:	2b01      	cmp	r3, #1
 8003dd0:	d009      	beq.n	8003de6 <HTS221_Set_BduMode+0x2a>
 8003dd2:	1cfb      	adds	r3, r7, #3
 8003dd4:	781b      	ldrb	r3, [r3, #0]
 8003dd6:	2b00      	cmp	r3, #0
 8003dd8:	d005      	beq.n	8003de6 <HTS221_Set_BduMode+0x2a>
 8003dda:	4a1a      	ldr	r2, [pc, #104]	; (8003e44 <HTS221_Set_BduMode+0x88>)
 8003ddc:	4b1a      	ldr	r3, [pc, #104]	; (8003e48 <HTS221_Set_BduMode+0x8c>)
 8003dde:	0011      	movs	r1, r2
 8003de0:	0018      	movs	r0, r3
 8003de2:	f000 f8a1 	bl	8003f28 <HTS221_assert_failed>

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG1, 1, &tmp))
 8003de6:	230f      	movs	r3, #15
 8003de8:	18fb      	adds	r3, r7, r3
 8003dea:	6878      	ldr	r0, [r7, #4]
 8003dec:	2201      	movs	r2, #1
 8003dee:	2120      	movs	r1, #32
 8003df0:	f7ff fd67 	bl	80038c2 <HTS221_ReadReg>
 8003df4:	1e03      	subs	r3, r0, #0
 8003df6:	d001      	beq.n	8003dfc <HTS221_Set_BduMode+0x40>
    return HTS221_ERROR;
 8003df8:	2301      	movs	r3, #1
 8003dfa:	e01e      	b.n	8003e3a <HTS221_Set_BduMode+0x7e>

  tmp &= ~HTS221_BDU_MASK;
 8003dfc:	210f      	movs	r1, #15
 8003dfe:	187b      	adds	r3, r7, r1
 8003e00:	781b      	ldrb	r3, [r3, #0]
 8003e02:	2204      	movs	r2, #4
 8003e04:	4393      	bics	r3, r2
 8003e06:	b2da      	uxtb	r2, r3
 8003e08:	187b      	adds	r3, r7, r1
 8003e0a:	701a      	strb	r2, [r3, #0]
  tmp |= ((uint8_t)status) << HTS221_BDU_BIT;
 8003e0c:	1cfb      	adds	r3, r7, #3
 8003e0e:	781b      	ldrb	r3, [r3, #0]
 8003e10:	009b      	lsls	r3, r3, #2
 8003e12:	b25a      	sxtb	r2, r3
 8003e14:	187b      	adds	r3, r7, r1
 8003e16:	781b      	ldrb	r3, [r3, #0]
 8003e18:	b25b      	sxtb	r3, r3
 8003e1a:	4313      	orrs	r3, r2
 8003e1c:	b25b      	sxtb	r3, r3
 8003e1e:	b2da      	uxtb	r2, r3
 8003e20:	187b      	adds	r3, r7, r1
 8003e22:	701a      	strb	r2, [r3, #0]

  if(HTS221_WriteReg(handle, HTS221_CTRL_REG1, 1, &tmp))
 8003e24:	187b      	adds	r3, r7, r1
 8003e26:	6878      	ldr	r0, [r7, #4]
 8003e28:	2201      	movs	r2, #1
 8003e2a:	2120      	movs	r1, #32
 8003e2c:	f7ff fd77 	bl	800391e <HTS221_WriteReg>
 8003e30:	1e03      	subs	r3, r0, #0
 8003e32:	d001      	beq.n	8003e38 <HTS221_Set_BduMode+0x7c>
    return HTS221_ERROR;
 8003e34:	2301      	movs	r3, #1
 8003e36:	e000      	b.n	8003e3a <HTS221_Set_BduMode+0x7e>

  return HTS221_OK;
 8003e38:	2300      	movs	r3, #0
}
 8003e3a:	0018      	movs	r0, r3
 8003e3c:	46bd      	mov	sp, r7
 8003e3e:	b004      	add	sp, #16
 8003e40:	bd80      	pop	{r7, pc}
 8003e42:	46c0      	nop			; (mov r8, r8)
 8003e44:	00000263 	.word	0x00000263
 8003e48:	0801ec44 	.word	0x0801ec44

08003e4c <HTS221_Set_Odr>:
* @param  odr is the output data rate mode.
*         This parameter is a @ref HTS221_Odr_et.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Set_Odr(void *handle, HTS221_Odr_et odr)
{
 8003e4c:	b580      	push	{r7, lr}
 8003e4e:	b084      	sub	sp, #16
 8003e50:	af00      	add	r7, sp, #0
 8003e52:	6078      	str	r0, [r7, #4]
 8003e54:	000a      	movs	r2, r1
 8003e56:	1cfb      	adds	r3, r7, #3
 8003e58:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;

  HTS221_assert_param(IS_HTS221_ODR(odr));
 8003e5a:	1cfb      	adds	r3, r7, #3
 8003e5c:	781b      	ldrb	r3, [r3, #0]
 8003e5e:	2b00      	cmp	r3, #0
 8003e60:	d011      	beq.n	8003e86 <HTS221_Set_Odr+0x3a>
 8003e62:	1cfb      	adds	r3, r7, #3
 8003e64:	781b      	ldrb	r3, [r3, #0]
 8003e66:	2b01      	cmp	r3, #1
 8003e68:	d00d      	beq.n	8003e86 <HTS221_Set_Odr+0x3a>
 8003e6a:	1cfb      	adds	r3, r7, #3
 8003e6c:	781b      	ldrb	r3, [r3, #0]
 8003e6e:	2b02      	cmp	r3, #2
 8003e70:	d009      	beq.n	8003e86 <HTS221_Set_Odr+0x3a>
 8003e72:	1cfb      	adds	r3, r7, #3
 8003e74:	781b      	ldrb	r3, [r3, #0]
 8003e76:	2b03      	cmp	r3, #3
 8003e78:	d005      	beq.n	8003e86 <HTS221_Set_Odr+0x3a>
 8003e7a:	4a18      	ldr	r2, [pc, #96]	; (8003edc <HTS221_Set_Odr+0x90>)
 8003e7c:	4b18      	ldr	r3, [pc, #96]	; (8003ee0 <HTS221_Set_Odr+0x94>)
 8003e7e:	0011      	movs	r1, r2
 8003e80:	0018      	movs	r0, r3
 8003e82:	f000 f851 	bl	8003f28 <HTS221_assert_failed>

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG1, 1, &tmp))
 8003e86:	230f      	movs	r3, #15
 8003e88:	18fb      	adds	r3, r7, r3
 8003e8a:	6878      	ldr	r0, [r7, #4]
 8003e8c:	2201      	movs	r2, #1
 8003e8e:	2120      	movs	r1, #32
 8003e90:	f7ff fd17 	bl	80038c2 <HTS221_ReadReg>
 8003e94:	1e03      	subs	r3, r0, #0
 8003e96:	d001      	beq.n	8003e9c <HTS221_Set_Odr+0x50>
    return HTS221_ERROR;
 8003e98:	2301      	movs	r3, #1
 8003e9a:	e01a      	b.n	8003ed2 <HTS221_Set_Odr+0x86>

  tmp &= ~HTS221_ODR_MASK;
 8003e9c:	210f      	movs	r1, #15
 8003e9e:	187b      	adds	r3, r7, r1
 8003ea0:	781b      	ldrb	r3, [r3, #0]
 8003ea2:	2203      	movs	r2, #3
 8003ea4:	4393      	bics	r3, r2
 8003ea6:	b2da      	uxtb	r2, r3
 8003ea8:	187b      	adds	r3, r7, r1
 8003eaa:	701a      	strb	r2, [r3, #0]
  tmp |= (uint8_t)odr;
 8003eac:	187b      	adds	r3, r7, r1
 8003eae:	781a      	ldrb	r2, [r3, #0]
 8003eb0:	1cfb      	adds	r3, r7, #3
 8003eb2:	781b      	ldrb	r3, [r3, #0]
 8003eb4:	4313      	orrs	r3, r2
 8003eb6:	b2da      	uxtb	r2, r3
 8003eb8:	187b      	adds	r3, r7, r1
 8003eba:	701a      	strb	r2, [r3, #0]

  if(HTS221_WriteReg(handle, HTS221_CTRL_REG1, 1, &tmp))
 8003ebc:	187b      	adds	r3, r7, r1
 8003ebe:	6878      	ldr	r0, [r7, #4]
 8003ec0:	2201      	movs	r2, #1
 8003ec2:	2120      	movs	r1, #32
 8003ec4:	f7ff fd2b 	bl	800391e <HTS221_WriteReg>
 8003ec8:	1e03      	subs	r3, r0, #0
 8003eca:	d001      	beq.n	8003ed0 <HTS221_Set_Odr+0x84>
    return HTS221_ERROR;
 8003ecc:	2301      	movs	r3, #1
 8003ece:	e000      	b.n	8003ed2 <HTS221_Set_Odr+0x86>

  return HTS221_OK;
 8003ed0:	2300      	movs	r3, #0
}
 8003ed2:	0018      	movs	r0, r3
 8003ed4:	46bd      	mov	sp, r7
 8003ed6:	b004      	add	sp, #16
 8003ed8:	bd80      	pop	{r7, pc}
 8003eda:	46c0      	nop			; (mov r8, r8)
 8003edc:	000002ba 	.word	0x000002ba
 8003ee0:	0801ec44 	.word	0x0801ec44

08003ee4 <HTS221_Get_Odr>:
* @param  *handle Device handle.
* @param  Pointer to the returned value with output data rate mode.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_Odr(void *handle, HTS221_Odr_et* odr)
{
 8003ee4:	b580      	push	{r7, lr}
 8003ee6:	b084      	sub	sp, #16
 8003ee8:	af00      	add	r7, sp, #0
 8003eea:	6078      	str	r0, [r7, #4]
 8003eec:	6039      	str	r1, [r7, #0]
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG1, 1, &tmp))
 8003eee:	230f      	movs	r3, #15
 8003ef0:	18fb      	adds	r3, r7, r3
 8003ef2:	6878      	ldr	r0, [r7, #4]
 8003ef4:	2201      	movs	r2, #1
 8003ef6:	2120      	movs	r1, #32
 8003ef8:	f7ff fce3 	bl	80038c2 <HTS221_ReadReg>
 8003efc:	1e03      	subs	r3, r0, #0
 8003efe:	d001      	beq.n	8003f04 <HTS221_Get_Odr+0x20>
    return HTS221_ERROR;
 8003f00:	2301      	movs	r3, #1
 8003f02:	e00c      	b.n	8003f1e <HTS221_Get_Odr+0x3a>

  tmp &= HTS221_ODR_MASK;
 8003f04:	210f      	movs	r1, #15
 8003f06:	187b      	adds	r3, r7, r1
 8003f08:	781b      	ldrb	r3, [r3, #0]
 8003f0a:	2203      	movs	r2, #3
 8003f0c:	4013      	ands	r3, r2
 8003f0e:	b2da      	uxtb	r2, r3
 8003f10:	187b      	adds	r3, r7, r1
 8003f12:	701a      	strb	r2, [r3, #0]
  *odr = (HTS221_Odr_et)tmp;
 8003f14:	187b      	adds	r3, r7, r1
 8003f16:	781a      	ldrb	r2, [r3, #0]
 8003f18:	683b      	ldr	r3, [r7, #0]
 8003f1a:	701a      	strb	r2, [r3, #0]

  return HTS221_OK;
 8003f1c:	2300      	movs	r3, #0
}
 8003f1e:	0018      	movs	r0, r3
 8003f20:	46bd      	mov	sp, r7
 8003f22:	b004      	add	sp, #16
 8003f24:	bd80      	pop	{r7, pc}
	...

08003f28 <HTS221_assert_failed>:
* @param file: pointer to the source file name
* @param line: assert_param error line source number
* @retval : None
*/
void HTS221_assert_failed(uint8_t* file, uint32_t line)
{
 8003f28:	b580      	push	{r7, lr}
 8003f2a:	b082      	sub	sp, #8
 8003f2c:	af00      	add	r7, sp, #0
 8003f2e:	6078      	str	r0, [r7, #4]
 8003f30:	6039      	str	r1, [r7, #0]
  /* User can add his own implementation to report the file name and line number */
  printf("Wrong parameters value: file %s on line %d\r\n", file, (int)line);
 8003f32:	683a      	ldr	r2, [r7, #0]
 8003f34:	6879      	ldr	r1, [r7, #4]
 8003f36:	4b02      	ldr	r3, [pc, #8]	; (8003f40 <HTS221_assert_failed+0x18>)
 8003f38:	0018      	movs	r0, r3
 8003f3a:	f019 fb13 	bl	801d564 <iprintf>

  /* Infinite loop */
  while (1)
 8003f3e:	e7fe      	b.n	8003f3e <HTS221_assert_failed+0x16>
 8003f40:	0801ec94 	.word	0x0801ec94

08003f44 <HTS221_H_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Init( DrvContextTypeDef *handle )
{
 8003f44:	b580      	push	{r7, lr}
 8003f46:	b082      	sub	sp, #8
 8003f48:	af00      	add	r7, sp, #0
 8003f4a:	6078      	str	r0, [r7, #4]

  /* Check if the HTS221 temperature sensor is already initialized. */
  /* If yes, skip the initialize function, if not call initialize function */
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 8003f4c:	687b      	ldr	r3, [r7, #4]
 8003f4e:	689b      	ldr	r3, [r3, #8]
 8003f50:	681b      	ldr	r3, [r3, #0]
 8003f52:	681b      	ldr	r3, [r3, #0]
 8003f54:	785b      	ldrb	r3, [r3, #1]
 8003f56:	2b00      	cmp	r3, #0
 8003f58:	d108      	bne.n	8003f6c <HTS221_H_Init+0x28>
  {
    if(HTS221_Init(handle) == COMPONENT_ERROR)
 8003f5a:	687b      	ldr	r3, [r7, #4]
 8003f5c:	0018      	movs	r0, r3
 8003f5e:	f000 fa99 	bl	8004494 <HTS221_Init>
 8003f62:	0003      	movs	r3, r0
 8003f64:	2b01      	cmp	r3, #1
 8003f66:	d101      	bne.n	8003f6c <HTS221_H_Init+0x28>
    {
      return COMPONENT_ERROR;
 8003f68:	2301      	movs	r3, #1
 8003f6a:	e009      	b.n	8003f80 <HTS221_H_Init+0x3c>
    }
  }

  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized = 1;
 8003f6c:	687b      	ldr	r3, [r7, #4]
 8003f6e:	689b      	ldr	r3, [r3, #8]
 8003f70:	681b      	ldr	r3, [r3, #0]
 8003f72:	681b      	ldr	r3, [r3, #0]
 8003f74:	2201      	movs	r2, #1
 8003f76:	701a      	strb	r2, [r3, #0]

  handle->isInitialized = 1;
 8003f78:	687b      	ldr	r3, [r7, #4]
 8003f7a:	2201      	movs	r2, #1
 8003f7c:	70da      	strb	r2, [r3, #3]

  return COMPONENT_OK;
 8003f7e:	2300      	movs	r3, #0
}
 8003f80:	0018      	movs	r0, r3
 8003f82:	46bd      	mov	sp, r7
 8003f84:	b002      	add	sp, #8
 8003f86:	bd80      	pop	{r7, pc}

08003f88 <HTS221_H_DeInit>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_DeInit( DrvContextTypeDef *handle )
{
 8003f88:	b580      	push	{r7, lr}
 8003f8a:	b082      	sub	sp, #8
 8003f8c:	af00      	add	r7, sp, #0
 8003f8e:	6078      	str	r0, [r7, #4]

  /* Check if the HTS221 temperature sensor is already initialized. */
  /* If yes, skip the deinitialize function, if not call deinitialize function */
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 8003f90:	687b      	ldr	r3, [r7, #4]
 8003f92:	689b      	ldr	r3, [r3, #8]
 8003f94:	681b      	ldr	r3, [r3, #0]
 8003f96:	681b      	ldr	r3, [r3, #0]
 8003f98:	785b      	ldrb	r3, [r3, #1]
 8003f9a:	2b00      	cmp	r3, #0
 8003f9c:	d108      	bne.n	8003fb0 <HTS221_H_DeInit+0x28>
  {
    if(HTS221_H_Sensor_Disable(handle) == COMPONENT_ERROR)
 8003f9e:	687b      	ldr	r3, [r7, #4]
 8003fa0:	0018      	movs	r0, r3
 8003fa2:	f000 f83b 	bl	800401c <HTS221_H_Sensor_Disable>
 8003fa6:	0003      	movs	r3, r0
 8003fa8:	2b01      	cmp	r3, #1
 8003faa:	d101      	bne.n	8003fb0 <HTS221_H_DeInit+0x28>
    {
      return COMPONENT_ERROR;
 8003fac:	2301      	movs	r3, #1
 8003fae:	e009      	b.n	8003fc4 <HTS221_H_DeInit+0x3c>
    }
  }

  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized = 0;
 8003fb0:	687b      	ldr	r3, [r7, #4]
 8003fb2:	689b      	ldr	r3, [r3, #8]
 8003fb4:	681b      	ldr	r3, [r3, #0]
 8003fb6:	681b      	ldr	r3, [r3, #0]
 8003fb8:	2200      	movs	r2, #0
 8003fba:	701a      	strb	r2, [r3, #0]

  handle->isInitialized = 0;
 8003fbc:	687b      	ldr	r3, [r7, #4]
 8003fbe:	2200      	movs	r2, #0
 8003fc0:	70da      	strb	r2, [r3, #3]

  return COMPONENT_OK;
 8003fc2:	2300      	movs	r3, #0
}
 8003fc4:	0018      	movs	r0, r3
 8003fc6:	46bd      	mov	sp, r7
 8003fc8:	b002      	add	sp, #8
 8003fca:	bd80      	pop	{r7, pc}

08003fcc <HTS221_H_Sensor_Enable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Sensor_Enable( DrvContextTypeDef *handle )
{
 8003fcc:	b580      	push	{r7, lr}
 8003fce:	b082      	sub	sp, #8
 8003fd0:	af00      	add	r7, sp, #0
 8003fd2:	6078      	str	r0, [r7, #4]

  /* Check if the component is already enabled */
  if ( handle->isEnabled == 1 )
 8003fd4:	687b      	ldr	r3, [r7, #4]
 8003fd6:	791b      	ldrb	r3, [r3, #4]
 8003fd8:	2b01      	cmp	r3, #1
 8003fda:	d101      	bne.n	8003fe0 <HTS221_H_Sensor_Enable+0x14>
  {
    return COMPONENT_OK;
 8003fdc:	2300      	movs	r3, #0
 8003fde:	e019      	b.n	8004014 <HTS221_H_Sensor_Enable+0x48>
  }

  /* Check if the HTS221 temperature sensor is already enabled. */
  /* If yes, skip the enable function, if not call enable function */
  if((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled == 0))
 8003fe0:	687b      	ldr	r3, [r7, #4]
 8003fe2:	689b      	ldr	r3, [r3, #8]
 8003fe4:	681b      	ldr	r3, [r3, #0]
 8003fe6:	681b      	ldr	r3, [r3, #0]
 8003fe8:	78db      	ldrb	r3, [r3, #3]
 8003fea:	2b00      	cmp	r3, #0
 8003fec:	d108      	bne.n	8004000 <HTS221_H_Sensor_Enable+0x34>
  {
    if(HTS221_Sensor_Enable(handle) == COMPONENT_ERROR)
 8003fee:	687b      	ldr	r3, [r7, #4]
 8003ff0:	0018      	movs	r0, r3
 8003ff2:	f000 fa7e 	bl	80044f2 <HTS221_Sensor_Enable>
 8003ff6:	0003      	movs	r3, r0
 8003ff8:	2b01      	cmp	r3, #1
 8003ffa:	d101      	bne.n	8004000 <HTS221_H_Sensor_Enable+0x34>
    {
      return COMPONENT_ERROR;
 8003ffc:	2301      	movs	r3, #1
 8003ffe:	e009      	b.n	8004014 <HTS221_H_Sensor_Enable+0x48>
    }
  }

  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled = 1;
 8004000:	687b      	ldr	r3, [r7, #4]
 8004002:	689b      	ldr	r3, [r3, #8]
 8004004:	681b      	ldr	r3, [r3, #0]
 8004006:	681b      	ldr	r3, [r3, #0]
 8004008:	2201      	movs	r2, #1
 800400a:	709a      	strb	r2, [r3, #2]

  handle->isEnabled = 1;
 800400c:	687b      	ldr	r3, [r7, #4]
 800400e:	2201      	movs	r2, #1
 8004010:	711a      	strb	r2, [r3, #4]

  return COMPONENT_OK;
 8004012:	2300      	movs	r3, #0
}
 8004014:	0018      	movs	r0, r3
 8004016:	46bd      	mov	sp, r7
 8004018:	b002      	add	sp, #8
 800401a:	bd80      	pop	{r7, pc}

0800401c <HTS221_H_Sensor_Disable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Sensor_Disable( DrvContextTypeDef *handle )
{
 800401c:	b580      	push	{r7, lr}
 800401e:	b082      	sub	sp, #8
 8004020:	af00      	add	r7, sp, #0
 8004022:	6078      	str	r0, [r7, #4]

  /* Check if the component is already disabled */
  if ( handle->isEnabled == 0 )
 8004024:	687b      	ldr	r3, [r7, #4]
 8004026:	791b      	ldrb	r3, [r3, #4]
 8004028:	2b00      	cmp	r3, #0
 800402a:	d101      	bne.n	8004030 <HTS221_H_Sensor_Disable+0x14>
  {
    return COMPONENT_OK;
 800402c:	2300      	movs	r3, #0
 800402e:	e019      	b.n	8004064 <HTS221_H_Sensor_Disable+0x48>
  }

  /* Check if the HTS221 temperature sensor is still enabled. */
  /* If yes, skip the disable function, if not call disable function */
  if((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled == 0))
 8004030:	687b      	ldr	r3, [r7, #4]
 8004032:	689b      	ldr	r3, [r3, #8]
 8004034:	681b      	ldr	r3, [r3, #0]
 8004036:	681b      	ldr	r3, [r3, #0]
 8004038:	78db      	ldrb	r3, [r3, #3]
 800403a:	2b00      	cmp	r3, #0
 800403c:	d108      	bne.n	8004050 <HTS221_H_Sensor_Disable+0x34>
  {
    if(HTS221_Sensor_Disable(handle) == COMPONENT_ERROR)
 800403e:	687b      	ldr	r3, [r7, #4]
 8004040:	0018      	movs	r0, r3
 8004042:	f000 fa68 	bl	8004516 <HTS221_Sensor_Disable>
 8004046:	0003      	movs	r3, r0
 8004048:	2b01      	cmp	r3, #1
 800404a:	d101      	bne.n	8004050 <HTS221_H_Sensor_Disable+0x34>
    {
      return COMPONENT_ERROR;
 800404c:	2301      	movs	r3, #1
 800404e:	e009      	b.n	8004064 <HTS221_H_Sensor_Disable+0x48>
    }
  }

  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled = 0;
 8004050:	687b      	ldr	r3, [r7, #4]
 8004052:	689b      	ldr	r3, [r3, #8]
 8004054:	681b      	ldr	r3, [r3, #0]
 8004056:	681b      	ldr	r3, [r3, #0]
 8004058:	2200      	movs	r2, #0
 800405a:	709a      	strb	r2, [r3, #2]

  handle->isEnabled = 0;
 800405c:	687b      	ldr	r3, [r7, #4]
 800405e:	2200      	movs	r2, #0
 8004060:	711a      	strb	r2, [r3, #4]

  return COMPONENT_OK;
 8004062:	2300      	movs	r3, #0
}
 8004064:	0018      	movs	r0, r3
 8004066:	46bd      	mov	sp, r7
 8004068:	b002      	add	sp, #8
 800406a:	bd80      	pop	{r7, pc}

0800406c <HTS221_H_Get_WhoAmI>:
 * @param who_am_i pointer to the value of WHO_AM_I register
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Get_WhoAmI( DrvContextTypeDef *handle, uint8_t *who_am_i )
{
 800406c:	b580      	push	{r7, lr}
 800406e:	b082      	sub	sp, #8
 8004070:	af00      	add	r7, sp, #0
 8004072:	6078      	str	r0, [r7, #4]
 8004074:	6039      	str	r1, [r7, #0]

  return HTS221_Get_WhoAmI( handle, who_am_i );
 8004076:	683a      	ldr	r2, [r7, #0]
 8004078:	687b      	ldr	r3, [r7, #4]
 800407a:	0011      	movs	r1, r2
 800407c:	0018      	movs	r0, r3
 800407e:	f000 fa5c 	bl	800453a <HTS221_Get_WhoAmI>
 8004082:	0003      	movs	r3, r0
}
 8004084:	0018      	movs	r0, r3
 8004086:	46bd      	mov	sp, r7
 8004088:	b002      	add	sp, #8
 800408a:	bd80      	pop	{r7, pc}

0800408c <HTS221_H_Check_WhoAmI>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Check_WhoAmI( DrvContextTypeDef *handle )
{
 800408c:	b580      	push	{r7, lr}
 800408e:	b082      	sub	sp, #8
 8004090:	af00      	add	r7, sp, #0
 8004092:	6078      	str	r0, [r7, #4]

  return HTS221_Check_WhoAmI( handle );
 8004094:	687b      	ldr	r3, [r7, #4]
 8004096:	0018      	movs	r0, r3
 8004098:	f000 fa64 	bl	8004564 <HTS221_Check_WhoAmI>
 800409c:	0003      	movs	r3, r0
}
 800409e:	0018      	movs	r0, r3
 80040a0:	46bd      	mov	sp, r7
 80040a2:	b002      	add	sp, #8
 80040a4:	bd80      	pop	{r7, pc}

080040a6 <HTS221_H_Get_Hum>:
 * @param humidity pointer where the value is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Get_Hum( DrvContextTypeDef *handle, float *humidity )
{
 80040a6:	b580      	push	{r7, lr}
 80040a8:	b082      	sub	sp, #8
 80040aa:	af00      	add	r7, sp, #0
 80040ac:	6078      	str	r0, [r7, #4]
 80040ae:	6039      	str	r1, [r7, #0]

  return HTS221_Get_Hum( handle, humidity );
 80040b0:	683a      	ldr	r2, [r7, #0]
 80040b2:	687b      	ldr	r3, [r7, #4]
 80040b4:	0011      	movs	r1, r2
 80040b6:	0018      	movs	r0, r3
 80040b8:	f000 fa76 	bl	80045a8 <HTS221_Get_Hum>
 80040bc:	0003      	movs	r3, r0
}
 80040be:	0018      	movs	r0, r3
 80040c0:	46bd      	mov	sp, r7
 80040c2:	b002      	add	sp, #8
 80040c4:	bd80      	pop	{r7, pc}

080040c6 <HTS221_H_Get_ODR>:
 * @param odr pointer where the output data rate is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Get_ODR( DrvContextTypeDef *handle, float *odr )
{
 80040c6:	b580      	push	{r7, lr}
 80040c8:	b082      	sub	sp, #8
 80040ca:	af00      	add	r7, sp, #0
 80040cc:	6078      	str	r0, [r7, #4]
 80040ce:	6039      	str	r1, [r7, #0]

  return HTS221_Get_ODR( handle, odr );
 80040d0:	683a      	ldr	r2, [r7, #0]
 80040d2:	687b      	ldr	r3, [r7, #4]
 80040d4:	0011      	movs	r1, r2
 80040d6:	0018      	movs	r0, r3
 80040d8:	f000 fabc 	bl	8004654 <HTS221_Get_ODR>
 80040dc:	0003      	movs	r3, r0
}
 80040de:	0018      	movs	r0, r3
 80040e0:	46bd      	mov	sp, r7
 80040e2:	b002      	add	sp, #8
 80040e4:	bd80      	pop	{r7, pc}

080040e6 <HTS221_H_Set_ODR>:
 * @param odr the functional output data rate to be set
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Set_ODR( DrvContextTypeDef *handle, SensorOdr_t odr )
{
 80040e6:	b580      	push	{r7, lr}
 80040e8:	b082      	sub	sp, #8
 80040ea:	af00      	add	r7, sp, #0
 80040ec:	6078      	str	r0, [r7, #4]
 80040ee:	000a      	movs	r2, r1
 80040f0:	1cfb      	adds	r3, r7, #3
 80040f2:	701a      	strb	r2, [r3, #0]

  return HTS221_Set_ODR( handle, odr );
 80040f4:	1cfb      	adds	r3, r7, #3
 80040f6:	781a      	ldrb	r2, [r3, #0]
 80040f8:	687b      	ldr	r3, [r7, #4]
 80040fa:	0011      	movs	r1, r2
 80040fc:	0018      	movs	r0, r3
 80040fe:	f000 fae9 	bl	80046d4 <HTS221_Set_ODR>
 8004102:	0003      	movs	r3, r0
}
 8004104:	0018      	movs	r0, r3
 8004106:	46bd      	mov	sp, r7
 8004108:	b002      	add	sp, #8
 800410a:	bd80      	pop	{r7, pc}

0800410c <HTS221_H_Set_ODR_Value>:
 * @param odr the output data rate value to be set
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Set_ODR_Value( DrvContextTypeDef *handle, float odr )
{
 800410c:	b580      	push	{r7, lr}
 800410e:	b082      	sub	sp, #8
 8004110:	af00      	add	r7, sp, #0
 8004112:	6078      	str	r0, [r7, #4]
 8004114:	6039      	str	r1, [r7, #0]

  return HTS221_Set_ODR_Value( handle, odr );
 8004116:	683a      	ldr	r2, [r7, #0]
 8004118:	687b      	ldr	r3, [r7, #4]
 800411a:	1c11      	adds	r1, r2, #0
 800411c:	0018      	movs	r0, r3
 800411e:	f000 fb19 	bl	8004754 <HTS221_Set_ODR_Value>
 8004122:	0003      	movs	r3, r0
}
 8004124:	0018      	movs	r0, r3
 8004126:	46bd      	mov	sp, r7
 8004128:	b002      	add	sp, #8
 800412a:	bd80      	pop	{r7, pc}

0800412c <HTS221_H_Read_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Read_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t *data )
{
 800412c:	b580      	push	{r7, lr}
 800412e:	b084      	sub	sp, #16
 8004130:	af00      	add	r7, sp, #0
 8004132:	60f8      	str	r0, [r7, #12]
 8004134:	607a      	str	r2, [r7, #4]
 8004136:	200b      	movs	r0, #11
 8004138:	183b      	adds	r3, r7, r0
 800413a:	1c0a      	adds	r2, r1, #0
 800413c:	701a      	strb	r2, [r3, #0]

  if ( HTS221_Read_Reg( handle, reg, data ) == COMPONENT_ERROR )
 800413e:	687a      	ldr	r2, [r7, #4]
 8004140:	183b      	adds	r3, r7, r0
 8004142:	7819      	ldrb	r1, [r3, #0]
 8004144:	68fb      	ldr	r3, [r7, #12]
 8004146:	0018      	movs	r0, r3
 8004148:	f000 fb32 	bl	80047b0 <HTS221_Read_Reg>
 800414c:	0003      	movs	r3, r0
 800414e:	2b01      	cmp	r3, #1
 8004150:	d101      	bne.n	8004156 <HTS221_H_Read_Reg+0x2a>
  {
    return COMPONENT_ERROR;
 8004152:	2301      	movs	r3, #1
 8004154:	e000      	b.n	8004158 <HTS221_H_Read_Reg+0x2c>
  }

  return COMPONENT_OK;
 8004156:	2300      	movs	r3, #0
}
 8004158:	0018      	movs	r0, r3
 800415a:	46bd      	mov	sp, r7
 800415c:	b004      	add	sp, #16
 800415e:	bd80      	pop	{r7, pc}

08004160 <HTS221_H_Write_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Write_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t data )
{
 8004160:	b580      	push	{r7, lr}
 8004162:	b082      	sub	sp, #8
 8004164:	af00      	add	r7, sp, #0
 8004166:	6078      	str	r0, [r7, #4]
 8004168:	0008      	movs	r0, r1
 800416a:	0011      	movs	r1, r2
 800416c:	1cfb      	adds	r3, r7, #3
 800416e:	1c02      	adds	r2, r0, #0
 8004170:	701a      	strb	r2, [r3, #0]
 8004172:	1cbb      	adds	r3, r7, #2
 8004174:	1c0a      	adds	r2, r1, #0
 8004176:	701a      	strb	r2, [r3, #0]

  if ( HTS221_Write_Reg( handle, reg, data ) == COMPONENT_ERROR )
 8004178:	1cbb      	adds	r3, r7, #2
 800417a:	781a      	ldrb	r2, [r3, #0]
 800417c:	1cfb      	adds	r3, r7, #3
 800417e:	7819      	ldrb	r1, [r3, #0]
 8004180:	687b      	ldr	r3, [r7, #4]
 8004182:	0018      	movs	r0, r3
 8004184:	f000 fb2f 	bl	80047e6 <HTS221_Write_Reg>
 8004188:	0003      	movs	r3, r0
 800418a:	2b01      	cmp	r3, #1
 800418c:	d101      	bne.n	8004192 <HTS221_H_Write_Reg+0x32>
  {
    return COMPONENT_ERROR;
 800418e:	2301      	movs	r3, #1
 8004190:	e000      	b.n	8004194 <HTS221_H_Write_Reg+0x34>
  }

  return COMPONENT_OK;
 8004192:	2300      	movs	r3, #0
}
 8004194:	0018      	movs	r0, r3
 8004196:	46bd      	mov	sp, r7
 8004198:	b002      	add	sp, #8
 800419a:	bd80      	pop	{r7, pc}

0800419c <HTS221_H_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 800419c:	b580      	push	{r7, lr}
 800419e:	b084      	sub	sp, #16
 80041a0:	af00      	add	r7, sp, #0
 80041a2:	6078      	str	r0, [r7, #4]
 80041a4:	6039      	str	r1, [r7, #0]

  HTS221_BitStatus_et hum_status_raw;
  HTS221_BitStatus_et temp_status_raw;

  if ( HTS221_Get_DataStatus( (void *)handle, &hum_status_raw, &temp_status_raw ) == HTS221_ERROR )
 80041a6:	230e      	movs	r3, #14
 80041a8:	18fa      	adds	r2, r7, r3
 80041aa:	230f      	movs	r3, #15
 80041ac:	18f9      	adds	r1, r7, r3
 80041ae:	687b      	ldr	r3, [r7, #4]
 80041b0:	0018      	movs	r0, r3
 80041b2:	f7ff fd8f 	bl	8003cd4 <HTS221_Get_DataStatus>
 80041b6:	0003      	movs	r3, r0
 80041b8:	2b01      	cmp	r3, #1
 80041ba:	d101      	bne.n	80041c0 <HTS221_H_Get_DRDY_Status+0x24>
  {
    return COMPONENT_ERROR;
 80041bc:	2301      	movs	r3, #1
 80041be:	e011      	b.n	80041e4 <HTS221_H_Get_DRDY_Status+0x48>
  }

  switch( hum_status_raw )
 80041c0:	230f      	movs	r3, #15
 80041c2:	18fb      	adds	r3, r7, r3
 80041c4:	781b      	ldrb	r3, [r3, #0]
 80041c6:	2b00      	cmp	r3, #0
 80041c8:	d005      	beq.n	80041d6 <HTS221_H_Get_DRDY_Status+0x3a>
 80041ca:	2b01      	cmp	r3, #1
 80041cc:	d107      	bne.n	80041de <HTS221_H_Get_DRDY_Status+0x42>
  {
    case HTS221_SET:
      *status = 1;
 80041ce:	683b      	ldr	r3, [r7, #0]
 80041d0:	2201      	movs	r2, #1
 80041d2:	701a      	strb	r2, [r3, #0]
      break;
 80041d4:	e005      	b.n	80041e2 <HTS221_H_Get_DRDY_Status+0x46>
    case HTS221_RESET:
      *status = 0;
 80041d6:	683b      	ldr	r3, [r7, #0]
 80041d8:	2200      	movs	r2, #0
 80041da:	701a      	strb	r2, [r3, #0]
      break;
 80041dc:	e001      	b.n	80041e2 <HTS221_H_Get_DRDY_Status+0x46>
    default:
      return COMPONENT_ERROR;
 80041de:	2301      	movs	r3, #1
 80041e0:	e000      	b.n	80041e4 <HTS221_H_Get_DRDY_Status+0x48>
  }

  return COMPONENT_OK;
 80041e2:	2300      	movs	r3, #0
}
 80041e4:	0018      	movs	r0, r3
 80041e6:	46bd      	mov	sp, r7
 80041e8:	b004      	add	sp, #16
 80041ea:	bd80      	pop	{r7, pc}

080041ec <HTS221_T_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Init( DrvContextTypeDef *handle )
{
 80041ec:	b580      	push	{r7, lr}
 80041ee:	b082      	sub	sp, #8
 80041f0:	af00      	add	r7, sp, #0
 80041f2:	6078      	str	r0, [r7, #4]

  /* Check if the HTS221 humidity sensor is already initialized. */
  /* If yes, skip the initialize function, if not call initialize function */
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 80041f4:	687b      	ldr	r3, [r7, #4]
 80041f6:	689b      	ldr	r3, [r3, #8]
 80041f8:	681b      	ldr	r3, [r3, #0]
 80041fa:	681b      	ldr	r3, [r3, #0]
 80041fc:	781b      	ldrb	r3, [r3, #0]
 80041fe:	2b00      	cmp	r3, #0
 8004200:	d108      	bne.n	8004214 <HTS221_T_Init+0x28>
  {
    if(HTS221_Init(handle) == COMPONENT_ERROR)
 8004202:	687b      	ldr	r3, [r7, #4]
 8004204:	0018      	movs	r0, r3
 8004206:	f000 f945 	bl	8004494 <HTS221_Init>
 800420a:	0003      	movs	r3, r0
 800420c:	2b01      	cmp	r3, #1
 800420e:	d101      	bne.n	8004214 <HTS221_T_Init+0x28>
    {
      return COMPONENT_ERROR;
 8004210:	2301      	movs	r3, #1
 8004212:	e009      	b.n	8004228 <HTS221_T_Init+0x3c>
    }
  }

  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized = 1;
 8004214:	687b      	ldr	r3, [r7, #4]
 8004216:	689b      	ldr	r3, [r3, #8]
 8004218:	681b      	ldr	r3, [r3, #0]
 800421a:	681b      	ldr	r3, [r3, #0]
 800421c:	2201      	movs	r2, #1
 800421e:	705a      	strb	r2, [r3, #1]

  handle->isInitialized = 1;
 8004220:	687b      	ldr	r3, [r7, #4]
 8004222:	2201      	movs	r2, #1
 8004224:	70da      	strb	r2, [r3, #3]

  return COMPONENT_OK;
 8004226:	2300      	movs	r3, #0
}
 8004228:	0018      	movs	r0, r3
 800422a:	46bd      	mov	sp, r7
 800422c:	b002      	add	sp, #8
 800422e:	bd80      	pop	{r7, pc}

08004230 <HTS221_T_DeInit>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_DeInit( DrvContextTypeDef *handle )
{
 8004230:	b580      	push	{r7, lr}
 8004232:	b082      	sub	sp, #8
 8004234:	af00      	add	r7, sp, #0
 8004236:	6078      	str	r0, [r7, #4]

  /* Check if the HTS221 humidity sensor is already initialized. */
  /* If yes, skip the deinitialize function, if not call deinitialize function */
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 8004238:	687b      	ldr	r3, [r7, #4]
 800423a:	689b      	ldr	r3, [r3, #8]
 800423c:	681b      	ldr	r3, [r3, #0]
 800423e:	681b      	ldr	r3, [r3, #0]
 8004240:	781b      	ldrb	r3, [r3, #0]
 8004242:	2b00      	cmp	r3, #0
 8004244:	d108      	bne.n	8004258 <HTS221_T_DeInit+0x28>
  {
    if(HTS221_T_Sensor_Disable(handle) == COMPONENT_ERROR)
 8004246:	687b      	ldr	r3, [r7, #4]
 8004248:	0018      	movs	r0, r3
 800424a:	f000 f83b 	bl	80042c4 <HTS221_T_Sensor_Disable>
 800424e:	0003      	movs	r3, r0
 8004250:	2b01      	cmp	r3, #1
 8004252:	d101      	bne.n	8004258 <HTS221_T_DeInit+0x28>
    {
      return COMPONENT_ERROR;
 8004254:	2301      	movs	r3, #1
 8004256:	e009      	b.n	800426c <HTS221_T_DeInit+0x3c>
    }
  }

  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized = 0;
 8004258:	687b      	ldr	r3, [r7, #4]
 800425a:	689b      	ldr	r3, [r3, #8]
 800425c:	681b      	ldr	r3, [r3, #0]
 800425e:	681b      	ldr	r3, [r3, #0]
 8004260:	2200      	movs	r2, #0
 8004262:	705a      	strb	r2, [r3, #1]

  handle->isInitialized = 0;
 8004264:	687b      	ldr	r3, [r7, #4]
 8004266:	2200      	movs	r2, #0
 8004268:	70da      	strb	r2, [r3, #3]

  return COMPONENT_OK;
 800426a:	2300      	movs	r3, #0
}
 800426c:	0018      	movs	r0, r3
 800426e:	46bd      	mov	sp, r7
 8004270:	b002      	add	sp, #8
 8004272:	bd80      	pop	{r7, pc}

08004274 <HTS221_T_Sensor_Enable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Sensor_Enable( DrvContextTypeDef *handle )
{
 8004274:	b580      	push	{r7, lr}
 8004276:	b082      	sub	sp, #8
 8004278:	af00      	add	r7, sp, #0
 800427a:	6078      	str	r0, [r7, #4]

  /* Check if the component is already enabled */
  if ( handle->isEnabled == 1 )
 800427c:	687b      	ldr	r3, [r7, #4]
 800427e:	791b      	ldrb	r3, [r3, #4]
 8004280:	2b01      	cmp	r3, #1
 8004282:	d101      	bne.n	8004288 <HTS221_T_Sensor_Enable+0x14>
  {
    return COMPONENT_OK;
 8004284:	2300      	movs	r3, #0
 8004286:	e019      	b.n	80042bc <HTS221_T_Sensor_Enable+0x48>
  }

  /* Check if the HTS221 humidity sensor is already enabled. */
  /* If yes, skip the enable function, if not call enable function */
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled == 0))
 8004288:	687b      	ldr	r3, [r7, #4]
 800428a:	689b      	ldr	r3, [r3, #8]
 800428c:	681b      	ldr	r3, [r3, #0]
 800428e:	681b      	ldr	r3, [r3, #0]
 8004290:	789b      	ldrb	r3, [r3, #2]
 8004292:	2b00      	cmp	r3, #0
 8004294:	d108      	bne.n	80042a8 <HTS221_T_Sensor_Enable+0x34>
  {
    if(HTS221_Sensor_Enable(handle) == COMPONENT_ERROR)
 8004296:	687b      	ldr	r3, [r7, #4]
 8004298:	0018      	movs	r0, r3
 800429a:	f000 f92a 	bl	80044f2 <HTS221_Sensor_Enable>
 800429e:	0003      	movs	r3, r0
 80042a0:	2b01      	cmp	r3, #1
 80042a2:	d101      	bne.n	80042a8 <HTS221_T_Sensor_Enable+0x34>
    {
      return COMPONENT_ERROR;
 80042a4:	2301      	movs	r3, #1
 80042a6:	e009      	b.n	80042bc <HTS221_T_Sensor_Enable+0x48>
    }
  }

  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled = 1;
 80042a8:	687b      	ldr	r3, [r7, #4]
 80042aa:	689b      	ldr	r3, [r3, #8]
 80042ac:	681b      	ldr	r3, [r3, #0]
 80042ae:	681b      	ldr	r3, [r3, #0]
 80042b0:	2201      	movs	r2, #1
 80042b2:	70da      	strb	r2, [r3, #3]

  handle->isEnabled = 1;
 80042b4:	687b      	ldr	r3, [r7, #4]
 80042b6:	2201      	movs	r2, #1
 80042b8:	711a      	strb	r2, [r3, #4]

  return COMPONENT_OK;
 80042ba:	2300      	movs	r3, #0
}
 80042bc:	0018      	movs	r0, r3
 80042be:	46bd      	mov	sp, r7
 80042c0:	b002      	add	sp, #8
 80042c2:	bd80      	pop	{r7, pc}

080042c4 <HTS221_T_Sensor_Disable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Sensor_Disable( DrvContextTypeDef *handle )
{
 80042c4:	b580      	push	{r7, lr}
 80042c6:	b082      	sub	sp, #8
 80042c8:	af00      	add	r7, sp, #0
 80042ca:	6078      	str	r0, [r7, #4]

  /* Check if the component is already disabled */
  if ( handle->isEnabled == 0 )
 80042cc:	687b      	ldr	r3, [r7, #4]
 80042ce:	791b      	ldrb	r3, [r3, #4]
 80042d0:	2b00      	cmp	r3, #0
 80042d2:	d101      	bne.n	80042d8 <HTS221_T_Sensor_Disable+0x14>
  {
    return COMPONENT_OK;
 80042d4:	2300      	movs	r3, #0
 80042d6:	e019      	b.n	800430c <HTS221_T_Sensor_Disable+0x48>
  }

  /* Check if the HTS221 humidity sensor is still enabled. */
  /* If yes, skip the disable function, if not call disable function */
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled == 0))
 80042d8:	687b      	ldr	r3, [r7, #4]
 80042da:	689b      	ldr	r3, [r3, #8]
 80042dc:	681b      	ldr	r3, [r3, #0]
 80042de:	681b      	ldr	r3, [r3, #0]
 80042e0:	789b      	ldrb	r3, [r3, #2]
 80042e2:	2b00      	cmp	r3, #0
 80042e4:	d108      	bne.n	80042f8 <HTS221_T_Sensor_Disable+0x34>
  {
    if(HTS221_Sensor_Disable(handle) == COMPONENT_ERROR)
 80042e6:	687b      	ldr	r3, [r7, #4]
 80042e8:	0018      	movs	r0, r3
 80042ea:	f000 f914 	bl	8004516 <HTS221_Sensor_Disable>
 80042ee:	0003      	movs	r3, r0
 80042f0:	2b01      	cmp	r3, #1
 80042f2:	d101      	bne.n	80042f8 <HTS221_T_Sensor_Disable+0x34>
    {
      return COMPONENT_ERROR;
 80042f4:	2301      	movs	r3, #1
 80042f6:	e009      	b.n	800430c <HTS221_T_Sensor_Disable+0x48>
    }
  }

  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled = 0;
 80042f8:	687b      	ldr	r3, [r7, #4]
 80042fa:	689b      	ldr	r3, [r3, #8]
 80042fc:	681b      	ldr	r3, [r3, #0]
 80042fe:	681b      	ldr	r3, [r3, #0]
 8004300:	2200      	movs	r2, #0
 8004302:	70da      	strb	r2, [r3, #3]

  handle->isEnabled = 0;
 8004304:	687b      	ldr	r3, [r7, #4]
 8004306:	2200      	movs	r2, #0
 8004308:	711a      	strb	r2, [r3, #4]

  return COMPONENT_OK;
 800430a:	2300      	movs	r3, #0
}
 800430c:	0018      	movs	r0, r3
 800430e:	46bd      	mov	sp, r7
 8004310:	b002      	add	sp, #8
 8004312:	bd80      	pop	{r7, pc}

08004314 <HTS221_T_Get_WhoAmI>:
 * @param who_am_i pointer to the value of WHO_AM_I register
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Get_WhoAmI( DrvContextTypeDef *handle, uint8_t *who_am_i )
{
 8004314:	b580      	push	{r7, lr}
 8004316:	b082      	sub	sp, #8
 8004318:	af00      	add	r7, sp, #0
 800431a:	6078      	str	r0, [r7, #4]
 800431c:	6039      	str	r1, [r7, #0]

  return HTS221_Get_WhoAmI( handle, who_am_i );
 800431e:	683a      	ldr	r2, [r7, #0]
 8004320:	687b      	ldr	r3, [r7, #4]
 8004322:	0011      	movs	r1, r2
 8004324:	0018      	movs	r0, r3
 8004326:	f000 f908 	bl	800453a <HTS221_Get_WhoAmI>
 800432a:	0003      	movs	r3, r0
}
 800432c:	0018      	movs	r0, r3
 800432e:	46bd      	mov	sp, r7
 8004330:	b002      	add	sp, #8
 8004332:	bd80      	pop	{r7, pc}

08004334 <HTS221_T_Check_WhoAmI>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Check_WhoAmI( DrvContextTypeDef *handle )
{
 8004334:	b580      	push	{r7, lr}
 8004336:	b082      	sub	sp, #8
 8004338:	af00      	add	r7, sp, #0
 800433a:	6078      	str	r0, [r7, #4]

  return HTS221_Check_WhoAmI( handle );
 800433c:	687b      	ldr	r3, [r7, #4]
 800433e:	0018      	movs	r0, r3
 8004340:	f000 f910 	bl	8004564 <HTS221_Check_WhoAmI>
 8004344:	0003      	movs	r3, r0
}
 8004346:	0018      	movs	r0, r3
 8004348:	46bd      	mov	sp, r7
 800434a:	b002      	add	sp, #8
 800434c:	bd80      	pop	{r7, pc}

0800434e <HTS221_T_Get_Temp>:
 * @param temperature pointer where the value is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Get_Temp( DrvContextTypeDef *handle, float *temperature )
{
 800434e:	b580      	push	{r7, lr}
 8004350:	b082      	sub	sp, #8
 8004352:	af00      	add	r7, sp, #0
 8004354:	6078      	str	r0, [r7, #4]
 8004356:	6039      	str	r1, [r7, #0]

  return HTS221_Get_Temp( handle, temperature );
 8004358:	683a      	ldr	r2, [r7, #0]
 800435a:	687b      	ldr	r3, [r7, #4]
 800435c:	0011      	movs	r1, r2
 800435e:	0018      	movs	r0, r3
 8004360:	f000 f94c 	bl	80045fc <HTS221_Get_Temp>
 8004364:	0003      	movs	r3, r0
}
 8004366:	0018      	movs	r0, r3
 8004368:	46bd      	mov	sp, r7
 800436a:	b002      	add	sp, #8
 800436c:	bd80      	pop	{r7, pc}

0800436e <HTS221_T_Get_ODR>:
 * @param odr pointer where the output data rate is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Get_ODR( DrvContextTypeDef *handle, float *odr )
{
 800436e:	b580      	push	{r7, lr}
 8004370:	b082      	sub	sp, #8
 8004372:	af00      	add	r7, sp, #0
 8004374:	6078      	str	r0, [r7, #4]
 8004376:	6039      	str	r1, [r7, #0]

  return HTS221_Get_ODR( handle, odr );
 8004378:	683a      	ldr	r2, [r7, #0]
 800437a:	687b      	ldr	r3, [r7, #4]
 800437c:	0011      	movs	r1, r2
 800437e:	0018      	movs	r0, r3
 8004380:	f000 f968 	bl	8004654 <HTS221_Get_ODR>
 8004384:	0003      	movs	r3, r0
}
 8004386:	0018      	movs	r0, r3
 8004388:	46bd      	mov	sp, r7
 800438a:	b002      	add	sp, #8
 800438c:	bd80      	pop	{r7, pc}

0800438e <HTS221_T_Set_ODR>:
 * @param odr the functional output data rate to be set
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Set_ODR( DrvContextTypeDef *handle, SensorOdr_t odr )
{
 800438e:	b580      	push	{r7, lr}
 8004390:	b082      	sub	sp, #8
 8004392:	af00      	add	r7, sp, #0
 8004394:	6078      	str	r0, [r7, #4]
 8004396:	000a      	movs	r2, r1
 8004398:	1cfb      	adds	r3, r7, #3
 800439a:	701a      	strb	r2, [r3, #0]

  return HTS221_Set_ODR( handle, odr );
 800439c:	1cfb      	adds	r3, r7, #3
 800439e:	781a      	ldrb	r2, [r3, #0]
 80043a0:	687b      	ldr	r3, [r7, #4]
 80043a2:	0011      	movs	r1, r2
 80043a4:	0018      	movs	r0, r3
 80043a6:	f000 f995 	bl	80046d4 <HTS221_Set_ODR>
 80043aa:	0003      	movs	r3, r0
}
 80043ac:	0018      	movs	r0, r3
 80043ae:	46bd      	mov	sp, r7
 80043b0:	b002      	add	sp, #8
 80043b2:	bd80      	pop	{r7, pc}

080043b4 <HTS221_T_Set_ODR_Value>:
 * @param odr the output data rate value to be set
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Set_ODR_Value( DrvContextTypeDef *handle, float odr )
{
 80043b4:	b580      	push	{r7, lr}
 80043b6:	b082      	sub	sp, #8
 80043b8:	af00      	add	r7, sp, #0
 80043ba:	6078      	str	r0, [r7, #4]
 80043bc:	6039      	str	r1, [r7, #0]

  return HTS221_Set_ODR_Value( handle, odr );
 80043be:	683a      	ldr	r2, [r7, #0]
 80043c0:	687b      	ldr	r3, [r7, #4]
 80043c2:	1c11      	adds	r1, r2, #0
 80043c4:	0018      	movs	r0, r3
 80043c6:	f000 f9c5 	bl	8004754 <HTS221_Set_ODR_Value>
 80043ca:	0003      	movs	r3, r0
}
 80043cc:	0018      	movs	r0, r3
 80043ce:	46bd      	mov	sp, r7
 80043d0:	b002      	add	sp, #8
 80043d2:	bd80      	pop	{r7, pc}

080043d4 <HTS221_T_Read_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Read_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t *data )
{
 80043d4:	b580      	push	{r7, lr}
 80043d6:	b084      	sub	sp, #16
 80043d8:	af00      	add	r7, sp, #0
 80043da:	60f8      	str	r0, [r7, #12]
 80043dc:	607a      	str	r2, [r7, #4]
 80043de:	200b      	movs	r0, #11
 80043e0:	183b      	adds	r3, r7, r0
 80043e2:	1c0a      	adds	r2, r1, #0
 80043e4:	701a      	strb	r2, [r3, #0]

  if ( HTS221_Read_Reg( handle, reg, data ) == COMPONENT_ERROR )
 80043e6:	687a      	ldr	r2, [r7, #4]
 80043e8:	183b      	adds	r3, r7, r0
 80043ea:	7819      	ldrb	r1, [r3, #0]
 80043ec:	68fb      	ldr	r3, [r7, #12]
 80043ee:	0018      	movs	r0, r3
 80043f0:	f000 f9de 	bl	80047b0 <HTS221_Read_Reg>
 80043f4:	0003      	movs	r3, r0
 80043f6:	2b01      	cmp	r3, #1
 80043f8:	d101      	bne.n	80043fe <HTS221_T_Read_Reg+0x2a>
  {
    return COMPONENT_ERROR;
 80043fa:	2301      	movs	r3, #1
 80043fc:	e000      	b.n	8004400 <HTS221_T_Read_Reg+0x2c>
  }

  return COMPONENT_OK;
 80043fe:	2300      	movs	r3, #0
}
 8004400:	0018      	movs	r0, r3
 8004402:	46bd      	mov	sp, r7
 8004404:	b004      	add	sp, #16
 8004406:	bd80      	pop	{r7, pc}

08004408 <HTS221_T_Write_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Write_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t data )
{
 8004408:	b580      	push	{r7, lr}
 800440a:	b082      	sub	sp, #8
 800440c:	af00      	add	r7, sp, #0
 800440e:	6078      	str	r0, [r7, #4]
 8004410:	0008      	movs	r0, r1
 8004412:	0011      	movs	r1, r2
 8004414:	1cfb      	adds	r3, r7, #3
 8004416:	1c02      	adds	r2, r0, #0
 8004418:	701a      	strb	r2, [r3, #0]
 800441a:	1cbb      	adds	r3, r7, #2
 800441c:	1c0a      	adds	r2, r1, #0
 800441e:	701a      	strb	r2, [r3, #0]

  if ( HTS221_Write_Reg( handle, reg, data ) == COMPONENT_ERROR )
 8004420:	1cbb      	adds	r3, r7, #2
 8004422:	781a      	ldrb	r2, [r3, #0]
 8004424:	1cfb      	adds	r3, r7, #3
 8004426:	7819      	ldrb	r1, [r3, #0]
 8004428:	687b      	ldr	r3, [r7, #4]
 800442a:	0018      	movs	r0, r3
 800442c:	f000 f9db 	bl	80047e6 <HTS221_Write_Reg>
 8004430:	0003      	movs	r3, r0
 8004432:	2b01      	cmp	r3, #1
 8004434:	d101      	bne.n	800443a <HTS221_T_Write_Reg+0x32>
  {
    return COMPONENT_ERROR;
 8004436:	2301      	movs	r3, #1
 8004438:	e000      	b.n	800443c <HTS221_T_Write_Reg+0x34>
  }

  return COMPONENT_OK;
 800443a:	2300      	movs	r3, #0
}
 800443c:	0018      	movs	r0, r3
 800443e:	46bd      	mov	sp, r7
 8004440:	b002      	add	sp, #8
 8004442:	bd80      	pop	{r7, pc}

08004444 <HTS221_T_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 8004444:	b580      	push	{r7, lr}
 8004446:	b084      	sub	sp, #16
 8004448:	af00      	add	r7, sp, #0
 800444a:	6078      	str	r0, [r7, #4]
 800444c:	6039      	str	r1, [r7, #0]

  HTS221_BitStatus_et hum_status_raw;
  HTS221_BitStatus_et temp_status_raw;

  if ( HTS221_Get_DataStatus( (void *)handle, &hum_status_raw, &temp_status_raw ) == HTS221_ERROR )
 800444e:	230e      	movs	r3, #14
 8004450:	18fa      	adds	r2, r7, r3
 8004452:	230f      	movs	r3, #15
 8004454:	18f9      	adds	r1, r7, r3
 8004456:	687b      	ldr	r3, [r7, #4]
 8004458:	0018      	movs	r0, r3
 800445a:	f7ff fc3b 	bl	8003cd4 <HTS221_Get_DataStatus>
 800445e:	0003      	movs	r3, r0
 8004460:	2b01      	cmp	r3, #1
 8004462:	d101      	bne.n	8004468 <HTS221_T_Get_DRDY_Status+0x24>
  {
    return COMPONENT_ERROR;
 8004464:	2301      	movs	r3, #1
 8004466:	e011      	b.n	800448c <HTS221_T_Get_DRDY_Status+0x48>
  }

  switch( temp_status_raw )
 8004468:	230e      	movs	r3, #14
 800446a:	18fb      	adds	r3, r7, r3
 800446c:	781b      	ldrb	r3, [r3, #0]
 800446e:	2b00      	cmp	r3, #0
 8004470:	d005      	beq.n	800447e <HTS221_T_Get_DRDY_Status+0x3a>
 8004472:	2b01      	cmp	r3, #1
 8004474:	d107      	bne.n	8004486 <HTS221_T_Get_DRDY_Status+0x42>
  {
    case HTS221_SET:
      *status = 1;
 8004476:	683b      	ldr	r3, [r7, #0]
 8004478:	2201      	movs	r2, #1
 800447a:	701a      	strb	r2, [r3, #0]
      break;
 800447c:	e005      	b.n	800448a <HTS221_T_Get_DRDY_Status+0x46>
    case HTS221_RESET:
      *status = 0;
 800447e:	683b      	ldr	r3, [r7, #0]
 8004480:	2200      	movs	r2, #0
 8004482:	701a      	strb	r2, [r3, #0]
      break;
 8004484:	e001      	b.n	800448a <HTS221_T_Get_DRDY_Status+0x46>
    default:
      return COMPONENT_ERROR;
 8004486:	2301      	movs	r3, #1
 8004488:	e000      	b.n	800448c <HTS221_T_Get_DRDY_Status+0x48>
  }

  return COMPONENT_OK;
 800448a:	2300      	movs	r3, #0
}
 800448c:	0018      	movs	r0, r3
 800448e:	46bd      	mov	sp, r7
 8004490:	b004      	add	sp, #16
 8004492:	bd80      	pop	{r7, pc}

08004494 <HTS221_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Init( DrvContextTypeDef *handle )
{
 8004494:	b580      	push	{r7, lr}
 8004496:	b082      	sub	sp, #8
 8004498:	af00      	add	r7, sp, #0
 800449a:	6078      	str	r0, [r7, #4]

  if ( HTS221_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 800449c:	687b      	ldr	r3, [r7, #4]
 800449e:	0018      	movs	r0, r3
 80044a0:	f000 f860 	bl	8004564 <HTS221_Check_WhoAmI>
 80044a4:	0003      	movs	r3, r0
 80044a6:	2b01      	cmp	r3, #1
 80044a8:	d101      	bne.n	80044ae <HTS221_Init+0x1a>
  {
    return COMPONENT_ERROR;
 80044aa:	2301      	movs	r3, #1
 80044ac:	e01d      	b.n	80044ea <HTS221_Init+0x56>
  }

  /* Power down the device */
  if ( HTS221_DeActivate( (void *)handle ) == HTS221_ERROR )
 80044ae:	687b      	ldr	r3, [r7, #4]
 80044b0:	0018      	movs	r0, r3
 80044b2:	f7ff fc5c 	bl	8003d6e <HTS221_DeActivate>
 80044b6:	0003      	movs	r3, r0
 80044b8:	2b01      	cmp	r3, #1
 80044ba:	d101      	bne.n	80044c0 <HTS221_Init+0x2c>
  {
    return COMPONENT_ERROR;
 80044bc:	2301      	movs	r3, #1
 80044be:	e014      	b.n	80044ea <HTS221_Init+0x56>
  }

  /* Enable BDU */
  if ( HTS221_Set_BduMode( (void *)handle, HTS221_ENABLE ) == HTS221_ERROR )
 80044c0:	687b      	ldr	r3, [r7, #4]
 80044c2:	2101      	movs	r1, #1
 80044c4:	0018      	movs	r0, r3
 80044c6:	f7ff fc79 	bl	8003dbc <HTS221_Set_BduMode>
 80044ca:	0003      	movs	r3, r0
 80044cc:	2b01      	cmp	r3, #1
 80044ce:	d101      	bne.n	80044d4 <HTS221_Init+0x40>
  {
    return COMPONENT_ERROR;
 80044d0:	2301      	movs	r3, #1
 80044d2:	e00a      	b.n	80044ea <HTS221_Init+0x56>
  }

  /* Set default ODR */
  if ( HTS221_Set_ODR( handle, ODR_LOW ) == COMPONENT_ERROR )
 80044d4:	687b      	ldr	r3, [r7, #4]
 80044d6:	2100      	movs	r1, #0
 80044d8:	0018      	movs	r0, r3
 80044da:	f000 f8fb 	bl	80046d4 <HTS221_Set_ODR>
 80044de:	0003      	movs	r3, r0
 80044e0:	2b01      	cmp	r3, #1
 80044e2:	d101      	bne.n	80044e8 <HTS221_Init+0x54>
  {
    return COMPONENT_ERROR;
 80044e4:	2301      	movs	r3, #1
 80044e6:	e000      	b.n	80044ea <HTS221_Init+0x56>
  }

  return COMPONENT_OK;
 80044e8:	2300      	movs	r3, #0
}
 80044ea:	0018      	movs	r0, r3
 80044ec:	46bd      	mov	sp, r7
 80044ee:	b002      	add	sp, #8
 80044f0:	bd80      	pop	{r7, pc}

080044f2 <HTS221_Sensor_Enable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Sensor_Enable( DrvContextTypeDef *handle )
{
 80044f2:	b580      	push	{r7, lr}
 80044f4:	b082      	sub	sp, #8
 80044f6:	af00      	add	r7, sp, #0
 80044f8:	6078      	str	r0, [r7, #4]

  /* Power up the device */
  if ( HTS221_Activate( (void *)handle ) == HTS221_ERROR )
 80044fa:	687b      	ldr	r3, [r7, #4]
 80044fc:	0018      	movs	r0, r3
 80044fe:	f7ff fc0f 	bl	8003d20 <HTS221_Activate>
 8004502:	0003      	movs	r3, r0
 8004504:	2b01      	cmp	r3, #1
 8004506:	d101      	bne.n	800450c <HTS221_Sensor_Enable+0x1a>
  {
    return COMPONENT_ERROR;
 8004508:	2301      	movs	r3, #1
 800450a:	e000      	b.n	800450e <HTS221_Sensor_Enable+0x1c>
  }

  return COMPONENT_OK;
 800450c:	2300      	movs	r3, #0
}
 800450e:	0018      	movs	r0, r3
 8004510:	46bd      	mov	sp, r7
 8004512:	b002      	add	sp, #8
 8004514:	bd80      	pop	{r7, pc}

08004516 <HTS221_Sensor_Disable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Sensor_Disable( DrvContextTypeDef *handle )
{
 8004516:	b580      	push	{r7, lr}
 8004518:	b082      	sub	sp, #8
 800451a:	af00      	add	r7, sp, #0
 800451c:	6078      	str	r0, [r7, #4]

  /* Power down the device */
  if ( HTS221_DeActivate( (void *)handle ) == HTS221_ERROR )
 800451e:	687b      	ldr	r3, [r7, #4]
 8004520:	0018      	movs	r0, r3
 8004522:	f7ff fc24 	bl	8003d6e <HTS221_DeActivate>
 8004526:	0003      	movs	r3, r0
 8004528:	2b01      	cmp	r3, #1
 800452a:	d101      	bne.n	8004530 <HTS221_Sensor_Disable+0x1a>
  {
    return COMPONENT_ERROR;
 800452c:	2301      	movs	r3, #1
 800452e:	e000      	b.n	8004532 <HTS221_Sensor_Disable+0x1c>
  }

  return COMPONENT_OK;
 8004530:	2300      	movs	r3, #0
}
 8004532:	0018      	movs	r0, r3
 8004534:	46bd      	mov	sp, r7
 8004536:	b002      	add	sp, #8
 8004538:	bd80      	pop	{r7, pc}

0800453a <HTS221_Get_WhoAmI>:
 * @param who_am_i pointer to the value of WHO_AM_I register
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Get_WhoAmI( DrvContextTypeDef *handle, uint8_t *who_am_i )
{
 800453a:	b580      	push	{r7, lr}
 800453c:	b082      	sub	sp, #8
 800453e:	af00      	add	r7, sp, #0
 8004540:	6078      	str	r0, [r7, #4]
 8004542:	6039      	str	r1, [r7, #0]

  /* Read WHO AM I register */
  if ( HTS221_Get_DeviceID( (void *)handle, who_am_i ) == HTS221_ERROR )
 8004544:	683a      	ldr	r2, [r7, #0]
 8004546:	687b      	ldr	r3, [r7, #4]
 8004548:	0011      	movs	r1, r2
 800454a:	0018      	movs	r0, r3
 800454c:	f7ff fa15 	bl	800397a <HTS221_Get_DeviceID>
 8004550:	0003      	movs	r3, r0
 8004552:	2b01      	cmp	r3, #1
 8004554:	d101      	bne.n	800455a <HTS221_Get_WhoAmI+0x20>
  {
    return COMPONENT_ERROR;
 8004556:	2301      	movs	r3, #1
 8004558:	e000      	b.n	800455c <HTS221_Get_WhoAmI+0x22>
  }

  return COMPONENT_OK;
 800455a:	2300      	movs	r3, #0
}
 800455c:	0018      	movs	r0, r3
 800455e:	46bd      	mov	sp, r7
 8004560:	b002      	add	sp, #8
 8004562:	bd80      	pop	{r7, pc}

08004564 <HTS221_Check_WhoAmI>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Check_WhoAmI( DrvContextTypeDef *handle )
{
 8004564:	b580      	push	{r7, lr}
 8004566:	b084      	sub	sp, #16
 8004568:	af00      	add	r7, sp, #0
 800456a:	6078      	str	r0, [r7, #4]

  uint8_t who_am_i = 0x00;
 800456c:	210f      	movs	r1, #15
 800456e:	187b      	adds	r3, r7, r1
 8004570:	2200      	movs	r2, #0
 8004572:	701a      	strb	r2, [r3, #0]

  if ( HTS221_Get_WhoAmI( handle, &who_am_i ) == COMPONENT_ERROR )
 8004574:	187a      	adds	r2, r7, r1
 8004576:	687b      	ldr	r3, [r7, #4]
 8004578:	0011      	movs	r1, r2
 800457a:	0018      	movs	r0, r3
 800457c:	f7ff ffdd 	bl	800453a <HTS221_Get_WhoAmI>
 8004580:	0003      	movs	r3, r0
 8004582:	2b01      	cmp	r3, #1
 8004584:	d101      	bne.n	800458a <HTS221_Check_WhoAmI+0x26>
  {
    return COMPONENT_ERROR;
 8004586:	2301      	movs	r3, #1
 8004588:	e009      	b.n	800459e <HTS221_Check_WhoAmI+0x3a>
  }
  if ( who_am_i != handle->who_am_i )
 800458a:	687b      	ldr	r3, [r7, #4]
 800458c:	781a      	ldrb	r2, [r3, #0]
 800458e:	230f      	movs	r3, #15
 8004590:	18fb      	adds	r3, r7, r3
 8004592:	781b      	ldrb	r3, [r3, #0]
 8004594:	429a      	cmp	r2, r3
 8004596:	d001      	beq.n	800459c <HTS221_Check_WhoAmI+0x38>
  {
    return COMPONENT_ERROR;
 8004598:	2301      	movs	r3, #1
 800459a:	e000      	b.n	800459e <HTS221_Check_WhoAmI+0x3a>
  }

  return COMPONENT_OK;
 800459c:	2300      	movs	r3, #0
}
 800459e:	0018      	movs	r0, r3
 80045a0:	46bd      	mov	sp, r7
 80045a2:	b004      	add	sp, #16
 80045a4:	bd80      	pop	{r7, pc}
	...

080045a8 <HTS221_Get_Hum>:
 * @param humidity pointer where the value is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Get_Hum( DrvContextTypeDef *handle, float *humidity )
{
 80045a8:	b580      	push	{r7, lr}
 80045aa:	b084      	sub	sp, #16
 80045ac:	af00      	add	r7, sp, #0
 80045ae:	6078      	str	r0, [r7, #4]
 80045b0:	6039      	str	r1, [r7, #0]

  uint16_t uint16data = 0;
 80045b2:	210e      	movs	r1, #14
 80045b4:	187b      	adds	r3, r7, r1
 80045b6:	2200      	movs	r2, #0
 80045b8:	801a      	strh	r2, [r3, #0]

  /* Read data from HTS221. */
  if ( HTS221_Get_Humidity( (void *)handle, &uint16data ) == HTS221_ERROR )
 80045ba:	187a      	adds	r2, r7, r1
 80045bc:	687b      	ldr	r3, [r7, #4]
 80045be:	0011      	movs	r1, r2
 80045c0:	0018      	movs	r0, r3
 80045c2:	f7ff f9ef 	bl	80039a4 <HTS221_Get_Humidity>
 80045c6:	0003      	movs	r3, r0
 80045c8:	2b01      	cmp	r3, #1
 80045ca:	d101      	bne.n	80045d0 <HTS221_Get_Hum+0x28>
  {
    return COMPONENT_ERROR;
 80045cc:	2301      	movs	r3, #1
 80045ce:	e00f      	b.n	80045f0 <HTS221_Get_Hum+0x48>
  }

  *humidity = ( float )uint16data / 10.0f;
 80045d0:	230e      	movs	r3, #14
 80045d2:	18fb      	adds	r3, r7, r3
 80045d4:	881b      	ldrh	r3, [r3, #0]
 80045d6:	0018      	movs	r0, r3
 80045d8:	f7fc ff5e 	bl	8001498 <__aeabi_ui2f>
 80045dc:	1c03      	adds	r3, r0, #0
 80045de:	4906      	ldr	r1, [pc, #24]	; (80045f8 <HTS221_Get_Hum+0x50>)
 80045e0:	1c18      	adds	r0, r3, #0
 80045e2:	f7fc fa47 	bl	8000a74 <__aeabi_fdiv>
 80045e6:	1c03      	adds	r3, r0, #0
 80045e8:	1c1a      	adds	r2, r3, #0
 80045ea:	683b      	ldr	r3, [r7, #0]
 80045ec:	601a      	str	r2, [r3, #0]

  return COMPONENT_OK;
 80045ee:	2300      	movs	r3, #0
}
 80045f0:	0018      	movs	r0, r3
 80045f2:	46bd      	mov	sp, r7
 80045f4:	b004      	add	sp, #16
 80045f6:	bd80      	pop	{r7, pc}
 80045f8:	41200000 	.word	0x41200000

080045fc <HTS221_Get_Temp>:
 * @param temperature pointer where the value is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Get_Temp( DrvContextTypeDef *handle, float *temperature )
{
 80045fc:	b580      	push	{r7, lr}
 80045fe:	b084      	sub	sp, #16
 8004600:	af00      	add	r7, sp, #0
 8004602:	6078      	str	r0, [r7, #4]
 8004604:	6039      	str	r1, [r7, #0]

  int16_t int16data = 0;
 8004606:	210e      	movs	r1, #14
 8004608:	187b      	adds	r3, r7, r1
 800460a:	2200      	movs	r2, #0
 800460c:	801a      	strh	r2, [r3, #0]

  /* Read data from HTS221. */
  if ( HTS221_Get_Temperature( (void *)handle, &int16data ) == HTS221_ERROR )
 800460e:	187a      	adds	r2, r7, r1
 8004610:	687b      	ldr	r3, [r7, #4]
 8004612:	0011      	movs	r1, r2
 8004614:	0018      	movs	r0, r3
 8004616:	f7ff fa8b 	bl	8003b30 <HTS221_Get_Temperature>
 800461a:	0003      	movs	r3, r0
 800461c:	2b01      	cmp	r3, #1
 800461e:	d101      	bne.n	8004624 <HTS221_Get_Temp+0x28>
  {
    return COMPONENT_ERROR;
 8004620:	2301      	movs	r3, #1
 8004622:	e010      	b.n	8004646 <HTS221_Get_Temp+0x4a>
  }

  *temperature = ( float )int16data / 10.0f;
 8004624:	230e      	movs	r3, #14
 8004626:	18fb      	adds	r3, r7, r3
 8004628:	2200      	movs	r2, #0
 800462a:	5e9b      	ldrsh	r3, [r3, r2]
 800462c:	0018      	movs	r0, r3
 800462e:	f7fc feed 	bl	800140c <__aeabi_i2f>
 8004632:	1c03      	adds	r3, r0, #0
 8004634:	4906      	ldr	r1, [pc, #24]	; (8004650 <HTS221_Get_Temp+0x54>)
 8004636:	1c18      	adds	r0, r3, #0
 8004638:	f7fc fa1c 	bl	8000a74 <__aeabi_fdiv>
 800463c:	1c03      	adds	r3, r0, #0
 800463e:	1c1a      	adds	r2, r3, #0
 8004640:	683b      	ldr	r3, [r7, #0]
 8004642:	601a      	str	r2, [r3, #0]

  return COMPONENT_OK;
 8004644:	2300      	movs	r3, #0
}
 8004646:	0018      	movs	r0, r3
 8004648:	46bd      	mov	sp, r7
 800464a:	b004      	add	sp, #16
 800464c:	bd80      	pop	{r7, pc}
 800464e:	46c0      	nop			; (mov r8, r8)
 8004650:	41200000 	.word	0x41200000

08004654 <HTS221_Get_ODR>:
 * @param odr pointer where the output data rate is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Get_ODR( DrvContextTypeDef *handle, float *odr )
{
 8004654:	b580      	push	{r7, lr}
 8004656:	b084      	sub	sp, #16
 8004658:	af00      	add	r7, sp, #0
 800465a:	6078      	str	r0, [r7, #4]
 800465c:	6039      	str	r1, [r7, #0]

  HTS221_Odr_et odr_low_level;

  if ( HTS221_Get_Odr( (void *)handle, &odr_low_level ) == HTS221_ERROR )
 800465e:	230f      	movs	r3, #15
 8004660:	18fa      	adds	r2, r7, r3
 8004662:	687b      	ldr	r3, [r7, #4]
 8004664:	0011      	movs	r1, r2
 8004666:	0018      	movs	r0, r3
 8004668:	f7ff fc3c 	bl	8003ee4 <HTS221_Get_Odr>
 800466c:	0003      	movs	r3, r0
 800466e:	2b01      	cmp	r3, #1
 8004670:	d101      	bne.n	8004676 <HTS221_Get_ODR+0x22>
  {
    return COMPONENT_ERROR;
 8004672:	2301      	movs	r3, #1
 8004674:	e024      	b.n	80046c0 <HTS221_Get_ODR+0x6c>
  }

  switch( odr_low_level )
 8004676:	230f      	movs	r3, #15
 8004678:	18fb      	adds	r3, r7, r3
 800467a:	781b      	ldrb	r3, [r3, #0]
 800467c:	2b03      	cmp	r3, #3
 800467e:	d015      	beq.n	80046ac <HTS221_Get_ODR+0x58>
 8004680:	dc18      	bgt.n	80046b4 <HTS221_Get_ODR+0x60>
 8004682:	2b02      	cmp	r3, #2
 8004684:	d00e      	beq.n	80046a4 <HTS221_Get_ODR+0x50>
 8004686:	dc15      	bgt.n	80046b4 <HTS221_Get_ODR+0x60>
 8004688:	2b00      	cmp	r3, #0
 800468a:	d002      	beq.n	8004692 <HTS221_Get_ODR+0x3e>
 800468c:	2b01      	cmp	r3, #1
 800468e:	d004      	beq.n	800469a <HTS221_Get_ODR+0x46>
 8004690:	e010      	b.n	80046b4 <HTS221_Get_ODR+0x60>
  {
    case HTS221_ODR_ONE_SHOT:
      *odr =  0.0f;
 8004692:	683b      	ldr	r3, [r7, #0]
 8004694:	2200      	movs	r2, #0
 8004696:	601a      	str	r2, [r3, #0]
      break;
 8004698:	e011      	b.n	80046be <HTS221_Get_ODR+0x6a>
    case HTS221_ODR_1HZ     :
      *odr =  1.0f;
 800469a:	683b      	ldr	r3, [r7, #0]
 800469c:	22fe      	movs	r2, #254	; 0xfe
 800469e:	0592      	lsls	r2, r2, #22
 80046a0:	601a      	str	r2, [r3, #0]
      break;
 80046a2:	e00c      	b.n	80046be <HTS221_Get_ODR+0x6a>
    case HTS221_ODR_7HZ     :
      *odr =  7.0f;
 80046a4:	683b      	ldr	r3, [r7, #0]
 80046a6:	4a08      	ldr	r2, [pc, #32]	; (80046c8 <HTS221_Get_ODR+0x74>)
 80046a8:	601a      	str	r2, [r3, #0]
      break;
 80046aa:	e008      	b.n	80046be <HTS221_Get_ODR+0x6a>
    case HTS221_ODR_12_5HZ  :
      *odr = 12.5f;
 80046ac:	683b      	ldr	r3, [r7, #0]
 80046ae:	4a07      	ldr	r2, [pc, #28]	; (80046cc <HTS221_Get_ODR+0x78>)
 80046b0:	601a      	str	r2, [r3, #0]
      break;
 80046b2:	e004      	b.n	80046be <HTS221_Get_ODR+0x6a>
    default                 :
      *odr = -1.0f;
 80046b4:	683b      	ldr	r3, [r7, #0]
 80046b6:	4a06      	ldr	r2, [pc, #24]	; (80046d0 <HTS221_Get_ODR+0x7c>)
 80046b8:	601a      	str	r2, [r3, #0]
      return COMPONENT_ERROR;
 80046ba:	2301      	movs	r3, #1
 80046bc:	e000      	b.n	80046c0 <HTS221_Get_ODR+0x6c>
  }

  return COMPONENT_OK;
 80046be:	2300      	movs	r3, #0
}
 80046c0:	0018      	movs	r0, r3
 80046c2:	46bd      	mov	sp, r7
 80046c4:	b004      	add	sp, #16
 80046c6:	bd80      	pop	{r7, pc}
 80046c8:	40e00000 	.word	0x40e00000
 80046cc:	41480000 	.word	0x41480000
 80046d0:	bf800000 	.word	0xbf800000

080046d4 <HTS221_Set_ODR>:
 * @param odr the functional output data rate to be set
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Set_ODR( DrvContextTypeDef *handle, SensorOdr_t odr )
{
 80046d4:	b580      	push	{r7, lr}
 80046d6:	b084      	sub	sp, #16
 80046d8:	af00      	add	r7, sp, #0
 80046da:	6078      	str	r0, [r7, #4]
 80046dc:	000a      	movs	r2, r1
 80046de:	1cfb      	adds	r3, r7, #3
 80046e0:	701a      	strb	r2, [r3, #0]

  HTS221_Odr_et new_odr;

  switch( odr )
 80046e2:	1cfb      	adds	r3, r7, #3
 80046e4:	781b      	ldrb	r3, [r3, #0]
 80046e6:	2b04      	cmp	r3, #4
 80046e8:	d81d      	bhi.n	8004726 <HTS221_Set_ODR+0x52>
 80046ea:	009a      	lsls	r2, r3, #2
 80046ec:	4b18      	ldr	r3, [pc, #96]	; (8004750 <HTS221_Set_ODR+0x7c>)
 80046ee:	18d3      	adds	r3, r2, r3
 80046f0:	681b      	ldr	r3, [r3, #0]
 80046f2:	469f      	mov	pc, r3
  {
    case ODR_LOW:
      new_odr = HTS221_ODR_1HZ;
 80046f4:	230f      	movs	r3, #15
 80046f6:	18fb      	adds	r3, r7, r3
 80046f8:	2201      	movs	r2, #1
 80046fa:	701a      	strb	r2, [r3, #0]
      break;
 80046fc:	e015      	b.n	800472a <HTS221_Set_ODR+0x56>
    case ODR_MID_LOW:
      new_odr = HTS221_ODR_12_5HZ;
 80046fe:	230f      	movs	r3, #15
 8004700:	18fb      	adds	r3, r7, r3
 8004702:	2203      	movs	r2, #3
 8004704:	701a      	strb	r2, [r3, #0]
      break;
 8004706:	e010      	b.n	800472a <HTS221_Set_ODR+0x56>
    case ODR_MID:
      new_odr = HTS221_ODR_12_5HZ;
 8004708:	230f      	movs	r3, #15
 800470a:	18fb      	adds	r3, r7, r3
 800470c:	2203      	movs	r2, #3
 800470e:	701a      	strb	r2, [r3, #0]
      break;
 8004710:	e00b      	b.n	800472a <HTS221_Set_ODR+0x56>
    case ODR_MID_HIGH:
      new_odr = HTS221_ODR_12_5HZ;
 8004712:	230f      	movs	r3, #15
 8004714:	18fb      	adds	r3, r7, r3
 8004716:	2203      	movs	r2, #3
 8004718:	701a      	strb	r2, [r3, #0]
      break;
 800471a:	e006      	b.n	800472a <HTS221_Set_ODR+0x56>
    case ODR_HIGH:
      new_odr = HTS221_ODR_12_5HZ;
 800471c:	230f      	movs	r3, #15
 800471e:	18fb      	adds	r3, r7, r3
 8004720:	2203      	movs	r2, #3
 8004722:	701a      	strb	r2, [r3, #0]
      break;
 8004724:	e001      	b.n	800472a <HTS221_Set_ODR+0x56>
    default:
      return COMPONENT_ERROR;
 8004726:	2301      	movs	r3, #1
 8004728:	e00d      	b.n	8004746 <HTS221_Set_ODR+0x72>
  }

  if ( HTS221_Set_Odr( (void *)handle, new_odr ) == HTS221_ERROR )
 800472a:	230f      	movs	r3, #15
 800472c:	18fb      	adds	r3, r7, r3
 800472e:	781a      	ldrb	r2, [r3, #0]
 8004730:	687b      	ldr	r3, [r7, #4]
 8004732:	0011      	movs	r1, r2
 8004734:	0018      	movs	r0, r3
 8004736:	f7ff fb89 	bl	8003e4c <HTS221_Set_Odr>
 800473a:	0003      	movs	r3, r0
 800473c:	2b01      	cmp	r3, #1
 800473e:	d101      	bne.n	8004744 <HTS221_Set_ODR+0x70>
  {
    return COMPONENT_ERROR;
 8004740:	2301      	movs	r3, #1
 8004742:	e000      	b.n	8004746 <HTS221_Set_ODR+0x72>
  }

  return COMPONENT_OK;
 8004744:	2300      	movs	r3, #0
}
 8004746:	0018      	movs	r0, r3
 8004748:	46bd      	mov	sp, r7
 800474a:	b004      	add	sp, #16
 800474c:	bd80      	pop	{r7, pc}
 800474e:	46c0      	nop			; (mov r8, r8)
 8004750:	0801ecc4 	.word	0x0801ecc4

08004754 <HTS221_Set_ODR_Value>:
 * @param odr the output data rate value to be set
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Set_ODR_Value( DrvContextTypeDef *handle, float odr )
{
 8004754:	b580      	push	{r7, lr}
 8004756:	b084      	sub	sp, #16
 8004758:	af00      	add	r7, sp, #0
 800475a:	6078      	str	r0, [r7, #4]
 800475c:	6039      	str	r1, [r7, #0]

  HTS221_Odr_et new_odr;

  new_odr = ( odr <= 1.0f ) ? HTS221_ODR_1HZ
            : ( odr <= 7.0f ) ? HTS221_ODR_7HZ
 800475e:	21fe      	movs	r1, #254	; 0xfe
 8004760:	0589      	lsls	r1, r1, #22
 8004762:	6838      	ldr	r0, [r7, #0]
 8004764:	f7fb feaa 	bl	80004bc <__aeabi_fcmple>
 8004768:	1e03      	subs	r3, r0, #0
 800476a:	d001      	beq.n	8004770 <HTS221_Set_ODR_Value+0x1c>
 800476c:	2301      	movs	r3, #1
 800476e:	e008      	b.n	8004782 <HTS221_Set_ODR_Value+0x2e>
 8004770:	490e      	ldr	r1, [pc, #56]	; (80047ac <HTS221_Set_ODR_Value+0x58>)
 8004772:	6838      	ldr	r0, [r7, #0]
 8004774:	f7fb fea2 	bl	80004bc <__aeabi_fcmple>
 8004778:	1e03      	subs	r3, r0, #0
 800477a:	d001      	beq.n	8004780 <HTS221_Set_ODR_Value+0x2c>
 800477c:	2302      	movs	r3, #2
 800477e:	e000      	b.n	8004782 <HTS221_Set_ODR_Value+0x2e>
 8004780:	2303      	movs	r3, #3
  new_odr = ( odr <= 1.0f ) ? HTS221_ODR_1HZ
 8004782:	210f      	movs	r1, #15
 8004784:	187a      	adds	r2, r7, r1
 8004786:	7013      	strb	r3, [r2, #0]
            :                   HTS221_ODR_12_5HZ;

  if ( HTS221_Set_Odr( (void *)handle, new_odr ) == HTS221_ERROR )
 8004788:	187b      	adds	r3, r7, r1
 800478a:	781a      	ldrb	r2, [r3, #0]
 800478c:	687b      	ldr	r3, [r7, #4]
 800478e:	0011      	movs	r1, r2
 8004790:	0018      	movs	r0, r3
 8004792:	f7ff fb5b 	bl	8003e4c <HTS221_Set_Odr>
 8004796:	0003      	movs	r3, r0
 8004798:	2b01      	cmp	r3, #1
 800479a:	d101      	bne.n	80047a0 <HTS221_Set_ODR_Value+0x4c>
  {
    return COMPONENT_ERROR;
 800479c:	2301      	movs	r3, #1
 800479e:	e000      	b.n	80047a2 <HTS221_Set_ODR_Value+0x4e>
  }

  return COMPONENT_OK;
 80047a0:	2300      	movs	r3, #0
}
 80047a2:	0018      	movs	r0, r3
 80047a4:	46bd      	mov	sp, r7
 80047a6:	b004      	add	sp, #16
 80047a8:	bd80      	pop	{r7, pc}
 80047aa:	46c0      	nop			; (mov r8, r8)
 80047ac:	40e00000 	.word	0x40e00000

080047b0 <HTS221_Read_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Read_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t *data )
{
 80047b0:	b580      	push	{r7, lr}
 80047b2:	b084      	sub	sp, #16
 80047b4:	af00      	add	r7, sp, #0
 80047b6:	60f8      	str	r0, [r7, #12]
 80047b8:	607a      	str	r2, [r7, #4]
 80047ba:	200b      	movs	r0, #11
 80047bc:	183b      	adds	r3, r7, r0
 80047be:	1c0a      	adds	r2, r1, #0
 80047c0:	701a      	strb	r2, [r3, #0]

  if ( HTS221_ReadReg( (void *)handle, reg, 1, data ) == HTS221_ERROR )
 80047c2:	687a      	ldr	r2, [r7, #4]
 80047c4:	183b      	adds	r3, r7, r0
 80047c6:	7819      	ldrb	r1, [r3, #0]
 80047c8:	68f8      	ldr	r0, [r7, #12]
 80047ca:	0013      	movs	r3, r2
 80047cc:	2201      	movs	r2, #1
 80047ce:	f7ff f878 	bl	80038c2 <HTS221_ReadReg>
 80047d2:	0003      	movs	r3, r0
 80047d4:	2b01      	cmp	r3, #1
 80047d6:	d101      	bne.n	80047dc <HTS221_Read_Reg+0x2c>
  {
    return COMPONENT_ERROR;
 80047d8:	2301      	movs	r3, #1
 80047da:	e000      	b.n	80047de <HTS221_Read_Reg+0x2e>
  }

  return COMPONENT_OK;
 80047dc:	2300      	movs	r3, #0
}
 80047de:	0018      	movs	r0, r3
 80047e0:	46bd      	mov	sp, r7
 80047e2:	b004      	add	sp, #16
 80047e4:	bd80      	pop	{r7, pc}

080047e6 <HTS221_Write_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Write_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t data )
{
 80047e6:	b580      	push	{r7, lr}
 80047e8:	b082      	sub	sp, #8
 80047ea:	af00      	add	r7, sp, #0
 80047ec:	6078      	str	r0, [r7, #4]
 80047ee:	0008      	movs	r0, r1
 80047f0:	0011      	movs	r1, r2
 80047f2:	1cfb      	adds	r3, r7, #3
 80047f4:	1c02      	adds	r2, r0, #0
 80047f6:	701a      	strb	r2, [r3, #0]
 80047f8:	1cbb      	adds	r3, r7, #2
 80047fa:	1c0a      	adds	r2, r1, #0
 80047fc:	701a      	strb	r2, [r3, #0]

  if ( HTS221_WriteReg( (void *)handle, reg, 1, &data ) == HTS221_ERROR )
 80047fe:	1cba      	adds	r2, r7, #2
 8004800:	1cfb      	adds	r3, r7, #3
 8004802:	7819      	ldrb	r1, [r3, #0]
 8004804:	6878      	ldr	r0, [r7, #4]
 8004806:	0013      	movs	r3, r2
 8004808:	2201      	movs	r2, #1
 800480a:	f7ff f888 	bl	800391e <HTS221_WriteReg>
 800480e:	0003      	movs	r3, r0
 8004810:	2b01      	cmp	r3, #1
 8004812:	d101      	bne.n	8004818 <HTS221_Write_Reg+0x32>
  {
    return COMPONENT_ERROR;
 8004814:	2301      	movs	r3, #1
 8004816:	e000      	b.n	800481a <HTS221_Write_Reg+0x34>
  }

  return COMPONENT_OK;
 8004818:	2300      	movs	r3, #0
}
 800481a:	0018      	movs	r0, r3
 800481c:	46bd      	mov	sp, r7
 800481e:	b002      	add	sp, #8
 8004820:	bd80      	pop	{r7, pc}

08004822 <LPS22HB_ReadReg>:
* Input       : Register Address
* Output      : Data Read
* Return      : None
*******************************************************************************/
LPS22HB_Error_et LPS22HB_ReadReg( void *handle, uint8_t RegAddr, uint16_t NumByteToRead, uint8_t *Data )
{
 8004822:	b580      	push	{r7, lr}
 8004824:	b086      	sub	sp, #24
 8004826:	af00      	add	r7, sp, #0
 8004828:	60f8      	str	r0, [r7, #12]
 800482a:	0008      	movs	r0, r1
 800482c:	0011      	movs	r1, r2
 800482e:	607b      	str	r3, [r7, #4]
 8004830:	230b      	movs	r3, #11
 8004832:	18fb      	adds	r3, r7, r3
 8004834:	1c02      	adds	r2, r0, #0
 8004836:	701a      	strb	r2, [r3, #0]
 8004838:	2308      	movs	r3, #8
 800483a:	18fb      	adds	r3, r7, r3
 800483c:	1c0a      	adds	r2, r1, #0
 800483e:	801a      	strh	r2, [r3, #0]
  int i = 0;
 8004840:	2300      	movs	r3, #0
 8004842:	617b      	str	r3, [r7, #20]

  for (i = 0; i < NumByteToRead; i++ )
 8004844:	2300      	movs	r3, #0
 8004846:	617b      	str	r3, [r7, #20]
 8004848:	e014      	b.n	8004874 <LPS22HB_ReadReg+0x52>
  {
    if( Sensor_IO_Read(handle, RegAddr + i, &Data[i], 1 ))
 800484a:	697b      	ldr	r3, [r7, #20]
 800484c:	b2da      	uxtb	r2, r3
 800484e:	230b      	movs	r3, #11
 8004850:	18fb      	adds	r3, r7, r3
 8004852:	781b      	ldrb	r3, [r3, #0]
 8004854:	18d3      	adds	r3, r2, r3
 8004856:	b2d9      	uxtb	r1, r3
 8004858:	697b      	ldr	r3, [r7, #20]
 800485a:	687a      	ldr	r2, [r7, #4]
 800485c:	18d2      	adds	r2, r2, r3
 800485e:	68f8      	ldr	r0, [r7, #12]
 8004860:	2301      	movs	r3, #1
 8004862:	f003 ff7f 	bl	8008764 <Sensor_IO_Read>
 8004866:	1e03      	subs	r3, r0, #0
 8004868:	d001      	beq.n	800486e <LPS22HB_ReadReg+0x4c>
      return LPS22HB_ERROR;
 800486a:	2301      	movs	r3, #1
 800486c:	e009      	b.n	8004882 <LPS22HB_ReadReg+0x60>
  for (i = 0; i < NumByteToRead; i++ )
 800486e:	697b      	ldr	r3, [r7, #20]
 8004870:	3301      	adds	r3, #1
 8004872:	617b      	str	r3, [r7, #20]
 8004874:	2308      	movs	r3, #8
 8004876:	18fb      	adds	r3, r7, r3
 8004878:	881b      	ldrh	r3, [r3, #0]
 800487a:	697a      	ldr	r2, [r7, #20]
 800487c:	429a      	cmp	r2, r3
 800487e:	dbe4      	blt.n	800484a <LPS22HB_ReadReg+0x28>
  }
  
  return LPS22HB_OK;
 8004880:	2300      	movs	r3, #0
}
 8004882:	0018      	movs	r0, r3
 8004884:	46bd      	mov	sp, r7
 8004886:	b006      	add	sp, #24
 8004888:	bd80      	pop	{r7, pc}

0800488a <LPS22HB_WriteReg>:
* Input       : Register Address, Data to be written
* Output      : None
* Return      : None
*******************************************************************************/
LPS22HB_Error_et LPS22HB_WriteReg( void *handle, uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t *Data )
{
 800488a:	b580      	push	{r7, lr}
 800488c:	b086      	sub	sp, #24
 800488e:	af00      	add	r7, sp, #0
 8004890:	60f8      	str	r0, [r7, #12]
 8004892:	0008      	movs	r0, r1
 8004894:	0011      	movs	r1, r2
 8004896:	607b      	str	r3, [r7, #4]
 8004898:	230b      	movs	r3, #11
 800489a:	18fb      	adds	r3, r7, r3
 800489c:	1c02      	adds	r2, r0, #0
 800489e:	701a      	strb	r2, [r3, #0]
 80048a0:	2308      	movs	r3, #8
 80048a2:	18fb      	adds	r3, r7, r3
 80048a4:	1c0a      	adds	r2, r1, #0
 80048a6:	801a      	strh	r2, [r3, #0]
  int i = 0;
 80048a8:	2300      	movs	r3, #0
 80048aa:	617b      	str	r3, [r7, #20]

  for (i = 0; i < NumByteToWrite; i++ )
 80048ac:	2300      	movs	r3, #0
 80048ae:	617b      	str	r3, [r7, #20]
 80048b0:	e014      	b.n	80048dc <LPS22HB_WriteReg+0x52>
  {
    if( Sensor_IO_Write(handle, RegAddr + i, &Data[i], 1 ))
 80048b2:	697b      	ldr	r3, [r7, #20]
 80048b4:	b2da      	uxtb	r2, r3
 80048b6:	230b      	movs	r3, #11
 80048b8:	18fb      	adds	r3, r7, r3
 80048ba:	781b      	ldrb	r3, [r3, #0]
 80048bc:	18d3      	adds	r3, r2, r3
 80048be:	b2d9      	uxtb	r1, r3
 80048c0:	697b      	ldr	r3, [r7, #20]
 80048c2:	687a      	ldr	r2, [r7, #4]
 80048c4:	18d2      	adds	r2, r2, r3
 80048c6:	68f8      	ldr	r0, [r7, #12]
 80048c8:	2301      	movs	r3, #1
 80048ca:	f003 ff27 	bl	800871c <Sensor_IO_Write>
 80048ce:	1e03      	subs	r3, r0, #0
 80048d0:	d001      	beq.n	80048d6 <LPS22HB_WriteReg+0x4c>
      return LPS22HB_ERROR;
 80048d2:	2301      	movs	r3, #1
 80048d4:	e009      	b.n	80048ea <LPS22HB_WriteReg+0x60>
  for (i = 0; i < NumByteToWrite; i++ )
 80048d6:	697b      	ldr	r3, [r7, #20]
 80048d8:	3301      	adds	r3, #1
 80048da:	617b      	str	r3, [r7, #20]
 80048dc:	2308      	movs	r3, #8
 80048de:	18fb      	adds	r3, r7, r3
 80048e0:	881b      	ldrh	r3, [r3, #0]
 80048e2:	697a      	ldr	r2, [r7, #20]
 80048e4:	429a      	cmp	r2, r3
 80048e6:	dbe4      	blt.n	80048b2 <LPS22HB_WriteReg+0x28>
  }
  
  return LPS22HB_OK;
 80048e8:	2300      	movs	r3, #0
}
 80048ea:	0018      	movs	r0, r3
 80048ec:	46bd      	mov	sp, r7
 80048ee:	b006      	add	sp, #24
 80048f0:	bd80      	pop	{r7, pc}

080048f2 <LPS22HB_Get_DeviceID>:
* @param  *handle Device handle.
* @param  Buffer to empty by Device identification Value.
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_DeviceID(void *handle, uint8_t* deviceid)
{
 80048f2:	b580      	push	{r7, lr}
 80048f4:	b082      	sub	sp, #8
 80048f6:	af00      	add	r7, sp, #0
 80048f8:	6078      	str	r0, [r7, #4]
 80048fa:	6039      	str	r1, [r7, #0]
  if(LPS22HB_ReadReg(handle, LPS22HB_WHO_AM_I_REG, 1, deviceid))
 80048fc:	683b      	ldr	r3, [r7, #0]
 80048fe:	6878      	ldr	r0, [r7, #4]
 8004900:	2201      	movs	r2, #1
 8004902:	210f      	movs	r1, #15
 8004904:	f7ff ff8d 	bl	8004822 <LPS22HB_ReadReg>
 8004908:	1e03      	subs	r3, r0, #0
 800490a:	d001      	beq.n	8004910 <LPS22HB_Get_DeviceID+0x1e>
    return LPS22HB_ERROR;
 800490c:	2301      	movs	r3, #1
 800490e:	e000      	b.n	8004912 <LPS22HB_Get_DeviceID+0x20>

  return LPS22HB_OK;
 8004910:	2300      	movs	r3, #0
}
 8004912:	0018      	movs	r0, r3
 8004914:	46bd      	mov	sp, r7
 8004916:	b002      	add	sp, #8
 8004918:	bd80      	pop	{r7, pc}

0800491a <LPS22HB_Set_PowerMode>:
* @param  *handle Device handle.
* @param  LPS22HB_LowNoise or LPS22HB_LowPower mode
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_PowerMode(void *handle, LPS22HB_PowerMode_et mode)
{
 800491a:	b580      	push	{r7, lr}
 800491c:	b084      	sub	sp, #16
 800491e:	af00      	add	r7, sp, #0
 8004920:	6078      	str	r0, [r7, #4]
 8004922:	000a      	movs	r2, r1
 8004924:	1cfb      	adds	r3, r7, #3
 8004926:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_PowerMode(mode));

  if(LPS22HB_ReadReg(handle, LPS22HB_RES_CONF_REG, 1, &tmp))
 8004928:	230f      	movs	r3, #15
 800492a:	18fb      	adds	r3, r7, r3
 800492c:	6878      	ldr	r0, [r7, #4]
 800492e:	2201      	movs	r2, #1
 8004930:	211a      	movs	r1, #26
 8004932:	f7ff ff76 	bl	8004822 <LPS22HB_ReadReg>
 8004936:	1e03      	subs	r3, r0, #0
 8004938:	d001      	beq.n	800493e <LPS22HB_Set_PowerMode+0x24>
    return LPS22HB_ERROR;
 800493a:	2301      	movs	r3, #1
 800493c:	e01a      	b.n	8004974 <LPS22HB_Set_PowerMode+0x5a>

  tmp &= ~LPS22HB_LCEN_MASK;
 800493e:	210f      	movs	r1, #15
 8004940:	187b      	adds	r3, r7, r1
 8004942:	781b      	ldrb	r3, [r3, #0]
 8004944:	2201      	movs	r2, #1
 8004946:	4393      	bics	r3, r2
 8004948:	b2da      	uxtb	r2, r3
 800494a:	187b      	adds	r3, r7, r1
 800494c:	701a      	strb	r2, [r3, #0]
  tmp |= (uint8_t)mode;
 800494e:	187b      	adds	r3, r7, r1
 8004950:	781a      	ldrb	r2, [r3, #0]
 8004952:	1cfb      	adds	r3, r7, #3
 8004954:	781b      	ldrb	r3, [r3, #0]
 8004956:	4313      	orrs	r3, r2
 8004958:	b2da      	uxtb	r2, r3
 800495a:	187b      	adds	r3, r7, r1
 800495c:	701a      	strb	r2, [r3, #0]

  if(LPS22HB_WriteReg(handle, LPS22HB_RES_CONF_REG, 1, &tmp))
 800495e:	187b      	adds	r3, r7, r1
 8004960:	6878      	ldr	r0, [r7, #4]
 8004962:	2201      	movs	r2, #1
 8004964:	211a      	movs	r1, #26
 8004966:	f7ff ff90 	bl	800488a <LPS22HB_WriteReg>
 800496a:	1e03      	subs	r3, r0, #0
 800496c:	d001      	beq.n	8004972 <LPS22HB_Set_PowerMode+0x58>
    return LPS22HB_ERROR;
 800496e:	2301      	movs	r3, #1
 8004970:	e000      	b.n	8004974 <LPS22HB_Set_PowerMode+0x5a>

  return LPS22HB_OK;
 8004972:	2300      	movs	r3, #0
}
 8004974:	0018      	movs	r0, r3
 8004976:	46bd      	mov	sp, r7
 8004978:	b004      	add	sp, #16
 800497a:	bd80      	pop	{r7, pc}

0800497c <LPS22HB_Set_Odr>:
* @param  *handle Device handle.
* @param  Output Data Rate
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_Odr(void *handle, LPS22HB_Odr_et odr)
{
 800497c:	b580      	push	{r7, lr}
 800497e:	b084      	sub	sp, #16
 8004980:	af00      	add	r7, sp, #0
 8004982:	6078      	str	r0, [r7, #4]
 8004984:	000a      	movs	r2, r1
 8004986:	1cfb      	adds	r3, r7, #3
 8004988:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;


  LPS22HB_assert_param(IS_LPS22HB_ODR(odr));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
 800498a:	230f      	movs	r3, #15
 800498c:	18fb      	adds	r3, r7, r3
 800498e:	6878      	ldr	r0, [r7, #4]
 8004990:	2201      	movs	r2, #1
 8004992:	2110      	movs	r1, #16
 8004994:	f7ff ff45 	bl	8004822 <LPS22HB_ReadReg>
 8004998:	1e03      	subs	r3, r0, #0
 800499a:	d001      	beq.n	80049a0 <LPS22HB_Set_Odr+0x24>
    return LPS22HB_ERROR;
 800499c:	2301      	movs	r3, #1
 800499e:	e01a      	b.n	80049d6 <LPS22HB_Set_Odr+0x5a>

  tmp &= ~LPS22HB_ODR_MASK;
 80049a0:	210f      	movs	r1, #15
 80049a2:	187b      	adds	r3, r7, r1
 80049a4:	781b      	ldrb	r3, [r3, #0]
 80049a6:	2270      	movs	r2, #112	; 0x70
 80049a8:	4393      	bics	r3, r2
 80049aa:	b2da      	uxtb	r2, r3
 80049ac:	187b      	adds	r3, r7, r1
 80049ae:	701a      	strb	r2, [r3, #0]
  tmp |= (uint8_t)odr;
 80049b0:	187b      	adds	r3, r7, r1
 80049b2:	781a      	ldrb	r2, [r3, #0]
 80049b4:	1cfb      	adds	r3, r7, #3
 80049b6:	781b      	ldrb	r3, [r3, #0]
 80049b8:	4313      	orrs	r3, r2
 80049ba:	b2da      	uxtb	r2, r3
 80049bc:	187b      	adds	r3, r7, r1
 80049be:	701a      	strb	r2, [r3, #0]

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
 80049c0:	187b      	adds	r3, r7, r1
 80049c2:	6878      	ldr	r0, [r7, #4]
 80049c4:	2201      	movs	r2, #1
 80049c6:	2110      	movs	r1, #16
 80049c8:	f7ff ff5f 	bl	800488a <LPS22HB_WriteReg>
 80049cc:	1e03      	subs	r3, r0, #0
 80049ce:	d001      	beq.n	80049d4 <LPS22HB_Set_Odr+0x58>
    return LPS22HB_ERROR;
 80049d0:	2301      	movs	r3, #1
 80049d2:	e000      	b.n	80049d6 <LPS22HB_Set_Odr+0x5a>

  return LPS22HB_OK;
 80049d4:	2300      	movs	r3, #0
}
 80049d6:	0018      	movs	r0, r3
 80049d8:	46bd      	mov	sp, r7
 80049da:	b004      	add	sp, #16
 80049dc:	bd80      	pop	{r7, pc}

080049de <LPS22HB_Get_Odr>:
* @param  *handle Device handle.
* @param  Buffer to empty with Output Data Rate
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_Odr(void *handle, LPS22HB_Odr_et* odr)
{
 80049de:	b580      	push	{r7, lr}
 80049e0:	b084      	sub	sp, #16
 80049e2:	af00      	add	r7, sp, #0
 80049e4:	6078      	str	r0, [r7, #4]
 80049e6:	6039      	str	r1, [r7, #0]
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
 80049e8:	230f      	movs	r3, #15
 80049ea:	18fb      	adds	r3, r7, r3
 80049ec:	6878      	ldr	r0, [r7, #4]
 80049ee:	2201      	movs	r2, #1
 80049f0:	2110      	movs	r1, #16
 80049f2:	f7ff ff16 	bl	8004822 <LPS22HB_ReadReg>
 80049f6:	1e03      	subs	r3, r0, #0
 80049f8:	d001      	beq.n	80049fe <LPS22HB_Get_Odr+0x20>
    return LPS22HB_ERROR;
 80049fa:	2301      	movs	r3, #1
 80049fc:	e008      	b.n	8004a10 <LPS22HB_Get_Odr+0x32>

  *odr = (LPS22HB_Odr_et)(tmp & LPS22HB_ODR_MASK);
 80049fe:	230f      	movs	r3, #15
 8004a00:	18fb      	adds	r3, r7, r3
 8004a02:	781b      	ldrb	r3, [r3, #0]
 8004a04:	2270      	movs	r2, #112	; 0x70
 8004a06:	4013      	ands	r3, r2
 8004a08:	b2da      	uxtb	r2, r3
 8004a0a:	683b      	ldr	r3, [r7, #0]
 8004a0c:	701a      	strb	r2, [r3, #0]

  return LPS22HB_OK;
 8004a0e:	2300      	movs	r3, #0
}
 8004a10:	0018      	movs	r0, r3
 8004a12:	46bd      	mov	sp, r7
 8004a14:	b004      	add	sp, #16
 8004a16:	bd80      	pop	{r7, pc}

08004a18 <LPS22HB_Set_LowPassFilter>:
* @param  *handle Device handle.
* @param  state: enable or disable
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_LowPassFilter(void *handle, LPS22HB_State_et state)
{
 8004a18:	b580      	push	{r7, lr}
 8004a1a:	b084      	sub	sp, #16
 8004a1c:	af00      	add	r7, sp, #0
 8004a1e:	6078      	str	r0, [r7, #4]
 8004a20:	000a      	movs	r2, r1
 8004a22:	1cfb      	adds	r3, r7, #3
 8004a24:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(state));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
 8004a26:	230f      	movs	r3, #15
 8004a28:	18fb      	adds	r3, r7, r3
 8004a2a:	6878      	ldr	r0, [r7, #4]
 8004a2c:	2201      	movs	r2, #1
 8004a2e:	2110      	movs	r1, #16
 8004a30:	f7ff fef7 	bl	8004822 <LPS22HB_ReadReg>
 8004a34:	1e03      	subs	r3, r0, #0
 8004a36:	d001      	beq.n	8004a3c <LPS22HB_Set_LowPassFilter+0x24>
    return LPS22HB_ERROR;
 8004a38:	2301      	movs	r3, #1
 8004a3a:	e01e      	b.n	8004a7a <LPS22HB_Set_LowPassFilter+0x62>

  tmp &= ~LPS22HB_LPFP_MASK;
 8004a3c:	210f      	movs	r1, #15
 8004a3e:	187b      	adds	r3, r7, r1
 8004a40:	781b      	ldrb	r3, [r3, #0]
 8004a42:	2208      	movs	r2, #8
 8004a44:	4393      	bics	r3, r2
 8004a46:	b2da      	uxtb	r2, r3
 8004a48:	187b      	adds	r3, r7, r1
 8004a4a:	701a      	strb	r2, [r3, #0]
  tmp |= ((uint8_t)state) << LPS22HB_LPFP_BIT;
 8004a4c:	1cfb      	adds	r3, r7, #3
 8004a4e:	781b      	ldrb	r3, [r3, #0]
 8004a50:	00db      	lsls	r3, r3, #3
 8004a52:	b25a      	sxtb	r2, r3
 8004a54:	187b      	adds	r3, r7, r1
 8004a56:	781b      	ldrb	r3, [r3, #0]
 8004a58:	b25b      	sxtb	r3, r3
 8004a5a:	4313      	orrs	r3, r2
 8004a5c:	b25b      	sxtb	r3, r3
 8004a5e:	b2da      	uxtb	r2, r3
 8004a60:	187b      	adds	r3, r7, r1
 8004a62:	701a      	strb	r2, [r3, #0]


  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
 8004a64:	187b      	adds	r3, r7, r1
 8004a66:	6878      	ldr	r0, [r7, #4]
 8004a68:	2201      	movs	r2, #1
 8004a6a:	2110      	movs	r1, #16
 8004a6c:	f7ff ff0d 	bl	800488a <LPS22HB_WriteReg>
 8004a70:	1e03      	subs	r3, r0, #0
 8004a72:	d001      	beq.n	8004a78 <LPS22HB_Set_LowPassFilter+0x60>
    return LPS22HB_ERROR;
 8004a74:	2301      	movs	r3, #1
 8004a76:	e000      	b.n	8004a7a <LPS22HB_Set_LowPassFilter+0x62>


  return LPS22HB_OK;
 8004a78:	2300      	movs	r3, #0
}
 8004a7a:	0018      	movs	r0, r3
 8004a7c:	46bd      	mov	sp, r7
 8004a7e:	b004      	add	sp, #16
 8004a80:	bd80      	pop	{r7, pc}

08004a82 <LPS22HB_Set_LowPassFilterCutoff>:
* @param  *handle Device handle.
* @param  Filter Cutoff ODR/9 or ODR/20
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_LowPassFilterCutoff(void *handle, LPS22HB_LPF_Cutoff_et cutoff)
{
 8004a82:	b580      	push	{r7, lr}
 8004a84:	b084      	sub	sp, #16
 8004a86:	af00      	add	r7, sp, #0
 8004a88:	6078      	str	r0, [r7, #4]
 8004a8a:	000a      	movs	r2, r1
 8004a8c:	1cfb      	adds	r3, r7, #3
 8004a8e:	701a      	strb	r2, [r3, #0]

  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_LPF_Cutoff(cutoff));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
 8004a90:	230f      	movs	r3, #15
 8004a92:	18fb      	adds	r3, r7, r3
 8004a94:	6878      	ldr	r0, [r7, #4]
 8004a96:	2201      	movs	r2, #1
 8004a98:	2110      	movs	r1, #16
 8004a9a:	f7ff fec2 	bl	8004822 <LPS22HB_ReadReg>
 8004a9e:	1e03      	subs	r3, r0, #0
 8004aa0:	d001      	beq.n	8004aa6 <LPS22HB_Set_LowPassFilterCutoff+0x24>
    return LPS22HB_ERROR;
 8004aa2:	2301      	movs	r3, #1
 8004aa4:	e01a      	b.n	8004adc <LPS22HB_Set_LowPassFilterCutoff+0x5a>

  tmp &= ~LPS22HB_LPFP_CUTOFF_MASK;
 8004aa6:	210f      	movs	r1, #15
 8004aa8:	187b      	adds	r3, r7, r1
 8004aaa:	781b      	ldrb	r3, [r3, #0]
 8004aac:	2204      	movs	r2, #4
 8004aae:	4393      	bics	r3, r2
 8004ab0:	b2da      	uxtb	r2, r3
 8004ab2:	187b      	adds	r3, r7, r1
 8004ab4:	701a      	strb	r2, [r3, #0]
  tmp |= (uint8_t)cutoff;
 8004ab6:	187b      	adds	r3, r7, r1
 8004ab8:	781a      	ldrb	r2, [r3, #0]
 8004aba:	1cfb      	adds	r3, r7, #3
 8004abc:	781b      	ldrb	r3, [r3, #0]
 8004abe:	4313      	orrs	r3, r2
 8004ac0:	b2da      	uxtb	r2, r3
 8004ac2:	187b      	adds	r3, r7, r1
 8004ac4:	701a      	strb	r2, [r3, #0]



  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
 8004ac6:	187b      	adds	r3, r7, r1
 8004ac8:	6878      	ldr	r0, [r7, #4]
 8004aca:	2201      	movs	r2, #1
 8004acc:	2110      	movs	r1, #16
 8004ace:	f7ff fedc 	bl	800488a <LPS22HB_WriteReg>
 8004ad2:	1e03      	subs	r3, r0, #0
 8004ad4:	d001      	beq.n	8004ada <LPS22HB_Set_LowPassFilterCutoff+0x58>
    return LPS22HB_ERROR;
 8004ad6:	2301      	movs	r3, #1
 8004ad8:	e000      	b.n	8004adc <LPS22HB_Set_LowPassFilterCutoff+0x5a>


  return LPS22HB_OK;
 8004ada:	2300      	movs	r3, #0

}
 8004adc:	0018      	movs	r0, r3
 8004ade:	46bd      	mov	sp, r7
 8004ae0:	b004      	add	sp, #16
 8004ae2:	bd80      	pop	{r7, pc}

08004ae4 <LPS22HB_Set_Bdu>:
* @param  LPS22HB_BDU_CONTINUOUS_UPDATE, LPS22HB_BDU_NO_UPDATE
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/

LPS22HB_Error_et LPS22HB_Set_Bdu(void *handle, LPS22HB_Bdu_et bdu)
{
 8004ae4:	b580      	push	{r7, lr}
 8004ae6:	b084      	sub	sp, #16
 8004ae8:	af00      	add	r7, sp, #0
 8004aea:	6078      	str	r0, [r7, #4]
 8004aec:	000a      	movs	r2, r1
 8004aee:	1cfb      	adds	r3, r7, #3
 8004af0:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;


  LPS22HB_assert_param(IS_LPS22HB_BDUMode(bdu));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
 8004af2:	230f      	movs	r3, #15
 8004af4:	18fb      	adds	r3, r7, r3
 8004af6:	6878      	ldr	r0, [r7, #4]
 8004af8:	2201      	movs	r2, #1
 8004afa:	2110      	movs	r1, #16
 8004afc:	f7ff fe91 	bl	8004822 <LPS22HB_ReadReg>
 8004b00:	1e03      	subs	r3, r0, #0
 8004b02:	d001      	beq.n	8004b08 <LPS22HB_Set_Bdu+0x24>
    return LPS22HB_ERROR;
 8004b04:	2301      	movs	r3, #1
 8004b06:	e01a      	b.n	8004b3e <LPS22HB_Set_Bdu+0x5a>

  tmp &= ~LPS22HB_BDU_MASK;
 8004b08:	210f      	movs	r1, #15
 8004b0a:	187b      	adds	r3, r7, r1
 8004b0c:	781b      	ldrb	r3, [r3, #0]
 8004b0e:	2202      	movs	r2, #2
 8004b10:	4393      	bics	r3, r2
 8004b12:	b2da      	uxtb	r2, r3
 8004b14:	187b      	adds	r3, r7, r1
 8004b16:	701a      	strb	r2, [r3, #0]
  tmp |= ((uint8_t)bdu);
 8004b18:	187b      	adds	r3, r7, r1
 8004b1a:	781a      	ldrb	r2, [r3, #0]
 8004b1c:	1cfb      	adds	r3, r7, #3
 8004b1e:	781b      	ldrb	r3, [r3, #0]
 8004b20:	4313      	orrs	r3, r2
 8004b22:	b2da      	uxtb	r2, r3
 8004b24:	187b      	adds	r3, r7, r1
 8004b26:	701a      	strb	r2, [r3, #0]


  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
 8004b28:	187b      	adds	r3, r7, r1
 8004b2a:	6878      	ldr	r0, [r7, #4]
 8004b2c:	2201      	movs	r2, #1
 8004b2e:	2110      	movs	r1, #16
 8004b30:	f7ff feab 	bl	800488a <LPS22HB_WriteReg>
 8004b34:	1e03      	subs	r3, r0, #0
 8004b36:	d001      	beq.n	8004b3c <LPS22HB_Set_Bdu+0x58>
    return LPS22HB_OK;
 8004b38:	2300      	movs	r3, #0
 8004b3a:	e000      	b.n	8004b3e <LPS22HB_Set_Bdu+0x5a>

  return LPS22HB_OK;
 8004b3c:	2300      	movs	r3, #0
}
 8004b3e:	0018      	movs	r0, r3
 8004b40:	46bd      	mov	sp, r7
 8004b42:	b004      	add	sp, #16
 8004b44:	bd80      	pop	{r7, pc}

08004b46 <LPS22HB_Set_FifoModeUse>:
* @param  *handle Device handle.
* @param LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoModeUse(void *handle, LPS22HB_State_et status)
{
 8004b46:	b580      	push	{r7, lr}
 8004b48:	b084      	sub	sp, #16
 8004b4a:	af00      	add	r7, sp, #0
 8004b4c:	6078      	str	r0, [r7, #4]
 8004b4e:	000a      	movs	r2, r1
 8004b50:	1cfb      	adds	r3, r7, #3
 8004b52:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
 8004b54:	230f      	movs	r3, #15
 8004b56:	18fb      	adds	r3, r7, r3
 8004b58:	6878      	ldr	r0, [r7, #4]
 8004b5a:	2201      	movs	r2, #1
 8004b5c:	2111      	movs	r1, #17
 8004b5e:	f7ff fe60 	bl	8004822 <LPS22HB_ReadReg>
 8004b62:	1e03      	subs	r3, r0, #0
 8004b64:	d001      	beq.n	8004b6a <LPS22HB_Set_FifoModeUse+0x24>
    return LPS22HB_ERROR;
 8004b66:	2301      	movs	r3, #1
 8004b68:	e01e      	b.n	8004ba8 <LPS22HB_Set_FifoModeUse+0x62>

  tmp &= ~LPS22HB_FIFO_EN_MASK;
 8004b6a:	210f      	movs	r1, #15
 8004b6c:	187b      	adds	r3, r7, r1
 8004b6e:	781b      	ldrb	r3, [r3, #0]
 8004b70:	2240      	movs	r2, #64	; 0x40
 8004b72:	4393      	bics	r3, r2
 8004b74:	b2da      	uxtb	r2, r3
 8004b76:	187b      	adds	r3, r7, r1
 8004b78:	701a      	strb	r2, [r3, #0]
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_EN_BIT;
 8004b7a:	1cfb      	adds	r3, r7, #3
 8004b7c:	781b      	ldrb	r3, [r3, #0]
 8004b7e:	019b      	lsls	r3, r3, #6
 8004b80:	b25a      	sxtb	r2, r3
 8004b82:	187b      	adds	r3, r7, r1
 8004b84:	781b      	ldrb	r3, [r3, #0]
 8004b86:	b25b      	sxtb	r3, r3
 8004b88:	4313      	orrs	r3, r2
 8004b8a:	b25b      	sxtb	r3, r3
 8004b8c:	b2da      	uxtb	r2, r3
 8004b8e:	187b      	adds	r3, r7, r1
 8004b90:	701a      	strb	r2, [r3, #0]

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
 8004b92:	187b      	adds	r3, r7, r1
 8004b94:	6878      	ldr	r0, [r7, #4]
 8004b96:	2201      	movs	r2, #1
 8004b98:	2111      	movs	r1, #17
 8004b9a:	f7ff fe76 	bl	800488a <LPS22HB_WriteReg>
 8004b9e:	1e03      	subs	r3, r0, #0
 8004ba0:	d001      	beq.n	8004ba6 <LPS22HB_Set_FifoModeUse+0x60>
    return LPS22HB_ERROR;
 8004ba2:	2301      	movs	r3, #1
 8004ba4:	e000      	b.n	8004ba8 <LPS22HB_Set_FifoModeUse+0x62>

  return LPS22HB_OK;
 8004ba6:	2300      	movs	r3, #0
}
 8004ba8:	0018      	movs	r0, r3
 8004baa:	46bd      	mov	sp, r7
 8004bac:	b004      	add	sp, #16
 8004bae:	bd80      	pop	{r7, pc}

08004bb0 <LPS22HB_Set_FifoWatermarkLevelUse>:
* @param  *handle Device handle.
* @param   LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoWatermarkLevelUse(void *handle, LPS22HB_State_et status)
{
 8004bb0:	b580      	push	{r7, lr}
 8004bb2:	b084      	sub	sp, #16
 8004bb4:	af00      	add	r7, sp, #0
 8004bb6:	6078      	str	r0, [r7, #4]
 8004bb8:	000a      	movs	r2, r1
 8004bba:	1cfb      	adds	r3, r7, #3
 8004bbc:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
 8004bbe:	230f      	movs	r3, #15
 8004bc0:	18fb      	adds	r3, r7, r3
 8004bc2:	6878      	ldr	r0, [r7, #4]
 8004bc4:	2201      	movs	r2, #1
 8004bc6:	2111      	movs	r1, #17
 8004bc8:	f7ff fe2b 	bl	8004822 <LPS22HB_ReadReg>
 8004bcc:	1e03      	subs	r3, r0, #0
 8004bce:	d001      	beq.n	8004bd4 <LPS22HB_Set_FifoWatermarkLevelUse+0x24>
    return LPS22HB_ERROR;
 8004bd0:	2301      	movs	r3, #1
 8004bd2:	e01e      	b.n	8004c12 <LPS22HB_Set_FifoWatermarkLevelUse+0x62>

  tmp &= ~LPS22HB_WTM_EN_MASK;
 8004bd4:	210f      	movs	r1, #15
 8004bd6:	187b      	adds	r3, r7, r1
 8004bd8:	781b      	ldrb	r3, [r3, #0]
 8004bda:	2220      	movs	r2, #32
 8004bdc:	4393      	bics	r3, r2
 8004bde:	b2da      	uxtb	r2, r3
 8004be0:	187b      	adds	r3, r7, r1
 8004be2:	701a      	strb	r2, [r3, #0]
  tmp |= ((uint8_t)status) << LPS22HB_WTM_EN_BIT;
 8004be4:	1cfb      	adds	r3, r7, #3
 8004be6:	781b      	ldrb	r3, [r3, #0]
 8004be8:	015b      	lsls	r3, r3, #5
 8004bea:	b25a      	sxtb	r2, r3
 8004bec:	187b      	adds	r3, r7, r1
 8004bee:	781b      	ldrb	r3, [r3, #0]
 8004bf0:	b25b      	sxtb	r3, r3
 8004bf2:	4313      	orrs	r3, r2
 8004bf4:	b25b      	sxtb	r3, r3
 8004bf6:	b2da      	uxtb	r2, r3
 8004bf8:	187b      	adds	r3, r7, r1
 8004bfa:	701a      	strb	r2, [r3, #0]

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
 8004bfc:	187b      	adds	r3, r7, r1
 8004bfe:	6878      	ldr	r0, [r7, #4]
 8004c00:	2201      	movs	r2, #1
 8004c02:	2111      	movs	r1, #17
 8004c04:	f7ff fe41 	bl	800488a <LPS22HB_WriteReg>
 8004c08:	1e03      	subs	r3, r0, #0
 8004c0a:	d001      	beq.n	8004c10 <LPS22HB_Set_FifoWatermarkLevelUse+0x60>
    return LPS22HB_ERROR;
 8004c0c:	2301      	movs	r3, #1
 8004c0e:	e000      	b.n	8004c12 <LPS22HB_Set_FifoWatermarkLevelUse+0x62>

  return LPS22HB_OK;
 8004c10:	2300      	movs	r3, #0
}
 8004c12:	0018      	movs	r0, r3
 8004c14:	46bd      	mov	sp, r7
 8004c16:	b004      	add	sp, #16
 8004c18:	bd80      	pop	{r7, pc}

08004c1a <LPS22HB_Set_AutomaticIncrementRegAddress>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE. Default is LPS22HB_ENABLE
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_AutomaticIncrementRegAddress(void *handle, LPS22HB_State_et status)
{
 8004c1a:	b580      	push	{r7, lr}
 8004c1c:	b084      	sub	sp, #16
 8004c1e:	af00      	add	r7, sp, #0
 8004c20:	6078      	str	r0, [r7, #4]
 8004c22:	000a      	movs	r2, r1
 8004c24:	1cfb      	adds	r3, r7, #3
 8004c26:	701a      	strb	r2, [r3, #0]

  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
 8004c28:	230f      	movs	r3, #15
 8004c2a:	18fb      	adds	r3, r7, r3
 8004c2c:	6878      	ldr	r0, [r7, #4]
 8004c2e:	2201      	movs	r2, #1
 8004c30:	2111      	movs	r1, #17
 8004c32:	f7ff fdf6 	bl	8004822 <LPS22HB_ReadReg>
 8004c36:	1e03      	subs	r3, r0, #0
 8004c38:	d001      	beq.n	8004c3e <LPS22HB_Set_AutomaticIncrementRegAddress+0x24>
    return LPS22HB_ERROR;
 8004c3a:	2301      	movs	r3, #1
 8004c3c:	e01e      	b.n	8004c7c <LPS22HB_Set_AutomaticIncrementRegAddress+0x62>

  tmp &= ~LPS22HB_ADD_INC_MASK;
 8004c3e:	210f      	movs	r1, #15
 8004c40:	187b      	adds	r3, r7, r1
 8004c42:	781b      	ldrb	r3, [r3, #0]
 8004c44:	2210      	movs	r2, #16
 8004c46:	4393      	bics	r3, r2
 8004c48:	b2da      	uxtb	r2, r3
 8004c4a:	187b      	adds	r3, r7, r1
 8004c4c:	701a      	strb	r2, [r3, #0]
  tmp |= (((uint8_t)status) << LPS22HB_ADD_INC_BIT);
 8004c4e:	1cfb      	adds	r3, r7, #3
 8004c50:	781b      	ldrb	r3, [r3, #0]
 8004c52:	011b      	lsls	r3, r3, #4
 8004c54:	b25a      	sxtb	r2, r3
 8004c56:	187b      	adds	r3, r7, r1
 8004c58:	781b      	ldrb	r3, [r3, #0]
 8004c5a:	b25b      	sxtb	r3, r3
 8004c5c:	4313      	orrs	r3, r2
 8004c5e:	b25b      	sxtb	r3, r3
 8004c60:	b2da      	uxtb	r2, r3
 8004c62:	187b      	adds	r3, r7, r1
 8004c64:	701a      	strb	r2, [r3, #0]

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
 8004c66:	187b      	adds	r3, r7, r1
 8004c68:	6878      	ldr	r0, [r7, #4]
 8004c6a:	2201      	movs	r2, #1
 8004c6c:	2111      	movs	r1, #17
 8004c6e:	f7ff fe0c 	bl	800488a <LPS22HB_WriteReg>
 8004c72:	1e03      	subs	r3, r0, #0
 8004c74:	d001      	beq.n	8004c7a <LPS22HB_Set_AutomaticIncrementRegAddress+0x60>
    return LPS22HB_ERROR;
 8004c76:	2301      	movs	r3, #1
 8004c78:	e000      	b.n	8004c7c <LPS22HB_Set_AutomaticIncrementRegAddress+0x62>

  return LPS22HB_OK;
 8004c7a:	2300      	movs	r3, #0

}
 8004c7c:	0018      	movs	r0, r3
 8004c7e:	46bd      	mov	sp, r7
 8004c80:	b004      	add	sp, #16
 8004c82:	bd80      	pop	{r7, pc}

08004c84 <LPS22HB_Set_FIFO_OVR_Interrupt>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FIFO_OVR_Interrupt(void *handle, LPS22HB_State_et status)
{
 8004c84:	b580      	push	{r7, lr}
 8004c86:	b084      	sub	sp, #16
 8004c88:	af00      	add	r7, sp, #0
 8004c8a:	6078      	str	r0, [r7, #4]
 8004c8c:	000a      	movs	r2, r1
 8004c8e:	1cfb      	adds	r3, r7, #3
 8004c90:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;


  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
 8004c92:	230f      	movs	r3, #15
 8004c94:	18fb      	adds	r3, r7, r3
 8004c96:	6878      	ldr	r0, [r7, #4]
 8004c98:	2201      	movs	r2, #1
 8004c9a:	2112      	movs	r1, #18
 8004c9c:	f7ff fdc1 	bl	8004822 <LPS22HB_ReadReg>
 8004ca0:	1e03      	subs	r3, r0, #0
 8004ca2:	d001      	beq.n	8004ca8 <LPS22HB_Set_FIFO_OVR_Interrupt+0x24>
    return LPS22HB_ERROR;
 8004ca4:	2301      	movs	r3, #1
 8004ca6:	e01e      	b.n	8004ce6 <LPS22HB_Set_FIFO_OVR_Interrupt+0x62>

  tmp &= ~LPS22HB_FIFO_OVR_MASK;
 8004ca8:	210f      	movs	r1, #15
 8004caa:	187b      	adds	r3, r7, r1
 8004cac:	781b      	ldrb	r3, [r3, #0]
 8004cae:	2208      	movs	r2, #8
 8004cb0:	4393      	bics	r3, r2
 8004cb2:	b2da      	uxtb	r2, r3
 8004cb4:	187b      	adds	r3, r7, r1
 8004cb6:	701a      	strb	r2, [r3, #0]
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_OVR_BIT;
 8004cb8:	1cfb      	adds	r3, r7, #3
 8004cba:	781b      	ldrb	r3, [r3, #0]
 8004cbc:	00db      	lsls	r3, r3, #3
 8004cbe:	b25a      	sxtb	r2, r3
 8004cc0:	187b      	adds	r3, r7, r1
 8004cc2:	781b      	ldrb	r3, [r3, #0]
 8004cc4:	b25b      	sxtb	r3, r3
 8004cc6:	4313      	orrs	r3, r2
 8004cc8:	b25b      	sxtb	r3, r3
 8004cca:	b2da      	uxtb	r2, r3
 8004ccc:	187b      	adds	r3, r7, r1
 8004cce:	701a      	strb	r2, [r3, #0]

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
 8004cd0:	187b      	adds	r3, r7, r1
 8004cd2:	6878      	ldr	r0, [r7, #4]
 8004cd4:	2201      	movs	r2, #1
 8004cd6:	2112      	movs	r1, #18
 8004cd8:	f7ff fdd7 	bl	800488a <LPS22HB_WriteReg>
 8004cdc:	1e03      	subs	r3, r0, #0
 8004cde:	d001      	beq.n	8004ce4 <LPS22HB_Set_FIFO_OVR_Interrupt+0x60>
    return LPS22HB_ERROR;
 8004ce0:	2301      	movs	r3, #1
 8004ce2:	e000      	b.n	8004ce6 <LPS22HB_Set_FIFO_OVR_Interrupt+0x62>

  return LPS22HB_OK;
 8004ce4:	2300      	movs	r3, #0
}
 8004ce6:	0018      	movs	r0, r3
 8004ce8:	46bd      	mov	sp, r7
 8004cea:	b004      	add	sp, #16
 8004cec:	bd80      	pop	{r7, pc}

08004cee <LPS22HB_Set_FIFO_FTH_Interrupt>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FIFO_FTH_Interrupt(void *handle, LPS22HB_State_et status)
{
 8004cee:	b580      	push	{r7, lr}
 8004cf0:	b084      	sub	sp, #16
 8004cf2:	af00      	add	r7, sp, #0
 8004cf4:	6078      	str	r0, [r7, #4]
 8004cf6:	000a      	movs	r2, r1
 8004cf8:	1cfb      	adds	r3, r7, #3
 8004cfa:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
 8004cfc:	230f      	movs	r3, #15
 8004cfe:	18fb      	adds	r3, r7, r3
 8004d00:	6878      	ldr	r0, [r7, #4]
 8004d02:	2201      	movs	r2, #1
 8004d04:	2112      	movs	r1, #18
 8004d06:	f7ff fd8c 	bl	8004822 <LPS22HB_ReadReg>
 8004d0a:	1e03      	subs	r3, r0, #0
 8004d0c:	d001      	beq.n	8004d12 <LPS22HB_Set_FIFO_FTH_Interrupt+0x24>
    return LPS22HB_ERROR;
 8004d0e:	2301      	movs	r3, #1
 8004d10:	e01e      	b.n	8004d50 <LPS22HB_Set_FIFO_FTH_Interrupt+0x62>

  tmp &= ~LPS22HB_FIFO_FTH_MASK;
 8004d12:	210f      	movs	r1, #15
 8004d14:	187b      	adds	r3, r7, r1
 8004d16:	781b      	ldrb	r3, [r3, #0]
 8004d18:	2210      	movs	r2, #16
 8004d1a:	4393      	bics	r3, r2
 8004d1c:	b2da      	uxtb	r2, r3
 8004d1e:	187b      	adds	r3, r7, r1
 8004d20:	701a      	strb	r2, [r3, #0]
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_FTH_BIT;
 8004d22:	1cfb      	adds	r3, r7, #3
 8004d24:	781b      	ldrb	r3, [r3, #0]
 8004d26:	011b      	lsls	r3, r3, #4
 8004d28:	b25a      	sxtb	r2, r3
 8004d2a:	187b      	adds	r3, r7, r1
 8004d2c:	781b      	ldrb	r3, [r3, #0]
 8004d2e:	b25b      	sxtb	r3, r3
 8004d30:	4313      	orrs	r3, r2
 8004d32:	b25b      	sxtb	r3, r3
 8004d34:	b2da      	uxtb	r2, r3
 8004d36:	187b      	adds	r3, r7, r1
 8004d38:	701a      	strb	r2, [r3, #0]

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
 8004d3a:	187b      	adds	r3, r7, r1
 8004d3c:	6878      	ldr	r0, [r7, #4]
 8004d3e:	2201      	movs	r2, #1
 8004d40:	2112      	movs	r1, #18
 8004d42:	f7ff fda2 	bl	800488a <LPS22HB_WriteReg>
 8004d46:	1e03      	subs	r3, r0, #0
 8004d48:	d001      	beq.n	8004d4e <LPS22HB_Set_FIFO_FTH_Interrupt+0x60>
    return LPS22HB_ERROR;
 8004d4a:	2301      	movs	r3, #1
 8004d4c:	e000      	b.n	8004d50 <LPS22HB_Set_FIFO_FTH_Interrupt+0x62>

  return LPS22HB_OK;
 8004d4e:	2300      	movs	r3, #0
}
 8004d50:	0018      	movs	r0, r3
 8004d52:	46bd      	mov	sp, r7
 8004d54:	b004      	add	sp, #16
 8004d56:	bd80      	pop	{r7, pc}

08004d58 <LPS22HB_Set_FIFO_FULL_Interrupt>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FIFO_FULL_Interrupt(void *handle, LPS22HB_State_et status)
{
 8004d58:	b580      	push	{r7, lr}
 8004d5a:	b084      	sub	sp, #16
 8004d5c:	af00      	add	r7, sp, #0
 8004d5e:	6078      	str	r0, [r7, #4]
 8004d60:	000a      	movs	r2, r1
 8004d62:	1cfb      	adds	r3, r7, #3
 8004d64:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
 8004d66:	230f      	movs	r3, #15
 8004d68:	18fb      	adds	r3, r7, r3
 8004d6a:	6878      	ldr	r0, [r7, #4]
 8004d6c:	2201      	movs	r2, #1
 8004d6e:	2112      	movs	r1, #18
 8004d70:	f7ff fd57 	bl	8004822 <LPS22HB_ReadReg>
 8004d74:	1e03      	subs	r3, r0, #0
 8004d76:	d001      	beq.n	8004d7c <LPS22HB_Set_FIFO_FULL_Interrupt+0x24>
    return LPS22HB_ERROR;
 8004d78:	2301      	movs	r3, #1
 8004d7a:	e01e      	b.n	8004dba <LPS22HB_Set_FIFO_FULL_Interrupt+0x62>

  tmp &= ~LPS22HB_FIFO_FULL_MASK;
 8004d7c:	210f      	movs	r1, #15
 8004d7e:	187b      	adds	r3, r7, r1
 8004d80:	781b      	ldrb	r3, [r3, #0]
 8004d82:	2220      	movs	r2, #32
 8004d84:	4393      	bics	r3, r2
 8004d86:	b2da      	uxtb	r2, r3
 8004d88:	187b      	adds	r3, r7, r1
 8004d8a:	701a      	strb	r2, [r3, #0]
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_FULL_BIT;
 8004d8c:	1cfb      	adds	r3, r7, #3
 8004d8e:	781b      	ldrb	r3, [r3, #0]
 8004d90:	015b      	lsls	r3, r3, #5
 8004d92:	b25a      	sxtb	r2, r3
 8004d94:	187b      	adds	r3, r7, r1
 8004d96:	781b      	ldrb	r3, [r3, #0]
 8004d98:	b25b      	sxtb	r3, r3
 8004d9a:	4313      	orrs	r3, r2
 8004d9c:	b25b      	sxtb	r3, r3
 8004d9e:	b2da      	uxtb	r2, r3
 8004da0:	187b      	adds	r3, r7, r1
 8004da2:	701a      	strb	r2, [r3, #0]

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
 8004da4:	187b      	adds	r3, r7, r1
 8004da6:	6878      	ldr	r0, [r7, #4]
 8004da8:	2201      	movs	r2, #1
 8004daa:	2112      	movs	r1, #18
 8004dac:	f7ff fd6d 	bl	800488a <LPS22HB_WriteReg>
 8004db0:	1e03      	subs	r3, r0, #0
 8004db2:	d001      	beq.n	8004db8 <LPS22HB_Set_FIFO_FULL_Interrupt+0x60>
    return LPS22HB_ERROR;
 8004db4:	2301      	movs	r3, #1
 8004db6:	e000      	b.n	8004dba <LPS22HB_Set_FIFO_FULL_Interrupt+0x62>

  return LPS22HB_OK;
 8004db8:	2300      	movs	r3, #0
}
 8004dba:	0018      	movs	r0, r3
 8004dbc:	46bd      	mov	sp, r7
 8004dbe:	b004      	add	sp, #16
 8004dc0:	bd80      	pop	{r7, pc}

08004dc2 <LPS22HB_Get_DataStatus>:
* @param  *handle Device handle.
* @param  Data Status Flag:  TempDataAvailable, TempDataOverrun, PressDataAvailable, PressDataOverrun
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_DataStatus(void *handle, LPS22HB_DataStatus_st* datastatus)
{
 8004dc2:	b580      	push	{r7, lr}
 8004dc4:	b084      	sub	sp, #16
 8004dc6:	af00      	add	r7, sp, #0
 8004dc8:	6078      	str	r0, [r7, #4]
 8004dca:	6039      	str	r1, [r7, #0]
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_STATUS_REG, 1, &tmp))
 8004dcc:	230f      	movs	r3, #15
 8004dce:	18fb      	adds	r3, r7, r3
 8004dd0:	6878      	ldr	r0, [r7, #4]
 8004dd2:	2201      	movs	r2, #1
 8004dd4:	2127      	movs	r1, #39	; 0x27
 8004dd6:	f7ff fd24 	bl	8004822 <LPS22HB_ReadReg>
 8004dda:	1e03      	subs	r3, r0, #0
 8004ddc:	d001      	beq.n	8004de2 <LPS22HB_Get_DataStatus+0x20>
    return LPS22HB_ERROR;
 8004dde:	2301      	movs	r3, #1
 8004de0:	e021      	b.n	8004e26 <LPS22HB_Get_DataStatus+0x64>

  datastatus->PressDataAvailable = (uint8_t)(tmp & LPS22HB_PDA_MASK);
 8004de2:	210f      	movs	r1, #15
 8004de4:	187b      	adds	r3, r7, r1
 8004de6:	781b      	ldrb	r3, [r3, #0]
 8004de8:	2201      	movs	r2, #1
 8004dea:	4013      	ands	r3, r2
 8004dec:	b2da      	uxtb	r2, r3
 8004dee:	683b      	ldr	r3, [r7, #0]
 8004df0:	705a      	strb	r2, [r3, #1]
  datastatus->TempDataAvailable = (uint8_t)((tmp & LPS22HB_TDA_MASK) >> LPS22HB_PDA_BIT);
 8004df2:	187b      	adds	r3, r7, r1
 8004df4:	781b      	ldrb	r3, [r3, #0]
 8004df6:	2202      	movs	r2, #2
 8004df8:	4013      	ands	r3, r2
 8004dfa:	b2da      	uxtb	r2, r3
 8004dfc:	683b      	ldr	r3, [r7, #0]
 8004dfe:	701a      	strb	r2, [r3, #0]
  datastatus->TempDataOverrun = (uint8_t)((tmp & LPS22HB_TOR_MASK) >> LPS22HB_TOR_BIT);
 8004e00:	187b      	adds	r3, r7, r1
 8004e02:	781b      	ldrb	r3, [r3, #0]
 8004e04:	115b      	asrs	r3, r3, #5
 8004e06:	b2db      	uxtb	r3, r3
 8004e08:	2201      	movs	r2, #1
 8004e0a:	4013      	ands	r3, r2
 8004e0c:	b2da      	uxtb	r2, r3
 8004e0e:	683b      	ldr	r3, [r7, #0]
 8004e10:	709a      	strb	r2, [r3, #2]
  datastatus->PressDataOverrun = (uint8_t)((tmp & LPS22HB_POR_MASK) >> LPS22HB_POR_BIT);
 8004e12:	187b      	adds	r3, r7, r1
 8004e14:	781b      	ldrb	r3, [r3, #0]
 8004e16:	111b      	asrs	r3, r3, #4
 8004e18:	b2db      	uxtb	r3, r3
 8004e1a:	2201      	movs	r2, #1
 8004e1c:	4013      	ands	r3, r2
 8004e1e:	b2da      	uxtb	r2, r3
 8004e20:	683b      	ldr	r3, [r7, #0]
 8004e22:	70da      	strb	r2, [r3, #3]

  return LPS22HB_OK;
 8004e24:	2300      	movs	r3, #0
}
 8004e26:	0018      	movs	r0, r3
 8004e28:	46bd      	mov	sp, r7
 8004e2a:	b004      	add	sp, #16
 8004e2c:	bd80      	pop	{r7, pc}

08004e2e <LPS22HB_Get_RawPressure>:
* @param  *handle Device handle.
* @param  The buffer to empty with the pressure raw value
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_RawPressure(void *handle, int32_t *raw_press)
{
 8004e2e:	b580      	push	{r7, lr}
 8004e30:	b084      	sub	sp, #16
 8004e32:	af00      	add	r7, sp, #0
 8004e34:	6078      	str	r0, [r7, #4]
 8004e36:	6039      	str	r1, [r7, #0]
  uint8_t buffer[3];
  uint32_t tmp = 0;
 8004e38:	2300      	movs	r3, #0
 8004e3a:	60fb      	str	r3, [r7, #12]
  uint8_t i;

  if(LPS22HB_ReadReg(handle, LPS22HB_PRESS_OUT_XL_REG, 3, buffer))
 8004e3c:	2308      	movs	r3, #8
 8004e3e:	18fb      	adds	r3, r7, r3
 8004e40:	6878      	ldr	r0, [r7, #4]
 8004e42:	2203      	movs	r2, #3
 8004e44:	2128      	movs	r1, #40	; 0x28
 8004e46:	f7ff fcec 	bl	8004822 <LPS22HB_ReadReg>
 8004e4a:	1e03      	subs	r3, r0, #0
 8004e4c:	d001      	beq.n	8004e52 <LPS22HB_Get_RawPressure+0x24>
    return LPS22HB_ERROR;
 8004e4e:	2301      	movs	r3, #1
 8004e50:	e02b      	b.n	8004eaa <LPS22HB_Get_RawPressure+0x7c>

  /* Build the raw data */
  for(i = 0; i < 3; i++)
 8004e52:	230b      	movs	r3, #11
 8004e54:	18fb      	adds	r3, r7, r3
 8004e56:	2200      	movs	r2, #0
 8004e58:	701a      	strb	r2, [r3, #0]
 8004e5a:	e013      	b.n	8004e84 <LPS22HB_Get_RawPressure+0x56>
    tmp |= (((uint32_t)buffer[i]) << (8 * i));
 8004e5c:	210b      	movs	r1, #11
 8004e5e:	187b      	adds	r3, r7, r1
 8004e60:	781b      	ldrb	r3, [r3, #0]
 8004e62:	2208      	movs	r2, #8
 8004e64:	18ba      	adds	r2, r7, r2
 8004e66:	5cd3      	ldrb	r3, [r2, r3]
 8004e68:	001a      	movs	r2, r3
 8004e6a:	187b      	adds	r3, r7, r1
 8004e6c:	781b      	ldrb	r3, [r3, #0]
 8004e6e:	00db      	lsls	r3, r3, #3
 8004e70:	409a      	lsls	r2, r3
 8004e72:	0013      	movs	r3, r2
 8004e74:	68fa      	ldr	r2, [r7, #12]
 8004e76:	4313      	orrs	r3, r2
 8004e78:	60fb      	str	r3, [r7, #12]
  for(i = 0; i < 3; i++)
 8004e7a:	187b      	adds	r3, r7, r1
 8004e7c:	781a      	ldrb	r2, [r3, #0]
 8004e7e:	187b      	adds	r3, r7, r1
 8004e80:	3201      	adds	r2, #1
 8004e82:	701a      	strb	r2, [r3, #0]
 8004e84:	230b      	movs	r3, #11
 8004e86:	18fb      	adds	r3, r7, r3
 8004e88:	781b      	ldrb	r3, [r3, #0]
 8004e8a:	2b02      	cmp	r3, #2
 8004e8c:	d9e6      	bls.n	8004e5c <LPS22HB_Get_RawPressure+0x2e>

  /* convert the 2's complement 24 bit to 2's complement 32 bit */
  if(tmp & 0x00800000)
 8004e8e:	68fa      	ldr	r2, [r7, #12]
 8004e90:	2380      	movs	r3, #128	; 0x80
 8004e92:	041b      	lsls	r3, r3, #16
 8004e94:	4013      	ands	r3, r2
 8004e96:	d004      	beq.n	8004ea2 <LPS22HB_Get_RawPressure+0x74>
    tmp |= 0xFF000000;
 8004e98:	68fb      	ldr	r3, [r7, #12]
 8004e9a:	22ff      	movs	r2, #255	; 0xff
 8004e9c:	0612      	lsls	r2, r2, #24
 8004e9e:	4313      	orrs	r3, r2
 8004ea0:	60fb      	str	r3, [r7, #12]

  *raw_press = ((int32_t)tmp);
 8004ea2:	68fa      	ldr	r2, [r7, #12]
 8004ea4:	683b      	ldr	r3, [r7, #0]
 8004ea6:	601a      	str	r2, [r3, #0]

  return LPS22HB_OK;
 8004ea8:	2300      	movs	r3, #0
}
 8004eaa:	0018      	movs	r0, r3
 8004eac:	46bd      	mov	sp, r7
 8004eae:	b004      	add	sp, #16
 8004eb0:	bd80      	pop	{r7, pc}
	...

08004eb4 <LPS22HB_Get_Pressure>:
* @param  *handle Device handle.
* @param      The buffer to empty with the pressure value that must be divided by 100 to get the value in hPA
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_Pressure(void *handle, int32_t* Pout)
{
 8004eb4:	b580      	push	{r7, lr}
 8004eb6:	b084      	sub	sp, #16
 8004eb8:	af00      	add	r7, sp, #0
 8004eba:	6078      	str	r0, [r7, #4]
 8004ebc:	6039      	str	r1, [r7, #0]
  int32_t raw_press;

  if(LPS22HB_Get_RawPressure(handle, &raw_press))
 8004ebe:	230c      	movs	r3, #12
 8004ec0:	18fa      	adds	r2, r7, r3
 8004ec2:	687b      	ldr	r3, [r7, #4]
 8004ec4:	0011      	movs	r1, r2
 8004ec6:	0018      	movs	r0, r3
 8004ec8:	f7ff ffb1 	bl	8004e2e <LPS22HB_Get_RawPressure>
 8004ecc:	1e03      	subs	r3, r0, #0
 8004ece:	d001      	beq.n	8004ed4 <LPS22HB_Get_Pressure+0x20>
    return LPS22HB_ERROR;
 8004ed0:	2301      	movs	r3, #1
 8004ed2:	e00c      	b.n	8004eee <LPS22HB_Get_Pressure+0x3a>

  *Pout = (raw_press * 100) / 4096;
 8004ed4:	68fb      	ldr	r3, [r7, #12]
 8004ed6:	2264      	movs	r2, #100	; 0x64
 8004ed8:	4353      	muls	r3, r2
 8004eda:	2b00      	cmp	r3, #0
 8004edc:	da02      	bge.n	8004ee4 <LPS22HB_Get_Pressure+0x30>
 8004ede:	4a06      	ldr	r2, [pc, #24]	; (8004ef8 <LPS22HB_Get_Pressure+0x44>)
 8004ee0:	4694      	mov	ip, r2
 8004ee2:	4463      	add	r3, ip
 8004ee4:	131b      	asrs	r3, r3, #12
 8004ee6:	001a      	movs	r2, r3
 8004ee8:	683b      	ldr	r3, [r7, #0]
 8004eea:	601a      	str	r2, [r3, #0]

  return LPS22HB_OK;
 8004eec:	2300      	movs	r3, #0
}
 8004eee:	0018      	movs	r0, r3
 8004ef0:	46bd      	mov	sp, r7
 8004ef2:	b004      	add	sp, #16
 8004ef4:	bd80      	pop	{r7, pc}
 8004ef6:	46c0      	nop			; (mov r8, r8)
 8004ef8:	00000fff 	.word	0x00000fff

08004efc <LPS22HB_Get_RawTemperature>:
* @param  *handle Device handle.
* @param     Buffer to empty with the temperature raw tmp.
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_RawTemperature(void *handle, int16_t* raw_data)
{
 8004efc:	b580      	push	{r7, lr}
 8004efe:	b084      	sub	sp, #16
 8004f00:	af00      	add	r7, sp, #0
 8004f02:	6078      	str	r0, [r7, #4]
 8004f04:	6039      	str	r1, [r7, #0]
  uint8_t buffer[2];
  uint16_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_TEMP_OUT_L_REG, 2, buffer))
 8004f06:	230c      	movs	r3, #12
 8004f08:	18fb      	adds	r3, r7, r3
 8004f0a:	6878      	ldr	r0, [r7, #4]
 8004f0c:	2202      	movs	r2, #2
 8004f0e:	212b      	movs	r1, #43	; 0x2b
 8004f10:	f7ff fc87 	bl	8004822 <LPS22HB_ReadReg>
 8004f14:	1e03      	subs	r3, r0, #0
 8004f16:	d001      	beq.n	8004f1c <LPS22HB_Get_RawTemperature+0x20>
    return LPS22HB_ERROR;
 8004f18:	2301      	movs	r3, #1
 8004f1a:	e012      	b.n	8004f42 <LPS22HB_Get_RawTemperature+0x46>

  /* Build the raw tmp */
  tmp = (((uint16_t)buffer[1]) << 8) + (uint16_t)buffer[0];
 8004f1c:	220c      	movs	r2, #12
 8004f1e:	18bb      	adds	r3, r7, r2
 8004f20:	785b      	ldrb	r3, [r3, #1]
 8004f22:	b29b      	uxth	r3, r3
 8004f24:	021b      	lsls	r3, r3, #8
 8004f26:	b299      	uxth	r1, r3
 8004f28:	18bb      	adds	r3, r7, r2
 8004f2a:	781b      	ldrb	r3, [r3, #0]
 8004f2c:	b29a      	uxth	r2, r3
 8004f2e:	200e      	movs	r0, #14
 8004f30:	183b      	adds	r3, r7, r0
 8004f32:	188a      	adds	r2, r1, r2
 8004f34:	801a      	strh	r2, [r3, #0]

  *raw_data = ((int16_t)tmp);
 8004f36:	183b      	adds	r3, r7, r0
 8004f38:	2200      	movs	r2, #0
 8004f3a:	5e9a      	ldrsh	r2, [r3, r2]
 8004f3c:	683b      	ldr	r3, [r7, #0]
 8004f3e:	801a      	strh	r2, [r3, #0]

  return LPS22HB_OK;
 8004f40:	2300      	movs	r3, #0
}
 8004f42:	0018      	movs	r0, r3
 8004f44:	46bd      	mov	sp, r7
 8004f46:	b004      	add	sp, #16
 8004f48:	bd80      	pop	{r7, pc}

08004f4a <LPS22HB_Get_Temperature>:
* @param  *handle Device handle.
* @param Buffer to empty with the temperature value that must be divided by 10 to get the value in C
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_Temperature(void *handle, int16_t* Tout)
{
 8004f4a:	b580      	push	{r7, lr}
 8004f4c:	b084      	sub	sp, #16
 8004f4e:	af00      	add	r7, sp, #0
 8004f50:	6078      	str	r0, [r7, #4]
 8004f52:	6039      	str	r1, [r7, #0]
  int16_t raw_data;

  if(LPS22HB_Get_RawTemperature(handle, &raw_data))
 8004f54:	230e      	movs	r3, #14
 8004f56:	18fa      	adds	r2, r7, r3
 8004f58:	687b      	ldr	r3, [r7, #4]
 8004f5a:	0011      	movs	r1, r2
 8004f5c:	0018      	movs	r0, r3
 8004f5e:	f7ff ffcd 	bl	8004efc <LPS22HB_Get_RawTemperature>
 8004f62:	1e03      	subs	r3, r0, #0
 8004f64:	d001      	beq.n	8004f6a <LPS22HB_Get_Temperature+0x20>
    return LPS22HB_ERROR;
 8004f66:	2301      	movs	r3, #1
 8004f68:	e00c      	b.n	8004f84 <LPS22HB_Get_Temperature+0x3a>

  *Tout = (raw_data * 10) / 100;
 8004f6a:	230e      	movs	r3, #14
 8004f6c:	18fb      	adds	r3, r7, r3
 8004f6e:	2200      	movs	r2, #0
 8004f70:	5e9b      	ldrsh	r3, [r3, r2]
 8004f72:	210a      	movs	r1, #10
 8004f74:	0018      	movs	r0, r3
 8004f76:	f7fb f95b 	bl	8000230 <__divsi3>
 8004f7a:	0003      	movs	r3, r0
 8004f7c:	b21a      	sxth	r2, r3
 8004f7e:	683b      	ldr	r3, [r7, #0]
 8004f80:	801a      	strh	r2, [r3, #0]

  return LPS22HB_OK;
 8004f82:	2300      	movs	r3, #0
}
 8004f84:	0018      	movs	r0, r3
 8004f86:	46bd      	mov	sp, r7
 8004f88:	b004      	add	sp, #16
 8004f8a:	bd80      	pop	{r7, pc}

08004f8c <LPS22HB_Set_FifoMode>:
* @param  *handle Device handle.
* @param  Fifo Mode struct
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoMode(void *handle, LPS22HB_FifoMode_et fifomode)
{
 8004f8c:	b580      	push	{r7, lr}
 8004f8e:	b084      	sub	sp, #16
 8004f90:	af00      	add	r7, sp, #0
 8004f92:	6078      	str	r0, [r7, #4]
 8004f94:	000a      	movs	r2, r1
 8004f96:	1cfb      	adds	r3, r7, #3
 8004f98:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_FifoMode(fifomode));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
 8004f9a:	230f      	movs	r3, #15
 8004f9c:	18fb      	adds	r3, r7, r3
 8004f9e:	6878      	ldr	r0, [r7, #4]
 8004fa0:	2201      	movs	r2, #1
 8004fa2:	2114      	movs	r1, #20
 8004fa4:	f7ff fc3d 	bl	8004822 <LPS22HB_ReadReg>
 8004fa8:	1e03      	subs	r3, r0, #0
 8004faa:	d001      	beq.n	8004fb0 <LPS22HB_Set_FifoMode+0x24>
    return LPS22HB_ERROR;
 8004fac:	2301      	movs	r3, #1
 8004fae:	e01a      	b.n	8004fe6 <LPS22HB_Set_FifoMode+0x5a>

  tmp &= ~LPS22HB_FIFO_MODE_MASK;
 8004fb0:	210f      	movs	r1, #15
 8004fb2:	187b      	adds	r3, r7, r1
 8004fb4:	781b      	ldrb	r3, [r3, #0]
 8004fb6:	221f      	movs	r2, #31
 8004fb8:	4013      	ands	r3, r2
 8004fba:	b2da      	uxtb	r2, r3
 8004fbc:	187b      	adds	r3, r7, r1
 8004fbe:	701a      	strb	r2, [r3, #0]
  tmp |= (uint8_t)fifomode;
 8004fc0:	187b      	adds	r3, r7, r1
 8004fc2:	781a      	ldrb	r2, [r3, #0]
 8004fc4:	1cfb      	adds	r3, r7, #3
 8004fc6:	781b      	ldrb	r3, [r3, #0]
 8004fc8:	4313      	orrs	r3, r2
 8004fca:	b2da      	uxtb	r2, r3
 8004fcc:	187b      	adds	r3, r7, r1
 8004fce:	701a      	strb	r2, [r3, #0]

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
 8004fd0:	187b      	adds	r3, r7, r1
 8004fd2:	6878      	ldr	r0, [r7, #4]
 8004fd4:	2201      	movs	r2, #1
 8004fd6:	2114      	movs	r1, #20
 8004fd8:	f7ff fc57 	bl	800488a <LPS22HB_WriteReg>
 8004fdc:	1e03      	subs	r3, r0, #0
 8004fde:	d001      	beq.n	8004fe4 <LPS22HB_Set_FifoMode+0x58>
    return LPS22HB_ERROR;
 8004fe0:	2301      	movs	r3, #1
 8004fe2:	e000      	b.n	8004fe6 <LPS22HB_Set_FifoMode+0x5a>

  return LPS22HB_OK;
 8004fe4:	2300      	movs	r3, #0
}
 8004fe6:	0018      	movs	r0, r3
 8004fe8:	46bd      	mov	sp, r7
 8004fea:	b004      	add	sp, #16
 8004fec:	bd80      	pop	{r7, pc}

08004fee <LPS22HB_Get_FifoMode>:
* @param  *handle Device handle.
* @param   buffer to empty with fifo mode tmp
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_FifoMode(void *handle, LPS22HB_FifoMode_et* fifomode)
{
 8004fee:	b580      	push	{r7, lr}
 8004ff0:	b084      	sub	sp, #16
 8004ff2:	af00      	add	r7, sp, #0
 8004ff4:	6078      	str	r0, [r7, #4]
 8004ff6:	6039      	str	r1, [r7, #0]
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
 8004ff8:	230f      	movs	r3, #15
 8004ffa:	18fb      	adds	r3, r7, r3
 8004ffc:	6878      	ldr	r0, [r7, #4]
 8004ffe:	2201      	movs	r2, #1
 8005000:	2114      	movs	r1, #20
 8005002:	f7ff fc0e 	bl	8004822 <LPS22HB_ReadReg>
 8005006:	1e03      	subs	r3, r0, #0
 8005008:	d001      	beq.n	800500e <LPS22HB_Get_FifoMode+0x20>
    return LPS22HB_ERROR;
 800500a:	2301      	movs	r3, #1
 800500c:	e00c      	b.n	8005028 <LPS22HB_Get_FifoMode+0x3a>

  tmp &= LPS22HB_FIFO_MODE_MASK;
 800500e:	210f      	movs	r1, #15
 8005010:	187b      	adds	r3, r7, r1
 8005012:	781b      	ldrb	r3, [r3, #0]
 8005014:	221f      	movs	r2, #31
 8005016:	4393      	bics	r3, r2
 8005018:	b2da      	uxtb	r2, r3
 800501a:	187b      	adds	r3, r7, r1
 800501c:	701a      	strb	r2, [r3, #0]
  *fifomode = (LPS22HB_FifoMode_et)tmp;
 800501e:	187b      	adds	r3, r7, r1
 8005020:	781a      	ldrb	r2, [r3, #0]
 8005022:	683b      	ldr	r3, [r7, #0]
 8005024:	701a      	strb	r2, [r3, #0]

  return LPS22HB_OK;
 8005026:	2300      	movs	r3, #0
}
 8005028:	0018      	movs	r0, r3
 800502a:	46bd      	mov	sp, r7
 800502c:	b004      	add	sp, #16
 800502e:	bd80      	pop	{r7, pc}

08005030 <LPS22HB_Set_FifoWatermarkLevel>:
* @param  *handle Device handle.
* @param    Watermark level value [0 31]
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoWatermarkLevel(void *handle, uint8_t wtmlevel)
{
 8005030:	b580      	push	{r7, lr}
 8005032:	b084      	sub	sp, #16
 8005034:	af00      	add	r7, sp, #0
 8005036:	6078      	str	r0, [r7, #4]
 8005038:	000a      	movs	r2, r1
 800503a:	1cfb      	adds	r3, r7, #3
 800503c:	701a      	strb	r2, [r3, #0]
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_WtmLevel(wtmlevel));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
 800503e:	230f      	movs	r3, #15
 8005040:	18fb      	adds	r3, r7, r3
 8005042:	6878      	ldr	r0, [r7, #4]
 8005044:	2201      	movs	r2, #1
 8005046:	2114      	movs	r1, #20
 8005048:	f7ff fbeb 	bl	8004822 <LPS22HB_ReadReg>
 800504c:	1e03      	subs	r3, r0, #0
 800504e:	d001      	beq.n	8005054 <LPS22HB_Set_FifoWatermarkLevel+0x24>
    return LPS22HB_ERROR;
 8005050:	2301      	movs	r3, #1
 8005052:	e01a      	b.n	800508a <LPS22HB_Set_FifoWatermarkLevel+0x5a>

  tmp &= ~LPS22HB_WTM_POINT_MASK;
 8005054:	210f      	movs	r1, #15
 8005056:	187b      	adds	r3, r7, r1
 8005058:	781b      	ldrb	r3, [r3, #0]
 800505a:	221f      	movs	r2, #31
 800505c:	4393      	bics	r3, r2
 800505e:	b2da      	uxtb	r2, r3
 8005060:	187b      	adds	r3, r7, r1
 8005062:	701a      	strb	r2, [r3, #0]
  tmp |= wtmlevel;
 8005064:	187b      	adds	r3, r7, r1
 8005066:	781a      	ldrb	r2, [r3, #0]
 8005068:	1cfb      	adds	r3, r7, #3
 800506a:	781b      	ldrb	r3, [r3, #0]
 800506c:	4313      	orrs	r3, r2
 800506e:	b2da      	uxtb	r2, r3
 8005070:	187b      	adds	r3, r7, r1
 8005072:	701a      	strb	r2, [r3, #0]

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
 8005074:	187b      	adds	r3, r7, r1
 8005076:	6878      	ldr	r0, [r7, #4]
 8005078:	2201      	movs	r2, #1
 800507a:	2114      	movs	r1, #20
 800507c:	f7ff fc05 	bl	800488a <LPS22HB_WriteReg>
 8005080:	1e03      	subs	r3, r0, #0
 8005082:	d001      	beq.n	8005088 <LPS22HB_Set_FifoWatermarkLevel+0x58>
    return LPS22HB_ERROR;
 8005084:	2301      	movs	r3, #1
 8005086:	e000      	b.n	800508a <LPS22HB_Set_FifoWatermarkLevel+0x5a>

  return LPS22HB_OK;
 8005088:	2300      	movs	r3, #0
}
 800508a:	0018      	movs	r0, r3
 800508c:	46bd      	mov	sp, r7
 800508e:	b004      	add	sp, #16
 8005090:	bd80      	pop	{r7, pc}

08005092 <LPS22HB_Get_FifoWatermarkLevel>:
* @param  *handle Device handle.
* @param   buffer to empty with watermak level[0,31] value read from sensor
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_FifoWatermarkLevel(void *handle, uint8_t *wtmlevel)
{
 8005092:	b580      	push	{r7, lr}
 8005094:	b082      	sub	sp, #8
 8005096:	af00      	add	r7, sp, #0
 8005098:	6078      	str	r0, [r7, #4]
 800509a:	6039      	str	r1, [r7, #0]
  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, wtmlevel))
 800509c:	683b      	ldr	r3, [r7, #0]
 800509e:	6878      	ldr	r0, [r7, #4]
 80050a0:	2201      	movs	r2, #1
 80050a2:	2114      	movs	r1, #20
 80050a4:	f7ff fbbd 	bl	8004822 <LPS22HB_ReadReg>
 80050a8:	1e03      	subs	r3, r0, #0
 80050aa:	d001      	beq.n	80050b0 <LPS22HB_Get_FifoWatermarkLevel+0x1e>
    return LPS22HB_ERROR;
 80050ac:	2301      	movs	r3, #1
 80050ae:	e007      	b.n	80050c0 <LPS22HB_Get_FifoWatermarkLevel+0x2e>

  *wtmlevel &= LPS22HB_WTM_POINT_MASK;
 80050b0:	683b      	ldr	r3, [r7, #0]
 80050b2:	781b      	ldrb	r3, [r3, #0]
 80050b4:	221f      	movs	r2, #31
 80050b6:	4013      	ands	r3, r2
 80050b8:	b2da      	uxtb	r2, r3
 80050ba:	683b      	ldr	r3, [r7, #0]
 80050bc:	701a      	strb	r2, [r3, #0]

  return LPS22HB_OK;
 80050be:	2300      	movs	r3, #0
}
 80050c0:	0018      	movs	r0, r3
 80050c2:	46bd      	mov	sp, r7
 80050c4:	b002      	add	sp, #8
 80050c6:	bd80      	pop	{r7, pc}

080050c8 <LPS22HB_Get_FifoStatus>:
* @param  *handle Device handle.
* @param    Status Flag: FIFO_FTH,FIFO_EMPTY,FIFO_FULL,FIFO_OVR and level of the FIFO->FIFO_LEVEL
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_FifoStatus(void *handle, LPS22HB_FifoStatus_st* status)
{
 80050c8:	b580      	push	{r7, lr}
 80050ca:	b084      	sub	sp, #16
 80050cc:	af00      	add	r7, sp, #0
 80050ce:	6078      	str	r0, [r7, #4]
 80050d0:	6039      	str	r1, [r7, #0]
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_STATUS_FIFO_REG, 1, &tmp))
 80050d2:	230f      	movs	r3, #15
 80050d4:	18fb      	adds	r3, r7, r3
 80050d6:	6878      	ldr	r0, [r7, #4]
 80050d8:	2201      	movs	r2, #1
 80050da:	2126      	movs	r1, #38	; 0x26
 80050dc:	f7ff fba1 	bl	8004822 <LPS22HB_ReadReg>
 80050e0:	1e03      	subs	r3, r0, #0
 80050e2:	d001      	beq.n	80050e8 <LPS22HB_Get_FifoStatus+0x20>
    return LPS22HB_ERROR;
 80050e4:	2301      	movs	r3, #1
 80050e6:	e02d      	b.n	8005144 <LPS22HB_Get_FifoStatus+0x7c>

  status->FIFO_FTH = (uint8_t)((tmp & LPS22HB_FTH_FIFO_MASK) >> LPS22HB_FTH_FIFO_BIT);
 80050e8:	210f      	movs	r1, #15
 80050ea:	187b      	adds	r3, r7, r1
 80050ec:	781b      	ldrb	r3, [r3, #0]
 80050ee:	09db      	lsrs	r3, r3, #7
 80050f0:	b2da      	uxtb	r2, r3
 80050f2:	683b      	ldr	r3, [r7, #0]
 80050f4:	711a      	strb	r2, [r3, #4]
  status->FIFO_OVR = (uint8_t)((tmp & LPS22HB_OVR_FIFO_MASK) >> LPS22HB_OVR_FIFO_BIT);
 80050f6:	187b      	adds	r3, r7, r1
 80050f8:	781b      	ldrb	r3, [r3, #0]
 80050fa:	119b      	asrs	r3, r3, #6
 80050fc:	b2db      	uxtb	r3, r3
 80050fe:	2201      	movs	r2, #1
 8005100:	4013      	ands	r3, r2
 8005102:	b2da      	uxtb	r2, r3
 8005104:	683b      	ldr	r3, [r7, #0]
 8005106:	70da      	strb	r2, [r3, #3]
  status->FIFO_LEVEL = (uint8_t)(tmp & LPS22HB_LEVEL_FIFO_MASK);
 8005108:	187b      	adds	r3, r7, r1
 800510a:	781b      	ldrb	r3, [r3, #0]
 800510c:	223f      	movs	r2, #63	; 0x3f
 800510e:	4013      	ands	r3, r2
 8005110:	b2da      	uxtb	r2, r3
 8005112:	683b      	ldr	r3, [r7, #0]
 8005114:	701a      	strb	r2, [r3, #0]

  if(status->FIFO_LEVEL == LPS22HB_FIFO_EMPTY)
 8005116:	683b      	ldr	r3, [r7, #0]
 8005118:	781b      	ldrb	r3, [r3, #0]
 800511a:	2b00      	cmp	r3, #0
 800511c:	d103      	bne.n	8005126 <LPS22HB_Get_FifoStatus+0x5e>
    status->FIFO_EMPTY = 0x01;
 800511e:	683b      	ldr	r3, [r7, #0]
 8005120:	2201      	movs	r2, #1
 8005122:	705a      	strb	r2, [r3, #1]
 8005124:	e002      	b.n	800512c <LPS22HB_Get_FifoStatus+0x64>
  else
    status->FIFO_EMPTY = 0x00;
 8005126:	683b      	ldr	r3, [r7, #0]
 8005128:	2200      	movs	r2, #0
 800512a:	705a      	strb	r2, [r3, #1]

  if (status->FIFO_LEVEL == LPS22HB_FIFO_FULL)
 800512c:	683b      	ldr	r3, [r7, #0]
 800512e:	781b      	ldrb	r3, [r3, #0]
 8005130:	2b20      	cmp	r3, #32
 8005132:	d103      	bne.n	800513c <LPS22HB_Get_FifoStatus+0x74>
    status->FIFO_FULL = 0x01;
 8005134:	683b      	ldr	r3, [r7, #0]
 8005136:	2201      	movs	r2, #1
 8005138:	709a      	strb	r2, [r3, #2]
 800513a:	e002      	b.n	8005142 <LPS22HB_Get_FifoStatus+0x7a>
  else
    status->FIFO_FULL = 0x00;
 800513c:	683b      	ldr	r3, [r7, #0]
 800513e:	2200      	movs	r2, #0
 8005140:	709a      	strb	r2, [r3, #2]


  return LPS22HB_OK;
 8005142:	2300      	movs	r3, #0
}
 8005144:	0018      	movs	r0, r3
 8005146:	46bd      	mov	sp, r7
 8005148:	b004      	add	sp, #16
 800514a:	bd80      	pop	{r7, pc}

0800514c <LPS22HB_P_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Init( DrvContextTypeDef *handle )
{
 800514c:	b580      	push	{r7, lr}
 800514e:	b084      	sub	sp, #16
 8005150:	af00      	add	r7, sp, #0
 8005152:	6078      	str	r0, [r7, #4]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 8005154:	687b      	ldr	r3, [r7, #4]
 8005156:	689b      	ldr	r3, [r3, #8]
 8005158:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 800515a:	681b      	ldr	r3, [r3, #0]
 800515c:	60fb      	str	r3, [r7, #12]

  /* Check if the LPS22HB temperature sensor is already initialized. */
  /* If yes, skip the initialize function, if not call initialize function */
  if(comboData->isTempInitialized == 0)
 800515e:	68fb      	ldr	r3, [r7, #12]
 8005160:	785b      	ldrb	r3, [r3, #1]
 8005162:	2b00      	cmp	r3, #0
 8005164:	d10a      	bne.n	800517c <LPS22HB_P_Init+0x30>
  {
    if(LPS22HB_Initialize(handle, comboData) == COMPONENT_ERROR)
 8005166:	68fa      	ldr	r2, [r7, #12]
 8005168:	687b      	ldr	r3, [r7, #4]
 800516a:	0011      	movs	r1, r2
 800516c:	0018      	movs	r0, r3
 800516e:	f000 fadd 	bl	800572c <LPS22HB_Initialize>
 8005172:	0003      	movs	r3, r0
 8005174:	2b01      	cmp	r3, #1
 8005176:	d101      	bne.n	800517c <LPS22HB_P_Init+0x30>
    {
      return COMPONENT_ERROR;
 8005178:	2301      	movs	r3, #1
 800517a:	e006      	b.n	800518a <LPS22HB_P_Init+0x3e>
    }
  }

  comboData->isPressInitialized = 1;
 800517c:	68fb      	ldr	r3, [r7, #12]
 800517e:	2201      	movs	r2, #1
 8005180:	701a      	strb	r2, [r3, #0]

  handle->isInitialized = 1;
 8005182:	687b      	ldr	r3, [r7, #4]
 8005184:	2201      	movs	r2, #1
 8005186:	70da      	strb	r2, [r3, #3]

  return COMPONENT_OK;
 8005188:	2300      	movs	r3, #0
}
 800518a:	0018      	movs	r0, r3
 800518c:	46bd      	mov	sp, r7
 800518e:	b004      	add	sp, #16
 8005190:	bd80      	pop	{r7, pc}

08005192 <LPS22HB_P_DeInit>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_DeInit( DrvContextTypeDef *handle )
{
 8005192:	b580      	push	{r7, lr}
 8005194:	b084      	sub	sp, #16
 8005196:	af00      	add	r7, sp, #0
 8005198:	6078      	str	r0, [r7, #4]

  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 800519a:	687b      	ldr	r3, [r7, #4]
 800519c:	689b      	ldr	r3, [r3, #8]
 800519e:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 80051a0:	681b      	ldr	r3, [r3, #0]
 80051a2:	60fb      	str	r3, [r7, #12]

  /* Check if the LPS22HB temperature sensor is already initialized. */
  /* If yes, skip the deinitialize function, if not call deinitialize function */
  if(comboData->isTempInitialized == 0)
 80051a4:	68fb      	ldr	r3, [r7, #12]
 80051a6:	785b      	ldrb	r3, [r3, #1]
 80051a8:	2b00      	cmp	r3, #0
 80051aa:	d108      	bne.n	80051be <LPS22HB_P_DeInit+0x2c>
  {
    if(LPS22HB_P_Sensor_Disable(handle) == COMPONENT_ERROR)
 80051ac:	687b      	ldr	r3, [r7, #4]
 80051ae:	0018      	movs	r0, r3
 80051b0:	f000 f836 	bl	8005220 <LPS22HB_P_Sensor_Disable>
 80051b4:	0003      	movs	r3, r0
 80051b6:	2b01      	cmp	r3, #1
 80051b8:	d101      	bne.n	80051be <LPS22HB_P_DeInit+0x2c>
    {
      return COMPONENT_ERROR;
 80051ba:	2301      	movs	r3, #1
 80051bc:	e006      	b.n	80051cc <LPS22HB_P_DeInit+0x3a>
    }
  }

  comboData->isPressInitialized = 0;
 80051be:	68fb      	ldr	r3, [r7, #12]
 80051c0:	2200      	movs	r2, #0
 80051c2:	701a      	strb	r2, [r3, #0]

  handle->isInitialized = 0;
 80051c4:	687b      	ldr	r3, [r7, #4]
 80051c6:	2200      	movs	r2, #0
 80051c8:	70da      	strb	r2, [r3, #3]

  return COMPONENT_OK;
 80051ca:	2300      	movs	r3, #0
}
 80051cc:	0018      	movs	r0, r3
 80051ce:	46bd      	mov	sp, r7
 80051d0:	b004      	add	sp, #16
 80051d2:	bd80      	pop	{r7, pc}

080051d4 <LPS22HB_P_Sensor_Enable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Sensor_Enable( DrvContextTypeDef *handle )
{
 80051d4:	b580      	push	{r7, lr}
 80051d6:	b084      	sub	sp, #16
 80051d8:	af00      	add	r7, sp, #0
 80051da:	6078      	str	r0, [r7, #4]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 80051dc:	687b      	ldr	r3, [r7, #4]
 80051de:	689b      	ldr	r3, [r3, #8]
 80051e0:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 80051e2:	681b      	ldr	r3, [r3, #0]
 80051e4:	60fb      	str	r3, [r7, #12]

  /* Check if the component is already enabled */
  if ( handle->isEnabled == 1 )
 80051e6:	687b      	ldr	r3, [r7, #4]
 80051e8:	791b      	ldrb	r3, [r3, #4]
 80051ea:	2b01      	cmp	r3, #1
 80051ec:	d101      	bne.n	80051f2 <LPS22HB_P_Sensor_Enable+0x1e>
  {
    return COMPONENT_OK;
 80051ee:	2300      	movs	r3, #0
 80051f0:	e012      	b.n	8005218 <LPS22HB_P_Sensor_Enable+0x44>
  }

  if(LPS22HB_Set_ODR_Value_When_Enabled(handle, comboData->Last_ODR, comboData) == COMPONENT_ERROR)
 80051f2:	68fb      	ldr	r3, [r7, #12]
 80051f4:	6859      	ldr	r1, [r3, #4]
 80051f6:	68fa      	ldr	r2, [r7, #12]
 80051f8:	687b      	ldr	r3, [r7, #4]
 80051fa:	0018      	movs	r0, r3
 80051fc:	f000 fc4c 	bl	8005a98 <LPS22HB_Set_ODR_Value_When_Enabled>
 8005200:	0003      	movs	r3, r0
 8005202:	2b01      	cmp	r3, #1
 8005204:	d101      	bne.n	800520a <LPS22HB_P_Sensor_Enable+0x36>
  {
    return COMPONENT_ERROR;
 8005206:	2301      	movs	r3, #1
 8005208:	e006      	b.n	8005218 <LPS22HB_P_Sensor_Enable+0x44>
  }

  comboData->isPressEnabled = 1;
 800520a:	68fb      	ldr	r3, [r7, #12]
 800520c:	2201      	movs	r2, #1
 800520e:	709a      	strb	r2, [r3, #2]

  handle->isEnabled = 1;
 8005210:	687b      	ldr	r3, [r7, #4]
 8005212:	2201      	movs	r2, #1
 8005214:	711a      	strb	r2, [r3, #4]

  return COMPONENT_OK;
 8005216:	2300      	movs	r3, #0
}
 8005218:	0018      	movs	r0, r3
 800521a:	46bd      	mov	sp, r7
 800521c:	b004      	add	sp, #16
 800521e:	bd80      	pop	{r7, pc}

08005220 <LPS22HB_P_Sensor_Disable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Sensor_Disable( DrvContextTypeDef *handle )
{
 8005220:	b580      	push	{r7, lr}
 8005222:	b084      	sub	sp, #16
 8005224:	af00      	add	r7, sp, #0
 8005226:	6078      	str	r0, [r7, #4]

  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 8005228:	687b      	ldr	r3, [r7, #4]
 800522a:	689b      	ldr	r3, [r3, #8]
 800522c:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 800522e:	681b      	ldr	r3, [r3, #0]
 8005230:	60fb      	str	r3, [r7, #12]

  /* Check if the component is already disabled */
  if ( handle->isEnabled == 0 )
 8005232:	687b      	ldr	r3, [r7, #4]
 8005234:	791b      	ldrb	r3, [r3, #4]
 8005236:	2b00      	cmp	r3, #0
 8005238:	d101      	bne.n	800523e <LPS22HB_P_Sensor_Disable+0x1e>
  {
    return COMPONENT_OK;
 800523a:	2300      	movs	r3, #0
 800523c:	e014      	b.n	8005268 <LPS22HB_P_Sensor_Disable+0x48>
  }

  /* Check if the LPS22HB temperature sensor is still enable. */
  /* If yes, skip the disable function, if not call disable function */
  if(comboData->isTempEnabled == 0)
 800523e:	68fb      	ldr	r3, [r7, #12]
 8005240:	78db      	ldrb	r3, [r3, #3]
 8005242:	2b00      	cmp	r3, #0
 8005244:	d109      	bne.n	800525a <LPS22HB_P_Sensor_Disable+0x3a>
  {
    /* Power down the device */
    if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 8005246:	687b      	ldr	r3, [r7, #4]
 8005248:	2100      	movs	r1, #0
 800524a:	0018      	movs	r0, r3
 800524c:	f7ff fb96 	bl	800497c <LPS22HB_Set_Odr>
 8005250:	0003      	movs	r3, r0
 8005252:	2b01      	cmp	r3, #1
 8005254:	d101      	bne.n	800525a <LPS22HB_P_Sensor_Disable+0x3a>
    {
      return COMPONENT_ERROR;
 8005256:	2301      	movs	r3, #1
 8005258:	e006      	b.n	8005268 <LPS22HB_P_Sensor_Disable+0x48>
    }
  }

  comboData->isPressEnabled = 0;
 800525a:	68fb      	ldr	r3, [r7, #12]
 800525c:	2200      	movs	r2, #0
 800525e:	709a      	strb	r2, [r3, #2]

  handle->isEnabled = 0;
 8005260:	687b      	ldr	r3, [r7, #4]
 8005262:	2200      	movs	r2, #0
 8005264:	711a      	strb	r2, [r3, #4]

  return COMPONENT_OK;
 8005266:	2300      	movs	r3, #0
}
 8005268:	0018      	movs	r0, r3
 800526a:	46bd      	mov	sp, r7
 800526c:	b004      	add	sp, #16
 800526e:	bd80      	pop	{r7, pc}

08005270 <LPS22HB_P_Get_WhoAmI>:
 * @param who_am_i pointer to the value of WHO_AM_I register
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Get_WhoAmI( DrvContextTypeDef *handle, uint8_t *who_am_i )
{
 8005270:	b580      	push	{r7, lr}
 8005272:	b082      	sub	sp, #8
 8005274:	af00      	add	r7, sp, #0
 8005276:	6078      	str	r0, [r7, #4]
 8005278:	6039      	str	r1, [r7, #0]

  return LPS22HB_Get_WhoAmI( handle, who_am_i );
 800527a:	683a      	ldr	r2, [r7, #0]
 800527c:	687b      	ldr	r3, [r7, #4]
 800527e:	0011      	movs	r1, r2
 8005280:	0018      	movs	r0, r3
 8005282:	f000 faa7 	bl	80057d4 <LPS22HB_Get_WhoAmI>
 8005286:	0003      	movs	r3, r0
}
 8005288:	0018      	movs	r0, r3
 800528a:	46bd      	mov	sp, r7
 800528c:	b002      	add	sp, #8
 800528e:	bd80      	pop	{r7, pc}

08005290 <LPS22HB_P_Check_WhoAmI>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Check_WhoAmI( DrvContextTypeDef *handle )
{
 8005290:	b580      	push	{r7, lr}
 8005292:	b082      	sub	sp, #8
 8005294:	af00      	add	r7, sp, #0
 8005296:	6078      	str	r0, [r7, #4]

  return LPS22HB_Check_WhoAmI( handle );
 8005298:	687b      	ldr	r3, [r7, #4]
 800529a:	0018      	movs	r0, r3
 800529c:	f000 faaf 	bl	80057fe <LPS22HB_Check_WhoAmI>
 80052a0:	0003      	movs	r3, r0
}
 80052a2:	0018      	movs	r0, r3
 80052a4:	46bd      	mov	sp, r7
 80052a6:	b002      	add	sp, #8
 80052a8:	bd80      	pop	{r7, pc}

080052aa <LPS22HB_P_Get_Press>:
 * @param pressure pointer where the value is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Get_Press( DrvContextTypeDef *handle, float *pressure )
{
 80052aa:	b580      	push	{r7, lr}
 80052ac:	b082      	sub	sp, #8
 80052ae:	af00      	add	r7, sp, #0
 80052b0:	6078      	str	r0, [r7, #4]
 80052b2:	6039      	str	r1, [r7, #0]

  return LPS22HB_Get_Press( handle, pressure );
 80052b4:	683a      	ldr	r2, [r7, #0]
 80052b6:	687b      	ldr	r3, [r7, #4]
 80052b8:	0011      	movs	r1, r2
 80052ba:	0018      	movs	r0, r3
 80052bc:	f000 fac0 	bl	8005840 <LPS22HB_Get_Press>
 80052c0:	0003      	movs	r3, r0
}
 80052c2:	0018      	movs	r0, r3
 80052c4:	46bd      	mov	sp, r7
 80052c6:	b002      	add	sp, #8
 80052c8:	bd80      	pop	{r7, pc}

080052ca <LPS22HB_P_Get_ODR>:
 * @param odr pointer where the output data rate is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Get_ODR( DrvContextTypeDef *handle, float *odr )
{
 80052ca:	b580      	push	{r7, lr}
 80052cc:	b082      	sub	sp, #8
 80052ce:	af00      	add	r7, sp, #0
 80052d0:	6078      	str	r0, [r7, #4]
 80052d2:	6039      	str	r1, [r7, #0]

  return LPS22HB_Get_ODR( handle, odr );
 80052d4:	683a      	ldr	r2, [r7, #0]
 80052d6:	687b      	ldr	r3, [r7, #4]
 80052d8:	0011      	movs	r1, r2
 80052da:	0018      	movs	r0, r3
 80052dc:	f000 fb04 	bl	80058e8 <LPS22HB_Get_ODR>
 80052e0:	0003      	movs	r3, r0
}
 80052e2:	0018      	movs	r0, r3
 80052e4:	46bd      	mov	sp, r7
 80052e6:	b002      	add	sp, #8
 80052e8:	bd80      	pop	{r7, pc}

080052ea <LPS22HB_P_Set_ODR>:
 * @param odr the functional output data rate to be set
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Set_ODR( DrvContextTypeDef *handle, SensorOdr_t odr )
{
 80052ea:	b580      	push	{r7, lr}
 80052ec:	b084      	sub	sp, #16
 80052ee:	af00      	add	r7, sp, #0
 80052f0:	6078      	str	r0, [r7, #4]
 80052f2:	000a      	movs	r2, r1
 80052f4:	1cfb      	adds	r3, r7, #3
 80052f6:	701a      	strb	r2, [r3, #0]

  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 80052f8:	687b      	ldr	r3, [r7, #4]
 80052fa:	689b      	ldr	r3, [r3, #8]
 80052fc:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 80052fe:	681b      	ldr	r3, [r3, #0]
 8005300:	60fb      	str	r3, [r7, #12]

  if(handle->isEnabled == 1)
 8005302:	687b      	ldr	r3, [r7, #4]
 8005304:	791b      	ldrb	r3, [r3, #4]
 8005306:	2b01      	cmp	r3, #1
 8005308:	d10b      	bne.n	8005322 <LPS22HB_P_Set_ODR+0x38>
  {
    if(LPS22HB_Set_ODR_When_Enabled(handle, odr, comboData) == COMPONENT_ERROR)
 800530a:	68fa      	ldr	r2, [r7, #12]
 800530c:	1cfb      	adds	r3, r7, #3
 800530e:	7819      	ldrb	r1, [r3, #0]
 8005310:	687b      	ldr	r3, [r7, #4]
 8005312:	0018      	movs	r0, r3
 8005314:	f000 fb3a 	bl	800598c <LPS22HB_Set_ODR_When_Enabled>
 8005318:	0003      	movs	r3, r0
 800531a:	2b01      	cmp	r3, #1
 800531c:	d10d      	bne.n	800533a <LPS22HB_P_Set_ODR+0x50>
    {
      return COMPONENT_ERROR;
 800531e:	2301      	movs	r3, #1
 8005320:	e00c      	b.n	800533c <LPS22HB_P_Set_ODR+0x52>
    }
  }
  else
  {
    if(LPS22HB_Set_ODR_When_Disabled(handle, odr, comboData) == COMPONENT_ERROR)
 8005322:	68fa      	ldr	r2, [r7, #12]
 8005324:	1cfb      	adds	r3, r7, #3
 8005326:	7819      	ldrb	r1, [r3, #0]
 8005328:	687b      	ldr	r3, [r7, #4]
 800532a:	0018      	movs	r0, r3
 800532c:	f000 fb7c 	bl	8005a28 <LPS22HB_Set_ODR_When_Disabled>
 8005330:	0003      	movs	r3, r0
 8005332:	2b01      	cmp	r3, #1
 8005334:	d101      	bne.n	800533a <LPS22HB_P_Set_ODR+0x50>
    {
      return COMPONENT_ERROR;
 8005336:	2301      	movs	r3, #1
 8005338:	e000      	b.n	800533c <LPS22HB_P_Set_ODR+0x52>
    }
  }

  return COMPONENT_OK;
 800533a:	2300      	movs	r3, #0
}
 800533c:	0018      	movs	r0, r3
 800533e:	46bd      	mov	sp, r7
 8005340:	b004      	add	sp, #16
 8005342:	bd80      	pop	{r7, pc}

08005344 <LPS22HB_P_Set_ODR_Value>:
 * @param odr the output data rate value to be set
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Set_ODR_Value( DrvContextTypeDef *handle, float odr )
{
 8005344:	b580      	push	{r7, lr}
 8005346:	b084      	sub	sp, #16
 8005348:	af00      	add	r7, sp, #0
 800534a:	6078      	str	r0, [r7, #4]
 800534c:	6039      	str	r1, [r7, #0]

  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 800534e:	687b      	ldr	r3, [r7, #4]
 8005350:	689b      	ldr	r3, [r3, #8]
 8005352:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8005354:	681b      	ldr	r3, [r3, #0]
 8005356:	60fb      	str	r3, [r7, #12]

  if(handle->isEnabled == 1)
 8005358:	687b      	ldr	r3, [r7, #4]
 800535a:	791b      	ldrb	r3, [r3, #4]
 800535c:	2b01      	cmp	r3, #1
 800535e:	d10a      	bne.n	8005376 <LPS22HB_P_Set_ODR_Value+0x32>
  {
    if(LPS22HB_Set_ODR_Value_When_Enabled(handle, odr, comboData) == COMPONENT_ERROR)
 8005360:	68fa      	ldr	r2, [r7, #12]
 8005362:	6839      	ldr	r1, [r7, #0]
 8005364:	687b      	ldr	r3, [r7, #4]
 8005366:	0018      	movs	r0, r3
 8005368:	f000 fb96 	bl	8005a98 <LPS22HB_Set_ODR_Value_When_Enabled>
 800536c:	0003      	movs	r3, r0
 800536e:	2b01      	cmp	r3, #1
 8005370:	d10c      	bne.n	800538c <LPS22HB_P_Set_ODR_Value+0x48>
    {
      return COMPONENT_ERROR;
 8005372:	2301      	movs	r3, #1
 8005374:	e00b      	b.n	800538e <LPS22HB_P_Set_ODR_Value+0x4a>
    }
  }
  else
  {
    if(LPS22HB_Set_ODR_Value_When_Disabled(handle, odr, comboData) == COMPONENT_ERROR)
 8005376:	68fa      	ldr	r2, [r7, #12]
 8005378:	6839      	ldr	r1, [r7, #0]
 800537a:	687b      	ldr	r3, [r7, #4]
 800537c:	0018      	movs	r0, r3
 800537e:	f000 fbd9 	bl	8005b34 <LPS22HB_Set_ODR_Value_When_Disabled>
 8005382:	0003      	movs	r3, r0
 8005384:	2b01      	cmp	r3, #1
 8005386:	d101      	bne.n	800538c <LPS22HB_P_Set_ODR_Value+0x48>
    {
      return COMPONENT_ERROR;
 8005388:	2301      	movs	r3, #1
 800538a:	e000      	b.n	800538e <LPS22HB_P_Set_ODR_Value+0x4a>
    }
  }

  return COMPONENT_OK;
 800538c:	2300      	movs	r3, #0
}
 800538e:	0018      	movs	r0, r3
 8005390:	46bd      	mov	sp, r7
 8005392:	b004      	add	sp, #16
 8005394:	bd80      	pop	{r7, pc}

08005396 <LPS22HB_P_Read_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Read_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t *data )
{
 8005396:	b580      	push	{r7, lr}
 8005398:	b084      	sub	sp, #16
 800539a:	af00      	add	r7, sp, #0
 800539c:	60f8      	str	r0, [r7, #12]
 800539e:	607a      	str	r2, [r7, #4]
 80053a0:	200b      	movs	r0, #11
 80053a2:	183b      	adds	r3, r7, r0
 80053a4:	1c0a      	adds	r2, r1, #0
 80053a6:	701a      	strb	r2, [r3, #0]

  if ( LPS22HB_Read_Reg( handle, reg, data ) == COMPONENT_ERROR )
 80053a8:	687a      	ldr	r2, [r7, #4]
 80053aa:	183b      	adds	r3, r7, r0
 80053ac:	7819      	ldrb	r1, [r3, #0]
 80053ae:	68fb      	ldr	r3, [r7, #12]
 80053b0:	0018      	movs	r0, r3
 80053b2:	f000 fbf7 	bl	8005ba4 <LPS22HB_Read_Reg>
 80053b6:	0003      	movs	r3, r0
 80053b8:	2b01      	cmp	r3, #1
 80053ba:	d101      	bne.n	80053c0 <LPS22HB_P_Read_Reg+0x2a>
  {
    return COMPONENT_ERROR;
 80053bc:	2301      	movs	r3, #1
 80053be:	e000      	b.n	80053c2 <LPS22HB_P_Read_Reg+0x2c>
  }

  return COMPONENT_OK;
 80053c0:	2300      	movs	r3, #0
}
 80053c2:	0018      	movs	r0, r3
 80053c4:	46bd      	mov	sp, r7
 80053c6:	b004      	add	sp, #16
 80053c8:	bd80      	pop	{r7, pc}

080053ca <LPS22HB_P_Write_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Write_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t data )
{
 80053ca:	b580      	push	{r7, lr}
 80053cc:	b082      	sub	sp, #8
 80053ce:	af00      	add	r7, sp, #0
 80053d0:	6078      	str	r0, [r7, #4]
 80053d2:	0008      	movs	r0, r1
 80053d4:	0011      	movs	r1, r2
 80053d6:	1cfb      	adds	r3, r7, #3
 80053d8:	1c02      	adds	r2, r0, #0
 80053da:	701a      	strb	r2, [r3, #0]
 80053dc:	1cbb      	adds	r3, r7, #2
 80053de:	1c0a      	adds	r2, r1, #0
 80053e0:	701a      	strb	r2, [r3, #0]

  if ( LPS22HB_Write_Reg( handle, reg, data ) == COMPONENT_ERROR )
 80053e2:	1cbb      	adds	r3, r7, #2
 80053e4:	781a      	ldrb	r2, [r3, #0]
 80053e6:	1cfb      	adds	r3, r7, #3
 80053e8:	7819      	ldrb	r1, [r3, #0]
 80053ea:	687b      	ldr	r3, [r7, #4]
 80053ec:	0018      	movs	r0, r3
 80053ee:	f000 fbf4 	bl	8005bda <LPS22HB_Write_Reg>
 80053f2:	0003      	movs	r3, r0
 80053f4:	2b01      	cmp	r3, #1
 80053f6:	d101      	bne.n	80053fc <LPS22HB_P_Write_Reg+0x32>
  {
    return COMPONENT_ERROR;
 80053f8:	2301      	movs	r3, #1
 80053fa:	e000      	b.n	80053fe <LPS22HB_P_Write_Reg+0x34>
  }

  return COMPONENT_OK;
 80053fc:	2300      	movs	r3, #0
}
 80053fe:	0018      	movs	r0, r3
 8005400:	46bd      	mov	sp, r7
 8005402:	b002      	add	sp, #8
 8005404:	bd80      	pop	{r7, pc}

08005406 <LPS22HB_P_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 8005406:	b580      	push	{r7, lr}
 8005408:	b084      	sub	sp, #16
 800540a:	af00      	add	r7, sp, #0
 800540c:	6078      	str	r0, [r7, #4]
 800540e:	6039      	str	r1, [r7, #0]

  LPS22HB_DataStatus_st status_raw;

  if ( LPS22HB_Get_DataStatus( (void *)handle, &status_raw ) == LPS22HB_ERROR )
 8005410:	230c      	movs	r3, #12
 8005412:	18fa      	adds	r2, r7, r3
 8005414:	687b      	ldr	r3, [r7, #4]
 8005416:	0011      	movs	r1, r2
 8005418:	0018      	movs	r0, r3
 800541a:	f7ff fcd2 	bl	8004dc2 <LPS22HB_Get_DataStatus>
 800541e:	0003      	movs	r3, r0
 8005420:	2b01      	cmp	r3, #1
 8005422:	d101      	bne.n	8005428 <LPS22HB_P_Get_DRDY_Status+0x22>
  {
    return COMPONENT_ERROR;
 8005424:	2301      	movs	r3, #1
 8005426:	e005      	b.n	8005434 <LPS22HB_P_Get_DRDY_Status+0x2e>
  }

  *status = status_raw.PressDataAvailable;
 8005428:	230c      	movs	r3, #12
 800542a:	18fb      	adds	r3, r7, r3
 800542c:	785a      	ldrb	r2, [r3, #1]
 800542e:	683b      	ldr	r3, [r7, #0]
 8005430:	701a      	strb	r2, [r3, #0]

  return COMPONENT_OK;
 8005432:	2300      	movs	r3, #0
}
 8005434:	0018      	movs	r0, r3
 8005436:	46bd      	mov	sp, r7
 8005438:	b004      	add	sp, #16
 800543a:	bd80      	pop	{r7, pc}

0800543c <LPS22HB_T_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Init( DrvContextTypeDef *handle )
{
 800543c:	b580      	push	{r7, lr}
 800543e:	b084      	sub	sp, #16
 8005440:	af00      	add	r7, sp, #0
 8005442:	6078      	str	r0, [r7, #4]

  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 8005444:	687b      	ldr	r3, [r7, #4]
 8005446:	689b      	ldr	r3, [r3, #8]
 8005448:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 800544a:	681b      	ldr	r3, [r3, #0]
 800544c:	60fb      	str	r3, [r7, #12]

  /* Check if the LPS22HB pressure sensor is already initialized. */
  /* If yes, skip the initialize function, if not call initialize function */
  if(comboData->isPressInitialized == 0)
 800544e:	68fb      	ldr	r3, [r7, #12]
 8005450:	781b      	ldrb	r3, [r3, #0]
 8005452:	2b00      	cmp	r3, #0
 8005454:	d10a      	bne.n	800546c <LPS22HB_T_Init+0x30>
  {
    if(LPS22HB_Initialize(handle, comboData) == COMPONENT_ERROR)
 8005456:	68fa      	ldr	r2, [r7, #12]
 8005458:	687b      	ldr	r3, [r7, #4]
 800545a:	0011      	movs	r1, r2
 800545c:	0018      	movs	r0, r3
 800545e:	f000 f965 	bl	800572c <LPS22HB_Initialize>
 8005462:	0003      	movs	r3, r0
 8005464:	2b01      	cmp	r3, #1
 8005466:	d101      	bne.n	800546c <LPS22HB_T_Init+0x30>
    {
      return COMPONENT_ERROR;
 8005468:	2301      	movs	r3, #1
 800546a:	e006      	b.n	800547a <LPS22HB_T_Init+0x3e>
    }
  }

  comboData->isTempInitialized = 1;
 800546c:	68fb      	ldr	r3, [r7, #12]
 800546e:	2201      	movs	r2, #1
 8005470:	705a      	strb	r2, [r3, #1]

  handle->isInitialized = 1;
 8005472:	687b      	ldr	r3, [r7, #4]
 8005474:	2201      	movs	r2, #1
 8005476:	70da      	strb	r2, [r3, #3]

  return COMPONENT_OK;
 8005478:	2300      	movs	r3, #0
}
 800547a:	0018      	movs	r0, r3
 800547c:	46bd      	mov	sp, r7
 800547e:	b004      	add	sp, #16
 8005480:	bd80      	pop	{r7, pc}

08005482 <LPS22HB_T_DeInit>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_DeInit( DrvContextTypeDef *handle )
{
 8005482:	b580      	push	{r7, lr}
 8005484:	b084      	sub	sp, #16
 8005486:	af00      	add	r7, sp, #0
 8005488:	6078      	str	r0, [r7, #4]

  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 800548a:	687b      	ldr	r3, [r7, #4]
 800548c:	689b      	ldr	r3, [r3, #8]
 800548e:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 8005490:	681b      	ldr	r3, [r3, #0]
 8005492:	60fb      	str	r3, [r7, #12]

  /* Check if the LPS22HB pressure sensor is already initialized. */
  /* If yes, skip the deinitialize function, if not call deinitialize function */
  if(comboData->isPressInitialized == 0)
 8005494:	68fb      	ldr	r3, [r7, #12]
 8005496:	781b      	ldrb	r3, [r3, #0]
 8005498:	2b00      	cmp	r3, #0
 800549a:	d108      	bne.n	80054ae <LPS22HB_T_DeInit+0x2c>
  {
    if(LPS22HB_T_Sensor_Disable(handle) == COMPONENT_ERROR)
 800549c:	687b      	ldr	r3, [r7, #4]
 800549e:	0018      	movs	r0, r3
 80054a0:	f000 f836 	bl	8005510 <LPS22HB_T_Sensor_Disable>
 80054a4:	0003      	movs	r3, r0
 80054a6:	2b01      	cmp	r3, #1
 80054a8:	d101      	bne.n	80054ae <LPS22HB_T_DeInit+0x2c>
    {
      return COMPONENT_ERROR;
 80054aa:	2301      	movs	r3, #1
 80054ac:	e006      	b.n	80054bc <LPS22HB_T_DeInit+0x3a>
    }
  }

  comboData->isTempInitialized = 0;
 80054ae:	68fb      	ldr	r3, [r7, #12]
 80054b0:	2200      	movs	r2, #0
 80054b2:	705a      	strb	r2, [r3, #1]

  handle->isInitialized = 0;
 80054b4:	687b      	ldr	r3, [r7, #4]
 80054b6:	2200      	movs	r2, #0
 80054b8:	70da      	strb	r2, [r3, #3]

  return COMPONENT_OK;
 80054ba:	2300      	movs	r3, #0
}
 80054bc:	0018      	movs	r0, r3
 80054be:	46bd      	mov	sp, r7
 80054c0:	b004      	add	sp, #16
 80054c2:	bd80      	pop	{r7, pc}

080054c4 <LPS22HB_T_Sensor_Enable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Sensor_Enable( DrvContextTypeDef *handle )
{
 80054c4:	b580      	push	{r7, lr}
 80054c6:	b084      	sub	sp, #16
 80054c8:	af00      	add	r7, sp, #0
 80054ca:	6078      	str	r0, [r7, #4]

  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 80054cc:	687b      	ldr	r3, [r7, #4]
 80054ce:	689b      	ldr	r3, [r3, #8]
 80054d0:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 80054d2:	681b      	ldr	r3, [r3, #0]
 80054d4:	60fb      	str	r3, [r7, #12]

  /* Check if the component is already enabled */
  if ( handle->isEnabled == 1 )
 80054d6:	687b      	ldr	r3, [r7, #4]
 80054d8:	791b      	ldrb	r3, [r3, #4]
 80054da:	2b01      	cmp	r3, #1
 80054dc:	d101      	bne.n	80054e2 <LPS22HB_T_Sensor_Enable+0x1e>
  {
    return COMPONENT_OK;
 80054de:	2300      	movs	r3, #0
 80054e0:	e012      	b.n	8005508 <LPS22HB_T_Sensor_Enable+0x44>
  }

  if(LPS22HB_Set_ODR_Value_When_Enabled(handle, comboData->Last_ODR, comboData) == COMPONENT_ERROR)
 80054e2:	68fb      	ldr	r3, [r7, #12]
 80054e4:	6859      	ldr	r1, [r3, #4]
 80054e6:	68fa      	ldr	r2, [r7, #12]
 80054e8:	687b      	ldr	r3, [r7, #4]
 80054ea:	0018      	movs	r0, r3
 80054ec:	f000 fad4 	bl	8005a98 <LPS22HB_Set_ODR_Value_When_Enabled>
 80054f0:	0003      	movs	r3, r0
 80054f2:	2b01      	cmp	r3, #1
 80054f4:	d101      	bne.n	80054fa <LPS22HB_T_Sensor_Enable+0x36>
  {
    return COMPONENT_ERROR;
 80054f6:	2301      	movs	r3, #1
 80054f8:	e006      	b.n	8005508 <LPS22HB_T_Sensor_Enable+0x44>
  }

  comboData->isTempEnabled = 1;
 80054fa:	68fb      	ldr	r3, [r7, #12]
 80054fc:	2201      	movs	r2, #1
 80054fe:	70da      	strb	r2, [r3, #3]

  handle->isEnabled = 1;
 8005500:	687b      	ldr	r3, [r7, #4]
 8005502:	2201      	movs	r2, #1
 8005504:	711a      	strb	r2, [r3, #4]

  return COMPONENT_OK;
 8005506:	2300      	movs	r3, #0
}
 8005508:	0018      	movs	r0, r3
 800550a:	46bd      	mov	sp, r7
 800550c:	b004      	add	sp, #16
 800550e:	bd80      	pop	{r7, pc}

08005510 <LPS22HB_T_Sensor_Disable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Sensor_Disable( DrvContextTypeDef *handle )
{
 8005510:	b580      	push	{r7, lr}
 8005512:	b084      	sub	sp, #16
 8005514:	af00      	add	r7, sp, #0
 8005516:	6078      	str	r0, [r7, #4]

  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 8005518:	687b      	ldr	r3, [r7, #4]
 800551a:	689b      	ldr	r3, [r3, #8]
 800551c:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 800551e:	681b      	ldr	r3, [r3, #0]
 8005520:	60fb      	str	r3, [r7, #12]

  /* Check if the component is already disabled */
  if ( handle->isEnabled == 0 )
 8005522:	687b      	ldr	r3, [r7, #4]
 8005524:	791b      	ldrb	r3, [r3, #4]
 8005526:	2b00      	cmp	r3, #0
 8005528:	d101      	bne.n	800552e <LPS22HB_T_Sensor_Disable+0x1e>
  {
    return COMPONENT_OK;
 800552a:	2300      	movs	r3, #0
 800552c:	e014      	b.n	8005558 <LPS22HB_T_Sensor_Disable+0x48>
  }

  /* Check if the LPS22HB pressure sensor is still enable. */
  /* If yes, skip the disable function, if not call disable function */
  if(comboData->isPressEnabled == 0)
 800552e:	68fb      	ldr	r3, [r7, #12]
 8005530:	789b      	ldrb	r3, [r3, #2]
 8005532:	2b00      	cmp	r3, #0
 8005534:	d109      	bne.n	800554a <LPS22HB_T_Sensor_Disable+0x3a>
  {
    /* Power down the device */
    if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 8005536:	687b      	ldr	r3, [r7, #4]
 8005538:	2100      	movs	r1, #0
 800553a:	0018      	movs	r0, r3
 800553c:	f7ff fa1e 	bl	800497c <LPS22HB_Set_Odr>
 8005540:	0003      	movs	r3, r0
 8005542:	2b01      	cmp	r3, #1
 8005544:	d101      	bne.n	800554a <LPS22HB_T_Sensor_Disable+0x3a>
    {
      return COMPONENT_ERROR;
 8005546:	2301      	movs	r3, #1
 8005548:	e006      	b.n	8005558 <LPS22HB_T_Sensor_Disable+0x48>
    }
  }

  comboData->isTempEnabled = 0;
 800554a:	68fb      	ldr	r3, [r7, #12]
 800554c:	2200      	movs	r2, #0
 800554e:	70da      	strb	r2, [r3, #3]

  handle->isEnabled = 0;
 8005550:	687b      	ldr	r3, [r7, #4]
 8005552:	2200      	movs	r2, #0
 8005554:	711a      	strb	r2, [r3, #4]

  return COMPONENT_OK;
 8005556:	2300      	movs	r3, #0
}
 8005558:	0018      	movs	r0, r3
 800555a:	46bd      	mov	sp, r7
 800555c:	b004      	add	sp, #16
 800555e:	bd80      	pop	{r7, pc}

08005560 <LPS22HB_T_Get_WhoAmI>:
 * @param who_am_i pointer to the value of WHO_AM_I register
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Get_WhoAmI( DrvContextTypeDef *handle, uint8_t *who_am_i )
{
 8005560:	b580      	push	{r7, lr}
 8005562:	b082      	sub	sp, #8
 8005564:	af00      	add	r7, sp, #0
 8005566:	6078      	str	r0, [r7, #4]
 8005568:	6039      	str	r1, [r7, #0]

  return LPS22HB_Get_WhoAmI( handle, who_am_i );
 800556a:	683a      	ldr	r2, [r7, #0]
 800556c:	687b      	ldr	r3, [r7, #4]
 800556e:	0011      	movs	r1, r2
 8005570:	0018      	movs	r0, r3
 8005572:	f000 f92f 	bl	80057d4 <LPS22HB_Get_WhoAmI>
 8005576:	0003      	movs	r3, r0
}
 8005578:	0018      	movs	r0, r3
 800557a:	46bd      	mov	sp, r7
 800557c:	b002      	add	sp, #8
 800557e:	bd80      	pop	{r7, pc}

08005580 <LPS22HB_T_Check_WhoAmI>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Check_WhoAmI( DrvContextTypeDef *handle )
{
 8005580:	b580      	push	{r7, lr}
 8005582:	b082      	sub	sp, #8
 8005584:	af00      	add	r7, sp, #0
 8005586:	6078      	str	r0, [r7, #4]

  return LPS22HB_Check_WhoAmI( handle );
 8005588:	687b      	ldr	r3, [r7, #4]
 800558a:	0018      	movs	r0, r3
 800558c:	f000 f937 	bl	80057fe <LPS22HB_Check_WhoAmI>
 8005590:	0003      	movs	r3, r0
}
 8005592:	0018      	movs	r0, r3
 8005594:	46bd      	mov	sp, r7
 8005596:	b002      	add	sp, #8
 8005598:	bd80      	pop	{r7, pc}

0800559a <LPS22HB_T_Get_Temp>:
 * @param temperature pointer where the value is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Get_Temp( DrvContextTypeDef *handle, float *temperature )
{
 800559a:	b580      	push	{r7, lr}
 800559c:	b082      	sub	sp, #8
 800559e:	af00      	add	r7, sp, #0
 80055a0:	6078      	str	r0, [r7, #4]
 80055a2:	6039      	str	r1, [r7, #0]

  return LPS22HB_Get_Temp( handle, temperature );
 80055a4:	683a      	ldr	r2, [r7, #0]
 80055a6:	687b      	ldr	r3, [r7, #4]
 80055a8:	0011      	movs	r1, r2
 80055aa:	0018      	movs	r0, r3
 80055ac:	f000 f970 	bl	8005890 <LPS22HB_Get_Temp>
 80055b0:	0003      	movs	r3, r0
}
 80055b2:	0018      	movs	r0, r3
 80055b4:	46bd      	mov	sp, r7
 80055b6:	b002      	add	sp, #8
 80055b8:	bd80      	pop	{r7, pc}

080055ba <LPS22HB_T_Get_ODR>:
 * @param odr pointer where the output data rate is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Get_ODR( DrvContextTypeDef *handle, float *odr )
{
 80055ba:	b580      	push	{r7, lr}
 80055bc:	b082      	sub	sp, #8
 80055be:	af00      	add	r7, sp, #0
 80055c0:	6078      	str	r0, [r7, #4]
 80055c2:	6039      	str	r1, [r7, #0]

  return LPS22HB_Get_ODR( handle, odr );
 80055c4:	683a      	ldr	r2, [r7, #0]
 80055c6:	687b      	ldr	r3, [r7, #4]
 80055c8:	0011      	movs	r1, r2
 80055ca:	0018      	movs	r0, r3
 80055cc:	f000 f98c 	bl	80058e8 <LPS22HB_Get_ODR>
 80055d0:	0003      	movs	r3, r0
}
 80055d2:	0018      	movs	r0, r3
 80055d4:	46bd      	mov	sp, r7
 80055d6:	b002      	add	sp, #8
 80055d8:	bd80      	pop	{r7, pc}

080055da <LPS22HB_T_Set_ODR>:
 * @param odr the functional output data rate to be set
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Set_ODR( DrvContextTypeDef *handle, SensorOdr_t odr )
{
 80055da:	b580      	push	{r7, lr}
 80055dc:	b084      	sub	sp, #16
 80055de:	af00      	add	r7, sp, #0
 80055e0:	6078      	str	r0, [r7, #4]
 80055e2:	000a      	movs	r2, r1
 80055e4:	1cfb      	adds	r3, r7, #3
 80055e6:	701a      	strb	r2, [r3, #0]

  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 80055e8:	687b      	ldr	r3, [r7, #4]
 80055ea:	689b      	ldr	r3, [r3, #8]
 80055ec:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 80055ee:	681b      	ldr	r3, [r3, #0]
 80055f0:	60fb      	str	r3, [r7, #12]

  if(handle->isEnabled == 1)
 80055f2:	687b      	ldr	r3, [r7, #4]
 80055f4:	791b      	ldrb	r3, [r3, #4]
 80055f6:	2b01      	cmp	r3, #1
 80055f8:	d10b      	bne.n	8005612 <LPS22HB_T_Set_ODR+0x38>
  {
    if(LPS22HB_Set_ODR_When_Enabled(handle, odr, comboData) == COMPONENT_ERROR)
 80055fa:	68fa      	ldr	r2, [r7, #12]
 80055fc:	1cfb      	adds	r3, r7, #3
 80055fe:	7819      	ldrb	r1, [r3, #0]
 8005600:	687b      	ldr	r3, [r7, #4]
 8005602:	0018      	movs	r0, r3
 8005604:	f000 f9c2 	bl	800598c <LPS22HB_Set_ODR_When_Enabled>
 8005608:	0003      	movs	r3, r0
 800560a:	2b01      	cmp	r3, #1
 800560c:	d10d      	bne.n	800562a <LPS22HB_T_Set_ODR+0x50>
    {
      return COMPONENT_ERROR;
 800560e:	2301      	movs	r3, #1
 8005610:	e00c      	b.n	800562c <LPS22HB_T_Set_ODR+0x52>
    }
  }
  else
  {
    if(LPS22HB_Set_ODR_When_Disabled(handle, odr, comboData) == COMPONENT_ERROR)
 8005612:	68fa      	ldr	r2, [r7, #12]
 8005614:	1cfb      	adds	r3, r7, #3
 8005616:	7819      	ldrb	r1, [r3, #0]
 8005618:	687b      	ldr	r3, [r7, #4]
 800561a:	0018      	movs	r0, r3
 800561c:	f000 fa04 	bl	8005a28 <LPS22HB_Set_ODR_When_Disabled>
 8005620:	0003      	movs	r3, r0
 8005622:	2b01      	cmp	r3, #1
 8005624:	d101      	bne.n	800562a <LPS22HB_T_Set_ODR+0x50>
    {
      return COMPONENT_ERROR;
 8005626:	2301      	movs	r3, #1
 8005628:	e000      	b.n	800562c <LPS22HB_T_Set_ODR+0x52>
    }
  }

  return COMPONENT_OK;
 800562a:	2300      	movs	r3, #0
}
 800562c:	0018      	movs	r0, r3
 800562e:	46bd      	mov	sp, r7
 8005630:	b004      	add	sp, #16
 8005632:	bd80      	pop	{r7, pc}

08005634 <LPS22HB_T_Set_ODR_Value>:
 * @param odr the output data rate value to be set
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Set_ODR_Value( DrvContextTypeDef *handle, float odr )
{
 8005634:	b580      	push	{r7, lr}
 8005636:	b084      	sub	sp, #16
 8005638:	af00      	add	r7, sp, #0
 800563a:	6078      	str	r0, [r7, #4]
 800563c:	6039      	str	r1, [r7, #0]

  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
                                       handle->pData))->pComponentData))->comboData;
 800563e:	687b      	ldr	r3, [r7, #4]
 8005640:	689b      	ldr	r3, [r3, #8]
 8005642:	681b      	ldr	r3, [r3, #0]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 8005644:	681b      	ldr	r3, [r3, #0]
 8005646:	60fb      	str	r3, [r7, #12]

  if(handle->isEnabled == 1)
 8005648:	687b      	ldr	r3, [r7, #4]
 800564a:	791b      	ldrb	r3, [r3, #4]
 800564c:	2b01      	cmp	r3, #1
 800564e:	d10a      	bne.n	8005666 <LPS22HB_T_Set_ODR_Value+0x32>
  {
    if(LPS22HB_Set_ODR_Value_When_Enabled(handle, odr, comboData) == COMPONENT_ERROR)
 8005650:	68fa      	ldr	r2, [r7, #12]
 8005652:	6839      	ldr	r1, [r7, #0]
 8005654:	687b      	ldr	r3, [r7, #4]
 8005656:	0018      	movs	r0, r3
 8005658:	f000 fa1e 	bl	8005a98 <LPS22HB_Set_ODR_Value_When_Enabled>
 800565c:	0003      	movs	r3, r0
 800565e:	2b01      	cmp	r3, #1
 8005660:	d10c      	bne.n	800567c <LPS22HB_T_Set_ODR_Value+0x48>
    {
      return COMPONENT_ERROR;
 8005662:	2301      	movs	r3, #1
 8005664:	e00b      	b.n	800567e <LPS22HB_T_Set_ODR_Value+0x4a>
    }
  }
  else
  {
    if(LPS22HB_Set_ODR_Value_When_Disabled(handle, odr, comboData) == COMPONENT_ERROR)
 8005666:	68fa      	ldr	r2, [r7, #12]
 8005668:	6839      	ldr	r1, [r7, #0]
 800566a:	687b      	ldr	r3, [r7, #4]
 800566c:	0018      	movs	r0, r3
 800566e:	f000 fa61 	bl	8005b34 <LPS22HB_Set_ODR_Value_When_Disabled>
 8005672:	0003      	movs	r3, r0
 8005674:	2b01      	cmp	r3, #1
 8005676:	d101      	bne.n	800567c <LPS22HB_T_Set_ODR_Value+0x48>
    {
      return COMPONENT_ERROR;
 8005678:	2301      	movs	r3, #1
 800567a:	e000      	b.n	800567e <LPS22HB_T_Set_ODR_Value+0x4a>
    }
  }

  return COMPONENT_OK;
 800567c:	2300      	movs	r3, #0
}
 800567e:	0018      	movs	r0, r3
 8005680:	46bd      	mov	sp, r7
 8005682:	b004      	add	sp, #16
 8005684:	bd80      	pop	{r7, pc}

08005686 <LPS22HB_T_Read_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Read_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t *data )
{
 8005686:	b580      	push	{r7, lr}
 8005688:	b084      	sub	sp, #16
 800568a:	af00      	add	r7, sp, #0
 800568c:	60f8      	str	r0, [r7, #12]
 800568e:	607a      	str	r2, [r7, #4]
 8005690:	200b      	movs	r0, #11
 8005692:	183b      	adds	r3, r7, r0
 8005694:	1c0a      	adds	r2, r1, #0
 8005696:	701a      	strb	r2, [r3, #0]

  if ( LPS22HB_Read_Reg( handle, reg, data ) == COMPONENT_ERROR )
 8005698:	687a      	ldr	r2, [r7, #4]
 800569a:	183b      	adds	r3, r7, r0
 800569c:	7819      	ldrb	r1, [r3, #0]
 800569e:	68fb      	ldr	r3, [r7, #12]
 80056a0:	0018      	movs	r0, r3
 80056a2:	f000 fa7f 	bl	8005ba4 <LPS22HB_Read_Reg>
 80056a6:	0003      	movs	r3, r0
 80056a8:	2b01      	cmp	r3, #1
 80056aa:	d101      	bne.n	80056b0 <LPS22HB_T_Read_Reg+0x2a>
  {
    return COMPONENT_ERROR;
 80056ac:	2301      	movs	r3, #1
 80056ae:	e000      	b.n	80056b2 <LPS22HB_T_Read_Reg+0x2c>
  }

  return COMPONENT_OK;
 80056b0:	2300      	movs	r3, #0
}
 80056b2:	0018      	movs	r0, r3
 80056b4:	46bd      	mov	sp, r7
 80056b6:	b004      	add	sp, #16
 80056b8:	bd80      	pop	{r7, pc}

080056ba <LPS22HB_T_Write_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Write_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t data )
{
 80056ba:	b580      	push	{r7, lr}
 80056bc:	b082      	sub	sp, #8
 80056be:	af00      	add	r7, sp, #0
 80056c0:	6078      	str	r0, [r7, #4]
 80056c2:	0008      	movs	r0, r1
 80056c4:	0011      	movs	r1, r2
 80056c6:	1cfb      	adds	r3, r7, #3
 80056c8:	1c02      	adds	r2, r0, #0
 80056ca:	701a      	strb	r2, [r3, #0]
 80056cc:	1cbb      	adds	r3, r7, #2
 80056ce:	1c0a      	adds	r2, r1, #0
 80056d0:	701a      	strb	r2, [r3, #0]

  if ( LPS22HB_Write_Reg( handle, reg, data ) == COMPONENT_ERROR )
 80056d2:	1cbb      	adds	r3, r7, #2
 80056d4:	781a      	ldrb	r2, [r3, #0]
 80056d6:	1cfb      	adds	r3, r7, #3
 80056d8:	7819      	ldrb	r1, [r3, #0]
 80056da:	687b      	ldr	r3, [r7, #4]
 80056dc:	0018      	movs	r0, r3
 80056de:	f000 fa7c 	bl	8005bda <LPS22HB_Write_Reg>
 80056e2:	0003      	movs	r3, r0
 80056e4:	2b01      	cmp	r3, #1
 80056e6:	d101      	bne.n	80056ec <LPS22HB_T_Write_Reg+0x32>
  {
    return COMPONENT_ERROR;
 80056e8:	2301      	movs	r3, #1
 80056ea:	e000      	b.n	80056ee <LPS22HB_T_Write_Reg+0x34>
  }

  return COMPONENT_OK;
 80056ec:	2300      	movs	r3, #0
}
 80056ee:	0018      	movs	r0, r3
 80056f0:	46bd      	mov	sp, r7
 80056f2:	b002      	add	sp, #8
 80056f4:	bd80      	pop	{r7, pc}

080056f6 <LPS22HB_T_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 80056f6:	b580      	push	{r7, lr}
 80056f8:	b084      	sub	sp, #16
 80056fa:	af00      	add	r7, sp, #0
 80056fc:	6078      	str	r0, [r7, #4]
 80056fe:	6039      	str	r1, [r7, #0]

  LPS22HB_DataStatus_st status_raw;

  if ( LPS22HB_Get_DataStatus( (void *)handle, &status_raw ) == LPS22HB_ERROR )
 8005700:	230c      	movs	r3, #12
 8005702:	18fa      	adds	r2, r7, r3
 8005704:	687b      	ldr	r3, [r7, #4]
 8005706:	0011      	movs	r1, r2
 8005708:	0018      	movs	r0, r3
 800570a:	f7ff fb5a 	bl	8004dc2 <LPS22HB_Get_DataStatus>
 800570e:	0003      	movs	r3, r0
 8005710:	2b01      	cmp	r3, #1
 8005712:	d101      	bne.n	8005718 <LPS22HB_T_Get_DRDY_Status+0x22>
  {
    return COMPONENT_ERROR;
 8005714:	2301      	movs	r3, #1
 8005716:	e005      	b.n	8005724 <LPS22HB_T_Get_DRDY_Status+0x2e>
  }

  *status = status_raw.TempDataAvailable;
 8005718:	230c      	movs	r3, #12
 800571a:	18fb      	adds	r3, r7, r3
 800571c:	781a      	ldrb	r2, [r3, #0]
 800571e:	683b      	ldr	r3, [r7, #0]
 8005720:	701a      	strb	r2, [r3, #0]

  return COMPONENT_OK;
 8005722:	2300      	movs	r3, #0
}
 8005724:	0018      	movs	r0, r3
 8005726:	46bd      	mov	sp, r7
 8005728:	b004      	add	sp, #16
 800572a:	bd80      	pop	{r7, pc}

0800572c <LPS22HB_Initialize>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Initialize( DrvContextTypeDef *handle, LPS22HB_Combo_Data_t *combo )
{
 800572c:	b580      	push	{r7, lr}
 800572e:	b082      	sub	sp, #8
 8005730:	af00      	add	r7, sp, #0
 8005732:	6078      	str	r0, [r7, #4]
 8005734:	6039      	str	r1, [r7, #0]

  if ( LPS22HB_Check_WhoAmI( handle ) == COMPONENT_ERROR )
 8005736:	687b      	ldr	r3, [r7, #4]
 8005738:	0018      	movs	r0, r3
 800573a:	f000 f860 	bl	80057fe <LPS22HB_Check_WhoAmI>
 800573e:	0003      	movs	r3, r0
 8005740:	2b01      	cmp	r3, #1
 8005742:	d101      	bne.n	8005748 <LPS22HB_Initialize+0x1c>
  {
    return COMPONENT_ERROR;
 8005744:	2301      	movs	r3, #1
 8005746:	e03f      	b.n	80057c8 <LPS22HB_Initialize+0x9c>
  }

  combo->Last_ODR = 25.0f;
 8005748:	683b      	ldr	r3, [r7, #0]
 800574a:	4a21      	ldr	r2, [pc, #132]	; (80057d0 <LPS22HB_Initialize+0xa4>)
 800574c:	605a      	str	r2, [r3, #4]

  /* Set Power mode */
  if ( LPS22HB_Set_PowerMode( (void *)handle, LPS22HB_LowPower) == LPS22HB_ERROR )
 800574e:	687b      	ldr	r3, [r7, #4]
 8005750:	2101      	movs	r1, #1
 8005752:	0018      	movs	r0, r3
 8005754:	f7ff f8e1 	bl	800491a <LPS22HB_Set_PowerMode>
 8005758:	0003      	movs	r3, r0
 800575a:	2b01      	cmp	r3, #1
 800575c:	d101      	bne.n	8005762 <LPS22HB_Initialize+0x36>
  {
    return COMPONENT_ERROR;
 800575e:	2301      	movs	r3, #1
 8005760:	e032      	b.n	80057c8 <LPS22HB_Initialize+0x9c>
  }

  /* Power down the device */
  if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 8005762:	687b      	ldr	r3, [r7, #4]
 8005764:	2100      	movs	r1, #0
 8005766:	0018      	movs	r0, r3
 8005768:	f7ff f908 	bl	800497c <LPS22HB_Set_Odr>
 800576c:	0003      	movs	r3, r0
 800576e:	2b01      	cmp	r3, #1
 8005770:	d101      	bne.n	8005776 <LPS22HB_Initialize+0x4a>
  {
    return COMPONENT_ERROR;
 8005772:	2301      	movs	r3, #1
 8005774:	e028      	b.n	80057c8 <LPS22HB_Initialize+0x9c>
  }

  /* Disable low-pass filter on LPS22HB pressure data */
  if( LPS22HB_Set_LowPassFilter( (void *)handle, LPS22HB_DISABLE) == LPS22HB_ERROR )
 8005776:	687b      	ldr	r3, [r7, #4]
 8005778:	2100      	movs	r1, #0
 800577a:	0018      	movs	r0, r3
 800577c:	f7ff f94c 	bl	8004a18 <LPS22HB_Set_LowPassFilter>
 8005780:	0003      	movs	r3, r0
 8005782:	2b01      	cmp	r3, #1
 8005784:	d101      	bne.n	800578a <LPS22HB_Initialize+0x5e>
  {
    return COMPONENT_ERROR;
 8005786:	2301      	movs	r3, #1
 8005788:	e01e      	b.n	80057c8 <LPS22HB_Initialize+0x9c>
  }

  /* Set low-pass filter cutoff configuration*/
  if( LPS22HB_Set_LowPassFilterCutoff( (void *)handle, LPS22HB_ODR_9) == LPS22HB_ERROR )
 800578a:	687b      	ldr	r3, [r7, #4]
 800578c:	2100      	movs	r1, #0
 800578e:	0018      	movs	r0, r3
 8005790:	f7ff f977 	bl	8004a82 <LPS22HB_Set_LowPassFilterCutoff>
 8005794:	0003      	movs	r3, r0
 8005796:	2b01      	cmp	r3, #1
 8005798:	d101      	bne.n	800579e <LPS22HB_Initialize+0x72>
  {
    return COMPONENT_ERROR;
 800579a:	2301      	movs	r3, #1
 800579c:	e014      	b.n	80057c8 <LPS22HB_Initialize+0x9c>
  }

  /* Set block data update mode */
  if ( LPS22HB_Set_Bdu( (void *)handle, LPS22HB_BDU_NO_UPDATE ) == LPS22HB_ERROR )
 800579e:	687b      	ldr	r3, [r7, #4]
 80057a0:	2102      	movs	r1, #2
 80057a2:	0018      	movs	r0, r3
 80057a4:	f7ff f99e 	bl	8004ae4 <LPS22HB_Set_Bdu>
 80057a8:	0003      	movs	r3, r0
 80057aa:	2b01      	cmp	r3, #1
 80057ac:	d101      	bne.n	80057b2 <LPS22HB_Initialize+0x86>
  {
    return COMPONENT_ERROR;
 80057ae:	2301      	movs	r3, #1
 80057b0:	e00a      	b.n	80057c8 <LPS22HB_Initialize+0x9c>
  }

  /* Disable automatic increment for multi-byte read/write */
  if( LPS22HB_Set_AutomaticIncrementRegAddress( (void *)handle, LPS22HB_DISABLE) == LPS22HB_ERROR )
 80057b2:	687b      	ldr	r3, [r7, #4]
 80057b4:	2100      	movs	r1, #0
 80057b6:	0018      	movs	r0, r3
 80057b8:	f7ff fa2f 	bl	8004c1a <LPS22HB_Set_AutomaticIncrementRegAddress>
 80057bc:	0003      	movs	r3, r0
 80057be:	2b01      	cmp	r3, #1
 80057c0:	d101      	bne.n	80057c6 <LPS22HB_Initialize+0x9a>
  {
    return COMPONENT_ERROR;
 80057c2:	2301      	movs	r3, #1
 80057c4:	e000      	b.n	80057c8 <LPS22HB_Initialize+0x9c>
  }

  return COMPONENT_OK;
 80057c6:	2300      	movs	r3, #0
}
 80057c8:	0018      	movs	r0, r3
 80057ca:	46bd      	mov	sp, r7
 80057cc:	b002      	add	sp, #8
 80057ce:	bd80      	pop	{r7, pc}
 80057d0:	41c80000 	.word	0x41c80000

080057d4 <LPS22HB_Get_WhoAmI>:
 * @param who_am_i pointer to the value of WHO_AM_I register
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Get_WhoAmI( DrvContextTypeDef *handle, uint8_t *who_am_i )
{
 80057d4:	b580      	push	{r7, lr}
 80057d6:	b082      	sub	sp, #8
 80057d8:	af00      	add	r7, sp, #0
 80057da:	6078      	str	r0, [r7, #4]
 80057dc:	6039      	str	r1, [r7, #0]

  /* Read WHO AM I register */
  if ( LPS22HB_Get_DeviceID( (void *)handle, who_am_i ) == LPS22HB_ERROR )
 80057de:	683a      	ldr	r2, [r7, #0]
 80057e0:	687b      	ldr	r3, [r7, #4]
 80057e2:	0011      	movs	r1, r2
 80057e4:	0018      	movs	r0, r3
 80057e6:	f7ff f884 	bl	80048f2 <LPS22HB_Get_DeviceID>
 80057ea:	0003      	movs	r3, r0
 80057ec:	2b01      	cmp	r3, #1
 80057ee:	d101      	bne.n	80057f4 <LPS22HB_Get_WhoAmI+0x20>
  {
    return COMPONENT_ERROR;
 80057f0:	2301      	movs	r3, #1
 80057f2:	e000      	b.n	80057f6 <LPS22HB_Get_WhoAmI+0x22>
  }

  return COMPONENT_OK;
 80057f4:	2300      	movs	r3, #0
}
 80057f6:	0018      	movs	r0, r3
 80057f8:	46bd      	mov	sp, r7
 80057fa:	b002      	add	sp, #8
 80057fc:	bd80      	pop	{r7, pc}

080057fe <LPS22HB_Check_WhoAmI>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Check_WhoAmI( DrvContextTypeDef *handle )
{
 80057fe:	b580      	push	{r7, lr}
 8005800:	b084      	sub	sp, #16
 8005802:	af00      	add	r7, sp, #0
 8005804:	6078      	str	r0, [r7, #4]

  uint8_t who_am_i = 0x00;
 8005806:	210f      	movs	r1, #15
 8005808:	187b      	adds	r3, r7, r1
 800580a:	2200      	movs	r2, #0
 800580c:	701a      	strb	r2, [r3, #0]

  if ( LPS22HB_Get_WhoAmI( handle, &who_am_i ) == COMPONENT_ERROR )
 800580e:	187a      	adds	r2, r7, r1
 8005810:	687b      	ldr	r3, [r7, #4]
 8005812:	0011      	movs	r1, r2
 8005814:	0018      	movs	r0, r3
 8005816:	f7ff ffdd 	bl	80057d4 <LPS22HB_Get_WhoAmI>
 800581a:	0003      	movs	r3, r0
 800581c:	2b01      	cmp	r3, #1
 800581e:	d101      	bne.n	8005824 <LPS22HB_Check_WhoAmI+0x26>
  {
    return COMPONENT_ERROR;
 8005820:	2301      	movs	r3, #1
 8005822:	e009      	b.n	8005838 <LPS22HB_Check_WhoAmI+0x3a>
  }
  if ( who_am_i != handle->who_am_i )
 8005824:	687b      	ldr	r3, [r7, #4]
 8005826:	781a      	ldrb	r2, [r3, #0]
 8005828:	230f      	movs	r3, #15
 800582a:	18fb      	adds	r3, r7, r3
 800582c:	781b      	ldrb	r3, [r3, #0]
 800582e:	429a      	cmp	r2, r3
 8005830:	d001      	beq.n	8005836 <LPS22HB_Check_WhoAmI+0x38>
  {
    return COMPONENT_ERROR;
 8005832:	2301      	movs	r3, #1
 8005834:	e000      	b.n	8005838 <LPS22HB_Check_WhoAmI+0x3a>
  }

  return COMPONENT_OK;
 8005836:	2300      	movs	r3, #0
}
 8005838:	0018      	movs	r0, r3
 800583a:	46bd      	mov	sp, r7
 800583c:	b004      	add	sp, #16
 800583e:	bd80      	pop	{r7, pc}

08005840 <LPS22HB_Get_Press>:
 * @param pressure pointer where the value is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Get_Press( DrvContextTypeDef *handle, float *pressure )
{
 8005840:	b580      	push	{r7, lr}
 8005842:	b084      	sub	sp, #16
 8005844:	af00      	add	r7, sp, #0
 8005846:	6078      	str	r0, [r7, #4]
 8005848:	6039      	str	r1, [r7, #0]

  int32_t int32data = 0;
 800584a:	2300      	movs	r3, #0
 800584c:	60fb      	str	r3, [r7, #12]

  /* Read data from LPS22HB. */
  if ( LPS22HB_Get_Pressure( (void *)handle, &int32data ) == LPS22HB_ERROR )
 800584e:	230c      	movs	r3, #12
 8005850:	18fa      	adds	r2, r7, r3
 8005852:	687b      	ldr	r3, [r7, #4]
 8005854:	0011      	movs	r1, r2
 8005856:	0018      	movs	r0, r3
 8005858:	f7ff fb2c 	bl	8004eb4 <LPS22HB_Get_Pressure>
 800585c:	0003      	movs	r3, r0
 800585e:	2b01      	cmp	r3, #1
 8005860:	d101      	bne.n	8005866 <LPS22HB_Get_Press+0x26>
  {
    return COMPONENT_ERROR;
 8005862:	2301      	movs	r3, #1
 8005864:	e00d      	b.n	8005882 <LPS22HB_Get_Press+0x42>
  }

  *pressure = ( float )int32data / 100.0f;
 8005866:	68fb      	ldr	r3, [r7, #12]
 8005868:	0018      	movs	r0, r3
 800586a:	f7fb fdcf 	bl	800140c <__aeabi_i2f>
 800586e:	1c03      	adds	r3, r0, #0
 8005870:	4906      	ldr	r1, [pc, #24]	; (800588c <LPS22HB_Get_Press+0x4c>)
 8005872:	1c18      	adds	r0, r3, #0
 8005874:	f7fb f8fe 	bl	8000a74 <__aeabi_fdiv>
 8005878:	1c03      	adds	r3, r0, #0
 800587a:	1c1a      	adds	r2, r3, #0
 800587c:	683b      	ldr	r3, [r7, #0]
 800587e:	601a      	str	r2, [r3, #0]

  return COMPONENT_OK;
 8005880:	2300      	movs	r3, #0
}
 8005882:	0018      	movs	r0, r3
 8005884:	46bd      	mov	sp, r7
 8005886:	b004      	add	sp, #16
 8005888:	bd80      	pop	{r7, pc}
 800588a:	46c0      	nop			; (mov r8, r8)
 800588c:	42c80000 	.word	0x42c80000

08005890 <LPS22HB_Get_Temp>:
 * @param temperature pointer where the value is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Get_Temp( DrvContextTypeDef *handle, float *temperature )
{
 8005890:	b580      	push	{r7, lr}
 8005892:	b084      	sub	sp, #16
 8005894:	af00      	add	r7, sp, #0
 8005896:	6078      	str	r0, [r7, #4]
 8005898:	6039      	str	r1, [r7, #0]

  int16_t int16data = 0;
 800589a:	210e      	movs	r1, #14
 800589c:	187b      	adds	r3, r7, r1
 800589e:	2200      	movs	r2, #0
 80058a0:	801a      	strh	r2, [r3, #0]

  /* Read data from LPS22HB. */
  if ( LPS22HB_Get_Temperature( (void *)handle, &int16data ) == LPS22HB_ERROR )
 80058a2:	187a      	adds	r2, r7, r1
 80058a4:	687b      	ldr	r3, [r7, #4]
 80058a6:	0011      	movs	r1, r2
 80058a8:	0018      	movs	r0, r3
 80058aa:	f7ff fb4e 	bl	8004f4a <LPS22HB_Get_Temperature>
 80058ae:	0003      	movs	r3, r0
 80058b0:	2b01      	cmp	r3, #1
 80058b2:	d101      	bne.n	80058b8 <LPS22HB_Get_Temp+0x28>
  {
    return COMPONENT_ERROR;
 80058b4:	2301      	movs	r3, #1
 80058b6:	e010      	b.n	80058da <LPS22HB_Get_Temp+0x4a>
  }

  *temperature = ( float )int16data / 10.0f;
 80058b8:	230e      	movs	r3, #14
 80058ba:	18fb      	adds	r3, r7, r3
 80058bc:	2200      	movs	r2, #0
 80058be:	5e9b      	ldrsh	r3, [r3, r2]
 80058c0:	0018      	movs	r0, r3
 80058c2:	f7fb fda3 	bl	800140c <__aeabi_i2f>
 80058c6:	1c03      	adds	r3, r0, #0
 80058c8:	4906      	ldr	r1, [pc, #24]	; (80058e4 <LPS22HB_Get_Temp+0x54>)
 80058ca:	1c18      	adds	r0, r3, #0
 80058cc:	f7fb f8d2 	bl	8000a74 <__aeabi_fdiv>
 80058d0:	1c03      	adds	r3, r0, #0
 80058d2:	1c1a      	adds	r2, r3, #0
 80058d4:	683b      	ldr	r3, [r7, #0]
 80058d6:	601a      	str	r2, [r3, #0]

  return COMPONENT_OK;
 80058d8:	2300      	movs	r3, #0
}
 80058da:	0018      	movs	r0, r3
 80058dc:	46bd      	mov	sp, r7
 80058de:	b004      	add	sp, #16
 80058e0:	bd80      	pop	{r7, pc}
 80058e2:	46c0      	nop			; (mov r8, r8)
 80058e4:	41200000 	.word	0x41200000

080058e8 <LPS22HB_Get_ODR>:
 * @param odr pointer where the output data rate is written
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Get_ODR( DrvContextTypeDef *handle, float *odr )
{
 80058e8:	b580      	push	{r7, lr}
 80058ea:	b084      	sub	sp, #16
 80058ec:	af00      	add	r7, sp, #0
 80058ee:	6078      	str	r0, [r7, #4]
 80058f0:	6039      	str	r1, [r7, #0]

  LPS22HB_Odr_et odr_low_level;

  if ( LPS22HB_Get_Odr( (void *)handle, &odr_low_level ) == LPS22HB_ERROR )
 80058f2:	230f      	movs	r3, #15
 80058f4:	18fa      	adds	r2, r7, r3
 80058f6:	687b      	ldr	r3, [r7, #4]
 80058f8:	0011      	movs	r1, r2
 80058fa:	0018      	movs	r0, r3
 80058fc:	f7ff f86f 	bl	80049de <LPS22HB_Get_Odr>
 8005900:	0003      	movs	r3, r0
 8005902:	2b01      	cmp	r3, #1
 8005904:	d101      	bne.n	800590a <LPS22HB_Get_ODR+0x22>
  {
    return COMPONENT_ERROR;
 8005906:	2301      	movs	r3, #1
 8005908:	e032      	b.n	8005970 <LPS22HB_Get_ODR+0x88>
  }

  switch( odr_low_level )
 800590a:	230f      	movs	r3, #15
 800590c:	18fb      	adds	r3, r7, r3
 800590e:	781b      	ldrb	r3, [r3, #0]
 8005910:	2b50      	cmp	r3, #80	; 0x50
 8005912:	d023      	beq.n	800595c <LPS22HB_Get_ODR+0x74>
 8005914:	dc26      	bgt.n	8005964 <LPS22HB_Get_ODR+0x7c>
 8005916:	2b40      	cmp	r3, #64	; 0x40
 8005918:	d01c      	beq.n	8005954 <LPS22HB_Get_ODR+0x6c>
 800591a:	dc23      	bgt.n	8005964 <LPS22HB_Get_ODR+0x7c>
 800591c:	2b30      	cmp	r3, #48	; 0x30
 800591e:	d015      	beq.n	800594c <LPS22HB_Get_ODR+0x64>
 8005920:	dc20      	bgt.n	8005964 <LPS22HB_Get_ODR+0x7c>
 8005922:	2b20      	cmp	r3, #32
 8005924:	d00e      	beq.n	8005944 <LPS22HB_Get_ODR+0x5c>
 8005926:	dc1d      	bgt.n	8005964 <LPS22HB_Get_ODR+0x7c>
 8005928:	2b00      	cmp	r3, #0
 800592a:	d002      	beq.n	8005932 <LPS22HB_Get_ODR+0x4a>
 800592c:	2b10      	cmp	r3, #16
 800592e:	d004      	beq.n	800593a <LPS22HB_Get_ODR+0x52>
 8005930:	e018      	b.n	8005964 <LPS22HB_Get_ODR+0x7c>
  {
    case LPS22HB_ODR_ONE_SHOT:
      *odr = 0.0f;
 8005932:	683b      	ldr	r3, [r7, #0]
 8005934:	2200      	movs	r2, #0
 8005936:	601a      	str	r2, [r3, #0]
      break;
 8005938:	e019      	b.n	800596e <LPS22HB_Get_ODR+0x86>
    case LPS22HB_ODR_1HZ:
      *odr = 1.0f;
 800593a:	683b      	ldr	r3, [r7, #0]
 800593c:	22fe      	movs	r2, #254	; 0xfe
 800593e:	0592      	lsls	r2, r2, #22
 8005940:	601a      	str	r2, [r3, #0]
      break;
 8005942:	e014      	b.n	800596e <LPS22HB_Get_ODR+0x86>
    case LPS22HB_ODR_10HZ:
      *odr = 10.0f;
 8005944:	683b      	ldr	r3, [r7, #0]
 8005946:	4a0c      	ldr	r2, [pc, #48]	; (8005978 <LPS22HB_Get_ODR+0x90>)
 8005948:	601a      	str	r2, [r3, #0]
      break;
 800594a:	e010      	b.n	800596e <LPS22HB_Get_ODR+0x86>
    case LPS22HB_ODR_25HZ:
      *odr = 25.0f;
 800594c:	683b      	ldr	r3, [r7, #0]
 800594e:	4a0b      	ldr	r2, [pc, #44]	; (800597c <LPS22HB_Get_ODR+0x94>)
 8005950:	601a      	str	r2, [r3, #0]
      break;
 8005952:	e00c      	b.n	800596e <LPS22HB_Get_ODR+0x86>
    case LPS22HB_ODR_50HZ:
      *odr = 50.0f;
 8005954:	683b      	ldr	r3, [r7, #0]
 8005956:	4a0a      	ldr	r2, [pc, #40]	; (8005980 <LPS22HB_Get_ODR+0x98>)
 8005958:	601a      	str	r2, [r3, #0]
      break;
 800595a:	e008      	b.n	800596e <LPS22HB_Get_ODR+0x86>
    case LPS22HB_ODR_75HZ:
      *odr = 75.0f;
 800595c:	683b      	ldr	r3, [r7, #0]
 800595e:	4a09      	ldr	r2, [pc, #36]	; (8005984 <LPS22HB_Get_ODR+0x9c>)
 8005960:	601a      	str	r2, [r3, #0]
      break;
 8005962:	e004      	b.n	800596e <LPS22HB_Get_ODR+0x86>
    default:
      *odr = -1.0f;
 8005964:	683b      	ldr	r3, [r7, #0]
 8005966:	4a08      	ldr	r2, [pc, #32]	; (8005988 <LPS22HB_Get_ODR+0xa0>)
 8005968:	601a      	str	r2, [r3, #0]
      return COMPONENT_ERROR;
 800596a:	2301      	movs	r3, #1
 800596c:	e000      	b.n	8005970 <LPS22HB_Get_ODR+0x88>
  }

  return COMPONENT_OK;
 800596e:	2300      	movs	r3, #0
}
 8005970:	0018      	movs	r0, r3
 8005972:	46bd      	mov	sp, r7
 8005974:	b004      	add	sp, #16
 8005976:	bd80      	pop	{r7, pc}
 8005978:	41200000 	.word	0x41200000
 800597c:	41c80000 	.word	0x41c80000
 8005980:	42480000 	.word	0x42480000
 8005984:	42960000 	.word	0x42960000
 8005988:	bf800000 	.word	0xbf800000

0800598c <LPS22HB_Set_ODR_When_Enabled>:
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Set_ODR_When_Enabled( DrvContextTypeDef *handle, SensorOdr_t odr,
    LPS22HB_Combo_Data_t *combo )
{
 800598c:	b580      	push	{r7, lr}
 800598e:	b086      	sub	sp, #24
 8005990:	af00      	add	r7, sp, #0
 8005992:	60f8      	str	r0, [r7, #12]
 8005994:	607a      	str	r2, [r7, #4]
 8005996:	200b      	movs	r0, #11
 8005998:	183b      	adds	r3, r7, r0
 800599a:	1c0a      	adds	r2, r1, #0
 800599c:	701a      	strb	r2, [r3, #0]

  LPS22HB_Odr_et new_odr;

  switch( odr )
 800599e:	183b      	adds	r3, r7, r0
 80059a0:	781b      	ldrb	r3, [r3, #0]
 80059a2:	2b04      	cmp	r3, #4
 80059a4:	d81d      	bhi.n	80059e2 <LPS22HB_Set_ODR_When_Enabled+0x56>
 80059a6:	009a      	lsls	r2, r3, #2
 80059a8:	4b1e      	ldr	r3, [pc, #120]	; (8005a24 <LPS22HB_Set_ODR_When_Enabled+0x98>)
 80059aa:	18d3      	adds	r3, r2, r3
 80059ac:	681b      	ldr	r3, [r3, #0]
 80059ae:	469f      	mov	pc, r3
  {
    case ODR_LOW:
      new_odr = LPS22HB_ODR_1HZ;
 80059b0:	2317      	movs	r3, #23
 80059b2:	18fb      	adds	r3, r7, r3
 80059b4:	2210      	movs	r2, #16
 80059b6:	701a      	strb	r2, [r3, #0]
      break;
 80059b8:	e015      	b.n	80059e6 <LPS22HB_Set_ODR_When_Enabled+0x5a>
    case ODR_MID_LOW:
      new_odr = LPS22HB_ODR_10HZ;
 80059ba:	2317      	movs	r3, #23
 80059bc:	18fb      	adds	r3, r7, r3
 80059be:	2220      	movs	r2, #32
 80059c0:	701a      	strb	r2, [r3, #0]
      break;
 80059c2:	e010      	b.n	80059e6 <LPS22HB_Set_ODR_When_Enabled+0x5a>
    case ODR_MID:
      new_odr = LPS22HB_ODR_25HZ;
 80059c4:	2317      	movs	r3, #23
 80059c6:	18fb      	adds	r3, r7, r3
 80059c8:	2230      	movs	r2, #48	; 0x30
 80059ca:	701a      	strb	r2, [r3, #0]
      break;
 80059cc:	e00b      	b.n	80059e6 <LPS22HB_Set_ODR_When_Enabled+0x5a>
    case ODR_MID_HIGH:
      new_odr = LPS22HB_ODR_50HZ;
 80059ce:	2317      	movs	r3, #23
 80059d0:	18fb      	adds	r3, r7, r3
 80059d2:	2240      	movs	r2, #64	; 0x40
 80059d4:	701a      	strb	r2, [r3, #0]
      break;
 80059d6:	e006      	b.n	80059e6 <LPS22HB_Set_ODR_When_Enabled+0x5a>
    case ODR_HIGH:
      new_odr = LPS22HB_ODR_75HZ;
 80059d8:	2317      	movs	r3, #23
 80059da:	18fb      	adds	r3, r7, r3
 80059dc:	2250      	movs	r2, #80	; 0x50
 80059de:	701a      	strb	r2, [r3, #0]
      break;
 80059e0:	e001      	b.n	80059e6 <LPS22HB_Set_ODR_When_Enabled+0x5a>
    default:
      return COMPONENT_ERROR;
 80059e2:	2301      	movs	r3, #1
 80059e4:	e019      	b.n	8005a1a <LPS22HB_Set_ODR_When_Enabled+0x8e>
  }

  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 80059e6:	2317      	movs	r3, #23
 80059e8:	18fb      	adds	r3, r7, r3
 80059ea:	781a      	ldrb	r2, [r3, #0]
 80059ec:	68fb      	ldr	r3, [r7, #12]
 80059ee:	0011      	movs	r1, r2
 80059f0:	0018      	movs	r0, r3
 80059f2:	f7fe ffc3 	bl	800497c <LPS22HB_Set_Odr>
 80059f6:	0003      	movs	r3, r0
 80059f8:	2b01      	cmp	r3, #1
 80059fa:	d101      	bne.n	8005a00 <LPS22HB_Set_ODR_When_Enabled+0x74>
  {
    return COMPONENT_ERROR;
 80059fc:	2301      	movs	r3, #1
 80059fe:	e00c      	b.n	8005a1a <LPS22HB_Set_ODR_When_Enabled+0x8e>
  }

  if ( LPS22HB_Get_ODR( handle, &combo->Last_ODR ) == COMPONENT_ERROR )
 8005a00:	687b      	ldr	r3, [r7, #4]
 8005a02:	1d1a      	adds	r2, r3, #4
 8005a04:	68fb      	ldr	r3, [r7, #12]
 8005a06:	0011      	movs	r1, r2
 8005a08:	0018      	movs	r0, r3
 8005a0a:	f7ff ff6d 	bl	80058e8 <LPS22HB_Get_ODR>
 8005a0e:	0003      	movs	r3, r0
 8005a10:	2b01      	cmp	r3, #1
 8005a12:	d101      	bne.n	8005a18 <LPS22HB_Set_ODR_When_Enabled+0x8c>
  {
    return COMPONENT_ERROR;
 8005a14:	2301      	movs	r3, #1
 8005a16:	e000      	b.n	8005a1a <LPS22HB_Set_ODR_When_Enabled+0x8e>
  }

  return COMPONENT_OK;
 8005a18:	2300      	movs	r3, #0
}
 8005a1a:	0018      	movs	r0, r3
 8005a1c:	46bd      	mov	sp, r7
 8005a1e:	b006      	add	sp, #24
 8005a20:	bd80      	pop	{r7, pc}
 8005a22:	46c0      	nop			; (mov r8, r8)
 8005a24:	0801ecd8 	.word	0x0801ecd8

08005a28 <LPS22HB_Set_ODR_When_Disabled>:
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Set_ODR_When_Disabled( DrvContextTypeDef *handle, SensorOdr_t odr,
    LPS22HB_Combo_Data_t *combo )
{
 8005a28:	b580      	push	{r7, lr}
 8005a2a:	b084      	sub	sp, #16
 8005a2c:	af00      	add	r7, sp, #0
 8005a2e:	60f8      	str	r0, [r7, #12]
 8005a30:	607a      	str	r2, [r7, #4]
 8005a32:	200b      	movs	r0, #11
 8005a34:	183b      	adds	r3, r7, r0
 8005a36:	1c0a      	adds	r2, r1, #0
 8005a38:	701a      	strb	r2, [r3, #0]

  switch( odr )
 8005a3a:	183b      	adds	r3, r7, r0
 8005a3c:	781b      	ldrb	r3, [r3, #0]
 8005a3e:	2b04      	cmp	r3, #4
 8005a40:	d819      	bhi.n	8005a76 <LPS22HB_Set_ODR_When_Disabled+0x4e>
 8005a42:	009a      	lsls	r2, r3, #2
 8005a44:	4b0f      	ldr	r3, [pc, #60]	; (8005a84 <LPS22HB_Set_ODR_When_Disabled+0x5c>)
 8005a46:	18d3      	adds	r3, r2, r3
 8005a48:	681b      	ldr	r3, [r3, #0]
 8005a4a:	469f      	mov	pc, r3
  {
    case ODR_LOW:
      combo->Last_ODR = 1.0f;
 8005a4c:	687b      	ldr	r3, [r7, #4]
 8005a4e:	22fe      	movs	r2, #254	; 0xfe
 8005a50:	0592      	lsls	r2, r2, #22
 8005a52:	605a      	str	r2, [r3, #4]
      break;
 8005a54:	e011      	b.n	8005a7a <LPS22HB_Set_ODR_When_Disabled+0x52>
    case ODR_MID_LOW:
      combo->Last_ODR = 10.0f;
 8005a56:	687b      	ldr	r3, [r7, #4]
 8005a58:	4a0b      	ldr	r2, [pc, #44]	; (8005a88 <LPS22HB_Set_ODR_When_Disabled+0x60>)
 8005a5a:	605a      	str	r2, [r3, #4]
      break;
 8005a5c:	e00d      	b.n	8005a7a <LPS22HB_Set_ODR_When_Disabled+0x52>
    case ODR_MID:
      combo->Last_ODR = 25.0f;
 8005a5e:	687b      	ldr	r3, [r7, #4]
 8005a60:	4a0a      	ldr	r2, [pc, #40]	; (8005a8c <LPS22HB_Set_ODR_When_Disabled+0x64>)
 8005a62:	605a      	str	r2, [r3, #4]
      break;
 8005a64:	e009      	b.n	8005a7a <LPS22HB_Set_ODR_When_Disabled+0x52>
    case ODR_MID_HIGH:
      combo->Last_ODR = 50.0f;
 8005a66:	687b      	ldr	r3, [r7, #4]
 8005a68:	4a09      	ldr	r2, [pc, #36]	; (8005a90 <LPS22HB_Set_ODR_When_Disabled+0x68>)
 8005a6a:	605a      	str	r2, [r3, #4]
      break;
 8005a6c:	e005      	b.n	8005a7a <LPS22HB_Set_ODR_When_Disabled+0x52>
    case ODR_HIGH:
      combo->Last_ODR = 75.0f;
 8005a6e:	687b      	ldr	r3, [r7, #4]
 8005a70:	4a08      	ldr	r2, [pc, #32]	; (8005a94 <LPS22HB_Set_ODR_When_Disabled+0x6c>)
 8005a72:	605a      	str	r2, [r3, #4]
      break;
 8005a74:	e001      	b.n	8005a7a <LPS22HB_Set_ODR_When_Disabled+0x52>
    default:
      return COMPONENT_ERROR;
 8005a76:	2301      	movs	r3, #1
 8005a78:	e000      	b.n	8005a7c <LPS22HB_Set_ODR_When_Disabled+0x54>
  }

  return COMPONENT_OK;
 8005a7a:	2300      	movs	r3, #0
}
 8005a7c:	0018      	movs	r0, r3
 8005a7e:	46bd      	mov	sp, r7
 8005a80:	b004      	add	sp, #16
 8005a82:	bd80      	pop	{r7, pc}
 8005a84:	0801ecec 	.word	0x0801ecec
 8005a88:	41200000 	.word	0x41200000
 8005a8c:	41c80000 	.word	0x41c80000
 8005a90:	42480000 	.word	0x42480000
 8005a94:	42960000 	.word	0x42960000

08005a98 <LPS22HB_Set_ODR_Value_When_Enabled>:
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Set_ODR_Value_When_Enabled( DrvContextTypeDef *handle, float odr,
    LPS22HB_Combo_Data_t *combo )
{
 8005a98:	b580      	push	{r7, lr}
 8005a9a:	b086      	sub	sp, #24
 8005a9c:	af00      	add	r7, sp, #0
 8005a9e:	60f8      	str	r0, [r7, #12]
 8005aa0:	60b9      	str	r1, [r7, #8]
 8005aa2:	607a      	str	r2, [r7, #4]

  LPS22HB_Odr_et new_odr;

  new_odr = ( odr <=  1.0f ) ? LPS22HB_ODR_1HZ
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 8005aa4:	21fe      	movs	r1, #254	; 0xfe
 8005aa6:	0589      	lsls	r1, r1, #22
 8005aa8:	68b8      	ldr	r0, [r7, #8]
 8005aaa:	f7fa fd07 	bl	80004bc <__aeabi_fcmple>
 8005aae:	1e03      	subs	r3, r0, #0
 8005ab0:	d001      	beq.n	8005ab6 <LPS22HB_Set_ODR_Value_When_Enabled+0x1e>
 8005ab2:	2310      	movs	r3, #16
 8005ab4:	e018      	b.n	8005ae8 <LPS22HB_Set_ODR_Value_When_Enabled+0x50>
 8005ab6:	491c      	ldr	r1, [pc, #112]	; (8005b28 <LPS22HB_Set_ODR_Value_When_Enabled+0x90>)
 8005ab8:	68b8      	ldr	r0, [r7, #8]
 8005aba:	f7fa fcff 	bl	80004bc <__aeabi_fcmple>
 8005abe:	1e03      	subs	r3, r0, #0
 8005ac0:	d001      	beq.n	8005ac6 <LPS22HB_Set_ODR_Value_When_Enabled+0x2e>
 8005ac2:	2320      	movs	r3, #32
 8005ac4:	e010      	b.n	8005ae8 <LPS22HB_Set_ODR_Value_When_Enabled+0x50>
 8005ac6:	4919      	ldr	r1, [pc, #100]	; (8005b2c <LPS22HB_Set_ODR_Value_When_Enabled+0x94>)
 8005ac8:	68b8      	ldr	r0, [r7, #8]
 8005aca:	f7fa fcf7 	bl	80004bc <__aeabi_fcmple>
 8005ace:	1e03      	subs	r3, r0, #0
 8005ad0:	d001      	beq.n	8005ad6 <LPS22HB_Set_ODR_Value_When_Enabled+0x3e>
 8005ad2:	2330      	movs	r3, #48	; 0x30
 8005ad4:	e008      	b.n	8005ae8 <LPS22HB_Set_ODR_Value_When_Enabled+0x50>
 8005ad6:	4916      	ldr	r1, [pc, #88]	; (8005b30 <LPS22HB_Set_ODR_Value_When_Enabled+0x98>)
 8005ad8:	68b8      	ldr	r0, [r7, #8]
 8005ada:	f7fa fcef 	bl	80004bc <__aeabi_fcmple>
 8005ade:	1e03      	subs	r3, r0, #0
 8005ae0:	d001      	beq.n	8005ae6 <LPS22HB_Set_ODR_Value_When_Enabled+0x4e>
 8005ae2:	2340      	movs	r3, #64	; 0x40
 8005ae4:	e000      	b.n	8005ae8 <LPS22HB_Set_ODR_Value_When_Enabled+0x50>
 8005ae6:	2350      	movs	r3, #80	; 0x50
  new_odr = ( odr <=  1.0f ) ? LPS22HB_ODR_1HZ
 8005ae8:	2117      	movs	r1, #23
 8005aea:	187a      	adds	r2, r7, r1
 8005aec:	7013      	strb	r3, [r2, #0]
            : ( odr <= 25.0f ) ? LPS22HB_ODR_25HZ
            : ( odr <= 50.0f ) ? LPS22HB_ODR_50HZ
            :                    LPS22HB_ODR_75HZ;

  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 8005aee:	187b      	adds	r3, r7, r1
 8005af0:	781a      	ldrb	r2, [r3, #0]
 8005af2:	68fb      	ldr	r3, [r7, #12]
 8005af4:	0011      	movs	r1, r2
 8005af6:	0018      	movs	r0, r3
 8005af8:	f7fe ff40 	bl	800497c <LPS22HB_Set_Odr>
 8005afc:	0003      	movs	r3, r0
 8005afe:	2b01      	cmp	r3, #1
 8005b00:	d101      	bne.n	8005b06 <LPS22HB_Set_ODR_Value_When_Enabled+0x6e>
  {
    return COMPONENT_ERROR;
 8005b02:	2301      	movs	r3, #1
 8005b04:	e00c      	b.n	8005b20 <LPS22HB_Set_ODR_Value_When_Enabled+0x88>
  }

  if ( LPS22HB_Get_ODR( handle, &combo->Last_ODR ) == COMPONENT_ERROR )
 8005b06:	687b      	ldr	r3, [r7, #4]
 8005b08:	1d1a      	adds	r2, r3, #4
 8005b0a:	68fb      	ldr	r3, [r7, #12]
 8005b0c:	0011      	movs	r1, r2
 8005b0e:	0018      	movs	r0, r3
 8005b10:	f7ff feea 	bl	80058e8 <LPS22HB_Get_ODR>
 8005b14:	0003      	movs	r3, r0
 8005b16:	2b01      	cmp	r3, #1
 8005b18:	d101      	bne.n	8005b1e <LPS22HB_Set_ODR_Value_When_Enabled+0x86>
  {
    return COMPONENT_ERROR;
 8005b1a:	2301      	movs	r3, #1
 8005b1c:	e000      	b.n	8005b20 <LPS22HB_Set_ODR_Value_When_Enabled+0x88>
  }

  return COMPONENT_OK;
 8005b1e:	2300      	movs	r3, #0
}
 8005b20:	0018      	movs	r0, r3
 8005b22:	46bd      	mov	sp, r7
 8005b24:	b006      	add	sp, #24
 8005b26:	bd80      	pop	{r7, pc}
 8005b28:	41200000 	.word	0x41200000
 8005b2c:	41c80000 	.word	0x41c80000
 8005b30:	42480000 	.word	0x42480000

08005b34 <LPS22HB_Set_ODR_Value_When_Disabled>:
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Set_ODR_Value_When_Disabled( DrvContextTypeDef *handle, float odr,
    LPS22HB_Combo_Data_t *combo )
{
 8005b34:	b580      	push	{r7, lr}
 8005b36:	b084      	sub	sp, #16
 8005b38:	af00      	add	r7, sp, #0
 8005b3a:	60f8      	str	r0, [r7, #12]
 8005b3c:	60b9      	str	r1, [r7, #8]
 8005b3e:	607a      	str	r2, [r7, #4]

  combo->Last_ODR = ( odr <=  1.0f ) ? 1.0f
                    : ( odr <= 10.0f ) ? 10.0f
 8005b40:	21fe      	movs	r1, #254	; 0xfe
 8005b42:	0589      	lsls	r1, r1, #22
 8005b44:	68b8      	ldr	r0, [r7, #8]
 8005b46:	f7fa fcb9 	bl	80004bc <__aeabi_fcmple>
 8005b4a:	1e03      	subs	r3, r0, #0
 8005b4c:	d002      	beq.n	8005b54 <LPS22HB_Set_ODR_Value_When_Disabled+0x20>
 8005b4e:	23fe      	movs	r3, #254	; 0xfe
 8005b50:	059b      	lsls	r3, r3, #22
 8005b52:	e018      	b.n	8005b86 <LPS22HB_Set_ODR_Value_When_Disabled+0x52>
                    : ( odr <= 25.0f ) ? 25.0f
 8005b54:	490f      	ldr	r1, [pc, #60]	; (8005b94 <LPS22HB_Set_ODR_Value_When_Disabled+0x60>)
 8005b56:	68b8      	ldr	r0, [r7, #8]
 8005b58:	f7fa fcb0 	bl	80004bc <__aeabi_fcmple>
 8005b5c:	1e03      	subs	r3, r0, #0
 8005b5e:	d001      	beq.n	8005b64 <LPS22HB_Set_ODR_Value_When_Disabled+0x30>
 8005b60:	4b0c      	ldr	r3, [pc, #48]	; (8005b94 <LPS22HB_Set_ODR_Value_When_Disabled+0x60>)
 8005b62:	e010      	b.n	8005b86 <LPS22HB_Set_ODR_Value_When_Disabled+0x52>
                    : ( odr <= 50.0f ) ? 50.0f
 8005b64:	490c      	ldr	r1, [pc, #48]	; (8005b98 <LPS22HB_Set_ODR_Value_When_Disabled+0x64>)
 8005b66:	68b8      	ldr	r0, [r7, #8]
 8005b68:	f7fa fca8 	bl	80004bc <__aeabi_fcmple>
 8005b6c:	1e03      	subs	r3, r0, #0
 8005b6e:	d001      	beq.n	8005b74 <LPS22HB_Set_ODR_Value_When_Disabled+0x40>
 8005b70:	4b09      	ldr	r3, [pc, #36]	; (8005b98 <LPS22HB_Set_ODR_Value_When_Disabled+0x64>)
 8005b72:	e008      	b.n	8005b86 <LPS22HB_Set_ODR_Value_When_Disabled+0x52>
                    :                    75.0f;
 8005b74:	4909      	ldr	r1, [pc, #36]	; (8005b9c <LPS22HB_Set_ODR_Value_When_Disabled+0x68>)
 8005b76:	68b8      	ldr	r0, [r7, #8]
 8005b78:	f7fa fca0 	bl	80004bc <__aeabi_fcmple>
 8005b7c:	1e03      	subs	r3, r0, #0
 8005b7e:	d001      	beq.n	8005b84 <LPS22HB_Set_ODR_Value_When_Disabled+0x50>
 8005b80:	4b06      	ldr	r3, [pc, #24]	; (8005b9c <LPS22HB_Set_ODR_Value_When_Disabled+0x68>)
 8005b82:	e000      	b.n	8005b86 <LPS22HB_Set_ODR_Value_When_Disabled+0x52>
 8005b84:	4b06      	ldr	r3, [pc, #24]	; (8005ba0 <LPS22HB_Set_ODR_Value_When_Disabled+0x6c>)
  combo->Last_ODR = ( odr <=  1.0f ) ? 1.0f
 8005b86:	687a      	ldr	r2, [r7, #4]
 8005b88:	6053      	str	r3, [r2, #4]

  return COMPONENT_OK;
 8005b8a:	2300      	movs	r3, #0
}
 8005b8c:	0018      	movs	r0, r3
 8005b8e:	46bd      	mov	sp, r7
 8005b90:	b004      	add	sp, #16
 8005b92:	bd80      	pop	{r7, pc}
 8005b94:	41200000 	.word	0x41200000
 8005b98:	41c80000 	.word	0x41c80000
 8005b9c:	42480000 	.word	0x42480000
 8005ba0:	42960000 	.word	0x42960000

08005ba4 <LPS22HB_Read_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Read_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t *data )
{
 8005ba4:	b580      	push	{r7, lr}
 8005ba6:	b084      	sub	sp, #16
 8005ba8:	af00      	add	r7, sp, #0
 8005baa:	60f8      	str	r0, [r7, #12]
 8005bac:	607a      	str	r2, [r7, #4]
 8005bae:	200b      	movs	r0, #11
 8005bb0:	183b      	adds	r3, r7, r0
 8005bb2:	1c0a      	adds	r2, r1, #0
 8005bb4:	701a      	strb	r2, [r3, #0]

  if ( LPS22HB_ReadReg( (void *)handle, reg, 1, data ) == LPS22HB_ERROR )
 8005bb6:	687a      	ldr	r2, [r7, #4]
 8005bb8:	183b      	adds	r3, r7, r0
 8005bba:	7819      	ldrb	r1, [r3, #0]
 8005bbc:	68f8      	ldr	r0, [r7, #12]
 8005bbe:	0013      	movs	r3, r2
 8005bc0:	2201      	movs	r2, #1
 8005bc2:	f7fe fe2e 	bl	8004822 <LPS22HB_ReadReg>
 8005bc6:	0003      	movs	r3, r0
 8005bc8:	2b01      	cmp	r3, #1
 8005bca:	d101      	bne.n	8005bd0 <LPS22HB_Read_Reg+0x2c>
  {
    return COMPONENT_ERROR;
 8005bcc:	2301      	movs	r3, #1
 8005bce:	e000      	b.n	8005bd2 <LPS22HB_Read_Reg+0x2e>
  }

  return COMPONENT_OK;
 8005bd0:	2300      	movs	r3, #0
}
 8005bd2:	0018      	movs	r0, r3
 8005bd4:	46bd      	mov	sp, r7
 8005bd6:	b004      	add	sp, #16
 8005bd8:	bd80      	pop	{r7, pc}

08005bda <LPS22HB_Write_Reg>:
 * @param data register data
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Write_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t data )
{
 8005bda:	b580      	push	{r7, lr}
 8005bdc:	b082      	sub	sp, #8
 8005bde:	af00      	add	r7, sp, #0
 8005be0:	6078      	str	r0, [r7, #4]
 8005be2:	0008      	movs	r0, r1
 8005be4:	0011      	movs	r1, r2
 8005be6:	1cfb      	adds	r3, r7, #3
 8005be8:	1c02      	adds	r2, r0, #0
 8005bea:	701a      	strb	r2, [r3, #0]
 8005bec:	1cbb      	adds	r3, r7, #2
 8005bee:	1c0a      	adds	r2, r1, #0
 8005bf0:	701a      	strb	r2, [r3, #0]

  if ( LPS22HB_WriteReg( (void *)handle, reg, 1, &data ) == LPS22HB_ERROR )
 8005bf2:	1cba      	adds	r2, r7, #2
 8005bf4:	1cfb      	adds	r3, r7, #3
 8005bf6:	7819      	ldrb	r1, [r3, #0]
 8005bf8:	6878      	ldr	r0, [r7, #4]
 8005bfa:	0013      	movs	r3, r2
 8005bfc:	2201      	movs	r2, #1
 8005bfe:	f7fe fe44 	bl	800488a <LPS22HB_WriteReg>
 8005c02:	0003      	movs	r3, r0
 8005c04:	2b01      	cmp	r3, #1
 8005c06:	d101      	bne.n	8005c0c <LPS22HB_Write_Reg+0x32>
  {
    return COMPONENT_ERROR;
 8005c08:	2301      	movs	r3, #1
 8005c0a:	e000      	b.n	8005c0e <LPS22HB_Write_Reg+0x34>
  }

  return COMPONENT_OK;
 8005c0c:	2300      	movs	r3, #0
}
 8005c0e:	0018      	movs	r0, r3
 8005c10:	46bd      	mov	sp, r7
 8005c12:	b002      	add	sp, #8
 8005c14:	bd80      	pop	{r7, pc}

08005c16 <LPS22HB_FIFO_Get_Empty_Status>:
 * @param status the pointer where the status is stored. 1 means FIFO_EMPTY
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Get_Empty_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 8005c16:	b580      	push	{r7, lr}
 8005c18:	b084      	sub	sp, #16
 8005c1a:	af00      	add	r7, sp, #0
 8005c1c:	6078      	str	r0, [r7, #4]
 8005c1e:	6039      	str	r1, [r7, #0]

  LPS22HB_FifoStatus_st status_raw;

  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8005c20:	2308      	movs	r3, #8
 8005c22:	18fa      	adds	r2, r7, r3
 8005c24:	687b      	ldr	r3, [r7, #4]
 8005c26:	0011      	movs	r1, r2
 8005c28:	0018      	movs	r0, r3
 8005c2a:	f7ff fa4d 	bl	80050c8 <LPS22HB_Get_FifoStatus>
 8005c2e:	0003      	movs	r3, r0
 8005c30:	2b01      	cmp	r3, #1
 8005c32:	d101      	bne.n	8005c38 <LPS22HB_FIFO_Get_Empty_Status+0x22>
  {
    return COMPONENT_ERROR;
 8005c34:	2301      	movs	r3, #1
 8005c36:	e005      	b.n	8005c44 <LPS22HB_FIFO_Get_Empty_Status+0x2e>
  }

  *status = status_raw.FIFO_EMPTY;
 8005c38:	2308      	movs	r3, #8
 8005c3a:	18fb      	adds	r3, r7, r3
 8005c3c:	785a      	ldrb	r2, [r3, #1]
 8005c3e:	683b      	ldr	r3, [r7, #0]
 8005c40:	701a      	strb	r2, [r3, #0]

  return COMPONENT_OK;
 8005c42:	2300      	movs	r3, #0
}
 8005c44:	0018      	movs	r0, r3
 8005c46:	46bd      	mov	sp, r7
 8005c48:	b004      	add	sp, #16
 8005c4a:	bd80      	pop	{r7, pc}

08005c4c <LPS22HB_FIFO_Get_Full_Status>:
 * @param status the pointer where the status is stored. 1 means FIFO_FULL
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Get_Full_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 8005c4c:	b580      	push	{r7, lr}
 8005c4e:	b084      	sub	sp, #16
 8005c50:	af00      	add	r7, sp, #0
 8005c52:	6078      	str	r0, [r7, #4]
 8005c54:	6039      	str	r1, [r7, #0]

  LPS22HB_FifoStatus_st status_raw;

  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8005c56:	2308      	movs	r3, #8
 8005c58:	18fa      	adds	r2, r7, r3
 8005c5a:	687b      	ldr	r3, [r7, #4]
 8005c5c:	0011      	movs	r1, r2
 8005c5e:	0018      	movs	r0, r3
 8005c60:	f7ff fa32 	bl	80050c8 <LPS22HB_Get_FifoStatus>
 8005c64:	0003      	movs	r3, r0
 8005c66:	2b01      	cmp	r3, #1
 8005c68:	d101      	bne.n	8005c6e <LPS22HB_FIFO_Get_Full_Status+0x22>
  {
    return COMPONENT_ERROR;
 8005c6a:	2301      	movs	r3, #1
 8005c6c:	e005      	b.n	8005c7a <LPS22HB_FIFO_Get_Full_Status+0x2e>
  }

  *status = status_raw.FIFO_FULL;
 8005c6e:	2308      	movs	r3, #8
 8005c70:	18fb      	adds	r3, r7, r3
 8005c72:	789a      	ldrb	r2, [r3, #2]
 8005c74:	683b      	ldr	r3, [r7, #0]
 8005c76:	701a      	strb	r2, [r3, #0]

  return COMPONENT_OK;
 8005c78:	2300      	movs	r3, #0
}
 8005c7a:	0018      	movs	r0, r3
 8005c7c:	46bd      	mov	sp, r7
 8005c7e:	b004      	add	sp, #16
 8005c80:	bd80      	pop	{r7, pc}

08005c82 <LPS22HB_FIFO_Get_Ovr_Status>:
 * @param status the pointer where the status is stored. 1 means FIFO_OVR
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Get_Ovr_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 8005c82:	b580      	push	{r7, lr}
 8005c84:	b084      	sub	sp, #16
 8005c86:	af00      	add	r7, sp, #0
 8005c88:	6078      	str	r0, [r7, #4]
 8005c8a:	6039      	str	r1, [r7, #0]

  LPS22HB_FifoStatus_st status_raw;

  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8005c8c:	2308      	movs	r3, #8
 8005c8e:	18fa      	adds	r2, r7, r3
 8005c90:	687b      	ldr	r3, [r7, #4]
 8005c92:	0011      	movs	r1, r2
 8005c94:	0018      	movs	r0, r3
 8005c96:	f7ff fa17 	bl	80050c8 <LPS22HB_Get_FifoStatus>
 8005c9a:	0003      	movs	r3, r0
 8005c9c:	2b01      	cmp	r3, #1
 8005c9e:	d101      	bne.n	8005ca4 <LPS22HB_FIFO_Get_Ovr_Status+0x22>
  {
    return COMPONENT_ERROR;
 8005ca0:	2301      	movs	r3, #1
 8005ca2:	e005      	b.n	8005cb0 <LPS22HB_FIFO_Get_Ovr_Status+0x2e>
  }

  *status = status_raw.FIFO_OVR;
 8005ca4:	2308      	movs	r3, #8
 8005ca6:	18fb      	adds	r3, r7, r3
 8005ca8:	78da      	ldrb	r2, [r3, #3]
 8005caa:	683b      	ldr	r3, [r7, #0]
 8005cac:	701a      	strb	r2, [r3, #0]

  return COMPONENT_OK;
 8005cae:	2300      	movs	r3, #0
}
 8005cb0:	0018      	movs	r0, r3
 8005cb2:	46bd      	mov	sp, r7
 8005cb4:	b004      	add	sp, #16
 8005cb6:	bd80      	pop	{r7, pc}

08005cb8 <LPS22HB_FIFO_Get_Fth_Status>:
 * @param status the pointer where the status is stored. 1 means FIFO_FTH
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Get_Fth_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 8005cb8:	b580      	push	{r7, lr}
 8005cba:	b084      	sub	sp, #16
 8005cbc:	af00      	add	r7, sp, #0
 8005cbe:	6078      	str	r0, [r7, #4]
 8005cc0:	6039      	str	r1, [r7, #0]

  LPS22HB_FifoStatus_st status_raw;

  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8005cc2:	2308      	movs	r3, #8
 8005cc4:	18fa      	adds	r2, r7, r3
 8005cc6:	687b      	ldr	r3, [r7, #4]
 8005cc8:	0011      	movs	r1, r2
 8005cca:	0018      	movs	r0, r3
 8005ccc:	f7ff f9fc 	bl	80050c8 <LPS22HB_Get_FifoStatus>
 8005cd0:	0003      	movs	r3, r0
 8005cd2:	2b01      	cmp	r3, #1
 8005cd4:	d101      	bne.n	8005cda <LPS22HB_FIFO_Get_Fth_Status+0x22>
  {
    return COMPONENT_ERROR;
 8005cd6:	2301      	movs	r3, #1
 8005cd8:	e005      	b.n	8005ce6 <LPS22HB_FIFO_Get_Fth_Status+0x2e>
  }

  *status = status_raw.FIFO_FTH;
 8005cda:	2308      	movs	r3, #8
 8005cdc:	18fb      	adds	r3, r7, r3
 8005cde:	791a      	ldrb	r2, [r3, #4]
 8005ce0:	683b      	ldr	r3, [r7, #0]
 8005ce2:	701a      	strb	r2, [r3, #0]

  return COMPONENT_OK;
 8005ce4:	2300      	movs	r3, #0
}
 8005ce6:	0018      	movs	r0, r3
 8005ce8:	46bd      	mov	sp, r7
 8005cea:	b004      	add	sp, #16
 8005cec:	bd80      	pop	{r7, pc}

08005cee <LPS22HB_FIFO_Stop_On_Fth>:
 * @param status enable or disable stopping on FTH interrupt
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Stop_On_Fth( DrvContextTypeDef *handle, uint8_t status )
{
 8005cee:	b580      	push	{r7, lr}
 8005cf0:	b082      	sub	sp, #8
 8005cf2:	af00      	add	r7, sp, #0
 8005cf4:	6078      	str	r0, [r7, #4]
 8005cf6:	000a      	movs	r2, r1
 8005cf8:	1cfb      	adds	r3, r7, #3
 8005cfa:	701a      	strb	r2, [r3, #0]

  /* Verify that the passed parameter contains one of the valid values */
  switch ( ( LPS22HB_State_et )status )
 8005cfc:	1cfb      	adds	r3, r7, #3
 8005cfe:	781b      	ldrb	r3, [r3, #0]
 8005d00:	2b01      	cmp	r3, #1
 8005d02:	d901      	bls.n	8005d08 <LPS22HB_FIFO_Stop_On_Fth+0x1a>
  {
    case LPS22HB_DISABLE:
    case LPS22HB_ENABLE:
      break;
    default:
      return COMPONENT_ERROR;
 8005d04:	2301      	movs	r3, #1
 8005d06:	e00d      	b.n	8005d24 <LPS22HB_FIFO_Stop_On_Fth+0x36>
      break;
 8005d08:	46c0      	nop			; (mov r8, r8)
  }

  if ( LPS22HB_Set_FifoWatermarkLevelUse( handle, ( LPS22HB_State_et )status ) == LPS22HB_ERROR )
 8005d0a:	1cfb      	adds	r3, r7, #3
 8005d0c:	781a      	ldrb	r2, [r3, #0]
 8005d0e:	687b      	ldr	r3, [r7, #4]
 8005d10:	0011      	movs	r1, r2
 8005d12:	0018      	movs	r0, r3
 8005d14:	f7fe ff4c 	bl	8004bb0 <LPS22HB_Set_FifoWatermarkLevelUse>
 8005d18:	0003      	movs	r3, r0
 8005d1a:	2b01      	cmp	r3, #1
 8005d1c:	d101      	bne.n	8005d22 <LPS22HB_FIFO_Stop_On_Fth+0x34>
  {
    return COMPONENT_ERROR;
 8005d1e:	2301      	movs	r3, #1
 8005d20:	e000      	b.n	8005d24 <LPS22HB_FIFO_Stop_On_Fth+0x36>
  }

  return COMPONENT_OK;
 8005d22:	2300      	movs	r3, #0
}
 8005d24:	0018      	movs	r0, r3
 8005d26:	46bd      	mov	sp, r7
 8005d28:	b002      	add	sp, #8
 8005d2a:	bd80      	pop	{r7, pc}

08005d2c <LPS22HB_FIFO_Usage>:
 * @param status enable or disable FIFO
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Usage( DrvContextTypeDef *handle, uint8_t status )
{
 8005d2c:	b580      	push	{r7, lr}
 8005d2e:	b082      	sub	sp, #8
 8005d30:	af00      	add	r7, sp, #0
 8005d32:	6078      	str	r0, [r7, #4]
 8005d34:	000a      	movs	r2, r1
 8005d36:	1cfb      	adds	r3, r7, #3
 8005d38:	701a      	strb	r2, [r3, #0]

  /* Verify that the passed parameter contains one of the valid values */
  switch ( ( LPS22HB_State_et )status )
 8005d3a:	1cfb      	adds	r3, r7, #3
 8005d3c:	781b      	ldrb	r3, [r3, #0]
 8005d3e:	2b01      	cmp	r3, #1
 8005d40:	d901      	bls.n	8005d46 <LPS22HB_FIFO_Usage+0x1a>
  {
    case LPS22HB_DISABLE:
    case LPS22HB_ENABLE:
      break;
    default:
      return COMPONENT_ERROR;
 8005d42:	2301      	movs	r3, #1
 8005d44:	e00d      	b.n	8005d62 <LPS22HB_FIFO_Usage+0x36>
      break;
 8005d46:	46c0      	nop			; (mov r8, r8)
  }

  if ( LPS22HB_Set_FifoModeUse( handle, ( LPS22HB_State_et )status ) == LPS22HB_ERROR )
 8005d48:	1cfb      	adds	r3, r7, #3
 8005d4a:	781a      	ldrb	r2, [r3, #0]
 8005d4c:	687b      	ldr	r3, [r7, #4]
 8005d4e:	0011      	movs	r1, r2
 8005d50:	0018      	movs	r0, r3
 8005d52:	f7fe fef8 	bl	8004b46 <LPS22HB_Set_FifoModeUse>
 8005d56:	0003      	movs	r3, r0
 8005d58:	2b01      	cmp	r3, #1
 8005d5a:	d101      	bne.n	8005d60 <LPS22HB_FIFO_Usage+0x34>
  {
    return COMPONENT_ERROR;
 8005d5c:	2301      	movs	r3, #1
 8005d5e:	e000      	b.n	8005d62 <LPS22HB_FIFO_Usage+0x36>
  }

  return COMPONENT_OK;
 8005d60:	2300      	movs	r3, #0
}
 8005d62:	0018      	movs	r0, r3
 8005d64:	46bd      	mov	sp, r7
 8005d66:	b002      	add	sp, #8
 8005d68:	bd80      	pop	{r7, pc}

08005d6a <LPS22HB_FIFO_Get_Num_Of_Samples>:
 * @param nSamples the pointer where the number of FIFO unread samples is stored
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Get_Num_Of_Samples( DrvContextTypeDef *handle, uint8_t *nSamples )
{
 8005d6a:	b580      	push	{r7, lr}
 8005d6c:	b084      	sub	sp, #16
 8005d6e:	af00      	add	r7, sp, #0
 8005d70:	6078      	str	r0, [r7, #4]
 8005d72:	6039      	str	r1, [r7, #0]

  LPS22HB_FifoStatus_st status_raw;

  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8005d74:	2308      	movs	r3, #8
 8005d76:	18fa      	adds	r2, r7, r3
 8005d78:	687b      	ldr	r3, [r7, #4]
 8005d7a:	0011      	movs	r1, r2
 8005d7c:	0018      	movs	r0, r3
 8005d7e:	f7ff f9a3 	bl	80050c8 <LPS22HB_Get_FifoStatus>
 8005d82:	0003      	movs	r3, r0
 8005d84:	2b01      	cmp	r3, #1
 8005d86:	d101      	bne.n	8005d8c <LPS22HB_FIFO_Get_Num_Of_Samples+0x22>
  {
    return COMPONENT_ERROR;
 8005d88:	2301      	movs	r3, #1
 8005d8a:	e005      	b.n	8005d98 <LPS22HB_FIFO_Get_Num_Of_Samples+0x2e>
  }

  *nSamples = status_raw.FIFO_LEVEL;
 8005d8c:	2308      	movs	r3, #8
 8005d8e:	18fb      	adds	r3, r7, r3
 8005d90:	781a      	ldrb	r2, [r3, #0]
 8005d92:	683b      	ldr	r3, [r7, #0]
 8005d94:	701a      	strb	r2, [r3, #0]

  return COMPONENT_OK;
 8005d96:	2300      	movs	r3, #0
}
 8005d98:	0018      	movs	r0, r3
 8005d9a:	46bd      	mov	sp, r7
 8005d9c:	b004      	add	sp, #16
 8005d9e:	bd80      	pop	{r7, pc}

08005da0 <LPS22HB_FIFO_Get_Data>:
 * @param temperature the pointer where the temperature part of FIFO sample is stored
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Get_Data( DrvContextTypeDef *handle, float *pressure, float *temperature )
{
 8005da0:	b580      	push	{r7, lr}
 8005da2:	b084      	sub	sp, #16
 8005da4:	af00      	add	r7, sp, #0
 8005da6:	60f8      	str	r0, [r7, #12]
 8005da8:	60b9      	str	r1, [r7, #8]
 8005daa:	607a      	str	r2, [r7, #4]

  if ( LPS22HB_Get_Press( handle, pressure ) == COMPONENT_ERROR )
 8005dac:	68ba      	ldr	r2, [r7, #8]
 8005dae:	68fb      	ldr	r3, [r7, #12]
 8005db0:	0011      	movs	r1, r2
 8005db2:	0018      	movs	r0, r3
 8005db4:	f7ff fd44 	bl	8005840 <LPS22HB_Get_Press>
 8005db8:	0003      	movs	r3, r0
 8005dba:	2b01      	cmp	r3, #1
 8005dbc:	d101      	bne.n	8005dc2 <LPS22HB_FIFO_Get_Data+0x22>
  {
    return COMPONENT_ERROR;
 8005dbe:	2301      	movs	r3, #1
 8005dc0:	e00b      	b.n	8005dda <LPS22HB_FIFO_Get_Data+0x3a>
  }

  if ( LPS22HB_Get_Temp( handle, temperature ) == COMPONENT_ERROR )
 8005dc2:	687a      	ldr	r2, [r7, #4]
 8005dc4:	68fb      	ldr	r3, [r7, #12]
 8005dc6:	0011      	movs	r1, r2
 8005dc8:	0018      	movs	r0, r3
 8005dca:	f7ff fd61 	bl	8005890 <LPS22HB_Get_Temp>
 8005dce:	0003      	movs	r3, r0
 8005dd0:	2b01      	cmp	r3, #1
 8005dd2:	d101      	bne.n	8005dd8 <LPS22HB_FIFO_Get_Data+0x38>
  {
    return COMPONENT_ERROR;
 8005dd4:	2301      	movs	r3, #1
 8005dd6:	e000      	b.n	8005dda <LPS22HB_FIFO_Get_Data+0x3a>
  }

  return COMPONENT_OK;
 8005dd8:	2300      	movs	r3, #0
}
 8005dda:	0018      	movs	r0, r3
 8005ddc:	46bd      	mov	sp, r7
 8005dde:	b004      	add	sp, #16
 8005de0:	bd80      	pop	{r7, pc}

08005de2 <LPS22HB_FIFO_Get_Mode>:
 * @param mode the pointer where the FIFO mode is stored
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Get_Mode( DrvContextTypeDef *handle, uint8_t *mode )
{
 8005de2:	b580      	push	{r7, lr}
 8005de4:	b084      	sub	sp, #16
 8005de6:	af00      	add	r7, sp, #0
 8005de8:	6078      	str	r0, [r7, #4]
 8005dea:	6039      	str	r1, [r7, #0]

  LPS22HB_FifoMode_et mode_raw;

  if ( LPS22HB_Get_FifoMode( handle, &mode_raw ) == LPS22HB_ERROR )
 8005dec:	230f      	movs	r3, #15
 8005dee:	18fa      	adds	r2, r7, r3
 8005df0:	687b      	ldr	r3, [r7, #4]
 8005df2:	0011      	movs	r1, r2
 8005df4:	0018      	movs	r0, r3
 8005df6:	f7ff f8fa 	bl	8004fee <LPS22HB_Get_FifoMode>
 8005dfa:	0003      	movs	r3, r0
 8005dfc:	2b01      	cmp	r3, #1
 8005dfe:	d101      	bne.n	8005e04 <LPS22HB_FIFO_Get_Mode+0x22>
  {
    return COMPONENT_ERROR;
 8005e00:	2301      	movs	r3, #1
 8005e02:	e005      	b.n	8005e10 <LPS22HB_FIFO_Get_Mode+0x2e>
  }

  *mode = ( uint8_t )mode_raw;
 8005e04:	230f      	movs	r3, #15
 8005e06:	18fb      	adds	r3, r7, r3
 8005e08:	781a      	ldrb	r2, [r3, #0]
 8005e0a:	683b      	ldr	r3, [r7, #0]
 8005e0c:	701a      	strb	r2, [r3, #0]

  return COMPONENT_OK;
 8005e0e:	2300      	movs	r3, #0
}
 8005e10:	0018      	movs	r0, r3
 8005e12:	46bd      	mov	sp, r7
 8005e14:	b004      	add	sp, #16
 8005e16:	bd80      	pop	{r7, pc}

08005e18 <LPS22HB_FIFO_Set_Mode>:
 * @param mode The FIFO mode to be set
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Set_Mode( DrvContextTypeDef *handle, uint8_t mode )
{
 8005e18:	b580      	push	{r7, lr}
 8005e1a:	b082      	sub	sp, #8
 8005e1c:	af00      	add	r7, sp, #0
 8005e1e:	6078      	str	r0, [r7, #4]
 8005e20:	000a      	movs	r2, r1
 8005e22:	1cfb      	adds	r3, r7, #3
 8005e24:	701a      	strb	r2, [r3, #0]

  /* Verify that the passed parameter contains one of the valid values */
  switch ( ( LPS22HB_FifoMode_et )mode )
 8005e26:	1cfb      	adds	r3, r7, #3
 8005e28:	781b      	ldrb	r3, [r3, #0]
 8005e2a:	2be0      	cmp	r3, #224	; 0xe0
 8005e2c:	d00f      	beq.n	8005e4e <LPS22HB_FIFO_Set_Mode+0x36>
 8005e2e:	dc0c      	bgt.n	8005e4a <LPS22HB_FIFO_Set_Mode+0x32>
 8005e30:	2b80      	cmp	r3, #128	; 0x80
 8005e32:	d00c      	beq.n	8005e4e <LPS22HB_FIFO_Set_Mode+0x36>
 8005e34:	dc09      	bgt.n	8005e4a <LPS22HB_FIFO_Set_Mode+0x32>
 8005e36:	2b60      	cmp	r3, #96	; 0x60
 8005e38:	d009      	beq.n	8005e4e <LPS22HB_FIFO_Set_Mode+0x36>
 8005e3a:	dc06      	bgt.n	8005e4a <LPS22HB_FIFO_Set_Mode+0x32>
 8005e3c:	2b40      	cmp	r3, #64	; 0x40
 8005e3e:	d006      	beq.n	8005e4e <LPS22HB_FIFO_Set_Mode+0x36>
 8005e40:	dc03      	bgt.n	8005e4a <LPS22HB_FIFO_Set_Mode+0x32>
 8005e42:	2b00      	cmp	r3, #0
 8005e44:	d003      	beq.n	8005e4e <LPS22HB_FIFO_Set_Mode+0x36>
 8005e46:	2b20      	cmp	r3, #32
 8005e48:	d001      	beq.n	8005e4e <LPS22HB_FIFO_Set_Mode+0x36>
    case LPS22HB_FIFO_TRIGGER_STREAMTOFIFO_MODE:
    case LPS22HB_FIFO_TRIGGER_BYPASSTOSTREAM_MODE:
    case LPS22HB_FIFO_TRIGGER_BYPASSTOFIFO_MODE:
      break;
    default:
      return COMPONENT_ERROR;
 8005e4a:	2301      	movs	r3, #1
 8005e4c:	e00d      	b.n	8005e6a <LPS22HB_FIFO_Set_Mode+0x52>
      break;
 8005e4e:	46c0      	nop			; (mov r8, r8)
  }

  if ( LPS22HB_Set_FifoMode( handle, ( LPS22HB_FifoMode_et )mode ) == LPS22HB_ERROR )
 8005e50:	1cfb      	adds	r3, r7, #3
 8005e52:	781a      	ldrb	r2, [r3, #0]
 8005e54:	687b      	ldr	r3, [r7, #4]
 8005e56:	0011      	movs	r1, r2
 8005e58:	0018      	movs	r0, r3
 8005e5a:	f7ff f897 	bl	8004f8c <LPS22HB_Set_FifoMode>
 8005e5e:	0003      	movs	r3, r0
 8005e60:	2b01      	cmp	r3, #1
 8005e62:	d101      	bne.n	8005e68 <LPS22HB_FIFO_Set_Mode+0x50>
  {
    return COMPONENT_ERROR;
 8005e64:	2301      	movs	r3, #1
 8005e66:	e000      	b.n	8005e6a <LPS22HB_FIFO_Set_Mode+0x52>
  }

  return COMPONENT_OK;
 8005e68:	2300      	movs	r3, #0
}
 8005e6a:	0018      	movs	r0, r3
 8005e6c:	46bd      	mov	sp, r7
 8005e6e:	b002      	add	sp, #8
 8005e70:	bd80      	pop	{r7, pc}

08005e72 <LPS22HB_FIFO_Get_Watermark_Level>:
 * @param watermark the pointer where the FIFO watermark level is stored; values: from 0 to 31
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Get_Watermark_Level( DrvContextTypeDef *handle, uint8_t *watermark )
{
 8005e72:	b580      	push	{r7, lr}
 8005e74:	b082      	sub	sp, #8
 8005e76:	af00      	add	r7, sp, #0
 8005e78:	6078      	str	r0, [r7, #4]
 8005e7a:	6039      	str	r1, [r7, #0]

  if ( LPS22HB_Get_FifoWatermarkLevel( handle, watermark ) == LPS22HB_ERROR )
 8005e7c:	683a      	ldr	r2, [r7, #0]
 8005e7e:	687b      	ldr	r3, [r7, #4]
 8005e80:	0011      	movs	r1, r2
 8005e82:	0018      	movs	r0, r3
 8005e84:	f7ff f905 	bl	8005092 <LPS22HB_Get_FifoWatermarkLevel>
 8005e88:	0003      	movs	r3, r0
 8005e8a:	2b01      	cmp	r3, #1
 8005e8c:	d101      	bne.n	8005e92 <LPS22HB_FIFO_Get_Watermark_Level+0x20>
  {
    return COMPONENT_ERROR;
 8005e8e:	2301      	movs	r3, #1
 8005e90:	e000      	b.n	8005e94 <LPS22HB_FIFO_Get_Watermark_Level+0x22>
  }

  return COMPONENT_OK;
 8005e92:	2300      	movs	r3, #0
}
 8005e94:	0018      	movs	r0, r3
 8005e96:	46bd      	mov	sp, r7
 8005e98:	b002      	add	sp, #8
 8005e9a:	bd80      	pop	{r7, pc}

08005e9c <LPS22HB_FIFO_Set_Watermark_Level>:
 * @param watermark The FIFO watermark level to be set; values: from 0 to 31
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Set_Watermark_Level( DrvContextTypeDef *handle, uint8_t watermark )
{
 8005e9c:	b580      	push	{r7, lr}
 8005e9e:	b082      	sub	sp, #8
 8005ea0:	af00      	add	r7, sp, #0
 8005ea2:	6078      	str	r0, [r7, #4]
 8005ea4:	000a      	movs	r2, r1
 8005ea6:	1cfb      	adds	r3, r7, #3
 8005ea8:	701a      	strb	r2, [r3, #0]

  if ( LPS22HB_Set_FifoWatermarkLevel( handle, watermark ) == LPS22HB_ERROR )
 8005eaa:	1cfb      	adds	r3, r7, #3
 8005eac:	781a      	ldrb	r2, [r3, #0]
 8005eae:	687b      	ldr	r3, [r7, #4]
 8005eb0:	0011      	movs	r1, r2
 8005eb2:	0018      	movs	r0, r3
 8005eb4:	f7ff f8bc 	bl	8005030 <LPS22HB_Set_FifoWatermarkLevel>
 8005eb8:	0003      	movs	r3, r0
 8005eba:	2b01      	cmp	r3, #1
 8005ebc:	d101      	bne.n	8005ec2 <LPS22HB_FIFO_Set_Watermark_Level+0x26>
  {
    return COMPONENT_ERROR;
 8005ebe:	2301      	movs	r3, #1
 8005ec0:	e000      	b.n	8005ec4 <LPS22HB_FIFO_Set_Watermark_Level+0x28>
  }

  return COMPONENT_OK;
 8005ec2:	2300      	movs	r3, #0
}
 8005ec4:	0018      	movs	r0, r3
 8005ec6:	46bd      	mov	sp, r7
 8005ec8:	b002      	add	sp, #8
 8005eca:	bd80      	pop	{r7, pc}

08005ecc <LPS22HB_FIFO_Watermark_Usage>:
 * @param usage The FIFO watermark enable or disable
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Watermark_Usage( DrvContextTypeDef *handle, uint8_t usage )
{
 8005ecc:	b580      	push	{r7, lr}
 8005ece:	b082      	sub	sp, #8
 8005ed0:	af00      	add	r7, sp, #0
 8005ed2:	6078      	str	r0, [r7, #4]
 8005ed4:	000a      	movs	r2, r1
 8005ed6:	1cfb      	adds	r3, r7, #3
 8005ed8:	701a      	strb	r2, [r3, #0]

  /* Verify that the passed parameter contains one of the valid values */
  switch ( ( LPS22HB_State_et )usage )
 8005eda:	1cfb      	adds	r3, r7, #3
 8005edc:	781b      	ldrb	r3, [r3, #0]
 8005ede:	2b01      	cmp	r3, #1
 8005ee0:	d901      	bls.n	8005ee6 <LPS22HB_FIFO_Watermark_Usage+0x1a>
  {
    case LPS22HB_DISABLE:
    case LPS22HB_ENABLE:
      break;
    default:
      return COMPONENT_ERROR;
 8005ee2:	2301      	movs	r3, #1
 8005ee4:	e00d      	b.n	8005f02 <LPS22HB_FIFO_Watermark_Usage+0x36>
      break;
 8005ee6:	46c0      	nop			; (mov r8, r8)
  }

  if ( LPS22HB_Set_FifoWatermarkLevelUse( handle, ( LPS22HB_State_et )usage ) == LPS22HB_ERROR )
 8005ee8:	1cfb      	adds	r3, r7, #3
 8005eea:	781a      	ldrb	r2, [r3, #0]
 8005eec:	687b      	ldr	r3, [r7, #4]
 8005eee:	0011      	movs	r1, r2
 8005ef0:	0018      	movs	r0, r3
 8005ef2:	f7fe fe5d 	bl	8004bb0 <LPS22HB_Set_FifoWatermarkLevelUse>
 8005ef6:	0003      	movs	r3, r0
 8005ef8:	2b01      	cmp	r3, #1
 8005efa:	d101      	bne.n	8005f00 <LPS22HB_FIFO_Watermark_Usage+0x34>
  {
    return COMPONENT_ERROR;
 8005efc:	2301      	movs	r3, #1
 8005efe:	e000      	b.n	8005f02 <LPS22HB_FIFO_Watermark_Usage+0x36>
  }

  return COMPONENT_OK;
 8005f00:	2300      	movs	r3, #0
}
 8005f02:	0018      	movs	r0, r3
 8005f04:	46bd      	mov	sp, r7
 8005f06:	b002      	add	sp, #8
 8005f08:	bd80      	pop	{r7, pc}

08005f0a <LPS22HB_FIFO_Set_Interrupt>:
 * @param interrupt The FIFO interrupt to be set; values: 0 = FTH; 1 = FULL; 2 = OVR
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Set_Interrupt( DrvContextTypeDef *handle, uint8_t interrupt )
{
 8005f0a:	b580      	push	{r7, lr}
 8005f0c:	b082      	sub	sp, #8
 8005f0e:	af00      	add	r7, sp, #0
 8005f10:	6078      	str	r0, [r7, #4]
 8005f12:	000a      	movs	r2, r1
 8005f14:	1cfb      	adds	r3, r7, #3
 8005f16:	701a      	strb	r2, [r3, #0]

  switch( interrupt )
 8005f18:	1cfb      	adds	r3, r7, #3
 8005f1a:	781b      	ldrb	r3, [r3, #0]
 8005f1c:	2b02      	cmp	r3, #2
 8005f1e:	d019      	beq.n	8005f54 <LPS22HB_FIFO_Set_Interrupt+0x4a>
 8005f20:	dc22      	bgt.n	8005f68 <LPS22HB_FIFO_Set_Interrupt+0x5e>
 8005f22:	2b00      	cmp	r3, #0
 8005f24:	d002      	beq.n	8005f2c <LPS22HB_FIFO_Set_Interrupt+0x22>
 8005f26:	2b01      	cmp	r3, #1
 8005f28:	d00a      	beq.n	8005f40 <LPS22HB_FIFO_Set_Interrupt+0x36>
 8005f2a:	e01d      	b.n	8005f68 <LPS22HB_FIFO_Set_Interrupt+0x5e>
  {
    case 0:
      if ( LPS22HB_Set_FIFO_FTH_Interrupt( handle, LPS22HB_ENABLE ) == LPS22HB_ERROR )
 8005f2c:	687b      	ldr	r3, [r7, #4]
 8005f2e:	2101      	movs	r1, #1
 8005f30:	0018      	movs	r0, r3
 8005f32:	f7fe fedc 	bl	8004cee <LPS22HB_Set_FIFO_FTH_Interrupt>
 8005f36:	0003      	movs	r3, r0
 8005f38:	2b01      	cmp	r3, #1
 8005f3a:	d117      	bne.n	8005f6c <LPS22HB_FIFO_Set_Interrupt+0x62>
      {
        return COMPONENT_ERROR;
 8005f3c:	2301      	movs	r3, #1
 8005f3e:	e01b      	b.n	8005f78 <LPS22HB_FIFO_Set_Interrupt+0x6e>
      }
      break;
    case 1:
      if ( LPS22HB_Set_FIFO_FULL_Interrupt( handle, LPS22HB_ENABLE ) == LPS22HB_ERROR )
 8005f40:	687b      	ldr	r3, [r7, #4]
 8005f42:	2101      	movs	r1, #1
 8005f44:	0018      	movs	r0, r3
 8005f46:	f7fe ff07 	bl	8004d58 <LPS22HB_Set_FIFO_FULL_Interrupt>
 8005f4a:	0003      	movs	r3, r0
 8005f4c:	2b01      	cmp	r3, #1
 8005f4e:	d10f      	bne.n	8005f70 <LPS22HB_FIFO_Set_Interrupt+0x66>
      {
        return COMPONENT_ERROR;
 8005f50:	2301      	movs	r3, #1
 8005f52:	e011      	b.n	8005f78 <LPS22HB_FIFO_Set_Interrupt+0x6e>
      }
      break;
    case 2:
      if ( LPS22HB_Set_FIFO_OVR_Interrupt( handle, LPS22HB_ENABLE ) == LPS22HB_ERROR )
 8005f54:	687b      	ldr	r3, [r7, #4]
 8005f56:	2101      	movs	r1, #1
 8005f58:	0018      	movs	r0, r3
 8005f5a:	f7fe fe93 	bl	8004c84 <LPS22HB_Set_FIFO_OVR_Interrupt>
 8005f5e:	0003      	movs	r3, r0
 8005f60:	2b01      	cmp	r3, #1
 8005f62:	d107      	bne.n	8005f74 <LPS22HB_FIFO_Set_Interrupt+0x6a>
      {
        return COMPONENT_ERROR;
 8005f64:	2301      	movs	r3, #1
 8005f66:	e007      	b.n	8005f78 <LPS22HB_FIFO_Set_Interrupt+0x6e>
      }
      break;
    default:
      return COMPONENT_ERROR;
 8005f68:	2301      	movs	r3, #1
 8005f6a:	e005      	b.n	8005f78 <LPS22HB_FIFO_Set_Interrupt+0x6e>
      break;
 8005f6c:	46c0      	nop			; (mov r8, r8)
 8005f6e:	e002      	b.n	8005f76 <LPS22HB_FIFO_Set_Interrupt+0x6c>
      break;
 8005f70:	46c0      	nop			; (mov r8, r8)
 8005f72:	e000      	b.n	8005f76 <LPS22HB_FIFO_Set_Interrupt+0x6c>
      break;
 8005f74:	46c0      	nop			; (mov r8, r8)
  }

  return COMPONENT_OK;
 8005f76:	2300      	movs	r3, #0
}
 8005f78:	0018      	movs	r0, r3
 8005f7a:	46bd      	mov	sp, r7
 8005f7c:	b002      	add	sp, #8
 8005f7e:	bd80      	pop	{r7, pc}

08005f80 <LPS22HB_FIFO_Reset_Interrupt>:
 * @param interrupt The FIFO interrupt to be reset; values: 0 = FTH; 1 = FULL; 2 = OVR
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Reset_Interrupt( DrvContextTypeDef *handle, uint8_t interrupt )
{
 8005f80:	b580      	push	{r7, lr}
 8005f82:	b082      	sub	sp, #8
 8005f84:	af00      	add	r7, sp, #0
 8005f86:	6078      	str	r0, [r7, #4]
 8005f88:	000a      	movs	r2, r1
 8005f8a:	1cfb      	adds	r3, r7, #3
 8005f8c:	701a      	strb	r2, [r3, #0]

  switch( interrupt )
 8005f8e:	1cfb      	adds	r3, r7, #3
 8005f90:	781b      	ldrb	r3, [r3, #0]
 8005f92:	2b02      	cmp	r3, #2
 8005f94:	d019      	beq.n	8005fca <LPS22HB_FIFO_Reset_Interrupt+0x4a>
 8005f96:	dc22      	bgt.n	8005fde <LPS22HB_FIFO_Reset_Interrupt+0x5e>
 8005f98:	2b00      	cmp	r3, #0
 8005f9a:	d002      	beq.n	8005fa2 <LPS22HB_FIFO_Reset_Interrupt+0x22>
 8005f9c:	2b01      	cmp	r3, #1
 8005f9e:	d00a      	beq.n	8005fb6 <LPS22HB_FIFO_Reset_Interrupt+0x36>
 8005fa0:	e01d      	b.n	8005fde <LPS22HB_FIFO_Reset_Interrupt+0x5e>
  {
    case 0:
      if ( LPS22HB_Set_FIFO_FTH_Interrupt( handle, LPS22HB_DISABLE ) == LPS22HB_ERROR )
 8005fa2:	687b      	ldr	r3, [r7, #4]
 8005fa4:	2100      	movs	r1, #0
 8005fa6:	0018      	movs	r0, r3
 8005fa8:	f7fe fea1 	bl	8004cee <LPS22HB_Set_FIFO_FTH_Interrupt>
 8005fac:	0003      	movs	r3, r0
 8005fae:	2b01      	cmp	r3, #1
 8005fb0:	d117      	bne.n	8005fe2 <LPS22HB_FIFO_Reset_Interrupt+0x62>
      {
        return COMPONENT_ERROR;
 8005fb2:	2301      	movs	r3, #1
 8005fb4:	e01b      	b.n	8005fee <LPS22HB_FIFO_Reset_Interrupt+0x6e>
      }
      break;
    case 1:
      if ( LPS22HB_Set_FIFO_FULL_Interrupt( handle, LPS22HB_DISABLE ) == LPS22HB_ERROR )
 8005fb6:	687b      	ldr	r3, [r7, #4]
 8005fb8:	2100      	movs	r1, #0
 8005fba:	0018      	movs	r0, r3
 8005fbc:	f7fe fecc 	bl	8004d58 <LPS22HB_Set_FIFO_FULL_Interrupt>
 8005fc0:	0003      	movs	r3, r0
 8005fc2:	2b01      	cmp	r3, #1
 8005fc4:	d10f      	bne.n	8005fe6 <LPS22HB_FIFO_Reset_Interrupt+0x66>
      {
        return COMPONENT_ERROR;
 8005fc6:	2301      	movs	r3, #1
 8005fc8:	e011      	b.n	8005fee <LPS22HB_FIFO_Reset_Interrupt+0x6e>
      }
      break;
    case 2:
      if ( LPS22HB_Set_FIFO_OVR_Interrupt( handle, LPS22HB_DISABLE ) == LPS22HB_ERROR )
 8005fca:	687b      	ldr	r3, [r7, #4]
 8005fcc:	2100      	movs	r1, #0
 8005fce:	0018      	movs	r0, r3
 8005fd0:	f7fe fe58 	bl	8004c84 <LPS22HB_Set_FIFO_OVR_Interrupt>
 8005fd4:	0003      	movs	r3, r0
 8005fd6:	2b01      	cmp	r3, #1
 8005fd8:	d107      	bne.n	8005fea <LPS22HB_FIFO_Reset_Interrupt+0x6a>
      {
        return COMPONENT_ERROR;
 8005fda:	2301      	movs	r3, #1
 8005fdc:	e007      	b.n	8005fee <LPS22HB_FIFO_Reset_Interrupt+0x6e>
      }
      break;
    default:
      return COMPONENT_ERROR;
 8005fde:	2301      	movs	r3, #1
 8005fe0:	e005      	b.n	8005fee <LPS22HB_FIFO_Reset_Interrupt+0x6e>
      break;
 8005fe2:	46c0      	nop			; (mov r8, r8)
 8005fe4:	e002      	b.n	8005fec <LPS22HB_FIFO_Reset_Interrupt+0x6c>
      break;
 8005fe6:	46c0      	nop			; (mov r8, r8)
 8005fe8:	e000      	b.n	8005fec <LPS22HB_FIFO_Reset_Interrupt+0x6c>
      break;
 8005fea:	46c0      	nop			; (mov r8, r8)
  }

  return COMPONENT_OK;
 8005fec:	2300      	movs	r3, #0
}
 8005fee:	0018      	movs	r0, r3
 8005ff0:	46bd      	mov	sp, r7
 8005ff2:	b002      	add	sp, #8
 8005ff4:	bd80      	pop	{r7, pc}
	...

08005ff8 <SX1276BoardInit>:

/*
 * Radio driver functions implementation
 */
void SX1276BoardInit( LoRaBoardCallback_t *callbacks )
{
 8005ff8:	b580      	push	{r7, lr}
 8005ffa:	b082      	sub	sp, #8
 8005ffc:	af00      	add	r7, sp, #0
 8005ffe:	6078      	str	r0, [r7, #4]
    LoRaBoardCallbacks =callbacks;
 8006000:	4b03      	ldr	r3, [pc, #12]	; (8006010 <SX1276BoardInit+0x18>)
 8006002:	687a      	ldr	r2, [r7, #4]
 8006004:	601a      	str	r2, [r3, #0]
}
 8006006:	46c0      	nop			; (mov r8, r8)
 8006008:	46bd      	mov	sp, r7
 800600a:	b002      	add	sp, #8
 800600c:	bd80      	pop	{r7, pc}
 800600e:	46c0      	nop			; (mov r8, r8)
 8006010:	20000454 	.word	0x20000454

08006014 <SX1276Init>:

uint32_t SX1276Init( RadioEvents_t *events )
{
 8006014:	b590      	push	{r4, r7, lr}
 8006016:	b085      	sub	sp, #20
 8006018:	af00      	add	r7, sp, #0
 800601a:	6078      	str	r0, [r7, #4]
    uint8_t i;

    RadioEvents = events;
 800601c:	4b33      	ldr	r3, [pc, #204]	; (80060ec <SX1276Init+0xd8>)
 800601e:	687a      	ldr	r2, [r7, #4]
 8006020:	601a      	str	r2, [r3, #0]

    // Initialize driver timeout timers
    TimerInit( &TxTimeoutTimer, SX1276OnTimeoutIrq );
 8006022:	4a33      	ldr	r2, [pc, #204]	; (80060f0 <SX1276Init+0xdc>)
 8006024:	4b33      	ldr	r3, [pc, #204]	; (80060f4 <SX1276Init+0xe0>)
 8006026:	0011      	movs	r1, r2
 8006028:	0018      	movs	r0, r3
 800602a:	f014 ff0d 	bl	801ae48 <TimerInit>
    TimerInit( &RxTimeoutTimer, SX1276OnTimeoutIrq );
 800602e:	4a30      	ldr	r2, [pc, #192]	; (80060f0 <SX1276Init+0xdc>)
 8006030:	4b31      	ldr	r3, [pc, #196]	; (80060f8 <SX1276Init+0xe4>)
 8006032:	0011      	movs	r1, r2
 8006034:	0018      	movs	r0, r3
 8006036:	f014 ff07 	bl	801ae48 <TimerInit>
    TimerInit( &RxTimeoutSyncWord, SX1276OnTimeoutIrq );
 800603a:	4a2d      	ldr	r2, [pc, #180]	; (80060f0 <SX1276Init+0xdc>)
 800603c:	4b2f      	ldr	r3, [pc, #188]	; (80060fc <SX1276Init+0xe8>)
 800603e:	0011      	movs	r1, r2
 8006040:	0018      	movs	r0, r3
 8006042:	f014 ff01 	bl	801ae48 <TimerInit>

    LoRaBoardCallbacks->SX1276BoardSetXO( SET );
 8006046:	4b2e      	ldr	r3, [pc, #184]	; (8006100 <SX1276Init+0xec>)
 8006048:	681b      	ldr	r3, [r3, #0]
 800604a:	681b      	ldr	r3, [r3, #0]
 800604c:	2001      	movs	r0, #1
 800604e:	4798      	blx	r3

    SX1276Reset( );
 8006050:	f001 fc30 	bl	80078b4 <SX1276Reset>

    RxChainCalibration( );
 8006054:	f000 f93c 	bl	80062d0 <RxChainCalibration>

    SX1276SetOpMode( RF_OPMODE_SLEEP );
 8006058:	2000      	movs	r0, #0
 800605a:	f001 fc5f 	bl	800791c <SX1276SetOpMode>

    LoRaBoardCallbacks->SX1276BoardIoIrqInit( DioIrq );
 800605e:	4b28      	ldr	r3, [pc, #160]	; (8006100 <SX1276Init+0xec>)
 8006060:	681b      	ldr	r3, [r3, #0]
 8006062:	689b      	ldr	r3, [r3, #8]
 8006064:	4a27      	ldr	r2, [pc, #156]	; (8006104 <SX1276Init+0xf0>)
 8006066:	0010      	movs	r0, r2
 8006068:	4798      	blx	r3

    for( i = 0; i < sizeof( RadioRegsInit ) / sizeof( RadioRegisters_t ); i++ )
 800606a:	230f      	movs	r3, #15
 800606c:	18fb      	adds	r3, r7, r3
 800606e:	2200      	movs	r2, #0
 8006070:	701a      	strb	r2, [r3, #0]
 8006072:	e025      	b.n	80060c0 <SX1276Init+0xac>
    {
        SX1276SetModem( RadioRegsInit[i].Modem );
 8006074:	240f      	movs	r4, #15
 8006076:	193b      	adds	r3, r7, r4
 8006078:	781a      	ldrb	r2, [r3, #0]
 800607a:	4923      	ldr	r1, [pc, #140]	; (8006108 <SX1276Init+0xf4>)
 800607c:	0013      	movs	r3, r2
 800607e:	005b      	lsls	r3, r3, #1
 8006080:	189b      	adds	r3, r3, r2
 8006082:	5c5b      	ldrb	r3, [r3, r1]
 8006084:	0018      	movs	r0, r3
 8006086:	f001 fc99 	bl	80079bc <SX1276SetModem>
        SX1276Write( RadioRegsInit[i].Addr, RadioRegsInit[i].Value );
 800608a:	193b      	adds	r3, r7, r4
 800608c:	781a      	ldrb	r2, [r3, #0]
 800608e:	491e      	ldr	r1, [pc, #120]	; (8006108 <SX1276Init+0xf4>)
 8006090:	0013      	movs	r3, r2
 8006092:	005b      	lsls	r3, r3, #1
 8006094:	189b      	adds	r3, r3, r2
 8006096:	18cb      	adds	r3, r1, r3
 8006098:	3301      	adds	r3, #1
 800609a:	781b      	ldrb	r3, [r3, #0]
 800609c:	b298      	uxth	r0, r3
 800609e:	193b      	adds	r3, r7, r4
 80060a0:	781a      	ldrb	r2, [r3, #0]
 80060a2:	4919      	ldr	r1, [pc, #100]	; (8006108 <SX1276Init+0xf4>)
 80060a4:	0013      	movs	r3, r2
 80060a6:	005b      	lsls	r3, r3, #1
 80060a8:	189b      	adds	r3, r3, r2
 80060aa:	18cb      	adds	r3, r1, r3
 80060ac:	3302      	adds	r3, #2
 80060ae:	781b      	ldrb	r3, [r3, #0]
 80060b0:	0019      	movs	r1, r3
 80060b2:	f001 fcdd 	bl	8007a70 <SX1276Write>
    for( i = 0; i < sizeof( RadioRegsInit ) / sizeof( RadioRegisters_t ); i++ )
 80060b6:	193b      	adds	r3, r7, r4
 80060b8:	781a      	ldrb	r2, [r3, #0]
 80060ba:	193b      	adds	r3, r7, r4
 80060bc:	3201      	adds	r2, #1
 80060be:	701a      	strb	r2, [r3, #0]
 80060c0:	230f      	movs	r3, #15
 80060c2:	18fb      	adds	r3, r7, r3
 80060c4:	781b      	ldrb	r3, [r3, #0]
 80060c6:	2b0f      	cmp	r3, #15
 80060c8:	d9d4      	bls.n	8006074 <SX1276Init+0x60>
    }

    SX1276SetModem( MODEM_FSK );
 80060ca:	2000      	movs	r0, #0
 80060cc:	f001 fc76 	bl	80079bc <SX1276SetModem>

    SX1276.Settings.State = RF_IDLE;
 80060d0:	4b0e      	ldr	r3, [pc, #56]	; (800610c <SX1276Init+0xf8>)
 80060d2:	2200      	movs	r2, #0
 80060d4:	711a      	strb	r2, [r3, #4]

    return ( uint32_t )LoRaBoardCallbacks->SX1276BoardGetWakeTime( ) + RADIO_WAKEUP_TIME;// BOARD_WAKEUP_TIME;
 80060d6:	4b0a      	ldr	r3, [pc, #40]	; (8006100 <SX1276Init+0xec>)
 80060d8:	681b      	ldr	r3, [r3, #0]
 80060da:	685b      	ldr	r3, [r3, #4]
 80060dc:	4798      	blx	r3
 80060de:	0003      	movs	r3, r0
 80060e0:	3302      	adds	r3, #2
}
 80060e2:	0018      	movs	r0, r3
 80060e4:	46bd      	mov	sp, r7
 80060e6:	b005      	add	sp, #20
 80060e8:	bd90      	pop	{r4, r7, pc}
 80060ea:	46c0      	nop			; (mov r8, r8)
 80060ec:	20000350 	.word	0x20000350
 80060f0:	08007cd9 	.word	0x08007cd9
 80060f4:	2000172c 	.word	0x2000172c
 80060f8:	200017c4 	.word	0x200017c4
 80060fc:	20001744 	.word	0x20001744
 8006100:	20000454 	.word	0x20000454
 8006104:	2000016c 	.word	0x2000016c
 8006108:	0801ed00 	.word	0x0801ed00
 800610c:	2000175c 	.word	0x2000175c

08006110 <SX1276GetStatus>:

RadioState_t SX1276GetStatus( void )
{
 8006110:	b580      	push	{r7, lr}
 8006112:	af00      	add	r7, sp, #0
    return SX1276.Settings.State;
 8006114:	4b02      	ldr	r3, [pc, #8]	; (8006120 <SX1276GetStatus+0x10>)
 8006116:	791b      	ldrb	r3, [r3, #4]
}
 8006118:	0018      	movs	r0, r3
 800611a:	46bd      	mov	sp, r7
 800611c:	bd80      	pop	{r7, pc}
 800611e:	46c0      	nop			; (mov r8, r8)
 8006120:	2000175c 	.word	0x2000175c

08006124 <SX1276SetChannel>:

void SX1276SetChannel( uint32_t freq )
{
 8006124:	b590      	push	{r4, r7, lr}
 8006126:	b087      	sub	sp, #28
 8006128:	af00      	add	r7, sp, #0
 800612a:	6078      	str	r0, [r7, #4]
    uint32_t channel;

    SX1276.Settings.Channel = freq;
 800612c:	4b1d      	ldr	r3, [pc, #116]	; (80061a4 <SX1276SetChannel+0x80>)
 800612e:	687a      	ldr	r2, [r7, #4]
 8006130:	609a      	str	r2, [r3, #8]

    SX_FREQ_TO_CHANNEL( channel, freq );
 8006132:	687b      	ldr	r3, [r7, #4]
 8006134:	491c      	ldr	r1, [pc, #112]	; (80061a8 <SX1276SetChannel+0x84>)
 8006136:	0018      	movs	r0, r3
 8006138:	f7f9 fff0 	bl	800011c <__udivsi3>
 800613c:	0003      	movs	r3, r0
 800613e:	617b      	str	r3, [r7, #20]
 8006140:	6979      	ldr	r1, [r7, #20]
 8006142:	000b      	movs	r3, r1
 8006144:	015b      	lsls	r3, r3, #5
 8006146:	1a5b      	subs	r3, r3, r1
 8006148:	019a      	lsls	r2, r3, #6
 800614a:	1ad2      	subs	r2, r2, r3
 800614c:	00d2      	lsls	r2, r2, #3
 800614e:	1853      	adds	r3, r2, r1
 8006150:	687a      	ldr	r2, [r7, #4]
 8006152:	1ad3      	subs	r3, r2, r3
 8006154:	613b      	str	r3, [r7, #16]
 8006156:	697b      	ldr	r3, [r7, #20]
 8006158:	021c      	lsls	r4, r3, #8
 800615a:	693b      	ldr	r3, [r7, #16]
 800615c:	021b      	lsls	r3, r3, #8
 800615e:	4a13      	ldr	r2, [pc, #76]	; (80061ac <SX1276SetChannel+0x88>)
 8006160:	4694      	mov	ip, r2
 8006162:	4463      	add	r3, ip
 8006164:	4910      	ldr	r1, [pc, #64]	; (80061a8 <SX1276SetChannel+0x84>)
 8006166:	0018      	movs	r0, r3
 8006168:	f7f9 ffd8 	bl	800011c <__udivsi3>
 800616c:	0003      	movs	r3, r0
 800616e:	18e3      	adds	r3, r4, r3
 8006170:	60fb      	str	r3, [r7, #12]

    SX1276Write( REG_FRFMSB, ( uint8_t )( ( channel >> 16 ) & 0xFF ) );
 8006172:	68fb      	ldr	r3, [r7, #12]
 8006174:	0c1b      	lsrs	r3, r3, #16
 8006176:	b2db      	uxtb	r3, r3
 8006178:	0019      	movs	r1, r3
 800617a:	2006      	movs	r0, #6
 800617c:	f001 fc78 	bl	8007a70 <SX1276Write>
    SX1276Write( REG_FRFMID, ( uint8_t )( ( channel >> 8 ) & 0xFF ) );
 8006180:	68fb      	ldr	r3, [r7, #12]
 8006182:	0a1b      	lsrs	r3, r3, #8
 8006184:	b2db      	uxtb	r3, r3
 8006186:	0019      	movs	r1, r3
 8006188:	2007      	movs	r0, #7
 800618a:	f001 fc71 	bl	8007a70 <SX1276Write>
    SX1276Write( REG_FRFLSB, ( uint8_t )( channel & 0xFF ) );
 800618e:	68fb      	ldr	r3, [r7, #12]
 8006190:	b2db      	uxtb	r3, r3
 8006192:	0019      	movs	r1, r3
 8006194:	2008      	movs	r0, #8
 8006196:	f001 fc6b 	bl	8007a70 <SX1276Write>
}
 800619a:	46c0      	nop			; (mov r8, r8)
 800619c:	46bd      	mov	sp, r7
 800619e:	b007      	add	sp, #28
 80061a0:	bd90      	pop	{r4, r7, pc}
 80061a2:	46c0      	nop			; (mov r8, r8)
 80061a4:	2000175c 	.word	0x2000175c
 80061a8:	00003d09 	.word	0x00003d09
 80061ac:	00001e84 	.word	0x00001e84

080061b0 <SX1276IsChannelFree>:

bool SX1276IsChannelFree( RadioModems_t modem, uint32_t freq, int16_t rssiThresh, uint32_t maxCarrierSenseTime )
{
 80061b0:	b5b0      	push	{r4, r5, r7, lr}
 80061b2:	b086      	sub	sp, #24
 80061b4:	af00      	add	r7, sp, #0
 80061b6:	60b9      	str	r1, [r7, #8]
 80061b8:	0011      	movs	r1, r2
 80061ba:	607b      	str	r3, [r7, #4]
 80061bc:	230f      	movs	r3, #15
 80061be:	18fb      	adds	r3, r7, r3
 80061c0:	1c02      	adds	r2, r0, #0
 80061c2:	701a      	strb	r2, [r3, #0]
 80061c4:	230c      	movs	r3, #12
 80061c6:	18fb      	adds	r3, r7, r3
 80061c8:	1c0a      	adds	r2, r1, #0
 80061ca:	801a      	strh	r2, [r3, #0]
    bool status = true;
 80061cc:	2317      	movs	r3, #23
 80061ce:	18fb      	adds	r3, r7, r3
 80061d0:	2201      	movs	r2, #1
 80061d2:	701a      	strb	r2, [r3, #0]
    int16_t rssi = 0;
 80061d4:	2314      	movs	r3, #20
 80061d6:	18fb      	adds	r3, r7, r3
 80061d8:	2200      	movs	r2, #0
 80061da:	801a      	strh	r2, [r3, #0]
    uint32_t carrierSenseTime = 0;
 80061dc:	2300      	movs	r3, #0
 80061de:	613b      	str	r3, [r7, #16]

    if( SX1276GetStatus( ) != RF_IDLE )
 80061e0:	f7ff ff96 	bl	8006110 <SX1276GetStatus>
 80061e4:	1e03      	subs	r3, r0, #0
 80061e6:	d001      	beq.n	80061ec <SX1276IsChannelFree+0x3c>
    {
        return false;
 80061e8:	2300      	movs	r3, #0
 80061ea:	e039      	b.n	8006260 <SX1276IsChannelFree+0xb0>
    }

    SX1276SetModem( modem );
 80061ec:	230f      	movs	r3, #15
 80061ee:	18fb      	adds	r3, r7, r3
 80061f0:	781b      	ldrb	r3, [r3, #0]
 80061f2:	0018      	movs	r0, r3
 80061f4:	f001 fbe2 	bl	80079bc <SX1276SetModem>

    SX1276SetChannel( freq );
 80061f8:	68bb      	ldr	r3, [r7, #8]
 80061fa:	0018      	movs	r0, r3
 80061fc:	f7ff ff92 	bl	8006124 <SX1276SetChannel>

    SX1276SetOpMode( RF_OPMODE_RECEIVER );
 8006200:	2005      	movs	r0, #5
 8006202:	f001 fb8b 	bl	800791c <SX1276SetOpMode>

    DelayMs( 1 );
 8006206:	2001      	movs	r0, #1
 8006208:	f016 fc46 	bl	801ca98 <HAL_Delay>

    carrierSenseTime = TimerGetCurrentTime( );
 800620c:	f014 ffb9 	bl	801b182 <TimerGetCurrentTime>
 8006210:	0003      	movs	r3, r0
 8006212:	613b      	str	r3, [r7, #16]

    // Perform carrier sense for maxCarrierSenseTime
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 8006214:	e017      	b.n	8006246 <SX1276IsChannelFree+0x96>
    {
        rssi = SX1276ReadRssi( modem );
 8006216:	2514      	movs	r5, #20
 8006218:	197c      	adds	r4, r7, r5
 800621a:	230f      	movs	r3, #15
 800621c:	18fb      	adds	r3, r7, r3
 800621e:	781b      	ldrb	r3, [r3, #0]
 8006220:	0018      	movs	r0, r3
 8006222:	f001 fafb 	bl	800781c <SX1276ReadRssi>
 8006226:	0003      	movs	r3, r0
 8006228:	8023      	strh	r3, [r4, #0]

        if( rssi > rssiThresh )
 800622a:	197a      	adds	r2, r7, r5
 800622c:	230c      	movs	r3, #12
 800622e:	18fb      	adds	r3, r7, r3
 8006230:	2100      	movs	r1, #0
 8006232:	5e52      	ldrsh	r2, [r2, r1]
 8006234:	2100      	movs	r1, #0
 8006236:	5e5b      	ldrsh	r3, [r3, r1]
 8006238:	429a      	cmp	r2, r3
 800623a:	dd04      	ble.n	8006246 <SX1276IsChannelFree+0x96>
        {
            status = false;
 800623c:	2317      	movs	r3, #23
 800623e:	18fb      	adds	r3, r7, r3
 8006240:	2200      	movs	r2, #0
 8006242:	701a      	strb	r2, [r3, #0]
            break;
 8006244:	e007      	b.n	8006256 <SX1276IsChannelFree+0xa6>
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 8006246:	693b      	ldr	r3, [r7, #16]
 8006248:	0018      	movs	r0, r3
 800624a:	f014 ffaa 	bl	801b1a2 <TimerGetElapsedTime>
 800624e:	0002      	movs	r2, r0
 8006250:	687b      	ldr	r3, [r7, #4]
 8006252:	4293      	cmp	r3, r2
 8006254:	d8df      	bhi.n	8006216 <SX1276IsChannelFree+0x66>
        }
    }
    SX1276SetSleep( );
 8006256:	f001 f803 	bl	8007260 <SX1276SetSleep>
    return status;
 800625a:	2317      	movs	r3, #23
 800625c:	18fb      	adds	r3, r7, r3
 800625e:	781b      	ldrb	r3, [r3, #0]
}
 8006260:	0018      	movs	r0, r3
 8006262:	46bd      	mov	sp, r7
 8006264:	b006      	add	sp, #24
 8006266:	bdb0      	pop	{r4, r5, r7, pc}

08006268 <SX1276Random>:

uint32_t SX1276Random( void )
{
 8006268:	b580      	push	{r7, lr}
 800626a:	b082      	sub	sp, #8
 800626c:	af00      	add	r7, sp, #0
    uint8_t i;
    uint32_t rnd = 0;
 800626e:	2300      	movs	r3, #0
 8006270:	603b      	str	r3, [r7, #0]

    /*
     * Radio setup for random number generation
     */
    // Set LoRa modem ON
    SX1276SetModem( MODEM_LORA );
 8006272:	2001      	movs	r0, #1
 8006274:	f001 fba2 	bl	80079bc <SX1276SetModem>

    // Disable LoRa modem interrupts
    SX1276Write( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
 8006278:	21ff      	movs	r1, #255	; 0xff
 800627a:	2011      	movs	r0, #17
 800627c:	f001 fbf8 	bl	8007a70 <SX1276Write>
                  RFLR_IRQFLAGS_CADDONE |
                  RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                  RFLR_IRQFLAGS_CADDETECTED );

    // Set radio in continuous reception
    SX1276SetOpMode( RF_OPMODE_RECEIVER );
 8006280:	2005      	movs	r0, #5
 8006282:	f001 fb4b 	bl	800791c <SX1276SetOpMode>

    for( i = 0; i < 32; i++ )
 8006286:	1dfb      	adds	r3, r7, #7
 8006288:	2200      	movs	r2, #0
 800628a:	701a      	strb	r2, [r3, #0]
 800628c:	e015      	b.n	80062ba <SX1276Random+0x52>
    {
        DelayMs( 1 );
 800628e:	2001      	movs	r0, #1
 8006290:	f016 fc02 	bl	801ca98 <HAL_Delay>
        // Unfiltered RSSI value reading. Only takes the LSB value
        rnd |= ( ( uint32_t )SX1276Read( REG_LR_RSSIWIDEBAND ) & 0x01 ) << i;
 8006294:	202c      	movs	r0, #44	; 0x2c
 8006296:	f001 fbff 	bl	8007a98 <SX1276Read>
 800629a:	0003      	movs	r3, r0
 800629c:	001a      	movs	r2, r3
 800629e:	2301      	movs	r3, #1
 80062a0:	401a      	ands	r2, r3
 80062a2:	1dfb      	adds	r3, r7, #7
 80062a4:	781b      	ldrb	r3, [r3, #0]
 80062a6:	409a      	lsls	r2, r3
 80062a8:	0013      	movs	r3, r2
 80062aa:	683a      	ldr	r2, [r7, #0]
 80062ac:	4313      	orrs	r3, r2
 80062ae:	603b      	str	r3, [r7, #0]
    for( i = 0; i < 32; i++ )
 80062b0:	1dfb      	adds	r3, r7, #7
 80062b2:	781a      	ldrb	r2, [r3, #0]
 80062b4:	1dfb      	adds	r3, r7, #7
 80062b6:	3201      	adds	r2, #1
 80062b8:	701a      	strb	r2, [r3, #0]
 80062ba:	1dfb      	adds	r3, r7, #7
 80062bc:	781b      	ldrb	r3, [r3, #0]
 80062be:	2b1f      	cmp	r3, #31
 80062c0:	d9e5      	bls.n	800628e <SX1276Random+0x26>
    }

    SX1276SetSleep( );
 80062c2:	f000 ffcd 	bl	8007260 <SX1276SetSleep>

    return rnd;
 80062c6:	683b      	ldr	r3, [r7, #0]
}
 80062c8:	0018      	movs	r0, r3
 80062ca:	46bd      	mov	sp, r7
 80062cc:	b002      	add	sp, #8
 80062ce:	bd80      	pop	{r7, pc}

080062d0 <RxChainCalibration>:
 * Performs the Rx chain calibration for LF and HF bands
 * \remark Must be called just after the reset so all registers are at their
 *         default values
 */
void RxChainCalibration( void )
{
 80062d0:	b590      	push	{r4, r7, lr}
 80062d2:	b087      	sub	sp, #28
 80062d4:	af00      	add	r7, sp, #0
    uint8_t regPaConfigInitVal;
    uint32_t initialFreq;
    uint32_t channel;

    // Save context
    regPaConfigInitVal = SX1276Read( REG_PACONFIG );
 80062d6:	2317      	movs	r3, #23
 80062d8:	18fc      	adds	r4, r7, r3
 80062da:	2009      	movs	r0, #9
 80062dc:	f001 fbdc 	bl	8007a98 <SX1276Read>
 80062e0:	0003      	movs	r3, r0
 80062e2:	7023      	strb	r3, [r4, #0]

    channel = ( ( ( uint32_t )SX1276Read( REG_FRFMSB ) << 16 ) |
 80062e4:	2006      	movs	r0, #6
 80062e6:	f001 fbd7 	bl	8007a98 <SX1276Read>
 80062ea:	0003      	movs	r3, r0
 80062ec:	041c      	lsls	r4, r3, #16
                ( ( uint32_t )SX1276Read( REG_FRFMID ) << 8 ) |
 80062ee:	2007      	movs	r0, #7
 80062f0:	f001 fbd2 	bl	8007a98 <SX1276Read>
 80062f4:	0003      	movs	r3, r0
 80062f6:	021b      	lsls	r3, r3, #8
    channel = ( ( ( uint32_t )SX1276Read( REG_FRFMSB ) << 16 ) |
 80062f8:	431c      	orrs	r4, r3
                ( ( uint32_t )SX1276Read( REG_FRFLSB ) ) );
 80062fa:	2008      	movs	r0, #8
 80062fc:	f001 fbcc 	bl	8007a98 <SX1276Read>
 8006300:	0003      	movs	r3, r0
    channel = ( ( ( uint32_t )SX1276Read( REG_FRFMSB ) << 16 ) |
 8006302:	4323      	orrs	r3, r4
 8006304:	613b      	str	r3, [r7, #16]

    SX_CHANNEL_TO_FREQ(channel, initialFreq);
 8006306:	693b      	ldr	r3, [r7, #16]
 8006308:	0a1b      	lsrs	r3, r3, #8
 800630a:	60fb      	str	r3, [r7, #12]
 800630c:	68fb      	ldr	r3, [r7, #12]
 800630e:	021b      	lsls	r3, r3, #8
 8006310:	693a      	ldr	r2, [r7, #16]
 8006312:	1ad3      	subs	r3, r2, r3
 8006314:	60bb      	str	r3, [r7, #8]
 8006316:	68f9      	ldr	r1, [r7, #12]
 8006318:	000b      	movs	r3, r1
 800631a:	015b      	lsls	r3, r3, #5
 800631c:	1a5b      	subs	r3, r3, r1
 800631e:	019a      	lsls	r2, r3, #6
 8006320:	1ad2      	subs	r2, r2, r3
 8006322:	00d2      	lsls	r2, r2, #3
 8006324:	1850      	adds	r0, r2, r1
 8006326:	68b9      	ldr	r1, [r7, #8]
 8006328:	000b      	movs	r3, r1
 800632a:	015b      	lsls	r3, r3, #5
 800632c:	1a5b      	subs	r3, r3, r1
 800632e:	019a      	lsls	r2, r3, #6
 8006330:	1ad2      	subs	r2, r2, r3
 8006332:	00d2      	lsls	r2, r2, #3
 8006334:	1853      	adds	r3, r2, r1
 8006336:	3380      	adds	r3, #128	; 0x80
 8006338:	0a1b      	lsrs	r3, r3, #8
 800633a:	18c3      	adds	r3, r0, r3
 800633c:	607b      	str	r3, [r7, #4]

    // Cut the PA just in case, RFO output, power = -1 dBm
    SX1276Write( REG_PACONFIG, 0x00 );
 800633e:	2100      	movs	r1, #0
 8006340:	2009      	movs	r0, #9
 8006342:	f001 fb95 	bl	8007a70 <SX1276Write>

    // Launch Rx chain calibration for LF band
    SX1276Write( REG_IMAGECAL, ( SX1276Read( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_MASK ) | RF_IMAGECAL_IMAGECAL_START );
 8006346:	203b      	movs	r0, #59	; 0x3b
 8006348:	f001 fba6 	bl	8007a98 <SX1276Read>
 800634c:	0003      	movs	r3, r0
 800634e:	001a      	movs	r2, r3
 8006350:	2340      	movs	r3, #64	; 0x40
 8006352:	4313      	orrs	r3, r2
 8006354:	b2db      	uxtb	r3, r3
 8006356:	0019      	movs	r1, r3
 8006358:	203b      	movs	r0, #59	; 0x3b
 800635a:	f001 fb89 	bl	8007a70 <SX1276Write>
    while( ( SX1276Read( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_RUNNING ) == RF_IMAGECAL_IMAGECAL_RUNNING )
 800635e:	46c0      	nop			; (mov r8, r8)
 8006360:	203b      	movs	r0, #59	; 0x3b
 8006362:	f001 fb99 	bl	8007a98 <SX1276Read>
 8006366:	0003      	movs	r3, r0
 8006368:	001a      	movs	r2, r3
 800636a:	2320      	movs	r3, #32
 800636c:	4013      	ands	r3, r2
 800636e:	2b20      	cmp	r3, #32
 8006370:	d0f6      	beq.n	8006360 <RxChainCalibration+0x90>
    {
    }

    // Sets a Frequency in HF band
    SX1276SetChannel( 868000000 );
 8006372:	4b14      	ldr	r3, [pc, #80]	; (80063c4 <RxChainCalibration+0xf4>)
 8006374:	0018      	movs	r0, r3
 8006376:	f7ff fed5 	bl	8006124 <SX1276SetChannel>

    // Launch Rx chain calibration for HF band
    SX1276Write( REG_IMAGECAL, ( SX1276Read( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_MASK ) | RF_IMAGECAL_IMAGECAL_START );
 800637a:	203b      	movs	r0, #59	; 0x3b
 800637c:	f001 fb8c 	bl	8007a98 <SX1276Read>
 8006380:	0003      	movs	r3, r0
 8006382:	001a      	movs	r2, r3
 8006384:	2340      	movs	r3, #64	; 0x40
 8006386:	4313      	orrs	r3, r2
 8006388:	b2db      	uxtb	r3, r3
 800638a:	0019      	movs	r1, r3
 800638c:	203b      	movs	r0, #59	; 0x3b
 800638e:	f001 fb6f 	bl	8007a70 <SX1276Write>
    while( ( SX1276Read( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_RUNNING ) == RF_IMAGECAL_IMAGECAL_RUNNING )
 8006392:	46c0      	nop			; (mov r8, r8)
 8006394:	203b      	movs	r0, #59	; 0x3b
 8006396:	f001 fb7f 	bl	8007a98 <SX1276Read>
 800639a:	0003      	movs	r3, r0
 800639c:	001a      	movs	r2, r3
 800639e:	2320      	movs	r3, #32
 80063a0:	4013      	ands	r3, r2
 80063a2:	2b20      	cmp	r3, #32
 80063a4:	d0f6      	beq.n	8006394 <RxChainCalibration+0xc4>
    {
    }

    // Restore context
    SX1276Write( REG_PACONFIG, regPaConfigInitVal );
 80063a6:	2317      	movs	r3, #23
 80063a8:	18fb      	adds	r3, r7, r3
 80063aa:	781b      	ldrb	r3, [r3, #0]
 80063ac:	0019      	movs	r1, r3
 80063ae:	2009      	movs	r0, #9
 80063b0:	f001 fb5e 	bl	8007a70 <SX1276Write>
    SX1276SetChannel( initialFreq );
 80063b4:	687b      	ldr	r3, [r7, #4]
 80063b6:	0018      	movs	r0, r3
 80063b8:	f7ff feb4 	bl	8006124 <SX1276SetChannel>
}
 80063bc:	46c0      	nop			; (mov r8, r8)
 80063be:	46bd      	mov	sp, r7
 80063c0:	b007      	add	sp, #28
 80063c2:	bd90      	pop	{r4, r7, pc}
 80063c4:	33bca100 	.word	0x33bca100

080063c8 <GetFskBandwidthRegValue>:
 *
 * \param [IN] bandwidth Bandwidth value in Hz
 * \retval regValue Bandwidth register value.
 */
static uint8_t GetFskBandwidthRegValue( uint32_t bandwidth )
{
 80063c8:	b580      	push	{r7, lr}
 80063ca:	b084      	sub	sp, #16
 80063cc:	af00      	add	r7, sp, #0
 80063ce:	6078      	str	r0, [r7, #4]
    uint8_t i;

    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ) - 1; i++ )
 80063d0:	230f      	movs	r3, #15
 80063d2:	18fb      	adds	r3, r7, r3
 80063d4:	2200      	movs	r2, #0
 80063d6:	701a      	strb	r2, [r3, #0]
 80063d8:	e01f      	b.n	800641a <GetFskBandwidthRegValue+0x52>
    {
        if( ( bandwidth >= FskBandwidths[i].bandwidth ) && ( bandwidth < FskBandwidths[i + 1].bandwidth ) )
 80063da:	210f      	movs	r1, #15
 80063dc:	187b      	adds	r3, r7, r1
 80063de:	781a      	ldrb	r2, [r3, #0]
 80063e0:	4b13      	ldr	r3, [pc, #76]	; (8006430 <GetFskBandwidthRegValue+0x68>)
 80063e2:	00d2      	lsls	r2, r2, #3
 80063e4:	58d3      	ldr	r3, [r2, r3]
 80063e6:	687a      	ldr	r2, [r7, #4]
 80063e8:	429a      	cmp	r2, r3
 80063ea:	d310      	bcc.n	800640e <GetFskBandwidthRegValue+0x46>
 80063ec:	187b      	adds	r3, r7, r1
 80063ee:	781b      	ldrb	r3, [r3, #0]
 80063f0:	1c5a      	adds	r2, r3, #1
 80063f2:	4b0f      	ldr	r3, [pc, #60]	; (8006430 <GetFskBandwidthRegValue+0x68>)
 80063f4:	00d2      	lsls	r2, r2, #3
 80063f6:	58d3      	ldr	r3, [r2, r3]
 80063f8:	687a      	ldr	r2, [r7, #4]
 80063fa:	429a      	cmp	r2, r3
 80063fc:	d207      	bcs.n	800640e <GetFskBandwidthRegValue+0x46>
        {
            return FskBandwidths[i].RegValue;
 80063fe:	187b      	adds	r3, r7, r1
 8006400:	781b      	ldrb	r3, [r3, #0]
 8006402:	4a0b      	ldr	r2, [pc, #44]	; (8006430 <GetFskBandwidthRegValue+0x68>)
 8006404:	00db      	lsls	r3, r3, #3
 8006406:	18d3      	adds	r3, r2, r3
 8006408:	3304      	adds	r3, #4
 800640a:	781b      	ldrb	r3, [r3, #0]
 800640c:	e00b      	b.n	8006426 <GetFskBandwidthRegValue+0x5e>
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ) - 1; i++ )
 800640e:	210f      	movs	r1, #15
 8006410:	187b      	adds	r3, r7, r1
 8006412:	781a      	ldrb	r2, [r3, #0]
 8006414:	187b      	adds	r3, r7, r1
 8006416:	3201      	adds	r2, #1
 8006418:	701a      	strb	r2, [r3, #0]
 800641a:	230f      	movs	r3, #15
 800641c:	18fb      	adds	r3, r7, r3
 800641e:	781b      	ldrb	r3, [r3, #0]
 8006420:	2b14      	cmp	r3, #20
 8006422:	d9da      	bls.n	80063da <GetFskBandwidthRegValue+0x12>
        }
    }
    // ERROR: Value not found
    while( 1 );
 8006424:	e7fe      	b.n	8006424 <GetFskBandwidthRegValue+0x5c>
}
 8006426:	0018      	movs	r0, r3
 8006428:	46bd      	mov	sp, r7
 800642a:	b004      	add	sp, #16
 800642c:	bd80      	pop	{r7, pc}
 800642e:	46c0      	nop			; (mov r8, r8)
 8006430:	0801ed30 	.word	0x0801ed30

08006434 <SX1276SetRxConfig>:
                         uint32_t bandwidthAfc, uint16_t preambleLen,
                         uint16_t symbTimeout, bool fixLen,
                         uint8_t payloadLen,
                         bool crcOn, bool freqHopOn, uint8_t hopPeriod,
                         bool iqInverted, bool rxContinuous )
{
 8006434:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006436:	46c6      	mov	lr, r8
 8006438:	b500      	push	{lr}
 800643a:	b084      	sub	sp, #16
 800643c:	af00      	add	r7, sp, #0
 800643e:	60b9      	str	r1, [r7, #8]
 8006440:	607a      	str	r2, [r7, #4]
 8006442:	0019      	movs	r1, r3
 8006444:	240f      	movs	r4, #15
 8006446:	193b      	adds	r3, r7, r4
 8006448:	1c02      	adds	r2, r0, #0
 800644a:	701a      	strb	r2, [r3, #0]
 800644c:	230e      	movs	r3, #14
 800644e:	18fb      	adds	r3, r7, r3
 8006450:	1c0a      	adds	r2, r1, #0
 8006452:	701a      	strb	r2, [r3, #0]
    SX1276SetModem( modem );
 8006454:	193b      	adds	r3, r7, r4
 8006456:	781b      	ldrb	r3, [r3, #0]
 8006458:	0018      	movs	r0, r3
 800645a:	f001 faaf 	bl	80079bc <SX1276SetModem>

    switch( modem )
 800645e:	193b      	adds	r3, r7, r4
 8006460:	781b      	ldrb	r3, [r3, #0]
 8006462:	2b00      	cmp	r3, #0
 8006464:	d003      	beq.n	800646e <SX1276SetRxConfig+0x3a>
 8006466:	2b01      	cmp	r3, #1
 8006468:	d100      	bne.n	800646c <SX1276SetRxConfig+0x38>
 800646a:	e0fb      	b.n	8006664 <SX1276SetRxConfig+0x230>
                             RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
            }
        }
        break;
    }
}
 800646c:	e26e      	b.n	800694c <SX1276SetRxConfig+0x518>
            SX1276.Settings.Fsk.Bandwidth = bandwidth;
 800646e:	4bbd      	ldr	r3, [pc, #756]	; (8006764 <SX1276SetRxConfig+0x330>)
 8006470:	68ba      	ldr	r2, [r7, #8]
 8006472:	615a      	str	r2, [r3, #20]
            SX1276.Settings.Fsk.Datarate = datarate;
 8006474:	4bbb      	ldr	r3, [pc, #748]	; (8006764 <SX1276SetRxConfig+0x330>)
 8006476:	687a      	ldr	r2, [r7, #4]
 8006478:	61da      	str	r2, [r3, #28]
            SX1276.Settings.Fsk.BandwidthAfc = bandwidthAfc;
 800647a:	4bba      	ldr	r3, [pc, #744]	; (8006764 <SX1276SetRxConfig+0x330>)
 800647c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800647e:	619a      	str	r2, [r3, #24]
            SX1276.Settings.Fsk.FixLen = fixLen;
 8006480:	4bb8      	ldr	r3, [pc, #736]	; (8006764 <SX1276SetRxConfig+0x330>)
 8006482:	222c      	movs	r2, #44	; 0x2c
 8006484:	2108      	movs	r1, #8
 8006486:	468c      	mov	ip, r1
 8006488:	44bc      	add	ip, r7
 800648a:	4462      	add	r2, ip
 800648c:	2122      	movs	r1, #34	; 0x22
 800648e:	7812      	ldrb	r2, [r2, #0]
 8006490:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.Fsk.PayloadLen = payloadLen;
 8006492:	4bb4      	ldr	r3, [pc, #720]	; (8006764 <SX1276SetRxConfig+0x330>)
 8006494:	2130      	movs	r1, #48	; 0x30
 8006496:	2408      	movs	r4, #8
 8006498:	193a      	adds	r2, r7, r4
 800649a:	1852      	adds	r2, r2, r1
 800649c:	2123      	movs	r1, #35	; 0x23
 800649e:	7812      	ldrb	r2, [r2, #0]
 80064a0:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.Fsk.CrcOn = crcOn;
 80064a2:	4bb0      	ldr	r3, [pc, #704]	; (8006764 <SX1276SetRxConfig+0x330>)
 80064a4:	2034      	movs	r0, #52	; 0x34
 80064a6:	193a      	adds	r2, r7, r4
 80064a8:	1812      	adds	r2, r2, r0
 80064aa:	2124      	movs	r1, #36	; 0x24
 80064ac:	7812      	ldrb	r2, [r2, #0]
 80064ae:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.Fsk.IqInverted = iqInverted;
 80064b0:	4bac      	ldr	r3, [pc, #688]	; (8006764 <SX1276SetRxConfig+0x330>)
 80064b2:	2220      	movs	r2, #32
 80064b4:	2020      	movs	r0, #32
 80064b6:	4684      	mov	ip, r0
 80064b8:	2108      	movs	r1, #8
 80064ba:	4688      	mov	r8, r1
 80064bc:	44b8      	add	r8, r7
 80064be:	44c4      	add	ip, r8
 80064c0:	4462      	add	r2, ip
 80064c2:	2125      	movs	r1, #37	; 0x25
 80064c4:	7812      	ldrb	r2, [r2, #0]
 80064c6:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.Fsk.RxContinuous = rxContinuous;
 80064c8:	4ba6      	ldr	r3, [pc, #664]	; (8006764 <SX1276SetRxConfig+0x330>)
 80064ca:	2224      	movs	r2, #36	; 0x24
 80064cc:	2020      	movs	r0, #32
 80064ce:	4684      	mov	ip, r0
 80064d0:	2108      	movs	r1, #8
 80064d2:	4688      	mov	r8, r1
 80064d4:	44b8      	add	r8, r7
 80064d6:	44c4      	add	ip, r8
 80064d8:	4462      	add	r2, ip
 80064da:	2126      	movs	r1, #38	; 0x26
 80064dc:	7812      	ldrb	r2, [r2, #0]
 80064de:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.Fsk.PreambleLen = preambleLen;
 80064e0:	4ba0      	ldr	r3, [pc, #640]	; (8006764 <SX1276SetRxConfig+0x330>)
 80064e2:	2624      	movs	r6, #36	; 0x24
 80064e4:	193a      	adds	r2, r7, r4
 80064e6:	1992      	adds	r2, r2, r6
 80064e8:	8812      	ldrh	r2, [r2, #0]
 80064ea:	841a      	strh	r2, [r3, #32]
            SX1276.Settings.Fsk.RxSingleTimeout = ( uint32_t )( symbTimeout * ( ( 1.0 / ( double )datarate ) * 8.0 ) * 1000 );
 80064ec:	2328      	movs	r3, #40	; 0x28
 80064ee:	2208      	movs	r2, #8
 80064f0:	4694      	mov	ip, r2
 80064f2:	44bc      	add	ip, r7
 80064f4:	4463      	add	r3, ip
 80064f6:	881b      	ldrh	r3, [r3, #0]
 80064f8:	0018      	movs	r0, r3
 80064fa:	f7fc fdad 	bl	8003058 <__aeabi_i2d>
 80064fe:	0004      	movs	r4, r0
 8006500:	000d      	movs	r5, r1
 8006502:	6878      	ldr	r0, [r7, #4]
 8006504:	f7fc fdd8 	bl	80030b8 <__aeabi_ui2d>
 8006508:	0002      	movs	r2, r0
 800650a:	000b      	movs	r3, r1
 800650c:	2000      	movs	r0, #0
 800650e:	4996      	ldr	r1, [pc, #600]	; (8006768 <SX1276SetRxConfig+0x334>)
 8006510:	f7fb fb68 	bl	8001be4 <__aeabi_ddiv>
 8006514:	0002      	movs	r2, r0
 8006516:	000b      	movs	r3, r1
 8006518:	0010      	movs	r0, r2
 800651a:	0019      	movs	r1, r3
 800651c:	2200      	movs	r2, #0
 800651e:	4b93      	ldr	r3, [pc, #588]	; (800676c <SX1276SetRxConfig+0x338>)
 8006520:	f7fb ff66 	bl	80023f0 <__aeabi_dmul>
 8006524:	0002      	movs	r2, r0
 8006526:	000b      	movs	r3, r1
 8006528:	0020      	movs	r0, r4
 800652a:	0029      	movs	r1, r5
 800652c:	f7fb ff60 	bl	80023f0 <__aeabi_dmul>
 8006530:	0002      	movs	r2, r0
 8006532:	000b      	movs	r3, r1
 8006534:	0010      	movs	r0, r2
 8006536:	0019      	movs	r1, r3
 8006538:	2200      	movs	r2, #0
 800653a:	4b8d      	ldr	r3, [pc, #564]	; (8006770 <SX1276SetRxConfig+0x33c>)
 800653c:	f7fb ff58 	bl	80023f0 <__aeabi_dmul>
 8006540:	0002      	movs	r2, r0
 8006542:	000b      	movs	r3, r1
 8006544:	0010      	movs	r0, r2
 8006546:	0019      	movs	r1, r3
 8006548:	f7fa f80e 	bl	8000568 <__aeabi_d2uiz>
 800654c:	0002      	movs	r2, r0
 800654e:	4b85      	ldr	r3, [pc, #532]	; (8006764 <SX1276SetRxConfig+0x330>)
 8006550:	62da      	str	r2, [r3, #44]	; 0x2c
            datarate = ( uint16_t )( ( double )XTAL_FREQ / ( double )datarate );
 8006552:	6878      	ldr	r0, [r7, #4]
 8006554:	f7fc fdb0 	bl	80030b8 <__aeabi_ui2d>
 8006558:	0002      	movs	r2, r0
 800655a:	000b      	movs	r3, r1
 800655c:	2000      	movs	r0, #0
 800655e:	4985      	ldr	r1, [pc, #532]	; (8006774 <SX1276SetRxConfig+0x340>)
 8006560:	f7fb fb40 	bl	8001be4 <__aeabi_ddiv>
 8006564:	0002      	movs	r2, r0
 8006566:	000b      	movs	r3, r1
 8006568:	0010      	movs	r0, r2
 800656a:	0019      	movs	r1, r3
 800656c:	f7f9 fffc 	bl	8000568 <__aeabi_d2uiz>
 8006570:	0003      	movs	r3, r0
 8006572:	b29b      	uxth	r3, r3
 8006574:	607b      	str	r3, [r7, #4]
            SX1276Write( REG_BITRATEMSB, ( uint8_t )( datarate >> 8 ) );
 8006576:	687b      	ldr	r3, [r7, #4]
 8006578:	0a1b      	lsrs	r3, r3, #8
 800657a:	b2db      	uxtb	r3, r3
 800657c:	0019      	movs	r1, r3
 800657e:	2002      	movs	r0, #2
 8006580:	f001 fa76 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_BITRATELSB, ( uint8_t )( datarate & 0xFF ) );
 8006584:	687b      	ldr	r3, [r7, #4]
 8006586:	b2db      	uxtb	r3, r3
 8006588:	0019      	movs	r1, r3
 800658a:	2003      	movs	r0, #3
 800658c:	f001 fa70 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_RXBW, GetFskBandwidthRegValue( bandwidth ) );
 8006590:	68bb      	ldr	r3, [r7, #8]
 8006592:	0018      	movs	r0, r3
 8006594:	f7ff ff18 	bl	80063c8 <GetFskBandwidthRegValue>
 8006598:	0003      	movs	r3, r0
 800659a:	0019      	movs	r1, r3
 800659c:	2012      	movs	r0, #18
 800659e:	f001 fa67 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_AFCBW, GetFskBandwidthRegValue( bandwidthAfc ) );
 80065a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80065a4:	0018      	movs	r0, r3
 80065a6:	f7ff ff0f 	bl	80063c8 <GetFskBandwidthRegValue>
 80065aa:	0003      	movs	r3, r0
 80065ac:	0019      	movs	r1, r3
 80065ae:	2013      	movs	r0, #19
 80065b0:	f001 fa5e 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_PREAMBLEMSB, ( uint8_t )( ( preambleLen >> 8 ) & 0xFF ) );
 80065b4:	2408      	movs	r4, #8
 80065b6:	193b      	adds	r3, r7, r4
 80065b8:	199b      	adds	r3, r3, r6
 80065ba:	881b      	ldrh	r3, [r3, #0]
 80065bc:	0a1b      	lsrs	r3, r3, #8
 80065be:	b29b      	uxth	r3, r3
 80065c0:	b2db      	uxtb	r3, r3
 80065c2:	0019      	movs	r1, r3
 80065c4:	2025      	movs	r0, #37	; 0x25
 80065c6:	f001 fa53 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_PREAMBLELSB, ( uint8_t )( preambleLen & 0xFF ) );
 80065ca:	193b      	adds	r3, r7, r4
 80065cc:	199b      	adds	r3, r3, r6
 80065ce:	881b      	ldrh	r3, [r3, #0]
 80065d0:	b2db      	uxtb	r3, r3
 80065d2:	0019      	movs	r1, r3
 80065d4:	2026      	movs	r0, #38	; 0x26
 80065d6:	f001 fa4b 	bl	8007a70 <SX1276Write>
            if( fixLen == 1 )
 80065da:	222c      	movs	r2, #44	; 0x2c
 80065dc:	193b      	adds	r3, r7, r4
 80065de:	189b      	adds	r3, r3, r2
 80065e0:	781b      	ldrb	r3, [r3, #0]
 80065e2:	2b00      	cmp	r3, #0
 80065e4:	d008      	beq.n	80065f8 <SX1276SetRxConfig+0x1c4>
                SX1276Write( REG_PAYLOADLENGTH, payloadLen );
 80065e6:	2130      	movs	r1, #48	; 0x30
 80065e8:	193b      	adds	r3, r7, r4
 80065ea:	185b      	adds	r3, r3, r1
 80065ec:	781b      	ldrb	r3, [r3, #0]
 80065ee:	0019      	movs	r1, r3
 80065f0:	2032      	movs	r0, #50	; 0x32
 80065f2:	f001 fa3d 	bl	8007a70 <SX1276Write>
 80065f6:	e003      	b.n	8006600 <SX1276SetRxConfig+0x1cc>
                SX1276Write( REG_PAYLOADLENGTH, 0xFF ); // Set payload length to the maximum
 80065f8:	21ff      	movs	r1, #255	; 0xff
 80065fa:	2032      	movs	r0, #50	; 0x32
 80065fc:	f001 fa38 	bl	8007a70 <SX1276Write>
                         ( SX1276Read( REG_PACKETCONFIG1 ) &
 8006600:	2030      	movs	r0, #48	; 0x30
 8006602:	f001 fa49 	bl	8007a98 <SX1276Read>
 8006606:	0003      	movs	r3, r0
 8006608:	b25b      	sxtb	r3, r3
                           RF_PACKETCONFIG1_CRC_MASK &
 800660a:	226f      	movs	r2, #111	; 0x6f
 800660c:	4013      	ands	r3, r2
 800660e:	b25a      	sxtb	r2, r3
                           RF_PACKETCONFIG1_PACKETFORMAT_MASK ) |
 8006610:	232c      	movs	r3, #44	; 0x2c
 8006612:	2108      	movs	r1, #8
 8006614:	468c      	mov	ip, r1
 8006616:	44bc      	add	ip, r7
 8006618:	4463      	add	r3, ip
 800661a:	781b      	ldrb	r3, [r3, #0]
 800661c:	2b00      	cmp	r3, #0
 800661e:	d001      	beq.n	8006624 <SX1276SetRxConfig+0x1f0>
 8006620:	2300      	movs	r3, #0
 8006622:	e001      	b.n	8006628 <SX1276SetRxConfig+0x1f4>
 8006624:	2380      	movs	r3, #128	; 0x80
 8006626:	425b      	negs	r3, r3
 8006628:	4313      	orrs	r3, r2
 800662a:	b25a      	sxtb	r2, r3
                           ( crcOn << 4 ) );
 800662c:	2334      	movs	r3, #52	; 0x34
 800662e:	2108      	movs	r1, #8
 8006630:	468c      	mov	ip, r1
 8006632:	44bc      	add	ip, r7
 8006634:	4463      	add	r3, ip
 8006636:	781b      	ldrb	r3, [r3, #0]
 8006638:	011b      	lsls	r3, r3, #4
                           ( ( fixLen == 1 ) ? RF_PACKETCONFIG1_PACKETFORMAT_FIXED : RF_PACKETCONFIG1_PACKETFORMAT_VARIABLE ) |
 800663a:	b25b      	sxtb	r3, r3
 800663c:	4313      	orrs	r3, r2
 800663e:	b25b      	sxtb	r3, r3
            SX1276Write( REG_PACKETCONFIG1,
 8006640:	b2db      	uxtb	r3, r3
 8006642:	0019      	movs	r1, r3
 8006644:	2030      	movs	r0, #48	; 0x30
 8006646:	f001 fa13 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_PACKETCONFIG2, ( SX1276Read( REG_PACKETCONFIG2 ) | RF_PACKETCONFIG2_DATAMODE_PACKET ) );
 800664a:	2031      	movs	r0, #49	; 0x31
 800664c:	f001 fa24 	bl	8007a98 <SX1276Read>
 8006650:	0003      	movs	r3, r0
 8006652:	001a      	movs	r2, r3
 8006654:	2340      	movs	r3, #64	; 0x40
 8006656:	4313      	orrs	r3, r2
 8006658:	b2db      	uxtb	r3, r3
 800665a:	0019      	movs	r1, r3
 800665c:	2031      	movs	r0, #49	; 0x31
 800665e:	f001 fa07 	bl	8007a70 <SX1276Write>
        break;
 8006662:	e173      	b.n	800694c <SX1276SetRxConfig+0x518>
            if( bandwidth > 2 )
 8006664:	68bb      	ldr	r3, [r7, #8]
 8006666:	2b02      	cmp	r3, #2
 8006668:	d900      	bls.n	800666c <SX1276SetRxConfig+0x238>
                while( 1 );
 800666a:	e7fe      	b.n	800666a <SX1276SetRxConfig+0x236>
            bandwidth += 7;
 800666c:	68bb      	ldr	r3, [r7, #8]
 800666e:	3307      	adds	r3, #7
 8006670:	60bb      	str	r3, [r7, #8]
            SX1276.Settings.LoRa.Bandwidth = bandwidth;
 8006672:	4b3c      	ldr	r3, [pc, #240]	; (8006764 <SX1276SetRxConfig+0x330>)
 8006674:	68ba      	ldr	r2, [r7, #8]
 8006676:	645a      	str	r2, [r3, #68]	; 0x44
            SX1276.Settings.LoRa.Datarate = datarate;
 8006678:	4b3a      	ldr	r3, [pc, #232]	; (8006764 <SX1276SetRxConfig+0x330>)
 800667a:	687a      	ldr	r2, [r7, #4]
 800667c:	649a      	str	r2, [r3, #72]	; 0x48
            SX1276.Settings.LoRa.Coderate = coderate;
 800667e:	4b39      	ldr	r3, [pc, #228]	; (8006764 <SX1276SetRxConfig+0x330>)
 8006680:	220e      	movs	r2, #14
 8006682:	18ba      	adds	r2, r7, r2
 8006684:	214d      	movs	r1, #77	; 0x4d
 8006686:	7812      	ldrb	r2, [r2, #0]
 8006688:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.PreambleLen = preambleLen;
 800668a:	4b36      	ldr	r3, [pc, #216]	; (8006764 <SX1276SetRxConfig+0x330>)
 800668c:	2224      	movs	r2, #36	; 0x24
 800668e:	2108      	movs	r1, #8
 8006690:	468c      	mov	ip, r1
 8006692:	44bc      	add	ip, r7
 8006694:	4462      	add	r2, ip
 8006696:	214e      	movs	r1, #78	; 0x4e
 8006698:	8812      	ldrh	r2, [r2, #0]
 800669a:	525a      	strh	r2, [r3, r1]
            SX1276.Settings.LoRa.FixLen = fixLen;
 800669c:	4b31      	ldr	r3, [pc, #196]	; (8006764 <SX1276SetRxConfig+0x330>)
 800669e:	222c      	movs	r2, #44	; 0x2c
 80066a0:	2108      	movs	r1, #8
 80066a2:	468c      	mov	ip, r1
 80066a4:	44bc      	add	ip, r7
 80066a6:	4462      	add	r2, ip
 80066a8:	2150      	movs	r1, #80	; 0x50
 80066aa:	7812      	ldrb	r2, [r2, #0]
 80066ac:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.PayloadLen = payloadLen;
 80066ae:	4b2d      	ldr	r3, [pc, #180]	; (8006764 <SX1276SetRxConfig+0x330>)
 80066b0:	2230      	movs	r2, #48	; 0x30
 80066b2:	2108      	movs	r1, #8
 80066b4:	468c      	mov	ip, r1
 80066b6:	44bc      	add	ip, r7
 80066b8:	4462      	add	r2, ip
 80066ba:	2151      	movs	r1, #81	; 0x51
 80066bc:	7812      	ldrb	r2, [r2, #0]
 80066be:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.CrcOn = crcOn;
 80066c0:	4b28      	ldr	r3, [pc, #160]	; (8006764 <SX1276SetRxConfig+0x330>)
 80066c2:	2234      	movs	r2, #52	; 0x34
 80066c4:	2108      	movs	r1, #8
 80066c6:	468c      	mov	ip, r1
 80066c8:	44bc      	add	ip, r7
 80066ca:	4462      	add	r2, ip
 80066cc:	2152      	movs	r1, #82	; 0x52
 80066ce:	7812      	ldrb	r2, [r2, #0]
 80066d0:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.FreqHopOn = freqHopOn;
 80066d2:	4b24      	ldr	r3, [pc, #144]	; (8006764 <SX1276SetRxConfig+0x330>)
 80066d4:	2238      	movs	r2, #56	; 0x38
 80066d6:	2108      	movs	r1, #8
 80066d8:	468c      	mov	ip, r1
 80066da:	44bc      	add	ip, r7
 80066dc:	4462      	add	r2, ip
 80066de:	2153      	movs	r1, #83	; 0x53
 80066e0:	7812      	ldrb	r2, [r2, #0]
 80066e2:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.HopPeriod = hopPeriod;
 80066e4:	4b1f      	ldr	r3, [pc, #124]	; (8006764 <SX1276SetRxConfig+0x330>)
 80066e6:	223c      	movs	r2, #60	; 0x3c
 80066e8:	2108      	movs	r1, #8
 80066ea:	468c      	mov	ip, r1
 80066ec:	44bc      	add	ip, r7
 80066ee:	4462      	add	r2, ip
 80066f0:	2154      	movs	r1, #84	; 0x54
 80066f2:	7812      	ldrb	r2, [r2, #0]
 80066f4:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.IqInverted = iqInverted;
 80066f6:	4b1b      	ldr	r3, [pc, #108]	; (8006764 <SX1276SetRxConfig+0x330>)
 80066f8:	2220      	movs	r2, #32
 80066fa:	2120      	movs	r1, #32
 80066fc:	468c      	mov	ip, r1
 80066fe:	2108      	movs	r1, #8
 8006700:	4688      	mov	r8, r1
 8006702:	44b8      	add	r8, r7
 8006704:	44c4      	add	ip, r8
 8006706:	4462      	add	r2, ip
 8006708:	2155      	movs	r1, #85	; 0x55
 800670a:	7812      	ldrb	r2, [r2, #0]
 800670c:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.RxContinuous = rxContinuous;
 800670e:	4b15      	ldr	r3, [pc, #84]	; (8006764 <SX1276SetRxConfig+0x330>)
 8006710:	2224      	movs	r2, #36	; 0x24
 8006712:	2120      	movs	r1, #32
 8006714:	468c      	mov	ip, r1
 8006716:	2108      	movs	r1, #8
 8006718:	4688      	mov	r8, r1
 800671a:	44b8      	add	r8, r7
 800671c:	44c4      	add	ip, r8
 800671e:	4462      	add	r2, ip
 8006720:	2156      	movs	r1, #86	; 0x56
 8006722:	7812      	ldrb	r2, [r2, #0]
 8006724:	545a      	strb	r2, [r3, r1]
            if( datarate > 12 )
 8006726:	687b      	ldr	r3, [r7, #4]
 8006728:	2b0c      	cmp	r3, #12
 800672a:	d902      	bls.n	8006732 <SX1276SetRxConfig+0x2fe>
                datarate = 12;
 800672c:	230c      	movs	r3, #12
 800672e:	607b      	str	r3, [r7, #4]
 8006730:	e004      	b.n	800673c <SX1276SetRxConfig+0x308>
            else if( datarate < 6 )
 8006732:	687b      	ldr	r3, [r7, #4]
 8006734:	2b05      	cmp	r3, #5
 8006736:	d801      	bhi.n	800673c <SX1276SetRxConfig+0x308>
                datarate = 6;
 8006738:	2306      	movs	r3, #6
 800673a:	607b      	str	r3, [r7, #4]
            if( ( ( bandwidth == 7 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 800673c:	68bb      	ldr	r3, [r7, #8]
 800673e:	2b07      	cmp	r3, #7
 8006740:	d105      	bne.n	800674e <SX1276SetRxConfig+0x31a>
 8006742:	687b      	ldr	r3, [r7, #4]
 8006744:	2b0b      	cmp	r3, #11
 8006746:	d008      	beq.n	800675a <SX1276SetRxConfig+0x326>
 8006748:	687b      	ldr	r3, [r7, #4]
 800674a:	2b0c      	cmp	r3, #12
 800674c:	d005      	beq.n	800675a <SX1276SetRxConfig+0x326>
 800674e:	68bb      	ldr	r3, [r7, #8]
 8006750:	2b08      	cmp	r3, #8
 8006752:	d111      	bne.n	8006778 <SX1276SetRxConfig+0x344>
                ( ( bandwidth == 8 ) && ( datarate == 12 ) ) )
 8006754:	687b      	ldr	r3, [r7, #4]
 8006756:	2b0c      	cmp	r3, #12
 8006758:	d10e      	bne.n	8006778 <SX1276SetRxConfig+0x344>
                SX1276.Settings.LoRa.LowDatarateOptimize = 0x01;
 800675a:	4b02      	ldr	r3, [pc, #8]	; (8006764 <SX1276SetRxConfig+0x330>)
 800675c:	224c      	movs	r2, #76	; 0x4c
 800675e:	2101      	movs	r1, #1
 8006760:	5499      	strb	r1, [r3, r2]
 8006762:	e00d      	b.n	8006780 <SX1276SetRxConfig+0x34c>
 8006764:	2000175c 	.word	0x2000175c
 8006768:	3ff00000 	.word	0x3ff00000
 800676c:	40200000 	.word	0x40200000
 8006770:	408f4000 	.word	0x408f4000
 8006774:	417e8480 	.word	0x417e8480
                SX1276.Settings.LoRa.LowDatarateOptimize = 0x00;
 8006778:	4b77      	ldr	r3, [pc, #476]	; (8006958 <SX1276SetRxConfig+0x524>)
 800677a:	224c      	movs	r2, #76	; 0x4c
 800677c:	2100      	movs	r1, #0
 800677e:	5499      	strb	r1, [r3, r2]
                         ( SX1276Read( REG_LR_MODEMCONFIG1 ) &
 8006780:	201d      	movs	r0, #29
 8006782:	f001 f989 	bl	8007a98 <SX1276Read>
                           ( bandwidth << 4 ) | ( coderate << 1 ) |
 8006786:	68bb      	ldr	r3, [r7, #8]
 8006788:	b2db      	uxtb	r3, r3
 800678a:	011b      	lsls	r3, r3, #4
 800678c:	b2da      	uxtb	r2, r3
 800678e:	230e      	movs	r3, #14
 8006790:	18fb      	adds	r3, r7, r3
 8006792:	781b      	ldrb	r3, [r3, #0]
 8006794:	18db      	adds	r3, r3, r3
 8006796:	b2db      	uxtb	r3, r3
 8006798:	4313      	orrs	r3, r2
 800679a:	b2da      	uxtb	r2, r3
            SX1276Write( REG_LR_MODEMCONFIG1,
 800679c:	242c      	movs	r4, #44	; 0x2c
 800679e:	2608      	movs	r6, #8
 80067a0:	19bb      	adds	r3, r7, r6
 80067a2:	191b      	adds	r3, r3, r4
 80067a4:	781b      	ldrb	r3, [r3, #0]
                           ( bandwidth << 4 ) | ( coderate << 1 ) |
 80067a6:	4313      	orrs	r3, r2
 80067a8:	b2db      	uxtb	r3, r3
            SX1276Write( REG_LR_MODEMCONFIG1,
 80067aa:	0019      	movs	r1, r3
 80067ac:	201d      	movs	r0, #29
 80067ae:	f001 f95f 	bl	8007a70 <SX1276Write>
                         ( SX1276Read( REG_LR_MODEMCONFIG2 ) &
 80067b2:	201e      	movs	r0, #30
 80067b4:	f001 f970 	bl	8007a98 <SX1276Read>
 80067b8:	0003      	movs	r3, r0
 80067ba:	001a      	movs	r2, r3
                           RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK &
 80067bc:	2308      	movs	r3, #8
 80067be:	4013      	ands	r3, r2
 80067c0:	b2da      	uxtb	r2, r3
                           ( datarate << 4 ) | ( crcOn << 2 ) |
 80067c2:	687b      	ldr	r3, [r7, #4]
 80067c4:	b2db      	uxtb	r3, r3
 80067c6:	011b      	lsls	r3, r3, #4
 80067c8:	b2db      	uxtb	r3, r3
                           RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) |
 80067ca:	4313      	orrs	r3, r2
 80067cc:	b2da      	uxtb	r2, r3
                           ( datarate << 4 ) | ( crcOn << 2 ) |
 80067ce:	2334      	movs	r3, #52	; 0x34
 80067d0:	2108      	movs	r1, #8
 80067d2:	468c      	mov	ip, r1
 80067d4:	44bc      	add	ip, r7
 80067d6:	4463      	add	r3, ip
 80067d8:	781b      	ldrb	r3, [r3, #0]
 80067da:	009b      	lsls	r3, r3, #2
 80067dc:	b2db      	uxtb	r3, r3
 80067de:	4313      	orrs	r3, r2
 80067e0:	b2da      	uxtb	r2, r3
                           ( ( symbTimeout >> 8 ) & ~RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) );
 80067e2:	2528      	movs	r5, #40	; 0x28
 80067e4:	19bb      	adds	r3, r7, r6
 80067e6:	195b      	adds	r3, r3, r5
 80067e8:	881b      	ldrh	r3, [r3, #0]
 80067ea:	0a1b      	lsrs	r3, r3, #8
 80067ec:	b29b      	uxth	r3, r3
 80067ee:	b2db      	uxtb	r3, r3
 80067f0:	2103      	movs	r1, #3
 80067f2:	400b      	ands	r3, r1
 80067f4:	b2db      	uxtb	r3, r3
            SX1276Write( REG_LR_MODEMCONFIG2,
 80067f6:	4313      	orrs	r3, r2
 80067f8:	b2db      	uxtb	r3, r3
 80067fa:	0019      	movs	r1, r3
 80067fc:	201e      	movs	r0, #30
 80067fe:	f001 f937 	bl	8007a70 <SX1276Write>
                         ( SX1276Read( REG_LR_MODEMCONFIG3 ) &
 8006802:	2026      	movs	r0, #38	; 0x26
 8006804:	f001 f948 	bl	8007a98 <SX1276Read>
 8006808:	0003      	movs	r3, r0
 800680a:	b25b      	sxtb	r3, r3
 800680c:	2208      	movs	r2, #8
 800680e:	4393      	bics	r3, r2
 8006810:	b25a      	sxtb	r2, r3
                           ( SX1276.Settings.LoRa.LowDatarateOptimize << 3 ) );
 8006812:	4b51      	ldr	r3, [pc, #324]	; (8006958 <SX1276SetRxConfig+0x524>)
 8006814:	214c      	movs	r1, #76	; 0x4c
 8006816:	5c5b      	ldrb	r3, [r3, r1]
 8006818:	00db      	lsls	r3, r3, #3
                           RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
 800681a:	b25b      	sxtb	r3, r3
 800681c:	4313      	orrs	r3, r2
 800681e:	b25b      	sxtb	r3, r3
            SX1276Write( REG_LR_MODEMCONFIG3,
 8006820:	b2db      	uxtb	r3, r3
 8006822:	0019      	movs	r1, r3
 8006824:	2026      	movs	r0, #38	; 0x26
 8006826:	f001 f923 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_LR_SYMBTIMEOUTLSB, ( uint8_t )( symbTimeout & 0xFF ) );
 800682a:	19bb      	adds	r3, r7, r6
 800682c:	195b      	adds	r3, r3, r5
 800682e:	881b      	ldrh	r3, [r3, #0]
 8006830:	b2db      	uxtb	r3, r3
 8006832:	0019      	movs	r1, r3
 8006834:	201f      	movs	r0, #31
 8006836:	f001 f91b 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_LR_PREAMBLEMSB, ( uint8_t )( ( preambleLen >> 8 ) & 0xFF ) );
 800683a:	2524      	movs	r5, #36	; 0x24
 800683c:	19bb      	adds	r3, r7, r6
 800683e:	195b      	adds	r3, r3, r5
 8006840:	881b      	ldrh	r3, [r3, #0]
 8006842:	0a1b      	lsrs	r3, r3, #8
 8006844:	b29b      	uxth	r3, r3
 8006846:	b2db      	uxtb	r3, r3
 8006848:	0019      	movs	r1, r3
 800684a:	2020      	movs	r0, #32
 800684c:	f001 f910 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_LR_PREAMBLELSB, ( uint8_t )( preambleLen & 0xFF ) );
 8006850:	19bb      	adds	r3, r7, r6
 8006852:	195b      	adds	r3, r3, r5
 8006854:	881b      	ldrh	r3, [r3, #0]
 8006856:	b2db      	uxtb	r3, r3
 8006858:	0019      	movs	r1, r3
 800685a:	2021      	movs	r0, #33	; 0x21
 800685c:	f001 f908 	bl	8007a70 <SX1276Write>
            if( fixLen == 1 )
 8006860:	19bb      	adds	r3, r7, r6
 8006862:	191b      	adds	r3, r3, r4
 8006864:	781b      	ldrb	r3, [r3, #0]
 8006866:	2b00      	cmp	r3, #0
 8006868:	d009      	beq.n	800687e <SX1276SetRxConfig+0x44a>
                SX1276Write( REG_LR_PAYLOADLENGTH, payloadLen );
 800686a:	2330      	movs	r3, #48	; 0x30
 800686c:	2208      	movs	r2, #8
 800686e:	4694      	mov	ip, r2
 8006870:	44bc      	add	ip, r7
 8006872:	4463      	add	r3, ip
 8006874:	781b      	ldrb	r3, [r3, #0]
 8006876:	0019      	movs	r1, r3
 8006878:	2022      	movs	r0, #34	; 0x22
 800687a:	f001 f8f9 	bl	8007a70 <SX1276Write>
            if( SX1276.Settings.LoRa.FreqHopOn == true )
 800687e:	4b36      	ldr	r3, [pc, #216]	; (8006958 <SX1276SetRxConfig+0x524>)
 8006880:	2253      	movs	r2, #83	; 0x53
 8006882:	5c9b      	ldrb	r3, [r3, r2]
 8006884:	2b00      	cmp	r3, #0
 8006886:	d013      	beq.n	80068b0 <SX1276SetRxConfig+0x47c>
                SX1276Write( REG_LR_PLLHOP, ( SX1276Read( REG_LR_PLLHOP ) & RFLR_PLLHOP_FASTHOP_MASK ) | RFLR_PLLHOP_FASTHOP_ON );
 8006888:	2044      	movs	r0, #68	; 0x44
 800688a:	f001 f905 	bl	8007a98 <SX1276Read>
 800688e:	0003      	movs	r3, r0
 8006890:	001a      	movs	r2, r3
 8006892:	2380      	movs	r3, #128	; 0x80
 8006894:	425b      	negs	r3, r3
 8006896:	4313      	orrs	r3, r2
 8006898:	b2db      	uxtb	r3, r3
 800689a:	0019      	movs	r1, r3
 800689c:	2044      	movs	r0, #68	; 0x44
 800689e:	f001 f8e7 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_HOPPERIOD, SX1276.Settings.LoRa.HopPeriod );
 80068a2:	4b2d      	ldr	r3, [pc, #180]	; (8006958 <SX1276SetRxConfig+0x524>)
 80068a4:	2254      	movs	r2, #84	; 0x54
 80068a6:	5c9b      	ldrb	r3, [r3, r2]
 80068a8:	0019      	movs	r1, r3
 80068aa:	2024      	movs	r0, #36	; 0x24
 80068ac:	f001 f8e0 	bl	8007a70 <SX1276Write>
            if( ( bandwidth == 9 ) && ( SX1276.Settings.Channel > RF_MID_BAND_THRESH ) )
 80068b0:	68bb      	ldr	r3, [r7, #8]
 80068b2:	2b09      	cmp	r3, #9
 80068b4:	d10d      	bne.n	80068d2 <SX1276SetRxConfig+0x49e>
 80068b6:	4b28      	ldr	r3, [pc, #160]	; (8006958 <SX1276SetRxConfig+0x524>)
 80068b8:	689b      	ldr	r3, [r3, #8]
 80068ba:	4a28      	ldr	r2, [pc, #160]	; (800695c <SX1276SetRxConfig+0x528>)
 80068bc:	4293      	cmp	r3, r2
 80068be:	d908      	bls.n	80068d2 <SX1276SetRxConfig+0x49e>
                SX1276Write( REG_LR_HIGHBWOPTIMIZE1, 0x02 );
 80068c0:	2102      	movs	r1, #2
 80068c2:	2036      	movs	r0, #54	; 0x36
 80068c4:	f001 f8d4 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_HIGHBWOPTIMIZE2, 0x64 );
 80068c8:	2164      	movs	r1, #100	; 0x64
 80068ca:	203a      	movs	r0, #58	; 0x3a
 80068cc:	f001 f8d0 	bl	8007a70 <SX1276Write>
 80068d0:	e00f      	b.n	80068f2 <SX1276SetRxConfig+0x4be>
            else if( bandwidth == 9 )
 80068d2:	68bb      	ldr	r3, [r7, #8]
 80068d4:	2b09      	cmp	r3, #9
 80068d6:	d108      	bne.n	80068ea <SX1276SetRxConfig+0x4b6>
                SX1276Write( REG_LR_HIGHBWOPTIMIZE1, 0x02 );
 80068d8:	2102      	movs	r1, #2
 80068da:	2036      	movs	r0, #54	; 0x36
 80068dc:	f001 f8c8 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_HIGHBWOPTIMIZE2, 0x7F );
 80068e0:	217f      	movs	r1, #127	; 0x7f
 80068e2:	203a      	movs	r0, #58	; 0x3a
 80068e4:	f001 f8c4 	bl	8007a70 <SX1276Write>
 80068e8:	e003      	b.n	80068f2 <SX1276SetRxConfig+0x4be>
                SX1276Write( REG_LR_HIGHBWOPTIMIZE1, 0x03 );
 80068ea:	2103      	movs	r1, #3
 80068ec:	2036      	movs	r0, #54	; 0x36
 80068ee:	f001 f8bf 	bl	8007a70 <SX1276Write>
            if( datarate == 6 )
 80068f2:	687b      	ldr	r3, [r7, #4]
 80068f4:	2b06      	cmp	r3, #6
 80068f6:	d114      	bne.n	8006922 <SX1276SetRxConfig+0x4ee>
                             ( SX1276Read( REG_LR_DETECTOPTIMIZE ) &
 80068f8:	2031      	movs	r0, #49	; 0x31
 80068fa:	f001 f8cd 	bl	8007a98 <SX1276Read>
 80068fe:	0003      	movs	r3, r0
 8006900:	b25b      	sxtb	r3, r3
 8006902:	2207      	movs	r2, #7
 8006904:	4393      	bics	r3, r2
 8006906:	b25b      	sxtb	r3, r3
                               RFLR_DETECTIONOPTIMIZE_MASK ) |
 8006908:	2205      	movs	r2, #5
 800690a:	4313      	orrs	r3, r2
 800690c:	b25b      	sxtb	r3, r3
                SX1276Write( REG_LR_DETECTOPTIMIZE,
 800690e:	b2db      	uxtb	r3, r3
 8006910:	0019      	movs	r1, r3
 8006912:	2031      	movs	r0, #49	; 0x31
 8006914:	f001 f8ac 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_DETECTIONTHRESHOLD,
 8006918:	210c      	movs	r1, #12
 800691a:	2037      	movs	r0, #55	; 0x37
 800691c:	f001 f8a8 	bl	8007a70 <SX1276Write>
        break;
 8006920:	e013      	b.n	800694a <SX1276SetRxConfig+0x516>
                             ( SX1276Read( REG_LR_DETECTOPTIMIZE ) &
 8006922:	2031      	movs	r0, #49	; 0x31
 8006924:	f001 f8b8 	bl	8007a98 <SX1276Read>
 8006928:	0003      	movs	r3, r0
 800692a:	b25b      	sxtb	r3, r3
 800692c:	2207      	movs	r2, #7
 800692e:	4393      	bics	r3, r2
 8006930:	b25b      	sxtb	r3, r3
                             RFLR_DETECTIONOPTIMIZE_MASK ) |
 8006932:	2203      	movs	r2, #3
 8006934:	4313      	orrs	r3, r2
 8006936:	b25b      	sxtb	r3, r3
                SX1276Write( REG_LR_DETECTOPTIMIZE,
 8006938:	b2db      	uxtb	r3, r3
 800693a:	0019      	movs	r1, r3
 800693c:	2031      	movs	r0, #49	; 0x31
 800693e:	f001 f897 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_DETECTIONTHRESHOLD,
 8006942:	210a      	movs	r1, #10
 8006944:	2037      	movs	r0, #55	; 0x37
 8006946:	f001 f893 	bl	8007a70 <SX1276Write>
        break;
 800694a:	46c0      	nop			; (mov r8, r8)
}
 800694c:	46c0      	nop			; (mov r8, r8)
 800694e:	46bd      	mov	sp, r7
 8006950:	b004      	add	sp, #16
 8006952:	bc80      	pop	{r7}
 8006954:	46b8      	mov	r8, r7
 8006956:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006958:	2000175c 	.word	0x2000175c
 800695c:	1f4add40 	.word	0x1f4add40

08006960 <SX1276SetTxConfig>:
void SX1276SetTxConfig( RadioModems_t modem, int8_t power, uint32_t fdev,
                        uint32_t bandwidth, uint32_t datarate,
                        uint8_t coderate, uint16_t preambleLen,
                        bool fixLen, bool crcOn, bool freqHopOn,
                        uint8_t hopPeriod, bool iqInverted, uint32_t timeout )
{
 8006960:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006962:	46c6      	mov	lr, r8
 8006964:	b500      	push	{lr}
 8006966:	b084      	sub	sp, #16
 8006968:	af00      	add	r7, sp, #0
 800696a:	60ba      	str	r2, [r7, #8]
 800696c:	607b      	str	r3, [r7, #4]
 800696e:	240f      	movs	r4, #15
 8006970:	193b      	adds	r3, r7, r4
 8006972:	1c02      	adds	r2, r0, #0
 8006974:	701a      	strb	r2, [r3, #0]
 8006976:	250e      	movs	r5, #14
 8006978:	197b      	adds	r3, r7, r5
 800697a:	1c0a      	adds	r2, r1, #0
 800697c:	701a      	strb	r2, [r3, #0]
    SX1276SetModem( modem );
 800697e:	193b      	adds	r3, r7, r4
 8006980:	781b      	ldrb	r3, [r3, #0]
 8006982:	0018      	movs	r0, r3
 8006984:	f001 f81a 	bl	80079bc <SX1276SetModem>

    LoRaBoardCallbacks->SX1276BoardSetRfTxPower( power );
 8006988:	4bac      	ldr	r3, [pc, #688]	; (8006c3c <SX1276SetTxConfig+0x2dc>)
 800698a:	681b      	ldr	r3, [r3, #0]
 800698c:	68db      	ldr	r3, [r3, #12]
 800698e:	197a      	adds	r2, r7, r5
 8006990:	7812      	ldrb	r2, [r2, #0]
 8006992:	b252      	sxtb	r2, r2
 8006994:	0010      	movs	r0, r2
 8006996:	4798      	blx	r3

    switch( modem )
 8006998:	193b      	adds	r3, r7, r4
 800699a:	781b      	ldrb	r3, [r3, #0]
 800699c:	2b00      	cmp	r3, #0
 800699e:	d003      	beq.n	80069a8 <SX1276SetTxConfig+0x48>
 80069a0:	2b01      	cmp	r3, #1
 80069a2:	d100      	bne.n	80069a6 <SX1276SetTxConfig+0x46>
 80069a4:	e0c1      	b.n	8006b2a <SX1276SetTxConfig+0x1ca>
                             RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
            }
        }
        break;
    }
}
 80069a6:	e209      	b.n	8006dbc <SX1276SetTxConfig+0x45c>
            SX1276.Settings.Fsk.Power = power;
 80069a8:	4ba5      	ldr	r3, [pc, #660]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 80069aa:	220e      	movs	r2, #14
 80069ac:	18ba      	adds	r2, r7, r2
 80069ae:	7812      	ldrb	r2, [r2, #0]
 80069b0:	731a      	strb	r2, [r3, #12]
            SX1276.Settings.Fsk.Fdev = fdev;
 80069b2:	4ba3      	ldr	r3, [pc, #652]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 80069b4:	68ba      	ldr	r2, [r7, #8]
 80069b6:	611a      	str	r2, [r3, #16]
            SX1276.Settings.Fsk.Bandwidth = bandwidth;
 80069b8:	4ba1      	ldr	r3, [pc, #644]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 80069ba:	687a      	ldr	r2, [r7, #4]
 80069bc:	615a      	str	r2, [r3, #20]
            SX1276.Settings.Fsk.Datarate = datarate;
 80069be:	4ba0      	ldr	r3, [pc, #640]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 80069c0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80069c2:	61da      	str	r2, [r3, #28]
            SX1276.Settings.Fsk.PreambleLen = preambleLen;
 80069c4:	4b9e      	ldr	r3, [pc, #632]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 80069c6:	2420      	movs	r4, #32
 80069c8:	2608      	movs	r6, #8
 80069ca:	2208      	movs	r2, #8
 80069cc:	18ba      	adds	r2, r7, r2
 80069ce:	1992      	adds	r2, r2, r6
 80069d0:	1912      	adds	r2, r2, r4
 80069d2:	8812      	ldrh	r2, [r2, #0]
 80069d4:	841a      	strh	r2, [r3, #32]
            SX1276.Settings.Fsk.FixLen = fixLen;
 80069d6:	4b9a      	ldr	r3, [pc, #616]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 80069d8:	2524      	movs	r5, #36	; 0x24
 80069da:	2208      	movs	r2, #8
 80069dc:	18ba      	adds	r2, r7, r2
 80069de:	1992      	adds	r2, r2, r6
 80069e0:	1952      	adds	r2, r2, r5
 80069e2:	2122      	movs	r1, #34	; 0x22
 80069e4:	7812      	ldrb	r2, [r2, #0]
 80069e6:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.Fsk.CrcOn = crcOn;
 80069e8:	4b95      	ldr	r3, [pc, #596]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 80069ea:	2228      	movs	r2, #40	; 0x28
 80069ec:	2108      	movs	r1, #8
 80069ee:	468c      	mov	ip, r1
 80069f0:	2108      	movs	r1, #8
 80069f2:	4688      	mov	r8, r1
 80069f4:	44b8      	add	r8, r7
 80069f6:	44c4      	add	ip, r8
 80069f8:	4462      	add	r2, ip
 80069fa:	2124      	movs	r1, #36	; 0x24
 80069fc:	7812      	ldrb	r2, [r2, #0]
 80069fe:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.Fsk.IqInverted = iqInverted;
 8006a00:	4b8f      	ldr	r3, [pc, #572]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006a02:	2234      	movs	r2, #52	; 0x34
 8006a04:	2108      	movs	r1, #8
 8006a06:	468c      	mov	ip, r1
 8006a08:	2108      	movs	r1, #8
 8006a0a:	4688      	mov	r8, r1
 8006a0c:	44b8      	add	r8, r7
 8006a0e:	44c4      	add	ip, r8
 8006a10:	4462      	add	r2, ip
 8006a12:	2125      	movs	r1, #37	; 0x25
 8006a14:	7812      	ldrb	r2, [r2, #0]
 8006a16:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.Fsk.TxTimeout = timeout;
 8006a18:	4b89      	ldr	r3, [pc, #548]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006a1a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006a1c:	629a      	str	r2, [r3, #40]	; 0x28
            fdev = ( uint16_t )( ( double )fdev / ( double )FREQ_STEP );
 8006a1e:	68b8      	ldr	r0, [r7, #8]
 8006a20:	f7fc fb4a 	bl	80030b8 <__aeabi_ui2d>
 8006a24:	2200      	movs	r2, #0
 8006a26:	4b87      	ldr	r3, [pc, #540]	; (8006c44 <SX1276SetTxConfig+0x2e4>)
 8006a28:	f7fb f8dc 	bl	8001be4 <__aeabi_ddiv>
 8006a2c:	0002      	movs	r2, r0
 8006a2e:	000b      	movs	r3, r1
 8006a30:	0010      	movs	r0, r2
 8006a32:	0019      	movs	r1, r3
 8006a34:	f7f9 fd98 	bl	8000568 <__aeabi_d2uiz>
 8006a38:	0003      	movs	r3, r0
 8006a3a:	b29b      	uxth	r3, r3
 8006a3c:	60bb      	str	r3, [r7, #8]
            SX1276Write( REG_FDEVMSB, ( uint8_t )( fdev >> 8 ) );
 8006a3e:	68bb      	ldr	r3, [r7, #8]
 8006a40:	0a1b      	lsrs	r3, r3, #8
 8006a42:	b2db      	uxtb	r3, r3
 8006a44:	0019      	movs	r1, r3
 8006a46:	2004      	movs	r0, #4
 8006a48:	f001 f812 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_FDEVLSB, ( uint8_t )( fdev & 0xFF ) );
 8006a4c:	68bb      	ldr	r3, [r7, #8]
 8006a4e:	b2db      	uxtb	r3, r3
 8006a50:	0019      	movs	r1, r3
 8006a52:	2005      	movs	r0, #5
 8006a54:	f001 f80c 	bl	8007a70 <SX1276Write>
            datarate = ( uint16_t )( ( double )XTAL_FREQ / ( double )datarate );
 8006a58:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8006a5a:	f7fc fb2d 	bl	80030b8 <__aeabi_ui2d>
 8006a5e:	0002      	movs	r2, r0
 8006a60:	000b      	movs	r3, r1
 8006a62:	2000      	movs	r0, #0
 8006a64:	4978      	ldr	r1, [pc, #480]	; (8006c48 <SX1276SetTxConfig+0x2e8>)
 8006a66:	f7fb f8bd 	bl	8001be4 <__aeabi_ddiv>
 8006a6a:	0002      	movs	r2, r0
 8006a6c:	000b      	movs	r3, r1
 8006a6e:	0010      	movs	r0, r2
 8006a70:	0019      	movs	r1, r3
 8006a72:	f7f9 fd79 	bl	8000568 <__aeabi_d2uiz>
 8006a76:	0003      	movs	r3, r0
 8006a78:	b29b      	uxth	r3, r3
 8006a7a:	62bb      	str	r3, [r7, #40]	; 0x28
            SX1276Write( REG_BITRATEMSB, ( uint8_t )( datarate >> 8 ) );
 8006a7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006a7e:	0a1b      	lsrs	r3, r3, #8
 8006a80:	b2db      	uxtb	r3, r3
 8006a82:	0019      	movs	r1, r3
 8006a84:	2002      	movs	r0, #2
 8006a86:	f000 fff3 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_BITRATELSB, ( uint8_t )( datarate & 0xFF ) );
 8006a8a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006a8c:	b2db      	uxtb	r3, r3
 8006a8e:	0019      	movs	r1, r3
 8006a90:	2003      	movs	r0, #3
 8006a92:	f000 ffed 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_PREAMBLEMSB, ( preambleLen >> 8 ) & 0x00FF );
 8006a96:	2308      	movs	r3, #8
 8006a98:	18fb      	adds	r3, r7, r3
 8006a9a:	199b      	adds	r3, r3, r6
 8006a9c:	191b      	adds	r3, r3, r4
 8006a9e:	881b      	ldrh	r3, [r3, #0]
 8006aa0:	0a1b      	lsrs	r3, r3, #8
 8006aa2:	b29b      	uxth	r3, r3
 8006aa4:	b2db      	uxtb	r3, r3
 8006aa6:	0019      	movs	r1, r3
 8006aa8:	2025      	movs	r0, #37	; 0x25
 8006aaa:	f000 ffe1 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_PREAMBLELSB, preambleLen & 0xFF );
 8006aae:	2308      	movs	r3, #8
 8006ab0:	18fb      	adds	r3, r7, r3
 8006ab2:	199b      	adds	r3, r3, r6
 8006ab4:	191b      	adds	r3, r3, r4
 8006ab6:	881b      	ldrh	r3, [r3, #0]
 8006ab8:	b2db      	uxtb	r3, r3
 8006aba:	0019      	movs	r1, r3
 8006abc:	2026      	movs	r0, #38	; 0x26
 8006abe:	f000 ffd7 	bl	8007a70 <SX1276Write>
                         ( SX1276Read( REG_PACKETCONFIG1 ) &
 8006ac2:	2030      	movs	r0, #48	; 0x30
 8006ac4:	f000 ffe8 	bl	8007a98 <SX1276Read>
 8006ac8:	0003      	movs	r3, r0
 8006aca:	b25b      	sxtb	r3, r3
                           RF_PACKETCONFIG1_CRC_MASK &
 8006acc:	226f      	movs	r2, #111	; 0x6f
 8006ace:	4013      	ands	r3, r2
 8006ad0:	b25a      	sxtb	r2, r3
                           RF_PACKETCONFIG1_PACKETFORMAT_MASK ) |
 8006ad2:	2308      	movs	r3, #8
 8006ad4:	18fb      	adds	r3, r7, r3
 8006ad6:	199b      	adds	r3, r3, r6
 8006ad8:	195b      	adds	r3, r3, r5
 8006ada:	781b      	ldrb	r3, [r3, #0]
 8006adc:	2b00      	cmp	r3, #0
 8006ade:	d001      	beq.n	8006ae4 <SX1276SetTxConfig+0x184>
 8006ae0:	2300      	movs	r3, #0
 8006ae2:	e001      	b.n	8006ae8 <SX1276SetTxConfig+0x188>
 8006ae4:	2380      	movs	r3, #128	; 0x80
 8006ae6:	425b      	negs	r3, r3
 8006ae8:	4313      	orrs	r3, r2
 8006aea:	b25a      	sxtb	r2, r3
                           ( crcOn << 4 ) );
 8006aec:	2328      	movs	r3, #40	; 0x28
 8006aee:	2108      	movs	r1, #8
 8006af0:	468c      	mov	ip, r1
 8006af2:	2108      	movs	r1, #8
 8006af4:	4688      	mov	r8, r1
 8006af6:	44b8      	add	r8, r7
 8006af8:	44c4      	add	ip, r8
 8006afa:	4463      	add	r3, ip
 8006afc:	781b      	ldrb	r3, [r3, #0]
 8006afe:	011b      	lsls	r3, r3, #4
                           ( ( fixLen == 1 ) ? RF_PACKETCONFIG1_PACKETFORMAT_FIXED : RF_PACKETCONFIG1_PACKETFORMAT_VARIABLE ) |
 8006b00:	b25b      	sxtb	r3, r3
 8006b02:	4313      	orrs	r3, r2
 8006b04:	b25b      	sxtb	r3, r3
            SX1276Write( REG_PACKETCONFIG1,
 8006b06:	b2db      	uxtb	r3, r3
 8006b08:	0019      	movs	r1, r3
 8006b0a:	2030      	movs	r0, #48	; 0x30
 8006b0c:	f000 ffb0 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_PACKETCONFIG2, ( SX1276Read( REG_PACKETCONFIG2 ) | RF_PACKETCONFIG2_DATAMODE_PACKET ) );
 8006b10:	2031      	movs	r0, #49	; 0x31
 8006b12:	f000 ffc1 	bl	8007a98 <SX1276Read>
 8006b16:	0003      	movs	r3, r0
 8006b18:	001a      	movs	r2, r3
 8006b1a:	2340      	movs	r3, #64	; 0x40
 8006b1c:	4313      	orrs	r3, r2
 8006b1e:	b2db      	uxtb	r3, r3
 8006b20:	0019      	movs	r1, r3
 8006b22:	2031      	movs	r0, #49	; 0x31
 8006b24:	f000 ffa4 	bl	8007a70 <SX1276Write>
        break;
 8006b28:	e148      	b.n	8006dbc <SX1276SetTxConfig+0x45c>
            SX1276.Settings.LoRa.Power = power;
 8006b2a:	4b45      	ldr	r3, [pc, #276]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006b2c:	220e      	movs	r2, #14
 8006b2e:	18ba      	adds	r2, r7, r2
 8006b30:	2140      	movs	r1, #64	; 0x40
 8006b32:	7812      	ldrb	r2, [r2, #0]
 8006b34:	545a      	strb	r2, [r3, r1]
            if( bandwidth > 2 )
 8006b36:	687b      	ldr	r3, [r7, #4]
 8006b38:	2b02      	cmp	r3, #2
 8006b3a:	d900      	bls.n	8006b3e <SX1276SetTxConfig+0x1de>
                while( 1 );
 8006b3c:	e7fe      	b.n	8006b3c <SX1276SetTxConfig+0x1dc>
            bandwidth += 7;
 8006b3e:	687b      	ldr	r3, [r7, #4]
 8006b40:	3307      	adds	r3, #7
 8006b42:	607b      	str	r3, [r7, #4]
            SX1276.Settings.LoRa.Bandwidth = bandwidth;
 8006b44:	4b3e      	ldr	r3, [pc, #248]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006b46:	687a      	ldr	r2, [r7, #4]
 8006b48:	645a      	str	r2, [r3, #68]	; 0x44
            SX1276.Settings.LoRa.Datarate = datarate;
 8006b4a:	4b3d      	ldr	r3, [pc, #244]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006b4c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8006b4e:	649a      	str	r2, [r3, #72]	; 0x48
            SX1276.Settings.LoRa.Coderate = coderate;
 8006b50:	4b3b      	ldr	r3, [pc, #236]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006b52:	221c      	movs	r2, #28
 8006b54:	2108      	movs	r1, #8
 8006b56:	468c      	mov	ip, r1
 8006b58:	2108      	movs	r1, #8
 8006b5a:	4688      	mov	r8, r1
 8006b5c:	44b8      	add	r8, r7
 8006b5e:	44c4      	add	ip, r8
 8006b60:	4462      	add	r2, ip
 8006b62:	214d      	movs	r1, #77	; 0x4d
 8006b64:	7812      	ldrb	r2, [r2, #0]
 8006b66:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.PreambleLen = preambleLen;
 8006b68:	4b35      	ldr	r3, [pc, #212]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006b6a:	2220      	movs	r2, #32
 8006b6c:	2108      	movs	r1, #8
 8006b6e:	468c      	mov	ip, r1
 8006b70:	2108      	movs	r1, #8
 8006b72:	4688      	mov	r8, r1
 8006b74:	44b8      	add	r8, r7
 8006b76:	44c4      	add	ip, r8
 8006b78:	4462      	add	r2, ip
 8006b7a:	214e      	movs	r1, #78	; 0x4e
 8006b7c:	8812      	ldrh	r2, [r2, #0]
 8006b7e:	525a      	strh	r2, [r3, r1]
            SX1276.Settings.LoRa.FixLen = fixLen;
 8006b80:	4b2f      	ldr	r3, [pc, #188]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006b82:	2224      	movs	r2, #36	; 0x24
 8006b84:	2108      	movs	r1, #8
 8006b86:	468c      	mov	ip, r1
 8006b88:	2108      	movs	r1, #8
 8006b8a:	4688      	mov	r8, r1
 8006b8c:	44b8      	add	r8, r7
 8006b8e:	44c4      	add	ip, r8
 8006b90:	4462      	add	r2, ip
 8006b92:	2150      	movs	r1, #80	; 0x50
 8006b94:	7812      	ldrb	r2, [r2, #0]
 8006b96:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.FreqHopOn = freqHopOn;
 8006b98:	4b29      	ldr	r3, [pc, #164]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006b9a:	222c      	movs	r2, #44	; 0x2c
 8006b9c:	2108      	movs	r1, #8
 8006b9e:	468c      	mov	ip, r1
 8006ba0:	2108      	movs	r1, #8
 8006ba2:	4688      	mov	r8, r1
 8006ba4:	44b8      	add	r8, r7
 8006ba6:	44c4      	add	ip, r8
 8006ba8:	4462      	add	r2, ip
 8006baa:	2153      	movs	r1, #83	; 0x53
 8006bac:	7812      	ldrb	r2, [r2, #0]
 8006bae:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.HopPeriod = hopPeriod;
 8006bb0:	4b23      	ldr	r3, [pc, #140]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006bb2:	2230      	movs	r2, #48	; 0x30
 8006bb4:	2108      	movs	r1, #8
 8006bb6:	468c      	mov	ip, r1
 8006bb8:	2108      	movs	r1, #8
 8006bba:	4688      	mov	r8, r1
 8006bbc:	44b8      	add	r8, r7
 8006bbe:	44c4      	add	ip, r8
 8006bc0:	4462      	add	r2, ip
 8006bc2:	2154      	movs	r1, #84	; 0x54
 8006bc4:	7812      	ldrb	r2, [r2, #0]
 8006bc6:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.CrcOn = crcOn;
 8006bc8:	4b1d      	ldr	r3, [pc, #116]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006bca:	2228      	movs	r2, #40	; 0x28
 8006bcc:	2108      	movs	r1, #8
 8006bce:	468c      	mov	ip, r1
 8006bd0:	2108      	movs	r1, #8
 8006bd2:	4688      	mov	r8, r1
 8006bd4:	44b8      	add	r8, r7
 8006bd6:	44c4      	add	ip, r8
 8006bd8:	4462      	add	r2, ip
 8006bda:	2152      	movs	r1, #82	; 0x52
 8006bdc:	7812      	ldrb	r2, [r2, #0]
 8006bde:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.IqInverted = iqInverted;
 8006be0:	4b17      	ldr	r3, [pc, #92]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006be2:	2234      	movs	r2, #52	; 0x34
 8006be4:	2108      	movs	r1, #8
 8006be6:	468c      	mov	ip, r1
 8006be8:	2108      	movs	r1, #8
 8006bea:	4688      	mov	r8, r1
 8006bec:	44b8      	add	r8, r7
 8006bee:	44c4      	add	ip, r8
 8006bf0:	4462      	add	r2, ip
 8006bf2:	2155      	movs	r1, #85	; 0x55
 8006bf4:	7812      	ldrb	r2, [r2, #0]
 8006bf6:	545a      	strb	r2, [r3, r1]
            SX1276.Settings.LoRa.TxTimeout = timeout;
 8006bf8:	4b11      	ldr	r3, [pc, #68]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006bfa:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006bfc:	659a      	str	r2, [r3, #88]	; 0x58
            if( datarate > 12 )
 8006bfe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006c00:	2b0c      	cmp	r3, #12
 8006c02:	d902      	bls.n	8006c0a <SX1276SetTxConfig+0x2aa>
                datarate = 12;
 8006c04:	230c      	movs	r3, #12
 8006c06:	62bb      	str	r3, [r7, #40]	; 0x28
 8006c08:	e004      	b.n	8006c14 <SX1276SetTxConfig+0x2b4>
            else if( datarate < 6 )
 8006c0a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006c0c:	2b05      	cmp	r3, #5
 8006c0e:	d801      	bhi.n	8006c14 <SX1276SetTxConfig+0x2b4>
                datarate = 6;
 8006c10:	2306      	movs	r3, #6
 8006c12:	62bb      	str	r3, [r7, #40]	; 0x28
            if( ( ( bandwidth == 7 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8006c14:	687b      	ldr	r3, [r7, #4]
 8006c16:	2b07      	cmp	r3, #7
 8006c18:	d105      	bne.n	8006c26 <SX1276SetTxConfig+0x2c6>
 8006c1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006c1c:	2b0b      	cmp	r3, #11
 8006c1e:	d008      	beq.n	8006c32 <SX1276SetTxConfig+0x2d2>
 8006c20:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006c22:	2b0c      	cmp	r3, #12
 8006c24:	d005      	beq.n	8006c32 <SX1276SetTxConfig+0x2d2>
 8006c26:	687b      	ldr	r3, [r7, #4]
 8006c28:	2b08      	cmp	r3, #8
 8006c2a:	d10f      	bne.n	8006c4c <SX1276SetTxConfig+0x2ec>
                ( ( bandwidth == 8 ) && ( datarate == 12 ) ) )
 8006c2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006c2e:	2b0c      	cmp	r3, #12
 8006c30:	d10c      	bne.n	8006c4c <SX1276SetTxConfig+0x2ec>
                SX1276.Settings.LoRa.LowDatarateOptimize = 0x01;
 8006c32:	4b03      	ldr	r3, [pc, #12]	; (8006c40 <SX1276SetTxConfig+0x2e0>)
 8006c34:	224c      	movs	r2, #76	; 0x4c
 8006c36:	2101      	movs	r1, #1
 8006c38:	5499      	strb	r1, [r3, r2]
 8006c3a:	e00b      	b.n	8006c54 <SX1276SetTxConfig+0x2f4>
 8006c3c:	20000454 	.word	0x20000454
 8006c40:	2000175c 	.word	0x2000175c
 8006c44:	404e8480 	.word	0x404e8480
 8006c48:	417e8480 	.word	0x417e8480
                SX1276.Settings.LoRa.LowDatarateOptimize = 0x00;
 8006c4c:	4b5e      	ldr	r3, [pc, #376]	; (8006dc8 <SX1276SetTxConfig+0x468>)
 8006c4e:	224c      	movs	r2, #76	; 0x4c
 8006c50:	2100      	movs	r1, #0
 8006c52:	5499      	strb	r1, [r3, r2]
            if( SX1276.Settings.LoRa.FreqHopOn == true )
 8006c54:	4b5c      	ldr	r3, [pc, #368]	; (8006dc8 <SX1276SetTxConfig+0x468>)
 8006c56:	2253      	movs	r2, #83	; 0x53
 8006c58:	5c9b      	ldrb	r3, [r3, r2]
 8006c5a:	2b00      	cmp	r3, #0
 8006c5c:	d013      	beq.n	8006c86 <SX1276SetTxConfig+0x326>
                SX1276Write( REG_LR_PLLHOP, ( SX1276Read( REG_LR_PLLHOP ) & RFLR_PLLHOP_FASTHOP_MASK ) | RFLR_PLLHOP_FASTHOP_ON );
 8006c5e:	2044      	movs	r0, #68	; 0x44
 8006c60:	f000 ff1a 	bl	8007a98 <SX1276Read>
 8006c64:	0003      	movs	r3, r0
 8006c66:	001a      	movs	r2, r3
 8006c68:	2380      	movs	r3, #128	; 0x80
 8006c6a:	425b      	negs	r3, r3
 8006c6c:	4313      	orrs	r3, r2
 8006c6e:	b2db      	uxtb	r3, r3
 8006c70:	0019      	movs	r1, r3
 8006c72:	2044      	movs	r0, #68	; 0x44
 8006c74:	f000 fefc 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_HOPPERIOD, SX1276.Settings.LoRa.HopPeriod );
 8006c78:	4b53      	ldr	r3, [pc, #332]	; (8006dc8 <SX1276SetTxConfig+0x468>)
 8006c7a:	2254      	movs	r2, #84	; 0x54
 8006c7c:	5c9b      	ldrb	r3, [r3, r2]
 8006c7e:	0019      	movs	r1, r3
 8006c80:	2024      	movs	r0, #36	; 0x24
 8006c82:	f000 fef5 	bl	8007a70 <SX1276Write>
                         ( SX1276Read( REG_LR_MODEMCONFIG1 ) &
 8006c86:	201d      	movs	r0, #29
 8006c88:	f000 ff06 	bl	8007a98 <SX1276Read>
                           ( bandwidth << 4 ) | ( coderate << 1 ) |
 8006c8c:	687b      	ldr	r3, [r7, #4]
 8006c8e:	b2db      	uxtb	r3, r3
 8006c90:	011b      	lsls	r3, r3, #4
 8006c92:	b2da      	uxtb	r2, r3
 8006c94:	231c      	movs	r3, #28
 8006c96:	2108      	movs	r1, #8
 8006c98:	468c      	mov	ip, r1
 8006c9a:	2108      	movs	r1, #8
 8006c9c:	4688      	mov	r8, r1
 8006c9e:	44b8      	add	r8, r7
 8006ca0:	44c4      	add	ip, r8
 8006ca2:	4463      	add	r3, ip
 8006ca4:	781b      	ldrb	r3, [r3, #0]
 8006ca6:	18db      	adds	r3, r3, r3
 8006ca8:	b2db      	uxtb	r3, r3
 8006caa:	4313      	orrs	r3, r2
 8006cac:	b2da      	uxtb	r2, r3
            SX1276Write( REG_LR_MODEMCONFIG1,
 8006cae:	2324      	movs	r3, #36	; 0x24
 8006cb0:	2108      	movs	r1, #8
 8006cb2:	468c      	mov	ip, r1
 8006cb4:	2108      	movs	r1, #8
 8006cb6:	4688      	mov	r8, r1
 8006cb8:	44b8      	add	r8, r7
 8006cba:	44c4      	add	ip, r8
 8006cbc:	4463      	add	r3, ip
 8006cbe:	781b      	ldrb	r3, [r3, #0]
                           ( bandwidth << 4 ) | ( coderate << 1 ) |
 8006cc0:	4313      	orrs	r3, r2
 8006cc2:	b2db      	uxtb	r3, r3
            SX1276Write( REG_LR_MODEMCONFIG1,
 8006cc4:	0019      	movs	r1, r3
 8006cc6:	201d      	movs	r0, #29
 8006cc8:	f000 fed2 	bl	8007a70 <SX1276Write>
                         ( SX1276Read( REG_LR_MODEMCONFIG2 ) &
 8006ccc:	201e      	movs	r0, #30
 8006cce:	f000 fee3 	bl	8007a98 <SX1276Read>
 8006cd2:	0003      	movs	r3, r0
 8006cd4:	001a      	movs	r2, r3
                           RFLR_MODEMCONFIG2_SF_MASK &
 8006cd6:	230b      	movs	r3, #11
 8006cd8:	4013      	ands	r3, r2
 8006cda:	b2da      	uxtb	r2, r3
                           ( datarate << 4 ) | ( crcOn << 2 ) );
 8006cdc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006cde:	b2db      	uxtb	r3, r3
 8006ce0:	011b      	lsls	r3, r3, #4
 8006ce2:	b2db      	uxtb	r3, r3
                           RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK ) |
 8006ce4:	4313      	orrs	r3, r2
 8006ce6:	b2da      	uxtb	r2, r3
                           ( datarate << 4 ) | ( crcOn << 2 ) );
 8006ce8:	2328      	movs	r3, #40	; 0x28
 8006cea:	2108      	movs	r1, #8
 8006cec:	468c      	mov	ip, r1
 8006cee:	2108      	movs	r1, #8
 8006cf0:	4688      	mov	r8, r1
 8006cf2:	44b8      	add	r8, r7
 8006cf4:	44c4      	add	ip, r8
 8006cf6:	4463      	add	r3, ip
 8006cf8:	781b      	ldrb	r3, [r3, #0]
 8006cfa:	009b      	lsls	r3, r3, #2
 8006cfc:	b2db      	uxtb	r3, r3
            SX1276Write( REG_LR_MODEMCONFIG2,
 8006cfe:	4313      	orrs	r3, r2
 8006d00:	b2db      	uxtb	r3, r3
 8006d02:	0019      	movs	r1, r3
 8006d04:	201e      	movs	r0, #30
 8006d06:	f000 feb3 	bl	8007a70 <SX1276Write>
                         ( SX1276Read( REG_LR_MODEMCONFIG3 ) &
 8006d0a:	2026      	movs	r0, #38	; 0x26
 8006d0c:	f000 fec4 	bl	8007a98 <SX1276Read>
 8006d10:	0003      	movs	r3, r0
 8006d12:	b25b      	sxtb	r3, r3
 8006d14:	2208      	movs	r2, #8
 8006d16:	4393      	bics	r3, r2
 8006d18:	b25a      	sxtb	r2, r3
                           ( SX1276.Settings.LoRa.LowDatarateOptimize << 3 ) );
 8006d1a:	4b2b      	ldr	r3, [pc, #172]	; (8006dc8 <SX1276SetTxConfig+0x468>)
 8006d1c:	214c      	movs	r1, #76	; 0x4c
 8006d1e:	5c5b      	ldrb	r3, [r3, r1]
 8006d20:	00db      	lsls	r3, r3, #3
                           RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
 8006d22:	b25b      	sxtb	r3, r3
 8006d24:	4313      	orrs	r3, r2
 8006d26:	b25b      	sxtb	r3, r3
            SX1276Write( REG_LR_MODEMCONFIG3,
 8006d28:	b2db      	uxtb	r3, r3
 8006d2a:	0019      	movs	r1, r3
 8006d2c:	2026      	movs	r0, #38	; 0x26
 8006d2e:	f000 fe9f 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_LR_PREAMBLEMSB, ( preambleLen >> 8 ) & 0x00FF );
 8006d32:	2420      	movs	r4, #32
 8006d34:	2508      	movs	r5, #8
 8006d36:	2308      	movs	r3, #8
 8006d38:	18fb      	adds	r3, r7, r3
 8006d3a:	195b      	adds	r3, r3, r5
 8006d3c:	191b      	adds	r3, r3, r4
 8006d3e:	881b      	ldrh	r3, [r3, #0]
 8006d40:	0a1b      	lsrs	r3, r3, #8
 8006d42:	b29b      	uxth	r3, r3
 8006d44:	b2db      	uxtb	r3, r3
 8006d46:	0019      	movs	r1, r3
 8006d48:	2020      	movs	r0, #32
 8006d4a:	f000 fe91 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_LR_PREAMBLELSB, preambleLen & 0xFF );
 8006d4e:	2308      	movs	r3, #8
 8006d50:	18fb      	adds	r3, r7, r3
 8006d52:	195b      	adds	r3, r3, r5
 8006d54:	191b      	adds	r3, r3, r4
 8006d56:	881b      	ldrh	r3, [r3, #0]
 8006d58:	b2db      	uxtb	r3, r3
 8006d5a:	0019      	movs	r1, r3
 8006d5c:	2021      	movs	r0, #33	; 0x21
 8006d5e:	f000 fe87 	bl	8007a70 <SX1276Write>
            if( datarate == 6 )
 8006d62:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006d64:	2b06      	cmp	r3, #6
 8006d66:	d114      	bne.n	8006d92 <SX1276SetTxConfig+0x432>
                             ( SX1276Read( REG_LR_DETECTOPTIMIZE ) &
 8006d68:	2031      	movs	r0, #49	; 0x31
 8006d6a:	f000 fe95 	bl	8007a98 <SX1276Read>
 8006d6e:	0003      	movs	r3, r0
 8006d70:	b25b      	sxtb	r3, r3
 8006d72:	2207      	movs	r2, #7
 8006d74:	4393      	bics	r3, r2
 8006d76:	b25b      	sxtb	r3, r3
                               RFLR_DETECTIONOPTIMIZE_MASK ) |
 8006d78:	2205      	movs	r2, #5
 8006d7a:	4313      	orrs	r3, r2
 8006d7c:	b25b      	sxtb	r3, r3
                SX1276Write( REG_LR_DETECTOPTIMIZE,
 8006d7e:	b2db      	uxtb	r3, r3
 8006d80:	0019      	movs	r1, r3
 8006d82:	2031      	movs	r0, #49	; 0x31
 8006d84:	f000 fe74 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_DETECTIONTHRESHOLD,
 8006d88:	210c      	movs	r1, #12
 8006d8a:	2037      	movs	r0, #55	; 0x37
 8006d8c:	f000 fe70 	bl	8007a70 <SX1276Write>
        break;
 8006d90:	e013      	b.n	8006dba <SX1276SetTxConfig+0x45a>
                             ( SX1276Read( REG_LR_DETECTOPTIMIZE ) &
 8006d92:	2031      	movs	r0, #49	; 0x31
 8006d94:	f000 fe80 	bl	8007a98 <SX1276Read>
 8006d98:	0003      	movs	r3, r0
 8006d9a:	b25b      	sxtb	r3, r3
 8006d9c:	2207      	movs	r2, #7
 8006d9e:	4393      	bics	r3, r2
 8006da0:	b25b      	sxtb	r3, r3
                             RFLR_DETECTIONOPTIMIZE_MASK ) |
 8006da2:	2203      	movs	r2, #3
 8006da4:	4313      	orrs	r3, r2
 8006da6:	b25b      	sxtb	r3, r3
                SX1276Write( REG_LR_DETECTOPTIMIZE,
 8006da8:	b2db      	uxtb	r3, r3
 8006daa:	0019      	movs	r1, r3
 8006dac:	2031      	movs	r0, #49	; 0x31
 8006dae:	f000 fe5f 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_DETECTIONTHRESHOLD,
 8006db2:	210a      	movs	r1, #10
 8006db4:	2037      	movs	r0, #55	; 0x37
 8006db6:	f000 fe5b 	bl	8007a70 <SX1276Write>
        break;
 8006dba:	46c0      	nop			; (mov r8, r8)
}
 8006dbc:	46c0      	nop			; (mov r8, r8)
 8006dbe:	46bd      	mov	sp, r7
 8006dc0:	b004      	add	sp, #16
 8006dc2:	bc80      	pop	{r7}
 8006dc4:	46b8      	mov	r8, r7
 8006dc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006dc8:	2000175c 	.word	0x2000175c

08006dcc <SX1276GetTimeOnAir>:

uint32_t SX1276GetTimeOnAir( RadioModems_t modem, uint8_t pktLen )
{
 8006dcc:	b5b0      	push	{r4, r5, r7, lr}
 8006dce:	b094      	sub	sp, #80	; 0x50
 8006dd0:	af00      	add	r7, sp, #0
 8006dd2:	0002      	movs	r2, r0
 8006dd4:	1dfb      	adds	r3, r7, #7
 8006dd6:	701a      	strb	r2, [r3, #0]
 8006dd8:	1dbb      	adds	r3, r7, #6
 8006dda:	1c0a      	adds	r2, r1, #0
 8006ddc:	701a      	strb	r2, [r3, #0]
    uint32_t airTime = 0;
 8006dde:	2300      	movs	r3, #0
 8006de0:	64fb      	str	r3, [r7, #76]	; 0x4c

    switch( modem )
 8006de2:	1dfb      	adds	r3, r7, #7
 8006de4:	781b      	ldrb	r3, [r3, #0]
 8006de6:	2b00      	cmp	r3, #0
 8006de8:	d003      	beq.n	8006df2 <SX1276GetTimeOnAir+0x26>
 8006dea:	2b01      	cmp	r3, #1
 8006dec:	d100      	bne.n	8006df0 <SX1276GetTimeOnAir+0x24>
 8006dee:	e080      	b.n	8006ef2 <SX1276GetTimeOnAir+0x126>
 8006df0:	e15c      	b.n	80070ac <SX1276GetTimeOnAir+0x2e0>
    {
    case MODEM_FSK:
        {
            airTime = (uint32_t) round( ( 8 * ( SX1276.Settings.Fsk.PreambleLen +
 8006df2:	4bb1      	ldr	r3, [pc, #708]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006df4:	8c1b      	ldrh	r3, [r3, #32]
 8006df6:	001c      	movs	r4, r3
                                     ( ( SX1276Read( REG_SYNCCONFIG ) & ~RF_SYNCCONFIG_SYNCSIZE_MASK ) + 1 ) +
 8006df8:	2027      	movs	r0, #39	; 0x27
 8006dfa:	f000 fe4d 	bl	8007a98 <SX1276Read>
 8006dfe:	0003      	movs	r3, r0
 8006e00:	001a      	movs	r2, r3
 8006e02:	23f8      	movs	r3, #248	; 0xf8
 8006e04:	439a      	bics	r2, r3
 8006e06:	0013      	movs	r3, r2
 8006e08:	3301      	adds	r3, #1
            airTime = (uint32_t) round( ( 8 * ( SX1276.Settings.Fsk.PreambleLen +
 8006e0a:	18e3      	adds	r3, r4, r3
                                     ( ( SX1276Read( REG_SYNCCONFIG ) & ~RF_SYNCCONFIG_SYNCSIZE_MASK ) + 1 ) +
 8006e0c:	0018      	movs	r0, r3
 8006e0e:	f7fc f923 	bl	8003058 <__aeabi_i2d>
 8006e12:	0002      	movs	r2, r0
 8006e14:	000b      	movs	r3, r1
                                     ( ( SX1276.Settings.Fsk.FixLen == 0x01 ) ? 0.0 : 1.0 ) +
 8006e16:	49a8      	ldr	r1, [pc, #672]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006e18:	2022      	movs	r0, #34	; 0x22
 8006e1a:	5c09      	ldrb	r1, [r1, r0]
 8006e1c:	2900      	cmp	r1, #0
 8006e1e:	d002      	beq.n	8006e26 <SX1276GetTimeOnAir+0x5a>
 8006e20:	2000      	movs	r0, #0
 8006e22:	2100      	movs	r1, #0
 8006e24:	e001      	b.n	8006e2a <SX1276GetTimeOnAir+0x5e>
 8006e26:	2000      	movs	r0, #0
 8006e28:	49a4      	ldr	r1, [pc, #656]	; (80070bc <SX1276GetTimeOnAir+0x2f0>)
                                     ( ( SX1276Read( REG_SYNCCONFIG ) & ~RF_SYNCCONFIG_SYNCSIZE_MASK ) + 1 ) +
 8006e2a:	f7fa fb71 	bl	8001510 <__aeabi_dadd>
 8006e2e:	0002      	movs	r2, r0
 8006e30:	000b      	movs	r3, r1
 8006e32:	0014      	movs	r4, r2
 8006e34:	001d      	movs	r5, r3
                                     ( ( ( SX1276Read( REG_PACKETCONFIG1 ) & ~RF_PACKETCONFIG1_ADDRSFILTERING_MASK ) != 0x00 ) ? 1.0 : 0 ) +
 8006e36:	2030      	movs	r0, #48	; 0x30
 8006e38:	f000 fe2e 	bl	8007a98 <SX1276Read>
 8006e3c:	0003      	movs	r3, r0
 8006e3e:	001a      	movs	r2, r3
 8006e40:	23f9      	movs	r3, #249	; 0xf9
 8006e42:	439a      	bics	r2, r3
 8006e44:	1e13      	subs	r3, r2, #0
 8006e46:	d002      	beq.n	8006e4e <SX1276GetTimeOnAir+0x82>
 8006e48:	2000      	movs	r0, #0
 8006e4a:	499c      	ldr	r1, [pc, #624]	; (80070bc <SX1276GetTimeOnAir+0x2f0>)
 8006e4c:	e001      	b.n	8006e52 <SX1276GetTimeOnAir+0x86>
 8006e4e:	2000      	movs	r0, #0
 8006e50:	2100      	movs	r1, #0
                                     ( ( SX1276.Settings.Fsk.FixLen == 0x01 ) ? 0.0 : 1.0 ) +
 8006e52:	0022      	movs	r2, r4
 8006e54:	002b      	movs	r3, r5
 8006e56:	f7fa fb5b 	bl	8001510 <__aeabi_dadd>
 8006e5a:	0002      	movs	r2, r0
 8006e5c:	000b      	movs	r3, r1
 8006e5e:	0014      	movs	r4, r2
 8006e60:	001d      	movs	r5, r3
                                     ( ( ( SX1276Read( REG_PACKETCONFIG1 ) & ~RF_PACKETCONFIG1_ADDRSFILTERING_MASK ) != 0x00 ) ? 1.0 : 0 ) +
 8006e62:	1dbb      	adds	r3, r7, #6
 8006e64:	781b      	ldrb	r3, [r3, #0]
 8006e66:	0018      	movs	r0, r3
 8006e68:	f7fc f8f6 	bl	8003058 <__aeabi_i2d>
 8006e6c:	0002      	movs	r2, r0
 8006e6e:	000b      	movs	r3, r1
 8006e70:	0020      	movs	r0, r4
 8006e72:	0029      	movs	r1, r5
 8006e74:	f7fa fb4c 	bl	8001510 <__aeabi_dadd>
 8006e78:	0002      	movs	r2, r0
 8006e7a:	000b      	movs	r3, r1
                                     pktLen +
                                     ( ( SX1276.Settings.Fsk.CrcOn == 0x01 ) ? 2.0 : 0 ) ) /
 8006e7c:	498e      	ldr	r1, [pc, #568]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006e7e:	2024      	movs	r0, #36	; 0x24
 8006e80:	5c09      	ldrb	r1, [r1, r0]
 8006e82:	2900      	cmp	r1, #0
 8006e84:	d003      	beq.n	8006e8e <SX1276GetTimeOnAir+0xc2>
 8006e86:	2000      	movs	r0, #0
 8006e88:	2180      	movs	r1, #128	; 0x80
 8006e8a:	05c9      	lsls	r1, r1, #23
 8006e8c:	e001      	b.n	8006e92 <SX1276GetTimeOnAir+0xc6>
 8006e8e:	2000      	movs	r0, #0
 8006e90:	2100      	movs	r1, #0
                                     pktLen +
 8006e92:	f7fa fb3d 	bl	8001510 <__aeabi_dadd>
 8006e96:	0002      	movs	r2, r0
 8006e98:	000b      	movs	r3, r1
 8006e9a:	0010      	movs	r0, r2
 8006e9c:	0019      	movs	r1, r3
            airTime = (uint32_t) round( ( 8 * ( SX1276.Settings.Fsk.PreambleLen +
 8006e9e:	2200      	movs	r2, #0
 8006ea0:	4b87      	ldr	r3, [pc, #540]	; (80070c0 <SX1276GetTimeOnAir+0x2f4>)
 8006ea2:	f7fb faa5 	bl	80023f0 <__aeabi_dmul>
 8006ea6:	0002      	movs	r2, r0
 8006ea8:	000b      	movs	r3, r1
 8006eaa:	0014      	movs	r4, r2
 8006eac:	001d      	movs	r5, r3
                                     SX1276.Settings.Fsk.Datarate ) * 1000 );
 8006eae:	4b82      	ldr	r3, [pc, #520]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006eb0:	69db      	ldr	r3, [r3, #28]
                                     ( ( SX1276.Settings.Fsk.CrcOn == 0x01 ) ? 2.0 : 0 ) ) /
 8006eb2:	0018      	movs	r0, r3
 8006eb4:	f7fc f900 	bl	80030b8 <__aeabi_ui2d>
 8006eb8:	0002      	movs	r2, r0
 8006eba:	000b      	movs	r3, r1
 8006ebc:	0020      	movs	r0, r4
 8006ebe:	0029      	movs	r1, r5
 8006ec0:	f7fa fe90 	bl	8001be4 <__aeabi_ddiv>
 8006ec4:	0002      	movs	r2, r0
 8006ec6:	000b      	movs	r3, r1
 8006ec8:	0010      	movs	r0, r2
 8006eca:	0019      	movs	r1, r3
            airTime = (uint32_t) round( ( 8 * ( SX1276.Settings.Fsk.PreambleLen +
 8006ecc:	2200      	movs	r2, #0
 8006ece:	4b7d      	ldr	r3, [pc, #500]	; (80070c4 <SX1276GetTimeOnAir+0x2f8>)
 8006ed0:	f7fb fa8e 	bl	80023f0 <__aeabi_dmul>
 8006ed4:	0002      	movs	r2, r0
 8006ed6:	000b      	movs	r3, r1
 8006ed8:	0010      	movs	r0, r2
 8006eda:	0019      	movs	r1, r3
 8006edc:	f017 fdd8 	bl	801ea90 <round>
 8006ee0:	0002      	movs	r2, r0
 8006ee2:	000b      	movs	r3, r1
 8006ee4:	0010      	movs	r0, r2
 8006ee6:	0019      	movs	r1, r3
 8006ee8:	f7f9 fb3e 	bl	8000568 <__aeabi_d2uiz>
 8006eec:	0003      	movs	r3, r0
 8006eee:	64fb      	str	r3, [r7, #76]	; 0x4c
        }
        break;
 8006ef0:	e0dc      	b.n	80070ac <SX1276GetTimeOnAir+0x2e0>
    case MODEM_LORA:
        {
            double bw = 0.0;
 8006ef2:	2200      	movs	r2, #0
 8006ef4:	2300      	movs	r3, #0
 8006ef6:	643a      	str	r2, [r7, #64]	; 0x40
 8006ef8:	647b      	str	r3, [r7, #68]	; 0x44
            // REMARK: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported
            switch( SX1276.Settings.LoRa.Bandwidth )
 8006efa:	4b6f      	ldr	r3, [pc, #444]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006efc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8006efe:	2b09      	cmp	r3, #9
 8006f00:	d00f      	beq.n	8006f22 <SX1276GetTimeOnAir+0x156>
 8006f02:	d813      	bhi.n	8006f2c <SX1276GetTimeOnAir+0x160>
 8006f04:	2b07      	cmp	r3, #7
 8006f06:	d002      	beq.n	8006f0e <SX1276GetTimeOnAir+0x142>
 8006f08:	2b08      	cmp	r3, #8
 8006f0a:	d005      	beq.n	8006f18 <SX1276GetTimeOnAir+0x14c>
 8006f0c:	e00e      	b.n	8006f2c <SX1276GetTimeOnAir+0x160>
            //    break;
            //case 6: // 62.5 kHz
            //    bw = 62500;
            //    break;
            case 7: // 125 kHz
                bw = 125000;
 8006f0e:	2200      	movs	r2, #0
 8006f10:	4b6d      	ldr	r3, [pc, #436]	; (80070c8 <SX1276GetTimeOnAir+0x2fc>)
 8006f12:	643a      	str	r2, [r7, #64]	; 0x40
 8006f14:	647b      	str	r3, [r7, #68]	; 0x44
                break;
 8006f16:	e009      	b.n	8006f2c <SX1276GetTimeOnAir+0x160>
            case 8: // 250 kHz
                bw = 250000;
 8006f18:	2200      	movs	r2, #0
 8006f1a:	4b6c      	ldr	r3, [pc, #432]	; (80070cc <SX1276GetTimeOnAir+0x300>)
 8006f1c:	643a      	str	r2, [r7, #64]	; 0x40
 8006f1e:	647b      	str	r3, [r7, #68]	; 0x44
                break;
 8006f20:	e004      	b.n	8006f2c <SX1276GetTimeOnAir+0x160>
            case 9: // 500 kHz
                bw = 500000;
 8006f22:	2200      	movs	r2, #0
 8006f24:	4b6a      	ldr	r3, [pc, #424]	; (80070d0 <SX1276GetTimeOnAir+0x304>)
 8006f26:	643a      	str	r2, [r7, #64]	; 0x40
 8006f28:	647b      	str	r3, [r7, #68]	; 0x44
                break;
 8006f2a:	46c0      	nop			; (mov r8, r8)
            }

            // Symbol rate : time for one symbol (secs)
            double rs = bw / ( 1 << SX1276.Settings.LoRa.Datarate );
 8006f2c:	4b62      	ldr	r3, [pc, #392]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006f2e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8006f30:	2201      	movs	r2, #1
 8006f32:	409a      	lsls	r2, r3
 8006f34:	0013      	movs	r3, r2
 8006f36:	0018      	movs	r0, r3
 8006f38:	f7fc f88e 	bl	8003058 <__aeabi_i2d>
 8006f3c:	0002      	movs	r2, r0
 8006f3e:	000b      	movs	r3, r1
 8006f40:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8006f42:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8006f44:	f7fa fe4e 	bl	8001be4 <__aeabi_ddiv>
 8006f48:	0002      	movs	r2, r0
 8006f4a:	000b      	movs	r3, r1
 8006f4c:	63ba      	str	r2, [r7, #56]	; 0x38
 8006f4e:	63fb      	str	r3, [r7, #60]	; 0x3c
            double ts = 1 / rs;
 8006f50:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8006f52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006f54:	2000      	movs	r0, #0
 8006f56:	4959      	ldr	r1, [pc, #356]	; (80070bc <SX1276GetTimeOnAir+0x2f0>)
 8006f58:	f7fa fe44 	bl	8001be4 <__aeabi_ddiv>
 8006f5c:	0002      	movs	r2, r0
 8006f5e:	000b      	movs	r3, r1
 8006f60:	633a      	str	r2, [r7, #48]	; 0x30
 8006f62:	637b      	str	r3, [r7, #52]	; 0x34
            // time of preamble
            double tPreamble = ( SX1276.Settings.LoRa.PreambleLen + 4.25 ) * ts;
 8006f64:	4b54      	ldr	r3, [pc, #336]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006f66:	224e      	movs	r2, #78	; 0x4e
 8006f68:	5a9b      	ldrh	r3, [r3, r2]
 8006f6a:	0018      	movs	r0, r3
 8006f6c:	f7fc f874 	bl	8003058 <__aeabi_i2d>
 8006f70:	2200      	movs	r2, #0
 8006f72:	4b58      	ldr	r3, [pc, #352]	; (80070d4 <SX1276GetTimeOnAir+0x308>)
 8006f74:	f7fa facc 	bl	8001510 <__aeabi_dadd>
 8006f78:	0002      	movs	r2, r0
 8006f7a:	000b      	movs	r3, r1
 8006f7c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8006f7e:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8006f80:	f7fb fa36 	bl	80023f0 <__aeabi_dmul>
 8006f84:	0002      	movs	r2, r0
 8006f86:	000b      	movs	r3, r1
 8006f88:	62ba      	str	r2, [r7, #40]	; 0x28
 8006f8a:	62fb      	str	r3, [r7, #44]	; 0x2c
            // Symbol length of payload and time
            double tmp = ceil( ( 8 * pktLen - 4 * SX1276.Settings.LoRa.Datarate +
 8006f8c:	1dbb      	adds	r3, r7, #6
 8006f8e:	781b      	ldrb	r3, [r3, #0]
 8006f90:	00db      	lsls	r3, r3, #3
 8006f92:	001a      	movs	r2, r3
 8006f94:	4b48      	ldr	r3, [pc, #288]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006f96:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8006f98:	009b      	lsls	r3, r3, #2
 8006f9a:	1ad3      	subs	r3, r2, r3
                                 28 + 16 * SX1276.Settings.LoRa.CrcOn -
 8006f9c:	4a46      	ldr	r2, [pc, #280]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006f9e:	2152      	movs	r1, #82	; 0x52
 8006fa0:	5c52      	ldrb	r2, [r2, r1]
 8006fa2:	0112      	lsls	r2, r2, #4
 8006fa4:	189a      	adds	r2, r3, r2
                                 ( SX1276.Settings.LoRa.FixLen ? 20 : 0 ) ) /
 8006fa6:	4b44      	ldr	r3, [pc, #272]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006fa8:	2150      	movs	r1, #80	; 0x50
 8006faa:	5c5b      	ldrb	r3, [r3, r1]
 8006fac:	2b00      	cmp	r3, #0
 8006fae:	d001      	beq.n	8006fb4 <SX1276GetTimeOnAir+0x1e8>
 8006fb0:	2314      	movs	r3, #20
 8006fb2:	e000      	b.n	8006fb6 <SX1276GetTimeOnAir+0x1ea>
 8006fb4:	2300      	movs	r3, #0
                                 28 + 16 * SX1276.Settings.LoRa.CrcOn -
 8006fb6:	1ad3      	subs	r3, r2, r3
 8006fb8:	331c      	adds	r3, #28
            double tmp = ceil( ( 8 * pktLen - 4 * SX1276.Settings.LoRa.Datarate +
 8006fba:	0018      	movs	r0, r3
 8006fbc:	f7fc f87c 	bl	80030b8 <__aeabi_ui2d>
 8006fc0:	0004      	movs	r4, r0
 8006fc2:	000d      	movs	r5, r1
                                 ( double )( 4 * ( SX1276.Settings.LoRa.Datarate -
 8006fc4:	4b3c      	ldr	r3, [pc, #240]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006fc6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
                                 ( ( SX1276.Settings.LoRa.LowDatarateOptimize > 0 ) ? 2 : 0 ) ) ) ) *
 8006fc8:	4b3b      	ldr	r3, [pc, #236]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8006fca:	214c      	movs	r1, #76	; 0x4c
 8006fcc:	5c5b      	ldrb	r3, [r3, r1]
 8006fce:	2b00      	cmp	r3, #0
 8006fd0:	d001      	beq.n	8006fd6 <SX1276GetTimeOnAir+0x20a>
 8006fd2:	2302      	movs	r3, #2
 8006fd4:	e000      	b.n	8006fd8 <SX1276GetTimeOnAir+0x20c>
 8006fd6:	2300      	movs	r3, #0
                                 ( double )( 4 * ( SX1276.Settings.LoRa.Datarate -
 8006fd8:	1ad3      	subs	r3, r2, r3
 8006fda:	009b      	lsls	r3, r3, #2
 8006fdc:	0018      	movs	r0, r3
 8006fde:	f7fc f86b 	bl	80030b8 <__aeabi_ui2d>
 8006fe2:	0002      	movs	r2, r0
 8006fe4:	000b      	movs	r3, r1
            double tmp = ceil( ( 8 * pktLen - 4 * SX1276.Settings.LoRa.Datarate +
 8006fe6:	0020      	movs	r0, r4
 8006fe8:	0029      	movs	r1, r5
 8006fea:	f7fa fdfb 	bl	8001be4 <__aeabi_ddiv>
 8006fee:	0002      	movs	r2, r0
 8006ff0:	000b      	movs	r3, r1
 8006ff2:	0010      	movs	r0, r2
 8006ff4:	0019      	movs	r1, r3
 8006ff6:	f017 fc37 	bl	801e868 <ceil>
 8006ffa:	0004      	movs	r4, r0
 8006ffc:	000d      	movs	r5, r1
                                 ( SX1276.Settings.LoRa.Coderate + 4 );
 8006ffe:	4b2e      	ldr	r3, [pc, #184]	; (80070b8 <SX1276GetTimeOnAir+0x2ec>)
 8007000:	224d      	movs	r2, #77	; 0x4d
 8007002:	5c9b      	ldrb	r3, [r3, r2]
 8007004:	3304      	adds	r3, #4
                                 ( ( SX1276.Settings.LoRa.LowDatarateOptimize > 0 ) ? 2 : 0 ) ) ) ) *
 8007006:	0018      	movs	r0, r3
 8007008:	f7fc f826 	bl	8003058 <__aeabi_i2d>
 800700c:	0002      	movs	r2, r0
 800700e:	000b      	movs	r3, r1
            double tmp = ceil( ( 8 * pktLen - 4 * SX1276.Settings.LoRa.Datarate +
 8007010:	0020      	movs	r0, r4
 8007012:	0029      	movs	r1, r5
 8007014:	f7fb f9ec 	bl	80023f0 <__aeabi_dmul>
 8007018:	0002      	movs	r2, r0
 800701a:	000b      	movs	r3, r1
 800701c:	623a      	str	r2, [r7, #32]
 800701e:	627b      	str	r3, [r7, #36]	; 0x24
            double nPayload = 8 + ( ( tmp > 0 ) ? tmp : 0 );
 8007020:	2200      	movs	r2, #0
 8007022:	2300      	movs	r3, #0
 8007024:	6a38      	ldr	r0, [r7, #32]
 8007026:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8007028:	f7f9 fa18 	bl	800045c <__aeabi_dcmpgt>
 800702c:	1e03      	subs	r3, r0, #0
 800702e:	d002      	beq.n	8007036 <SX1276GetTimeOnAir+0x26a>
 8007030:	6a38      	ldr	r0, [r7, #32]
 8007032:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8007034:	e001      	b.n	800703a <SX1276GetTimeOnAir+0x26e>
 8007036:	2000      	movs	r0, #0
 8007038:	2100      	movs	r1, #0
 800703a:	2200      	movs	r2, #0
 800703c:	4b20      	ldr	r3, [pc, #128]	; (80070c0 <SX1276GetTimeOnAir+0x2f4>)
 800703e:	f7fa fa67 	bl	8001510 <__aeabi_dadd>
 8007042:	0002      	movs	r2, r0
 8007044:	000b      	movs	r3, r1
 8007046:	61ba      	str	r2, [r7, #24]
 8007048:	61fb      	str	r3, [r7, #28]
            double tPayload = nPayload * ts;
 800704a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800704c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800704e:	69b8      	ldr	r0, [r7, #24]
 8007050:	69f9      	ldr	r1, [r7, #28]
 8007052:	f7fb f9cd 	bl	80023f0 <__aeabi_dmul>
 8007056:	0002      	movs	r2, r0
 8007058:	000b      	movs	r3, r1
 800705a:	613a      	str	r2, [r7, #16]
 800705c:	617b      	str	r3, [r7, #20]
            // Time on air
            double tOnAir = tPreamble + tPayload;
 800705e:	693a      	ldr	r2, [r7, #16]
 8007060:	697b      	ldr	r3, [r7, #20]
 8007062:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007064:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8007066:	f7fa fa53 	bl	8001510 <__aeabi_dadd>
 800706a:	0002      	movs	r2, r0
 800706c:	000b      	movs	r3, r1
 800706e:	60ba      	str	r2, [r7, #8]
 8007070:	60fb      	str	r3, [r7, #12]
            // return ms secs
            airTime = (uint32_t) floor( tOnAir * 1000 + 0.999 );
 8007072:	2200      	movs	r2, #0
 8007074:	4b13      	ldr	r3, [pc, #76]	; (80070c4 <SX1276GetTimeOnAir+0x2f8>)
 8007076:	68b8      	ldr	r0, [r7, #8]
 8007078:	68f9      	ldr	r1, [r7, #12]
 800707a:	f7fb f9b9 	bl	80023f0 <__aeabi_dmul>
 800707e:	0002      	movs	r2, r0
 8007080:	000b      	movs	r3, r1
 8007082:	0010      	movs	r0, r2
 8007084:	0019      	movs	r1, r3
 8007086:	4a14      	ldr	r2, [pc, #80]	; (80070d8 <SX1276GetTimeOnAir+0x30c>)
 8007088:	4b14      	ldr	r3, [pc, #80]	; (80070dc <SX1276GetTimeOnAir+0x310>)
 800708a:	f7fa fa41 	bl	8001510 <__aeabi_dadd>
 800708e:	0002      	movs	r2, r0
 8007090:	000b      	movs	r3, r1
 8007092:	0010      	movs	r0, r2
 8007094:	0019      	movs	r1, r3
 8007096:	f017 fc71 	bl	801e97c <floor>
 800709a:	0002      	movs	r2, r0
 800709c:	000b      	movs	r3, r1
 800709e:	0010      	movs	r0, r2
 80070a0:	0019      	movs	r1, r3
 80070a2:	f7f9 fa61 	bl	8000568 <__aeabi_d2uiz>
 80070a6:	0003      	movs	r3, r0
 80070a8:	64fb      	str	r3, [r7, #76]	; 0x4c
        }
        break;
 80070aa:	46c0      	nop			; (mov r8, r8)
    }
    return airTime;
 80070ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
 80070ae:	0018      	movs	r0, r3
 80070b0:	46bd      	mov	sp, r7
 80070b2:	b014      	add	sp, #80	; 0x50
 80070b4:	bdb0      	pop	{r4, r5, r7, pc}
 80070b6:	46c0      	nop			; (mov r8, r8)
 80070b8:	2000175c 	.word	0x2000175c
 80070bc:	3ff00000 	.word	0x3ff00000
 80070c0:	40200000 	.word	0x40200000
 80070c4:	408f4000 	.word	0x408f4000
 80070c8:	40fe8480 	.word	0x40fe8480
 80070cc:	410e8480 	.word	0x410e8480
 80070d0:	411e8480 	.word	0x411e8480
 80070d4:	40110000 	.word	0x40110000
 80070d8:	d916872b 	.word	0xd916872b
 80070dc:	3feff7ce 	.word	0x3feff7ce

080070e0 <SX1276Send>:

void SX1276Send( uint8_t *buffer, uint8_t size )
{
 80070e0:	b580      	push	{r7, lr}
 80070e2:	b084      	sub	sp, #16
 80070e4:	af00      	add	r7, sp, #0
 80070e6:	6078      	str	r0, [r7, #4]
 80070e8:	000a      	movs	r2, r1
 80070ea:	1cfb      	adds	r3, r7, #3
 80070ec:	701a      	strb	r2, [r3, #0]
    uint32_t txTimeout = 0;
 80070ee:	2300      	movs	r3, #0
 80070f0:	60fb      	str	r3, [r7, #12]

    switch( SX1276.Settings.Modem )
 80070f2:	4b59      	ldr	r3, [pc, #356]	; (8007258 <SX1276Send+0x178>)
 80070f4:	795b      	ldrb	r3, [r3, #5]
 80070f6:	2b00      	cmp	r3, #0
 80070f8:	d002      	beq.n	8007100 <SX1276Send+0x20>
 80070fa:	2b01      	cmp	r3, #1
 80070fc:	d04c      	beq.n	8007198 <SX1276Send+0xb8>
 80070fe:	e0a2      	b.n	8007246 <SX1276Send+0x166>
    {
    case MODEM_FSK:
        {
            SX1276.Settings.FskPacketHandler.NbBytes = 0;
 8007100:	4b55      	ldr	r3, [pc, #340]	; (8007258 <SX1276Send+0x178>)
 8007102:	2200      	movs	r2, #0
 8007104:	879a      	strh	r2, [r3, #60]	; 0x3c
            SX1276.Settings.FskPacketHandler.Size = size;
 8007106:	1cfb      	adds	r3, r7, #3
 8007108:	781b      	ldrb	r3, [r3, #0]
 800710a:	b29a      	uxth	r2, r3
 800710c:	4b52      	ldr	r3, [pc, #328]	; (8007258 <SX1276Send+0x178>)
 800710e:	875a      	strh	r2, [r3, #58]	; 0x3a

            if( SX1276.Settings.Fsk.FixLen == false )
 8007110:	4b51      	ldr	r3, [pc, #324]	; (8007258 <SX1276Send+0x178>)
 8007112:	2222      	movs	r2, #34	; 0x22
 8007114:	5c9b      	ldrb	r3, [r3, r2]
 8007116:	2201      	movs	r2, #1
 8007118:	4053      	eors	r3, r2
 800711a:	b2db      	uxtb	r3, r3
 800711c:	2b00      	cmp	r3, #0
 800711e:	d005      	beq.n	800712c <SX1276Send+0x4c>
            {
                SX1276WriteFifo( ( uint8_t* )&size, 1 );
 8007120:	1cfb      	adds	r3, r7, #3
 8007122:	2101      	movs	r1, #1
 8007124:	0018      	movs	r0, r3
 8007126:	f000 fd51 	bl	8007bcc <SX1276WriteFifo>
 800712a:	e005      	b.n	8007138 <SX1276Send+0x58>
            }
            else
            {
                SX1276Write( REG_PAYLOADLENGTH, size );
 800712c:	1cfb      	adds	r3, r7, #3
 800712e:	781b      	ldrb	r3, [r3, #0]
 8007130:	0019      	movs	r1, r3
 8007132:	2032      	movs	r0, #50	; 0x32
 8007134:	f000 fc9c 	bl	8007a70 <SX1276Write>
            }

            if( ( size > 0 ) && ( size <= 64 ) )
 8007138:	1cfb      	adds	r3, r7, #3
 800713a:	781b      	ldrb	r3, [r3, #0]
 800713c:	2b00      	cmp	r3, #0
 800713e:	d009      	beq.n	8007154 <SX1276Send+0x74>
 8007140:	1cfb      	adds	r3, r7, #3
 8007142:	781b      	ldrb	r3, [r3, #0]
 8007144:	2b40      	cmp	r3, #64	; 0x40
 8007146:	d805      	bhi.n	8007154 <SX1276Send+0x74>
            {
                SX1276.Settings.FskPacketHandler.ChunkSize = size;
 8007148:	1cfb      	adds	r3, r7, #3
 800714a:	7819      	ldrb	r1, [r3, #0]
 800714c:	4b42      	ldr	r3, [pc, #264]	; (8007258 <SX1276Send+0x178>)
 800714e:	223f      	movs	r2, #63	; 0x3f
 8007150:	5499      	strb	r1, [r3, r2]
 8007152:	e00b      	b.n	800716c <SX1276Send+0x8c>
            }
            else
            {
                memcpy1( RxTxBuffer, buffer, size );
 8007154:	1cfb      	adds	r3, r7, #3
 8007156:	781b      	ldrb	r3, [r3, #0]
 8007158:	b29a      	uxth	r2, r3
 800715a:	6879      	ldr	r1, [r7, #4]
 800715c:	4b3f      	ldr	r3, [pc, #252]	; (800725c <SX1276Send+0x17c>)
 800715e:	0018      	movs	r0, r3
 8007160:	f014 f9f2 	bl	801b548 <memcpy1>
                SX1276.Settings.FskPacketHandler.ChunkSize = 32;
 8007164:	4b3c      	ldr	r3, [pc, #240]	; (8007258 <SX1276Send+0x178>)
 8007166:	223f      	movs	r2, #63	; 0x3f
 8007168:	2120      	movs	r1, #32
 800716a:	5499      	strb	r1, [r3, r2]
            }

            // Write payload buffer
            SX1276WriteFifo( buffer, SX1276.Settings.FskPacketHandler.ChunkSize );
 800716c:	4b3a      	ldr	r3, [pc, #232]	; (8007258 <SX1276Send+0x178>)
 800716e:	223f      	movs	r2, #63	; 0x3f
 8007170:	5c9a      	ldrb	r2, [r3, r2]
 8007172:	687b      	ldr	r3, [r7, #4]
 8007174:	0011      	movs	r1, r2
 8007176:	0018      	movs	r0, r3
 8007178:	f000 fd28 	bl	8007bcc <SX1276WriteFifo>
            SX1276.Settings.FskPacketHandler.NbBytes += SX1276.Settings.FskPacketHandler.ChunkSize;
 800717c:	4b36      	ldr	r3, [pc, #216]	; (8007258 <SX1276Send+0x178>)
 800717e:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
 8007180:	4b35      	ldr	r3, [pc, #212]	; (8007258 <SX1276Send+0x178>)
 8007182:	213f      	movs	r1, #63	; 0x3f
 8007184:	5c5b      	ldrb	r3, [r3, r1]
 8007186:	b29b      	uxth	r3, r3
 8007188:	18d3      	adds	r3, r2, r3
 800718a:	b29a      	uxth	r2, r3
 800718c:	4b32      	ldr	r3, [pc, #200]	; (8007258 <SX1276Send+0x178>)
 800718e:	879a      	strh	r2, [r3, #60]	; 0x3c
            txTimeout = SX1276.Settings.Fsk.TxTimeout;
 8007190:	4b31      	ldr	r3, [pc, #196]	; (8007258 <SX1276Send+0x178>)
 8007192:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007194:	60fb      	str	r3, [r7, #12]
        }
        break;
 8007196:	e056      	b.n	8007246 <SX1276Send+0x166>
    case MODEM_LORA:
        {
            if( SX1276.Settings.LoRa.IqInverted == true )
 8007198:	4b2f      	ldr	r3, [pc, #188]	; (8007258 <SX1276Send+0x178>)
 800719a:	2255      	movs	r2, #85	; 0x55
 800719c:	5c9b      	ldrb	r3, [r3, r2]
 800719e:	2b00      	cmp	r3, #0
 80071a0:	d011      	beq.n	80071c6 <SX1276Send+0xe6>
            {
                SX1276Write( REG_LR_INVERTIQ, ( ( SX1276Read( REG_LR_INVERTIQ ) & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK ) | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_ON ) );
 80071a2:	2033      	movs	r0, #51	; 0x33
 80071a4:	f000 fc78 	bl	8007a98 <SX1276Read>
 80071a8:	0003      	movs	r3, r0
 80071aa:	001a      	movs	r2, r3
 80071ac:	2341      	movs	r3, #65	; 0x41
 80071ae:	439a      	bics	r2, r3
 80071b0:	0013      	movs	r3, r2
 80071b2:	b2db      	uxtb	r3, r3
 80071b4:	0019      	movs	r1, r3
 80071b6:	2033      	movs	r0, #51	; 0x33
 80071b8:	f000 fc5a 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON );
 80071bc:	2119      	movs	r1, #25
 80071be:	203b      	movs	r0, #59	; 0x3b
 80071c0:	f000 fc56 	bl	8007a70 <SX1276Write>
 80071c4:	e013      	b.n	80071ee <SX1276Send+0x10e>
            }
            else
            {
                SX1276Write( REG_LR_INVERTIQ, ( ( SX1276Read( REG_LR_INVERTIQ ) & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK ) | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF ) );
 80071c6:	2033      	movs	r0, #51	; 0x33
 80071c8:	f000 fc66 	bl	8007a98 <SX1276Read>
 80071cc:	0003      	movs	r3, r0
 80071ce:	b25b      	sxtb	r3, r3
 80071d0:	2241      	movs	r2, #65	; 0x41
 80071d2:	4393      	bics	r3, r2
 80071d4:	b25b      	sxtb	r3, r3
 80071d6:	2201      	movs	r2, #1
 80071d8:	4313      	orrs	r3, r2
 80071da:	b25b      	sxtb	r3, r3
 80071dc:	b2db      	uxtb	r3, r3
 80071de:	0019      	movs	r1, r3
 80071e0:	2033      	movs	r0, #51	; 0x33
 80071e2:	f000 fc45 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF );
 80071e6:	211d      	movs	r1, #29
 80071e8:	203b      	movs	r0, #59	; 0x3b
 80071ea:	f000 fc41 	bl	8007a70 <SX1276Write>
            }

            SX1276.Settings.LoRaPacketHandler.Size = size;
 80071ee:	1cfb      	adds	r3, r7, #3
 80071f0:	7819      	ldrb	r1, [r3, #0]
 80071f2:	4b19      	ldr	r3, [pc, #100]	; (8007258 <SX1276Send+0x178>)
 80071f4:	2264      	movs	r2, #100	; 0x64
 80071f6:	5499      	strb	r1, [r3, r2]

            // Initializes the payload size
            SX1276Write( REG_LR_PAYLOADLENGTH, size );
 80071f8:	1cfb      	adds	r3, r7, #3
 80071fa:	781b      	ldrb	r3, [r3, #0]
 80071fc:	0019      	movs	r1, r3
 80071fe:	2022      	movs	r0, #34	; 0x22
 8007200:	f000 fc36 	bl	8007a70 <SX1276Write>

            // Full buffer used for Tx
            SX1276Write( REG_LR_FIFOTXBASEADDR, 0 );
 8007204:	2100      	movs	r1, #0
 8007206:	200e      	movs	r0, #14
 8007208:	f000 fc32 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_LR_FIFOADDRPTR, 0 );
 800720c:	2100      	movs	r1, #0
 800720e:	200d      	movs	r0, #13
 8007210:	f000 fc2e 	bl	8007a70 <SX1276Write>

            // FIFO operations can not take place in Sleep mode
            if( ( SX1276Read( REG_OPMODE ) & ~RF_OPMODE_MASK ) == RF_OPMODE_SLEEP )
 8007214:	2001      	movs	r0, #1
 8007216:	f000 fc3f 	bl	8007a98 <SX1276Read>
 800721a:	0003      	movs	r3, r0
 800721c:	001a      	movs	r2, r3
 800721e:	23f8      	movs	r3, #248	; 0xf8
 8007220:	439a      	bics	r2, r3
 8007222:	1e13      	subs	r3, r2, #0
 8007224:	d104      	bne.n	8007230 <SX1276Send+0x150>
            {
                SX1276SetStby( );
 8007226:	f000 f841 	bl	80072ac <SX1276SetStby>
                DelayMs( 1 );
 800722a:	2001      	movs	r0, #1
 800722c:	f015 fc34 	bl	801ca98 <HAL_Delay>
            }
            // Write payload buffer
            SX1276WriteFifo( buffer, size );
 8007230:	1cfb      	adds	r3, r7, #3
 8007232:	781a      	ldrb	r2, [r3, #0]
 8007234:	687b      	ldr	r3, [r7, #4]
 8007236:	0011      	movs	r1, r2
 8007238:	0018      	movs	r0, r3
 800723a:	f000 fcc7 	bl	8007bcc <SX1276WriteFifo>
            txTimeout = SX1276.Settings.LoRa.TxTimeout;
 800723e:	4b06      	ldr	r3, [pc, #24]	; (8007258 <SX1276Send+0x178>)
 8007240:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007242:	60fb      	str	r3, [r7, #12]
        }
        break;
 8007244:	46c0      	nop			; (mov r8, r8)
    }

    SX1276SetTx( txTimeout );
 8007246:	68fb      	ldr	r3, [r7, #12]
 8007248:	0018      	movs	r0, r3
 800724a:	f000 f9dd 	bl	8007608 <SX1276SetTx>
}
 800724e:	46c0      	nop			; (mov r8, r8)
 8007250:	46bd      	mov	sp, r7
 8007252:	b004      	add	sp, #16
 8007254:	bd80      	pop	{r7, pc}
 8007256:	46c0      	nop			; (mov r8, r8)
 8007258:	2000175c 	.word	0x2000175c
 800725c:	20000354 	.word	0x20000354

08007260 <SX1276SetSleep>:

void SX1276SetSleep( void )
{
 8007260:	b580      	push	{r7, lr}
 8007262:	af00      	add	r7, sp, #0
    TimerStop( &RxTimeoutTimer );
 8007264:	4b0c      	ldr	r3, [pc, #48]	; (8007298 <SX1276SetSleep+0x38>)
 8007266:	0018      	movs	r0, r3
 8007268:	f013 fee8 	bl	801b03c <TimerStop>
    TimerStop( &TxTimeoutTimer );
 800726c:	4b0b      	ldr	r3, [pc, #44]	; (800729c <SX1276SetSleep+0x3c>)
 800726e:	0018      	movs	r0, r3
 8007270:	f013 fee4 	bl	801b03c <TimerStop>
    TimerStop( &RxTimeoutSyncWord );
 8007274:	4b0a      	ldr	r3, [pc, #40]	; (80072a0 <SX1276SetSleep+0x40>)
 8007276:	0018      	movs	r0, r3
 8007278:	f013 fee0 	bl	801b03c <TimerStop>

    SX1276SetOpMode( RF_OPMODE_SLEEP );
 800727c:	2000      	movs	r0, #0
 800727e:	f000 fb4d 	bl	800791c <SX1276SetOpMode>

    // Disable TCXO radio is in SLEEP mode
    LoRaBoardCallbacks->SX1276BoardSetXO( RESET );
 8007282:	4b08      	ldr	r3, [pc, #32]	; (80072a4 <SX1276SetSleep+0x44>)
 8007284:	681b      	ldr	r3, [r3, #0]
 8007286:	681b      	ldr	r3, [r3, #0]
 8007288:	2000      	movs	r0, #0
 800728a:	4798      	blx	r3

    SX1276.Settings.State = RF_IDLE;
 800728c:	4b06      	ldr	r3, [pc, #24]	; (80072a8 <SX1276SetSleep+0x48>)
 800728e:	2200      	movs	r2, #0
 8007290:	711a      	strb	r2, [r3, #4]
}
 8007292:	46c0      	nop			; (mov r8, r8)
 8007294:	46bd      	mov	sp, r7
 8007296:	bd80      	pop	{r7, pc}
 8007298:	200017c4 	.word	0x200017c4
 800729c:	2000172c 	.word	0x2000172c
 80072a0:	20001744 	.word	0x20001744
 80072a4:	20000454 	.word	0x20000454
 80072a8:	2000175c 	.word	0x2000175c

080072ac <SX1276SetStby>:

void SX1276SetStby( void )
{
 80072ac:	b580      	push	{r7, lr}
 80072ae:	af00      	add	r7, sp, #0
    TimerStop( &RxTimeoutTimer );
 80072b0:	4b0a      	ldr	r3, [pc, #40]	; (80072dc <SX1276SetStby+0x30>)
 80072b2:	0018      	movs	r0, r3
 80072b4:	f013 fec2 	bl	801b03c <TimerStop>
    TimerStop( &TxTimeoutTimer );
 80072b8:	4b09      	ldr	r3, [pc, #36]	; (80072e0 <SX1276SetStby+0x34>)
 80072ba:	0018      	movs	r0, r3
 80072bc:	f013 febe 	bl	801b03c <TimerStop>
    TimerStop( &RxTimeoutSyncWord );
 80072c0:	4b08      	ldr	r3, [pc, #32]	; (80072e4 <SX1276SetStby+0x38>)
 80072c2:	0018      	movs	r0, r3
 80072c4:	f013 feba 	bl	801b03c <TimerStop>

    SX1276SetOpMode( RF_OPMODE_STANDBY );
 80072c8:	2001      	movs	r0, #1
 80072ca:	f000 fb27 	bl	800791c <SX1276SetOpMode>
    SX1276.Settings.State = RF_IDLE;
 80072ce:	4b06      	ldr	r3, [pc, #24]	; (80072e8 <SX1276SetStby+0x3c>)
 80072d0:	2200      	movs	r2, #0
 80072d2:	711a      	strb	r2, [r3, #4]
}
 80072d4:	46c0      	nop			; (mov r8, r8)
 80072d6:	46bd      	mov	sp, r7
 80072d8:	bd80      	pop	{r7, pc}
 80072da:	46c0      	nop			; (mov r8, r8)
 80072dc:	200017c4 	.word	0x200017c4
 80072e0:	2000172c 	.word	0x2000172c
 80072e4:	20001744 	.word	0x20001744
 80072e8:	2000175c 	.word	0x2000175c

080072ec <SX1276SetRx>:

void SX1276SetRx( uint32_t timeout )
{
 80072ec:	b580      	push	{r7, lr}
 80072ee:	b084      	sub	sp, #16
 80072f0:	af00      	add	r7, sp, #0
 80072f2:	6078      	str	r0, [r7, #4]
    bool rxContinuous = false;
 80072f4:	230f      	movs	r3, #15
 80072f6:	18fb      	adds	r3, r7, r3
 80072f8:	2200      	movs	r2, #0
 80072fa:	701a      	strb	r2, [r3, #0]
    TimerStop( &TxTimeoutTimer );
 80072fc:	4bb6      	ldr	r3, [pc, #728]	; (80075d8 <SX1276SetRx+0x2ec>)
 80072fe:	0018      	movs	r0, r3
 8007300:	f013 fe9c 	bl	801b03c <TimerStop>

    switch( SX1276.Settings.Modem )
 8007304:	4bb5      	ldr	r3, [pc, #724]	; (80075dc <SX1276SetRx+0x2f0>)
 8007306:	795b      	ldrb	r3, [r3, #5]
 8007308:	2b00      	cmp	r3, #0
 800730a:	d002      	beq.n	8007312 <SX1276SetRx+0x26>
 800730c:	2b01      	cmp	r3, #1
 800730e:	d041      	beq.n	8007394 <SX1276SetRx+0xa8>
 8007310:	e127      	b.n	8007562 <SX1276SetRx+0x276>
    {
    case MODEM_FSK:
        {
            rxContinuous = SX1276.Settings.Fsk.RxContinuous;
 8007312:	230f      	movs	r3, #15
 8007314:	18fb      	adds	r3, r7, r3
 8007316:	4ab1      	ldr	r2, [pc, #708]	; (80075dc <SX1276SetRx+0x2f0>)
 8007318:	2126      	movs	r1, #38	; 0x26
 800731a:	5c52      	ldrb	r2, [r2, r1]
 800731c:	701a      	strb	r2, [r3, #0]
            // DIO1=FifoLevel
            // DIO2=SyncAddr
            // DIO3=FifoEmpty
            // DIO4=Preamble
            // DIO5=ModeReady
            SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RF_DIOMAPPING1_DIO0_MASK &
 800731e:	2040      	movs	r0, #64	; 0x40
 8007320:	f000 fbba 	bl	8007a98 <SX1276Read>
 8007324:	0003      	movs	r3, r0
 8007326:	b25b      	sxtb	r3, r3
                                                                            RF_DIOMAPPING1_DIO1_MASK &
                                                                            RF_DIOMAPPING1_DIO2_MASK ) |
                                                                            RF_DIOMAPPING1_DIO0_00 |
 8007328:	2203      	movs	r2, #3
 800732a:	4013      	ands	r3, r2
 800732c:	b25b      	sxtb	r3, r3
                                                                            RF_DIOMAPPING1_DIO1_00 |
 800732e:	220c      	movs	r2, #12
 8007330:	4313      	orrs	r3, r2
 8007332:	b25b      	sxtb	r3, r3
            SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RF_DIOMAPPING1_DIO0_MASK &
 8007334:	b2db      	uxtb	r3, r3
 8007336:	0019      	movs	r1, r3
 8007338:	2040      	movs	r0, #64	; 0x40
 800733a:	f000 fb99 	bl	8007a70 <SX1276Write>
                                                                            RF_DIOMAPPING1_DIO2_11 );

            SX1276Write( REG_DIOMAPPING2, ( SX1276Read( REG_DIOMAPPING2 ) & RF_DIOMAPPING2_DIO4_MASK &
 800733e:	2041      	movs	r0, #65	; 0x41
 8007340:	f000 fbaa 	bl	8007a98 <SX1276Read>
 8007344:	0003      	movs	r3, r0
 8007346:	001a      	movs	r2, r3
 8007348:	233f      	movs	r3, #63	; 0x3f
 800734a:	425b      	negs	r3, r3
 800734c:	4313      	orrs	r3, r2
 800734e:	b2db      	uxtb	r3, r3
 8007350:	0019      	movs	r1, r3
 8007352:	2041      	movs	r0, #65	; 0x41
 8007354:	f000 fb8c 	bl	8007a70 <SX1276Write>
                                                                            RF_DIOMAPPING2_MAP_MASK ) |
                                                                            RF_DIOMAPPING2_DIO4_11 |
                                                                            RF_DIOMAPPING2_MAP_PREAMBLEDETECT );

            SX1276.Settings.FskPacketHandler.FifoThresh = SX1276Read( REG_FIFOTHRESH ) & 0x3F;
 8007358:	2035      	movs	r0, #53	; 0x35
 800735a:	f000 fb9d 	bl	8007a98 <SX1276Read>
 800735e:	0003      	movs	r3, r0
 8007360:	001a      	movs	r2, r3
 8007362:	233f      	movs	r3, #63	; 0x3f
 8007364:	4013      	ands	r3, r2
 8007366:	b2d9      	uxtb	r1, r3
 8007368:	4b9c      	ldr	r3, [pc, #624]	; (80075dc <SX1276SetRx+0x2f0>)
 800736a:	223e      	movs	r2, #62	; 0x3e
 800736c:	5499      	strb	r1, [r3, r2]

            SX1276Write( REG_RXCONFIG, RF_RXCONFIG_AFCAUTO_ON | RF_RXCONFIG_AGCAUTO_ON | RF_RXCONFIG_RXTRIGER_PREAMBLEDETECT );
 800736e:	211e      	movs	r1, #30
 8007370:	200d      	movs	r0, #13
 8007372:	f000 fb7d 	bl	8007a70 <SX1276Write>

            SX1276.Settings.FskPacketHandler.PreambleDetected = false;
 8007376:	4b99      	ldr	r3, [pc, #612]	; (80075dc <SX1276SetRx+0x2f0>)
 8007378:	2230      	movs	r2, #48	; 0x30
 800737a:	2100      	movs	r1, #0
 800737c:	5499      	strb	r1, [r3, r2]
            SX1276.Settings.FskPacketHandler.SyncWordDetected = false;
 800737e:	4b97      	ldr	r3, [pc, #604]	; (80075dc <SX1276SetRx+0x2f0>)
 8007380:	2231      	movs	r2, #49	; 0x31
 8007382:	2100      	movs	r1, #0
 8007384:	5499      	strb	r1, [r3, r2]
            SX1276.Settings.FskPacketHandler.NbBytes = 0;
 8007386:	4b95      	ldr	r3, [pc, #596]	; (80075dc <SX1276SetRx+0x2f0>)
 8007388:	2200      	movs	r2, #0
 800738a:	879a      	strh	r2, [r3, #60]	; 0x3c
            SX1276.Settings.FskPacketHandler.Size = 0;
 800738c:	4b93      	ldr	r3, [pc, #588]	; (80075dc <SX1276SetRx+0x2f0>)
 800738e:	2200      	movs	r2, #0
 8007390:	875a      	strh	r2, [r3, #58]	; 0x3a
        }
        break;
 8007392:	e0e6      	b.n	8007562 <SX1276SetRx+0x276>
    case MODEM_LORA:
        {
            if( SX1276.Settings.LoRa.IqInverted == true )
 8007394:	4b91      	ldr	r3, [pc, #580]	; (80075dc <SX1276SetRx+0x2f0>)
 8007396:	2255      	movs	r2, #85	; 0x55
 8007398:	5c9b      	ldrb	r3, [r3, r2]
 800739a:	2b00      	cmp	r3, #0
 800739c:	d010      	beq.n	80073c0 <SX1276SetRx+0xd4>
            {
                SX1276Write( REG_LR_INVERTIQ, ( ( SX1276Read( REG_LR_INVERTIQ ) & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK ) | RFLR_INVERTIQ_RX_ON | RFLR_INVERTIQ_TX_OFF ) );
 800739e:	2033      	movs	r0, #51	; 0x33
 80073a0:	f000 fb7a 	bl	8007a98 <SX1276Read>
 80073a4:	0003      	movs	r3, r0
 80073a6:	001a      	movs	r2, r3
 80073a8:	2341      	movs	r3, #65	; 0x41
 80073aa:	4313      	orrs	r3, r2
 80073ac:	b2db      	uxtb	r3, r3
 80073ae:	0019      	movs	r1, r3
 80073b0:	2033      	movs	r0, #51	; 0x33
 80073b2:	f000 fb5d 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON );
 80073b6:	2119      	movs	r1, #25
 80073b8:	203b      	movs	r0, #59	; 0x3b
 80073ba:	f000 fb59 	bl	8007a70 <SX1276Write>
 80073be:	e013      	b.n	80073e8 <SX1276SetRx+0xfc>
            }
            else
            {
                SX1276Write( REG_LR_INVERTIQ, ( ( SX1276Read( REG_LR_INVERTIQ ) & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK ) | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF ) );
 80073c0:	2033      	movs	r0, #51	; 0x33
 80073c2:	f000 fb69 	bl	8007a98 <SX1276Read>
 80073c6:	0003      	movs	r3, r0
 80073c8:	b25b      	sxtb	r3, r3
 80073ca:	2241      	movs	r2, #65	; 0x41
 80073cc:	4393      	bics	r3, r2
 80073ce:	b25b      	sxtb	r3, r3
 80073d0:	2201      	movs	r2, #1
 80073d2:	4313      	orrs	r3, r2
 80073d4:	b25b      	sxtb	r3, r3
 80073d6:	b2db      	uxtb	r3, r3
 80073d8:	0019      	movs	r1, r3
 80073da:	2033      	movs	r0, #51	; 0x33
 80073dc:	f000 fb48 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF );
 80073e0:	211d      	movs	r1, #29
 80073e2:	203b      	movs	r0, #59	; 0x3b
 80073e4:	f000 fb44 	bl	8007a70 <SX1276Write>
            }

            // ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal
            if( SX1276.Settings.LoRa.Bandwidth < 9 )
 80073e8:	4b7c      	ldr	r3, [pc, #496]	; (80075dc <SX1276SetRx+0x2f0>)
 80073ea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80073ec:	2b08      	cmp	r3, #8
 80073ee:	d900      	bls.n	80073f2 <SX1276SetRx+0x106>
 80073f0:	e075      	b.n	80074de <SX1276SetRx+0x1f2>
            {
                SX1276Write( REG_LR_DETECTOPTIMIZE, SX1276Read( REG_LR_DETECTOPTIMIZE ) & 0x7F );
 80073f2:	2031      	movs	r0, #49	; 0x31
 80073f4:	f000 fb50 	bl	8007a98 <SX1276Read>
 80073f8:	0003      	movs	r3, r0
 80073fa:	001a      	movs	r2, r3
 80073fc:	237f      	movs	r3, #127	; 0x7f
 80073fe:	4013      	ands	r3, r2
 8007400:	b2db      	uxtb	r3, r3
 8007402:	0019      	movs	r1, r3
 8007404:	2031      	movs	r0, #49	; 0x31
 8007406:	f000 fb33 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_LR_IFFREQ2, 0x00 );
 800740a:	2100      	movs	r1, #0
 800740c:	2030      	movs	r0, #48	; 0x30
 800740e:	f000 fb2f 	bl	8007a70 <SX1276Write>
                switch( SX1276.Settings.LoRa.Bandwidth )
 8007412:	4b72      	ldr	r3, [pc, #456]	; (80075dc <SX1276SetRx+0x2f0>)
 8007414:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007416:	2b08      	cmp	r3, #8
 8007418:	d86e      	bhi.n	80074f8 <SX1276SetRx+0x20c>
 800741a:	009a      	lsls	r2, r3, #2
 800741c:	4b70      	ldr	r3, [pc, #448]	; (80075e0 <SX1276SetRx+0x2f4>)
 800741e:	18d3      	adds	r3, r2, r3
 8007420:	681b      	ldr	r3, [r3, #0]
 8007422:	469f      	mov	pc, r3
                {
                case 0: // 7.8 kHz
                    SX1276Write( REG_LR_IFFREQ1, 0x48 );
 8007424:	2148      	movs	r1, #72	; 0x48
 8007426:	202f      	movs	r0, #47	; 0x2f
 8007428:	f000 fb22 	bl	8007a70 <SX1276Write>
                    SX1276SetChannel(SX1276.Settings.Channel + 7810 );
 800742c:	4b6b      	ldr	r3, [pc, #428]	; (80075dc <SX1276SetRx+0x2f0>)
 800742e:	689b      	ldr	r3, [r3, #8]
 8007430:	4a6c      	ldr	r2, [pc, #432]	; (80075e4 <SX1276SetRx+0x2f8>)
 8007432:	4694      	mov	ip, r2
 8007434:	4463      	add	r3, ip
 8007436:	0018      	movs	r0, r3
 8007438:	f7fe fe74 	bl	8006124 <SX1276SetChannel>
                    break;
 800743c:	e05c      	b.n	80074f8 <SX1276SetRx+0x20c>
                case 1: // 10.4 kHz
                    SX1276Write( REG_LR_IFFREQ1, 0x44 );
 800743e:	2144      	movs	r1, #68	; 0x44
 8007440:	202f      	movs	r0, #47	; 0x2f
 8007442:	f000 fb15 	bl	8007a70 <SX1276Write>
                    SX1276SetChannel(SX1276.Settings.Channel + 10420 );
 8007446:	4b65      	ldr	r3, [pc, #404]	; (80075dc <SX1276SetRx+0x2f0>)
 8007448:	689b      	ldr	r3, [r3, #8]
 800744a:	4a67      	ldr	r2, [pc, #412]	; (80075e8 <SX1276SetRx+0x2fc>)
 800744c:	4694      	mov	ip, r2
 800744e:	4463      	add	r3, ip
 8007450:	0018      	movs	r0, r3
 8007452:	f7fe fe67 	bl	8006124 <SX1276SetChannel>
                    break;
 8007456:	e04f      	b.n	80074f8 <SX1276SetRx+0x20c>
                case 2: // 15.6 kHz
                    SX1276Write( REG_LR_IFFREQ1, 0x44 );
 8007458:	2144      	movs	r1, #68	; 0x44
 800745a:	202f      	movs	r0, #47	; 0x2f
 800745c:	f000 fb08 	bl	8007a70 <SX1276Write>
                    SX1276SetChannel(SX1276.Settings.Channel + 15620 );
 8007460:	4b5e      	ldr	r3, [pc, #376]	; (80075dc <SX1276SetRx+0x2f0>)
 8007462:	689b      	ldr	r3, [r3, #8]
 8007464:	4a61      	ldr	r2, [pc, #388]	; (80075ec <SX1276SetRx+0x300>)
 8007466:	4694      	mov	ip, r2
 8007468:	4463      	add	r3, ip
 800746a:	0018      	movs	r0, r3
 800746c:	f7fe fe5a 	bl	8006124 <SX1276SetChannel>
                    break;
 8007470:	e042      	b.n	80074f8 <SX1276SetRx+0x20c>
                case 3: // 20.8 kHz
                    SX1276Write( REG_LR_IFFREQ1, 0x44 );
 8007472:	2144      	movs	r1, #68	; 0x44
 8007474:	202f      	movs	r0, #47	; 0x2f
 8007476:	f000 fafb 	bl	8007a70 <SX1276Write>
                    SX1276SetChannel(SX1276.Settings.Channel + 20830 );
 800747a:	4b58      	ldr	r3, [pc, #352]	; (80075dc <SX1276SetRx+0x2f0>)
 800747c:	689b      	ldr	r3, [r3, #8]
 800747e:	4a5c      	ldr	r2, [pc, #368]	; (80075f0 <SX1276SetRx+0x304>)
 8007480:	4694      	mov	ip, r2
 8007482:	4463      	add	r3, ip
 8007484:	0018      	movs	r0, r3
 8007486:	f7fe fe4d 	bl	8006124 <SX1276SetChannel>
                    break;
 800748a:	e035      	b.n	80074f8 <SX1276SetRx+0x20c>
                case 4: // 31.2 kHz
                    SX1276Write( REG_LR_IFFREQ1, 0x44 );
 800748c:	2144      	movs	r1, #68	; 0x44
 800748e:	202f      	movs	r0, #47	; 0x2f
 8007490:	f000 faee 	bl	8007a70 <SX1276Write>
                    SX1276SetChannel(SX1276.Settings.Channel + 31250 );
 8007494:	4b51      	ldr	r3, [pc, #324]	; (80075dc <SX1276SetRx+0x2f0>)
 8007496:	689b      	ldr	r3, [r3, #8]
 8007498:	4a56      	ldr	r2, [pc, #344]	; (80075f4 <SX1276SetRx+0x308>)
 800749a:	4694      	mov	ip, r2
 800749c:	4463      	add	r3, ip
 800749e:	0018      	movs	r0, r3
 80074a0:	f7fe fe40 	bl	8006124 <SX1276SetChannel>
                    break;
 80074a4:	e028      	b.n	80074f8 <SX1276SetRx+0x20c>
                case 5: // 41.4 kHz
                    SX1276Write( REG_LR_IFFREQ1, 0x44 );
 80074a6:	2144      	movs	r1, #68	; 0x44
 80074a8:	202f      	movs	r0, #47	; 0x2f
 80074aa:	f000 fae1 	bl	8007a70 <SX1276Write>
                    SX1276SetChannel(SX1276.Settings.Channel + 41670 );
 80074ae:	4b4b      	ldr	r3, [pc, #300]	; (80075dc <SX1276SetRx+0x2f0>)
 80074b0:	689b      	ldr	r3, [r3, #8]
 80074b2:	4a51      	ldr	r2, [pc, #324]	; (80075f8 <SX1276SetRx+0x30c>)
 80074b4:	4694      	mov	ip, r2
 80074b6:	4463      	add	r3, ip
 80074b8:	0018      	movs	r0, r3
 80074ba:	f7fe fe33 	bl	8006124 <SX1276SetChannel>
                    break;
 80074be:	e01b      	b.n	80074f8 <SX1276SetRx+0x20c>
                case 6: // 62.5 kHz
                    SX1276Write( REG_LR_IFFREQ1, 0x40 );
 80074c0:	2140      	movs	r1, #64	; 0x40
 80074c2:	202f      	movs	r0, #47	; 0x2f
 80074c4:	f000 fad4 	bl	8007a70 <SX1276Write>
                    break;
 80074c8:	e016      	b.n	80074f8 <SX1276SetRx+0x20c>
                case 7: // 125 kHz
                    SX1276Write( REG_LR_IFFREQ1, 0x40 );
 80074ca:	2140      	movs	r1, #64	; 0x40
 80074cc:	202f      	movs	r0, #47	; 0x2f
 80074ce:	f000 facf 	bl	8007a70 <SX1276Write>
                    break;
 80074d2:	e011      	b.n	80074f8 <SX1276SetRx+0x20c>
                case 8: // 250 kHz
                    SX1276Write( REG_LR_IFFREQ1, 0x40 );
 80074d4:	2140      	movs	r1, #64	; 0x40
 80074d6:	202f      	movs	r0, #47	; 0x2f
 80074d8:	f000 faca 	bl	8007a70 <SX1276Write>
                    break;
 80074dc:	e00c      	b.n	80074f8 <SX1276SetRx+0x20c>
                }
            }
            else
            {
                SX1276Write( REG_LR_DETECTOPTIMIZE, SX1276Read( REG_LR_DETECTOPTIMIZE ) | 0x80 );
 80074de:	2031      	movs	r0, #49	; 0x31
 80074e0:	f000 fada 	bl	8007a98 <SX1276Read>
 80074e4:	0003      	movs	r3, r0
 80074e6:	001a      	movs	r2, r3
 80074e8:	2380      	movs	r3, #128	; 0x80
 80074ea:	425b      	negs	r3, r3
 80074ec:	4313      	orrs	r3, r2
 80074ee:	b2db      	uxtb	r3, r3
 80074f0:	0019      	movs	r1, r3
 80074f2:	2031      	movs	r0, #49	; 0x31
 80074f4:	f000 fabc 	bl	8007a70 <SX1276Write>
            }

            rxContinuous = SX1276.Settings.LoRa.RxContinuous;
 80074f8:	230f      	movs	r3, #15
 80074fa:	18fb      	adds	r3, r7, r3
 80074fc:	4a37      	ldr	r2, [pc, #220]	; (80075dc <SX1276SetRx+0x2f0>)
 80074fe:	2156      	movs	r1, #86	; 0x56
 8007500:	5c52      	ldrb	r2, [r2, r1]
 8007502:	701a      	strb	r2, [r3, #0]

            if( SX1276.Settings.LoRa.FreqHopOn == true )
 8007504:	4b35      	ldr	r3, [pc, #212]	; (80075dc <SX1276SetRx+0x2f0>)
 8007506:	2253      	movs	r2, #83	; 0x53
 8007508:	5c9b      	ldrb	r3, [r3, r2]
 800750a:	2b00      	cmp	r3, #0
 800750c:	d010      	beq.n	8007530 <SX1276SetRx+0x244>
            {
                SX1276Write( REG_LR_IRQFLAGSMASK, //RFLR_IRQFLAGS_RXTIMEOUT |
 800750e:	211d      	movs	r1, #29
 8007510:	2011      	movs	r0, #17
 8007512:	f000 faad 	bl	8007a70 <SX1276Write>
                                                  RFLR_IRQFLAGS_CADDONE |
                                                  //RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                                  RFLR_IRQFLAGS_CADDETECTED );

                // DIO0=RxDone, DIO2=FhssChangeChannel
                SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO0_MASK & RFLR_DIOMAPPING1_DIO2_MASK  ) | RFLR_DIOMAPPING1_DIO0_00 | RFLR_DIOMAPPING1_DIO2_00 );
 8007516:	2040      	movs	r0, #64	; 0x40
 8007518:	f000 fabe 	bl	8007a98 <SX1276Read>
 800751c:	0003      	movs	r3, r0
 800751e:	001a      	movs	r2, r3
 8007520:	2333      	movs	r3, #51	; 0x33
 8007522:	4013      	ands	r3, r2
 8007524:	b2db      	uxtb	r3, r3
 8007526:	0019      	movs	r1, r3
 8007528:	2040      	movs	r0, #64	; 0x40
 800752a:	f000 faa1 	bl	8007a70 <SX1276Write>
 800752e:	e00f      	b.n	8007550 <SX1276SetRx+0x264>
            }
            else
            {
                SX1276Write( REG_LR_IRQFLAGSMASK, //RFLR_IRQFLAGS_RXTIMEOUT |
 8007530:	211f      	movs	r1, #31
 8007532:	2011      	movs	r0, #17
 8007534:	f000 fa9c 	bl	8007a70 <SX1276Write>
                                                  RFLR_IRQFLAGS_CADDONE |
                                                  RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                                  RFLR_IRQFLAGS_CADDETECTED );

                // DIO0=RxDone
                SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO0_MASK ) | RFLR_DIOMAPPING1_DIO0_00 );
 8007538:	2040      	movs	r0, #64	; 0x40
 800753a:	f000 faad 	bl	8007a98 <SX1276Read>
 800753e:	0003      	movs	r3, r0
 8007540:	001a      	movs	r2, r3
 8007542:	233f      	movs	r3, #63	; 0x3f
 8007544:	4013      	ands	r3, r2
 8007546:	b2db      	uxtb	r3, r3
 8007548:	0019      	movs	r1, r3
 800754a:	2040      	movs	r0, #64	; 0x40
 800754c:	f000 fa90 	bl	8007a70 <SX1276Write>
            }
            SX1276Write( REG_LR_FIFORXBASEADDR, 0 );
 8007550:	2100      	movs	r1, #0
 8007552:	200f      	movs	r0, #15
 8007554:	f000 fa8c 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_LR_FIFOADDRPTR, 0 );
 8007558:	2100      	movs	r1, #0
 800755a:	200d      	movs	r0, #13
 800755c:	f000 fa88 	bl	8007a70 <SX1276Write>
        }
        break;
 8007560:	46c0      	nop			; (mov r8, r8)
    }

    memset( RxTxBuffer, 0, ( size_t )RX_BUFFER_SIZE );
 8007562:	2380      	movs	r3, #128	; 0x80
 8007564:	005a      	lsls	r2, r3, #1
 8007566:	4b25      	ldr	r3, [pc, #148]	; (80075fc <SX1276SetRx+0x310>)
 8007568:	2100      	movs	r1, #0
 800756a:	0018      	movs	r0, r3
 800756c:	f015 fff2 	bl	801d554 <memset>

    SX1276.Settings.State = RF_RX_RUNNING;
 8007570:	4b1a      	ldr	r3, [pc, #104]	; (80075dc <SX1276SetRx+0x2f0>)
 8007572:	2201      	movs	r2, #1
 8007574:	711a      	strb	r2, [r3, #4]
    if( timeout != 0 )
 8007576:	687b      	ldr	r3, [r7, #4]
 8007578:	2b00      	cmp	r3, #0
 800757a:	d009      	beq.n	8007590 <SX1276SetRx+0x2a4>
    {
        TimerSetValue( &RxTimeoutTimer, timeout );
 800757c:	687a      	ldr	r2, [r7, #4]
 800757e:	4b20      	ldr	r3, [pc, #128]	; (8007600 <SX1276SetRx+0x314>)
 8007580:	0011      	movs	r1, r2
 8007582:	0018      	movs	r0, r3
 8007584:	f013 fdd8 	bl	801b138 <TimerSetValue>
        TimerStart( &RxTimeoutTimer );
 8007588:	4b1d      	ldr	r3, [pc, #116]	; (8007600 <SX1276SetRx+0x314>)
 800758a:	0018      	movs	r0, r3
 800758c:	f013 fc7a 	bl	801ae84 <TimerStart>
    }

    if( SX1276.Settings.Modem == MODEM_FSK )
 8007590:	4b12      	ldr	r3, [pc, #72]	; (80075dc <SX1276SetRx+0x2f0>)
 8007592:	795b      	ldrb	r3, [r3, #5]
 8007594:	2b00      	cmp	r3, #0
 8007596:	d10e      	bne.n	80075b6 <SX1276SetRx+0x2ca>
    {
        SX1276SetOpMode( RF_OPMODE_RECEIVER );
 8007598:	2005      	movs	r0, #5
 800759a:	f000 f9bf 	bl	800791c <SX1276SetOpMode>

        TimerSetValue( &RxTimeoutSyncWord, SX1276.Settings.Fsk.RxSingleTimeout );
 800759e:	4b0f      	ldr	r3, [pc, #60]	; (80075dc <SX1276SetRx+0x2f0>)
 80075a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80075a2:	4b18      	ldr	r3, [pc, #96]	; (8007604 <SX1276SetRx+0x318>)
 80075a4:	0011      	movs	r1, r2
 80075a6:	0018      	movs	r0, r3
 80075a8:	f013 fdc6 	bl	801b138 <TimerSetValue>
        TimerStart( &RxTimeoutSyncWord );
 80075ac:	4b15      	ldr	r3, [pc, #84]	; (8007604 <SX1276SetRx+0x318>)
 80075ae:	0018      	movs	r0, r3
 80075b0:	f013 fc68 	bl	801ae84 <TimerStart>
        else
        {
            SX1276SetOpMode( RFLR_OPMODE_RECEIVER_SINGLE );
        }
    }
}
 80075b4:	e00b      	b.n	80075ce <SX1276SetRx+0x2e2>
        if( rxContinuous == true )
 80075b6:	230f      	movs	r3, #15
 80075b8:	18fb      	adds	r3, r7, r3
 80075ba:	781b      	ldrb	r3, [r3, #0]
 80075bc:	2b00      	cmp	r3, #0
 80075be:	d003      	beq.n	80075c8 <SX1276SetRx+0x2dc>
            SX1276SetOpMode( RFLR_OPMODE_RECEIVER );
 80075c0:	2005      	movs	r0, #5
 80075c2:	f000 f9ab 	bl	800791c <SX1276SetOpMode>
}
 80075c6:	e002      	b.n	80075ce <SX1276SetRx+0x2e2>
            SX1276SetOpMode( RFLR_OPMODE_RECEIVER_SINGLE );
 80075c8:	2006      	movs	r0, #6
 80075ca:	f000 f9a7 	bl	800791c <SX1276SetOpMode>
}
 80075ce:	46c0      	nop			; (mov r8, r8)
 80075d0:	46bd      	mov	sp, r7
 80075d2:	b004      	add	sp, #16
 80075d4:	bd80      	pop	{r7, pc}
 80075d6:	46c0      	nop			; (mov r8, r8)
 80075d8:	2000172c 	.word	0x2000172c
 80075dc:	2000175c 	.word	0x2000175c
 80075e0:	0801ede0 	.word	0x0801ede0
 80075e4:	00001e82 	.word	0x00001e82
 80075e8:	000028b4 	.word	0x000028b4
 80075ec:	00003d04 	.word	0x00003d04
 80075f0:	0000515e 	.word	0x0000515e
 80075f4:	00007a12 	.word	0x00007a12
 80075f8:	0000a2c6 	.word	0x0000a2c6
 80075fc:	20000354 	.word	0x20000354
 8007600:	200017c4 	.word	0x200017c4
 8007604:	20001744 	.word	0x20001744

08007608 <SX1276SetTx>:

void SX1276SetTx( uint32_t timeout )
{
 8007608:	b580      	push	{r7, lr}
 800760a:	b082      	sub	sp, #8
 800760c:	af00      	add	r7, sp, #0
 800760e:	6078      	str	r0, [r7, #4]
    TimerStop( &RxTimeoutTimer );
 8007610:	4b3a      	ldr	r3, [pc, #232]	; (80076fc <SX1276SetTx+0xf4>)
 8007612:	0018      	movs	r0, r3
 8007614:	f013 fd12 	bl	801b03c <TimerStop>

    TimerSetValue( &TxTimeoutTimer, timeout );
 8007618:	687a      	ldr	r2, [r7, #4]
 800761a:	4b39      	ldr	r3, [pc, #228]	; (8007700 <SX1276SetTx+0xf8>)
 800761c:	0011      	movs	r1, r2
 800761e:	0018      	movs	r0, r3
 8007620:	f013 fd8a 	bl	801b138 <TimerSetValue>

    switch( SX1276.Settings.Modem )
 8007624:	4b37      	ldr	r3, [pc, #220]	; (8007704 <SX1276SetTx+0xfc>)
 8007626:	795b      	ldrb	r3, [r3, #5]
 8007628:	2b00      	cmp	r3, #0
 800762a:	d002      	beq.n	8007632 <SX1276SetTx+0x2a>
 800762c:	2b01      	cmp	r3, #1
 800762e:	d028      	beq.n	8007682 <SX1276SetTx+0x7a>
 8007630:	e056      	b.n	80076e0 <SX1276SetTx+0xd8>
            // DIO1=FifoEmpty
            // DIO2=FifoFull
            // DIO3=FifoEmpty
            // DIO4=LowBat
            // DIO5=ModeReady
            SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RF_DIOMAPPING1_DIO0_MASK &
 8007632:	2040      	movs	r0, #64	; 0x40
 8007634:	f000 fa30 	bl	8007a98 <SX1276Read>
 8007638:	0003      	movs	r3, r0
 800763a:	b25b      	sxtb	r3, r3
                                                                            RF_DIOMAPPING1_DIO1_MASK &
 800763c:	2203      	movs	r2, #3
 800763e:	4013      	ands	r3, r2
 8007640:	b25b      	sxtb	r3, r3
                                                                            RF_DIOMAPPING1_DIO2_MASK ) |
 8007642:	2210      	movs	r2, #16
 8007644:	4313      	orrs	r3, r2
 8007646:	b25b      	sxtb	r3, r3
            SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RF_DIOMAPPING1_DIO0_MASK &
 8007648:	b2db      	uxtb	r3, r3
 800764a:	0019      	movs	r1, r3
 800764c:	2040      	movs	r0, #64	; 0x40
 800764e:	f000 fa0f 	bl	8007a70 <SX1276Write>
                                                                            RF_DIOMAPPING1_DIO1_01 );

            SX1276Write( REG_DIOMAPPING2, ( SX1276Read( REG_DIOMAPPING2 ) & RF_DIOMAPPING2_DIO4_MASK &
 8007652:	2041      	movs	r0, #65	; 0x41
 8007654:	f000 fa20 	bl	8007a98 <SX1276Read>
 8007658:	0003      	movs	r3, r0
 800765a:	001a      	movs	r2, r3
 800765c:	233e      	movs	r3, #62	; 0x3e
 800765e:	4013      	ands	r3, r2
 8007660:	b2db      	uxtb	r3, r3
 8007662:	0019      	movs	r1, r3
 8007664:	2041      	movs	r0, #65	; 0x41
 8007666:	f000 fa03 	bl	8007a70 <SX1276Write>
                                                                            RF_DIOMAPPING2_MAP_MASK ) );
            SX1276.Settings.FskPacketHandler.FifoThresh = SX1276Read( REG_FIFOTHRESH ) & 0x3F;
 800766a:	2035      	movs	r0, #53	; 0x35
 800766c:	f000 fa14 	bl	8007a98 <SX1276Read>
 8007670:	0003      	movs	r3, r0
 8007672:	001a      	movs	r2, r3
 8007674:	233f      	movs	r3, #63	; 0x3f
 8007676:	4013      	ands	r3, r2
 8007678:	b2d9      	uxtb	r1, r3
 800767a:	4b22      	ldr	r3, [pc, #136]	; (8007704 <SX1276SetTx+0xfc>)
 800767c:	223e      	movs	r2, #62	; 0x3e
 800767e:	5499      	strb	r1, [r3, r2]
        }
        break;
 8007680:	e02e      	b.n	80076e0 <SX1276SetTx+0xd8>
    case MODEM_LORA:
        {
            if( SX1276.Settings.LoRa.FreqHopOn == true )
 8007682:	4b20      	ldr	r3, [pc, #128]	; (8007704 <SX1276SetTx+0xfc>)
 8007684:	2253      	movs	r2, #83	; 0x53
 8007686:	5c9b      	ldrb	r3, [r3, r2]
 8007688:	2b00      	cmp	r3, #0
 800768a:	d014      	beq.n	80076b6 <SX1276SetTx+0xae>
            {
                SX1276Write( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
 800768c:	21f5      	movs	r1, #245	; 0xf5
 800768e:	2011      	movs	r0, #17
 8007690:	f000 f9ee 	bl	8007a70 <SX1276Write>
                                                  RFLR_IRQFLAGS_CADDONE |
                                                  //RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                                  RFLR_IRQFLAGS_CADDETECTED );

                // DIO0=TxDone, DIO2=FhssChangeChannel
                SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO0_MASK & RFLR_DIOMAPPING1_DIO2_MASK ) | RFLR_DIOMAPPING1_DIO0_01 | RFLR_DIOMAPPING1_DIO2_00 );
 8007694:	2040      	movs	r0, #64	; 0x40
 8007696:	f000 f9ff 	bl	8007a98 <SX1276Read>
 800769a:	0003      	movs	r3, r0
 800769c:	b25b      	sxtb	r3, r3
 800769e:	2233      	movs	r2, #51	; 0x33
 80076a0:	4013      	ands	r3, r2
 80076a2:	b25b      	sxtb	r3, r3
 80076a4:	2240      	movs	r2, #64	; 0x40
 80076a6:	4313      	orrs	r3, r2
 80076a8:	b25b      	sxtb	r3, r3
 80076aa:	b2db      	uxtb	r3, r3
 80076ac:	0019      	movs	r1, r3
 80076ae:	2040      	movs	r0, #64	; 0x40
 80076b0:	f000 f9de 	bl	8007a70 <SX1276Write>

                // DIO0=TxDone
                SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO0_MASK ) | RFLR_DIOMAPPING1_DIO0_01 );
            }
        }
        break;
 80076b4:	e013      	b.n	80076de <SX1276SetTx+0xd6>
                SX1276Write( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
 80076b6:	21f7      	movs	r1, #247	; 0xf7
 80076b8:	2011      	movs	r0, #17
 80076ba:	f000 f9d9 	bl	8007a70 <SX1276Write>
                SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO0_MASK ) | RFLR_DIOMAPPING1_DIO0_01 );
 80076be:	2040      	movs	r0, #64	; 0x40
 80076c0:	f000 f9ea 	bl	8007a98 <SX1276Read>
 80076c4:	0003      	movs	r3, r0
 80076c6:	b25b      	sxtb	r3, r3
 80076c8:	223f      	movs	r2, #63	; 0x3f
 80076ca:	4013      	ands	r3, r2
 80076cc:	b25b      	sxtb	r3, r3
 80076ce:	2240      	movs	r2, #64	; 0x40
 80076d0:	4313      	orrs	r3, r2
 80076d2:	b25b      	sxtb	r3, r3
 80076d4:	b2db      	uxtb	r3, r3
 80076d6:	0019      	movs	r1, r3
 80076d8:	2040      	movs	r0, #64	; 0x40
 80076da:	f000 f9c9 	bl	8007a70 <SX1276Write>
        break;
 80076de:	46c0      	nop			; (mov r8, r8)
    }

    SX1276.Settings.State = RF_TX_RUNNING;
 80076e0:	4b08      	ldr	r3, [pc, #32]	; (8007704 <SX1276SetTx+0xfc>)
 80076e2:	2202      	movs	r2, #2
 80076e4:	711a      	strb	r2, [r3, #4]
    TimerStart( &TxTimeoutTimer );
 80076e6:	4b06      	ldr	r3, [pc, #24]	; (8007700 <SX1276SetTx+0xf8>)
 80076e8:	0018      	movs	r0, r3
 80076ea:	f013 fbcb 	bl	801ae84 <TimerStart>
    SX1276SetOpMode( RF_OPMODE_TRANSMITTER );
 80076ee:	2003      	movs	r0, #3
 80076f0:	f000 f914 	bl	800791c <SX1276SetOpMode>
}
 80076f4:	46c0      	nop			; (mov r8, r8)
 80076f6:	46bd      	mov	sp, r7
 80076f8:	b002      	add	sp, #8
 80076fa:	bd80      	pop	{r7, pc}
 80076fc:	200017c4 	.word	0x200017c4
 8007700:	2000172c 	.word	0x2000172c
 8007704:	2000175c 	.word	0x2000175c

08007708 <SX1276StartCad>:

void SX1276StartCad( void )
{
 8007708:	b580      	push	{r7, lr}
 800770a:	af00      	add	r7, sp, #0
    switch( SX1276.Settings.Modem )
 800770c:	4b11      	ldr	r3, [pc, #68]	; (8007754 <SX1276StartCad+0x4c>)
 800770e:	795b      	ldrb	r3, [r3, #5]
 8007710:	2b00      	cmp	r3, #0
 8007712:	d01a      	beq.n	800774a <SX1276StartCad+0x42>
 8007714:	2b01      	cmp	r3, #1
 8007716:	d000      	beq.n	800771a <SX1276StartCad+0x12>
            SX1276.Settings.State = RF_CAD;
            SX1276SetOpMode( RFLR_OPMODE_CAD );
        }
        break;
    default:
        break;
 8007718:	e018      	b.n	800774c <SX1276StartCad+0x44>
            SX1276Write( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
 800771a:	21fa      	movs	r1, #250	; 0xfa
 800771c:	2011      	movs	r0, #17
 800771e:	f000 f9a7 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO3_MASK ) | RFLR_DIOMAPPING1_DIO3_00 );
 8007722:	2040      	movs	r0, #64	; 0x40
 8007724:	f000 f9b8 	bl	8007a98 <SX1276Read>
 8007728:	0003      	movs	r3, r0
 800772a:	001a      	movs	r2, r3
 800772c:	2303      	movs	r3, #3
 800772e:	439a      	bics	r2, r3
 8007730:	0013      	movs	r3, r2
 8007732:	b2db      	uxtb	r3, r3
 8007734:	0019      	movs	r1, r3
 8007736:	2040      	movs	r0, #64	; 0x40
 8007738:	f000 f99a 	bl	8007a70 <SX1276Write>
            SX1276.Settings.State = RF_CAD;
 800773c:	4b05      	ldr	r3, [pc, #20]	; (8007754 <SX1276StartCad+0x4c>)
 800773e:	2203      	movs	r2, #3
 8007740:	711a      	strb	r2, [r3, #4]
            SX1276SetOpMode( RFLR_OPMODE_CAD );
 8007742:	2007      	movs	r0, #7
 8007744:	f000 f8ea 	bl	800791c <SX1276SetOpMode>
        break;
 8007748:	e000      	b.n	800774c <SX1276StartCad+0x44>
        break;
 800774a:	46c0      	nop			; (mov r8, r8)
    }
}
 800774c:	46c0      	nop			; (mov r8, r8)
 800774e:	46bd      	mov	sp, r7
 8007750:	bd80      	pop	{r7, pc}
 8007752:	46c0      	nop			; (mov r8, r8)
 8007754:	2000175c 	.word	0x2000175c

08007758 <SX1276SetTxContinuousWave>:

void SX1276SetTxContinuousWave( uint32_t freq, int8_t power, uint16_t time )
{
 8007758:	b580      	push	{r7, lr}
 800775a:	b08e      	sub	sp, #56	; 0x38
 800775c:	af0a      	add	r7, sp, #40	; 0x28
 800775e:	6078      	str	r0, [r7, #4]
 8007760:	0008      	movs	r0, r1
 8007762:	0011      	movs	r1, r2
 8007764:	1cfb      	adds	r3, r7, #3
 8007766:	1c02      	adds	r2, r0, #0
 8007768:	701a      	strb	r2, [r3, #0]
 800776a:	003b      	movs	r3, r7
 800776c:	1c0a      	adds	r2, r1, #0
 800776e:	801a      	strh	r2, [r3, #0]
    uint32_t timeout = ( uint32_t )( time * 1000 );
 8007770:	003b      	movs	r3, r7
 8007772:	881a      	ldrh	r2, [r3, #0]
 8007774:	0013      	movs	r3, r2
 8007776:	015b      	lsls	r3, r3, #5
 8007778:	1a9b      	subs	r3, r3, r2
 800777a:	009b      	lsls	r3, r3, #2
 800777c:	189b      	adds	r3, r3, r2
 800777e:	00db      	lsls	r3, r3, #3
 8007780:	60fb      	str	r3, [r7, #12]

    SX1276SetChannel( freq );
 8007782:	687b      	ldr	r3, [r7, #4]
 8007784:	0018      	movs	r0, r3
 8007786:	f7fe fccd 	bl	8006124 <SX1276SetChannel>

    SX1276SetTxConfig( MODEM_FSK, power, 0, 0, 4800, 0, 5, false, false, 0, 0, 0, timeout );
 800778a:	1cfb      	adds	r3, r7, #3
 800778c:	2100      	movs	r1, #0
 800778e:	5659      	ldrsb	r1, [r3, r1]
 8007790:	68fb      	ldr	r3, [r7, #12]
 8007792:	9308      	str	r3, [sp, #32]
 8007794:	2300      	movs	r3, #0
 8007796:	9307      	str	r3, [sp, #28]
 8007798:	2300      	movs	r3, #0
 800779a:	9306      	str	r3, [sp, #24]
 800779c:	2300      	movs	r3, #0
 800779e:	9305      	str	r3, [sp, #20]
 80077a0:	2300      	movs	r3, #0
 80077a2:	9304      	str	r3, [sp, #16]
 80077a4:	2300      	movs	r3, #0
 80077a6:	9303      	str	r3, [sp, #12]
 80077a8:	2305      	movs	r3, #5
 80077aa:	9302      	str	r3, [sp, #8]
 80077ac:	2300      	movs	r3, #0
 80077ae:	9301      	str	r3, [sp, #4]
 80077b0:	2396      	movs	r3, #150	; 0x96
 80077b2:	015b      	lsls	r3, r3, #5
 80077b4:	9300      	str	r3, [sp, #0]
 80077b6:	2300      	movs	r3, #0
 80077b8:	2200      	movs	r2, #0
 80077ba:	2000      	movs	r0, #0
 80077bc:	f7ff f8d0 	bl	8006960 <SX1276SetTxConfig>

    SX1276Write( REG_PACKETCONFIG2, ( SX1276Read( REG_PACKETCONFIG2 ) & RF_PACKETCONFIG2_DATAMODE_MASK ) );
 80077c0:	2031      	movs	r0, #49	; 0x31
 80077c2:	f000 f969 	bl	8007a98 <SX1276Read>
 80077c6:	0003      	movs	r3, r0
 80077c8:	001a      	movs	r2, r3
 80077ca:	2340      	movs	r3, #64	; 0x40
 80077cc:	439a      	bics	r2, r3
 80077ce:	0013      	movs	r3, r2
 80077d0:	b2db      	uxtb	r3, r3
 80077d2:	0019      	movs	r1, r3
 80077d4:	2031      	movs	r0, #49	; 0x31
 80077d6:	f000 f94b 	bl	8007a70 <SX1276Write>
    // Disable radio interrupts
    SX1276Write( REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_11 | RF_DIOMAPPING1_DIO1_11 );
 80077da:	21f0      	movs	r1, #240	; 0xf0
 80077dc:	2040      	movs	r0, #64	; 0x40
 80077de:	f000 f947 	bl	8007a70 <SX1276Write>
    SX1276Write( REG_DIOMAPPING2, RF_DIOMAPPING2_DIO4_10 | RF_DIOMAPPING2_DIO5_10 );
 80077e2:	21a0      	movs	r1, #160	; 0xa0
 80077e4:	2041      	movs	r0, #65	; 0x41
 80077e6:	f000 f943 	bl	8007a70 <SX1276Write>

    TimerSetValue( &TxTimeoutTimer, timeout );
 80077ea:	68fa      	ldr	r2, [r7, #12]
 80077ec:	4b09      	ldr	r3, [pc, #36]	; (8007814 <SX1276SetTxContinuousWave+0xbc>)
 80077ee:	0011      	movs	r1, r2
 80077f0:	0018      	movs	r0, r3
 80077f2:	f013 fca1 	bl	801b138 <TimerSetValue>

    SX1276.Settings.State = RF_TX_RUNNING;
 80077f6:	4b08      	ldr	r3, [pc, #32]	; (8007818 <SX1276SetTxContinuousWave+0xc0>)
 80077f8:	2202      	movs	r2, #2
 80077fa:	711a      	strb	r2, [r3, #4]
    TimerStart( &TxTimeoutTimer );
 80077fc:	4b05      	ldr	r3, [pc, #20]	; (8007814 <SX1276SetTxContinuousWave+0xbc>)
 80077fe:	0018      	movs	r0, r3
 8007800:	f013 fb40 	bl	801ae84 <TimerStart>
    SX1276SetOpMode( RF_OPMODE_TRANSMITTER );
 8007804:	2003      	movs	r0, #3
 8007806:	f000 f889 	bl	800791c <SX1276SetOpMode>
}
 800780a:	46c0      	nop			; (mov r8, r8)
 800780c:	46bd      	mov	sp, r7
 800780e:	b004      	add	sp, #16
 8007810:	bd80      	pop	{r7, pc}
 8007812:	46c0      	nop			; (mov r8, r8)
 8007814:	2000172c 	.word	0x2000172c
 8007818:	2000175c 	.word	0x2000175c

0800781c <SX1276ReadRssi>:

int16_t SX1276ReadRssi( RadioModems_t modem )
{
 800781c:	b580      	push	{r7, lr}
 800781e:	b084      	sub	sp, #16
 8007820:	af00      	add	r7, sp, #0
 8007822:	0002      	movs	r2, r0
 8007824:	1dfb      	adds	r3, r7, #7
 8007826:	701a      	strb	r2, [r3, #0]
    int16_t rssi = 0;
 8007828:	230e      	movs	r3, #14
 800782a:	18fb      	adds	r3, r7, r3
 800782c:	2200      	movs	r2, #0
 800782e:	801a      	strh	r2, [r3, #0]

    switch( modem )
 8007830:	1dfb      	adds	r3, r7, #7
 8007832:	781b      	ldrb	r3, [r3, #0]
 8007834:	2b00      	cmp	r3, #0
 8007836:	d002      	beq.n	800783e <SX1276ReadRssi+0x22>
 8007838:	2b01      	cmp	r3, #1
 800783a:	d00d      	beq.n	8007858 <SX1276ReadRssi+0x3c>
 800783c:	e027      	b.n	800788e <SX1276ReadRssi+0x72>
    {
    case MODEM_FSK:
        rssi = -( SX1276Read( REG_RSSIVALUE ) >> 1 );
 800783e:	2011      	movs	r0, #17
 8007840:	f000 f92a 	bl	8007a98 <SX1276Read>
 8007844:	0003      	movs	r3, r0
 8007846:	085b      	lsrs	r3, r3, #1
 8007848:	b2db      	uxtb	r3, r3
 800784a:	b29b      	uxth	r3, r3
 800784c:	425b      	negs	r3, r3
 800784e:	b29a      	uxth	r2, r3
 8007850:	230e      	movs	r3, #14
 8007852:	18fb      	adds	r3, r7, r3
 8007854:	801a      	strh	r2, [r3, #0]
        break;
 8007856:	e020      	b.n	800789a <SX1276ReadRssi+0x7e>
    case MODEM_LORA:
        if( SX1276.Settings.Channel > RF_MID_BAND_THRESH )
 8007858:	4b14      	ldr	r3, [pc, #80]	; (80078ac <SX1276ReadRssi+0x90>)
 800785a:	689b      	ldr	r3, [r3, #8]
 800785c:	4a14      	ldr	r2, [pc, #80]	; (80078b0 <SX1276ReadRssi+0x94>)
 800785e:	4293      	cmp	r3, r2
 8007860:	d90a      	bls.n	8007878 <SX1276ReadRssi+0x5c>
        {
            rssi = RSSI_OFFSET_HF + SX1276Read( REG_LR_RSSIVALUE );
 8007862:	201b      	movs	r0, #27
 8007864:	f000 f918 	bl	8007a98 <SX1276Read>
 8007868:	0003      	movs	r3, r0
 800786a:	b29b      	uxth	r3, r3
 800786c:	3b9d      	subs	r3, #157	; 0x9d
 800786e:	b29a      	uxth	r2, r3
 8007870:	230e      	movs	r3, #14
 8007872:	18fb      	adds	r3, r7, r3
 8007874:	801a      	strh	r2, [r3, #0]
        }
        else
        {
            rssi = RSSI_OFFSET_LF + SX1276Read( REG_LR_RSSIVALUE );
        }
        break;
 8007876:	e010      	b.n	800789a <SX1276ReadRssi+0x7e>
            rssi = RSSI_OFFSET_LF + SX1276Read( REG_LR_RSSIVALUE );
 8007878:	201b      	movs	r0, #27
 800787a:	f000 f90d 	bl	8007a98 <SX1276Read>
 800787e:	0003      	movs	r3, r0
 8007880:	b29b      	uxth	r3, r3
 8007882:	3ba4      	subs	r3, #164	; 0xa4
 8007884:	b29a      	uxth	r2, r3
 8007886:	230e      	movs	r3, #14
 8007888:	18fb      	adds	r3, r7, r3
 800788a:	801a      	strh	r2, [r3, #0]
        break;
 800788c:	e005      	b.n	800789a <SX1276ReadRssi+0x7e>
    default:
        rssi = -1;
 800788e:	230e      	movs	r3, #14
 8007890:	18fb      	adds	r3, r7, r3
 8007892:	2201      	movs	r2, #1
 8007894:	4252      	negs	r2, r2
 8007896:	801a      	strh	r2, [r3, #0]
        break;
 8007898:	46c0      	nop			; (mov r8, r8)
    }
    return rssi;
 800789a:	230e      	movs	r3, #14
 800789c:	18fb      	adds	r3, r7, r3
 800789e:	2200      	movs	r2, #0
 80078a0:	5e9b      	ldrsh	r3, [r3, r2]
}
 80078a2:	0018      	movs	r0, r3
 80078a4:	46bd      	mov	sp, r7
 80078a6:	b004      	add	sp, #16
 80078a8:	bd80      	pop	{r7, pc}
 80078aa:	46c0      	nop			; (mov r8, r8)
 80078ac:	2000175c 	.word	0x2000175c
 80078b0:	1f4add40 	.word	0x1f4add40

080078b4 <SX1276Reset>:

void SX1276Reset( void )
{
 80078b4:	b580      	push	{r7, lr}
 80078b6:	b086      	sub	sp, #24
 80078b8:	af00      	add	r7, sp, #0
    GPIO_InitTypeDef initStruct = { 0 };
 80078ba:	1d3b      	adds	r3, r7, #4
 80078bc:	0018      	movs	r0, r3
 80078be:	2314      	movs	r3, #20
 80078c0:	001a      	movs	r2, r3
 80078c2:	2100      	movs	r1, #0
 80078c4:	f015 fe46 	bl	801d554 <memset>

    initStruct.Mode =GPIO_MODE_OUTPUT_PP;
 80078c8:	1d3b      	adds	r3, r7, #4
 80078ca:	2201      	movs	r2, #1
 80078cc:	605a      	str	r2, [r3, #4]
    initStruct.Pull = GPIO_NOPULL;
 80078ce:	1d3b      	adds	r3, r7, #4
 80078d0:	2200      	movs	r2, #0
 80078d2:	609a      	str	r2, [r3, #8]
    initStruct.Speed = GPIO_SPEED_HIGH;
 80078d4:	1d3b      	adds	r3, r7, #4
 80078d6:	2203      	movs	r2, #3
 80078d8:	60da      	str	r2, [r3, #12]

    // Set RESET pin to 0
    HW_GPIO_Init( RADIO_RESET_PORT, RADIO_RESET_PIN, &initStruct );
 80078da:	1d3b      	adds	r3, r7, #4
 80078dc:	480e      	ldr	r0, [pc, #56]	; (8007918 <SX1276Reset+0x64>)
 80078de:	001a      	movs	r2, r3
 80078e0:	2101      	movs	r1, #1
 80078e2:	f013 ff5f 	bl	801b7a4 <HW_GPIO_Init>
    HW_GPIO_Write( RADIO_RESET_PORT, RADIO_RESET_PIN, 0 );
 80078e6:	4b0c      	ldr	r3, [pc, #48]	; (8007918 <SX1276Reset+0x64>)
 80078e8:	2200      	movs	r2, #0
 80078ea:	2101      	movs	r1, #1
 80078ec:	0018      	movs	r0, r3
 80078ee:	f014 f82b 	bl	801b948 <HW_GPIO_Write>

    // Wait 1 ms
    DelayMs( 1 );
 80078f2:	2001      	movs	r0, #1
 80078f4:	f015 f8d0 	bl	801ca98 <HAL_Delay>

    // Configure RESET as input
    initStruct.Mode = GPIO_NOPULL;
 80078f8:	1d3b      	adds	r3, r7, #4
 80078fa:	2200      	movs	r2, #0
 80078fc:	605a      	str	r2, [r3, #4]
    HW_GPIO_Init( RADIO_RESET_PORT, RADIO_RESET_PIN, &initStruct );
 80078fe:	1d3b      	adds	r3, r7, #4
 8007900:	4805      	ldr	r0, [pc, #20]	; (8007918 <SX1276Reset+0x64>)
 8007902:	001a      	movs	r2, r3
 8007904:	2101      	movs	r1, #1
 8007906:	f013 ff4d 	bl	801b7a4 <HW_GPIO_Init>

    // Wait 6 ms
    DelayMs( 6 );
 800790a:	2006      	movs	r0, #6
 800790c:	f015 f8c4 	bl	801ca98 <HAL_Delay>
}
 8007910:	46c0      	nop			; (mov r8, r8)
 8007912:	46bd      	mov	sp, r7
 8007914:	b006      	add	sp, #24
 8007916:	bd80      	pop	{r7, pc}
 8007918:	50000800 	.word	0x50000800

0800791c <SX1276SetOpMode>:

void SX1276SetOpMode( uint8_t opMode )
{
 800791c:	b580      	push	{r7, lr}
 800791e:	b082      	sub	sp, #8
 8007920:	af00      	add	r7, sp, #0
 8007922:	0002      	movs	r2, r0
 8007924:	1dfb      	adds	r3, r7, #7
 8007926:	701a      	strb	r2, [r3, #0]
    if( opMode == RF_OPMODE_SLEEP )
 8007928:	1dfb      	adds	r3, r7, #7
 800792a:	781b      	ldrb	r3, [r3, #0]
 800792c:	2b00      	cmp	r3, #0
 800792e:	d11c      	bne.n	800796a <SX1276SetOpMode+0x4e>
    {
      SX1276Write( REG_OPMODE, ( SX1276Read( REG_OPMODE ) & RF_OPMODE_MASK ) | opMode );
 8007930:	2001      	movs	r0, #1
 8007932:	f000 f8b1 	bl	8007a98 <SX1276Read>
 8007936:	0003      	movs	r3, r0
 8007938:	b25b      	sxtb	r3, r3
 800793a:	2207      	movs	r2, #7
 800793c:	4393      	bics	r3, r2
 800793e:	b25a      	sxtb	r2, r3
 8007940:	1dfb      	adds	r3, r7, #7
 8007942:	781b      	ldrb	r3, [r3, #0]
 8007944:	b25b      	sxtb	r3, r3
 8007946:	4313      	orrs	r3, r2
 8007948:	b25b      	sxtb	r3, r3
 800794a:	b2db      	uxtb	r3, r3
 800794c:	0019      	movs	r1, r3
 800794e:	2001      	movs	r0, #1
 8007950:	f000 f88e 	bl	8007a70 <SX1276Write>
      
      LoRaBoardCallbacks->SX1276BoardSetAntSwLowPower( true );
 8007954:	4b18      	ldr	r3, [pc, #96]	; (80079b8 <SX1276SetOpMode+0x9c>)
 8007956:	681b      	ldr	r3, [r3, #0]
 8007958:	691b      	ldr	r3, [r3, #16]
 800795a:	2001      	movs	r0, #1
 800795c:	4798      	blx	r3
      
      LoRaBoardCallbacks->SX1276BoardSetXO( RESET ); 
 800795e:	4b16      	ldr	r3, [pc, #88]	; (80079b8 <SX1276SetOpMode+0x9c>)
 8007960:	681b      	ldr	r3, [r3, #0]
 8007962:	681b      	ldr	r3, [r3, #0]
 8007964:	2000      	movs	r0, #0
 8007966:	4798      	blx	r3
      
      LoRaBoardCallbacks->SX1276BoardSetAntSw( opMode );
      
      SX1276Write( REG_OPMODE, ( SX1276Read( REG_OPMODE ) & RF_OPMODE_MASK ) | opMode );
    }
}
 8007968:	e022      	b.n	80079b0 <SX1276SetOpMode+0x94>
      LoRaBoardCallbacks->SX1276BoardSetXO( SET ); 
 800796a:	4b13      	ldr	r3, [pc, #76]	; (80079b8 <SX1276SetOpMode+0x9c>)
 800796c:	681b      	ldr	r3, [r3, #0]
 800796e:	681b      	ldr	r3, [r3, #0]
 8007970:	2001      	movs	r0, #1
 8007972:	4798      	blx	r3
      LoRaBoardCallbacks->SX1276BoardSetAntSwLowPower( false );
 8007974:	4b10      	ldr	r3, [pc, #64]	; (80079b8 <SX1276SetOpMode+0x9c>)
 8007976:	681b      	ldr	r3, [r3, #0]
 8007978:	691b      	ldr	r3, [r3, #16]
 800797a:	2000      	movs	r0, #0
 800797c:	4798      	blx	r3
      LoRaBoardCallbacks->SX1276BoardSetAntSw( opMode );
 800797e:	4b0e      	ldr	r3, [pc, #56]	; (80079b8 <SX1276SetOpMode+0x9c>)
 8007980:	681b      	ldr	r3, [r3, #0]
 8007982:	695b      	ldr	r3, [r3, #20]
 8007984:	1dfa      	adds	r2, r7, #7
 8007986:	7812      	ldrb	r2, [r2, #0]
 8007988:	0010      	movs	r0, r2
 800798a:	4798      	blx	r3
      SX1276Write( REG_OPMODE, ( SX1276Read( REG_OPMODE ) & RF_OPMODE_MASK ) | opMode );
 800798c:	2001      	movs	r0, #1
 800798e:	f000 f883 	bl	8007a98 <SX1276Read>
 8007992:	0003      	movs	r3, r0
 8007994:	b25b      	sxtb	r3, r3
 8007996:	2207      	movs	r2, #7
 8007998:	4393      	bics	r3, r2
 800799a:	b25a      	sxtb	r2, r3
 800799c:	1dfb      	adds	r3, r7, #7
 800799e:	781b      	ldrb	r3, [r3, #0]
 80079a0:	b25b      	sxtb	r3, r3
 80079a2:	4313      	orrs	r3, r2
 80079a4:	b25b      	sxtb	r3, r3
 80079a6:	b2db      	uxtb	r3, r3
 80079a8:	0019      	movs	r1, r3
 80079aa:	2001      	movs	r0, #1
 80079ac:	f000 f860 	bl	8007a70 <SX1276Write>
}
 80079b0:	46c0      	nop			; (mov r8, r8)
 80079b2:	46bd      	mov	sp, r7
 80079b4:	b002      	add	sp, #8
 80079b6:	bd80      	pop	{r7, pc}
 80079b8:	20000454 	.word	0x20000454

080079bc <SX1276SetModem>:

void SX1276SetModem( RadioModems_t modem )
{
 80079bc:	b580      	push	{r7, lr}
 80079be:	b082      	sub	sp, #8
 80079c0:	af00      	add	r7, sp, #0
 80079c2:	0002      	movs	r2, r0
 80079c4:	1dfb      	adds	r3, r7, #7
 80079c6:	701a      	strb	r2, [r3, #0]
    if( ( SX1276Read( REG_OPMODE ) & RFLR_OPMODE_LONGRANGEMODE_ON ) != 0 )
 80079c8:	2001      	movs	r0, #1
 80079ca:	f000 f865 	bl	8007a98 <SX1276Read>
 80079ce:	0003      	movs	r3, r0
 80079d0:	b25b      	sxtb	r3, r3
 80079d2:	2b00      	cmp	r3, #0
 80079d4:	da03      	bge.n	80079de <SX1276SetModem+0x22>
    {
        SX1276.Settings.Modem = MODEM_LORA;
 80079d6:	4b25      	ldr	r3, [pc, #148]	; (8007a6c <SX1276SetModem+0xb0>)
 80079d8:	2201      	movs	r2, #1
 80079da:	715a      	strb	r2, [r3, #5]
 80079dc:	e002      	b.n	80079e4 <SX1276SetModem+0x28>
    }
    else
    {
        SX1276.Settings.Modem = MODEM_FSK;
 80079de:	4b23      	ldr	r3, [pc, #140]	; (8007a6c <SX1276SetModem+0xb0>)
 80079e0:	2200      	movs	r2, #0
 80079e2:	715a      	strb	r2, [r3, #5]
    }

    if( SX1276.Settings.Modem == modem )
 80079e4:	4b21      	ldr	r3, [pc, #132]	; (8007a6c <SX1276SetModem+0xb0>)
 80079e6:	795b      	ldrb	r3, [r3, #5]
 80079e8:	1dfa      	adds	r2, r7, #7
 80079ea:	7812      	ldrb	r2, [r2, #0]
 80079ec:	429a      	cmp	r2, r3
 80079ee:	d038      	beq.n	8007a62 <SX1276SetModem+0xa6>
    {
        return;
    }

    SX1276.Settings.Modem = modem;
 80079f0:	4b1e      	ldr	r3, [pc, #120]	; (8007a6c <SX1276SetModem+0xb0>)
 80079f2:	1dfa      	adds	r2, r7, #7
 80079f4:	7812      	ldrb	r2, [r2, #0]
 80079f6:	715a      	strb	r2, [r3, #5]
    switch( SX1276.Settings.Modem )
 80079f8:	4b1c      	ldr	r3, [pc, #112]	; (8007a6c <SX1276SetModem+0xb0>)
 80079fa:	795b      	ldrb	r3, [r3, #5]
 80079fc:	2b01      	cmp	r3, #1
 80079fe:	d017      	beq.n	8007a30 <SX1276SetModem+0x74>
    {
    default:
    case MODEM_FSK:
        SX1276SetOpMode( RF_OPMODE_SLEEP );
 8007a00:	2000      	movs	r0, #0
 8007a02:	f7ff ff8b 	bl	800791c <SX1276SetOpMode>
        SX1276Write( REG_OPMODE, ( SX1276Read( REG_OPMODE ) & RFLR_OPMODE_LONGRANGEMODE_MASK ) | RFLR_OPMODE_LONGRANGEMODE_OFF );
 8007a06:	2001      	movs	r0, #1
 8007a08:	f000 f846 	bl	8007a98 <SX1276Read>
 8007a0c:	0003      	movs	r3, r0
 8007a0e:	001a      	movs	r2, r3
 8007a10:	237f      	movs	r3, #127	; 0x7f
 8007a12:	4013      	ands	r3, r2
 8007a14:	b2db      	uxtb	r3, r3
 8007a16:	0019      	movs	r1, r3
 8007a18:	2001      	movs	r0, #1
 8007a1a:	f000 f829 	bl	8007a70 <SX1276Write>

        SX1276Write( REG_DIOMAPPING1, 0x00 );
 8007a1e:	2100      	movs	r1, #0
 8007a20:	2040      	movs	r0, #64	; 0x40
 8007a22:	f000 f825 	bl	8007a70 <SX1276Write>
        SX1276Write( REG_DIOMAPPING2, 0x30 ); // DIO5=ModeReady
 8007a26:	2130      	movs	r1, #48	; 0x30
 8007a28:	2041      	movs	r0, #65	; 0x41
 8007a2a:	f000 f821 	bl	8007a70 <SX1276Write>
        break;
 8007a2e:	e019      	b.n	8007a64 <SX1276SetModem+0xa8>
    case MODEM_LORA:
        SX1276SetOpMode( RF_OPMODE_SLEEP );
 8007a30:	2000      	movs	r0, #0
 8007a32:	f7ff ff73 	bl	800791c <SX1276SetOpMode>
        SX1276Write( REG_OPMODE, ( SX1276Read( REG_OPMODE ) & RFLR_OPMODE_LONGRANGEMODE_MASK ) | RFLR_OPMODE_LONGRANGEMODE_ON );
 8007a36:	2001      	movs	r0, #1
 8007a38:	f000 f82e 	bl	8007a98 <SX1276Read>
 8007a3c:	0003      	movs	r3, r0
 8007a3e:	001a      	movs	r2, r3
 8007a40:	2380      	movs	r3, #128	; 0x80
 8007a42:	425b      	negs	r3, r3
 8007a44:	4313      	orrs	r3, r2
 8007a46:	b2db      	uxtb	r3, r3
 8007a48:	0019      	movs	r1, r3
 8007a4a:	2001      	movs	r0, #1
 8007a4c:	f000 f810 	bl	8007a70 <SX1276Write>

        SX1276Write( REG_DIOMAPPING1, 0x00 );
 8007a50:	2100      	movs	r1, #0
 8007a52:	2040      	movs	r0, #64	; 0x40
 8007a54:	f000 f80c 	bl	8007a70 <SX1276Write>
        SX1276Write( REG_DIOMAPPING2, 0x00 );
 8007a58:	2100      	movs	r1, #0
 8007a5a:	2041      	movs	r0, #65	; 0x41
 8007a5c:	f000 f808 	bl	8007a70 <SX1276Write>
        break;
 8007a60:	e000      	b.n	8007a64 <SX1276SetModem+0xa8>
        return;
 8007a62:	46c0      	nop			; (mov r8, r8)
    }
}
 8007a64:	46bd      	mov	sp, r7
 8007a66:	b002      	add	sp, #8
 8007a68:	bd80      	pop	{r7, pc}
 8007a6a:	46c0      	nop			; (mov r8, r8)
 8007a6c:	2000175c 	.word	0x2000175c

08007a70 <SX1276Write>:

void SX1276Write( uint16_t addr, uint8_t data )
{
 8007a70:	b580      	push	{r7, lr}
 8007a72:	b082      	sub	sp, #8
 8007a74:	af00      	add	r7, sp, #0
 8007a76:	0002      	movs	r2, r0
 8007a78:	1dbb      	adds	r3, r7, #6
 8007a7a:	801a      	strh	r2, [r3, #0]
 8007a7c:	1d7b      	adds	r3, r7, #5
 8007a7e:	1c0a      	adds	r2, r1, #0
 8007a80:	701a      	strb	r2, [r3, #0]
    SX1276WriteBuffer( addr, &data, 1 );
 8007a82:	1d79      	adds	r1, r7, #5
 8007a84:	1dbb      	adds	r3, r7, #6
 8007a86:	881b      	ldrh	r3, [r3, #0]
 8007a88:	2201      	movs	r2, #1
 8007a8a:	0018      	movs	r0, r3
 8007a8c:	f000 f818 	bl	8007ac0 <SX1276WriteBuffer>
}
 8007a90:	46c0      	nop			; (mov r8, r8)
 8007a92:	46bd      	mov	sp, r7
 8007a94:	b002      	add	sp, #8
 8007a96:	bd80      	pop	{r7, pc}

08007a98 <SX1276Read>:

uint8_t SX1276Read( uint16_t addr )
{
 8007a98:	b590      	push	{r4, r7, lr}
 8007a9a:	b085      	sub	sp, #20
 8007a9c:	af00      	add	r7, sp, #0
 8007a9e:	0002      	movs	r2, r0
 8007aa0:	1dbb      	adds	r3, r7, #6
 8007aa2:	801a      	strh	r2, [r3, #0]
    uint8_t data;
    SX1276ReadBuffer( addr, &data, 1 );
 8007aa4:	240f      	movs	r4, #15
 8007aa6:	1939      	adds	r1, r7, r4
 8007aa8:	1dbb      	adds	r3, r7, #6
 8007aaa:	881b      	ldrh	r3, [r3, #0]
 8007aac:	2201      	movs	r2, #1
 8007aae:	0018      	movs	r0, r3
 8007ab0:	f000 f848 	bl	8007b44 <SX1276ReadBuffer>
    return data;
 8007ab4:	193b      	adds	r3, r7, r4
 8007ab6:	781b      	ldrb	r3, [r3, #0]
}
 8007ab8:	0018      	movs	r0, r3
 8007aba:	46bd      	mov	sp, r7
 8007abc:	b005      	add	sp, #20
 8007abe:	bd90      	pop	{r4, r7, pc}

08007ac0 <SX1276WriteBuffer>:

void SX1276WriteBuffer( uint16_t addr, uint8_t *buffer, uint8_t size )
{
 8007ac0:	b590      	push	{r4, r7, lr}
 8007ac2:	b085      	sub	sp, #20
 8007ac4:	af00      	add	r7, sp, #0
 8007ac6:	6039      	str	r1, [r7, #0]
 8007ac8:	0011      	movs	r1, r2
 8007aca:	1dbb      	adds	r3, r7, #6
 8007acc:	1c02      	adds	r2, r0, #0
 8007ace:	801a      	strh	r2, [r3, #0]
 8007ad0:	1d7b      	adds	r3, r7, #5
 8007ad2:	1c0a      	adds	r2, r1, #0
 8007ad4:	701a      	strb	r2, [r3, #0]
    uint8_t i;

    //NSS = 0;
    HW_GPIO_Write( RADIO_NSS_PORT, RADIO_NSS_PIN, 0 );
 8007ad6:	2380      	movs	r3, #128	; 0x80
 8007ad8:	0219      	lsls	r1, r3, #8
 8007ada:	23a0      	movs	r3, #160	; 0xa0
 8007adc:	05db      	lsls	r3, r3, #23
 8007ade:	2200      	movs	r2, #0
 8007ae0:	0018      	movs	r0, r3
 8007ae2:	f013 ff31 	bl	801b948 <HW_GPIO_Write>

    HW_SPI_InOut( addr | 0x80 );
 8007ae6:	1dbb      	adds	r3, r7, #6
 8007ae8:	881b      	ldrh	r3, [r3, #0]
 8007aea:	2280      	movs	r2, #128	; 0x80
 8007aec:	4313      	orrs	r3, r2
 8007aee:	b29b      	uxth	r3, r3
 8007af0:	0018      	movs	r0, r3
 8007af2:	f014 fc41 	bl	801c378 <HW_SPI_InOut>
    for( i = 0; i < size; i++ )
 8007af6:	230f      	movs	r3, #15
 8007af8:	18fb      	adds	r3, r7, r3
 8007afa:	2200      	movs	r2, #0
 8007afc:	701a      	strb	r2, [r3, #0]
 8007afe:	e00e      	b.n	8007b1e <SX1276WriteBuffer+0x5e>
    {
        HW_SPI_InOut( buffer[i] );
 8007b00:	240f      	movs	r4, #15
 8007b02:	193b      	adds	r3, r7, r4
 8007b04:	781b      	ldrb	r3, [r3, #0]
 8007b06:	683a      	ldr	r2, [r7, #0]
 8007b08:	18d3      	adds	r3, r2, r3
 8007b0a:	781b      	ldrb	r3, [r3, #0]
 8007b0c:	b29b      	uxth	r3, r3
 8007b0e:	0018      	movs	r0, r3
 8007b10:	f014 fc32 	bl	801c378 <HW_SPI_InOut>
    for( i = 0; i < size; i++ )
 8007b14:	193b      	adds	r3, r7, r4
 8007b16:	781a      	ldrb	r2, [r3, #0]
 8007b18:	193b      	adds	r3, r7, r4
 8007b1a:	3201      	adds	r2, #1
 8007b1c:	701a      	strb	r2, [r3, #0]
 8007b1e:	230f      	movs	r3, #15
 8007b20:	18fa      	adds	r2, r7, r3
 8007b22:	1d7b      	adds	r3, r7, #5
 8007b24:	7812      	ldrb	r2, [r2, #0]
 8007b26:	781b      	ldrb	r3, [r3, #0]
 8007b28:	429a      	cmp	r2, r3
 8007b2a:	d3e9      	bcc.n	8007b00 <SX1276WriteBuffer+0x40>
    }

    //NSS = 1;
    HW_GPIO_Write( RADIO_NSS_PORT, RADIO_NSS_PIN, 1 );
 8007b2c:	2380      	movs	r3, #128	; 0x80
 8007b2e:	0219      	lsls	r1, r3, #8
 8007b30:	23a0      	movs	r3, #160	; 0xa0
 8007b32:	05db      	lsls	r3, r3, #23
 8007b34:	2201      	movs	r2, #1
 8007b36:	0018      	movs	r0, r3
 8007b38:	f013 ff06 	bl	801b948 <HW_GPIO_Write>
}
 8007b3c:	46c0      	nop			; (mov r8, r8)
 8007b3e:	46bd      	mov	sp, r7
 8007b40:	b005      	add	sp, #20
 8007b42:	bd90      	pop	{r4, r7, pc}

08007b44 <SX1276ReadBuffer>:

void SX1276ReadBuffer( uint16_t addr, uint8_t *buffer, uint8_t size )
{
 8007b44:	b580      	push	{r7, lr}
 8007b46:	b084      	sub	sp, #16
 8007b48:	af00      	add	r7, sp, #0
 8007b4a:	6039      	str	r1, [r7, #0]
 8007b4c:	0011      	movs	r1, r2
 8007b4e:	1dbb      	adds	r3, r7, #6
 8007b50:	1c02      	adds	r2, r0, #0
 8007b52:	801a      	strh	r2, [r3, #0]
 8007b54:	1d7b      	adds	r3, r7, #5
 8007b56:	1c0a      	adds	r2, r1, #0
 8007b58:	701a      	strb	r2, [r3, #0]
    uint8_t i;

    //NSS = 0;
    HW_GPIO_Write( RADIO_NSS_PORT, RADIO_NSS_PIN, 0 );
 8007b5a:	2380      	movs	r3, #128	; 0x80
 8007b5c:	0219      	lsls	r1, r3, #8
 8007b5e:	23a0      	movs	r3, #160	; 0xa0
 8007b60:	05db      	lsls	r3, r3, #23
 8007b62:	2200      	movs	r2, #0
 8007b64:	0018      	movs	r0, r3
 8007b66:	f013 feef 	bl	801b948 <HW_GPIO_Write>

    HW_SPI_InOut( addr & 0x7F );
 8007b6a:	1dbb      	adds	r3, r7, #6
 8007b6c:	881b      	ldrh	r3, [r3, #0]
 8007b6e:	227f      	movs	r2, #127	; 0x7f
 8007b70:	4013      	ands	r3, r2
 8007b72:	b29b      	uxth	r3, r3
 8007b74:	0018      	movs	r0, r3
 8007b76:	f014 fbff 	bl	801c378 <HW_SPI_InOut>

    for( i = 0; i < size; i++ )
 8007b7a:	230f      	movs	r3, #15
 8007b7c:	18fb      	adds	r3, r7, r3
 8007b7e:	2200      	movs	r2, #0
 8007b80:	701a      	strb	r2, [r3, #0]
 8007b82:	e010      	b.n	8007ba6 <SX1276ReadBuffer+0x62>
    {
        buffer[i] = HW_SPI_InOut( 0 );
 8007b84:	2000      	movs	r0, #0
 8007b86:	f014 fbf7 	bl	801c378 <HW_SPI_InOut>
 8007b8a:	0003      	movs	r3, r0
 8007b8c:	0019      	movs	r1, r3
 8007b8e:	200f      	movs	r0, #15
 8007b90:	183b      	adds	r3, r7, r0
 8007b92:	781b      	ldrb	r3, [r3, #0]
 8007b94:	683a      	ldr	r2, [r7, #0]
 8007b96:	18d3      	adds	r3, r2, r3
 8007b98:	b2ca      	uxtb	r2, r1
 8007b9a:	701a      	strb	r2, [r3, #0]
    for( i = 0; i < size; i++ )
 8007b9c:	183b      	adds	r3, r7, r0
 8007b9e:	781a      	ldrb	r2, [r3, #0]
 8007ba0:	183b      	adds	r3, r7, r0
 8007ba2:	3201      	adds	r2, #1
 8007ba4:	701a      	strb	r2, [r3, #0]
 8007ba6:	230f      	movs	r3, #15
 8007ba8:	18fa      	adds	r2, r7, r3
 8007baa:	1d7b      	adds	r3, r7, #5
 8007bac:	7812      	ldrb	r2, [r2, #0]
 8007bae:	781b      	ldrb	r3, [r3, #0]
 8007bb0:	429a      	cmp	r2, r3
 8007bb2:	d3e7      	bcc.n	8007b84 <SX1276ReadBuffer+0x40>
    }

    //NSS = 1;
    HW_GPIO_Write( RADIO_NSS_PORT, RADIO_NSS_PIN, 1 );
 8007bb4:	2380      	movs	r3, #128	; 0x80
 8007bb6:	0219      	lsls	r1, r3, #8
 8007bb8:	23a0      	movs	r3, #160	; 0xa0
 8007bba:	05db      	lsls	r3, r3, #23
 8007bbc:	2201      	movs	r2, #1
 8007bbe:	0018      	movs	r0, r3
 8007bc0:	f013 fec2 	bl	801b948 <HW_GPIO_Write>
}
 8007bc4:	46c0      	nop			; (mov r8, r8)
 8007bc6:	46bd      	mov	sp, r7
 8007bc8:	b004      	add	sp, #16
 8007bca:	bd80      	pop	{r7, pc}

08007bcc <SX1276WriteFifo>:

void SX1276WriteFifo( uint8_t *buffer, uint8_t size )
{
 8007bcc:	b580      	push	{r7, lr}
 8007bce:	b082      	sub	sp, #8
 8007bd0:	af00      	add	r7, sp, #0
 8007bd2:	6078      	str	r0, [r7, #4]
 8007bd4:	000a      	movs	r2, r1
 8007bd6:	1cfb      	adds	r3, r7, #3
 8007bd8:	701a      	strb	r2, [r3, #0]
    SX1276WriteBuffer( 0, buffer, size );
 8007bda:	1cfb      	adds	r3, r7, #3
 8007bdc:	781a      	ldrb	r2, [r3, #0]
 8007bde:	687b      	ldr	r3, [r7, #4]
 8007be0:	0019      	movs	r1, r3
 8007be2:	2000      	movs	r0, #0
 8007be4:	f7ff ff6c 	bl	8007ac0 <SX1276WriteBuffer>
}
 8007be8:	46c0      	nop			; (mov r8, r8)
 8007bea:	46bd      	mov	sp, r7
 8007bec:	b002      	add	sp, #8
 8007bee:	bd80      	pop	{r7, pc}

08007bf0 <SX1276ReadFifo>:

void SX1276ReadFifo( uint8_t *buffer, uint8_t size )
{
 8007bf0:	b580      	push	{r7, lr}
 8007bf2:	b082      	sub	sp, #8
 8007bf4:	af00      	add	r7, sp, #0
 8007bf6:	6078      	str	r0, [r7, #4]
 8007bf8:	000a      	movs	r2, r1
 8007bfa:	1cfb      	adds	r3, r7, #3
 8007bfc:	701a      	strb	r2, [r3, #0]
    SX1276ReadBuffer( 0, buffer, size );
 8007bfe:	1cfb      	adds	r3, r7, #3
 8007c00:	781a      	ldrb	r2, [r3, #0]
 8007c02:	687b      	ldr	r3, [r7, #4]
 8007c04:	0019      	movs	r1, r3
 8007c06:	2000      	movs	r0, #0
 8007c08:	f7ff ff9c 	bl	8007b44 <SX1276ReadBuffer>
}
 8007c0c:	46c0      	nop			; (mov r8, r8)
 8007c0e:	46bd      	mov	sp, r7
 8007c10:	b002      	add	sp, #8
 8007c12:	bd80      	pop	{r7, pc}

08007c14 <SX1276SetMaxPayloadLength>:

void SX1276SetMaxPayloadLength( RadioModems_t modem, uint8_t max )
{
 8007c14:	b580      	push	{r7, lr}
 8007c16:	b082      	sub	sp, #8
 8007c18:	af00      	add	r7, sp, #0
 8007c1a:	0002      	movs	r2, r0
 8007c1c:	1dfb      	adds	r3, r7, #7
 8007c1e:	701a      	strb	r2, [r3, #0]
 8007c20:	1dbb      	adds	r3, r7, #6
 8007c22:	1c0a      	adds	r2, r1, #0
 8007c24:	701a      	strb	r2, [r3, #0]
    SX1276SetModem( modem );
 8007c26:	1dfb      	adds	r3, r7, #7
 8007c28:	781b      	ldrb	r3, [r3, #0]
 8007c2a:	0018      	movs	r0, r3
 8007c2c:	f7ff fec6 	bl	80079bc <SX1276SetModem>

    switch( modem )
 8007c30:	1dfb      	adds	r3, r7, #7
 8007c32:	781b      	ldrb	r3, [r3, #0]
 8007c34:	2b00      	cmp	r3, #0
 8007c36:	d002      	beq.n	8007c3e <SX1276SetMaxPayloadLength+0x2a>
 8007c38:	2b01      	cmp	r3, #1
 8007c3a:	d00f      	beq.n	8007c5c <SX1276SetMaxPayloadLength+0x48>
        break;
    case MODEM_LORA:
        SX1276Write( REG_LR_PAYLOADMAXLENGTH, max );
        break;
    }
}
 8007c3c:	e016      	b.n	8007c6c <SX1276SetMaxPayloadLength+0x58>
        if( SX1276.Settings.Fsk.FixLen == false )
 8007c3e:	4b0d      	ldr	r3, [pc, #52]	; (8007c74 <SX1276SetMaxPayloadLength+0x60>)
 8007c40:	2222      	movs	r2, #34	; 0x22
 8007c42:	5c9b      	ldrb	r3, [r3, r2]
 8007c44:	2201      	movs	r2, #1
 8007c46:	4053      	eors	r3, r2
 8007c48:	b2db      	uxtb	r3, r3
 8007c4a:	2b00      	cmp	r3, #0
 8007c4c:	d00d      	beq.n	8007c6a <SX1276SetMaxPayloadLength+0x56>
            SX1276Write( REG_PAYLOADLENGTH, max );
 8007c4e:	1dbb      	adds	r3, r7, #6
 8007c50:	781b      	ldrb	r3, [r3, #0]
 8007c52:	0019      	movs	r1, r3
 8007c54:	2032      	movs	r0, #50	; 0x32
 8007c56:	f7ff ff0b 	bl	8007a70 <SX1276Write>
        break;
 8007c5a:	e006      	b.n	8007c6a <SX1276SetMaxPayloadLength+0x56>
        SX1276Write( REG_LR_PAYLOADMAXLENGTH, max );
 8007c5c:	1dbb      	adds	r3, r7, #6
 8007c5e:	781b      	ldrb	r3, [r3, #0]
 8007c60:	0019      	movs	r1, r3
 8007c62:	2023      	movs	r0, #35	; 0x23
 8007c64:	f7ff ff04 	bl	8007a70 <SX1276Write>
        break;
 8007c68:	e000      	b.n	8007c6c <SX1276SetMaxPayloadLength+0x58>
        break;
 8007c6a:	46c0      	nop			; (mov r8, r8)
}
 8007c6c:	46c0      	nop			; (mov r8, r8)
 8007c6e:	46bd      	mov	sp, r7
 8007c70:	b002      	add	sp, #8
 8007c72:	bd80      	pop	{r7, pc}
 8007c74:	2000175c 	.word	0x2000175c

08007c78 <SX1276SetPublicNetwork>:

void SX1276SetPublicNetwork( bool enable )
{
 8007c78:	b580      	push	{r7, lr}
 8007c7a:	b082      	sub	sp, #8
 8007c7c:	af00      	add	r7, sp, #0
 8007c7e:	0002      	movs	r2, r0
 8007c80:	1dfb      	adds	r3, r7, #7
 8007c82:	701a      	strb	r2, [r3, #0]
    SX1276SetModem( MODEM_LORA );
 8007c84:	2001      	movs	r0, #1
 8007c86:	f7ff fe99 	bl	80079bc <SX1276SetModem>
    SX1276.Settings.LoRa.PublicNetwork = enable;
 8007c8a:	4b0b      	ldr	r3, [pc, #44]	; (8007cb8 <SX1276SetPublicNetwork+0x40>)
 8007c8c:	1dfa      	adds	r2, r7, #7
 8007c8e:	215c      	movs	r1, #92	; 0x5c
 8007c90:	7812      	ldrb	r2, [r2, #0]
 8007c92:	545a      	strb	r2, [r3, r1]
    if( enable == true )
 8007c94:	1dfb      	adds	r3, r7, #7
 8007c96:	781b      	ldrb	r3, [r3, #0]
 8007c98:	2b00      	cmp	r3, #0
 8007c9a:	d004      	beq.n	8007ca6 <SX1276SetPublicNetwork+0x2e>
    {
        // Change LoRa modem SyncWord
        SX1276Write( REG_LR_SYNCWORD, LORA_MAC_PUBLIC_SYNCWORD );
 8007c9c:	2134      	movs	r1, #52	; 0x34
 8007c9e:	2039      	movs	r0, #57	; 0x39
 8007ca0:	f7ff fee6 	bl	8007a70 <SX1276Write>
    else
    {
        // Change LoRa modem SyncWord
        SX1276Write( REG_LR_SYNCWORD, LORA_MAC_PRIVATE_SYNCWORD );
    }
}
 8007ca4:	e003      	b.n	8007cae <SX1276SetPublicNetwork+0x36>
        SX1276Write( REG_LR_SYNCWORD, LORA_MAC_PRIVATE_SYNCWORD );
 8007ca6:	2112      	movs	r1, #18
 8007ca8:	2039      	movs	r0, #57	; 0x39
 8007caa:	f7ff fee1 	bl	8007a70 <SX1276Write>
}
 8007cae:	46c0      	nop			; (mov r8, r8)
 8007cb0:	46bd      	mov	sp, r7
 8007cb2:	b002      	add	sp, #8
 8007cb4:	bd80      	pop	{r7, pc}
 8007cb6:	46c0      	nop			; (mov r8, r8)
 8007cb8:	2000175c 	.word	0x2000175c

08007cbc <SX1276GetWakeupTime>:

uint32_t SX1276GetWakeupTime( void )
{
 8007cbc:	b580      	push	{r7, lr}
 8007cbe:	af00      	add	r7, sp, #0
    return ( uint32_t )LoRaBoardCallbacks->SX1276BoardGetWakeTime( ) + RADIO_WAKEUP_TIME;// BOARD_WAKEUP_TIME;
 8007cc0:	4b04      	ldr	r3, [pc, #16]	; (8007cd4 <SX1276GetWakeupTime+0x18>)
 8007cc2:	681b      	ldr	r3, [r3, #0]
 8007cc4:	685b      	ldr	r3, [r3, #4]
 8007cc6:	4798      	blx	r3
 8007cc8:	0003      	movs	r3, r0
 8007cca:	3302      	adds	r3, #2
}
 8007ccc:	0018      	movs	r0, r3
 8007cce:	46bd      	mov	sp, r7
 8007cd0:	bd80      	pop	{r7, pc}
 8007cd2:	46c0      	nop			; (mov r8, r8)
 8007cd4:	20000454 	.word	0x20000454

08007cd8 <SX1276OnTimeoutIrq>:

void SX1276OnTimeoutIrq( void* context )
{
 8007cd8:	b590      	push	{r4, r7, lr}
 8007cda:	b085      	sub	sp, #20
 8007cdc:	af00      	add	r7, sp, #0
 8007cde:	6078      	str	r0, [r7, #4]
    switch( SX1276.Settings.State )
 8007ce0:	4b51      	ldr	r3, [pc, #324]	; (8007e28 <SX1276OnTimeoutIrq+0x150>)
 8007ce2:	791b      	ldrb	r3, [r3, #4]
 8007ce4:	2b01      	cmp	r3, #1
 8007ce6:	d002      	beq.n	8007cee <SX1276OnTimeoutIrq+0x16>
 8007ce8:	2b02      	cmp	r3, #2
 8007cea:	d045      	beq.n	8007d78 <SX1276OnTimeoutIrq+0xa0>
        {
            RadioEvents->TxTimeout( );
        }
        break;
    default:
        break;
 8007cec:	e098      	b.n	8007e20 <SX1276OnTimeoutIrq+0x148>
        if( SX1276.Settings.Modem == MODEM_FSK )
 8007cee:	4b4e      	ldr	r3, [pc, #312]	; (8007e28 <SX1276OnTimeoutIrq+0x150>)
 8007cf0:	795b      	ldrb	r3, [r3, #5]
 8007cf2:	2b00      	cmp	r3, #0
 8007cf4:	d132      	bne.n	8007d5c <SX1276OnTimeoutIrq+0x84>
            SX1276.Settings.FskPacketHandler.PreambleDetected = false;
 8007cf6:	4b4c      	ldr	r3, [pc, #304]	; (8007e28 <SX1276OnTimeoutIrq+0x150>)
 8007cf8:	2230      	movs	r2, #48	; 0x30
 8007cfa:	2100      	movs	r1, #0
 8007cfc:	5499      	strb	r1, [r3, r2]
            SX1276.Settings.FskPacketHandler.SyncWordDetected = false;
 8007cfe:	4b4a      	ldr	r3, [pc, #296]	; (8007e28 <SX1276OnTimeoutIrq+0x150>)
 8007d00:	2231      	movs	r2, #49	; 0x31
 8007d02:	2100      	movs	r1, #0
 8007d04:	5499      	strb	r1, [r3, r2]
            SX1276.Settings.FskPacketHandler.NbBytes = 0;
 8007d06:	4b48      	ldr	r3, [pc, #288]	; (8007e28 <SX1276OnTimeoutIrq+0x150>)
 8007d08:	2200      	movs	r2, #0
 8007d0a:	879a      	strh	r2, [r3, #60]	; 0x3c
            SX1276.Settings.FskPacketHandler.Size = 0;
 8007d0c:	4b46      	ldr	r3, [pc, #280]	; (8007e28 <SX1276OnTimeoutIrq+0x150>)
 8007d0e:	2200      	movs	r2, #0
 8007d10:	875a      	strh	r2, [r3, #58]	; 0x3a
            SX1276Write( REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |
 8007d12:	210b      	movs	r1, #11
 8007d14:	203e      	movs	r0, #62	; 0x3e
 8007d16:	f7ff feab 	bl	8007a70 <SX1276Write>
            SX1276Write( REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN );
 8007d1a:	2110      	movs	r1, #16
 8007d1c:	203f      	movs	r0, #63	; 0x3f
 8007d1e:	f7ff fea7 	bl	8007a70 <SX1276Write>
            if( SX1276.Settings.Fsk.RxContinuous == true )
 8007d22:	4b41      	ldr	r3, [pc, #260]	; (8007e28 <SX1276OnTimeoutIrq+0x150>)
 8007d24:	2226      	movs	r2, #38	; 0x26
 8007d26:	5c9b      	ldrb	r3, [r3, r2]
 8007d28:	2b00      	cmp	r3, #0
 8007d2a:	d010      	beq.n	8007d4e <SX1276OnTimeoutIrq+0x76>
                SX1276Write( REG_RXCONFIG, SX1276Read( REG_RXCONFIG ) | RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK );
 8007d2c:	200d      	movs	r0, #13
 8007d2e:	f7ff feb3 	bl	8007a98 <SX1276Read>
 8007d32:	0003      	movs	r3, r0
 8007d34:	001a      	movs	r2, r3
 8007d36:	2340      	movs	r3, #64	; 0x40
 8007d38:	4313      	orrs	r3, r2
 8007d3a:	b2db      	uxtb	r3, r3
 8007d3c:	0019      	movs	r1, r3
 8007d3e:	200d      	movs	r0, #13
 8007d40:	f7ff fe96 	bl	8007a70 <SX1276Write>
                TimerStart( &RxTimeoutSyncWord );
 8007d44:	4b39      	ldr	r3, [pc, #228]	; (8007e2c <SX1276OnTimeoutIrq+0x154>)
 8007d46:	0018      	movs	r0, r3
 8007d48:	f013 f89c 	bl	801ae84 <TimerStart>
 8007d4c:	e006      	b.n	8007d5c <SX1276OnTimeoutIrq+0x84>
                SX1276.Settings.State = RF_IDLE;
 8007d4e:	4b36      	ldr	r3, [pc, #216]	; (8007e28 <SX1276OnTimeoutIrq+0x150>)
 8007d50:	2200      	movs	r2, #0
 8007d52:	711a      	strb	r2, [r3, #4]
                TimerStop( &RxTimeoutSyncWord );
 8007d54:	4b35      	ldr	r3, [pc, #212]	; (8007e2c <SX1276OnTimeoutIrq+0x154>)
 8007d56:	0018      	movs	r0, r3
 8007d58:	f013 f970 	bl	801b03c <TimerStop>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8007d5c:	4b34      	ldr	r3, [pc, #208]	; (8007e30 <SX1276OnTimeoutIrq+0x158>)
 8007d5e:	681b      	ldr	r3, [r3, #0]
 8007d60:	2b00      	cmp	r3, #0
 8007d62:	d05a      	beq.n	8007e1a <SX1276OnTimeoutIrq+0x142>
 8007d64:	4b32      	ldr	r3, [pc, #200]	; (8007e30 <SX1276OnTimeoutIrq+0x158>)
 8007d66:	681b      	ldr	r3, [r3, #0]
 8007d68:	68db      	ldr	r3, [r3, #12]
 8007d6a:	2b00      	cmp	r3, #0
 8007d6c:	d055      	beq.n	8007e1a <SX1276OnTimeoutIrq+0x142>
            RadioEvents->RxTimeout( );
 8007d6e:	4b30      	ldr	r3, [pc, #192]	; (8007e30 <SX1276OnTimeoutIrq+0x158>)
 8007d70:	681b      	ldr	r3, [r3, #0]
 8007d72:	68db      	ldr	r3, [r3, #12]
 8007d74:	4798      	blx	r3
        break;
 8007d76:	e050      	b.n	8007e1a <SX1276OnTimeoutIrq+0x142>
        SX1276Reset( );
 8007d78:	f7ff fd9c 	bl	80078b4 <SX1276Reset>
        RxChainCalibration( );
 8007d7c:	f7fe faa8 	bl	80062d0 <RxChainCalibration>
        SX1276SetOpMode( RF_OPMODE_SLEEP );
 8007d80:	2000      	movs	r0, #0
 8007d82:	f7ff fdcb 	bl	800791c <SX1276SetOpMode>
        for( uint8_t i = 0; i < sizeof( RadioRegsInit ) / sizeof( RadioRegisters_t ); i++ )
 8007d86:	230f      	movs	r3, #15
 8007d88:	18fb      	adds	r3, r7, r3
 8007d8a:	2200      	movs	r2, #0
 8007d8c:	701a      	strb	r2, [r3, #0]
 8007d8e:	e025      	b.n	8007ddc <SX1276OnTimeoutIrq+0x104>
            SX1276SetModem( RadioRegsInit[i].Modem );
 8007d90:	240f      	movs	r4, #15
 8007d92:	193b      	adds	r3, r7, r4
 8007d94:	781a      	ldrb	r2, [r3, #0]
 8007d96:	4927      	ldr	r1, [pc, #156]	; (8007e34 <SX1276OnTimeoutIrq+0x15c>)
 8007d98:	0013      	movs	r3, r2
 8007d9a:	005b      	lsls	r3, r3, #1
 8007d9c:	189b      	adds	r3, r3, r2
 8007d9e:	5c5b      	ldrb	r3, [r3, r1]
 8007da0:	0018      	movs	r0, r3
 8007da2:	f7ff fe0b 	bl	80079bc <SX1276SetModem>
            SX1276Write( RadioRegsInit[i].Addr, RadioRegsInit[i].Value );
 8007da6:	193b      	adds	r3, r7, r4
 8007da8:	781a      	ldrb	r2, [r3, #0]
 8007daa:	4922      	ldr	r1, [pc, #136]	; (8007e34 <SX1276OnTimeoutIrq+0x15c>)
 8007dac:	0013      	movs	r3, r2
 8007dae:	005b      	lsls	r3, r3, #1
 8007db0:	189b      	adds	r3, r3, r2
 8007db2:	18cb      	adds	r3, r1, r3
 8007db4:	3301      	adds	r3, #1
 8007db6:	781b      	ldrb	r3, [r3, #0]
 8007db8:	b298      	uxth	r0, r3
 8007dba:	193b      	adds	r3, r7, r4
 8007dbc:	781a      	ldrb	r2, [r3, #0]
 8007dbe:	491d      	ldr	r1, [pc, #116]	; (8007e34 <SX1276OnTimeoutIrq+0x15c>)
 8007dc0:	0013      	movs	r3, r2
 8007dc2:	005b      	lsls	r3, r3, #1
 8007dc4:	189b      	adds	r3, r3, r2
 8007dc6:	18cb      	adds	r3, r1, r3
 8007dc8:	3302      	adds	r3, #2
 8007dca:	781b      	ldrb	r3, [r3, #0]
 8007dcc:	0019      	movs	r1, r3
 8007dce:	f7ff fe4f 	bl	8007a70 <SX1276Write>
        for( uint8_t i = 0; i < sizeof( RadioRegsInit ) / sizeof( RadioRegisters_t ); i++ )
 8007dd2:	193b      	adds	r3, r7, r4
 8007dd4:	781a      	ldrb	r2, [r3, #0]
 8007dd6:	193b      	adds	r3, r7, r4
 8007dd8:	3201      	adds	r2, #1
 8007dda:	701a      	strb	r2, [r3, #0]
 8007ddc:	230f      	movs	r3, #15
 8007dde:	18fb      	adds	r3, r7, r3
 8007de0:	781b      	ldrb	r3, [r3, #0]
 8007de2:	2b0f      	cmp	r3, #15
 8007de4:	d9d4      	bls.n	8007d90 <SX1276OnTimeoutIrq+0xb8>
        SX1276SetModem( MODEM_FSK );
 8007de6:	2000      	movs	r0, #0
 8007de8:	f7ff fde8 	bl	80079bc <SX1276SetModem>
        SX1276SetPublicNetwork( SX1276.Settings.LoRa.PublicNetwork );
 8007dec:	4b0e      	ldr	r3, [pc, #56]	; (8007e28 <SX1276OnTimeoutIrq+0x150>)
 8007dee:	225c      	movs	r2, #92	; 0x5c
 8007df0:	5c9b      	ldrb	r3, [r3, r2]
 8007df2:	0018      	movs	r0, r3
 8007df4:	f7ff ff40 	bl	8007c78 <SX1276SetPublicNetwork>
        SX1276.Settings.State = RF_IDLE;
 8007df8:	4b0b      	ldr	r3, [pc, #44]	; (8007e28 <SX1276OnTimeoutIrq+0x150>)
 8007dfa:	2200      	movs	r2, #0
 8007dfc:	711a      	strb	r2, [r3, #4]
        if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 8007dfe:	4b0c      	ldr	r3, [pc, #48]	; (8007e30 <SX1276OnTimeoutIrq+0x158>)
 8007e00:	681b      	ldr	r3, [r3, #0]
 8007e02:	2b00      	cmp	r3, #0
 8007e04:	d00b      	beq.n	8007e1e <SX1276OnTimeoutIrq+0x146>
 8007e06:	4b0a      	ldr	r3, [pc, #40]	; (8007e30 <SX1276OnTimeoutIrq+0x158>)
 8007e08:	681b      	ldr	r3, [r3, #0]
 8007e0a:	685b      	ldr	r3, [r3, #4]
 8007e0c:	2b00      	cmp	r3, #0
 8007e0e:	d006      	beq.n	8007e1e <SX1276OnTimeoutIrq+0x146>
            RadioEvents->TxTimeout( );
 8007e10:	4b07      	ldr	r3, [pc, #28]	; (8007e30 <SX1276OnTimeoutIrq+0x158>)
 8007e12:	681b      	ldr	r3, [r3, #0]
 8007e14:	685b      	ldr	r3, [r3, #4]
 8007e16:	4798      	blx	r3
        break;
 8007e18:	e001      	b.n	8007e1e <SX1276OnTimeoutIrq+0x146>
        break;
 8007e1a:	46c0      	nop			; (mov r8, r8)
 8007e1c:	e000      	b.n	8007e20 <SX1276OnTimeoutIrq+0x148>
        break;
 8007e1e:	46c0      	nop			; (mov r8, r8)
    }
}
 8007e20:	46c0      	nop			; (mov r8, r8)
 8007e22:	46bd      	mov	sp, r7
 8007e24:	b005      	add	sp, #20
 8007e26:	bd90      	pop	{r4, r7, pc}
 8007e28:	2000175c 	.word	0x2000175c
 8007e2c:	20001744 	.word	0x20001744
 8007e30:	20000350 	.word	0x20000350
 8007e34:	0801ed00 	.word	0x0801ed00

08007e38 <SX1276OnDio0Irq>:

void SX1276OnDio0Irq( void* context )
{
 8007e38:	b590      	push	{r4, r7, lr}
 8007e3a:	b085      	sub	sp, #20
 8007e3c:	af00      	add	r7, sp, #0
 8007e3e:	6078      	str	r0, [r7, #4]
    volatile uint8_t irqFlags = 0;
 8007e40:	230d      	movs	r3, #13
 8007e42:	18fb      	adds	r3, r7, r3
 8007e44:	2200      	movs	r2, #0
 8007e46:	701a      	strb	r2, [r3, #0]

    switch( SX1276.Settings.State )
 8007e48:	4bca      	ldr	r3, [pc, #808]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007e4a:	791b      	ldrb	r3, [r3, #4]
 8007e4c:	2b01      	cmp	r3, #1
 8007e4e:	d003      	beq.n	8007e58 <SX1276OnDio0Irq+0x20>
 8007e50:	2b02      	cmp	r3, #2
 8007e52:	d100      	bne.n	8007e56 <SX1276OnDio0Irq+0x1e>
 8007e54:	e1f1      	b.n	800823a <SX1276OnDio0Irq+0x402>
                }
                break;
            }
            break;
        default:
            break;
 8007e56:	e20e      	b.n	8008276 <SX1276OnDio0Irq+0x43e>
            switch( SX1276.Settings.Modem )
 8007e58:	4bc6      	ldr	r3, [pc, #792]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007e5a:	795b      	ldrb	r3, [r3, #5]
 8007e5c:	2b00      	cmp	r3, #0
 8007e5e:	d003      	beq.n	8007e68 <SX1276OnDio0Irq+0x30>
 8007e60:	2b01      	cmp	r3, #1
 8007e62:	d100      	bne.n	8007e66 <SX1276OnDio0Irq+0x2e>
 8007e64:	e0eb      	b.n	800803e <SX1276OnDio0Irq+0x206>
                break;
 8007e66:	e1e7      	b.n	8008238 <SX1276OnDio0Irq+0x400>
                if( SX1276.Settings.Fsk.CrcOn == true )
 8007e68:	4bc2      	ldr	r3, [pc, #776]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007e6a:	2224      	movs	r2, #36	; 0x24
 8007e6c:	5c9b      	ldrb	r3, [r3, r2]
 8007e6e:	2b00      	cmp	r3, #0
 8007e70:	d057      	beq.n	8007f22 <SX1276OnDio0Irq+0xea>
                    irqFlags = SX1276Read( REG_IRQFLAGS2 );
 8007e72:	203f      	movs	r0, #63	; 0x3f
 8007e74:	f7ff fe10 	bl	8007a98 <SX1276Read>
 8007e78:	0003      	movs	r3, r0
 8007e7a:	001a      	movs	r2, r3
 8007e7c:	210d      	movs	r1, #13
 8007e7e:	187b      	adds	r3, r7, r1
 8007e80:	701a      	strb	r2, [r3, #0]
                    if( ( irqFlags & RF_IRQFLAGS2_CRCOK ) != RF_IRQFLAGS2_CRCOK )
 8007e82:	187b      	adds	r3, r7, r1
 8007e84:	781b      	ldrb	r3, [r3, #0]
 8007e86:	b2db      	uxtb	r3, r3
 8007e88:	001a      	movs	r2, r3
 8007e8a:	2302      	movs	r3, #2
 8007e8c:	4013      	ands	r3, r2
 8007e8e:	2b02      	cmp	r3, #2
 8007e90:	d047      	beq.n	8007f22 <SX1276OnDio0Irq+0xea>
                        SX1276Write( REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |
 8007e92:	210b      	movs	r1, #11
 8007e94:	203e      	movs	r0, #62	; 0x3e
 8007e96:	f7ff fdeb 	bl	8007a70 <SX1276Write>
                        SX1276Write( REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN );
 8007e9a:	2110      	movs	r1, #16
 8007e9c:	203f      	movs	r0, #63	; 0x3f
 8007e9e:	f7ff fde7 	bl	8007a70 <SX1276Write>
                        TimerStop( &RxTimeoutTimer );
 8007ea2:	4bb5      	ldr	r3, [pc, #724]	; (8008178 <SX1276OnDio0Irq+0x340>)
 8007ea4:	0018      	movs	r0, r3
 8007ea6:	f013 f8c9 	bl	801b03c <TimerStop>
                        if( SX1276.Settings.Fsk.RxContinuous == false )
 8007eaa:	4bb2      	ldr	r3, [pc, #712]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007eac:	2226      	movs	r2, #38	; 0x26
 8007eae:	5c9b      	ldrb	r3, [r3, r2]
 8007eb0:	2201      	movs	r2, #1
 8007eb2:	4053      	eors	r3, r2
 8007eb4:	b2db      	uxtb	r3, r3
 8007eb6:	2b00      	cmp	r3, #0
 8007eb8:	d007      	beq.n	8007eca <SX1276OnDio0Irq+0x92>
                            TimerStop( &RxTimeoutSyncWord );
 8007eba:	4bb0      	ldr	r3, [pc, #704]	; (800817c <SX1276OnDio0Irq+0x344>)
 8007ebc:	0018      	movs	r0, r3
 8007ebe:	f013 f8bd 	bl	801b03c <TimerStop>
                            SX1276.Settings.State = RF_IDLE;
 8007ec2:	4bac      	ldr	r3, [pc, #688]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007ec4:	2200      	movs	r2, #0
 8007ec6:	711a      	strb	r2, [r3, #4]
 8007ec8:	e00f      	b.n	8007eea <SX1276OnDio0Irq+0xb2>
                            SX1276Write( REG_RXCONFIG, SX1276Read( REG_RXCONFIG ) | RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK );
 8007eca:	200d      	movs	r0, #13
 8007ecc:	f7ff fde4 	bl	8007a98 <SX1276Read>
 8007ed0:	0003      	movs	r3, r0
 8007ed2:	001a      	movs	r2, r3
 8007ed4:	2340      	movs	r3, #64	; 0x40
 8007ed6:	4313      	orrs	r3, r2
 8007ed8:	b2db      	uxtb	r3, r3
 8007eda:	0019      	movs	r1, r3
 8007edc:	200d      	movs	r0, #13
 8007ede:	f7ff fdc7 	bl	8007a70 <SX1276Write>
                            TimerStart( &RxTimeoutSyncWord );
 8007ee2:	4ba6      	ldr	r3, [pc, #664]	; (800817c <SX1276OnDio0Irq+0x344>)
 8007ee4:	0018      	movs	r0, r3
 8007ee6:	f012 ffcd 	bl	801ae84 <TimerStart>
                        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError != NULL ) )
 8007eea:	4ba5      	ldr	r3, [pc, #660]	; (8008180 <SX1276OnDio0Irq+0x348>)
 8007eec:	681b      	ldr	r3, [r3, #0]
 8007eee:	2b00      	cmp	r3, #0
 8007ef0:	d008      	beq.n	8007f04 <SX1276OnDio0Irq+0xcc>
 8007ef2:	4ba3      	ldr	r3, [pc, #652]	; (8008180 <SX1276OnDio0Irq+0x348>)
 8007ef4:	681b      	ldr	r3, [r3, #0]
 8007ef6:	691b      	ldr	r3, [r3, #16]
 8007ef8:	2b00      	cmp	r3, #0
 8007efa:	d003      	beq.n	8007f04 <SX1276OnDio0Irq+0xcc>
                            RadioEvents->RxError( );
 8007efc:	4ba0      	ldr	r3, [pc, #640]	; (8008180 <SX1276OnDio0Irq+0x348>)
 8007efe:	681b      	ldr	r3, [r3, #0]
 8007f00:	691b      	ldr	r3, [r3, #16]
 8007f02:	4798      	blx	r3
                        SX1276.Settings.FskPacketHandler.PreambleDetected = false;
 8007f04:	4b9b      	ldr	r3, [pc, #620]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f06:	2230      	movs	r2, #48	; 0x30
 8007f08:	2100      	movs	r1, #0
 8007f0a:	5499      	strb	r1, [r3, r2]
                        SX1276.Settings.FskPacketHandler.SyncWordDetected = false;
 8007f0c:	4b99      	ldr	r3, [pc, #612]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f0e:	2231      	movs	r2, #49	; 0x31
 8007f10:	2100      	movs	r1, #0
 8007f12:	5499      	strb	r1, [r3, r2]
                        SX1276.Settings.FskPacketHandler.NbBytes = 0;
 8007f14:	4b97      	ldr	r3, [pc, #604]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f16:	2200      	movs	r2, #0
 8007f18:	879a      	strh	r2, [r3, #60]	; 0x3c
                        SX1276.Settings.FskPacketHandler.Size = 0;
 8007f1a:	4b96      	ldr	r3, [pc, #600]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f1c:	2200      	movs	r2, #0
 8007f1e:	875a      	strh	r2, [r3, #58]	; 0x3a
                        break;
 8007f20:	e18a      	b.n	8008238 <SX1276OnDio0Irq+0x400>
                if( ( SX1276.Settings.FskPacketHandler.Size == 0 ) && ( SX1276.Settings.FskPacketHandler.NbBytes == 0 ) )
 8007f22:	4b94      	ldr	r3, [pc, #592]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f24:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 8007f26:	2b00      	cmp	r3, #0
 8007f28:	d12d      	bne.n	8007f86 <SX1276OnDio0Irq+0x14e>
 8007f2a:	4b92      	ldr	r3, [pc, #584]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f2c:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 8007f2e:	2b00      	cmp	r3, #0
 8007f30:	d129      	bne.n	8007f86 <SX1276OnDio0Irq+0x14e>
                    if( SX1276.Settings.Fsk.FixLen == false )
 8007f32:	4b90      	ldr	r3, [pc, #576]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f34:	2222      	movs	r2, #34	; 0x22
 8007f36:	5c9b      	ldrb	r3, [r3, r2]
 8007f38:	2201      	movs	r2, #1
 8007f3a:	4053      	eors	r3, r2
 8007f3c:	b2db      	uxtb	r3, r3
 8007f3e:	2b00      	cmp	r3, #0
 8007f40:	d005      	beq.n	8007f4e <SX1276OnDio0Irq+0x116>
                        SX1276ReadFifo( ( uint8_t* )&SX1276.Settings.FskPacketHandler.Size, 1 );
 8007f42:	4b90      	ldr	r3, [pc, #576]	; (8008184 <SX1276OnDio0Irq+0x34c>)
 8007f44:	2101      	movs	r1, #1
 8007f46:	0018      	movs	r0, r3
 8007f48:	f7ff fe52 	bl	8007bf0 <SX1276ReadFifo>
 8007f4c:	e006      	b.n	8007f5c <SX1276OnDio0Irq+0x124>
                        SX1276.Settings.FskPacketHandler.Size = SX1276Read( REG_PAYLOADLENGTH );
 8007f4e:	2032      	movs	r0, #50	; 0x32
 8007f50:	f7ff fda2 	bl	8007a98 <SX1276Read>
 8007f54:	0003      	movs	r3, r0
 8007f56:	b29a      	uxth	r2, r3
 8007f58:	4b86      	ldr	r3, [pc, #536]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f5a:	875a      	strh	r2, [r3, #58]	; 0x3a
                    SX1276ReadFifo( RxTxBuffer + SX1276.Settings.FskPacketHandler.NbBytes, SX1276.Settings.FskPacketHandler.Size - SX1276.Settings.FskPacketHandler.NbBytes );
 8007f5c:	4b85      	ldr	r3, [pc, #532]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f5e:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 8007f60:	001a      	movs	r2, r3
 8007f62:	4b89      	ldr	r3, [pc, #548]	; (8008188 <SX1276OnDio0Irq+0x350>)
 8007f64:	18d0      	adds	r0, r2, r3
 8007f66:	4b83      	ldr	r3, [pc, #524]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f68:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 8007f6a:	b2da      	uxtb	r2, r3
 8007f6c:	4b81      	ldr	r3, [pc, #516]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f6e:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 8007f70:	b2db      	uxtb	r3, r3
 8007f72:	1ad3      	subs	r3, r2, r3
 8007f74:	b2db      	uxtb	r3, r3
 8007f76:	0019      	movs	r1, r3
 8007f78:	f7ff fe3a 	bl	8007bf0 <SX1276ReadFifo>
                    SX1276.Settings.FskPacketHandler.NbBytes += ( SX1276.Settings.FskPacketHandler.Size - SX1276.Settings.FskPacketHandler.NbBytes );
 8007f7c:	4b7d      	ldr	r3, [pc, #500]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f7e:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
 8007f80:	4b7c      	ldr	r3, [pc, #496]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f82:	879a      	strh	r2, [r3, #60]	; 0x3c
 8007f84:	e013      	b.n	8007fae <SX1276OnDio0Irq+0x176>
                    SX1276ReadFifo( RxTxBuffer + SX1276.Settings.FskPacketHandler.NbBytes, SX1276.Settings.FskPacketHandler.Size - SX1276.Settings.FskPacketHandler.NbBytes );
 8007f86:	4b7b      	ldr	r3, [pc, #492]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f88:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 8007f8a:	001a      	movs	r2, r3
 8007f8c:	4b7e      	ldr	r3, [pc, #504]	; (8008188 <SX1276OnDio0Irq+0x350>)
 8007f8e:	18d0      	adds	r0, r2, r3
 8007f90:	4b78      	ldr	r3, [pc, #480]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f92:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 8007f94:	b2da      	uxtb	r2, r3
 8007f96:	4b77      	ldr	r3, [pc, #476]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007f98:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 8007f9a:	b2db      	uxtb	r3, r3
 8007f9c:	1ad3      	subs	r3, r2, r3
 8007f9e:	b2db      	uxtb	r3, r3
 8007fa0:	0019      	movs	r1, r3
 8007fa2:	f7ff fe25 	bl	8007bf0 <SX1276ReadFifo>
                    SX1276.Settings.FskPacketHandler.NbBytes += ( SX1276.Settings.FskPacketHandler.Size - SX1276.Settings.FskPacketHandler.NbBytes );
 8007fa6:	4b73      	ldr	r3, [pc, #460]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007fa8:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
 8007faa:	4b72      	ldr	r3, [pc, #456]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007fac:	879a      	strh	r2, [r3, #60]	; 0x3c
                TimerStop( &RxTimeoutTimer );
 8007fae:	4b72      	ldr	r3, [pc, #456]	; (8008178 <SX1276OnDio0Irq+0x340>)
 8007fb0:	0018      	movs	r0, r3
 8007fb2:	f013 f843 	bl	801b03c <TimerStop>
                if( SX1276.Settings.Fsk.RxContinuous == false )
 8007fb6:	4b6f      	ldr	r3, [pc, #444]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007fb8:	2226      	movs	r2, #38	; 0x26
 8007fba:	5c9b      	ldrb	r3, [r3, r2]
 8007fbc:	2201      	movs	r2, #1
 8007fbe:	4053      	eors	r3, r2
 8007fc0:	b2db      	uxtb	r3, r3
 8007fc2:	2b00      	cmp	r3, #0
 8007fc4:	d007      	beq.n	8007fd6 <SX1276OnDio0Irq+0x19e>
                    SX1276.Settings.State = RF_IDLE;
 8007fc6:	4b6b      	ldr	r3, [pc, #428]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8007fc8:	2200      	movs	r2, #0
 8007fca:	711a      	strb	r2, [r3, #4]
                    TimerStop( &RxTimeoutSyncWord );
 8007fcc:	4b6b      	ldr	r3, [pc, #428]	; (800817c <SX1276OnDio0Irq+0x344>)
 8007fce:	0018      	movs	r0, r3
 8007fd0:	f013 f834 	bl	801b03c <TimerStop>
 8007fd4:	e00f      	b.n	8007ff6 <SX1276OnDio0Irq+0x1be>
                    SX1276Write( REG_RXCONFIG, SX1276Read( REG_RXCONFIG ) | RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK );
 8007fd6:	200d      	movs	r0, #13
 8007fd8:	f7ff fd5e 	bl	8007a98 <SX1276Read>
 8007fdc:	0003      	movs	r3, r0
 8007fde:	001a      	movs	r2, r3
 8007fe0:	2340      	movs	r3, #64	; 0x40
 8007fe2:	4313      	orrs	r3, r2
 8007fe4:	b2db      	uxtb	r3, r3
 8007fe6:	0019      	movs	r1, r3
 8007fe8:	200d      	movs	r0, #13
 8007fea:	f7ff fd41 	bl	8007a70 <SX1276Write>
                    TimerStart( &RxTimeoutSyncWord );
 8007fee:	4b63      	ldr	r3, [pc, #396]	; (800817c <SX1276OnDio0Irq+0x344>)
 8007ff0:	0018      	movs	r0, r3
 8007ff2:	f012 ff47 	bl	801ae84 <TimerStart>
                if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 8007ff6:	4b62      	ldr	r3, [pc, #392]	; (8008180 <SX1276OnDio0Irq+0x348>)
 8007ff8:	681b      	ldr	r3, [r3, #0]
 8007ffa:	2b00      	cmp	r3, #0
 8007ffc:	d010      	beq.n	8008020 <SX1276OnDio0Irq+0x1e8>
 8007ffe:	4b60      	ldr	r3, [pc, #384]	; (8008180 <SX1276OnDio0Irq+0x348>)
 8008000:	681b      	ldr	r3, [r3, #0]
 8008002:	689b      	ldr	r3, [r3, #8]
 8008004:	2b00      	cmp	r3, #0
 8008006:	d00b      	beq.n	8008020 <SX1276OnDio0Irq+0x1e8>
                    RadioEvents->RxDone( RxTxBuffer, SX1276.Settings.FskPacketHandler.Size, SX1276.Settings.FskPacketHandler.RssiValue, 0 );
 8008008:	4b5d      	ldr	r3, [pc, #372]	; (8008180 <SX1276OnDio0Irq+0x348>)
 800800a:	681b      	ldr	r3, [r3, #0]
 800800c:	689c      	ldr	r4, [r3, #8]
 800800e:	4b59      	ldr	r3, [pc, #356]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8008010:	8f59      	ldrh	r1, [r3, #58]	; 0x3a
 8008012:	4b58      	ldr	r3, [pc, #352]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8008014:	2232      	movs	r2, #50	; 0x32
 8008016:	569b      	ldrsb	r3, [r3, r2]
 8008018:	b21a      	sxth	r2, r3
 800801a:	485b      	ldr	r0, [pc, #364]	; (8008188 <SX1276OnDio0Irq+0x350>)
 800801c:	2300      	movs	r3, #0
 800801e:	47a0      	blx	r4
                SX1276.Settings.FskPacketHandler.PreambleDetected = false;
 8008020:	4b54      	ldr	r3, [pc, #336]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8008022:	2230      	movs	r2, #48	; 0x30
 8008024:	2100      	movs	r1, #0
 8008026:	5499      	strb	r1, [r3, r2]
                SX1276.Settings.FskPacketHandler.SyncWordDetected = false;
 8008028:	4b52      	ldr	r3, [pc, #328]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 800802a:	2231      	movs	r2, #49	; 0x31
 800802c:	2100      	movs	r1, #0
 800802e:	5499      	strb	r1, [r3, r2]
                SX1276.Settings.FskPacketHandler.NbBytes = 0;
 8008030:	4b50      	ldr	r3, [pc, #320]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8008032:	2200      	movs	r2, #0
 8008034:	879a      	strh	r2, [r3, #60]	; 0x3c
                SX1276.Settings.FskPacketHandler.Size = 0;
 8008036:	4b4f      	ldr	r3, [pc, #316]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8008038:	2200      	movs	r2, #0
 800803a:	875a      	strh	r2, [r3, #58]	; 0x3a
                break;
 800803c:	e0fc      	b.n	8008238 <SX1276OnDio0Irq+0x400>
                    SX1276Write( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXDONE );
 800803e:	2140      	movs	r1, #64	; 0x40
 8008040:	2012      	movs	r0, #18
 8008042:	f7ff fd15 	bl	8007a70 <SX1276Write>
                    irqFlags = SX1276Read( REG_LR_IRQFLAGS );
 8008046:	2012      	movs	r0, #18
 8008048:	f7ff fd26 	bl	8007a98 <SX1276Read>
 800804c:	0003      	movs	r3, r0
 800804e:	001a      	movs	r2, r3
 8008050:	210d      	movs	r1, #13
 8008052:	187b      	adds	r3, r7, r1
 8008054:	701a      	strb	r2, [r3, #0]
                    if( ( irqFlags & RFLR_IRQFLAGS_PAYLOADCRCERROR_MASK ) == RFLR_IRQFLAGS_PAYLOADCRCERROR )
 8008056:	187b      	adds	r3, r7, r1
 8008058:	781b      	ldrb	r3, [r3, #0]
 800805a:	b2db      	uxtb	r3, r3
 800805c:	001a      	movs	r2, r3
 800805e:	2320      	movs	r3, #32
 8008060:	4013      	ands	r3, r2
 8008062:	2b20      	cmp	r3, #32
 8008064:	d122      	bne.n	80080ac <SX1276OnDio0Irq+0x274>
                        SX1276Write( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_PAYLOADCRCERROR );
 8008066:	2120      	movs	r1, #32
 8008068:	2012      	movs	r0, #18
 800806a:	f7ff fd01 	bl	8007a70 <SX1276Write>
                        if( SX1276.Settings.LoRa.RxContinuous == false )
 800806e:	4b41      	ldr	r3, [pc, #260]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8008070:	2256      	movs	r2, #86	; 0x56
 8008072:	5c9b      	ldrb	r3, [r3, r2]
 8008074:	2201      	movs	r2, #1
 8008076:	4053      	eors	r3, r2
 8008078:	b2db      	uxtb	r3, r3
 800807a:	2b00      	cmp	r3, #0
 800807c:	d002      	beq.n	8008084 <SX1276OnDio0Irq+0x24c>
                            SX1276.Settings.State = RF_IDLE;
 800807e:	4b3d      	ldr	r3, [pc, #244]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8008080:	2200      	movs	r2, #0
 8008082:	711a      	strb	r2, [r3, #4]
                        TimerStop( &RxTimeoutTimer );
 8008084:	4b3c      	ldr	r3, [pc, #240]	; (8008178 <SX1276OnDio0Irq+0x340>)
 8008086:	0018      	movs	r0, r3
 8008088:	f012 ffd8 	bl	801b03c <TimerStop>
                        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError != NULL ) )
 800808c:	4b3c      	ldr	r3, [pc, #240]	; (8008180 <SX1276OnDio0Irq+0x348>)
 800808e:	681b      	ldr	r3, [r3, #0]
 8008090:	2b00      	cmp	r3, #0
 8008092:	d100      	bne.n	8008096 <SX1276OnDio0Irq+0x25e>
 8008094:	e0cd      	b.n	8008232 <SX1276OnDio0Irq+0x3fa>
 8008096:	4b3a      	ldr	r3, [pc, #232]	; (8008180 <SX1276OnDio0Irq+0x348>)
 8008098:	681b      	ldr	r3, [r3, #0]
 800809a:	691b      	ldr	r3, [r3, #16]
 800809c:	2b00      	cmp	r3, #0
 800809e:	d100      	bne.n	80080a2 <SX1276OnDio0Irq+0x26a>
 80080a0:	e0c7      	b.n	8008232 <SX1276OnDio0Irq+0x3fa>
                            RadioEvents->RxError( );
 80080a2:	4b37      	ldr	r3, [pc, #220]	; (8008180 <SX1276OnDio0Irq+0x348>)
 80080a4:	681b      	ldr	r3, [r3, #0]
 80080a6:	691b      	ldr	r3, [r3, #16]
 80080a8:	4798      	blx	r3
                        break;
 80080aa:	e0c2      	b.n	8008232 <SX1276OnDio0Irq+0x3fa>
                    SX1276.Settings.LoRaPacketHandler.SnrValue = ( ( ( int8_t )SX1276Read( REG_LR_PKTSNRVALUE ) ) + 2 ) >> 2;
 80080ac:	2019      	movs	r0, #25
 80080ae:	f7ff fcf3 	bl	8007a98 <SX1276Read>
 80080b2:	0003      	movs	r3, r0
 80080b4:	b25b      	sxtb	r3, r3
 80080b6:	3302      	adds	r3, #2
 80080b8:	109b      	asrs	r3, r3, #2
 80080ba:	b259      	sxtb	r1, r3
 80080bc:	4b2d      	ldr	r3, [pc, #180]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 80080be:	2260      	movs	r2, #96	; 0x60
 80080c0:	5499      	strb	r1, [r3, r2]
                    int16_t rssi = SX1276Read( REG_LR_PKTRSSIVALUE );
 80080c2:	201a      	movs	r0, #26
 80080c4:	f7ff fce8 	bl	8007a98 <SX1276Read>
 80080c8:	0003      	movs	r3, r0
 80080ca:	001a      	movs	r2, r3
 80080cc:	210e      	movs	r1, #14
 80080ce:	187b      	adds	r3, r7, r1
 80080d0:	801a      	strh	r2, [r3, #0]
                    if( SX1276.Settings.LoRaPacketHandler.SnrValue < 0 )
 80080d2:	4b28      	ldr	r3, [pc, #160]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 80080d4:	2260      	movs	r2, #96	; 0x60
 80080d6:	569b      	ldrsb	r3, [r3, r2]
 80080d8:	2b00      	cmp	r3, #0
 80080da:	da33      	bge.n	8008144 <SX1276OnDio0Irq+0x30c>
                        if( SX1276.Settings.Channel > RF_MID_BAND_THRESH )
 80080dc:	4b25      	ldr	r3, [pc, #148]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 80080de:	689b      	ldr	r3, [r3, #8]
 80080e0:	4a2a      	ldr	r2, [pc, #168]	; (800818c <SX1276OnDio0Irq+0x354>)
 80080e2:	4293      	cmp	r3, r2
 80080e4:	d916      	bls.n	8008114 <SX1276OnDio0Irq+0x2dc>
                            SX1276.Settings.LoRaPacketHandler.RssiValue = RSSI_OFFSET_HF + rssi + ( rssi >> 4 ) +
 80080e6:	187b      	adds	r3, r7, r1
 80080e8:	2200      	movs	r2, #0
 80080ea:	5e9b      	ldrsh	r3, [r3, r2]
 80080ec:	111b      	asrs	r3, r3, #4
 80080ee:	b21b      	sxth	r3, r3
 80080f0:	b29a      	uxth	r2, r3
 80080f2:	187b      	adds	r3, r7, r1
 80080f4:	881b      	ldrh	r3, [r3, #0]
 80080f6:	18d3      	adds	r3, r2, r3
 80080f8:	b29a      	uxth	r2, r3
                                                                          SX1276.Settings.LoRaPacketHandler.SnrValue;
 80080fa:	4b1e      	ldr	r3, [pc, #120]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 80080fc:	2160      	movs	r1, #96	; 0x60
 80080fe:	565b      	ldrsb	r3, [r3, r1]
 8008100:	b29b      	uxth	r3, r3
                            SX1276.Settings.LoRaPacketHandler.RssiValue = RSSI_OFFSET_HF + rssi + ( rssi >> 4 ) +
 8008102:	18d3      	adds	r3, r2, r3
 8008104:	b29b      	uxth	r3, r3
 8008106:	3b9d      	subs	r3, #157	; 0x9d
 8008108:	b29b      	uxth	r3, r3
 800810a:	b219      	sxth	r1, r3
 800810c:	4b19      	ldr	r3, [pc, #100]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 800810e:	2262      	movs	r2, #98	; 0x62
 8008110:	5299      	strh	r1, [r3, r2]
 8008112:	e04e      	b.n	80081b2 <SX1276OnDio0Irq+0x37a>
                            SX1276.Settings.LoRaPacketHandler.RssiValue = RSSI_OFFSET_LF + rssi + ( rssi >> 4 ) +
 8008114:	210e      	movs	r1, #14
 8008116:	187b      	adds	r3, r7, r1
 8008118:	2200      	movs	r2, #0
 800811a:	5e9b      	ldrsh	r3, [r3, r2]
 800811c:	111b      	asrs	r3, r3, #4
 800811e:	b21b      	sxth	r3, r3
 8008120:	b29a      	uxth	r2, r3
 8008122:	187b      	adds	r3, r7, r1
 8008124:	881b      	ldrh	r3, [r3, #0]
 8008126:	18d3      	adds	r3, r2, r3
 8008128:	b29a      	uxth	r2, r3
                                                                          SX1276.Settings.LoRaPacketHandler.SnrValue;
 800812a:	4b12      	ldr	r3, [pc, #72]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 800812c:	2160      	movs	r1, #96	; 0x60
 800812e:	565b      	ldrsb	r3, [r3, r1]
 8008130:	b29b      	uxth	r3, r3
                            SX1276.Settings.LoRaPacketHandler.RssiValue = RSSI_OFFSET_LF + rssi + ( rssi >> 4 ) +
 8008132:	18d3      	adds	r3, r2, r3
 8008134:	b29b      	uxth	r3, r3
 8008136:	3ba4      	subs	r3, #164	; 0xa4
 8008138:	b29b      	uxth	r3, r3
 800813a:	b219      	sxth	r1, r3
 800813c:	4b0d      	ldr	r3, [pc, #52]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 800813e:	2262      	movs	r2, #98	; 0x62
 8008140:	5299      	strh	r1, [r3, r2]
 8008142:	e036      	b.n	80081b2 <SX1276OnDio0Irq+0x37a>
                        if( SX1276.Settings.Channel > RF_MID_BAND_THRESH )
 8008144:	4b0b      	ldr	r3, [pc, #44]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 8008146:	689b      	ldr	r3, [r3, #8]
 8008148:	4a10      	ldr	r2, [pc, #64]	; (800818c <SX1276OnDio0Irq+0x354>)
 800814a:	4293      	cmp	r3, r2
 800814c:	d920      	bls.n	8008190 <SX1276OnDio0Irq+0x358>
                            SX1276.Settings.LoRaPacketHandler.RssiValue = RSSI_OFFSET_HF + rssi + ( rssi >> 4 );
 800814e:	210e      	movs	r1, #14
 8008150:	187b      	adds	r3, r7, r1
 8008152:	2200      	movs	r2, #0
 8008154:	5e9b      	ldrsh	r3, [r3, r2]
 8008156:	111b      	asrs	r3, r3, #4
 8008158:	b21b      	sxth	r3, r3
 800815a:	b29a      	uxth	r2, r3
 800815c:	187b      	adds	r3, r7, r1
 800815e:	881b      	ldrh	r3, [r3, #0]
 8008160:	18d3      	adds	r3, r2, r3
 8008162:	b29b      	uxth	r3, r3
 8008164:	3b9d      	subs	r3, #157	; 0x9d
 8008166:	b29b      	uxth	r3, r3
 8008168:	b219      	sxth	r1, r3
 800816a:	4b02      	ldr	r3, [pc, #8]	; (8008174 <SX1276OnDio0Irq+0x33c>)
 800816c:	2262      	movs	r2, #98	; 0x62
 800816e:	5299      	strh	r1, [r3, r2]
 8008170:	e01f      	b.n	80081b2 <SX1276OnDio0Irq+0x37a>
 8008172:	46c0      	nop			; (mov r8, r8)
 8008174:	2000175c 	.word	0x2000175c
 8008178:	200017c4 	.word	0x200017c4
 800817c:	20001744 	.word	0x20001744
 8008180:	20000350 	.word	0x20000350
 8008184:	20001796 	.word	0x20001796
 8008188:	20000354 	.word	0x20000354
 800818c:	1f4add40 	.word	0x1f4add40
                            SX1276.Settings.LoRaPacketHandler.RssiValue = RSSI_OFFSET_LF + rssi + ( rssi >> 4 );
 8008190:	210e      	movs	r1, #14
 8008192:	187b      	adds	r3, r7, r1
 8008194:	2200      	movs	r2, #0
 8008196:	5e9b      	ldrsh	r3, [r3, r2]
 8008198:	111b      	asrs	r3, r3, #4
 800819a:	b21b      	sxth	r3, r3
 800819c:	b29a      	uxth	r2, r3
 800819e:	187b      	adds	r3, r7, r1
 80081a0:	881b      	ldrh	r3, [r3, #0]
 80081a2:	18d3      	adds	r3, r2, r3
 80081a4:	b29b      	uxth	r3, r3
 80081a6:	3ba4      	subs	r3, #164	; 0xa4
 80081a8:	b29b      	uxth	r3, r3
 80081aa:	b219      	sxth	r1, r3
 80081ac:	4b34      	ldr	r3, [pc, #208]	; (8008280 <SX1276OnDio0Irq+0x448>)
 80081ae:	2262      	movs	r2, #98	; 0x62
 80081b0:	5299      	strh	r1, [r3, r2]
                    SX1276.Settings.LoRaPacketHandler.Size = SX1276Read( REG_LR_RXNBBYTES );
 80081b2:	2013      	movs	r0, #19
 80081b4:	f7ff fc70 	bl	8007a98 <SX1276Read>
 80081b8:	0003      	movs	r3, r0
 80081ba:	0019      	movs	r1, r3
 80081bc:	4b30      	ldr	r3, [pc, #192]	; (8008280 <SX1276OnDio0Irq+0x448>)
 80081be:	2264      	movs	r2, #100	; 0x64
 80081c0:	5499      	strb	r1, [r3, r2]
                    SX1276Write( REG_LR_FIFOADDRPTR, SX1276Read( REG_LR_FIFORXCURRENTADDR ) );
 80081c2:	2010      	movs	r0, #16
 80081c4:	f7ff fc68 	bl	8007a98 <SX1276Read>
 80081c8:	0003      	movs	r3, r0
 80081ca:	0019      	movs	r1, r3
 80081cc:	200d      	movs	r0, #13
 80081ce:	f7ff fc4f 	bl	8007a70 <SX1276Write>
                    SX1276ReadFifo( RxTxBuffer, SX1276.Settings.LoRaPacketHandler.Size );
 80081d2:	4b2b      	ldr	r3, [pc, #172]	; (8008280 <SX1276OnDio0Irq+0x448>)
 80081d4:	2264      	movs	r2, #100	; 0x64
 80081d6:	5c9a      	ldrb	r2, [r3, r2]
 80081d8:	4b2a      	ldr	r3, [pc, #168]	; (8008284 <SX1276OnDio0Irq+0x44c>)
 80081da:	0011      	movs	r1, r2
 80081dc:	0018      	movs	r0, r3
 80081de:	f7ff fd07 	bl	8007bf0 <SX1276ReadFifo>
                    if( SX1276.Settings.LoRa.RxContinuous == false )
 80081e2:	4b27      	ldr	r3, [pc, #156]	; (8008280 <SX1276OnDio0Irq+0x448>)
 80081e4:	2256      	movs	r2, #86	; 0x56
 80081e6:	5c9b      	ldrb	r3, [r3, r2]
 80081e8:	2201      	movs	r2, #1
 80081ea:	4053      	eors	r3, r2
 80081ec:	b2db      	uxtb	r3, r3
 80081ee:	2b00      	cmp	r3, #0
 80081f0:	d002      	beq.n	80081f8 <SX1276OnDio0Irq+0x3c0>
                        SX1276.Settings.State = RF_IDLE;
 80081f2:	4b23      	ldr	r3, [pc, #140]	; (8008280 <SX1276OnDio0Irq+0x448>)
 80081f4:	2200      	movs	r2, #0
 80081f6:	711a      	strb	r2, [r3, #4]
                    TimerStop( &RxTimeoutTimer );
 80081f8:	4b23      	ldr	r3, [pc, #140]	; (8008288 <SX1276OnDio0Irq+0x450>)
 80081fa:	0018      	movs	r0, r3
 80081fc:	f012 ff1e 	bl	801b03c <TimerStop>
                    if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 8008200:	4b22      	ldr	r3, [pc, #136]	; (800828c <SX1276OnDio0Irq+0x454>)
 8008202:	681b      	ldr	r3, [r3, #0]
 8008204:	2b00      	cmp	r3, #0
 8008206:	d016      	beq.n	8008236 <SX1276OnDio0Irq+0x3fe>
 8008208:	4b20      	ldr	r3, [pc, #128]	; (800828c <SX1276OnDio0Irq+0x454>)
 800820a:	681b      	ldr	r3, [r3, #0]
 800820c:	689b      	ldr	r3, [r3, #8]
 800820e:	2b00      	cmp	r3, #0
 8008210:	d011      	beq.n	8008236 <SX1276OnDio0Irq+0x3fe>
                        RadioEvents->RxDone( RxTxBuffer, SX1276.Settings.LoRaPacketHandler.Size, SX1276.Settings.LoRaPacketHandler.RssiValue, SX1276.Settings.LoRaPacketHandler.SnrValue );
 8008212:	4b1e      	ldr	r3, [pc, #120]	; (800828c <SX1276OnDio0Irq+0x454>)
 8008214:	681b      	ldr	r3, [r3, #0]
 8008216:	689c      	ldr	r4, [r3, #8]
 8008218:	4b19      	ldr	r3, [pc, #100]	; (8008280 <SX1276OnDio0Irq+0x448>)
 800821a:	2264      	movs	r2, #100	; 0x64
 800821c:	5c9b      	ldrb	r3, [r3, r2]
 800821e:	b299      	uxth	r1, r3
 8008220:	4b17      	ldr	r3, [pc, #92]	; (8008280 <SX1276OnDio0Irq+0x448>)
 8008222:	2262      	movs	r2, #98	; 0x62
 8008224:	5e9a      	ldrsh	r2, [r3, r2]
 8008226:	4b16      	ldr	r3, [pc, #88]	; (8008280 <SX1276OnDio0Irq+0x448>)
 8008228:	2060      	movs	r0, #96	; 0x60
 800822a:	561b      	ldrsb	r3, [r3, r0]
 800822c:	4815      	ldr	r0, [pc, #84]	; (8008284 <SX1276OnDio0Irq+0x44c>)
 800822e:	47a0      	blx	r4
                break;
 8008230:	e001      	b.n	8008236 <SX1276OnDio0Irq+0x3fe>
                        break;
 8008232:	46c0      	nop			; (mov r8, r8)
 8008234:	e01f      	b.n	8008276 <SX1276OnDio0Irq+0x43e>
                break;
 8008236:	46c0      	nop			; (mov r8, r8)
            break;
 8008238:	e01d      	b.n	8008276 <SX1276OnDio0Irq+0x43e>
            TimerStop( &TxTimeoutTimer );
 800823a:	4b15      	ldr	r3, [pc, #84]	; (8008290 <SX1276OnDio0Irq+0x458>)
 800823c:	0018      	movs	r0, r3
 800823e:	f012 fefd 	bl	801b03c <TimerStop>
            switch( SX1276.Settings.Modem )
 8008242:	4b0f      	ldr	r3, [pc, #60]	; (8008280 <SX1276OnDio0Irq+0x448>)
 8008244:	795b      	ldrb	r3, [r3, #5]
 8008246:	2b01      	cmp	r3, #1
 8008248:	d103      	bne.n	8008252 <SX1276OnDio0Irq+0x41a>
                SX1276Write( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_TXDONE );
 800824a:	2108      	movs	r1, #8
 800824c:	2012      	movs	r0, #18
 800824e:	f7ff fc0f 	bl	8007a70 <SX1276Write>
                SX1276.Settings.State = RF_IDLE;
 8008252:	4b0b      	ldr	r3, [pc, #44]	; (8008280 <SX1276OnDio0Irq+0x448>)
 8008254:	2200      	movs	r2, #0
 8008256:	711a      	strb	r2, [r3, #4]
                if( ( RadioEvents != NULL ) && ( RadioEvents->TxDone != NULL ) )
 8008258:	4b0c      	ldr	r3, [pc, #48]	; (800828c <SX1276OnDio0Irq+0x454>)
 800825a:	681b      	ldr	r3, [r3, #0]
 800825c:	2b00      	cmp	r3, #0
 800825e:	d008      	beq.n	8008272 <SX1276OnDio0Irq+0x43a>
 8008260:	4b0a      	ldr	r3, [pc, #40]	; (800828c <SX1276OnDio0Irq+0x454>)
 8008262:	681b      	ldr	r3, [r3, #0]
 8008264:	681b      	ldr	r3, [r3, #0]
 8008266:	2b00      	cmp	r3, #0
 8008268:	d003      	beq.n	8008272 <SX1276OnDio0Irq+0x43a>
                    RadioEvents->TxDone( );
 800826a:	4b08      	ldr	r3, [pc, #32]	; (800828c <SX1276OnDio0Irq+0x454>)
 800826c:	681b      	ldr	r3, [r3, #0]
 800826e:	681b      	ldr	r3, [r3, #0]
 8008270:	4798      	blx	r3
                break;
 8008272:	46c0      	nop			; (mov r8, r8)
            break;
 8008274:	46c0      	nop			; (mov r8, r8)
    }
}
 8008276:	46c0      	nop			; (mov r8, r8)
 8008278:	46bd      	mov	sp, r7
 800827a:	b005      	add	sp, #20
 800827c:	bd90      	pop	{r4, r7, pc}
 800827e:	46c0      	nop			; (mov r8, r8)
 8008280:	2000175c 	.word	0x2000175c
 8008284:	20000354 	.word	0x20000354
 8008288:	200017c4 	.word	0x200017c4
 800828c:	20000350 	.word	0x20000350
 8008290:	2000172c 	.word	0x2000172c

08008294 <SX1276OnDio1Irq>:

void SX1276OnDio1Irq( void* context )
{
 8008294:	b580      	push	{r7, lr}
 8008296:	b082      	sub	sp, #8
 8008298:	af00      	add	r7, sp, #0
 800829a:	6078      	str	r0, [r7, #4]
    switch( SX1276.Settings.State )
 800829c:	4b62      	ldr	r3, [pc, #392]	; (8008428 <SX1276OnDio1Irq+0x194>)
 800829e:	791b      	ldrb	r3, [r3, #4]
 80082a0:	2b01      	cmp	r3, #1
 80082a2:	d003      	beq.n	80082ac <SX1276OnDio1Irq+0x18>
 80082a4:	2b02      	cmp	r3, #2
 80082a6:	d100      	bne.n	80082aa <SX1276OnDio1Irq+0x16>
 80082a8:	e07d      	b.n	80083a6 <SX1276OnDio1Irq+0x112>
            default:
                break;
            }
            break;
        default:
            break;
 80082aa:	e0b9      	b.n	8008420 <SX1276OnDio1Irq+0x18c>
            switch( SX1276.Settings.Modem )
 80082ac:	4b5e      	ldr	r3, [pc, #376]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80082ae:	795b      	ldrb	r3, [r3, #5]
 80082b0:	2b00      	cmp	r3, #0
 80082b2:	d002      	beq.n	80082ba <SX1276OnDio1Irq+0x26>
 80082b4:	2b01      	cmp	r3, #1
 80082b6:	d05c      	beq.n	8008372 <SX1276OnDio1Irq+0xde>
                break;
 80082b8:	e074      	b.n	80083a4 <SX1276OnDio1Irq+0x110>
                TimerStop( &RxTimeoutSyncWord );
 80082ba:	4b5c      	ldr	r3, [pc, #368]	; (800842c <SX1276OnDio1Irq+0x198>)
 80082bc:	0018      	movs	r0, r3
 80082be:	f012 febd 	bl	801b03c <TimerStop>
                if( ( SX1276.Settings.FskPacketHandler.Size == 0 ) && ( SX1276.Settings.FskPacketHandler.NbBytes == 0 ) )
 80082c2:	4b59      	ldr	r3, [pc, #356]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80082c4:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 80082c6:	2b00      	cmp	r3, #0
 80082c8:	d118      	bne.n	80082fc <SX1276OnDio1Irq+0x68>
 80082ca:	4b57      	ldr	r3, [pc, #348]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80082cc:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 80082ce:	2b00      	cmp	r3, #0
 80082d0:	d114      	bne.n	80082fc <SX1276OnDio1Irq+0x68>
                    if( SX1276.Settings.Fsk.FixLen == false )
 80082d2:	4b55      	ldr	r3, [pc, #340]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80082d4:	2222      	movs	r2, #34	; 0x22
 80082d6:	5c9b      	ldrb	r3, [r3, r2]
 80082d8:	2201      	movs	r2, #1
 80082da:	4053      	eors	r3, r2
 80082dc:	b2db      	uxtb	r3, r3
 80082de:	2b00      	cmp	r3, #0
 80082e0:	d005      	beq.n	80082ee <SX1276OnDio1Irq+0x5a>
                        SX1276ReadFifo( ( uint8_t* )&SX1276.Settings.FskPacketHandler.Size, 1 );
 80082e2:	4b53      	ldr	r3, [pc, #332]	; (8008430 <SX1276OnDio1Irq+0x19c>)
 80082e4:	2101      	movs	r1, #1
 80082e6:	0018      	movs	r0, r3
 80082e8:	f7ff fc82 	bl	8007bf0 <SX1276ReadFifo>
 80082ec:	e006      	b.n	80082fc <SX1276OnDio1Irq+0x68>
                        SX1276.Settings.FskPacketHandler.Size = SX1276Read( REG_PAYLOADLENGTH );
 80082ee:	2032      	movs	r0, #50	; 0x32
 80082f0:	f7ff fbd2 	bl	8007a98 <SX1276Read>
 80082f4:	0003      	movs	r3, r0
 80082f6:	b29a      	uxth	r2, r3
 80082f8:	4b4b      	ldr	r3, [pc, #300]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80082fa:	875a      	strh	r2, [r3, #58]	; 0x3a
                if( ( SX1276.Settings.FskPacketHandler.Size - SX1276.Settings.FskPacketHandler.NbBytes ) >= SX1276.Settings.FskPacketHandler.FifoThresh )
 80082fc:	4b4a      	ldr	r3, [pc, #296]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80082fe:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 8008300:	001a      	movs	r2, r3
 8008302:	4b49      	ldr	r3, [pc, #292]	; (8008428 <SX1276OnDio1Irq+0x194>)
 8008304:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 8008306:	1ad3      	subs	r3, r2, r3
 8008308:	4a47      	ldr	r2, [pc, #284]	; (8008428 <SX1276OnDio1Irq+0x194>)
 800830a:	213e      	movs	r1, #62	; 0x3e
 800830c:	5c52      	ldrb	r2, [r2, r1]
 800830e:	4293      	cmp	r3, r2
 8008310:	db1a      	blt.n	8008348 <SX1276OnDio1Irq+0xb4>
                    SX1276ReadFifo( ( RxTxBuffer + SX1276.Settings.FskPacketHandler.NbBytes ), SX1276.Settings.FskPacketHandler.FifoThresh - 1 );
 8008312:	4b45      	ldr	r3, [pc, #276]	; (8008428 <SX1276OnDio1Irq+0x194>)
 8008314:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 8008316:	001a      	movs	r2, r3
 8008318:	4b46      	ldr	r3, [pc, #280]	; (8008434 <SX1276OnDio1Irq+0x1a0>)
 800831a:	18d2      	adds	r2, r2, r3
 800831c:	4b42      	ldr	r3, [pc, #264]	; (8008428 <SX1276OnDio1Irq+0x194>)
 800831e:	213e      	movs	r1, #62	; 0x3e
 8008320:	5c5b      	ldrb	r3, [r3, r1]
 8008322:	3b01      	subs	r3, #1
 8008324:	b2db      	uxtb	r3, r3
 8008326:	0019      	movs	r1, r3
 8008328:	0010      	movs	r0, r2
 800832a:	f7ff fc61 	bl	8007bf0 <SX1276ReadFifo>
                    SX1276.Settings.FskPacketHandler.NbBytes += SX1276.Settings.FskPacketHandler.FifoThresh - 1;
 800832e:	4b3e      	ldr	r3, [pc, #248]	; (8008428 <SX1276OnDio1Irq+0x194>)
 8008330:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
 8008332:	4b3d      	ldr	r3, [pc, #244]	; (8008428 <SX1276OnDio1Irq+0x194>)
 8008334:	213e      	movs	r1, #62	; 0x3e
 8008336:	5c5b      	ldrb	r3, [r3, r1]
 8008338:	b29b      	uxth	r3, r3
 800833a:	18d3      	adds	r3, r2, r3
 800833c:	b29b      	uxth	r3, r3
 800833e:	3b01      	subs	r3, #1
 8008340:	b29a      	uxth	r2, r3
 8008342:	4b39      	ldr	r3, [pc, #228]	; (8008428 <SX1276OnDio1Irq+0x194>)
 8008344:	879a      	strh	r2, [r3, #60]	; 0x3c
                break;
 8008346:	e02d      	b.n	80083a4 <SX1276OnDio1Irq+0x110>
                    SX1276ReadFifo( ( RxTxBuffer + SX1276.Settings.FskPacketHandler.NbBytes ), SX1276.Settings.FskPacketHandler.Size - SX1276.Settings.FskPacketHandler.NbBytes );
 8008348:	4b37      	ldr	r3, [pc, #220]	; (8008428 <SX1276OnDio1Irq+0x194>)
 800834a:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800834c:	001a      	movs	r2, r3
 800834e:	4b39      	ldr	r3, [pc, #228]	; (8008434 <SX1276OnDio1Irq+0x1a0>)
 8008350:	18d0      	adds	r0, r2, r3
 8008352:	4b35      	ldr	r3, [pc, #212]	; (8008428 <SX1276OnDio1Irq+0x194>)
 8008354:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 8008356:	b2da      	uxtb	r2, r3
 8008358:	4b33      	ldr	r3, [pc, #204]	; (8008428 <SX1276OnDio1Irq+0x194>)
 800835a:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800835c:	b2db      	uxtb	r3, r3
 800835e:	1ad3      	subs	r3, r2, r3
 8008360:	b2db      	uxtb	r3, r3
 8008362:	0019      	movs	r1, r3
 8008364:	f7ff fc44 	bl	8007bf0 <SX1276ReadFifo>
                    SX1276.Settings.FskPacketHandler.NbBytes += ( SX1276.Settings.FskPacketHandler.Size - SX1276.Settings.FskPacketHandler.NbBytes );
 8008368:	4b2f      	ldr	r3, [pc, #188]	; (8008428 <SX1276OnDio1Irq+0x194>)
 800836a:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
 800836c:	4b2e      	ldr	r3, [pc, #184]	; (8008428 <SX1276OnDio1Irq+0x194>)
 800836e:	879a      	strh	r2, [r3, #60]	; 0x3c
                break;
 8008370:	e018      	b.n	80083a4 <SX1276OnDio1Irq+0x110>
                TimerStop( &RxTimeoutTimer );
 8008372:	4b31      	ldr	r3, [pc, #196]	; (8008438 <SX1276OnDio1Irq+0x1a4>)
 8008374:	0018      	movs	r0, r3
 8008376:	f012 fe61 	bl	801b03c <TimerStop>
                SX1276Write( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXTIMEOUT );
 800837a:	2180      	movs	r1, #128	; 0x80
 800837c:	2012      	movs	r0, #18
 800837e:	f7ff fb77 	bl	8007a70 <SX1276Write>
                SX1276.Settings.State = RF_IDLE;
 8008382:	4b29      	ldr	r3, [pc, #164]	; (8008428 <SX1276OnDio1Irq+0x194>)
 8008384:	2200      	movs	r2, #0
 8008386:	711a      	strb	r2, [r3, #4]
                if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8008388:	4b2c      	ldr	r3, [pc, #176]	; (800843c <SX1276OnDio1Irq+0x1a8>)
 800838a:	681b      	ldr	r3, [r3, #0]
 800838c:	2b00      	cmp	r3, #0
 800838e:	d008      	beq.n	80083a2 <SX1276OnDio1Irq+0x10e>
 8008390:	4b2a      	ldr	r3, [pc, #168]	; (800843c <SX1276OnDio1Irq+0x1a8>)
 8008392:	681b      	ldr	r3, [r3, #0]
 8008394:	68db      	ldr	r3, [r3, #12]
 8008396:	2b00      	cmp	r3, #0
 8008398:	d003      	beq.n	80083a2 <SX1276OnDio1Irq+0x10e>
                    RadioEvents->RxTimeout( );
 800839a:	4b28      	ldr	r3, [pc, #160]	; (800843c <SX1276OnDio1Irq+0x1a8>)
 800839c:	681b      	ldr	r3, [r3, #0]
 800839e:	68db      	ldr	r3, [r3, #12]
 80083a0:	4798      	blx	r3
                break;
 80083a2:	46c0      	nop			; (mov r8, r8)
            break;
 80083a4:	e03c      	b.n	8008420 <SX1276OnDio1Irq+0x18c>
            switch( SX1276.Settings.Modem )
 80083a6:	4b20      	ldr	r3, [pc, #128]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80083a8:	795b      	ldrb	r3, [r3, #5]
 80083aa:	2b00      	cmp	r3, #0
 80083ac:	d136      	bne.n	800841c <SX1276OnDio1Irq+0x188>
                if( ( SX1276.Settings.FskPacketHandler.Size - SX1276.Settings.FskPacketHandler.NbBytes ) > SX1276.Settings.FskPacketHandler.ChunkSize )
 80083ae:	4b1e      	ldr	r3, [pc, #120]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80083b0:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 80083b2:	001a      	movs	r2, r3
 80083b4:	4b1c      	ldr	r3, [pc, #112]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80083b6:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 80083b8:	1ad3      	subs	r3, r2, r3
 80083ba:	4a1b      	ldr	r2, [pc, #108]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80083bc:	213f      	movs	r1, #63	; 0x3f
 80083be:	5c52      	ldrb	r2, [r2, r1]
 80083c0:	4293      	cmp	r3, r2
 80083c2:	dd16      	ble.n	80083f2 <SX1276OnDio1Irq+0x15e>
                    SX1276WriteFifo( ( RxTxBuffer + SX1276.Settings.FskPacketHandler.NbBytes ), SX1276.Settings.FskPacketHandler.ChunkSize );
 80083c4:	4b18      	ldr	r3, [pc, #96]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80083c6:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 80083c8:	001a      	movs	r2, r3
 80083ca:	4b1a      	ldr	r3, [pc, #104]	; (8008434 <SX1276OnDio1Irq+0x1a0>)
 80083cc:	18d2      	adds	r2, r2, r3
 80083ce:	4b16      	ldr	r3, [pc, #88]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80083d0:	213f      	movs	r1, #63	; 0x3f
 80083d2:	5c5b      	ldrb	r3, [r3, r1]
 80083d4:	0019      	movs	r1, r3
 80083d6:	0010      	movs	r0, r2
 80083d8:	f7ff fbf8 	bl	8007bcc <SX1276WriteFifo>
                    SX1276.Settings.FskPacketHandler.NbBytes += SX1276.Settings.FskPacketHandler.ChunkSize;
 80083dc:	4b12      	ldr	r3, [pc, #72]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80083de:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
 80083e0:	4b11      	ldr	r3, [pc, #68]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80083e2:	213f      	movs	r1, #63	; 0x3f
 80083e4:	5c5b      	ldrb	r3, [r3, r1]
 80083e6:	b29b      	uxth	r3, r3
 80083e8:	18d3      	adds	r3, r2, r3
 80083ea:	b29a      	uxth	r2, r3
 80083ec:	4b0e      	ldr	r3, [pc, #56]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80083ee:	879a      	strh	r2, [r3, #60]	; 0x3c
                break;
 80083f0:	e015      	b.n	800841e <SX1276OnDio1Irq+0x18a>
                    SX1276WriteFifo( RxTxBuffer + SX1276.Settings.FskPacketHandler.NbBytes, SX1276.Settings.FskPacketHandler.Size - SX1276.Settings.FskPacketHandler.NbBytes );
 80083f2:	4b0d      	ldr	r3, [pc, #52]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80083f4:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 80083f6:	001a      	movs	r2, r3
 80083f8:	4b0e      	ldr	r3, [pc, #56]	; (8008434 <SX1276OnDio1Irq+0x1a0>)
 80083fa:	18d0      	adds	r0, r2, r3
 80083fc:	4b0a      	ldr	r3, [pc, #40]	; (8008428 <SX1276OnDio1Irq+0x194>)
 80083fe:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 8008400:	b2da      	uxtb	r2, r3
 8008402:	4b09      	ldr	r3, [pc, #36]	; (8008428 <SX1276OnDio1Irq+0x194>)
 8008404:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 8008406:	b2db      	uxtb	r3, r3
 8008408:	1ad3      	subs	r3, r2, r3
 800840a:	b2db      	uxtb	r3, r3
 800840c:	0019      	movs	r1, r3
 800840e:	f7ff fbdd 	bl	8007bcc <SX1276WriteFifo>
                    SX1276.Settings.FskPacketHandler.NbBytes += SX1276.Settings.FskPacketHandler.Size - SX1276.Settings.FskPacketHandler.NbBytes;
 8008412:	4b05      	ldr	r3, [pc, #20]	; (8008428 <SX1276OnDio1Irq+0x194>)
 8008414:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
 8008416:	4b04      	ldr	r3, [pc, #16]	; (8008428 <SX1276OnDio1Irq+0x194>)
 8008418:	879a      	strh	r2, [r3, #60]	; 0x3c
                break;
 800841a:	e000      	b.n	800841e <SX1276OnDio1Irq+0x18a>
                break;
 800841c:	46c0      	nop			; (mov r8, r8)
            break;
 800841e:	46c0      	nop			; (mov r8, r8)
    }
}
 8008420:	46c0      	nop			; (mov r8, r8)
 8008422:	46bd      	mov	sp, r7
 8008424:	b002      	add	sp, #8
 8008426:	bd80      	pop	{r7, pc}
 8008428:	2000175c 	.word	0x2000175c
 800842c:	20001744 	.word	0x20001744
 8008430:	20001796 	.word	0x20001796
 8008434:	20000354 	.word	0x20000354
 8008438:	200017c4 	.word	0x200017c4
 800843c:	20000350 	.word	0x20000350

08008440 <SX1276OnDio2Irq>:

void SX1276OnDio2Irq( void* context )
{
 8008440:	b590      	push	{r4, r7, lr}
 8008442:	b087      	sub	sp, #28
 8008444:	af00      	add	r7, sp, #0
 8008446:	6078      	str	r0, [r7, #4]
    uint32_t afcChannel = 0;
 8008448:	2300      	movs	r3, #0
 800844a:	617b      	str	r3, [r7, #20]

    switch( SX1276.Settings.State )
 800844c:	4b5d      	ldr	r3, [pc, #372]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 800844e:	791b      	ldrb	r3, [r3, #4]
 8008450:	2b01      	cmp	r3, #1
 8008452:	d003      	beq.n	800845c <SX1276OnDio2Irq+0x1c>
 8008454:	2b02      	cmp	r3, #2
 8008456:	d100      	bne.n	800845a <SX1276OnDio2Irq+0x1a>
 8008458:	e083      	b.n	8008562 <SX1276OnDio2Irq+0x122>
            default:
                break;
            }
            break;
        default:
            break;
 800845a:	e0ae      	b.n	80085ba <SX1276OnDio2Irq+0x17a>
            switch( SX1276.Settings.Modem )
 800845c:	4b59      	ldr	r3, [pc, #356]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 800845e:	795b      	ldrb	r3, [r3, #5]
 8008460:	2b00      	cmp	r3, #0
 8008462:	d002      	beq.n	800846a <SX1276OnDio2Irq+0x2a>
 8008464:	2b01      	cmp	r3, #1
 8008466:	d058      	beq.n	800851a <SX1276OnDio2Irq+0xda>
                break;
 8008468:	e07a      	b.n	8008560 <SX1276OnDio2Irq+0x120>
                SX1276.Settings.FskPacketHandler.PreambleDetected = true;
 800846a:	4b56      	ldr	r3, [pc, #344]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 800846c:	2230      	movs	r2, #48	; 0x30
 800846e:	2101      	movs	r1, #1
 8008470:	5499      	strb	r1, [r3, r2]
                if( ( SX1276.Settings.FskPacketHandler.PreambleDetected == true ) && ( SX1276.Settings.FskPacketHandler.SyncWordDetected == false ) )
 8008472:	4b54      	ldr	r3, [pc, #336]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 8008474:	2230      	movs	r2, #48	; 0x30
 8008476:	5c9b      	ldrb	r3, [r3, r2]
 8008478:	2b01      	cmp	r3, #1
 800847a:	d16e      	bne.n	800855a <SX1276OnDio2Irq+0x11a>
 800847c:	4b51      	ldr	r3, [pc, #324]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 800847e:	2231      	movs	r2, #49	; 0x31
 8008480:	5c9b      	ldrb	r3, [r3, r2]
 8008482:	2b00      	cmp	r3, #0
 8008484:	d169      	bne.n	800855a <SX1276OnDio2Irq+0x11a>
                    TimerStop( &RxTimeoutSyncWord );
 8008486:	4b50      	ldr	r3, [pc, #320]	; (80085c8 <SX1276OnDio2Irq+0x188>)
 8008488:	0018      	movs	r0, r3
 800848a:	f012 fdd7 	bl	801b03c <TimerStop>
                    SX1276.Settings.FskPacketHandler.SyncWordDetected = true;
 800848e:	4b4d      	ldr	r3, [pc, #308]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 8008490:	2231      	movs	r2, #49	; 0x31
 8008492:	2101      	movs	r1, #1
 8008494:	5499      	strb	r1, [r3, r2]
                    SX1276.Settings.FskPacketHandler.RssiValue = -( SX1276Read( REG_RSSIVALUE ) >> 1 );
 8008496:	2011      	movs	r0, #17
 8008498:	f7ff fafe 	bl	8007a98 <SX1276Read>
 800849c:	0003      	movs	r3, r0
 800849e:	085b      	lsrs	r3, r3, #1
 80084a0:	b2db      	uxtb	r3, r3
 80084a2:	425b      	negs	r3, r3
 80084a4:	b2db      	uxtb	r3, r3
 80084a6:	b259      	sxtb	r1, r3
 80084a8:	4b46      	ldr	r3, [pc, #280]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 80084aa:	2232      	movs	r2, #50	; 0x32
 80084ac:	5499      	strb	r1, [r3, r2]
                    afcChannel = ( ( ( uint16_t )SX1276Read( REG_AFCMSB ) << 8 ) |
 80084ae:	201b      	movs	r0, #27
 80084b0:	f7ff faf2 	bl	8007a98 <SX1276Read>
 80084b4:	0003      	movs	r3, r0
 80084b6:	021c      	lsls	r4, r3, #8
                                     ( uint16_t )SX1276Read( REG_AFCLSB ) );
 80084b8:	201c      	movs	r0, #28
 80084ba:	f7ff faed 	bl	8007a98 <SX1276Read>
 80084be:	0003      	movs	r3, r0
                    afcChannel = ( ( ( uint16_t )SX1276Read( REG_AFCMSB ) << 8 ) |
 80084c0:	4323      	orrs	r3, r4
 80084c2:	617b      	str	r3, [r7, #20]
                    SX_CHANNEL_TO_FREQ( afcChannel, SX1276.Settings.FskPacketHandler.AfcValue );
 80084c4:	697b      	ldr	r3, [r7, #20]
 80084c6:	0a1b      	lsrs	r3, r3, #8
 80084c8:	613b      	str	r3, [r7, #16]
 80084ca:	693b      	ldr	r3, [r7, #16]
 80084cc:	021b      	lsls	r3, r3, #8
 80084ce:	697a      	ldr	r2, [r7, #20]
 80084d0:	1ad3      	subs	r3, r2, r3
 80084d2:	60fb      	str	r3, [r7, #12]
 80084d4:	6939      	ldr	r1, [r7, #16]
 80084d6:	000b      	movs	r3, r1
 80084d8:	015b      	lsls	r3, r3, #5
 80084da:	1a5b      	subs	r3, r3, r1
 80084dc:	019a      	lsls	r2, r3, #6
 80084de:	1ad2      	subs	r2, r2, r3
 80084e0:	00d2      	lsls	r2, r2, #3
 80084e2:	1850      	adds	r0, r2, r1
 80084e4:	68f9      	ldr	r1, [r7, #12]
 80084e6:	000b      	movs	r3, r1
 80084e8:	015b      	lsls	r3, r3, #5
 80084ea:	1a5b      	subs	r3, r3, r1
 80084ec:	019a      	lsls	r2, r3, #6
 80084ee:	1ad2      	subs	r2, r2, r3
 80084f0:	00d2      	lsls	r2, r2, #3
 80084f2:	1853      	adds	r3, r2, r1
 80084f4:	3380      	adds	r3, #128	; 0x80
 80084f6:	0a1b      	lsrs	r3, r3, #8
 80084f8:	18c3      	adds	r3, r0, r3
 80084fa:	001a      	movs	r2, r3
 80084fc:	4b31      	ldr	r3, [pc, #196]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 80084fe:	635a      	str	r2, [r3, #52]	; 0x34
                    SX1276.Settings.FskPacketHandler.RxGain = ( SX1276Read( REG_LNA ) >> 5 ) & 0x07;
 8008500:	200c      	movs	r0, #12
 8008502:	f7ff fac9 	bl	8007a98 <SX1276Read>
 8008506:	0003      	movs	r3, r0
 8008508:	095b      	lsrs	r3, r3, #5
 800850a:	b2db      	uxtb	r3, r3
 800850c:	2207      	movs	r2, #7
 800850e:	4013      	ands	r3, r2
 8008510:	b2d9      	uxtb	r1, r3
 8008512:	4b2c      	ldr	r3, [pc, #176]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 8008514:	2238      	movs	r2, #56	; 0x38
 8008516:	5499      	strb	r1, [r3, r2]
                break;
 8008518:	e01f      	b.n	800855a <SX1276OnDio2Irq+0x11a>
                if( SX1276.Settings.LoRa.FreqHopOn == true )
 800851a:	4b2a      	ldr	r3, [pc, #168]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 800851c:	2253      	movs	r2, #83	; 0x53
 800851e:	5c9b      	ldrb	r3, [r3, r2]
 8008520:	2b00      	cmp	r3, #0
 8008522:	d01c      	beq.n	800855e <SX1276OnDio2Irq+0x11e>
                    SX1276Write( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL );
 8008524:	2102      	movs	r1, #2
 8008526:	2012      	movs	r0, #18
 8008528:	f7ff faa2 	bl	8007a70 <SX1276Write>
                    if( ( RadioEvents != NULL ) && ( RadioEvents->FhssChangeChannel != NULL ) )
 800852c:	4b27      	ldr	r3, [pc, #156]	; (80085cc <SX1276OnDio2Irq+0x18c>)
 800852e:	681b      	ldr	r3, [r3, #0]
 8008530:	2b00      	cmp	r3, #0
 8008532:	d014      	beq.n	800855e <SX1276OnDio2Irq+0x11e>
 8008534:	4b25      	ldr	r3, [pc, #148]	; (80085cc <SX1276OnDio2Irq+0x18c>)
 8008536:	681b      	ldr	r3, [r3, #0]
 8008538:	695b      	ldr	r3, [r3, #20]
 800853a:	2b00      	cmp	r3, #0
 800853c:	d00f      	beq.n	800855e <SX1276OnDio2Irq+0x11e>
                        RadioEvents->FhssChangeChannel( ( SX1276Read( REG_LR_HOPCHANNEL ) & RFLR_HOPCHANNEL_CHANNEL_MASK ) );
 800853e:	4b23      	ldr	r3, [pc, #140]	; (80085cc <SX1276OnDio2Irq+0x18c>)
 8008540:	681b      	ldr	r3, [r3, #0]
 8008542:	695c      	ldr	r4, [r3, #20]
 8008544:	201c      	movs	r0, #28
 8008546:	f7ff faa7 	bl	8007a98 <SX1276Read>
 800854a:	0003      	movs	r3, r0
 800854c:	001a      	movs	r2, r3
 800854e:	233f      	movs	r3, #63	; 0x3f
 8008550:	4013      	ands	r3, r2
 8008552:	b2db      	uxtb	r3, r3
 8008554:	0018      	movs	r0, r3
 8008556:	47a0      	blx	r4
                break;
 8008558:	e001      	b.n	800855e <SX1276OnDio2Irq+0x11e>
                break;
 800855a:	46c0      	nop			; (mov r8, r8)
 800855c:	e02d      	b.n	80085ba <SX1276OnDio2Irq+0x17a>
                break;
 800855e:	46c0      	nop			; (mov r8, r8)
            break;
 8008560:	e02b      	b.n	80085ba <SX1276OnDio2Irq+0x17a>
            switch( SX1276.Settings.Modem )
 8008562:	4b18      	ldr	r3, [pc, #96]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 8008564:	795b      	ldrb	r3, [r3, #5]
 8008566:	2b00      	cmp	r3, #0
 8008568:	d021      	beq.n	80085ae <SX1276OnDio2Irq+0x16e>
 800856a:	2b01      	cmp	r3, #1
 800856c:	d121      	bne.n	80085b2 <SX1276OnDio2Irq+0x172>
                if( SX1276.Settings.LoRa.FreqHopOn == true )
 800856e:	4b15      	ldr	r3, [pc, #84]	; (80085c4 <SX1276OnDio2Irq+0x184>)
 8008570:	2253      	movs	r2, #83	; 0x53
 8008572:	5c9b      	ldrb	r3, [r3, r2]
 8008574:	2b00      	cmp	r3, #0
 8008576:	d01e      	beq.n	80085b6 <SX1276OnDio2Irq+0x176>
                    SX1276Write( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL );
 8008578:	2102      	movs	r1, #2
 800857a:	2012      	movs	r0, #18
 800857c:	f7ff fa78 	bl	8007a70 <SX1276Write>
                    if( ( RadioEvents != NULL ) && ( RadioEvents->FhssChangeChannel != NULL ) )
 8008580:	4b12      	ldr	r3, [pc, #72]	; (80085cc <SX1276OnDio2Irq+0x18c>)
 8008582:	681b      	ldr	r3, [r3, #0]
 8008584:	2b00      	cmp	r3, #0
 8008586:	d016      	beq.n	80085b6 <SX1276OnDio2Irq+0x176>
 8008588:	4b10      	ldr	r3, [pc, #64]	; (80085cc <SX1276OnDio2Irq+0x18c>)
 800858a:	681b      	ldr	r3, [r3, #0]
 800858c:	695b      	ldr	r3, [r3, #20]
 800858e:	2b00      	cmp	r3, #0
 8008590:	d011      	beq.n	80085b6 <SX1276OnDio2Irq+0x176>
                        RadioEvents->FhssChangeChannel( ( SX1276Read( REG_LR_HOPCHANNEL ) & RFLR_HOPCHANNEL_CHANNEL_MASK ) );
 8008592:	4b0e      	ldr	r3, [pc, #56]	; (80085cc <SX1276OnDio2Irq+0x18c>)
 8008594:	681b      	ldr	r3, [r3, #0]
 8008596:	695c      	ldr	r4, [r3, #20]
 8008598:	201c      	movs	r0, #28
 800859a:	f7ff fa7d 	bl	8007a98 <SX1276Read>
 800859e:	0003      	movs	r3, r0
 80085a0:	001a      	movs	r2, r3
 80085a2:	233f      	movs	r3, #63	; 0x3f
 80085a4:	4013      	ands	r3, r2
 80085a6:	b2db      	uxtb	r3, r3
 80085a8:	0018      	movs	r0, r3
 80085aa:	47a0      	blx	r4
                break;
 80085ac:	e003      	b.n	80085b6 <SX1276OnDio2Irq+0x176>
                break;
 80085ae:	46c0      	nop			; (mov r8, r8)
 80085b0:	e002      	b.n	80085b8 <SX1276OnDio2Irq+0x178>
                break;
 80085b2:	46c0      	nop			; (mov r8, r8)
 80085b4:	e000      	b.n	80085b8 <SX1276OnDio2Irq+0x178>
                break;
 80085b6:	46c0      	nop			; (mov r8, r8)
            break;
 80085b8:	46c0      	nop			; (mov r8, r8)
    }
}
 80085ba:	46c0      	nop			; (mov r8, r8)
 80085bc:	46bd      	mov	sp, r7
 80085be:	b007      	add	sp, #28
 80085c0:	bd90      	pop	{r4, r7, pc}
 80085c2:	46c0      	nop			; (mov r8, r8)
 80085c4:	2000175c 	.word	0x2000175c
 80085c8:	20001744 	.word	0x20001744
 80085cc:	20000350 	.word	0x20000350

080085d0 <SX1276OnDio3Irq>:

void SX1276OnDio3Irq( void* context )
{
 80085d0:	b580      	push	{r7, lr}
 80085d2:	b082      	sub	sp, #8
 80085d4:	af00      	add	r7, sp, #0
 80085d6:	6078      	str	r0, [r7, #4]
    switch( SX1276.Settings.Modem )
 80085d8:	4b1e      	ldr	r3, [pc, #120]	; (8008654 <SX1276OnDio3Irq+0x84>)
 80085da:	795b      	ldrb	r3, [r3, #5]
 80085dc:	2b00      	cmp	r3, #0
 80085de:	d031      	beq.n	8008644 <SX1276OnDio3Irq+0x74>
 80085e0:	2b01      	cmp	r3, #1
 80085e2:	d000      	beq.n	80085e6 <SX1276OnDio3Irq+0x16>
                RadioEvents->CadDone( false );
            }
        }
        break;
    default:
        break;
 80085e4:	e031      	b.n	800864a <SX1276OnDio3Irq+0x7a>
        if( ( SX1276Read( REG_LR_IRQFLAGS ) & RFLR_IRQFLAGS_CADDETECTED ) == RFLR_IRQFLAGS_CADDETECTED )
 80085e6:	2012      	movs	r0, #18
 80085e8:	f7ff fa56 	bl	8007a98 <SX1276Read>
 80085ec:	0003      	movs	r3, r0
 80085ee:	001a      	movs	r2, r3
 80085f0:	2301      	movs	r3, #1
 80085f2:	4013      	ands	r3, r2
 80085f4:	2b01      	cmp	r3, #1
 80085f6:	d112      	bne.n	800861e <SX1276OnDio3Irq+0x4e>
            SX1276Write( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_CADDETECTED | RFLR_IRQFLAGS_CADDONE );
 80085f8:	2105      	movs	r1, #5
 80085fa:	2012      	movs	r0, #18
 80085fc:	f7ff fa38 	bl	8007a70 <SX1276Write>
            if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 8008600:	4b15      	ldr	r3, [pc, #84]	; (8008658 <SX1276OnDio3Irq+0x88>)
 8008602:	681b      	ldr	r3, [r3, #0]
 8008604:	2b00      	cmp	r3, #0
 8008606:	d01f      	beq.n	8008648 <SX1276OnDio3Irq+0x78>
 8008608:	4b13      	ldr	r3, [pc, #76]	; (8008658 <SX1276OnDio3Irq+0x88>)
 800860a:	681b      	ldr	r3, [r3, #0]
 800860c:	699b      	ldr	r3, [r3, #24]
 800860e:	2b00      	cmp	r3, #0
 8008610:	d01a      	beq.n	8008648 <SX1276OnDio3Irq+0x78>
                RadioEvents->CadDone( true );
 8008612:	4b11      	ldr	r3, [pc, #68]	; (8008658 <SX1276OnDio3Irq+0x88>)
 8008614:	681b      	ldr	r3, [r3, #0]
 8008616:	699b      	ldr	r3, [r3, #24]
 8008618:	2001      	movs	r0, #1
 800861a:	4798      	blx	r3
        break;
 800861c:	e014      	b.n	8008648 <SX1276OnDio3Irq+0x78>
            SX1276Write( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_CADDONE );
 800861e:	2104      	movs	r1, #4
 8008620:	2012      	movs	r0, #18
 8008622:	f7ff fa25 	bl	8007a70 <SX1276Write>
            if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 8008626:	4b0c      	ldr	r3, [pc, #48]	; (8008658 <SX1276OnDio3Irq+0x88>)
 8008628:	681b      	ldr	r3, [r3, #0]
 800862a:	2b00      	cmp	r3, #0
 800862c:	d00c      	beq.n	8008648 <SX1276OnDio3Irq+0x78>
 800862e:	4b0a      	ldr	r3, [pc, #40]	; (8008658 <SX1276OnDio3Irq+0x88>)
 8008630:	681b      	ldr	r3, [r3, #0]
 8008632:	699b      	ldr	r3, [r3, #24]
 8008634:	2b00      	cmp	r3, #0
 8008636:	d007      	beq.n	8008648 <SX1276OnDio3Irq+0x78>
                RadioEvents->CadDone( false );
 8008638:	4b07      	ldr	r3, [pc, #28]	; (8008658 <SX1276OnDio3Irq+0x88>)
 800863a:	681b      	ldr	r3, [r3, #0]
 800863c:	699b      	ldr	r3, [r3, #24]
 800863e:	2000      	movs	r0, #0
 8008640:	4798      	blx	r3
        break;
 8008642:	e001      	b.n	8008648 <SX1276OnDio3Irq+0x78>
        break;
 8008644:	46c0      	nop			; (mov r8, r8)
 8008646:	e000      	b.n	800864a <SX1276OnDio3Irq+0x7a>
        break;
 8008648:	46c0      	nop			; (mov r8, r8)
    }
}
 800864a:	46c0      	nop			; (mov r8, r8)
 800864c:	46bd      	mov	sp, r7
 800864e:	b002      	add	sp, #8
 8008650:	bd80      	pop	{r7, pc}
 8008652:	46c0      	nop			; (mov r8, r8)
 8008654:	2000175c 	.word	0x2000175c
 8008658:	20000350 	.word	0x20000350

0800865c <SX1276OnDio4Irq>:

void SX1276OnDio4Irq( void* context )
{
 800865c:	b580      	push	{r7, lr}
 800865e:	b082      	sub	sp, #8
 8008660:	af00      	add	r7, sp, #0
 8008662:	6078      	str	r0, [r7, #4]
    switch( SX1276.Settings.Modem )
 8008664:	4b0b      	ldr	r3, [pc, #44]	; (8008694 <SX1276OnDio4Irq+0x38>)
 8008666:	795b      	ldrb	r3, [r3, #5]
 8008668:	2b00      	cmp	r3, #0
 800866a:	d002      	beq.n	8008672 <SX1276OnDio4Irq+0x16>
 800866c:	2b01      	cmp	r3, #1
 800866e:	d00a      	beq.n	8008686 <SX1276OnDio4Irq+0x2a>
        }
        break;
    case MODEM_LORA:
        break;
    default:
        break;
 8008670:	e00c      	b.n	800868c <SX1276OnDio4Irq+0x30>
            if( SX1276.Settings.FskPacketHandler.PreambleDetected == false )
 8008672:	4b08      	ldr	r3, [pc, #32]	; (8008694 <SX1276OnDio4Irq+0x38>)
 8008674:	2230      	movs	r2, #48	; 0x30
 8008676:	5c9b      	ldrb	r3, [r3, r2]
 8008678:	2b00      	cmp	r3, #0
 800867a:	d106      	bne.n	800868a <SX1276OnDio4Irq+0x2e>
                SX1276.Settings.FskPacketHandler.PreambleDetected = true;
 800867c:	4b05      	ldr	r3, [pc, #20]	; (8008694 <SX1276OnDio4Irq+0x38>)
 800867e:	2230      	movs	r2, #48	; 0x30
 8008680:	2101      	movs	r1, #1
 8008682:	5499      	strb	r1, [r3, r2]
        break;
 8008684:	e001      	b.n	800868a <SX1276OnDio4Irq+0x2e>
        break;
 8008686:	46c0      	nop			; (mov r8, r8)
 8008688:	e000      	b.n	800868c <SX1276OnDio4Irq+0x30>
        break;
 800868a:	46c0      	nop			; (mov r8, r8)
    }
}
 800868c:	46c0      	nop			; (mov r8, r8)
 800868e:	46bd      	mov	sp, r7
 8008690:	b002      	add	sp, #8
 8008692:	bd80      	pop	{r7, pc}
 8008694:	2000175c 	.word	0x2000175c

08008698 <Sensor_IO_Init>:
 * @param  None
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef Sensor_IO_Init( void )
{
 8008698:	b580      	push	{r7, lr}
 800869a:	af00      	add	r7, sp, #0

  if ( I2C_EXPBD_Init() )
 800869c:	f000 f886 	bl	80087ac <I2C_EXPBD_Init>
 80086a0:	1e03      	subs	r3, r0, #0
 80086a2:	d001      	beq.n	80086a8 <Sensor_IO_Init+0x10>
  {
    return COMPONENT_ERROR;
 80086a4:	2301      	movs	r3, #1
 80086a6:	e000      	b.n	80086aa <Sensor_IO_Init+0x12>
  }
  else
  {
    return COMPONENT_OK;
 80086a8:	2300      	movs	r3, #0
  }
}
 80086aa:	0018      	movs	r0, r3
 80086ac:	46bd      	mov	sp, r7
 80086ae:	bd80      	pop	{r7, pc}

080086b0 <LPS22HB_Sensor_IO_ITConfig>:
 * @param  None
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef LPS22HB_Sensor_IO_ITConfig( void )
{
 80086b0:	b580      	push	{r7, lr}
 80086b2:	b086      	sub	sp, #24
 80086b4:	af00      	add	r7, sp, #0

  /* At the moment this feature is only implemented for LPS22HB */
  GPIO_InitTypeDef GPIO_InitStructureInt1;
  /* Enable INT1 GPIO clock */
  LPS22H_INT1_O_GPIO_CLK_ENABLE();
 80086b6:	4b16      	ldr	r3, [pc, #88]	; (8008710 <LPS22HB_Sensor_IO_ITConfig+0x60>)
 80086b8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80086ba:	4b15      	ldr	r3, [pc, #84]	; (8008710 <LPS22HB_Sensor_IO_ITConfig+0x60>)
 80086bc:	2102      	movs	r1, #2
 80086be:	430a      	orrs	r2, r1
 80086c0:	62da      	str	r2, [r3, #44]	; 0x2c
 80086c2:	4b13      	ldr	r3, [pc, #76]	; (8008710 <LPS22HB_Sensor_IO_ITConfig+0x60>)
 80086c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80086c6:	2202      	movs	r2, #2
 80086c8:	4013      	ands	r3, r2
 80086ca:	603b      	str	r3, [r7, #0]
 80086cc:	683b      	ldr	r3, [r7, #0]

  /* Configure GPIO PINs to detect Interrupts */
  GPIO_InitStructureInt1.Pin = LPS22H_INT1_O_PIN;
 80086ce:	1d3b      	adds	r3, r7, #4
 80086d0:	2280      	movs	r2, #128	; 0x80
 80086d2:	00d2      	lsls	r2, r2, #3
 80086d4:	601a      	str	r2, [r3, #0]
  GPIO_InitStructureInt1.Mode = GPIO_MODE_IT_RISING;
 80086d6:	1d3b      	adds	r3, r7, #4
 80086d8:	4a0e      	ldr	r2, [pc, #56]	; (8008714 <LPS22HB_Sensor_IO_ITConfig+0x64>)
 80086da:	605a      	str	r2, [r3, #4]
#if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L0XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO))|| (defined (USE_B_L072Z_LRWAN1)))
  GPIO_InitStructureInt1.Speed = GPIO_SPEED_FAST;
 80086dc:	1d3b      	adds	r3, r7, #4
 80086de:	2202      	movs	r2, #2
 80086e0:	60da      	str	r2, [r3, #12]
#endif

#if (defined (USE_STM32L1XX_NUCLEO))
  GPIO_InitStructureInt1.Speed = GPIO_SPEED_MEDIUM;
#endif
  GPIO_InitStructureInt1.Pull  = GPIO_NOPULL;
 80086e2:	1d3b      	adds	r3, r7, #4
 80086e4:	2200      	movs	r2, #0
 80086e6:	609a      	str	r2, [r3, #8]
  HAL_GPIO_Init(LPS22H_INT1_O_GPIO_PORT, &GPIO_InitStructureInt1);
 80086e8:	1d3b      	adds	r3, r7, #4
 80086ea:	4a0b      	ldr	r2, [pc, #44]	; (8008718 <LPS22HB_Sensor_IO_ITConfig+0x68>)
 80086ec:	0019      	movs	r1, r3
 80086ee:	0010      	movs	r0, r2
 80086f0:	f001 fc18 	bl	8009f24 <HAL_GPIO_Init>

  /* Enable and set EXTI Interrupt priority */
  HAL_NVIC_SetPriority(LPS22H_INT1_O_EXTI_IRQn, 0x00, 0x00);
 80086f4:	2200      	movs	r2, #0
 80086f6:	2100      	movs	r1, #0
 80086f8:	2007      	movs	r0, #7
 80086fa:	f001 f9eb 	bl	8009ad4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(LPS22H_INT1_O_EXTI_IRQn);
 80086fe:	2007      	movs	r0, #7
 8008700:	f001 f9fd 	bl	8009afe <HAL_NVIC_EnableIRQ>

  return COMPONENT_OK;
 8008704:	2300      	movs	r3, #0
}
 8008706:	0018      	movs	r0, r3
 8008708:	46bd      	mov	sp, r7
 800870a:	b006      	add	sp, #24
 800870c:	bd80      	pop	{r7, pc}
 800870e:	46c0      	nop			; (mov r8, r8)
 8008710:	40021000 	.word	0x40021000
 8008714:	10110000 	.word	0x10110000
 8008718:	50000400 	.word	0x50000400

0800871c <Sensor_IO_Write>:
 * @param  nBytesToWrite number of bytes to be written
 * @retval 0 in case of success
 * @retval 1 in case of failure
 */
uint8_t Sensor_IO_Write( void *handle, uint8_t WriteAddr, uint8_t *pBuffer, uint16_t nBytesToWrite )
{
 800871c:	b5b0      	push	{r4, r5, r7, lr}
 800871e:	b086      	sub	sp, #24
 8008720:	af00      	add	r7, sp, #0
 8008722:	60f8      	str	r0, [r7, #12]
 8008724:	0008      	movs	r0, r1
 8008726:	607a      	str	r2, [r7, #4]
 8008728:	0019      	movs	r1, r3
 800872a:	250b      	movs	r5, #11
 800872c:	197b      	adds	r3, r7, r5
 800872e:	1c02      	adds	r2, r0, #0
 8008730:	701a      	strb	r2, [r3, #0]
 8008732:	2408      	movs	r4, #8
 8008734:	193b      	adds	r3, r7, r4
 8008736:	1c0a      	adds	r2, r1, #0
 8008738:	801a      	strh	r2, [r3, #0]
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 800873a:	68fb      	ldr	r3, [r7, #12]
 800873c:	617b      	str	r3, [r7, #20]

  /* call I2C_EXPBD Read data bus function */
  if ( I2C_EXPBD_WriteData( ctx->address, WriteAddr, pBuffer, nBytesToWrite ) )
 800873e:	697b      	ldr	r3, [r7, #20]
 8008740:	7858      	ldrb	r0, [r3, #1]
 8008742:	193b      	adds	r3, r7, r4
 8008744:	881c      	ldrh	r4, [r3, #0]
 8008746:	687a      	ldr	r2, [r7, #4]
 8008748:	197b      	adds	r3, r7, r5
 800874a:	7819      	ldrb	r1, [r3, #0]
 800874c:	0023      	movs	r3, r4
 800874e:	f000 f85b 	bl	8008808 <I2C_EXPBD_WriteData>
 8008752:	1e03      	subs	r3, r0, #0
 8008754:	d001      	beq.n	800875a <Sensor_IO_Write+0x3e>
  {
    return 1;
 8008756:	2301      	movs	r3, #1
 8008758:	e000      	b.n	800875c <Sensor_IO_Write+0x40>
  }
  else
  {
    return 0;
 800875a:	2300      	movs	r3, #0
  }
}
 800875c:	0018      	movs	r0, r3
 800875e:	46bd      	mov	sp, r7
 8008760:	b006      	add	sp, #24
 8008762:	bdb0      	pop	{r4, r5, r7, pc}

08008764 <Sensor_IO_Read>:
 * @param  nBytesToRead number of bytes to be read
 * @retval 0 in case of success
 * @retval 1 in case of failure
 */
uint8_t Sensor_IO_Read( void *handle, uint8_t ReadAddr, uint8_t *pBuffer, uint16_t nBytesToRead )
{
 8008764:	b5b0      	push	{r4, r5, r7, lr}
 8008766:	b086      	sub	sp, #24
 8008768:	af00      	add	r7, sp, #0
 800876a:	60f8      	str	r0, [r7, #12]
 800876c:	0008      	movs	r0, r1
 800876e:	607a      	str	r2, [r7, #4]
 8008770:	0019      	movs	r1, r3
 8008772:	250b      	movs	r5, #11
 8008774:	197b      	adds	r3, r7, r5
 8008776:	1c02      	adds	r2, r0, #0
 8008778:	701a      	strb	r2, [r3, #0]
 800877a:	2408      	movs	r4, #8
 800877c:	193b      	adds	r3, r7, r4
 800877e:	1c0a      	adds	r2, r1, #0
 8008780:	801a      	strh	r2, [r3, #0]
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 8008782:	68fb      	ldr	r3, [r7, #12]
 8008784:	617b      	str	r3, [r7, #20]

  /* call I2C_EXPBD Read data bus function */
  if ( I2C_EXPBD_ReadData( ctx->address, ReadAddr, pBuffer, nBytesToRead ) )
 8008786:	697b      	ldr	r3, [r7, #20]
 8008788:	7858      	ldrb	r0, [r3, #1]
 800878a:	193b      	adds	r3, r7, r4
 800878c:	881c      	ldrh	r4, [r3, #0]
 800878e:	687a      	ldr	r2, [r7, #4]
 8008790:	197b      	adds	r3, r7, r5
 8008792:	7819      	ldrb	r1, [r3, #0]
 8008794:	0023      	movs	r3, r4
 8008796:	f000 f875 	bl	8008884 <I2C_EXPBD_ReadData>
 800879a:	1e03      	subs	r3, r0, #0
 800879c:	d001      	beq.n	80087a2 <Sensor_IO_Read+0x3e>
  {
    return 1;
 800879e:	2301      	movs	r3, #1
 80087a0:	e000      	b.n	80087a4 <Sensor_IO_Read+0x40>
  }
  else
  {
    return 0;
 80087a2:	2300      	movs	r3, #0
  }
}
 80087a4:	0018      	movs	r0, r3
 80087a6:	46bd      	mov	sp, r7
 80087a8:	b006      	add	sp, #24
 80087aa:	bdb0      	pop	{r4, r5, r7, pc}

080087ac <I2C_EXPBD_Init>:
 * @param  None
 * @retval 0 in case of success
 * @retval 1 in case of failure
 */
static uint8_t I2C_EXPBD_Init( void )
{
 80087ac:	b580      	push	{r7, lr}
 80087ae:	af00      	add	r7, sp, #0
  if(HAL_I2C_GetState( &I2C_EXPBD_Handle) == HAL_I2C_STATE_RESET )
 80087b0:	4b12      	ldr	r3, [pc, #72]	; (80087fc <I2C_EXPBD_Init+0x50>)
 80087b2:	0018      	movs	r0, r3
 80087b4:	f002 f8a6 	bl	800a904 <HAL_I2C_GetState>
 80087b8:	1e03      	subs	r3, r0, #0
 80087ba:	d111      	bne.n	80087e0 <I2C_EXPBD_Init+0x34>
    I2C_EXPBD_Handle.Init.ClockSpeed = NUCLEO_I2C_EXPBD_SPEED;
    I2C_EXPBD_Handle.Init.DutyCycle = I2C_DUTYCYCLE_2;
#endif

#if (defined (USE_STM32L0XX_NUCLEO)|| (defined (USE_B_L072Z_LRWAN1)))
    I2C_EXPBD_Handle.Init.Timing = NUCLEO_I2C_EXPBD_TIMING_400KHZ;    /* 400KHz */
 80087bc:	4b0f      	ldr	r3, [pc, #60]	; (80087fc <I2C_EXPBD_Init+0x50>)
 80087be:	4a10      	ldr	r2, [pc, #64]	; (8008800 <I2C_EXPBD_Init+0x54>)
 80087c0:	605a      	str	r2, [r3, #4]
#endif
#if (defined (USE_STM32L4XX_NUCLEO))
    I2C_EXPBD_Handle.Init.Timing = NUCLEO_I2C_EXPBD_TIMING_400KHZ;    /* 400KHz */
#endif

    I2C_EXPBD_Handle.Init.OwnAddress1    = 0x33;
 80087c2:	4b0e      	ldr	r3, [pc, #56]	; (80087fc <I2C_EXPBD_Init+0x50>)
 80087c4:	2233      	movs	r2, #51	; 0x33
 80087c6:	609a      	str	r2, [r3, #8]
    I2C_EXPBD_Handle.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80087c8:	4b0c      	ldr	r3, [pc, #48]	; (80087fc <I2C_EXPBD_Init+0x50>)
 80087ca:	2201      	movs	r2, #1
 80087cc:	60da      	str	r2, [r3, #12]
    I2C_EXPBD_Handle.Instance            = NUCLEO_I2C_EXPBD;
 80087ce:	4b0b      	ldr	r3, [pc, #44]	; (80087fc <I2C_EXPBD_Init+0x50>)
 80087d0:	4a0c      	ldr	r2, [pc, #48]	; (8008804 <I2C_EXPBD_Init+0x58>)
 80087d2:	601a      	str	r2, [r3, #0]

    /* Init the I2C */
    I2C_EXPBD_MspInit();
 80087d4:	f000 f8a6 	bl	8008924 <I2C_EXPBD_MspInit>
    HAL_I2C_Init( &I2C_EXPBD_Handle );
 80087d8:	4b08      	ldr	r3, [pc, #32]	; (80087fc <I2C_EXPBD_Init+0x50>)
 80087da:	0018      	movs	r0, r3
 80087dc:	f001 fd5a 	bl	800a294 <HAL_I2C_Init>
  }

  if( HAL_I2C_GetState( &I2C_EXPBD_Handle) == HAL_I2C_STATE_READY )
 80087e0:	4b06      	ldr	r3, [pc, #24]	; (80087fc <I2C_EXPBD_Init+0x50>)
 80087e2:	0018      	movs	r0, r3
 80087e4:	f002 f88e 	bl	800a904 <HAL_I2C_GetState>
 80087e8:	0003      	movs	r3, r0
 80087ea:	2b20      	cmp	r3, #32
 80087ec:	d101      	bne.n	80087f2 <I2C_EXPBD_Init+0x46>
  {
    return 0;
 80087ee:	2300      	movs	r3, #0
 80087f0:	e000      	b.n	80087f4 <I2C_EXPBD_Init+0x48>
  }
  else
  {
    return 1;
 80087f2:	2301      	movs	r3, #1
  }
}
 80087f4:	0018      	movs	r0, r3
 80087f6:	46bd      	mov	sp, r7
 80087f8:	bd80      	pop	{r7, pc}
 80087fa:	46c0      	nop			; (mov r8, r8)
 80087fc:	20000458 	.word	0x20000458
 8008800:	00b1112e 	.word	0x00b1112e
 8008804:	40005400 	.word	0x40005400

08008808 <I2C_EXPBD_WriteData>:
 * @param  Size Number of bytes to be written
 * @retval 0 in case of success
 * @retval 1 in case of failure
 */
static uint8_t I2C_EXPBD_WriteData( uint8_t Addr, uint8_t Reg, uint8_t* pBuffer, uint16_t Size )
{
 8008808:	b5b0      	push	{r4, r5, r7, lr}
 800880a:	b088      	sub	sp, #32
 800880c:	af04      	add	r7, sp, #16
 800880e:	0004      	movs	r4, r0
 8008810:	0008      	movs	r0, r1
 8008812:	603a      	str	r2, [r7, #0]
 8008814:	0019      	movs	r1, r3
 8008816:	1dfb      	adds	r3, r7, #7
 8008818:	1c22      	adds	r2, r4, #0
 800881a:	701a      	strb	r2, [r3, #0]
 800881c:	1dbb      	adds	r3, r7, #6
 800881e:	1c02      	adds	r2, r0, #0
 8008820:	701a      	strb	r2, [r3, #0]
 8008822:	1d3b      	adds	r3, r7, #4
 8008824:	1c0a      	adds	r2, r1, #0
 8008826:	801a      	strh	r2, [r3, #0]

  HAL_StatusTypeDef status = HAL_OK;
 8008828:	200f      	movs	r0, #15
 800882a:	183b      	adds	r3, r7, r0
 800882c:	2200      	movs	r2, #0
 800882e:	701a      	strb	r2, [r3, #0]

  status = HAL_I2C_Mem_Write( &I2C_EXPBD_Handle, Addr, ( uint16_t )Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size,
 8008830:	1dfb      	adds	r3, r7, #7
 8008832:	781b      	ldrb	r3, [r3, #0]
 8008834:	b299      	uxth	r1, r3
 8008836:	1dbb      	adds	r3, r7, #6
 8008838:	781b      	ldrb	r3, [r3, #0]
 800883a:	b29a      	uxth	r2, r3
 800883c:	4b0f      	ldr	r3, [pc, #60]	; (800887c <I2C_EXPBD_WriteData+0x74>)
 800883e:	681b      	ldr	r3, [r3, #0]
 8008840:	0005      	movs	r5, r0
 8008842:	183c      	adds	r4, r7, r0
 8008844:	480e      	ldr	r0, [pc, #56]	; (8008880 <I2C_EXPBD_WriteData+0x78>)
 8008846:	9302      	str	r3, [sp, #8]
 8008848:	1d3b      	adds	r3, r7, #4
 800884a:	881b      	ldrh	r3, [r3, #0]
 800884c:	9301      	str	r3, [sp, #4]
 800884e:	683b      	ldr	r3, [r7, #0]
 8008850:	9300      	str	r3, [sp, #0]
 8008852:	2301      	movs	r3, #1
 8008854:	f001 fdf4 	bl	800a440 <HAL_I2C_Mem_Write>
 8008858:	0003      	movs	r3, r0
 800885a:	7023      	strb	r3, [r4, #0]
                              I2C_EXPBD_Timeout );

  /* Check the communication status */
  if( status != HAL_OK )
 800885c:	197b      	adds	r3, r7, r5
 800885e:	781b      	ldrb	r3, [r3, #0]
 8008860:	2b00      	cmp	r3, #0
 8008862:	d006      	beq.n	8008872 <I2C_EXPBD_WriteData+0x6a>
  {

    /* Execute user timeout callback */
    I2C_EXPBD_Error( Addr );
 8008864:	1dfb      	adds	r3, r7, #7
 8008866:	781b      	ldrb	r3, [r3, #0]
 8008868:	0018      	movs	r0, r3
 800886a:	f000 f849 	bl	8008900 <I2C_EXPBD_Error>
    return 1;
 800886e:	2301      	movs	r3, #1
 8008870:	e000      	b.n	8008874 <I2C_EXPBD_WriteData+0x6c>
  }
  else
  {
    return 0;
 8008872:	2300      	movs	r3, #0
  }
}
 8008874:	0018      	movs	r0, r3
 8008876:	46bd      	mov	sp, r7
 8008878:	b004      	add	sp, #16
 800887a:	bdb0      	pop	{r4, r5, r7, pc}
 800887c:	20000184 	.word	0x20000184
 8008880:	20000458 	.word	0x20000458

08008884 <I2C_EXPBD_ReadData>:
 * @param  Size Number of bytes to be read
 * @retval 0 in case of success
 * @retval 1 in case of failure
 */
static uint8_t I2C_EXPBD_ReadData( uint8_t Addr, uint8_t Reg, uint8_t* pBuffer, uint16_t Size )
{
 8008884:	b5b0      	push	{r4, r5, r7, lr}
 8008886:	b088      	sub	sp, #32
 8008888:	af04      	add	r7, sp, #16
 800888a:	0004      	movs	r4, r0
 800888c:	0008      	movs	r0, r1
 800888e:	603a      	str	r2, [r7, #0]
 8008890:	0019      	movs	r1, r3
 8008892:	1dfb      	adds	r3, r7, #7
 8008894:	1c22      	adds	r2, r4, #0
 8008896:	701a      	strb	r2, [r3, #0]
 8008898:	1dbb      	adds	r3, r7, #6
 800889a:	1c02      	adds	r2, r0, #0
 800889c:	701a      	strb	r2, [r3, #0]
 800889e:	1d3b      	adds	r3, r7, #4
 80088a0:	1c0a      	adds	r2, r1, #0
 80088a2:	801a      	strh	r2, [r3, #0]

  HAL_StatusTypeDef status = HAL_OK;
 80088a4:	200f      	movs	r0, #15
 80088a6:	183b      	adds	r3, r7, r0
 80088a8:	2200      	movs	r2, #0
 80088aa:	701a      	strb	r2, [r3, #0]

  status = HAL_I2C_Mem_Read( &I2C_EXPBD_Handle, Addr, ( uint16_t )Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size,
 80088ac:	1dfb      	adds	r3, r7, #7
 80088ae:	781b      	ldrb	r3, [r3, #0]
 80088b0:	b299      	uxth	r1, r3
 80088b2:	1dbb      	adds	r3, r7, #6
 80088b4:	781b      	ldrb	r3, [r3, #0]
 80088b6:	b29a      	uxth	r2, r3
 80088b8:	4b0f      	ldr	r3, [pc, #60]	; (80088f8 <I2C_EXPBD_ReadData+0x74>)
 80088ba:	681b      	ldr	r3, [r3, #0]
 80088bc:	0005      	movs	r5, r0
 80088be:	183c      	adds	r4, r7, r0
 80088c0:	480e      	ldr	r0, [pc, #56]	; (80088fc <I2C_EXPBD_ReadData+0x78>)
 80088c2:	9302      	str	r3, [sp, #8]
 80088c4:	1d3b      	adds	r3, r7, #4
 80088c6:	881b      	ldrh	r3, [r3, #0]
 80088c8:	9301      	str	r3, [sp, #4]
 80088ca:	683b      	ldr	r3, [r7, #0]
 80088cc:	9300      	str	r3, [sp, #0]
 80088ce:	2301      	movs	r3, #1
 80088d0:	f001 fee4 	bl	800a69c <HAL_I2C_Mem_Read>
 80088d4:	0003      	movs	r3, r0
 80088d6:	7023      	strb	r3, [r4, #0]
                             I2C_EXPBD_Timeout );

  /* Check the communication status */
  if( status != HAL_OK )
 80088d8:	197b      	adds	r3, r7, r5
 80088da:	781b      	ldrb	r3, [r3, #0]
 80088dc:	2b00      	cmp	r3, #0
 80088de:	d006      	beq.n	80088ee <I2C_EXPBD_ReadData+0x6a>
  {

    /* Execute user timeout callback */
    I2C_EXPBD_Error( Addr );
 80088e0:	1dfb      	adds	r3, r7, #7
 80088e2:	781b      	ldrb	r3, [r3, #0]
 80088e4:	0018      	movs	r0, r3
 80088e6:	f000 f80b 	bl	8008900 <I2C_EXPBD_Error>
    return 1;
 80088ea:	2301      	movs	r3, #1
 80088ec:	e000      	b.n	80088f0 <I2C_EXPBD_ReadData+0x6c>
  }
  else
  {
    return 0;
 80088ee:	2300      	movs	r3, #0
  }
}
 80088f0:	0018      	movs	r0, r3
 80088f2:	46bd      	mov	sp, r7
 80088f4:	b004      	add	sp, #16
 80088f6:	bdb0      	pop	{r4, r5, r7, pc}
 80088f8:	20000184 	.word	0x20000184
 80088fc:	20000458 	.word	0x20000458

08008900 <I2C_EXPBD_Error>:
 * @brief  Manages error callback by re-initializing I2C
 * @param  Addr I2C Address
 * @retval None
 */
static void I2C_EXPBD_Error( uint8_t Addr )
{
 8008900:	b580      	push	{r7, lr}
 8008902:	b082      	sub	sp, #8
 8008904:	af00      	add	r7, sp, #0
 8008906:	0002      	movs	r2, r0
 8008908:	1dfb      	adds	r3, r7, #7
 800890a:	701a      	strb	r2, [r3, #0]

  /* De-initialize the I2C comunication bus */
  HAL_I2C_DeInit( &I2C_EXPBD_Handle );
 800890c:	4b04      	ldr	r3, [pc, #16]	; (8008920 <I2C_EXPBD_Error+0x20>)
 800890e:	0018      	movs	r0, r3
 8008910:	f001 fd56 	bl	800a3c0 <HAL_I2C_DeInit>

  /* Re-Initiaize the I2C comunication bus */
  I2C_EXPBD_Init();
 8008914:	f7ff ff4a 	bl	80087ac <I2C_EXPBD_Init>
}
 8008918:	46c0      	nop			; (mov r8, r8)
 800891a:	46bd      	mov	sp, r7
 800891c:	b002      	add	sp, #8
 800891e:	bd80      	pop	{r7, pc}
 8008920:	20000458 	.word	0x20000458

08008924 <I2C_EXPBD_MspInit>:
 * @param None
 * @retval None
 */

static void I2C_EXPBD_MspInit( void )
{
 8008924:	b580      	push	{r7, lr}
 8008926:	b086      	sub	sp, #24
 8008928:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef  GPIO_InitStruct;

  /* Enable I2C GPIO clocks */
  NUCLEO_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 800892a:	4b21      	ldr	r3, [pc, #132]	; (80089b0 <I2C_EXPBD_MspInit+0x8c>)
 800892c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800892e:	4b20      	ldr	r3, [pc, #128]	; (80089b0 <I2C_EXPBD_MspInit+0x8c>)
 8008930:	2102      	movs	r1, #2
 8008932:	430a      	orrs	r2, r1
 8008934:	62da      	str	r2, [r3, #44]	; 0x2c
 8008936:	4b1e      	ldr	r3, [pc, #120]	; (80089b0 <I2C_EXPBD_MspInit+0x8c>)
 8008938:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800893a:	2202      	movs	r2, #2
 800893c:	4013      	ands	r3, r2
 800893e:	603b      	str	r3, [r7, #0]
 8008940:	683b      	ldr	r3, [r7, #0]

  /* I2C_EXPBD SCL and SDA pins configuration -------------------------------------*/
  GPIO_InitStruct.Pin        = NUCLEO_I2C_EXPBD_SCL_PIN | NUCLEO_I2C_EXPBD_SDA_PIN;
 8008942:	1d3b      	adds	r3, r7, #4
 8008944:	22c0      	movs	r2, #192	; 0xc0
 8008946:	0092      	lsls	r2, r2, #2
 8008948:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode       = GPIO_MODE_AF_OD;
 800894a:	1d3b      	adds	r3, r7, #4
 800894c:	2212      	movs	r2, #18
 800894e:	605a      	str	r2, [r3, #4]
#if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L0XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO))|| (defined (USE_B_L072Z_LRWAN1)))
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 8008950:	1d3b      	adds	r3, r7, #4
 8008952:	2202      	movs	r2, #2
 8008954:	60da      	str	r2, [r3, #12]
#endif

#if (defined (USE_STM32L1XX_NUCLEO))
  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
#endif
  GPIO_InitStruct.Pull       = GPIO_NOPULL;
 8008956:	1d3b      	adds	r3, r7, #4
 8008958:	2200      	movs	r2, #0
 800895a:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Alternate  = NUCLEO_I2C_EXPBD_SCL_SDA_AF;
 800895c:	1d3b      	adds	r3, r7, #4
 800895e:	2204      	movs	r2, #4
 8008960:	611a      	str	r2, [r3, #16]

  HAL_GPIO_Init( NUCLEO_I2C_EXPBD_SCL_SDA_GPIO_PORT, &GPIO_InitStruct );
 8008962:	1d3b      	adds	r3, r7, #4
 8008964:	4a13      	ldr	r2, [pc, #76]	; (80089b4 <I2C_EXPBD_MspInit+0x90>)
 8008966:	0019      	movs	r1, r3
 8008968:	0010      	movs	r0, r2
 800896a:	f001 fadb 	bl	8009f24 <HAL_GPIO_Init>

  /* Enable the I2C_EXPBD peripheral clock */
  NUCLEO_I2C_EXPBD_CLK_ENABLE();
 800896e:	4b10      	ldr	r3, [pc, #64]	; (80089b0 <I2C_EXPBD_MspInit+0x8c>)
 8008970:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8008972:	4b0f      	ldr	r3, [pc, #60]	; (80089b0 <I2C_EXPBD_MspInit+0x8c>)
 8008974:	2180      	movs	r1, #128	; 0x80
 8008976:	0389      	lsls	r1, r1, #14
 8008978:	430a      	orrs	r2, r1
 800897a:	639a      	str	r2, [r3, #56]	; 0x38

  /* Force the I2C peripheral clock reset */
  NUCLEO_I2C_EXPBD_FORCE_RESET();
 800897c:	4b0c      	ldr	r3, [pc, #48]	; (80089b0 <I2C_EXPBD_MspInit+0x8c>)
 800897e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8008980:	4b0b      	ldr	r3, [pc, #44]	; (80089b0 <I2C_EXPBD_MspInit+0x8c>)
 8008982:	2180      	movs	r1, #128	; 0x80
 8008984:	0389      	lsls	r1, r1, #14
 8008986:	430a      	orrs	r2, r1
 8008988:	629a      	str	r2, [r3, #40]	; 0x28

  /* Release the I2C peripheral clock reset */
  NUCLEO_I2C_EXPBD_RELEASE_RESET();
 800898a:	4b09      	ldr	r3, [pc, #36]	; (80089b0 <I2C_EXPBD_MspInit+0x8c>)
 800898c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800898e:	4b08      	ldr	r3, [pc, #32]	; (80089b0 <I2C_EXPBD_MspInit+0x8c>)
 8008990:	4909      	ldr	r1, [pc, #36]	; (80089b8 <I2C_EXPBD_MspInit+0x94>)
 8008992:	400a      	ands	r2, r1
 8008994:	629a      	str	r2, [r3, #40]	; 0x28

  /* Enable and set I2C_EXPBD Interrupt to the highest priority */
  HAL_NVIC_SetPriority(NUCLEO_I2C_EXPBD_EV_IRQn, 0, 0);
 8008996:	2200      	movs	r2, #0
 8008998:	2100      	movs	r1, #0
 800899a:	2017      	movs	r0, #23
 800899c:	f001 f89a 	bl	8009ad4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(NUCLEO_I2C_EXPBD_EV_IRQn);
 80089a0:	2017      	movs	r0, #23
 80089a2:	f001 f8ac 	bl	8009afe <HAL_NVIC_EnableIRQ>
  /* Enable and set I2C_EXPBD Interrupt to the highest priority */
  HAL_NVIC_SetPriority(NUCLEO_I2C_EXPBD_ER_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(NUCLEO_I2C_EXPBD_ER_IRQn);
#endif

}
 80089a6:	46c0      	nop			; (mov r8, r8)
 80089a8:	46bd      	mov	sp, r7
 80089aa:	b006      	add	sp, #24
 80089ac:	bd80      	pop	{r7, pc}
 80089ae:	46c0      	nop			; (mov r8, r8)
 80089b0:	40021000 	.word	0x40021000
 80089b4:	50000400 	.word	0x50000400
 80089b8:	ffdfffff 	.word	0xffdfffff

080089bc <BSP_HUMIDITY_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_HUMIDITY_Init( HUMIDITY_ID_t id, void **handle )
{
 80089bc:	b580      	push	{r7, lr}
 80089be:	b082      	sub	sp, #8
 80089c0:	af00      	add	r7, sp, #0
 80089c2:	0002      	movs	r2, r0
 80089c4:	6039      	str	r1, [r7, #0]
 80089c6:	1dfb      	adds	r3, r7, #7
 80089c8:	701a      	strb	r2, [r3, #0]

  *handle = NULL;
 80089ca:	683b      	ldr	r3, [r7, #0]
 80089cc:	2200      	movs	r2, #0
 80089ce:	601a      	str	r2, [r3, #0]

  switch(id)
 80089d0:	1dfb      	adds	r3, r7, #7
 80089d2:	781b      	ldrb	r3, [r3, #0]
 80089d4:	b25b      	sxtb	r3, r3
 80089d6:	2b00      	cmp	r3, #0
 80089d8:	d008      	beq.n	80089ec <BSP_HUMIDITY_Init+0x30>
  {
    case HUMIDITY_SENSORS_AUTO:
    default:
    {
      if( BSP_HTS221_HUMIDITY_Init(handle)  == COMPONENT_ERROR )
 80089da:	683b      	ldr	r3, [r7, #0]
 80089dc:	0018      	movs	r0, r3
 80089de:	f000 f817 	bl	8008a10 <BSP_HTS221_HUMIDITY_Init>
 80089e2:	0003      	movs	r3, r0
 80089e4:	2b01      	cmp	r3, #1
 80089e6:	d10a      	bne.n	80089fe <BSP_HUMIDITY_Init+0x42>
      {
        return COMPONENT_ERROR;
 80089e8:	2301      	movs	r3, #1
 80089ea:	e00c      	b.n	8008a06 <BSP_HUMIDITY_Init+0x4a>
      }
      break;
    }
    case HTS221_H_0:
    {
      if( BSP_HTS221_HUMIDITY_Init(handle)  == COMPONENT_ERROR )
 80089ec:	683b      	ldr	r3, [r7, #0]
 80089ee:	0018      	movs	r0, r3
 80089f0:	f000 f80e 	bl	8008a10 <BSP_HTS221_HUMIDITY_Init>
 80089f4:	0003      	movs	r3, r0
 80089f6:	2b01      	cmp	r3, #1
 80089f8:	d103      	bne.n	8008a02 <BSP_HUMIDITY_Init+0x46>
      {
        return COMPONENT_ERROR;
 80089fa:	2301      	movs	r3, #1
 80089fc:	e003      	b.n	8008a06 <BSP_HUMIDITY_Init+0x4a>
      break;
 80089fe:	46c0      	nop			; (mov r8, r8)
 8008a00:	e000      	b.n	8008a04 <BSP_HUMIDITY_Init+0x48>
      }
      break;
 8008a02:	46c0      	nop			; (mov r8, r8)
    }
  }

  return COMPONENT_OK;
 8008a04:	2300      	movs	r3, #0
}
 8008a06:	0018      	movs	r0, r3
 8008a08:	46bd      	mov	sp, r7
 8008a0a:	b002      	add	sp, #8
 8008a0c:	bd80      	pop	{r7, pc}
	...

08008a10 <BSP_HTS221_HUMIDITY_Init>:



static DrvStatusTypeDef BSP_HTS221_HUMIDITY_Init( void **handle )
{
 8008a10:	b580      	push	{r7, lr}
 8008a12:	b084      	sub	sp, #16
 8008a14:	af00      	add	r7, sp, #0
 8008a16:	6078      	str	r0, [r7, #4]
  HUMIDITY_Drv_t *driver = NULL;
 8008a18:	2300      	movs	r3, #0
 8008a1a:	60fb      	str	r3, [r7, #12]

  if(HUMIDITY_SensorHandle[ HTS221_H_0 ].isInitialized == 1)
 8008a1c:	4b30      	ldr	r3, [pc, #192]	; (8008ae0 <BSP_HTS221_HUMIDITY_Init+0xd0>)
 8008a1e:	78db      	ldrb	r3, [r3, #3]
 8008a20:	2b01      	cmp	r3, #1
 8008a22:	d101      	bne.n	8008a28 <BSP_HTS221_HUMIDITY_Init+0x18>
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
 8008a24:	2301      	movs	r3, #1
 8008a26:	e057      	b.n	8008ad8 <BSP_HTS221_HUMIDITY_Init+0xc8>
  }

  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8008a28:	f7ff fe36 	bl	8008698 <Sensor_IO_Init>
 8008a2c:	0003      	movs	r3, r0
 8008a2e:	2b01      	cmp	r3, #1
 8008a30:	d101      	bne.n	8008a36 <BSP_HTS221_HUMIDITY_Init+0x26>
  {
    return COMPONENT_ERROR;
 8008a32:	2301      	movs	r3, #1
 8008a34:	e050      	b.n	8008ad8 <BSP_HTS221_HUMIDITY_Init+0xc8>
  }

  /* Setup sensor handle. */
  HUMIDITY_SensorHandle[ HTS221_H_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 8008a36:	4b2a      	ldr	r3, [pc, #168]	; (8008ae0 <BSP_HTS221_HUMIDITY_Init+0xd0>)
 8008a38:	22bc      	movs	r2, #188	; 0xbc
 8008a3a:	701a      	strb	r2, [r3, #0]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].address       = HTS221_ADDRESS_DEFAULT;
 8008a3c:	4b28      	ldr	r3, [pc, #160]	; (8008ae0 <BSP_HTS221_HUMIDITY_Init+0xd0>)
 8008a3e:	22be      	movs	r2, #190	; 0xbe
 8008a40:	705a      	strb	r2, [r3, #1]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].instance      = HTS221_H_0;
 8008a42:	4b27      	ldr	r3, [pc, #156]	; (8008ae0 <BSP_HTS221_HUMIDITY_Init+0xd0>)
 8008a44:	2200      	movs	r2, #0
 8008a46:	709a      	strb	r2, [r3, #2]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].isInitialized = 0;
 8008a48:	4b25      	ldr	r3, [pc, #148]	; (8008ae0 <BSP_HTS221_HUMIDITY_Init+0xd0>)
 8008a4a:	2200      	movs	r2, #0
 8008a4c:	70da      	strb	r2, [r3, #3]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].isEnabled     = 0;
 8008a4e:	4b24      	ldr	r3, [pc, #144]	; (8008ae0 <BSP_HTS221_HUMIDITY_Init+0xd0>)
 8008a50:	2200      	movs	r2, #0
 8008a52:	711a      	strb	r2, [r3, #4]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].isCombo       = 1;
 8008a54:	4b22      	ldr	r3, [pc, #136]	; (8008ae0 <BSP_HTS221_HUMIDITY_Init+0xd0>)
 8008a56:	2201      	movs	r2, #1
 8008a58:	715a      	strb	r2, [r3, #5]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pData         = ( void * )&HUMIDITY_Data[ HTS221_H_0 ];
 8008a5a:	4b21      	ldr	r3, [pc, #132]	; (8008ae0 <BSP_HTS221_HUMIDITY_Init+0xd0>)
 8008a5c:	4a21      	ldr	r2, [pc, #132]	; (8008ae4 <BSP_HTS221_HUMIDITY_Init+0xd4>)
 8008a5e:	609a      	str	r2, [r3, #8]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pVTable       = ( void * )&HTS221_H_Drv;
 8008a60:	4b1f      	ldr	r3, [pc, #124]	; (8008ae0 <BSP_HTS221_HUMIDITY_Init+0xd0>)
 8008a62:	4a21      	ldr	r2, [pc, #132]	; (8008ae8 <BSP_HTS221_HUMIDITY_Init+0xd8>)
 8008a64:	60da      	str	r2, [r3, #12]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pExtVTable    = 0;
 8008a66:	4b1e      	ldr	r3, [pc, #120]	; (8008ae0 <BSP_HTS221_HUMIDITY_Init+0xd0>)
 8008a68:	2200      	movs	r2, #0
 8008a6a:	611a      	str	r2, [r3, #16]

  HTS221_H_0_Data.comboData = &HTS221_Combo_Data[0];
 8008a6c:	4b1f      	ldr	r3, [pc, #124]	; (8008aec <BSP_HTS221_HUMIDITY_Init+0xdc>)
 8008a6e:	4a20      	ldr	r2, [pc, #128]	; (8008af0 <BSP_HTS221_HUMIDITY_Init+0xe0>)
 8008a70:	601a      	str	r2, [r3, #0]
  HUMIDITY_Data[ HTS221_H_0 ].pComponentData = ( void * )&HTS221_H_0_Data;
 8008a72:	4b1c      	ldr	r3, [pc, #112]	; (8008ae4 <BSP_HTS221_HUMIDITY_Init+0xd4>)
 8008a74:	4a1d      	ldr	r2, [pc, #116]	; (8008aec <BSP_HTS221_HUMIDITY_Init+0xdc>)
 8008a76:	601a      	str	r2, [r3, #0]
  HUMIDITY_Data[ HTS221_H_0 ].pExtData       = 0;
 8008a78:	4b1a      	ldr	r3, [pc, #104]	; (8008ae4 <BSP_HTS221_HUMIDITY_Init+0xd4>)
 8008a7a:	2200      	movs	r2, #0
 8008a7c:	605a      	str	r2, [r3, #4]

  *handle = (void *)&HUMIDITY_SensorHandle[ HTS221_H_0 ];
 8008a7e:	687b      	ldr	r3, [r7, #4]
 8008a80:	4a17      	ldr	r2, [pc, #92]	; (8008ae0 <BSP_HTS221_HUMIDITY_Init+0xd0>)
 8008a82:	601a      	str	r2, [r3, #0]

  driver = ( HUMIDITY_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
 8008a84:	687b      	ldr	r3, [r7, #4]
 8008a86:	681b      	ldr	r3, [r3, #0]
 8008a88:	68db      	ldr	r3, [r3, #12]
 8008a8a:	60fb      	str	r3, [r7, #12]

  if ( driver->Init == NULL )
 8008a8c:	68fb      	ldr	r3, [r7, #12]
 8008a8e:	681b      	ldr	r3, [r3, #0]
 8008a90:	2b00      	cmp	r3, #0
 8008a92:	d10b      	bne.n	8008aac <BSP_HTS221_HUMIDITY_Init+0x9c>
  {
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8008a94:	687b      	ldr	r3, [r7, #4]
 8008a96:	681b      	ldr	r3, [r3, #0]
 8008a98:	2214      	movs	r2, #20
 8008a9a:	2100      	movs	r1, #0
 8008a9c:	0018      	movs	r0, r3
 8008a9e:	f014 fd59 	bl	801d554 <memset>
    *handle = NULL;
 8008aa2:	687b      	ldr	r3, [r7, #4]
 8008aa4:	2200      	movs	r2, #0
 8008aa6:	601a      	str	r2, [r3, #0]
    return COMPONENT_ERROR;
 8008aa8:	2301      	movs	r3, #1
 8008aaa:	e015      	b.n	8008ad8 <BSP_HTS221_HUMIDITY_Init+0xc8>
  }

  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8008aac:	68fb      	ldr	r3, [r7, #12]
 8008aae:	681a      	ldr	r2, [r3, #0]
 8008ab0:	687b      	ldr	r3, [r7, #4]
 8008ab2:	681b      	ldr	r3, [r3, #0]
 8008ab4:	0018      	movs	r0, r3
 8008ab6:	4790      	blx	r2
 8008ab8:	0003      	movs	r3, r0
 8008aba:	2b01      	cmp	r3, #1
 8008abc:	d10b      	bne.n	8008ad6 <BSP_HTS221_HUMIDITY_Init+0xc6>
  {
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8008abe:	687b      	ldr	r3, [r7, #4]
 8008ac0:	681b      	ldr	r3, [r3, #0]
 8008ac2:	2214      	movs	r2, #20
 8008ac4:	2100      	movs	r1, #0
 8008ac6:	0018      	movs	r0, r3
 8008ac8:	f014 fd44 	bl	801d554 <memset>
    *handle = NULL;
 8008acc:	687b      	ldr	r3, [r7, #4]
 8008ace:	2200      	movs	r2, #0
 8008ad0:	601a      	str	r2, [r3, #0]
    return COMPONENT_ERROR;
 8008ad2:	2301      	movs	r3, #1
 8008ad4:	e000      	b.n	8008ad8 <BSP_HTS221_HUMIDITY_Init+0xc8>
  }

  return COMPONENT_OK;
 8008ad6:	2300      	movs	r3, #0
}
 8008ad8:	0018      	movs	r0, r3
 8008ada:	46bd      	mov	sp, r7
 8008adc:	b004      	add	sp, #16
 8008ade:	bd80      	pop	{r7, pc}
 8008ae0:	200004a4 	.word	0x200004a4
 8008ae4:	200004b8 	.word	0x200004b8
 8008ae8:	20000024 	.word	0x20000024
 8008aec:	200004c0 	.word	0x200004c0
 8008af0:	20001720 	.word	0x20001720

08008af4 <BSP_HUMIDITY_Sensor_Enable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_HUMIDITY_Sensor_Enable( void *handle )
{
 8008af4:	b580      	push	{r7, lr}
 8008af6:	b084      	sub	sp, #16
 8008af8:	af00      	add	r7, sp, #0
 8008afa:	6078      	str	r0, [r7, #4]

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 8008afc:	687b      	ldr	r3, [r7, #4]
 8008afe:	60fb      	str	r3, [r7, #12]
  HUMIDITY_Drv_t *driver = NULL;
 8008b00:	2300      	movs	r3, #0
 8008b02:	60bb      	str	r3, [r7, #8]

  if(ctx == NULL)
 8008b04:	68fb      	ldr	r3, [r7, #12]
 8008b06:	2b00      	cmp	r3, #0
 8008b08:	d101      	bne.n	8008b0e <BSP_HUMIDITY_Sensor_Enable+0x1a>
  {
    return COMPONENT_ERROR;
 8008b0a:	2301      	movs	r3, #1
 8008b0c:	e013      	b.n	8008b36 <BSP_HUMIDITY_Sensor_Enable+0x42>
  }

  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;
 8008b0e:	68fb      	ldr	r3, [r7, #12]
 8008b10:	68db      	ldr	r3, [r3, #12]
 8008b12:	60bb      	str	r3, [r7, #8]

  if ( driver->Sensor_Enable == NULL )
 8008b14:	68bb      	ldr	r3, [r7, #8]
 8008b16:	689b      	ldr	r3, [r3, #8]
 8008b18:	2b00      	cmp	r3, #0
 8008b1a:	d101      	bne.n	8008b20 <BSP_HUMIDITY_Sensor_Enable+0x2c>
  {
    return COMPONENT_ERROR;
 8008b1c:	2301      	movs	r3, #1
 8008b1e:	e00a      	b.n	8008b36 <BSP_HUMIDITY_Sensor_Enable+0x42>
  }

  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 8008b20:	68bb      	ldr	r3, [r7, #8]
 8008b22:	689b      	ldr	r3, [r3, #8]
 8008b24:	68fa      	ldr	r2, [r7, #12]
 8008b26:	0010      	movs	r0, r2
 8008b28:	4798      	blx	r3
 8008b2a:	0003      	movs	r3, r0
 8008b2c:	2b01      	cmp	r3, #1
 8008b2e:	d101      	bne.n	8008b34 <BSP_HUMIDITY_Sensor_Enable+0x40>
  {
    return COMPONENT_ERROR;
 8008b30:	2301      	movs	r3, #1
 8008b32:	e000      	b.n	8008b36 <BSP_HUMIDITY_Sensor_Enable+0x42>
  }

  return COMPONENT_OK;
 8008b34:	2300      	movs	r3, #0
}
 8008b36:	0018      	movs	r0, r3
 8008b38:	46bd      	mov	sp, r7
 8008b3a:	b004      	add	sp, #16
 8008b3c:	bd80      	pop	{r7, pc}

08008b3e <BSP_HUMIDITY_Get_Hum>:
 * @param humidity pointer where the value is written [%]
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_HUMIDITY_Get_Hum( void *handle, float *humidity )
{
 8008b3e:	b580      	push	{r7, lr}
 8008b40:	b084      	sub	sp, #16
 8008b42:	af00      	add	r7, sp, #0
 8008b44:	6078      	str	r0, [r7, #4]
 8008b46:	6039      	str	r1, [r7, #0]

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 8008b48:	687b      	ldr	r3, [r7, #4]
 8008b4a:	60fb      	str	r3, [r7, #12]
  HUMIDITY_Drv_t *driver = NULL;
 8008b4c:	2300      	movs	r3, #0
 8008b4e:	60bb      	str	r3, [r7, #8]

  if(ctx == NULL)
 8008b50:	68fb      	ldr	r3, [r7, #12]
 8008b52:	2b00      	cmp	r3, #0
 8008b54:	d101      	bne.n	8008b5a <BSP_HUMIDITY_Get_Hum+0x1c>
  {
    return COMPONENT_ERROR;
 8008b56:	2301      	movs	r3, #1
 8008b58:	e019      	b.n	8008b8e <BSP_HUMIDITY_Get_Hum+0x50>
  }

  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;
 8008b5a:	68fb      	ldr	r3, [r7, #12]
 8008b5c:	68db      	ldr	r3, [r3, #12]
 8008b5e:	60bb      	str	r3, [r7, #8]

  if ( humidity == NULL )
 8008b60:	683b      	ldr	r3, [r7, #0]
 8008b62:	2b00      	cmp	r3, #0
 8008b64:	d101      	bne.n	8008b6a <BSP_HUMIDITY_Get_Hum+0x2c>
  {
    return COMPONENT_ERROR;
 8008b66:	2301      	movs	r3, #1
 8008b68:	e011      	b.n	8008b8e <BSP_HUMIDITY_Get_Hum+0x50>
  }
  if ( driver->Get_Hum == NULL )
 8008b6a:	68bb      	ldr	r3, [r7, #8]
 8008b6c:	699b      	ldr	r3, [r3, #24]
 8008b6e:	2b00      	cmp	r3, #0
 8008b70:	d101      	bne.n	8008b76 <BSP_HUMIDITY_Get_Hum+0x38>
  {
    return COMPONENT_ERROR;
 8008b72:	2301      	movs	r3, #1
 8008b74:	e00b      	b.n	8008b8e <BSP_HUMIDITY_Get_Hum+0x50>
  }
  if ( driver->Get_Hum( ctx, humidity ) == COMPONENT_ERROR )
 8008b76:	68bb      	ldr	r3, [r7, #8]
 8008b78:	699b      	ldr	r3, [r3, #24]
 8008b7a:	6839      	ldr	r1, [r7, #0]
 8008b7c:	68fa      	ldr	r2, [r7, #12]
 8008b7e:	0010      	movs	r0, r2
 8008b80:	4798      	blx	r3
 8008b82:	0003      	movs	r3, r0
 8008b84:	2b01      	cmp	r3, #1
 8008b86:	d101      	bne.n	8008b8c <BSP_HUMIDITY_Get_Hum+0x4e>
  {
    return COMPONENT_ERROR;
 8008b88:	2301      	movs	r3, #1
 8008b8a:	e000      	b.n	8008b8e <BSP_HUMIDITY_Get_Hum+0x50>
  }

  return COMPONENT_OK;
 8008b8c:	2300      	movs	r3, #0
}
 8008b8e:	0018      	movs	r0, r3
 8008b90:	46bd      	mov	sp, r7
 8008b92:	b004      	add	sp, #16
 8008b94:	bd80      	pop	{r7, pc}

08008b96 <BSP_PRESSURE_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_PRESSURE_Init( PRESSURE_ID_t id, void **handle )
{
 8008b96:	b580      	push	{r7, lr}
 8008b98:	b082      	sub	sp, #8
 8008b9a:	af00      	add	r7, sp, #0
 8008b9c:	0002      	movs	r2, r0
 8008b9e:	6039      	str	r1, [r7, #0]
 8008ba0:	1dfb      	adds	r3, r7, #7
 8008ba2:	701a      	strb	r2, [r3, #0]
  *handle = NULL;
 8008ba4:	683b      	ldr	r3, [r7, #0]
 8008ba6:	2200      	movs	r2, #0
 8008ba8:	601a      	str	r2, [r3, #0]

  switch(id)
 8008baa:	1dfb      	adds	r3, r7, #7
 8008bac:	781b      	ldrb	r3, [r3, #0]
 8008bae:	b25b      	sxtb	r3, r3
 8008bb0:	2b00      	cmp	r3, #0
 8008bb2:	d008      	beq.n	8008bc6 <BSP_PRESSURE_Init+0x30>
  {
    case PRESSURE_SENSORS_AUTO:
    default:
    {
      /* Try to init the LPS22HB first */
      if( BSP_LPS22HB_PRESSURE_Init(handle) == COMPONENT_ERROR )
 8008bb4:	683b      	ldr	r3, [r7, #0]
 8008bb6:	0018      	movs	r0, r3
 8008bb8:	f000 f816 	bl	8008be8 <BSP_LPS22HB_PRESSURE_Init>
 8008bbc:	0003      	movs	r3, r0
 8008bbe:	2b01      	cmp	r3, #1
 8008bc0:	d10a      	bne.n	8008bd8 <BSP_PRESSURE_Init+0x42>
      {
        return COMPONENT_ERROR;
 8008bc2:	2301      	movs	r3, #1
 8008bc4:	e00c      	b.n	8008be0 <BSP_PRESSURE_Init+0x4a>
      }
      break;
    }
    case LPS22HB_P_0:
    {
      if( BSP_LPS22HB_PRESSURE_Init(handle) == COMPONENT_ERROR )
 8008bc6:	683b      	ldr	r3, [r7, #0]
 8008bc8:	0018      	movs	r0, r3
 8008bca:	f000 f80d 	bl	8008be8 <BSP_LPS22HB_PRESSURE_Init>
 8008bce:	0003      	movs	r3, r0
 8008bd0:	2b01      	cmp	r3, #1
 8008bd2:	d103      	bne.n	8008bdc <BSP_PRESSURE_Init+0x46>
      {
        return COMPONENT_ERROR;
 8008bd4:	2301      	movs	r3, #1
 8008bd6:	e003      	b.n	8008be0 <BSP_PRESSURE_Init+0x4a>
      break;
 8008bd8:	46c0      	nop			; (mov r8, r8)
 8008bda:	e000      	b.n	8008bde <BSP_PRESSURE_Init+0x48>
      }
      break;
 8008bdc:	46c0      	nop			; (mov r8, r8)
    }
  }

  return COMPONENT_OK;
 8008bde:	2300      	movs	r3, #0
}
 8008be0:	0018      	movs	r0, r3
 8008be2:	46bd      	mov	sp, r7
 8008be4:	b002      	add	sp, #8
 8008be6:	bd80      	pop	{r7, pc}

08008be8 <BSP_LPS22HB_PRESSURE_Init>:


static DrvStatusTypeDef BSP_LPS22HB_PRESSURE_Init( void **handle )
{
 8008be8:	b580      	push	{r7, lr}
 8008bea:	b084      	sub	sp, #16
 8008bec:	af00      	add	r7, sp, #0
 8008bee:	6078      	str	r0, [r7, #4]
  PRESSURE_Drv_t *driver = NULL;
 8008bf0:	2300      	movs	r3, #0
 8008bf2:	60fb      	str	r3, [r7, #12]

  if(PRESSURE_SensorHandle[ LPS22HB_P_0 ].isInitialized == 1)
 8008bf4:	4b31      	ldr	r3, [pc, #196]	; (8008cbc <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 8008bf6:	78db      	ldrb	r3, [r3, #3]
 8008bf8:	2b01      	cmp	r3, #1
 8008bfa:	d101      	bne.n	8008c00 <BSP_LPS22HB_PRESSURE_Init+0x18>
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
 8008bfc:	2301      	movs	r3, #1
 8008bfe:	e059      	b.n	8008cb4 <BSP_LPS22HB_PRESSURE_Init+0xcc>
  }

  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8008c00:	f7ff fd4a 	bl	8008698 <Sensor_IO_Init>
 8008c04:	0003      	movs	r3, r0
 8008c06:	2b01      	cmp	r3, #1
 8008c08:	d101      	bne.n	8008c0e <BSP_LPS22HB_PRESSURE_Init+0x26>
  {
    return COMPONENT_ERROR;
 8008c0a:	2301      	movs	r3, #1
 8008c0c:	e052      	b.n	8008cb4 <BSP_LPS22HB_PRESSURE_Init+0xcc>
  }

  /* Setup sensor handle. */
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 8008c0e:	4b2b      	ldr	r3, [pc, #172]	; (8008cbc <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 8008c10:	22b1      	movs	r2, #177	; 0xb1
 8008c12:	701a      	strb	r2, [r3, #0]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].address       = LPS22HB_ADDRESS_HIGH;
 8008c14:	4b29      	ldr	r3, [pc, #164]	; (8008cbc <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 8008c16:	22ba      	movs	r2, #186	; 0xba
 8008c18:	705a      	strb	r2, [r3, #1]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].instance      = LPS22HB_P_0;
 8008c1a:	4b28      	ldr	r3, [pc, #160]	; (8008cbc <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 8008c1c:	2200      	movs	r2, #0
 8008c1e:	709a      	strb	r2, [r3, #2]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].isInitialized = 0;
 8008c20:	4b26      	ldr	r3, [pc, #152]	; (8008cbc <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 8008c22:	2200      	movs	r2, #0
 8008c24:	70da      	strb	r2, [r3, #3]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].isEnabled     = 0;
 8008c26:	4b25      	ldr	r3, [pc, #148]	; (8008cbc <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 8008c28:	2200      	movs	r2, #0
 8008c2a:	711a      	strb	r2, [r3, #4]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].isCombo       = 1;
 8008c2c:	4b23      	ldr	r3, [pc, #140]	; (8008cbc <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 8008c2e:	2201      	movs	r2, #1
 8008c30:	715a      	strb	r2, [r3, #5]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pData         = ( void * )&PRESSURE_Data[ LPS22HB_P_0 ];
 8008c32:	4b22      	ldr	r3, [pc, #136]	; (8008cbc <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 8008c34:	4a22      	ldr	r2, [pc, #136]	; (8008cc0 <BSP_LPS22HB_PRESSURE_Init+0xd8>)
 8008c36:	609a      	str	r2, [r3, #8]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pVTable       = ( void * )&LPS22HB_P_Drv;
 8008c38:	4b20      	ldr	r3, [pc, #128]	; (8008cbc <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 8008c3a:	4a22      	ldr	r2, [pc, #136]	; (8008cc4 <BSP_LPS22HB_PRESSURE_Init+0xdc>)
 8008c3c:	60da      	str	r2, [r3, #12]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pExtVTable    = ( void * )&LPS22HB_P_ExtDrv;
 8008c3e:	4b1f      	ldr	r3, [pc, #124]	; (8008cbc <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 8008c40:	4a21      	ldr	r2, [pc, #132]	; (8008cc8 <BSP_LPS22HB_PRESSURE_Init+0xe0>)
 8008c42:	611a      	str	r2, [r3, #16]

  LPS22HB_P_0_Data.comboData = &LPS22HB_Combo_Data[0];
 8008c44:	4b21      	ldr	r3, [pc, #132]	; (8008ccc <BSP_LPS22HB_PRESSURE_Init+0xe4>)
 8008c46:	4a22      	ldr	r2, [pc, #136]	; (8008cd0 <BSP_LPS22HB_PRESSURE_Init+0xe8>)
 8008c48:	601a      	str	r2, [r3, #0]
  PRESSURE_Data[ LPS22HB_P_0 ].pComponentData = ( void * )&LPS22HB_P_0_Data;
 8008c4a:	4b1d      	ldr	r3, [pc, #116]	; (8008cc0 <BSP_LPS22HB_PRESSURE_Init+0xd8>)
 8008c4c:	4a1f      	ldr	r2, [pc, #124]	; (8008ccc <BSP_LPS22HB_PRESSURE_Init+0xe4>)
 8008c4e:	601a      	str	r2, [r3, #0]
  PRESSURE_Data[ LPS22HB_P_0 ].pExtData       = 0;
 8008c50:	4b1b      	ldr	r3, [pc, #108]	; (8008cc0 <BSP_LPS22HB_PRESSURE_Init+0xd8>)
 8008c52:	2200      	movs	r2, #0
 8008c54:	605a      	str	r2, [r3, #4]

  *handle = (void *)&PRESSURE_SensorHandle[ LPS22HB_P_0 ];
 8008c56:	687b      	ldr	r3, [r7, #4]
 8008c58:	4a18      	ldr	r2, [pc, #96]	; (8008cbc <BSP_LPS22HB_PRESSURE_Init+0xd4>)
 8008c5a:	601a      	str	r2, [r3, #0]

  driver = ( PRESSURE_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
 8008c5c:	687b      	ldr	r3, [r7, #4]
 8008c5e:	681b      	ldr	r3, [r3, #0]
 8008c60:	68db      	ldr	r3, [r3, #12]
 8008c62:	60fb      	str	r3, [r7, #12]

  if ( driver->Init == NULL )
 8008c64:	68fb      	ldr	r3, [r7, #12]
 8008c66:	681b      	ldr	r3, [r3, #0]
 8008c68:	2b00      	cmp	r3, #0
 8008c6a:	d10b      	bne.n	8008c84 <BSP_LPS22HB_PRESSURE_Init+0x9c>
  {
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8008c6c:	687b      	ldr	r3, [r7, #4]
 8008c6e:	681b      	ldr	r3, [r3, #0]
 8008c70:	2214      	movs	r2, #20
 8008c72:	2100      	movs	r1, #0
 8008c74:	0018      	movs	r0, r3
 8008c76:	f014 fc6d 	bl	801d554 <memset>
    *handle = NULL;
 8008c7a:	687b      	ldr	r3, [r7, #4]
 8008c7c:	2200      	movs	r2, #0
 8008c7e:	601a      	str	r2, [r3, #0]
    return COMPONENT_ERROR;
 8008c80:	2301      	movs	r3, #1
 8008c82:	e017      	b.n	8008cb4 <BSP_LPS22HB_PRESSURE_Init+0xcc>
  }

  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8008c84:	68fb      	ldr	r3, [r7, #12]
 8008c86:	681a      	ldr	r2, [r3, #0]
 8008c88:	687b      	ldr	r3, [r7, #4]
 8008c8a:	681b      	ldr	r3, [r3, #0]
 8008c8c:	0018      	movs	r0, r3
 8008c8e:	4790      	blx	r2
 8008c90:	0003      	movs	r3, r0
 8008c92:	2b01      	cmp	r3, #1
 8008c94:	d10b      	bne.n	8008cae <BSP_LPS22HB_PRESSURE_Init+0xc6>
  {
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8008c96:	687b      	ldr	r3, [r7, #4]
 8008c98:	681b      	ldr	r3, [r3, #0]
 8008c9a:	2214      	movs	r2, #20
 8008c9c:	2100      	movs	r1, #0
 8008c9e:	0018      	movs	r0, r3
 8008ca0:	f014 fc58 	bl	801d554 <memset>
    *handle = NULL;
 8008ca4:	687b      	ldr	r3, [r7, #4]
 8008ca6:	2200      	movs	r2, #0
 8008ca8:	601a      	str	r2, [r3, #0]
    return COMPONENT_ERROR;
 8008caa:	2301      	movs	r3, #1
 8008cac:	e002      	b.n	8008cb4 <BSP_LPS22HB_PRESSURE_Init+0xcc>
  }

  /* Configure interrupt lines for LPS22HB */
  LPS22HB_Sensor_IO_ITConfig();
 8008cae:	f7ff fcff 	bl	80086b0 <LPS22HB_Sensor_IO_ITConfig>

  return COMPONENT_OK;
 8008cb2:	2300      	movs	r3, #0
}
 8008cb4:	0018      	movs	r0, r3
 8008cb6:	46bd      	mov	sp, r7
 8008cb8:	b004      	add	sp, #16
 8008cba:	bd80      	pop	{r7, pc}
 8008cbc:	200004c4 	.word	0x200004c4
 8008cc0:	200004d8 	.word	0x200004d8
 8008cc4:	2000008c 	.word	0x2000008c
 8008cc8:	200000f4 	.word	0x200000f4
 8008ccc:	200004e0 	.word	0x200004e0
 8008cd0:	20001724 	.word	0x20001724

08008cd4 <BSP_PRESSURE_Sensor_Enable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_PRESSURE_Sensor_Enable( void *handle )
{
 8008cd4:	b580      	push	{r7, lr}
 8008cd6:	b084      	sub	sp, #16
 8008cd8:	af00      	add	r7, sp, #0
 8008cda:	6078      	str	r0, [r7, #4]

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 8008cdc:	687b      	ldr	r3, [r7, #4]
 8008cde:	60fb      	str	r3, [r7, #12]
  PRESSURE_Drv_t *driver = NULL;
 8008ce0:	2300      	movs	r3, #0
 8008ce2:	60bb      	str	r3, [r7, #8]

  if(ctx == NULL)
 8008ce4:	68fb      	ldr	r3, [r7, #12]
 8008ce6:	2b00      	cmp	r3, #0
 8008ce8:	d101      	bne.n	8008cee <BSP_PRESSURE_Sensor_Enable+0x1a>
  {
    return COMPONENT_ERROR;
 8008cea:	2301      	movs	r3, #1
 8008cec:	e013      	b.n	8008d16 <BSP_PRESSURE_Sensor_Enable+0x42>
  }

  driver = ( PRESSURE_Drv_t * )ctx->pVTable;
 8008cee:	68fb      	ldr	r3, [r7, #12]
 8008cf0:	68db      	ldr	r3, [r3, #12]
 8008cf2:	60bb      	str	r3, [r7, #8]

  if ( driver->Sensor_Enable == NULL )
 8008cf4:	68bb      	ldr	r3, [r7, #8]
 8008cf6:	689b      	ldr	r3, [r3, #8]
 8008cf8:	2b00      	cmp	r3, #0
 8008cfa:	d101      	bne.n	8008d00 <BSP_PRESSURE_Sensor_Enable+0x2c>
  {
    return COMPONENT_ERROR;
 8008cfc:	2301      	movs	r3, #1
 8008cfe:	e00a      	b.n	8008d16 <BSP_PRESSURE_Sensor_Enable+0x42>
  }

  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 8008d00:	68bb      	ldr	r3, [r7, #8]
 8008d02:	689b      	ldr	r3, [r3, #8]
 8008d04:	68fa      	ldr	r2, [r7, #12]
 8008d06:	0010      	movs	r0, r2
 8008d08:	4798      	blx	r3
 8008d0a:	0003      	movs	r3, r0
 8008d0c:	2b01      	cmp	r3, #1
 8008d0e:	d101      	bne.n	8008d14 <BSP_PRESSURE_Sensor_Enable+0x40>
  {
    return COMPONENT_ERROR;
 8008d10:	2301      	movs	r3, #1
 8008d12:	e000      	b.n	8008d16 <BSP_PRESSURE_Sensor_Enable+0x42>
  }

  return COMPONENT_OK;
 8008d14:	2300      	movs	r3, #0
}
 8008d16:	0018      	movs	r0, r3
 8008d18:	46bd      	mov	sp, r7
 8008d1a:	b004      	add	sp, #16
 8008d1c:	bd80      	pop	{r7, pc}

08008d1e <BSP_PRESSURE_Get_Press>:
 * @param pressure pointer where the value is written [hPa]
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_PRESSURE_Get_Press( void *handle, float *pressure )
{
 8008d1e:	b580      	push	{r7, lr}
 8008d20:	b084      	sub	sp, #16
 8008d22:	af00      	add	r7, sp, #0
 8008d24:	6078      	str	r0, [r7, #4]
 8008d26:	6039      	str	r1, [r7, #0]

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 8008d28:	687b      	ldr	r3, [r7, #4]
 8008d2a:	60fb      	str	r3, [r7, #12]
  PRESSURE_Drv_t *driver = NULL;
 8008d2c:	2300      	movs	r3, #0
 8008d2e:	60bb      	str	r3, [r7, #8]

  if(ctx == NULL)
 8008d30:	68fb      	ldr	r3, [r7, #12]
 8008d32:	2b00      	cmp	r3, #0
 8008d34:	d101      	bne.n	8008d3a <BSP_PRESSURE_Get_Press+0x1c>
  {
    return COMPONENT_ERROR;
 8008d36:	2301      	movs	r3, #1
 8008d38:	e019      	b.n	8008d6e <BSP_PRESSURE_Get_Press+0x50>
  }

  driver = ( PRESSURE_Drv_t * )ctx->pVTable;
 8008d3a:	68fb      	ldr	r3, [r7, #12]
 8008d3c:	68db      	ldr	r3, [r3, #12]
 8008d3e:	60bb      	str	r3, [r7, #8]

  if ( pressure == NULL )
 8008d40:	683b      	ldr	r3, [r7, #0]
 8008d42:	2b00      	cmp	r3, #0
 8008d44:	d101      	bne.n	8008d4a <BSP_PRESSURE_Get_Press+0x2c>
  {
    return COMPONENT_ERROR;
 8008d46:	2301      	movs	r3, #1
 8008d48:	e011      	b.n	8008d6e <BSP_PRESSURE_Get_Press+0x50>
  }
  if ( driver->Get_Press == NULL )
 8008d4a:	68bb      	ldr	r3, [r7, #8]
 8008d4c:	699b      	ldr	r3, [r3, #24]
 8008d4e:	2b00      	cmp	r3, #0
 8008d50:	d101      	bne.n	8008d56 <BSP_PRESSURE_Get_Press+0x38>
  {
    return COMPONENT_ERROR;
 8008d52:	2301      	movs	r3, #1
 8008d54:	e00b      	b.n	8008d6e <BSP_PRESSURE_Get_Press+0x50>
  }
  if ( driver->Get_Press( ctx, pressure ) == COMPONENT_ERROR )
 8008d56:	68bb      	ldr	r3, [r7, #8]
 8008d58:	699b      	ldr	r3, [r3, #24]
 8008d5a:	6839      	ldr	r1, [r7, #0]
 8008d5c:	68fa      	ldr	r2, [r7, #12]
 8008d5e:	0010      	movs	r0, r2
 8008d60:	4798      	blx	r3
 8008d62:	0003      	movs	r3, r0
 8008d64:	2b01      	cmp	r3, #1
 8008d66:	d101      	bne.n	8008d6c <BSP_PRESSURE_Get_Press+0x4e>
  {
    return COMPONENT_ERROR;
 8008d68:	2301      	movs	r3, #1
 8008d6a:	e000      	b.n	8008d6e <BSP_PRESSURE_Get_Press+0x50>
  }

  return COMPONENT_OK;
 8008d6c:	2300      	movs	r3, #0
}
 8008d6e:	0018      	movs	r0, r3
 8008d70:	46bd      	mov	sp, r7
 8008d72:	b004      	add	sp, #16
 8008d74:	bd80      	pop	{r7, pc}

08008d76 <BSP_TEMPERATURE_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_TEMPERATURE_Init( TEMPERATURE_ID_t id, void **handle )
{
 8008d76:	b580      	push	{r7, lr}
 8008d78:	b082      	sub	sp, #8
 8008d7a:	af00      	add	r7, sp, #0
 8008d7c:	0002      	movs	r2, r0
 8008d7e:	6039      	str	r1, [r7, #0]
 8008d80:	1dfb      	adds	r3, r7, #7
 8008d82:	701a      	strb	r2, [r3, #0]

  *handle = NULL;
 8008d84:	683b      	ldr	r3, [r7, #0]
 8008d86:	2200      	movs	r2, #0
 8008d88:	601a      	str	r2, [r3, #0]

  switch(id)
 8008d8a:	1dfb      	adds	r3, r7, #7
 8008d8c:	781b      	ldrb	r3, [r3, #0]
 8008d8e:	b25b      	sxtb	r3, r3
 8008d90:	2b00      	cmp	r3, #0
 8008d92:	d011      	beq.n	8008db8 <BSP_TEMPERATURE_Init+0x42>
 8008d94:	2b01      	cmp	r3, #1
 8008d96:	d018      	beq.n	8008dca <BSP_TEMPERATURE_Init+0x54>
  {
    case TEMPERATURE_SENSORS_AUTO:
    default:
    {
      /* Try to init the HTS221 on board */
      if( BSP_HTS221_TEMPERATURE_Init(handle) == COMPONENT_ERROR )
 8008d98:	683b      	ldr	r3, [r7, #0]
 8008d9a:	0018      	movs	r0, r3
 8008d9c:	f000 f828 	bl	8008df0 <BSP_HTS221_TEMPERATURE_Init>
 8008da0:	0003      	movs	r3, r0
 8008da2:	2b01      	cmp	r3, #1
 8008da4:	d11a      	bne.n	8008ddc <BSP_TEMPERATURE_Init+0x66>
      {
        /* Try to init the LPS22HB on board if we do not use the HTS221 on board */
        if(BSP_LPS22HB_TEMPERATURE_Init(handle) == COMPONENT_ERROR )
 8008da6:	683b      	ldr	r3, [r7, #0]
 8008da8:	0018      	movs	r0, r3
 8008daa:	f000 f893 	bl	8008ed4 <BSP_LPS22HB_TEMPERATURE_Init>
 8008dae:	0003      	movs	r3, r0
 8008db0:	2b01      	cmp	r3, #1
 8008db2:	d113      	bne.n	8008ddc <BSP_TEMPERATURE_Init+0x66>
        {
          return COMPONENT_ERROR;
 8008db4:	2301      	movs	r3, #1
 8008db6:	e017      	b.n	8008de8 <BSP_TEMPERATURE_Init+0x72>
      }
      break;
    }
    case HTS221_T_0:
    {
      if( BSP_HTS221_TEMPERATURE_Init(handle) == COMPONENT_ERROR )
 8008db8:	683b      	ldr	r3, [r7, #0]
 8008dba:	0018      	movs	r0, r3
 8008dbc:	f000 f818 	bl	8008df0 <BSP_HTS221_TEMPERATURE_Init>
 8008dc0:	0003      	movs	r3, r0
 8008dc2:	2b01      	cmp	r3, #1
 8008dc4:	d10c      	bne.n	8008de0 <BSP_TEMPERATURE_Init+0x6a>
      {
        return COMPONENT_ERROR;
 8008dc6:	2301      	movs	r3, #1
 8008dc8:	e00e      	b.n	8008de8 <BSP_TEMPERATURE_Init+0x72>
      }
      break;
    }
    case LPS22HB_T_0:
    {
      if(BSP_LPS22HB_TEMPERATURE_Init(handle) == COMPONENT_ERROR )
 8008dca:	683b      	ldr	r3, [r7, #0]
 8008dcc:	0018      	movs	r0, r3
 8008dce:	f000 f881 	bl	8008ed4 <BSP_LPS22HB_TEMPERATURE_Init>
 8008dd2:	0003      	movs	r3, r0
 8008dd4:	2b01      	cmp	r3, #1
 8008dd6:	d105      	bne.n	8008de4 <BSP_TEMPERATURE_Init+0x6e>
      {
        return COMPONENT_ERROR;
 8008dd8:	2301      	movs	r3, #1
 8008dda:	e005      	b.n	8008de8 <BSP_TEMPERATURE_Init+0x72>
      break;
 8008ddc:	46c0      	nop			; (mov r8, r8)
 8008dde:	e002      	b.n	8008de6 <BSP_TEMPERATURE_Init+0x70>
      break;
 8008de0:	46c0      	nop			; (mov r8, r8)
 8008de2:	e000      	b.n	8008de6 <BSP_TEMPERATURE_Init+0x70>
      }
      break;
 8008de4:	46c0      	nop			; (mov r8, r8)
    }
  }

  return COMPONENT_OK;
 8008de6:	2300      	movs	r3, #0
}
 8008de8:	0018      	movs	r0, r3
 8008dea:	46bd      	mov	sp, r7
 8008dec:	b002      	add	sp, #8
 8008dee:	bd80      	pop	{r7, pc}

08008df0 <BSP_HTS221_TEMPERATURE_Init>:


static DrvStatusTypeDef BSP_HTS221_TEMPERATURE_Init( void **handle )
{
 8008df0:	b580      	push	{r7, lr}
 8008df2:	b084      	sub	sp, #16
 8008df4:	af00      	add	r7, sp, #0
 8008df6:	6078      	str	r0, [r7, #4]
  TEMPERATURE_Drv_t *driver = NULL;
 8008df8:	2300      	movs	r3, #0
 8008dfa:	60fb      	str	r3, [r7, #12]

  if(TEMPERATURE_SensorHandle[ HTS221_T_0 ].isInitialized == 1)
 8008dfc:	4b30      	ldr	r3, [pc, #192]	; (8008ec0 <BSP_HTS221_TEMPERATURE_Init+0xd0>)
 8008dfe:	78db      	ldrb	r3, [r3, #3]
 8008e00:	2b01      	cmp	r3, #1
 8008e02:	d101      	bne.n	8008e08 <BSP_HTS221_TEMPERATURE_Init+0x18>
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
 8008e04:	2301      	movs	r3, #1
 8008e06:	e057      	b.n	8008eb8 <BSP_HTS221_TEMPERATURE_Init+0xc8>
  }

  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8008e08:	f7ff fc46 	bl	8008698 <Sensor_IO_Init>
 8008e0c:	0003      	movs	r3, r0
 8008e0e:	2b01      	cmp	r3, #1
 8008e10:	d101      	bne.n	8008e16 <BSP_HTS221_TEMPERATURE_Init+0x26>
  {
    return COMPONENT_ERROR;
 8008e12:	2301      	movs	r3, #1
 8008e14:	e050      	b.n	8008eb8 <BSP_HTS221_TEMPERATURE_Init+0xc8>
  }

  /* Setup sensor handle. */
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 8008e16:	4b2a      	ldr	r3, [pc, #168]	; (8008ec0 <BSP_HTS221_TEMPERATURE_Init+0xd0>)
 8008e18:	22bc      	movs	r2, #188	; 0xbc
 8008e1a:	701a      	strb	r2, [r3, #0]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].address       = HTS221_ADDRESS_DEFAULT;
 8008e1c:	4b28      	ldr	r3, [pc, #160]	; (8008ec0 <BSP_HTS221_TEMPERATURE_Init+0xd0>)
 8008e1e:	22be      	movs	r2, #190	; 0xbe
 8008e20:	705a      	strb	r2, [r3, #1]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].instance      = HTS221_T_0;
 8008e22:	4b27      	ldr	r3, [pc, #156]	; (8008ec0 <BSP_HTS221_TEMPERATURE_Init+0xd0>)
 8008e24:	2200      	movs	r2, #0
 8008e26:	709a      	strb	r2, [r3, #2]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].isInitialized = 0;
 8008e28:	4b25      	ldr	r3, [pc, #148]	; (8008ec0 <BSP_HTS221_TEMPERATURE_Init+0xd0>)
 8008e2a:	2200      	movs	r2, #0
 8008e2c:	70da      	strb	r2, [r3, #3]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].isEnabled     = 0;
 8008e2e:	4b24      	ldr	r3, [pc, #144]	; (8008ec0 <BSP_HTS221_TEMPERATURE_Init+0xd0>)
 8008e30:	2200      	movs	r2, #0
 8008e32:	711a      	strb	r2, [r3, #4]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].isCombo       = 1;
 8008e34:	4b22      	ldr	r3, [pc, #136]	; (8008ec0 <BSP_HTS221_TEMPERATURE_Init+0xd0>)
 8008e36:	2201      	movs	r2, #1
 8008e38:	715a      	strb	r2, [r3, #5]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ HTS221_T_0 ];
 8008e3a:	4b21      	ldr	r3, [pc, #132]	; (8008ec0 <BSP_HTS221_TEMPERATURE_Init+0xd0>)
 8008e3c:	4a21      	ldr	r2, [pc, #132]	; (8008ec4 <BSP_HTS221_TEMPERATURE_Init+0xd4>)
 8008e3e:	609a      	str	r2, [r3, #8]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pVTable       = ( void * )&HTS221_T_Drv;
 8008e40:	4b1f      	ldr	r3, [pc, #124]	; (8008ec0 <BSP_HTS221_TEMPERATURE_Init+0xd0>)
 8008e42:	4a21      	ldr	r2, [pc, #132]	; (8008ec8 <BSP_HTS221_TEMPERATURE_Init+0xd8>)
 8008e44:	60da      	str	r2, [r3, #12]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pExtVTable    = 0;
 8008e46:	4b1e      	ldr	r3, [pc, #120]	; (8008ec0 <BSP_HTS221_TEMPERATURE_Init+0xd0>)
 8008e48:	2200      	movs	r2, #0
 8008e4a:	611a      	str	r2, [r3, #16]

  HTS221_T_0_Data.comboData = &HTS221_Combo_Data[0];
 8008e4c:	4b1f      	ldr	r3, [pc, #124]	; (8008ecc <BSP_HTS221_TEMPERATURE_Init+0xdc>)
 8008e4e:	4a20      	ldr	r2, [pc, #128]	; (8008ed0 <BSP_HTS221_TEMPERATURE_Init+0xe0>)
 8008e50:	601a      	str	r2, [r3, #0]
  TEMPERATURE_Data[ HTS221_T_0 ].pComponentData = ( void * )&HTS221_T_0_Data;
 8008e52:	4b1c      	ldr	r3, [pc, #112]	; (8008ec4 <BSP_HTS221_TEMPERATURE_Init+0xd4>)
 8008e54:	4a1d      	ldr	r2, [pc, #116]	; (8008ecc <BSP_HTS221_TEMPERATURE_Init+0xdc>)
 8008e56:	601a      	str	r2, [r3, #0]
  TEMPERATURE_Data[ HTS221_T_0 ].pExtData       = 0;
 8008e58:	4b1a      	ldr	r3, [pc, #104]	; (8008ec4 <BSP_HTS221_TEMPERATURE_Init+0xd4>)
 8008e5a:	2200      	movs	r2, #0
 8008e5c:	605a      	str	r2, [r3, #4]

  *handle = (void *)&TEMPERATURE_SensorHandle[ HTS221_T_0 ];
 8008e5e:	687b      	ldr	r3, [r7, #4]
 8008e60:	4a17      	ldr	r2, [pc, #92]	; (8008ec0 <BSP_HTS221_TEMPERATURE_Init+0xd0>)
 8008e62:	601a      	str	r2, [r3, #0]

  driver = ( TEMPERATURE_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
 8008e64:	687b      	ldr	r3, [r7, #4]
 8008e66:	681b      	ldr	r3, [r3, #0]
 8008e68:	68db      	ldr	r3, [r3, #12]
 8008e6a:	60fb      	str	r3, [r7, #12]

  if ( driver->Init == NULL )
 8008e6c:	68fb      	ldr	r3, [r7, #12]
 8008e6e:	681b      	ldr	r3, [r3, #0]
 8008e70:	2b00      	cmp	r3, #0
 8008e72:	d10b      	bne.n	8008e8c <BSP_HTS221_TEMPERATURE_Init+0x9c>
  {
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8008e74:	687b      	ldr	r3, [r7, #4]
 8008e76:	681b      	ldr	r3, [r3, #0]
 8008e78:	2214      	movs	r2, #20
 8008e7a:	2100      	movs	r1, #0
 8008e7c:	0018      	movs	r0, r3
 8008e7e:	f014 fb69 	bl	801d554 <memset>
    *handle = NULL;
 8008e82:	687b      	ldr	r3, [r7, #4]
 8008e84:	2200      	movs	r2, #0
 8008e86:	601a      	str	r2, [r3, #0]
    return COMPONENT_ERROR;
 8008e88:	2301      	movs	r3, #1
 8008e8a:	e015      	b.n	8008eb8 <BSP_HTS221_TEMPERATURE_Init+0xc8>
  }

  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8008e8c:	68fb      	ldr	r3, [r7, #12]
 8008e8e:	681a      	ldr	r2, [r3, #0]
 8008e90:	687b      	ldr	r3, [r7, #4]
 8008e92:	681b      	ldr	r3, [r3, #0]
 8008e94:	0018      	movs	r0, r3
 8008e96:	4790      	blx	r2
 8008e98:	0003      	movs	r3, r0
 8008e9a:	2b01      	cmp	r3, #1
 8008e9c:	d10b      	bne.n	8008eb6 <BSP_HTS221_TEMPERATURE_Init+0xc6>
  {
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8008e9e:	687b      	ldr	r3, [r7, #4]
 8008ea0:	681b      	ldr	r3, [r3, #0]
 8008ea2:	2214      	movs	r2, #20
 8008ea4:	2100      	movs	r1, #0
 8008ea6:	0018      	movs	r0, r3
 8008ea8:	f014 fb54 	bl	801d554 <memset>
    *handle = NULL;
 8008eac:	687b      	ldr	r3, [r7, #4]
 8008eae:	2200      	movs	r2, #0
 8008eb0:	601a      	str	r2, [r3, #0]
    return COMPONENT_ERROR;
 8008eb2:	2301      	movs	r3, #1
 8008eb4:	e000      	b.n	8008eb8 <BSP_HTS221_TEMPERATURE_Init+0xc8>
  }

  return COMPONENT_OK;
 8008eb6:	2300      	movs	r3, #0
}
 8008eb8:	0018      	movs	r0, r3
 8008eba:	46bd      	mov	sp, r7
 8008ebc:	b004      	add	sp, #16
 8008ebe:	bd80      	pop	{r7, pc}
 8008ec0:	200004e4 	.word	0x200004e4
 8008ec4:	2000050c 	.word	0x2000050c
 8008ec8:	20000058 	.word	0x20000058
 8008ecc:	2000051c 	.word	0x2000051c
 8008ed0:	20001720 	.word	0x20001720

08008ed4 <BSP_LPS22HB_TEMPERATURE_Init>:


static DrvStatusTypeDef BSP_LPS22HB_TEMPERATURE_Init( void **handle )
{
 8008ed4:	b580      	push	{r7, lr}
 8008ed6:	b084      	sub	sp, #16
 8008ed8:	af00      	add	r7, sp, #0
 8008eda:	6078      	str	r0, [r7, #4]
  TEMPERATURE_Drv_t *driver = NULL;
 8008edc:	2300      	movs	r3, #0
 8008ede:	60fb      	str	r3, [r7, #12]

  if(TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isInitialized == 1)
 8008ee0:	4b31      	ldr	r3, [pc, #196]	; (8008fa8 <BSP_LPS22HB_TEMPERATURE_Init+0xd4>)
 8008ee2:	7ddb      	ldrb	r3, [r3, #23]
 8008ee4:	2b01      	cmp	r3, #1
 8008ee6:	d101      	bne.n	8008eec <BSP_LPS22HB_TEMPERATURE_Init+0x18>
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
 8008ee8:	2301      	movs	r3, #1
 8008eea:	e059      	b.n	8008fa0 <BSP_LPS22HB_TEMPERATURE_Init+0xcc>
  }

  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8008eec:	f7ff fbd4 	bl	8008698 <Sensor_IO_Init>
 8008ef0:	0003      	movs	r3, r0
 8008ef2:	2b01      	cmp	r3, #1
 8008ef4:	d101      	bne.n	8008efa <BSP_LPS22HB_TEMPERATURE_Init+0x26>
  {
    return COMPONENT_ERROR;
 8008ef6:	2301      	movs	r3, #1
 8008ef8:	e052      	b.n	8008fa0 <BSP_LPS22HB_TEMPERATURE_Init+0xcc>
  }

  /* Setup sensor handle. */
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 8008efa:	4b2b      	ldr	r3, [pc, #172]	; (8008fa8 <BSP_LPS22HB_TEMPERATURE_Init+0xd4>)
 8008efc:	22b1      	movs	r2, #177	; 0xb1
 8008efe:	751a      	strb	r2, [r3, #20]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].address       = LPS22HB_ADDRESS_HIGH;
 8008f00:	4b29      	ldr	r3, [pc, #164]	; (8008fa8 <BSP_LPS22HB_TEMPERATURE_Init+0xd4>)
 8008f02:	22ba      	movs	r2, #186	; 0xba
 8008f04:	755a      	strb	r2, [r3, #21]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].instance      = LPS22HB_T_0;
 8008f06:	4b28      	ldr	r3, [pc, #160]	; (8008fa8 <BSP_LPS22HB_TEMPERATURE_Init+0xd4>)
 8008f08:	2201      	movs	r2, #1
 8008f0a:	759a      	strb	r2, [r3, #22]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isInitialized = 0;
 8008f0c:	4b26      	ldr	r3, [pc, #152]	; (8008fa8 <BSP_LPS22HB_TEMPERATURE_Init+0xd4>)
 8008f0e:	2200      	movs	r2, #0
 8008f10:	75da      	strb	r2, [r3, #23]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isEnabled     = 0;
 8008f12:	4b25      	ldr	r3, [pc, #148]	; (8008fa8 <BSP_LPS22HB_TEMPERATURE_Init+0xd4>)
 8008f14:	2200      	movs	r2, #0
 8008f16:	761a      	strb	r2, [r3, #24]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isCombo       = 1;
 8008f18:	4b23      	ldr	r3, [pc, #140]	; (8008fa8 <BSP_LPS22HB_TEMPERATURE_Init+0xd4>)
 8008f1a:	2201      	movs	r2, #1
 8008f1c:	765a      	strb	r2, [r3, #25]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ LPS22HB_T_0 ];
 8008f1e:	4b22      	ldr	r3, [pc, #136]	; (8008fa8 <BSP_LPS22HB_TEMPERATURE_Init+0xd4>)
 8008f20:	4a22      	ldr	r2, [pc, #136]	; (8008fac <BSP_LPS22HB_TEMPERATURE_Init+0xd8>)
 8008f22:	61da      	str	r2, [r3, #28]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pVTable       = ( void * )&LPS22HB_T_Drv;
 8008f24:	4b20      	ldr	r3, [pc, #128]	; (8008fa8 <BSP_LPS22HB_TEMPERATURE_Init+0xd4>)
 8008f26:	4a22      	ldr	r2, [pc, #136]	; (8008fb0 <BSP_LPS22HB_TEMPERATURE_Init+0xdc>)
 8008f28:	621a      	str	r2, [r3, #32]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pExtVTable    = ( void * )&LPS22HB_T_ExtDrv;
 8008f2a:	4b1f      	ldr	r3, [pc, #124]	; (8008fa8 <BSP_LPS22HB_TEMPERATURE_Init+0xd4>)
 8008f2c:	4a21      	ldr	r2, [pc, #132]	; (8008fb4 <BSP_LPS22HB_TEMPERATURE_Init+0xe0>)
 8008f2e:	625a      	str	r2, [r3, #36]	; 0x24

  LPS22HB_T_0_Data.comboData = &LPS22HB_Combo_Data[0];
 8008f30:	4b21      	ldr	r3, [pc, #132]	; (8008fb8 <BSP_LPS22HB_TEMPERATURE_Init+0xe4>)
 8008f32:	4a22      	ldr	r2, [pc, #136]	; (8008fbc <BSP_LPS22HB_TEMPERATURE_Init+0xe8>)
 8008f34:	601a      	str	r2, [r3, #0]
  TEMPERATURE_Data[ LPS22HB_T_0 ].pComponentData = ( void * )&LPS22HB_T_0_Data;
 8008f36:	4b22      	ldr	r3, [pc, #136]	; (8008fc0 <BSP_LPS22HB_TEMPERATURE_Init+0xec>)
 8008f38:	4a1f      	ldr	r2, [pc, #124]	; (8008fb8 <BSP_LPS22HB_TEMPERATURE_Init+0xe4>)
 8008f3a:	609a      	str	r2, [r3, #8]
  TEMPERATURE_Data[ LPS22HB_T_0 ].pExtData       = 0;
 8008f3c:	4b20      	ldr	r3, [pc, #128]	; (8008fc0 <BSP_LPS22HB_TEMPERATURE_Init+0xec>)
 8008f3e:	2200      	movs	r2, #0
 8008f40:	60da      	str	r2, [r3, #12]

  *handle = (void *)&TEMPERATURE_SensorHandle[ LPS22HB_T_0 ];
 8008f42:	687b      	ldr	r3, [r7, #4]
 8008f44:	4a1f      	ldr	r2, [pc, #124]	; (8008fc4 <BSP_LPS22HB_TEMPERATURE_Init+0xf0>)
 8008f46:	601a      	str	r2, [r3, #0]

  driver = ( TEMPERATURE_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;
 8008f48:	687b      	ldr	r3, [r7, #4]
 8008f4a:	681b      	ldr	r3, [r3, #0]
 8008f4c:	68db      	ldr	r3, [r3, #12]
 8008f4e:	60fb      	str	r3, [r7, #12]

  if ( driver->Init == NULL )
 8008f50:	68fb      	ldr	r3, [r7, #12]
 8008f52:	681b      	ldr	r3, [r3, #0]
 8008f54:	2b00      	cmp	r3, #0
 8008f56:	d10b      	bne.n	8008f70 <BSP_LPS22HB_TEMPERATURE_Init+0x9c>
  {
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8008f58:	687b      	ldr	r3, [r7, #4]
 8008f5a:	681b      	ldr	r3, [r3, #0]
 8008f5c:	2214      	movs	r2, #20
 8008f5e:	2100      	movs	r1, #0
 8008f60:	0018      	movs	r0, r3
 8008f62:	f014 faf7 	bl	801d554 <memset>
    *handle = NULL;
 8008f66:	687b      	ldr	r3, [r7, #4]
 8008f68:	2200      	movs	r2, #0
 8008f6a:	601a      	str	r2, [r3, #0]
    return COMPONENT_ERROR;
 8008f6c:	2301      	movs	r3, #1
 8008f6e:	e017      	b.n	8008fa0 <BSP_LPS22HB_TEMPERATURE_Init+0xcc>
  }

  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8008f70:	68fb      	ldr	r3, [r7, #12]
 8008f72:	681a      	ldr	r2, [r3, #0]
 8008f74:	687b      	ldr	r3, [r7, #4]
 8008f76:	681b      	ldr	r3, [r3, #0]
 8008f78:	0018      	movs	r0, r3
 8008f7a:	4790      	blx	r2
 8008f7c:	0003      	movs	r3, r0
 8008f7e:	2b01      	cmp	r3, #1
 8008f80:	d10b      	bne.n	8008f9a <BSP_LPS22HB_TEMPERATURE_Init+0xc6>
  {
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8008f82:	687b      	ldr	r3, [r7, #4]
 8008f84:	681b      	ldr	r3, [r3, #0]
 8008f86:	2214      	movs	r2, #20
 8008f88:	2100      	movs	r1, #0
 8008f8a:	0018      	movs	r0, r3
 8008f8c:	f014 fae2 	bl	801d554 <memset>
    *handle = NULL;
 8008f90:	687b      	ldr	r3, [r7, #4]
 8008f92:	2200      	movs	r2, #0
 8008f94:	601a      	str	r2, [r3, #0]
    return COMPONENT_ERROR;
 8008f96:	2301      	movs	r3, #1
 8008f98:	e002      	b.n	8008fa0 <BSP_LPS22HB_TEMPERATURE_Init+0xcc>
  }

  /* Configure interrupt lines for LPS22HB */
  LPS22HB_Sensor_IO_ITConfig();
 8008f9a:	f7ff fb89 	bl	80086b0 <LPS22HB_Sensor_IO_ITConfig>

  return COMPONENT_OK;
 8008f9e:	2300      	movs	r3, #0
}
 8008fa0:	0018      	movs	r0, r3
 8008fa2:	46bd      	mov	sp, r7
 8008fa4:	b004      	add	sp, #16
 8008fa6:	bd80      	pop	{r7, pc}
 8008fa8:	200004e4 	.word	0x200004e4
 8008fac:	20000514 	.word	0x20000514
 8008fb0:	200000c0 	.word	0x200000c0
 8008fb4:	20000130 	.word	0x20000130
 8008fb8:	20000520 	.word	0x20000520
 8008fbc:	20001724 	.word	0x20001724
 8008fc0:	2000050c 	.word	0x2000050c
 8008fc4:	200004f8 	.word	0x200004f8

08008fc8 <BSP_TEMPERATURE_Sensor_Enable>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_TEMPERATURE_Sensor_Enable( void *handle )
{
 8008fc8:	b580      	push	{r7, lr}
 8008fca:	b084      	sub	sp, #16
 8008fcc:	af00      	add	r7, sp, #0
 8008fce:	6078      	str	r0, [r7, #4]

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 8008fd0:	687b      	ldr	r3, [r7, #4]
 8008fd2:	60fb      	str	r3, [r7, #12]
  TEMPERATURE_Drv_t *driver = NULL;
 8008fd4:	2300      	movs	r3, #0
 8008fd6:	60bb      	str	r3, [r7, #8]

  if(ctx == NULL)
 8008fd8:	68fb      	ldr	r3, [r7, #12]
 8008fda:	2b00      	cmp	r3, #0
 8008fdc:	d101      	bne.n	8008fe2 <BSP_TEMPERATURE_Sensor_Enable+0x1a>
  {
    return COMPONENT_ERROR;
 8008fde:	2301      	movs	r3, #1
 8008fe0:	e013      	b.n	800900a <BSP_TEMPERATURE_Sensor_Enable+0x42>
  }

  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;
 8008fe2:	68fb      	ldr	r3, [r7, #12]
 8008fe4:	68db      	ldr	r3, [r3, #12]
 8008fe6:	60bb      	str	r3, [r7, #8]

  if ( driver->Sensor_Enable == NULL )
 8008fe8:	68bb      	ldr	r3, [r7, #8]
 8008fea:	689b      	ldr	r3, [r3, #8]
 8008fec:	2b00      	cmp	r3, #0
 8008fee:	d101      	bne.n	8008ff4 <BSP_TEMPERATURE_Sensor_Enable+0x2c>
  {
    return COMPONENT_ERROR;
 8008ff0:	2301      	movs	r3, #1
 8008ff2:	e00a      	b.n	800900a <BSP_TEMPERATURE_Sensor_Enable+0x42>
  }

  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 8008ff4:	68bb      	ldr	r3, [r7, #8]
 8008ff6:	689b      	ldr	r3, [r3, #8]
 8008ff8:	68fa      	ldr	r2, [r7, #12]
 8008ffa:	0010      	movs	r0, r2
 8008ffc:	4798      	blx	r3
 8008ffe:	0003      	movs	r3, r0
 8009000:	2b01      	cmp	r3, #1
 8009002:	d101      	bne.n	8009008 <BSP_TEMPERATURE_Sensor_Enable+0x40>
  {
    return COMPONENT_ERROR;
 8009004:	2301      	movs	r3, #1
 8009006:	e000      	b.n	800900a <BSP_TEMPERATURE_Sensor_Enable+0x42>
  }

  return COMPONENT_OK;
 8009008:	2300      	movs	r3, #0
}
 800900a:	0018      	movs	r0, r3
 800900c:	46bd      	mov	sp, r7
 800900e:	b004      	add	sp, #16
 8009010:	bd80      	pop	{r7, pc}

08009012 <BSP_TEMPERATURE_Get_Temp>:
 * @param temperature pointer where the value is written [C]
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_TEMPERATURE_Get_Temp( void *handle, float *temperature )
{
 8009012:	b580      	push	{r7, lr}
 8009014:	b084      	sub	sp, #16
 8009016:	af00      	add	r7, sp, #0
 8009018:	6078      	str	r0, [r7, #4]
 800901a:	6039      	str	r1, [r7, #0]

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
 800901c:	687b      	ldr	r3, [r7, #4]
 800901e:	60fb      	str	r3, [r7, #12]
  TEMPERATURE_Drv_t *driver = NULL;
 8009020:	2300      	movs	r3, #0
 8009022:	60bb      	str	r3, [r7, #8]

  if(ctx == NULL)
 8009024:	68fb      	ldr	r3, [r7, #12]
 8009026:	2b00      	cmp	r3, #0
 8009028:	d101      	bne.n	800902e <BSP_TEMPERATURE_Get_Temp+0x1c>
  {
    return COMPONENT_ERROR;
 800902a:	2301      	movs	r3, #1
 800902c:	e019      	b.n	8009062 <BSP_TEMPERATURE_Get_Temp+0x50>
  }

  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;
 800902e:	68fb      	ldr	r3, [r7, #12]
 8009030:	68db      	ldr	r3, [r3, #12]
 8009032:	60bb      	str	r3, [r7, #8]

  if ( temperature == NULL )
 8009034:	683b      	ldr	r3, [r7, #0]
 8009036:	2b00      	cmp	r3, #0
 8009038:	d101      	bne.n	800903e <BSP_TEMPERATURE_Get_Temp+0x2c>
  {
    return COMPONENT_ERROR;
 800903a:	2301      	movs	r3, #1
 800903c:	e011      	b.n	8009062 <BSP_TEMPERATURE_Get_Temp+0x50>
  }
  if ( driver->Get_Temp == NULL )
 800903e:	68bb      	ldr	r3, [r7, #8]
 8009040:	699b      	ldr	r3, [r3, #24]
 8009042:	2b00      	cmp	r3, #0
 8009044:	d101      	bne.n	800904a <BSP_TEMPERATURE_Get_Temp+0x38>
  {
    return COMPONENT_ERROR;
 8009046:	2301      	movs	r3, #1
 8009048:	e00b      	b.n	8009062 <BSP_TEMPERATURE_Get_Temp+0x50>
  }
  if ( driver->Get_Temp( ctx, temperature ) == COMPONENT_ERROR )
 800904a:	68bb      	ldr	r3, [r7, #8]
 800904c:	699b      	ldr	r3, [r3, #24]
 800904e:	6839      	ldr	r1, [r7, #0]
 8009050:	68fa      	ldr	r2, [r7, #12]
 8009052:	0010      	movs	r0, r2
 8009054:	4798      	blx	r3
 8009056:	0003      	movs	r3, r0
 8009058:	2b01      	cmp	r3, #1
 800905a:	d101      	bne.n	8009060 <BSP_TEMPERATURE_Get_Temp+0x4e>
  {
    return COMPONENT_ERROR;
 800905c:	2301      	movs	r3, #1
 800905e:	e000      	b.n	8009062 <BSP_TEMPERATURE_Get_Temp+0x50>
  }

  return COMPONENT_OK;
 8009060:	2300      	movs	r3, #0
}
 8009062:	0018      	movs	r0, r3
 8009064:	46bd      	mov	sp, r7
 8009066:	b004      	add	sp, #16
 8009068:	bd80      	pop	{r7, pc}
	...

0800906c <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 800906c:	b580      	push	{r7, lr}
 800906e:	af00      	add	r7, sp, #0
/*!< Set MSION bit */
  RCC->CR |= (uint32_t)0x00000100U;
 8009070:	4b17      	ldr	r3, [pc, #92]	; (80090d0 <SystemInit+0x64>)
 8009072:	681a      	ldr	r2, [r3, #0]
 8009074:	4b16      	ldr	r3, [pc, #88]	; (80090d0 <SystemInit+0x64>)
 8009076:	2180      	movs	r1, #128	; 0x80
 8009078:	0049      	lsls	r1, r1, #1
 800907a:	430a      	orrs	r2, r1
 800907c:	601a      	str	r2, [r3, #0]

  /*!< Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
  RCC->CFGR &= (uint32_t) 0x88FF400CU;
 800907e:	4b14      	ldr	r3, [pc, #80]	; (80090d0 <SystemInit+0x64>)
 8009080:	68da      	ldr	r2, [r3, #12]
 8009082:	4b13      	ldr	r3, [pc, #76]	; (80090d0 <SystemInit+0x64>)
 8009084:	4913      	ldr	r1, [pc, #76]	; (80090d4 <SystemInit+0x68>)
 8009086:	400a      	ands	r2, r1
 8009088:	60da      	str	r2, [r3, #12]

  /*!< Reset HSION, HSIDIVEN, HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFF6U;
 800908a:	4b11      	ldr	r3, [pc, #68]	; (80090d0 <SystemInit+0x64>)
 800908c:	681a      	ldr	r2, [r3, #0]
 800908e:	4b10      	ldr	r3, [pc, #64]	; (80090d0 <SystemInit+0x64>)
 8009090:	4911      	ldr	r1, [pc, #68]	; (80090d8 <SystemInit+0x6c>)
 8009092:	400a      	ands	r2, r1
 8009094:	601a      	str	r2, [r3, #0]

  /*!< Reset HSI48ON  bit */
  RCC->CRRCR &= (uint32_t)0xFFFFFFFEU;
 8009096:	4b0e      	ldr	r3, [pc, #56]	; (80090d0 <SystemInit+0x64>)
 8009098:	689a      	ldr	r2, [r3, #8]
 800909a:	4b0d      	ldr	r3, [pc, #52]	; (80090d0 <SystemInit+0x64>)
 800909c:	2101      	movs	r1, #1
 800909e:	438a      	bics	r2, r1
 80090a0:	609a      	str	r2, [r3, #8]

  /*!< Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFFU;
 80090a2:	4b0b      	ldr	r3, [pc, #44]	; (80090d0 <SystemInit+0x64>)
 80090a4:	681a      	ldr	r2, [r3, #0]
 80090a6:	4b0a      	ldr	r3, [pc, #40]	; (80090d0 <SystemInit+0x64>)
 80090a8:	490c      	ldr	r1, [pc, #48]	; (80090dc <SystemInit+0x70>)
 80090aa:	400a      	ands	r2, r1
 80090ac:	601a      	str	r2, [r3, #0]

  /*!< Reset PLLSRC, PLLMUL[3:0] and PLLDIV[1:0] bits */
  RCC->CFGR &= (uint32_t)0xFF02FFFFU;
 80090ae:	4b08      	ldr	r3, [pc, #32]	; (80090d0 <SystemInit+0x64>)
 80090b0:	68da      	ldr	r2, [r3, #12]
 80090b2:	4b07      	ldr	r3, [pc, #28]	; (80090d0 <SystemInit+0x64>)
 80090b4:	490a      	ldr	r1, [pc, #40]	; (80090e0 <SystemInit+0x74>)
 80090b6:	400a      	ands	r2, r1
 80090b8:	60da      	str	r2, [r3, #12]

  /*!< Disable all interrupts */
  RCC->CIER = 0x00000000U;
 80090ba:	4b05      	ldr	r3, [pc, #20]	; (80090d0 <SystemInit+0x64>)
 80090bc:	2200      	movs	r2, #0
 80090be:	611a      	str	r2, [r3, #16]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80090c0:	4b08      	ldr	r3, [pc, #32]	; (80090e4 <SystemInit+0x78>)
 80090c2:	2280      	movs	r2, #128	; 0x80
 80090c4:	0512      	lsls	r2, r2, #20
 80090c6:	609a      	str	r2, [r3, #8]
#endif
}
 80090c8:	46c0      	nop			; (mov r8, r8)
 80090ca:	46bd      	mov	sp, r7
 80090cc:	bd80      	pop	{r7, pc}
 80090ce:	46c0      	nop			; (mov r8, r8)
 80090d0:	40021000 	.word	0x40021000
 80090d4:	88ff400c 	.word	0x88ff400c
 80090d8:	fef6fff6 	.word	0xfef6fff6
 80090dc:	fffbffff 	.word	0xfffbffff
 80090e0:	ff02ffff 	.word	0xff02ffff
 80090e4:	e000ed00 	.word	0xe000ed00

080090e8 <HAL_Init>:
  *        In the default implementation,Systick is used as source of time base.
  *        the tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80090e8:	b580      	push	{r7, lr}
 80090ea:	b082      	sub	sp, #8
 80090ec:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 80090ee:	1dfb      	adds	r3, r7, #7
 80090f0:	2200      	movs	r2, #0
 80090f2:	701a      	strb	r2, [r3, #0]
#if (PREREAD_ENABLE != 0)
  __HAL_FLASH_PREREAD_BUFFER_ENABLE();
#endif /* PREREAD_ENABLE */

#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80090f4:	4b0b      	ldr	r3, [pc, #44]	; (8009124 <HAL_Init+0x3c>)
 80090f6:	681a      	ldr	r2, [r3, #0]
 80090f8:	4b0a      	ldr	r3, [pc, #40]	; (8009124 <HAL_Init+0x3c>)
 80090fa:	2102      	movs	r1, #2
 80090fc:	430a      	orrs	r2, r1
 80090fe:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8009100:	2003      	movs	r0, #3
 8009102:	f013 fcc0 	bl	801ca86 <HAL_InitTick>
 8009106:	1e03      	subs	r3, r0, #0
 8009108:	d003      	beq.n	8009112 <HAL_Init+0x2a>
  {
    status = HAL_ERROR;
 800910a:	1dfb      	adds	r3, r7, #7
 800910c:	2201      	movs	r2, #1
 800910e:	701a      	strb	r2, [r3, #0]
 8009110:	e001      	b.n	8009116 <HAL_Init+0x2e>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 8009112:	f013 fccd 	bl	801cab0 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 8009116:	1dfb      	adds	r3, r7, #7
 8009118:	781b      	ldrb	r3, [r3, #0]
}
 800911a:	0018      	movs	r0, r3
 800911c:	46bd      	mov	sp, r7
 800911e:	b002      	add	sp, #8
 8009120:	bd80      	pop	{r7, pc}
 8009122:	46c0      	nop			; (mov r8, r8)
 8009124:	40022000 	.word	0x40022000

08009128 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8009128:	b580      	push	{r7, lr}
 800912a:	af00      	add	r7, sp, #0
  uwTick++;
 800912c:	4b03      	ldr	r3, [pc, #12]	; (800913c <HAL_IncTick+0x14>)
 800912e:	681b      	ldr	r3, [r3, #0]
 8009130:	1c5a      	adds	r2, r3, #1
 8009132:	4b02      	ldr	r3, [pc, #8]	; (800913c <HAL_IncTick+0x14>)
 8009134:	601a      	str	r2, [r3, #0]
}
 8009136:	46c0      	nop			; (mov r8, r8)
 8009138:	46bd      	mov	sp, r7
 800913a:	bd80      	pop	{r7, pc}
 800913c:	200017dc 	.word	0x200017dc

08009140 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8009140:	b580      	push	{r7, lr}
 8009142:	af00      	add	r7, sp, #0
  return uwTick;
 8009144:	4b02      	ldr	r3, [pc, #8]	; (8009150 <HAL_GetTick+0x10>)
 8009146:	681b      	ldr	r3, [r3, #0]
}
 8009148:	0018      	movs	r0, r3
 800914a:	46bd      	mov	sp, r7
 800914c:	bd80      	pop	{r7, pc}
 800914e:	46c0      	nop			; (mov r8, r8)
 8009150:	200017dc 	.word	0x200017dc

08009154 <HAL_DBGMCU_EnableDBGSleepMode>:
/**
  * @brief  Enables the Debug Module during SLEEP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
 8009154:	b580      	push	{r7, lr}
 8009156:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 8009158:	4b04      	ldr	r3, [pc, #16]	; (800916c <HAL_DBGMCU_EnableDBGSleepMode+0x18>)
 800915a:	685a      	ldr	r2, [r3, #4]
 800915c:	4b03      	ldr	r3, [pc, #12]	; (800916c <HAL_DBGMCU_EnableDBGSleepMode+0x18>)
 800915e:	2101      	movs	r1, #1
 8009160:	430a      	orrs	r2, r1
 8009162:	605a      	str	r2, [r3, #4]
}
 8009164:	46c0      	nop			; (mov r8, r8)
 8009166:	46bd      	mov	sp, r7
 8009168:	bd80      	pop	{r7, pc}
 800916a:	46c0      	nop			; (mov r8, r8)
 800916c:	40015800 	.word	0x40015800

08009170 <HAL_DBGMCU_EnableDBGStopMode>:
/**
  * @brief  Enables the Debug Module during STOP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
 8009170:	b580      	push	{r7, lr}
 8009172:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8009174:	4b04      	ldr	r3, [pc, #16]	; (8009188 <HAL_DBGMCU_EnableDBGStopMode+0x18>)
 8009176:	685a      	ldr	r2, [r3, #4]
 8009178:	4b03      	ldr	r3, [pc, #12]	; (8009188 <HAL_DBGMCU_EnableDBGStopMode+0x18>)
 800917a:	2102      	movs	r1, #2
 800917c:	430a      	orrs	r2, r1
 800917e:	605a      	str	r2, [r3, #4]
}
 8009180:	46c0      	nop			; (mov r8, r8)
 8009182:	46bd      	mov	sp, r7
 8009184:	bd80      	pop	{r7, pc}
 8009186:	46c0      	nop			; (mov r8, r8)
 8009188:	40015800 	.word	0x40015800

0800918c <HAL_DBGMCU_EnableDBGStandbyMode>:
/**
  * @brief  Enables the Debug Module during STANDBY mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
 800918c:	b580      	push	{r7, lr}
 800918e:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 8009190:	4b04      	ldr	r3, [pc, #16]	; (80091a4 <HAL_DBGMCU_EnableDBGStandbyMode+0x18>)
 8009192:	685a      	ldr	r2, [r3, #4]
 8009194:	4b03      	ldr	r3, [pc, #12]	; (80091a4 <HAL_DBGMCU_EnableDBGStandbyMode+0x18>)
 8009196:	2104      	movs	r1, #4
 8009198:	430a      	orrs	r2, r1
 800919a:	605a      	str	r2, [r3, #4]
}
 800919c:	46c0      	nop			; (mov r8, r8)
 800919e:	46bd      	mov	sp, r7
 80091a0:	bd80      	pop	{r7, pc}
 80091a2:	46c0      	nop			; (mov r8, r8)
 80091a4:	40015800 	.word	0x40015800

080091a8 <HAL_ADC_Init>:
  *         function "HAL_ADCEx_EnableVREFINTTempSensor()" must be called similarilly.  
  * @param  hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 80091a8:	b580      	push	{r7, lr}
 80091aa:	b082      	sub	sp, #8
 80091ac:	af00      	add	r7, sp, #0
 80091ae:	6078      	str	r0, [r7, #4]
 
  /* Check ADC handle */
  if(hadc == NULL)
 80091b0:	687b      	ldr	r3, [r7, #4]
 80091b2:	2b00      	cmp	r3, #0
 80091b4:	d101      	bne.n	80091ba <HAL_ADC_Init+0x12>
  {
    return HAL_ERROR;
 80091b6:	2301      	movs	r3, #1
 80091b8:	e159      	b.n	800946e <HAL_ADC_Init+0x2c6>
  /* Refer to header of this file for more details on clock enabling procedure*/
  
  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  /* - ADC voltage regulator enable                                           */
  if(hadc->State == HAL_ADC_STATE_RESET)
 80091ba:	687b      	ldr	r3, [r7, #4]
 80091bc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80091be:	2b00      	cmp	r3, #0
 80091c0:	d10a      	bne.n	80091d8 <HAL_ADC_Init+0x30>
  {
    /* Initialize ADC error code */
    ADC_CLEAR_ERRORCODE(hadc);
 80091c2:	687b      	ldr	r3, [r7, #4]
 80091c4:	2200      	movs	r2, #0
 80091c6:	659a      	str	r2, [r3, #88]	; 0x58
    
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 80091c8:	687b      	ldr	r3, [r7, #4]
 80091ca:	2250      	movs	r2, #80	; 0x50
 80091cc:	2100      	movs	r1, #0
 80091ce:	5499      	strb	r1, [r3, r2]
    
    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 80091d0:	687b      	ldr	r3, [r7, #4]
 80091d2:	0018      	movs	r0, r3
 80091d4:	f000 f95c 	bl	8009490 <HAL_ADC_MspInit>
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  /* and if there is no conversion on going on regular group (ADC can be      */
  /* enabled anyway, in case of call of this function to update a parameter   */
  /* on the fly).                                                             */
  if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) ||
 80091d8:	687b      	ldr	r3, [r7, #4]
 80091da:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80091dc:	2210      	movs	r2, #16
 80091de:	4013      	ands	r3, r2
 80091e0:	2b10      	cmp	r3, #16
 80091e2:	d005      	beq.n	80091f0 <HAL_ADC_Init+0x48>
     (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) != RESET)  )
 80091e4:	687b      	ldr	r3, [r7, #4]
 80091e6:	681b      	ldr	r3, [r3, #0]
 80091e8:	689b      	ldr	r3, [r3, #8]
 80091ea:	2204      	movs	r2, #4
 80091ec:	4013      	ands	r3, r2
  if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) ||
 80091ee:	d00b      	beq.n	8009208 <HAL_ADC_Init+0x60>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80091f0:	687b      	ldr	r3, [r7, #4]
 80091f2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80091f4:	2210      	movs	r2, #16
 80091f6:	431a      	orrs	r2, r3
 80091f8:	687b      	ldr	r3, [r7, #4]
 80091fa:	655a      	str	r2, [r3, #84]	; 0x54
        
    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 80091fc:	687b      	ldr	r3, [r7, #4]
 80091fe:	2250      	movs	r2, #80	; 0x50
 8009200:	2100      	movs	r1, #0
 8009202:	5499      	strb	r1, [r3, r2]
    return HAL_ERROR;
 8009204:	2301      	movs	r3, #1
 8009206:	e132      	b.n	800946e <HAL_ADC_Init+0x2c6>
  }

  /* Set ADC state */
  ADC_STATE_CLR_SET(hadc->State,
 8009208:	687b      	ldr	r3, [r7, #4]
 800920a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800920c:	4a9a      	ldr	r2, [pc, #616]	; (8009478 <HAL_ADC_Init+0x2d0>)
 800920e:	4013      	ands	r3, r2
 8009210:	2202      	movs	r2, #2
 8009212:	431a      	orrs	r2, r3
 8009214:	687b      	ldr	r3, [r7, #4]
 8009216:	655a      	str	r2, [r3, #84]	; 0x54
  /* Parameters update conditioned to ADC state:                            */
  /* Parameters that can be updated only when ADC is disabled:              */
  /*  - ADC clock mode                                                      */
  /*  - ADC clock prescaler                                                 */
  /*  - ADC Resolution                                                      */
  if (ADC_IS_ENABLE(hadc) == RESET)
 8009218:	687b      	ldr	r3, [r7, #4]
 800921a:	681b      	ldr	r3, [r3, #0]
 800921c:	689b      	ldr	r3, [r3, #8]
 800921e:	2203      	movs	r2, #3
 8009220:	4013      	ands	r3, r2
 8009222:	2b01      	cmp	r3, #1
 8009224:	d108      	bne.n	8009238 <HAL_ADC_Init+0x90>
 8009226:	687b      	ldr	r3, [r7, #4]
 8009228:	681b      	ldr	r3, [r3, #0]
 800922a:	681b      	ldr	r3, [r3, #0]
 800922c:	2201      	movs	r2, #1
 800922e:	4013      	ands	r3, r2
 8009230:	2b01      	cmp	r3, #1
 8009232:	d101      	bne.n	8009238 <HAL_ADC_Init+0x90>
 8009234:	2301      	movs	r3, #1
 8009236:	e000      	b.n	800923a <HAL_ADC_Init+0x92>
 8009238:	2300      	movs	r3, #0
 800923a:	2b00      	cmp	r3, #0
 800923c:	d149      	bne.n	80092d2 <HAL_ADC_Init+0x12a>
    /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
    /*     (set into HAL_ADC_ConfigChannel() )                              */
   
    /* Configuration of ADC clock: clock source PCLK or asynchronous with 
    selectable prescaler */
    __HAL_ADC_CLOCK_PRESCALER(hadc);
 800923e:	687b      	ldr	r3, [r7, #4]
 8009240:	685a      	ldr	r2, [r3, #4]
 8009242:	23c0      	movs	r3, #192	; 0xc0
 8009244:	061b      	lsls	r3, r3, #24
 8009246:	429a      	cmp	r2, r3
 8009248:	d00b      	beq.n	8009262 <HAL_ADC_Init+0xba>
 800924a:	687b      	ldr	r3, [r7, #4]
 800924c:	685a      	ldr	r2, [r3, #4]
 800924e:	2380      	movs	r3, #128	; 0x80
 8009250:	05db      	lsls	r3, r3, #23
 8009252:	429a      	cmp	r2, r3
 8009254:	d005      	beq.n	8009262 <HAL_ADC_Init+0xba>
 8009256:	687b      	ldr	r3, [r7, #4]
 8009258:	685a      	ldr	r2, [r3, #4]
 800925a:	2380      	movs	r3, #128	; 0x80
 800925c:	061b      	lsls	r3, r3, #24
 800925e:	429a      	cmp	r2, r3
 8009260:	d111      	bne.n	8009286 <HAL_ADC_Init+0xde>
 8009262:	687b      	ldr	r3, [r7, #4]
 8009264:	681b      	ldr	r3, [r3, #0]
 8009266:	691a      	ldr	r2, [r3, #16]
 8009268:	687b      	ldr	r3, [r7, #4]
 800926a:	681b      	ldr	r3, [r3, #0]
 800926c:	0092      	lsls	r2, r2, #2
 800926e:	0892      	lsrs	r2, r2, #2
 8009270:	611a      	str	r2, [r3, #16]
 8009272:	687b      	ldr	r3, [r7, #4]
 8009274:	681b      	ldr	r3, [r3, #0]
 8009276:	6919      	ldr	r1, [r3, #16]
 8009278:	687b      	ldr	r3, [r7, #4]
 800927a:	685a      	ldr	r2, [r3, #4]
 800927c:	687b      	ldr	r3, [r7, #4]
 800927e:	681b      	ldr	r3, [r3, #0]
 8009280:	430a      	orrs	r2, r1
 8009282:	611a      	str	r2, [r3, #16]
 8009284:	e014      	b.n	80092b0 <HAL_ADC_Init+0x108>
 8009286:	687b      	ldr	r3, [r7, #4]
 8009288:	681b      	ldr	r3, [r3, #0]
 800928a:	691a      	ldr	r2, [r3, #16]
 800928c:	687b      	ldr	r3, [r7, #4]
 800928e:	681b      	ldr	r3, [r3, #0]
 8009290:	0092      	lsls	r2, r2, #2
 8009292:	0892      	lsrs	r2, r2, #2
 8009294:	611a      	str	r2, [r3, #16]
 8009296:	4b79      	ldr	r3, [pc, #484]	; (800947c <HAL_ADC_Init+0x2d4>)
 8009298:	681a      	ldr	r2, [r3, #0]
 800929a:	4b78      	ldr	r3, [pc, #480]	; (800947c <HAL_ADC_Init+0x2d4>)
 800929c:	4978      	ldr	r1, [pc, #480]	; (8009480 <HAL_ADC_Init+0x2d8>)
 800929e:	400a      	ands	r2, r1
 80092a0:	601a      	str	r2, [r3, #0]
 80092a2:	4b76      	ldr	r3, [pc, #472]	; (800947c <HAL_ADC_Init+0x2d4>)
 80092a4:	6819      	ldr	r1, [r3, #0]
 80092a6:	687b      	ldr	r3, [r7, #4]
 80092a8:	685a      	ldr	r2, [r3, #4]
 80092aa:	4b74      	ldr	r3, [pc, #464]	; (800947c <HAL_ADC_Init+0x2d4>)
 80092ac:	430a      	orrs	r2, r1
 80092ae:	601a      	str	r2, [r3, #0]
    
    /* Configuration of ADC:                                                */
    /*  - Resolution                                                        */
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_RES);
 80092b0:	687b      	ldr	r3, [r7, #4]
 80092b2:	681b      	ldr	r3, [r3, #0]
 80092b4:	68da      	ldr	r2, [r3, #12]
 80092b6:	687b      	ldr	r3, [r7, #4]
 80092b8:	681b      	ldr	r3, [r3, #0]
 80092ba:	2118      	movs	r1, #24
 80092bc:	438a      	bics	r2, r1
 80092be:	60da      	str	r2, [r3, #12]
    hadc->Instance->CFGR1 |= hadc->Init.Resolution;    
 80092c0:	687b      	ldr	r3, [r7, #4]
 80092c2:	681b      	ldr	r3, [r3, #0]
 80092c4:	68d9      	ldr	r1, [r3, #12]
 80092c6:	687b      	ldr	r3, [r7, #4]
 80092c8:	689a      	ldr	r2, [r3, #8]
 80092ca:	687b      	ldr	r3, [r7, #4]
 80092cc:	681b      	ldr	r3, [r3, #0]
 80092ce:	430a      	orrs	r2, r1
 80092d0:	60da      	str	r2, [r3, #12]
  }
  
  /* Set the Low Frequency mode */
  ADC->CCR &= (uint32_t)~ADC_CCR_LFMEN;
 80092d2:	4b6a      	ldr	r3, [pc, #424]	; (800947c <HAL_ADC_Init+0x2d4>)
 80092d4:	681a      	ldr	r2, [r3, #0]
 80092d6:	4b69      	ldr	r3, [pc, #420]	; (800947c <HAL_ADC_Init+0x2d4>)
 80092d8:	496a      	ldr	r1, [pc, #424]	; (8009484 <HAL_ADC_Init+0x2dc>)
 80092da:	400a      	ands	r2, r1
 80092dc:	601a      	str	r2, [r3, #0]
  ADC->CCR |=__HAL_ADC_CCR_LOWFREQUENCY(hadc->Init.LowPowerFrequencyMode);  
 80092de:	4b67      	ldr	r3, [pc, #412]	; (800947c <HAL_ADC_Init+0x2d4>)
 80092e0:	6819      	ldr	r1, [r3, #0]
 80092e2:	687b      	ldr	r3, [r7, #4]
 80092e4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80092e6:	065a      	lsls	r2, r3, #25
 80092e8:	4b64      	ldr	r3, [pc, #400]	; (800947c <HAL_ADC_Init+0x2d4>)
 80092ea:	430a      	orrs	r2, r1
 80092ec:	601a      	str	r2, [r3, #0]
   
  /* Enable voltage regulator (if disabled at this step) */
  if (HAL_IS_BIT_CLR(hadc->Instance->CR, ADC_CR_ADVREGEN))
 80092ee:	687b      	ldr	r3, [r7, #4]
 80092f0:	681b      	ldr	r3, [r3, #0]
 80092f2:	689a      	ldr	r2, [r3, #8]
 80092f4:	2380      	movs	r3, #128	; 0x80
 80092f6:	055b      	lsls	r3, r3, #21
 80092f8:	4013      	ands	r3, r2
 80092fa:	d108      	bne.n	800930e <HAL_ADC_Init+0x166>
  {
    /* Set ADVREGEN bit */
    hadc->Instance->CR |= ADC_CR_ADVREGEN;
 80092fc:	687b      	ldr	r3, [r7, #4]
 80092fe:	681b      	ldr	r3, [r3, #0]
 8009300:	689a      	ldr	r2, [r3, #8]
 8009302:	687b      	ldr	r3, [r7, #4]
 8009304:	681b      	ldr	r3, [r3, #0]
 8009306:	2180      	movs	r1, #128	; 0x80
 8009308:	0549      	lsls	r1, r1, #21
 800930a:	430a      	orrs	r2, r1
 800930c:	609a      	str	r2, [r3, #8]
  /*  - Continuous conversion mode                                            */
  /*  - DMA continuous request                                                */
  /*  - Overrun                                                               */
  /*  - AutoDelay feature                                                     */
  /*  - Discontinuous mode                                                    */
  hadc->Instance->CFGR1 &= ~(ADC_CFGR1_ALIGN   |
 800930e:	687b      	ldr	r3, [r7, #4]
 8009310:	681b      	ldr	r3, [r3, #0]
 8009312:	68da      	ldr	r2, [r3, #12]
 8009314:	687b      	ldr	r3, [r7, #4]
 8009316:	681b      	ldr	r3, [r3, #0]
 8009318:	495b      	ldr	r1, [pc, #364]	; (8009488 <HAL_ADC_Init+0x2e0>)
 800931a:	400a      	ands	r2, r1
 800931c:	60da      	str	r2, [r3, #12]
                             ADC_CFGR1_OVRMOD  |
                             ADC_CFGR1_AUTDLY  |
                             ADC_CFGR1_AUTOFF  |
                             ADC_CFGR1_DISCEN   );
  
  hadc->Instance->CFGR1 |= (hadc->Init.DataAlign                             |
 800931e:	687b      	ldr	r3, [r7, #4]
 8009320:	681b      	ldr	r3, [r3, #0]
 8009322:	68d9      	ldr	r1, [r3, #12]
 8009324:	687b      	ldr	r3, [r7, #4]
 8009326:	68da      	ldr	r2, [r3, #12]
                            ADC_SCANDIR(hadc->Init.ScanConvMode)             |
 8009328:	687b      	ldr	r3, [r7, #4]
 800932a:	691b      	ldr	r3, [r3, #16]
 800932c:	2b02      	cmp	r3, #2
 800932e:	d101      	bne.n	8009334 <HAL_ADC_Init+0x18c>
 8009330:	2304      	movs	r3, #4
 8009332:	e000      	b.n	8009336 <HAL_ADC_Init+0x18e>
 8009334:	2300      	movs	r3, #0
  hadc->Instance->CFGR1 |= (hadc->Init.DataAlign                             |
 8009336:	431a      	orrs	r2, r3
                            ADC_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
 8009338:	687b      	ldr	r3, [r7, #4]
 800933a:	2020      	movs	r0, #32
 800933c:	5c1b      	ldrb	r3, [r3, r0]
 800933e:	035b      	lsls	r3, r3, #13
                            ADC_SCANDIR(hadc->Init.ScanConvMode)             |
 8009340:	431a      	orrs	r2, r3
                            ADC_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests) |
 8009342:	687b      	ldr	r3, [r7, #4]
 8009344:	202c      	movs	r0, #44	; 0x2c
 8009346:	5c1b      	ldrb	r3, [r3, r0]
 8009348:	005b      	lsls	r3, r3, #1
                            ADC_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
 800934a:	431a      	orrs	r2, r3
                            hadc->Init.Overrun                               |
 800934c:	687b      	ldr	r3, [r7, #4]
 800934e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                            ADC_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests) |
 8009350:	431a      	orrs	r2, r3
                            __HAL_ADC_CFGR1_AutoDelay(hadc->Init.LowPowerAutoWait) |
 8009352:	687b      	ldr	r3, [r7, #4]
 8009354:	699b      	ldr	r3, [r3, #24]
 8009356:	039b      	lsls	r3, r3, #14
                            hadc->Init.Overrun                               |
 8009358:	431a      	orrs	r2, r3
                            __HAL_ADC_CFGR1_AUTOFF(hadc->Init.LowPowerAutoPowerOff));
 800935a:	687b      	ldr	r3, [r7, #4]
 800935c:	69db      	ldr	r3, [r3, #28]
 800935e:	03db      	lsls	r3, r3, #15
                            __HAL_ADC_CFGR1_AutoDelay(hadc->Init.LowPowerAutoWait) |
 8009360:	431a      	orrs	r2, r3
  hadc->Instance->CFGR1 |= (hadc->Init.DataAlign                             |
 8009362:	687b      	ldr	r3, [r7, #4]
 8009364:	681b      	ldr	r3, [r3, #0]
 8009366:	430a      	orrs	r2, r1
 8009368:	60da      	str	r2, [r3, #12]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800936a:	687b      	ldr	r3, [r7, #4]
 800936c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800936e:	23c2      	movs	r3, #194	; 0xc2
 8009370:	33ff      	adds	r3, #255	; 0xff
 8009372:	429a      	cmp	r2, r3
 8009374:	d00b      	beq.n	800938e <HAL_ADC_Init+0x1e6>
  {
    hadc->Instance->CFGR1 |= hadc->Init.ExternalTrigConv |
 8009376:	687b      	ldr	r3, [r7, #4]
 8009378:	681b      	ldr	r3, [r3, #0]
 800937a:	68d9      	ldr	r1, [r3, #12]
 800937c:	687b      	ldr	r3, [r7, #4]
 800937e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
                             hadc->Init.ExternalTrigConvEdge;
 8009380:	687b      	ldr	r3, [r7, #4]
 8009382:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    hadc->Instance->CFGR1 |= hadc->Init.ExternalTrigConv |
 8009384:	431a      	orrs	r2, r3
 8009386:	687b      	ldr	r3, [r7, #4]
 8009388:	681b      	ldr	r3, [r3, #0]
 800938a:	430a      	orrs	r2, r1
 800938c:	60da      	str	r2, [r3, #12]
  }
  
  /* Enable discontinuous mode only if continuous mode is disabled */
  if (hadc->Init.DiscontinuousConvMode == ENABLE)
 800938e:	687b      	ldr	r3, [r7, #4]
 8009390:	2221      	movs	r2, #33	; 0x21
 8009392:	5c9b      	ldrb	r3, [r3, r2]
 8009394:	2b01      	cmp	r3, #1
 8009396:	d11a      	bne.n	80093ce <HAL_ADC_Init+0x226>
  {
    if (hadc->Init.ContinuousConvMode == DISABLE)
 8009398:	687b      	ldr	r3, [r7, #4]
 800939a:	2220      	movs	r2, #32
 800939c:	5c9b      	ldrb	r3, [r3, r2]
 800939e:	2b00      	cmp	r3, #0
 80093a0:	d109      	bne.n	80093b6 <HAL_ADC_Init+0x20e>
    {
      /* Enable the selected ADC group regular discontinuous mode */
      hadc->Instance->CFGR1 |= (ADC_CFGR1_DISCEN);
 80093a2:	687b      	ldr	r3, [r7, #4]
 80093a4:	681b      	ldr	r3, [r3, #0]
 80093a6:	68da      	ldr	r2, [r3, #12]
 80093a8:	687b      	ldr	r3, [r7, #4]
 80093aa:	681b      	ldr	r3, [r3, #0]
 80093ac:	2180      	movs	r1, #128	; 0x80
 80093ae:	0249      	lsls	r1, r1, #9
 80093b0:	430a      	orrs	r2, r1
 80093b2:	60da      	str	r2, [r3, #12]
 80093b4:	e00b      	b.n	80093ce <HAL_ADC_Init+0x226>
      /* ADC regular group discontinuous was intended to be enabled,        */
      /* but ADC regular group modes continuous and sequencer discontinuous */
      /* cannot be enabled simultaneously.                                  */
      
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80093b6:	687b      	ldr	r3, [r7, #4]
 80093b8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80093ba:	2220      	movs	r2, #32
 80093bc:	431a      	orrs	r2, r3
 80093be:	687b      	ldr	r3, [r7, #4]
 80093c0:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80093c2:	687b      	ldr	r3, [r7, #4]
 80093c4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80093c6:	2201      	movs	r2, #1
 80093c8:	431a      	orrs	r2, r3
 80093ca:	687b      	ldr	r3, [r7, #4]
 80093cc:	659a      	str	r2, [r3, #88]	; 0x58
    }
  }
  
  if (hadc->Init.OversamplingMode == ENABLE)
 80093ce:	687b      	ldr	r3, [r7, #4]
 80093d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80093d2:	2b01      	cmp	r3, #1
 80093d4:	d11f      	bne.n	8009416 <HAL_ADC_Init+0x26e>
    /* Configuration of Oversampler:                                          */
    /*  - Oversampling Ratio                                                  */
    /*  - Right bit shift                                                     */
    /*  - Triggered mode                                                      */
    
    hadc->Instance->CFGR2 &= ~( ADC_CFGR2_OVSR |
 80093d6:	687b      	ldr	r3, [r7, #4]
 80093d8:	681b      	ldr	r3, [r3, #0]
 80093da:	691a      	ldr	r2, [r3, #16]
 80093dc:	687b      	ldr	r3, [r7, #4]
 80093de:	681b      	ldr	r3, [r3, #0]
 80093e0:	492a      	ldr	r1, [pc, #168]	; (800948c <HAL_ADC_Init+0x2e4>)
 80093e2:	400a      	ands	r2, r1
 80093e4:	611a      	str	r2, [r3, #16]
                                ADC_CFGR2_OVSS |
                                ADC_CFGR2_TOVS );
    
    hadc->Instance->CFGR2 |= ( hadc->Init.Oversample.Ratio         |
 80093e6:	687b      	ldr	r3, [r7, #4]
 80093e8:	681b      	ldr	r3, [r3, #0]
 80093ea:	6919      	ldr	r1, [r3, #16]
 80093ec:	687b      	ldr	r3, [r7, #4]
 80093ee:	6c1a      	ldr	r2, [r3, #64]	; 0x40
                               hadc->Init.Oversample.RightBitShift             |
 80093f0:	687b      	ldr	r3, [r7, #4]
 80093f2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    hadc->Instance->CFGR2 |= ( hadc->Init.Oversample.Ratio         |
 80093f4:	431a      	orrs	r2, r3
                               hadc->Init.Oversample.TriggeredMode );
 80093f6:	687b      	ldr	r3, [r7, #4]
 80093f8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
                               hadc->Init.Oversample.RightBitShift             |
 80093fa:	431a      	orrs	r2, r3
    hadc->Instance->CFGR2 |= ( hadc->Init.Oversample.Ratio         |
 80093fc:	687b      	ldr	r3, [r7, #4]
 80093fe:	681b      	ldr	r3, [r3, #0]
 8009400:	430a      	orrs	r2, r1
 8009402:	611a      	str	r2, [r3, #16]
    
    /* Enable OverSampling mode */
     hadc->Instance->CFGR2 |= ADC_CFGR2_OVSE;
 8009404:	687b      	ldr	r3, [r7, #4]
 8009406:	681b      	ldr	r3, [r3, #0]
 8009408:	691a      	ldr	r2, [r3, #16]
 800940a:	687b      	ldr	r3, [r7, #4]
 800940c:	681b      	ldr	r3, [r3, #0]
 800940e:	2101      	movs	r1, #1
 8009410:	430a      	orrs	r2, r1
 8009412:	611a      	str	r2, [r3, #16]
 8009414:	e00e      	b.n	8009434 <HAL_ADC_Init+0x28c>
  }
  else
  {
    if(HAL_IS_BIT_SET(hadc->Instance->CFGR2, ADC_CFGR2_OVSE))
 8009416:	687b      	ldr	r3, [r7, #4]
 8009418:	681b      	ldr	r3, [r3, #0]
 800941a:	691b      	ldr	r3, [r3, #16]
 800941c:	2201      	movs	r2, #1
 800941e:	4013      	ands	r3, r2
 8009420:	2b01      	cmp	r3, #1
 8009422:	d107      	bne.n	8009434 <HAL_ADC_Init+0x28c>
    {
      /* Disable OverSampling mode if needed */
      hadc->Instance->CFGR2 &= ~ADC_CFGR2_OVSE;
 8009424:	687b      	ldr	r3, [r7, #4]
 8009426:	681b      	ldr	r3, [r3, #0]
 8009428:	691a      	ldr	r2, [r3, #16]
 800942a:	687b      	ldr	r3, [r7, #4]
 800942c:	681b      	ldr	r3, [r3, #0]
 800942e:	2101      	movs	r1, #1
 8009430:	438a      	bics	r2, r1
 8009432:	611a      	str	r2, [r3, #16]
    }
  }    
  
  /* Clear the old sampling time */
  hadc->Instance->SMPR &= (uint32_t)(~ADC_SMPR_SMPR);
 8009434:	687b      	ldr	r3, [r7, #4]
 8009436:	681b      	ldr	r3, [r3, #0]
 8009438:	695a      	ldr	r2, [r3, #20]
 800943a:	687b      	ldr	r3, [r7, #4]
 800943c:	681b      	ldr	r3, [r3, #0]
 800943e:	2107      	movs	r1, #7
 8009440:	438a      	bics	r2, r1
 8009442:	615a      	str	r2, [r3, #20]
  
  /* Set the new sample time */
  hadc->Instance->SMPR |= hadc->Init.SamplingTime;
 8009444:	687b      	ldr	r3, [r7, #4]
 8009446:	681b      	ldr	r3, [r3, #0]
 8009448:	6959      	ldr	r1, [r3, #20]
 800944a:	687b      	ldr	r3, [r7, #4]
 800944c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800944e:	687b      	ldr	r3, [r7, #4]
 8009450:	681b      	ldr	r3, [r3, #0]
 8009452:	430a      	orrs	r2, r1
 8009454:	615a      	str	r2, [r3, #20]
  
  /* Clear ADC error code */
  ADC_CLEAR_ERRORCODE(hadc);
 8009456:	687b      	ldr	r3, [r7, #4]
 8009458:	2200      	movs	r2, #0
 800945a:	659a      	str	r2, [r3, #88]	; 0x58

  /* Set the ADC state */
  ADC_STATE_CLR_SET(hadc->State,
 800945c:	687b      	ldr	r3, [r7, #4]
 800945e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009460:	2203      	movs	r2, #3
 8009462:	4393      	bics	r3, r2
 8009464:	2201      	movs	r2, #1
 8009466:	431a      	orrs	r2, r3
 8009468:	687b      	ldr	r3, [r7, #4]
 800946a:	655a      	str	r2, [r3, #84]	; 0x54
                    HAL_ADC_STATE_BUSY_INTERNAL,
                    HAL_ADC_STATE_READY);


  /* Return function status */
  return HAL_OK;
 800946c:	2300      	movs	r3, #0
}
 800946e:	0018      	movs	r0, r3
 8009470:	46bd      	mov	sp, r7
 8009472:	b002      	add	sp, #8
 8009474:	bd80      	pop	{r7, pc}
 8009476:	46c0      	nop			; (mov r8, r8)
 8009478:	fffffefd 	.word	0xfffffefd
 800947c:	40012708 	.word	0x40012708
 8009480:	ffc3ffff 	.word	0xffc3ffff
 8009484:	fdffffff 	.word	0xfdffffff
 8009488:	fffe0219 	.word	0xfffe0219
 800948c:	fffffc03 	.word	0xfffffc03

08009490 <HAL_ADC_MspInit>:
  * @brief  Initialize the ADC MSP.
  * @param  hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8009490:	b580      	push	{r7, lr}
 8009492:	b082      	sub	sp, #8
 8009494:	af00      	add	r7, sp, #0
 8009496:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_MspInit must be implemented in the user file.
   */ 
}
 8009498:	46c0      	nop			; (mov r8, r8)
 800949a:	46bd      	mov	sp, r7
 800949c:	b002      	add	sp, #8
 800949e:	bd80      	pop	{r7, pc}

080094a0 <HAL_ADC_Start>:
  * @note   Interruptions enabled in this function: None.
  * @param  hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
{
 80094a0:	b590      	push	{r4, r7, lr}
 80094a2:	b085      	sub	sp, #20
 80094a4:	af00      	add	r7, sp, #0
 80094a6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80094a8:	230f      	movs	r3, #15
 80094aa:	18fb      	adds	r3, r7, r3
 80094ac:	2200      	movs	r2, #0
 80094ae:	701a      	strb	r2, [r3, #0]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* Perform ADC enable and conversion start if no conversion is on going */
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80094b0:	687b      	ldr	r3, [r7, #4]
 80094b2:	681b      	ldr	r3, [r3, #0]
 80094b4:	689b      	ldr	r3, [r3, #8]
 80094b6:	2204      	movs	r2, #4
 80094b8:	4013      	ands	r3, r2
 80094ba:	d138      	bne.n	800952e <HAL_ADC_Start+0x8e>
  {
    /* Process locked */
    __HAL_LOCK(hadc);
 80094bc:	687b      	ldr	r3, [r7, #4]
 80094be:	2250      	movs	r2, #80	; 0x50
 80094c0:	5c9b      	ldrb	r3, [r3, r2]
 80094c2:	2b01      	cmp	r3, #1
 80094c4:	d101      	bne.n	80094ca <HAL_ADC_Start+0x2a>
 80094c6:	2302      	movs	r3, #2
 80094c8:	e038      	b.n	800953c <HAL_ADC_Start+0x9c>
 80094ca:	687b      	ldr	r3, [r7, #4]
 80094cc:	2250      	movs	r2, #80	; 0x50
 80094ce:	2101      	movs	r1, #1
 80094d0:	5499      	strb	r1, [r3, r2]
    
    /* Enable the ADC peripheral */
    /* If low power mode AutoPowerOff is enabled, power-on/off phases are     */
    /* performed automatically by hardware.                                   */
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 80094d2:	687b      	ldr	r3, [r7, #4]
 80094d4:	69db      	ldr	r3, [r3, #28]
 80094d6:	2b01      	cmp	r3, #1
 80094d8:	d007      	beq.n	80094ea <HAL_ADC_Start+0x4a>
    {
      tmp_hal_status = ADC_Enable(hadc);
 80094da:	230f      	movs	r3, #15
 80094dc:	18fc      	adds	r4, r7, r3
 80094de:	687b      	ldr	r3, [r7, #4]
 80094e0:	0018      	movs	r0, r3
 80094e2:	f000 f959 	bl	8009798 <ADC_Enable>
 80094e6:	0003      	movs	r3, r0
 80094e8:	7023      	strb	r3, [r4, #0]
    }
    
    /* Start conversion if ADC is effectively enabled */
    if (tmp_hal_status == HAL_OK)
 80094ea:	230f      	movs	r3, #15
 80094ec:	18fb      	adds	r3, r7, r3
 80094ee:	781b      	ldrb	r3, [r3, #0]
 80094f0:	2b00      	cmp	r3, #0
 80094f2:	d120      	bne.n	8009536 <HAL_ADC_Start+0x96>
    {
      /* Set ADC state                                                        */
      /* - Clear state bitfield related to regular group conversion results   */
      /* - Set state bitfield related to regular operation                    */
      ADC_STATE_CLR_SET(hadc->State,
 80094f4:	687b      	ldr	r3, [r7, #4]
 80094f6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80094f8:	4a12      	ldr	r2, [pc, #72]	; (8009544 <HAL_ADC_Start+0xa4>)
 80094fa:	4013      	ands	r3, r2
 80094fc:	2280      	movs	r2, #128	; 0x80
 80094fe:	0052      	lsls	r2, r2, #1
 8009500:	431a      	orrs	r2, r3
 8009502:	687b      	ldr	r3, [r7, #4]
 8009504:	655a      	str	r2, [r3, #84]	; 0x54
                        HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
                        HAL_ADC_STATE_REG_BUSY);
      
      /* Reset ADC all error code fields */
      ADC_CLEAR_ERRORCODE(hadc);
 8009506:	687b      	ldr	r3, [r7, #4]
 8009508:	2200      	movs	r2, #0
 800950a:	659a      	str	r2, [r3, #88]	; 0x58
      
      /* Process unlocked */
      /* Unlock before starting ADC conversions: in case of potential         */
      /* interruption, to let the process to ADC IRQ Handler.                 */
      __HAL_UNLOCK(hadc);
 800950c:	687b      	ldr	r3, [r7, #4]
 800950e:	2250      	movs	r2, #80	; 0x50
 8009510:	2100      	movs	r1, #0
 8009512:	5499      	strb	r1, [r3, r2]
      
      /* Clear regular group conversion flag and overrun flag */
      /* (To ensure of no unknown state from potential previous ADC           */
      /* operations)                                                          */
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8009514:	687b      	ldr	r3, [r7, #4]
 8009516:	681b      	ldr	r3, [r3, #0]
 8009518:	221c      	movs	r2, #28
 800951a:	601a      	str	r2, [r3, #0]
      
      /* Enable conversion of regular group.                                  */
      /* If software start has been selected, conversion starts immediately.  */
      /* If external trigger has been selected, conversion will start at next */
      /* trigger event.                                                       */
      hadc->Instance->CR |= ADC_CR_ADSTART;
 800951c:	687b      	ldr	r3, [r7, #4]
 800951e:	681b      	ldr	r3, [r3, #0]
 8009520:	689a      	ldr	r2, [r3, #8]
 8009522:	687b      	ldr	r3, [r7, #4]
 8009524:	681b      	ldr	r3, [r3, #0]
 8009526:	2104      	movs	r1, #4
 8009528:	430a      	orrs	r2, r1
 800952a:	609a      	str	r2, [r3, #8]
 800952c:	e003      	b.n	8009536 <HAL_ADC_Start+0x96>
    }
  }
  else
  {
    tmp_hal_status = HAL_BUSY;
 800952e:	230f      	movs	r3, #15
 8009530:	18fb      	adds	r3, r7, r3
 8009532:	2202      	movs	r2, #2
 8009534:	701a      	strb	r2, [r3, #0]
  }
  
  /* Return function status */
  return tmp_hal_status;
 8009536:	230f      	movs	r3, #15
 8009538:	18fb      	adds	r3, r7, r3
 800953a:	781b      	ldrb	r3, [r3, #0]
}
 800953c:	0018      	movs	r0, r3
 800953e:	46bd      	mov	sp, r7
 8009540:	b005      	add	sp, #20
 8009542:	bd90      	pop	{r4, r7, pc}
 8009544:	fffff0fe 	.word	0xfffff0fe

08009548 <HAL_ADC_PollForConversion>:
  * @param  hadc ADC handle
  * @param  Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
{
 8009548:	b580      	push	{r7, lr}
 800954a:	b084      	sub	sp, #16
 800954c:	af00      	add	r7, sp, #0
 800954e:	6078      	str	r0, [r7, #4]
 8009550:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
 8009552:	2300      	movs	r3, #0
 8009554:	60bb      	str	r3, [r7, #8]
  uint32_t tmp_Flag_EOC   = 0x00;
 8009556:	2300      	movs	r3, #0
 8009558:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 800955a:	687b      	ldr	r3, [r7, #4]
 800955c:	695b      	ldr	r3, [r3, #20]
 800955e:	2b08      	cmp	r3, #8
 8009560:	d102      	bne.n	8009568 <HAL_ADC_PollForConversion+0x20>
  {
    tmp_Flag_EOC = ADC_FLAG_EOS;
 8009562:	2308      	movs	r3, #8
 8009564:	60fb      	str	r3, [r7, #12]
 8009566:	e014      	b.n	8009592 <HAL_ADC_PollForConversion+0x4a>
    /* each conversion:                                                       */
    /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    /* several ranks and polling for end of each conversion.                  */
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
    if (HAL_IS_BIT_SET(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN))
 8009568:	687b      	ldr	r3, [r7, #4]
 800956a:	681b      	ldr	r3, [r3, #0]
 800956c:	68db      	ldr	r3, [r3, #12]
 800956e:	2201      	movs	r2, #1
 8009570:	4013      	ands	r3, r2
 8009572:	2b01      	cmp	r3, #1
 8009574:	d10b      	bne.n	800958e <HAL_ADC_PollForConversion+0x46>
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8009576:	687b      	ldr	r3, [r7, #4]
 8009578:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800957a:	2220      	movs	r2, #32
 800957c:	431a      	orrs	r2, r3
 800957e:	687b      	ldr	r3, [r7, #4]
 8009580:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Process unlocked */
      __HAL_UNLOCK(hadc);
 8009582:	687b      	ldr	r3, [r7, #4]
 8009584:	2250      	movs	r2, #80	; 0x50
 8009586:	2100      	movs	r1, #0
 8009588:	5499      	strb	r1, [r3, r2]
      
      return HAL_ERROR;
 800958a:	2301      	movs	r3, #1
 800958c:	e06c      	b.n	8009668 <HAL_ADC_PollForConversion+0x120>
    }
    else
    {
      tmp_Flag_EOC = (ADC_FLAG_EOC | ADC_FLAG_EOS);
 800958e:	230c      	movs	r3, #12
 8009590:	60fb      	str	r3, [r7, #12]
    }
  }
  
  /* Get tick count */
  tickstart = HAL_GetTick();
 8009592:	f7ff fdd5 	bl	8009140 <HAL_GetTick>
 8009596:	0003      	movs	r3, r0
 8009598:	60bb      	str	r3, [r7, #8]
  
  /* Wait until End of unitary conversion or sequence conversions flag is raised */
  while(HAL_IS_BIT_CLR(hadc->Instance->ISR, tmp_Flag_EOC))
 800959a:	e019      	b.n	80095d0 <HAL_ADC_PollForConversion+0x88>
  {
    /* Check if timeout is disabled (set to infinite wait) */
    if(Timeout != HAL_MAX_DELAY)
 800959c:	683b      	ldr	r3, [r7, #0]
 800959e:	3301      	adds	r3, #1
 80095a0:	d016      	beq.n	80095d0 <HAL_ADC_PollForConversion+0x88>
    {
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 80095a2:	683b      	ldr	r3, [r7, #0]
 80095a4:	2b00      	cmp	r3, #0
 80095a6:	d007      	beq.n	80095b8 <HAL_ADC_PollForConversion+0x70>
 80095a8:	f7ff fdca 	bl	8009140 <HAL_GetTick>
 80095ac:	0002      	movs	r2, r0
 80095ae:	68bb      	ldr	r3, [r7, #8]
 80095b0:	1ad3      	subs	r3, r2, r3
 80095b2:	683a      	ldr	r2, [r7, #0]
 80095b4:	429a      	cmp	r2, r3
 80095b6:	d20b      	bcs.n	80095d0 <HAL_ADC_PollForConversion+0x88>
      {
        /* Update ADC state machine to timeout */
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80095b8:	687b      	ldr	r3, [r7, #4]
 80095ba:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80095bc:	2204      	movs	r2, #4
 80095be:	431a      	orrs	r2, r3
 80095c0:	687b      	ldr	r3, [r7, #4]
 80095c2:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 80095c4:	687b      	ldr	r3, [r7, #4]
 80095c6:	2250      	movs	r2, #80	; 0x50
 80095c8:	2100      	movs	r1, #0
 80095ca:	5499      	strb	r1, [r3, r2]
        
        return HAL_TIMEOUT;
 80095cc:	2303      	movs	r3, #3
 80095ce:	e04b      	b.n	8009668 <HAL_ADC_PollForConversion+0x120>
  while(HAL_IS_BIT_CLR(hadc->Instance->ISR, tmp_Flag_EOC))
 80095d0:	687b      	ldr	r3, [r7, #4]
 80095d2:	681b      	ldr	r3, [r3, #0]
 80095d4:	681b      	ldr	r3, [r3, #0]
 80095d6:	68fa      	ldr	r2, [r7, #12]
 80095d8:	4013      	ands	r3, r2
 80095da:	d0df      	beq.n	800959c <HAL_ADC_PollForConversion+0x54>
      }
    }
  }
  
  /* Update ADC state machine */
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 80095dc:	687b      	ldr	r3, [r7, #4]
 80095de:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80095e0:	2280      	movs	r2, #128	; 0x80
 80095e2:	0092      	lsls	r2, r2, #2
 80095e4:	431a      	orrs	r2, r3
 80095e6:	687b      	ldr	r3, [r7, #4]
 80095e8:	655a      	str	r2, [r3, #84]	; 0x54
  
  /* Determine whether any further conversion upcoming on group regular       */
  /* by external trigger, continuous mode or scan sequence on going.          */
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80095ea:	687b      	ldr	r3, [r7, #4]
 80095ec:	681b      	ldr	r3, [r3, #0]
 80095ee:	68da      	ldr	r2, [r3, #12]
 80095f0:	23c0      	movs	r3, #192	; 0xc0
 80095f2:	011b      	lsls	r3, r3, #4
 80095f4:	4013      	ands	r3, r2
 80095f6:	d12e      	bne.n	8009656 <HAL_ADC_PollForConversion+0x10e>
     (hadc->Init.ContinuousConvMode == DISABLE)   )
 80095f8:	687b      	ldr	r3, [r7, #4]
 80095fa:	2220      	movs	r2, #32
 80095fc:	5c9b      	ldrb	r3, [r3, r2]
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80095fe:	2b00      	cmp	r3, #0
 8009600:	d129      	bne.n	8009656 <HAL_ADC_PollForConversion+0x10e>
  {
    /* If End of Sequence is reached, disable interrupts */
    if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
 8009602:	687b      	ldr	r3, [r7, #4]
 8009604:	681b      	ldr	r3, [r3, #0]
 8009606:	681b      	ldr	r3, [r3, #0]
 8009608:	2208      	movs	r2, #8
 800960a:	4013      	ands	r3, r2
 800960c:	2b08      	cmp	r3, #8
 800960e:	d122      	bne.n	8009656 <HAL_ADC_PollForConversion+0x10e>
    {
      /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit             */
      /* ADSTART==0 (no conversion on going)                                  */
      if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8009610:	687b      	ldr	r3, [r7, #4]
 8009612:	681b      	ldr	r3, [r3, #0]
 8009614:	689b      	ldr	r3, [r3, #8]
 8009616:	2204      	movs	r2, #4
 8009618:	4013      	ands	r3, r2
 800961a:	d110      	bne.n	800963e <HAL_ADC_PollForConversion+0xf6>
      {
        /* Disable ADC end of single conversion interrupt on group regular */
        /* Note: Overrun interrupt was enabled with EOC interrupt in          */
        /* HAL_Start_IT(), but is not disabled here because can be used       */
        /* by overrun IRQ process below.                                      */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 800961c:	687b      	ldr	r3, [r7, #4]
 800961e:	681b      	ldr	r3, [r3, #0]
 8009620:	685a      	ldr	r2, [r3, #4]
 8009622:	687b      	ldr	r3, [r7, #4]
 8009624:	681b      	ldr	r3, [r3, #0]
 8009626:	210c      	movs	r1, #12
 8009628:	438a      	bics	r2, r1
 800962a:	605a      	str	r2, [r3, #4]
        
        /* Set ADC state */
        ADC_STATE_CLR_SET(hadc->State,
 800962c:	687b      	ldr	r3, [r7, #4]
 800962e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009630:	4a0f      	ldr	r2, [pc, #60]	; (8009670 <HAL_ADC_PollForConversion+0x128>)
 8009632:	4013      	ands	r3, r2
 8009634:	2201      	movs	r2, #1
 8009636:	431a      	orrs	r2, r3
 8009638:	687b      	ldr	r3, [r7, #4]
 800963a:	655a      	str	r2, [r3, #84]	; 0x54
 800963c:	e00b      	b.n	8009656 <HAL_ADC_PollForConversion+0x10e>
                          HAL_ADC_STATE_READY);
      }
      else
      {
        /* Change ADC state to error state */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800963e:	687b      	ldr	r3, [r7, #4]
 8009640:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009642:	2220      	movs	r2, #32
 8009644:	431a      	orrs	r2, r3
 8009646:	687b      	ldr	r3, [r7, #4]
 8009648:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Set ADC error code to ADC peripheral internal error */
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800964a:	687b      	ldr	r3, [r7, #4]
 800964c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800964e:	2201      	movs	r2, #1
 8009650:	431a      	orrs	r2, r3
 8009652:	687b      	ldr	r3, [r7, #4]
 8009654:	659a      	str	r2, [r3, #88]	; 0x58
  }
  
  /* Clear end of conversion flag of regular group if low power feature       */
  /* "LowPowerAutoWait " is disabled, to not interfere with this feature      */
  /* until data register is read using function HAL_ADC_GetValue().           */
  if (hadc->Init.LowPowerAutoWait == DISABLE)
 8009656:	687b      	ldr	r3, [r7, #4]
 8009658:	699b      	ldr	r3, [r3, #24]
 800965a:	2b00      	cmp	r3, #0
 800965c:	d103      	bne.n	8009666 <HAL_ADC_PollForConversion+0x11e>
  {
    /* Clear regular group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 800965e:	687b      	ldr	r3, [r7, #4]
 8009660:	681b      	ldr	r3, [r3, #0]
 8009662:	220c      	movs	r2, #12
 8009664:	601a      	str	r2, [r3, #0]
  }
  
  /* Return function status */
  return HAL_OK;
 8009666:	2300      	movs	r3, #0
}
 8009668:	0018      	movs	r0, r3
 800966a:	46bd      	mov	sp, r7
 800966c:	b004      	add	sp, #16
 800966e:	bd80      	pop	{r7, pc}
 8009670:	fffffefe 	.word	0xfffffefe

08009674 <HAL_ADC_GetValue>:
  *         or @ref __HAL_ADC_CLEAR_FLAG(&hadc, ADC_FLAG_EOS).
  * @param  hadc ADC handle
  * @retval ADC group regular conversion data
  */
uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
{
 8009674:	b580      	push	{r7, lr}
 8009676:	b082      	sub	sp, #8
 8009678:	af00      	add	r7, sp, #0
 800967a:	6078      	str	r0, [r7, #4]

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */
  
  /* Return ADC converted value */ 
  return hadc->Instance->DR;
 800967c:	687b      	ldr	r3, [r7, #4]
 800967e:	681b      	ldr	r3, [r3, #0]
 8009680:	6c1b      	ldr	r3, [r3, #64]	; 0x40
}
 8009682:	0018      	movs	r0, r3
 8009684:	46bd      	mov	sp, r7
 8009686:	b002      	add	sp, #8
 8009688:	bd80      	pop	{r7, pc}
	...

0800968c <HAL_ADC_ConfigChannel>:
  * @param  hadc ADC handle
  * @param  sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 800968c:	b580      	push	{r7, lr}
 800968e:	b082      	sub	sp, #8
 8009690:	af00      	add	r7, sp, #0
 8009692:	6078      	str	r0, [r7, #4]
 8009694:	6039      	str	r1, [r7, #0]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_RANK(sConfig->Rank));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8009696:	687b      	ldr	r3, [r7, #4]
 8009698:	2250      	movs	r2, #80	; 0x50
 800969a:	5c9b      	ldrb	r3, [r3, r2]
 800969c:	2b01      	cmp	r3, #1
 800969e:	d101      	bne.n	80096a4 <HAL_ADC_ConfigChannel+0x18>
 80096a0:	2302      	movs	r3, #2
 80096a2:	e06c      	b.n	800977e <HAL_ADC_ConfigChannel+0xf2>
 80096a4:	687b      	ldr	r3, [r7, #4]
 80096a6:	2250      	movs	r2, #80	; 0x50
 80096a8:	2101      	movs	r1, #1
 80096aa:	5499      	strb	r1, [r3, r2]
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Management of internal measurement channels: Vbat/VrefInt/TempSensor  */
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) != RESET)
 80096ac:	687b      	ldr	r3, [r7, #4]
 80096ae:	681b      	ldr	r3, [r3, #0]
 80096b0:	689b      	ldr	r3, [r3, #8]
 80096b2:	2204      	movs	r2, #4
 80096b4:	4013      	ands	r3, r2
 80096b6:	d00b      	beq.n	80096d0 <HAL_ADC_ConfigChannel+0x44>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80096b8:	687b      	ldr	r3, [r7, #4]
 80096ba:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80096bc:	2220      	movs	r2, #32
 80096be:	431a      	orrs	r2, r3
 80096c0:	687b      	ldr	r3, [r7, #4]
 80096c2:	655a      	str	r2, [r3, #84]	; 0x54
    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 80096c4:	687b      	ldr	r3, [r7, #4]
 80096c6:	2250      	movs	r2, #80	; 0x50
 80096c8:	2100      	movs	r1, #0
 80096ca:	5499      	strb	r1, [r3, r2]
    return HAL_ERROR;
 80096cc:	2301      	movs	r3, #1
 80096ce:	e056      	b.n	800977e <HAL_ADC_ConfigChannel+0xf2>
  }
  
  if (sConfig->Rank != ADC_RANK_NONE)
 80096d0:	683b      	ldr	r3, [r7, #0]
 80096d2:	685b      	ldr	r3, [r3, #4]
 80096d4:	4a2c      	ldr	r2, [pc, #176]	; (8009788 <HAL_ADC_ConfigChannel+0xfc>)
 80096d6:	4293      	cmp	r3, r2
 80096d8:	d028      	beq.n	800972c <HAL_ADC_ConfigChannel+0xa0>
  {
    /* Enable selected channels */
    hadc->Instance->CHSELR |= (uint32_t)(sConfig->Channel & ADC_CHANNEL_MASK);
 80096da:	687b      	ldr	r3, [r7, #4]
 80096dc:	681b      	ldr	r3, [r3, #0]
 80096de:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80096e0:	683b      	ldr	r3, [r7, #0]
 80096e2:	681b      	ldr	r3, [r3, #0]
 80096e4:	035b      	lsls	r3, r3, #13
 80096e6:	0b5a      	lsrs	r2, r3, #13
 80096e8:	687b      	ldr	r3, [r7, #4]
 80096ea:	681b      	ldr	r3, [r3, #0]
 80096ec:	430a      	orrs	r2, r1
 80096ee:	629a      	str	r2, [r3, #40]	; 0x28
    /* dedicated internal buffers and path.                                     */
    
    #if defined(ADC_CCR_TSEN)
    /* If Temperature sensor channel is selected, then enable the internal      */
    /* buffers and path  */
    if (((sConfig->Channel & ADC_CHANNEL_MASK) & ADC_CHANNEL_TEMPSENSOR ) == (ADC_CHANNEL_TEMPSENSOR & ADC_CHANNEL_MASK))
 80096f0:	683b      	ldr	r3, [r7, #0]
 80096f2:	681a      	ldr	r2, [r3, #0]
 80096f4:	2380      	movs	r3, #128	; 0x80
 80096f6:	02db      	lsls	r3, r3, #11
 80096f8:	4013      	ands	r3, r2
 80096fa:	d009      	beq.n	8009710 <HAL_ADC_ConfigChannel+0x84>
    {
      ADC->CCR |= ADC_CCR_TSEN;   
 80096fc:	4b23      	ldr	r3, [pc, #140]	; (800978c <HAL_ADC_ConfigChannel+0x100>)
 80096fe:	681a      	ldr	r2, [r3, #0]
 8009700:	4b22      	ldr	r3, [pc, #136]	; (800978c <HAL_ADC_ConfigChannel+0x100>)
 8009702:	2180      	movs	r1, #128	; 0x80
 8009704:	0409      	lsls	r1, r1, #16
 8009706:	430a      	orrs	r2, r1
 8009708:	601a      	str	r2, [r3, #0]
      
      /* Delay for temperature sensor stabilization time */
      ADC_DelayMicroSecond(ADC_TEMPSENSOR_DELAY_US);
 800970a:	200a      	movs	r0, #10
 800970c:	f000 f8a4 	bl	8009858 <ADC_DelayMicroSecond>
    }
    #endif
    
    /* If VRefInt channel is selected, then enable the internal buffers and path   */
    if (((sConfig->Channel & ADC_CHANNEL_MASK) & ADC_CHANNEL_VREFINT) == (ADC_CHANNEL_VREFINT & ADC_CHANNEL_MASK))
 8009710:	683b      	ldr	r3, [r7, #0]
 8009712:	681a      	ldr	r2, [r3, #0]
 8009714:	2380      	movs	r3, #128	; 0x80
 8009716:	029b      	lsls	r3, r3, #10
 8009718:	4013      	ands	r3, r2
 800971a:	d02b      	beq.n	8009774 <HAL_ADC_ConfigChannel+0xe8>
    {
      ADC->CCR |= ADC_CCR_VREFEN;   
 800971c:	4b1b      	ldr	r3, [pc, #108]	; (800978c <HAL_ADC_ConfigChannel+0x100>)
 800971e:	681a      	ldr	r2, [r3, #0]
 8009720:	4b1a      	ldr	r3, [pc, #104]	; (800978c <HAL_ADC_ConfigChannel+0x100>)
 8009722:	2180      	movs	r1, #128	; 0x80
 8009724:	03c9      	lsls	r1, r1, #15
 8009726:	430a      	orrs	r2, r1
 8009728:	601a      	str	r2, [r3, #0]
 800972a:	e023      	b.n	8009774 <HAL_ADC_ConfigChannel+0xe8>
  }
  else
  {
    /* Regular sequence configuration */
    /* Reset the channel selection register from the selected channel */
    hadc->Instance->CHSELR &= ~((uint32_t)(sConfig->Channel & ADC_CHANNEL_MASK));
 800972c:	687b      	ldr	r3, [r7, #4]
 800972e:	681b      	ldr	r3, [r3, #0]
 8009730:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8009732:	683b      	ldr	r3, [r7, #0]
 8009734:	681b      	ldr	r3, [r3, #0]
 8009736:	035b      	lsls	r3, r3, #13
 8009738:	0b5b      	lsrs	r3, r3, #13
 800973a:	43d9      	mvns	r1, r3
 800973c:	687b      	ldr	r3, [r7, #4]
 800973e:	681b      	ldr	r3, [r3, #0]
 8009740:	400a      	ands	r2, r1
 8009742:	629a      	str	r2, [r3, #40]	; 0x28
    
    /* Management of internal measurement channels: VrefInt/TempSensor/Vbat */
    /* internal measurement paths disable: If internal channel selected,    */
    /* disable dedicated internal buffers and path.                         */
    #if defined(ADC_CCR_TSEN)
    if (((sConfig->Channel & ADC_CHANNEL_MASK) & ADC_CHANNEL_TEMPSENSOR ) == (ADC_CHANNEL_TEMPSENSOR & ADC_CHANNEL_MASK))
 8009744:	683b      	ldr	r3, [r7, #0]
 8009746:	681a      	ldr	r2, [r3, #0]
 8009748:	2380      	movs	r3, #128	; 0x80
 800974a:	02db      	lsls	r3, r3, #11
 800974c:	4013      	ands	r3, r2
 800974e:	d005      	beq.n	800975c <HAL_ADC_ConfigChannel+0xd0>
    {
      ADC->CCR &= ~ADC_CCR_TSEN;   
 8009750:	4b0e      	ldr	r3, [pc, #56]	; (800978c <HAL_ADC_ConfigChannel+0x100>)
 8009752:	681a      	ldr	r2, [r3, #0]
 8009754:	4b0d      	ldr	r3, [pc, #52]	; (800978c <HAL_ADC_ConfigChannel+0x100>)
 8009756:	490e      	ldr	r1, [pc, #56]	; (8009790 <HAL_ADC_ConfigChannel+0x104>)
 8009758:	400a      	ands	r2, r1
 800975a:	601a      	str	r2, [r3, #0]
    }
    #endif
    
    /* If VRefInt channel is selected, then enable the internal buffers and path   */
    if (((sConfig->Channel & ADC_CHANNEL_MASK) & ADC_CHANNEL_VREFINT) == (ADC_CHANNEL_VREFINT & ADC_CHANNEL_MASK))
 800975c:	683b      	ldr	r3, [r7, #0]
 800975e:	681a      	ldr	r2, [r3, #0]
 8009760:	2380      	movs	r3, #128	; 0x80
 8009762:	029b      	lsls	r3, r3, #10
 8009764:	4013      	ands	r3, r2
 8009766:	d005      	beq.n	8009774 <HAL_ADC_ConfigChannel+0xe8>
    {
      ADC->CCR &= ~ADC_CCR_VREFEN;   
 8009768:	4b08      	ldr	r3, [pc, #32]	; (800978c <HAL_ADC_ConfigChannel+0x100>)
 800976a:	681a      	ldr	r2, [r3, #0]
 800976c:	4b07      	ldr	r3, [pc, #28]	; (800978c <HAL_ADC_ConfigChannel+0x100>)
 800976e:	4909      	ldr	r1, [pc, #36]	; (8009794 <HAL_ADC_ConfigChannel+0x108>)
 8009770:	400a      	ands	r2, r1
 8009772:	601a      	str	r2, [r3, #0]
    }
#endif
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8009774:	687b      	ldr	r3, [r7, #4]
 8009776:	2250      	movs	r2, #80	; 0x50
 8009778:	2100      	movs	r1, #0
 800977a:	5499      	strb	r1, [r3, r2]
  
  /* Return function status */
  return HAL_OK;
 800977c:	2300      	movs	r3, #0
}
 800977e:	0018      	movs	r0, r3
 8009780:	46bd      	mov	sp, r7
 8009782:	b002      	add	sp, #8
 8009784:	bd80      	pop	{r7, pc}
 8009786:	46c0      	nop			; (mov r8, r8)
 8009788:	00001001 	.word	0x00001001
 800978c:	40012708 	.word	0x40012708
 8009790:	ff7fffff 	.word	0xff7fffff
 8009794:	ffbfffff 	.word	0xffbfffff

08009798 <ADC_Enable>:
  *         "if (hadc->Init.LowPowerAutoPowerOff != ENABLE)".
  * @param  hadc ADC handle
  * @retval HAL status.
  */
static HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
{
 8009798:	b580      	push	{r7, lr}
 800979a:	b084      	sub	sp, #16
 800979c:	af00      	add	r7, sp, #0
 800979e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 80097a0:	2300      	movs	r3, #0
 80097a2:	60fb      	str	r3, [r7, #12]

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (ADC_IS_ENABLE(hadc) == RESET)
 80097a4:	687b      	ldr	r3, [r7, #4]
 80097a6:	681b      	ldr	r3, [r3, #0]
 80097a8:	689b      	ldr	r3, [r3, #8]
 80097aa:	2203      	movs	r2, #3
 80097ac:	4013      	ands	r3, r2
 80097ae:	2b01      	cmp	r3, #1
 80097b0:	d108      	bne.n	80097c4 <ADC_Enable+0x2c>
 80097b2:	687b      	ldr	r3, [r7, #4]
 80097b4:	681b      	ldr	r3, [r3, #0]
 80097b6:	681b      	ldr	r3, [r3, #0]
 80097b8:	2201      	movs	r2, #1
 80097ba:	4013      	ands	r3, r2
 80097bc:	2b01      	cmp	r3, #1
 80097be:	d101      	bne.n	80097c4 <ADC_Enable+0x2c>
 80097c0:	2301      	movs	r3, #1
 80097c2:	e000      	b.n	80097c6 <ADC_Enable+0x2e>
 80097c4:	2300      	movs	r3, #0
 80097c6:	2b00      	cmp	r3, #0
 80097c8:	d13f      	bne.n	800984a <ADC_Enable+0xb2>
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if (ADC_ENABLING_CONDITIONS(hadc) == RESET)
 80097ca:	687b      	ldr	r3, [r7, #4]
 80097cc:	681b      	ldr	r3, [r3, #0]
 80097ce:	689b      	ldr	r3, [r3, #8]
 80097d0:	4a20      	ldr	r2, [pc, #128]	; (8009854 <ADC_Enable+0xbc>)
 80097d2:	4013      	ands	r3, r2
 80097d4:	d00d      	beq.n	80097f2 <ADC_Enable+0x5a>
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80097d6:	687b      	ldr	r3, [r7, #4]
 80097d8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80097da:	2210      	movs	r2, #16
 80097dc:	431a      	orrs	r2, r3
 80097de:	687b      	ldr	r3, [r7, #4]
 80097e0:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80097e2:	687b      	ldr	r3, [r7, #4]
 80097e4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80097e6:	2201      	movs	r2, #1
 80097e8:	431a      	orrs	r2, r3
 80097ea:	687b      	ldr	r3, [r7, #4]
 80097ec:	659a      	str	r2, [r3, #88]	; 0x58
      
      return HAL_ERROR;
 80097ee:	2301      	movs	r3, #1
 80097f0:	e02c      	b.n	800984c <ADC_Enable+0xb4>
    }
    
    /* Enable the ADC peripheral */
    __HAL_ADC_ENABLE(hadc);
 80097f2:	687b      	ldr	r3, [r7, #4]
 80097f4:	681b      	ldr	r3, [r3, #0]
 80097f6:	689a      	ldr	r2, [r3, #8]
 80097f8:	687b      	ldr	r3, [r7, #4]
 80097fa:	681b      	ldr	r3, [r3, #0]
 80097fc:	2101      	movs	r1, #1
 80097fe:	430a      	orrs	r2, r1
 8009800:	609a      	str	r2, [r3, #8]
    
    /* Delay for ADC stabilization time. */
    ADC_DelayMicroSecond(ADC_STAB_DELAY_US);
 8009802:	2001      	movs	r0, #1
 8009804:	f000 f828 	bl	8009858 <ADC_DelayMicroSecond>

    /* Get tick count */
    tickstart = HAL_GetTick();
 8009808:	f7ff fc9a 	bl	8009140 <HAL_GetTick>
 800980c:	0003      	movs	r3, r0
 800980e:	60fb      	str	r3, [r7, #12]
    
    /* Wait for ADC effectively enabled */
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 8009810:	e014      	b.n	800983c <ADC_Enable+0xa4>
    {
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8009812:	f7ff fc95 	bl	8009140 <HAL_GetTick>
 8009816:	0002      	movs	r2, r0
 8009818:	68fb      	ldr	r3, [r7, #12]
 800981a:	1ad3      	subs	r3, r2, r3
 800981c:	2b0a      	cmp	r3, #10
 800981e:	d90d      	bls.n	800983c <ADC_Enable+0xa4>
      {
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8009820:	687b      	ldr	r3, [r7, #4]
 8009822:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009824:	2210      	movs	r2, #16
 8009826:	431a      	orrs	r2, r3
 8009828:	687b      	ldr	r3, [r7, #4]
 800982a:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Set ADC error code to ADC peripheral internal error */
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800982c:	687b      	ldr	r3, [r7, #4]
 800982e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009830:	2201      	movs	r2, #1
 8009832:	431a      	orrs	r2, r3
 8009834:	687b      	ldr	r3, [r7, #4]
 8009836:	659a      	str	r2, [r3, #88]	; 0x58
        
        return HAL_ERROR;
 8009838:	2301      	movs	r3, #1
 800983a:	e007      	b.n	800984c <ADC_Enable+0xb4>
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 800983c:	687b      	ldr	r3, [r7, #4]
 800983e:	681b      	ldr	r3, [r3, #0]
 8009840:	681b      	ldr	r3, [r3, #0]
 8009842:	2201      	movs	r2, #1
 8009844:	4013      	ands	r3, r2
 8009846:	2b01      	cmp	r3, #1
 8009848:	d1e3      	bne.n	8009812 <ADC_Enable+0x7a>
      }
    }
  }
   
  /* Return HAL status */
  return HAL_OK;
 800984a:	2300      	movs	r3, #0
}
 800984c:	0018      	movs	r0, r3
 800984e:	46bd      	mov	sp, r7
 8009850:	b004      	add	sp, #16
 8009852:	bd80      	pop	{r7, pc}
 8009854:	80000017 	.word	0x80000017

08009858 <ADC_DelayMicroSecond>:
  * @brief  Delay micro seconds 
  * @param  microSecond  delay
  * @retval None
  */
static void ADC_DelayMicroSecond(uint32_t microSecond)
{
 8009858:	b580      	push	{r7, lr}
 800985a:	b084      	sub	sp, #16
 800985c:	af00      	add	r7, sp, #0
 800985e:	6078      	str	r0, [r7, #4]
  /* Compute number of CPU cycles to wait for */
  __IO uint32_t waitLoopIndex = (microSecond * (SystemCoreClock / 1000000U));
 8009860:	4b0b      	ldr	r3, [pc, #44]	; (8009890 <ADC_DelayMicroSecond+0x38>)
 8009862:	681b      	ldr	r3, [r3, #0]
 8009864:	490b      	ldr	r1, [pc, #44]	; (8009894 <ADC_DelayMicroSecond+0x3c>)
 8009866:	0018      	movs	r0, r3
 8009868:	f7f6 fc58 	bl	800011c <__udivsi3>
 800986c:	0003      	movs	r3, r0
 800986e:	001a      	movs	r2, r3
 8009870:	687b      	ldr	r3, [r7, #4]
 8009872:	4353      	muls	r3, r2
 8009874:	60fb      	str	r3, [r7, #12]

  while(waitLoopIndex != 0U)
 8009876:	e002      	b.n	800987e <ADC_DelayMicroSecond+0x26>
  {
    waitLoopIndex--;
 8009878:	68fb      	ldr	r3, [r7, #12]
 800987a:	3b01      	subs	r3, #1
 800987c:	60fb      	str	r3, [r7, #12]
  while(waitLoopIndex != 0U)
 800987e:	68fb      	ldr	r3, [r7, #12]
 8009880:	2b00      	cmp	r3, #0
 8009882:	d1f9      	bne.n	8009878 <ADC_DelayMicroSecond+0x20>
  } 
}
 8009884:	46c0      	nop			; (mov r8, r8)
 8009886:	46c0      	nop			; (mov r8, r8)
 8009888:	46bd      	mov	sp, r7
 800988a:	b004      	add	sp, #16
 800988c:	bd80      	pop	{r7, pc}
 800988e:	46c0      	nop			; (mov r8, r8)
 8009890:	20000188 	.word	0x20000188
 8009894:	000f4240 	.word	0x000f4240

08009898 <HAL_ADCEx_Calibration_Start>:
  *          This parameter can be only of the following values:
  *            @arg ADC_SINGLE_ENDED: Channel in mode input single ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc, uint32_t SingleDiff)
{
 8009898:	b580      	push	{r7, lr}
 800989a:	b086      	sub	sp, #24
 800989c:	af00      	add	r7, sp, #0
 800989e:	6078      	str	r0, [r7, #4]
 80098a0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80098a2:	2317      	movs	r3, #23
 80098a4:	18fb      	adds	r3, r7, r3
 80098a6:	2200      	movs	r2, #0
 80098a8:	701a      	strb	r2, [r3, #0]
  uint32_t tickstart = 0U;
 80098aa:	2300      	movs	r3, #0
 80098ac:	613b      	str	r3, [r7, #16]
  uint32_t backup_setting_adc_dma_transfer = 0U; /* Note: Variable not declared as volatile because register read is already declared as volatile */
 80098ae:	2300      	movs	r3, #0
 80098b0:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
 80098b2:	687b      	ldr	r3, [r7, #4]
 80098b4:	2250      	movs	r2, #80	; 0x50
 80098b6:	5c9b      	ldrb	r3, [r3, r2]
 80098b8:	2b01      	cmp	r3, #1
 80098ba:	d101      	bne.n	80098c0 <HAL_ADCEx_Calibration_Start+0x28>
 80098bc:	2302      	movs	r3, #2
 80098be:	e07a      	b.n	80099b6 <HAL_ADCEx_Calibration_Start+0x11e>
 80098c0:	687b      	ldr	r3, [r7, #4]
 80098c2:	2250      	movs	r2, #80	; 0x50
 80098c4:	2101      	movs	r1, #1
 80098c6:	5499      	strb	r1, [r3, r2]
  
  /* Calibration prerequisite: ADC must be disabled. */
  if (ADC_IS_ENABLE(hadc) == RESET)
 80098c8:	687b      	ldr	r3, [r7, #4]
 80098ca:	681b      	ldr	r3, [r3, #0]
 80098cc:	689b      	ldr	r3, [r3, #8]
 80098ce:	2203      	movs	r2, #3
 80098d0:	4013      	ands	r3, r2
 80098d2:	2b01      	cmp	r3, #1
 80098d4:	d108      	bne.n	80098e8 <HAL_ADCEx_Calibration_Start+0x50>
 80098d6:	687b      	ldr	r3, [r7, #4]
 80098d8:	681b      	ldr	r3, [r3, #0]
 80098da:	681b      	ldr	r3, [r3, #0]
 80098dc:	2201      	movs	r2, #1
 80098de:	4013      	ands	r3, r2
 80098e0:	2b01      	cmp	r3, #1
 80098e2:	d101      	bne.n	80098e8 <HAL_ADCEx_Calibration_Start+0x50>
 80098e4:	2301      	movs	r3, #1
 80098e6:	e000      	b.n	80098ea <HAL_ADCEx_Calibration_Start+0x52>
 80098e8:	2300      	movs	r3, #0
 80098ea:	2b00      	cmp	r3, #0
 80098ec:	d152      	bne.n	8009994 <HAL_ADCEx_Calibration_Start+0xfc>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State, 
 80098ee:	687b      	ldr	r3, [r7, #4]
 80098f0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80098f2:	4a33      	ldr	r2, [pc, #204]	; (80099c0 <HAL_ADCEx_Calibration_Start+0x128>)
 80098f4:	4013      	ands	r3, r2
 80098f6:	2202      	movs	r2, #2
 80098f8:	431a      	orrs	r2, r3
 80098fa:	687b      	ldr	r3, [r7, #4]
 80098fc:	655a      	str	r2, [r3, #84]	; 0x54
    /* Note: Specificity of this STM32 serie: Calibration factor is           */
    /*       available in data register and also transfered by DMA.           */
    /*       To not insert ADC calibration factor among ADC conversion data   */
    /*       in array variable, DMA transfer must be disabled during          */
    /*       calibration.                                                     */
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 80098fe:	687b      	ldr	r3, [r7, #4]
 8009900:	681b      	ldr	r3, [r3, #0]
 8009902:	68db      	ldr	r3, [r3, #12]
 8009904:	2203      	movs	r2, #3
 8009906:	4013      	ands	r3, r2
 8009908:	60fb      	str	r3, [r7, #12]
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 800990a:	687b      	ldr	r3, [r7, #4]
 800990c:	681b      	ldr	r3, [r3, #0]
 800990e:	68da      	ldr	r2, [r3, #12]
 8009910:	687b      	ldr	r3, [r7, #4]
 8009912:	681b      	ldr	r3, [r3, #0]
 8009914:	2103      	movs	r1, #3
 8009916:	438a      	bics	r2, r1
 8009918:	60da      	str	r2, [r3, #12]
    
    /* Start ADC calibration */
    hadc->Instance->CR |= ADC_CR_ADCAL;
 800991a:	687b      	ldr	r3, [r7, #4]
 800991c:	681b      	ldr	r3, [r3, #0]
 800991e:	689a      	ldr	r2, [r3, #8]
 8009920:	687b      	ldr	r3, [r7, #4]
 8009922:	681b      	ldr	r3, [r3, #0]
 8009924:	2180      	movs	r1, #128	; 0x80
 8009926:	0609      	lsls	r1, r1, #24
 8009928:	430a      	orrs	r2, r1
 800992a:	609a      	str	r2, [r3, #8]
    
    tickstart = HAL_GetTick();  
 800992c:	f7ff fc08 	bl	8009140 <HAL_GetTick>
 8009930:	0003      	movs	r3, r0
 8009932:	613b      	str	r3, [r7, #16]
    
    /* Wait for calibration completion */
    while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADCAL))
 8009934:	e014      	b.n	8009960 <HAL_ADCEx_Calibration_Start+0xc8>
    {
      if((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
 8009936:	f7ff fc03 	bl	8009140 <HAL_GetTick>
 800993a:	0002      	movs	r2, r0
 800993c:	693b      	ldr	r3, [r7, #16]
 800993e:	1ad3      	subs	r3, r2, r3
 8009940:	2b0a      	cmp	r3, #10
 8009942:	d90d      	bls.n	8009960 <HAL_ADCEx_Calibration_Start+0xc8>
      {
        /* Update ADC state machine to error */
        ADC_STATE_CLR_SET(hadc->State,
 8009944:	687b      	ldr	r3, [r7, #4]
 8009946:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009948:	2212      	movs	r2, #18
 800994a:	4393      	bics	r3, r2
 800994c:	2210      	movs	r2, #16
 800994e:	431a      	orrs	r2, r3
 8009950:	687b      	ldr	r3, [r7, #4]
 8009952:	655a      	str	r2, [r3, #84]	; 0x54
                          HAL_ADC_STATE_BUSY_INTERNAL,
                          HAL_ADC_STATE_ERROR_INTERNAL);
        
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 8009954:	687b      	ldr	r3, [r7, #4]
 8009956:	2250      	movs	r2, #80	; 0x50
 8009958:	2100      	movs	r1, #0
 800995a:	5499      	strb	r1, [r3, r2]
        
        return HAL_ERROR;
 800995c:	2301      	movs	r3, #1
 800995e:	e02a      	b.n	80099b6 <HAL_ADCEx_Calibration_Start+0x11e>
    while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADCAL))
 8009960:	687b      	ldr	r3, [r7, #4]
 8009962:	681b      	ldr	r3, [r3, #0]
 8009964:	689b      	ldr	r3, [r3, #8]
 8009966:	0fdb      	lsrs	r3, r3, #31
 8009968:	07da      	lsls	r2, r3, #31
 800996a:	2380      	movs	r3, #128	; 0x80
 800996c:	061b      	lsls	r3, r3, #24
 800996e:	429a      	cmp	r2, r3
 8009970:	d0e1      	beq.n	8009936 <HAL_ADCEx_Calibration_Start+0x9e>
      }
    }
    
    /* Restore ADC DMA transfer request after calibration */
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 8009972:	687b      	ldr	r3, [r7, #4]
 8009974:	681b      	ldr	r3, [r3, #0]
 8009976:	68d9      	ldr	r1, [r3, #12]
 8009978:	687b      	ldr	r3, [r7, #4]
 800997a:	681b      	ldr	r3, [r3, #0]
 800997c:	68fa      	ldr	r2, [r7, #12]
 800997e:	430a      	orrs	r2, r1
 8009980:	60da      	str	r2, [r3, #12]
    
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8009982:	687b      	ldr	r3, [r7, #4]
 8009984:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009986:	2203      	movs	r2, #3
 8009988:	4393      	bics	r3, r2
 800998a:	2201      	movs	r2, #1
 800998c:	431a      	orrs	r2, r3
 800998e:	687b      	ldr	r3, [r7, #4]
 8009990:	655a      	str	r2, [r3, #84]	; 0x54
 8009992:	e009      	b.n	80099a8 <HAL_ADCEx_Calibration_Start+0x110>
                      HAL_ADC_STATE_READY);
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8009994:	687b      	ldr	r3, [r7, #4]
 8009996:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009998:	2220      	movs	r2, #32
 800999a:	431a      	orrs	r2, r3
 800999c:	687b      	ldr	r3, [r7, #4]
 800999e:	655a      	str	r2, [r3, #84]	; 0x54
    
    tmp_hal_status = HAL_ERROR;
 80099a0:	2317      	movs	r3, #23
 80099a2:	18fb      	adds	r3, r7, r3
 80099a4:	2201      	movs	r2, #1
 80099a6:	701a      	strb	r2, [r3, #0]
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80099a8:	687b      	ldr	r3, [r7, #4]
 80099aa:	2250      	movs	r2, #80	; 0x50
 80099ac:	2100      	movs	r1, #0
 80099ae:	5499      	strb	r1, [r3, r2]
  
  /* Return function status */
  return tmp_hal_status;
 80099b0:	2317      	movs	r3, #23
 80099b2:	18fb      	adds	r3, r7, r3
 80099b4:	781b      	ldrb	r3, [r3, #0]
}
 80099b6:	0018      	movs	r0, r3
 80099b8:	46bd      	mov	sp, r7
 80099ba:	b006      	add	sp, #24
 80099bc:	bd80      	pop	{r7, pc}
 80099be:	46c0      	nop			; (mov r8, r8)
 80099c0:	fffffefd 	.word	0xfffffefd

080099c4 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80099c4:	b580      	push	{r7, lr}
 80099c6:	b082      	sub	sp, #8
 80099c8:	af00      	add	r7, sp, #0
 80099ca:	0002      	movs	r2, r0
 80099cc:	1dfb      	adds	r3, r7, #7
 80099ce:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 80099d0:	1dfb      	adds	r3, r7, #7
 80099d2:	781b      	ldrb	r3, [r3, #0]
 80099d4:	2b7f      	cmp	r3, #127	; 0x7f
 80099d6:	d809      	bhi.n	80099ec <__NVIC_EnableIRQ+0x28>
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80099d8:	1dfb      	adds	r3, r7, #7
 80099da:	781b      	ldrb	r3, [r3, #0]
 80099dc:	001a      	movs	r2, r3
 80099de:	231f      	movs	r3, #31
 80099e0:	401a      	ands	r2, r3
 80099e2:	4b04      	ldr	r3, [pc, #16]	; (80099f4 <__NVIC_EnableIRQ+0x30>)
 80099e4:	2101      	movs	r1, #1
 80099e6:	4091      	lsls	r1, r2
 80099e8:	000a      	movs	r2, r1
 80099ea:	601a      	str	r2, [r3, #0]
  }
}
 80099ec:	46c0      	nop			; (mov r8, r8)
 80099ee:	46bd      	mov	sp, r7
 80099f0:	b002      	add	sp, #8
 80099f2:	bd80      	pop	{r7, pc}
 80099f4:	e000e100 	.word	0xe000e100

080099f8 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80099f8:	b590      	push	{r4, r7, lr}
 80099fa:	b083      	sub	sp, #12
 80099fc:	af00      	add	r7, sp, #0
 80099fe:	0002      	movs	r2, r0
 8009a00:	6039      	str	r1, [r7, #0]
 8009a02:	1dfb      	adds	r3, r7, #7
 8009a04:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 8009a06:	1dfb      	adds	r3, r7, #7
 8009a08:	781b      	ldrb	r3, [r3, #0]
 8009a0a:	2b7f      	cmp	r3, #127	; 0x7f
 8009a0c:	d828      	bhi.n	8009a60 <__NVIC_SetPriority+0x68>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8009a0e:	4a2f      	ldr	r2, [pc, #188]	; (8009acc <__NVIC_SetPriority+0xd4>)
 8009a10:	1dfb      	adds	r3, r7, #7
 8009a12:	781b      	ldrb	r3, [r3, #0]
 8009a14:	b25b      	sxtb	r3, r3
 8009a16:	089b      	lsrs	r3, r3, #2
 8009a18:	33c0      	adds	r3, #192	; 0xc0
 8009a1a:	009b      	lsls	r3, r3, #2
 8009a1c:	589b      	ldr	r3, [r3, r2]
 8009a1e:	1dfa      	adds	r2, r7, #7
 8009a20:	7812      	ldrb	r2, [r2, #0]
 8009a22:	0011      	movs	r1, r2
 8009a24:	2203      	movs	r2, #3
 8009a26:	400a      	ands	r2, r1
 8009a28:	00d2      	lsls	r2, r2, #3
 8009a2a:	21ff      	movs	r1, #255	; 0xff
 8009a2c:	4091      	lsls	r1, r2
 8009a2e:	000a      	movs	r2, r1
 8009a30:	43d2      	mvns	r2, r2
 8009a32:	401a      	ands	r2, r3
 8009a34:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8009a36:	683b      	ldr	r3, [r7, #0]
 8009a38:	019b      	lsls	r3, r3, #6
 8009a3a:	22ff      	movs	r2, #255	; 0xff
 8009a3c:	401a      	ands	r2, r3
 8009a3e:	1dfb      	adds	r3, r7, #7
 8009a40:	781b      	ldrb	r3, [r3, #0]
 8009a42:	0018      	movs	r0, r3
 8009a44:	2303      	movs	r3, #3
 8009a46:	4003      	ands	r3, r0
 8009a48:	00db      	lsls	r3, r3, #3
 8009a4a:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8009a4c:	481f      	ldr	r0, [pc, #124]	; (8009acc <__NVIC_SetPriority+0xd4>)
 8009a4e:	1dfb      	adds	r3, r7, #7
 8009a50:	781b      	ldrb	r3, [r3, #0]
 8009a52:	b25b      	sxtb	r3, r3
 8009a54:	089b      	lsrs	r3, r3, #2
 8009a56:	430a      	orrs	r2, r1
 8009a58:	33c0      	adds	r3, #192	; 0xc0
 8009a5a:	009b      	lsls	r3, r3, #2
 8009a5c:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 8009a5e:	e031      	b.n	8009ac4 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8009a60:	4a1b      	ldr	r2, [pc, #108]	; (8009ad0 <__NVIC_SetPriority+0xd8>)
 8009a62:	1dfb      	adds	r3, r7, #7
 8009a64:	781b      	ldrb	r3, [r3, #0]
 8009a66:	0019      	movs	r1, r3
 8009a68:	230f      	movs	r3, #15
 8009a6a:	400b      	ands	r3, r1
 8009a6c:	3b08      	subs	r3, #8
 8009a6e:	089b      	lsrs	r3, r3, #2
 8009a70:	3306      	adds	r3, #6
 8009a72:	009b      	lsls	r3, r3, #2
 8009a74:	18d3      	adds	r3, r2, r3
 8009a76:	3304      	adds	r3, #4
 8009a78:	681b      	ldr	r3, [r3, #0]
 8009a7a:	1dfa      	adds	r2, r7, #7
 8009a7c:	7812      	ldrb	r2, [r2, #0]
 8009a7e:	0011      	movs	r1, r2
 8009a80:	2203      	movs	r2, #3
 8009a82:	400a      	ands	r2, r1
 8009a84:	00d2      	lsls	r2, r2, #3
 8009a86:	21ff      	movs	r1, #255	; 0xff
 8009a88:	4091      	lsls	r1, r2
 8009a8a:	000a      	movs	r2, r1
 8009a8c:	43d2      	mvns	r2, r2
 8009a8e:	401a      	ands	r2, r3
 8009a90:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8009a92:	683b      	ldr	r3, [r7, #0]
 8009a94:	019b      	lsls	r3, r3, #6
 8009a96:	22ff      	movs	r2, #255	; 0xff
 8009a98:	401a      	ands	r2, r3
 8009a9a:	1dfb      	adds	r3, r7, #7
 8009a9c:	781b      	ldrb	r3, [r3, #0]
 8009a9e:	0018      	movs	r0, r3
 8009aa0:	2303      	movs	r3, #3
 8009aa2:	4003      	ands	r3, r0
 8009aa4:	00db      	lsls	r3, r3, #3
 8009aa6:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8009aa8:	4809      	ldr	r0, [pc, #36]	; (8009ad0 <__NVIC_SetPriority+0xd8>)
 8009aaa:	1dfb      	adds	r3, r7, #7
 8009aac:	781b      	ldrb	r3, [r3, #0]
 8009aae:	001c      	movs	r4, r3
 8009ab0:	230f      	movs	r3, #15
 8009ab2:	4023      	ands	r3, r4
 8009ab4:	3b08      	subs	r3, #8
 8009ab6:	089b      	lsrs	r3, r3, #2
 8009ab8:	430a      	orrs	r2, r1
 8009aba:	3306      	adds	r3, #6
 8009abc:	009b      	lsls	r3, r3, #2
 8009abe:	18c3      	adds	r3, r0, r3
 8009ac0:	3304      	adds	r3, #4
 8009ac2:	601a      	str	r2, [r3, #0]
}
 8009ac4:	46c0      	nop			; (mov r8, r8)
 8009ac6:	46bd      	mov	sp, r7
 8009ac8:	b003      	add	sp, #12
 8009aca:	bd90      	pop	{r4, r7, pc}
 8009acc:	e000e100 	.word	0xe000e100
 8009ad0:	e000ed00 	.word	0xe000ed00

08009ad4 <HAL_NVIC_SetPriority>:
  *         with stm32l0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0+ based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8009ad4:	b580      	push	{r7, lr}
 8009ad6:	b084      	sub	sp, #16
 8009ad8:	af00      	add	r7, sp, #0
 8009ada:	60b9      	str	r1, [r7, #8]
 8009adc:	607a      	str	r2, [r7, #4]
 8009ade:	210f      	movs	r1, #15
 8009ae0:	187b      	adds	r3, r7, r1
 8009ae2:	1c02      	adds	r2, r0, #0
 8009ae4:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
 8009ae6:	68ba      	ldr	r2, [r7, #8]
 8009ae8:	187b      	adds	r3, r7, r1
 8009aea:	781b      	ldrb	r3, [r3, #0]
 8009aec:	b25b      	sxtb	r3, r3
 8009aee:	0011      	movs	r1, r2
 8009af0:	0018      	movs	r0, r3
 8009af2:	f7ff ff81 	bl	80099f8 <__NVIC_SetPriority>
}
 8009af6:	46c0      	nop			; (mov r8, r8)
 8009af8:	46bd      	mov	sp, r7
 8009afa:	b004      	add	sp, #16
 8009afc:	bd80      	pop	{r7, pc}

08009afe <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of  IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32l0xx.h file)  
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8009afe:	b580      	push	{r7, lr}
 8009b00:	b082      	sub	sp, #8
 8009b02:	af00      	add	r7, sp, #0
 8009b04:	0002      	movs	r2, r0
 8009b06:	1dfb      	adds	r3, r7, #7
 8009b08:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8009b0a:	1dfb      	adds	r3, r7, #7
 8009b0c:	781b      	ldrb	r3, [r3, #0]
 8009b0e:	b25b      	sxtb	r3, r3
 8009b10:	0018      	movs	r0, r3
 8009b12:	f7ff ff57 	bl	80099c4 <__NVIC_EnableIRQ>
}
 8009b16:	46c0      	nop			; (mov r8, r8)
 8009b18:	46bd      	mov	sp, r7
 8009b1a:	b002      	add	sp, #8
 8009b1c:	bd80      	pop	{r7, pc}
	...

08009b20 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8009b20:	b580      	push	{r7, lr}
 8009b22:	b084      	sub	sp, #16
 8009b24:	af00      	add	r7, sp, #0
 8009b26:	6078      	str	r0, [r7, #4]
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if(hdma == NULL)
 8009b28:	687b      	ldr	r3, [r7, #4]
 8009b2a:	2b00      	cmp	r3, #0
 8009b2c:	d101      	bne.n	8009b32 <HAL_DMA_Init+0x12>
  {
    return HAL_ERROR;
 8009b2e:	2301      	movs	r3, #1
 8009b30:	e061      	b.n	8009bf6 <HAL_DMA_Init+0xd6>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  /* Compute the channel index */
  /* Only one DMA: DMA1 */
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8009b32:	687b      	ldr	r3, [r7, #4]
 8009b34:	681b      	ldr	r3, [r3, #0]
 8009b36:	4a32      	ldr	r2, [pc, #200]	; (8009c00 <HAL_DMA_Init+0xe0>)
 8009b38:	4694      	mov	ip, r2
 8009b3a:	4463      	add	r3, ip
 8009b3c:	2114      	movs	r1, #20
 8009b3e:	0018      	movs	r0, r3
 8009b40:	f7f6 faec 	bl	800011c <__udivsi3>
 8009b44:	0003      	movs	r3, r0
 8009b46:	009a      	lsls	r2, r3, #2
 8009b48:	687b      	ldr	r3, [r7, #4]
 8009b4a:	645a      	str	r2, [r3, #68]	; 0x44
  hdma->DmaBaseAddress = DMA1;
 8009b4c:	687b      	ldr	r3, [r7, #4]
 8009b4e:	4a2d      	ldr	r2, [pc, #180]	; (8009c04 <HAL_DMA_Init+0xe4>)
 8009b50:	641a      	str	r2, [r3, #64]	; 0x40

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8009b52:	687b      	ldr	r3, [r7, #4]
 8009b54:	2225      	movs	r2, #37	; 0x25
 8009b56:	2102      	movs	r1, #2
 8009b58:	5499      	strb	r1, [r3, r2]

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 8009b5a:	687b      	ldr	r3, [r7, #4]
 8009b5c:	681b      	ldr	r3, [r3, #0]
 8009b5e:	681b      	ldr	r3, [r3, #0]
 8009b60:	60fb      	str	r3, [r7, #12]

  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR and MEM2MEM bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 8009b62:	68fb      	ldr	r3, [r7, #12]
 8009b64:	4a28      	ldr	r2, [pc, #160]	; (8009c08 <HAL_DMA_Init+0xe8>)
 8009b66:	4013      	ands	r3, r2
 8009b68:	60fb      	str	r3, [r7, #12]
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8009b6a:	687b      	ldr	r3, [r7, #4]
 8009b6c:	689a      	ldr	r2, [r3, #8]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8009b6e:	687b      	ldr	r3, [r7, #4]
 8009b70:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Direction        |
 8009b72:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8009b74:	687b      	ldr	r3, [r7, #4]
 8009b76:	691b      	ldr	r3, [r3, #16]
 8009b78:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8009b7a:	687b      	ldr	r3, [r7, #4]
 8009b7c:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8009b7e:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8009b80:	687b      	ldr	r3, [r7, #4]
 8009b82:	699b      	ldr	r3, [r3, #24]
 8009b84:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8009b86:	687b      	ldr	r3, [r7, #4]
 8009b88:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8009b8a:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8009b8c:	687b      	ldr	r3, [r7, #4]
 8009b8e:	6a1b      	ldr	r3, [r3, #32]
 8009b90:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Direction        |
 8009b92:	68fa      	ldr	r2, [r7, #12]
 8009b94:	4313      	orrs	r3, r2
 8009b96:	60fb      	str	r3, [r7, #12]

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;
 8009b98:	687b      	ldr	r3, [r7, #4]
 8009b9a:	681b      	ldr	r3, [r3, #0]
 8009b9c:	68fa      	ldr	r2, [r7, #12]
 8009b9e:	601a      	str	r2, [r3, #0]

  /* Set request selection */
  if(hdma->Init.Direction != DMA_MEMORY_TO_MEMORY)
 8009ba0:	687b      	ldr	r3, [r7, #4]
 8009ba2:	689a      	ldr	r2, [r3, #8]
 8009ba4:	2380      	movs	r3, #128	; 0x80
 8009ba6:	01db      	lsls	r3, r3, #7
 8009ba8:	429a      	cmp	r2, r3
 8009baa:	d018      	beq.n	8009bde <HAL_DMA_Init+0xbe>
  {
    /* Write to DMA channel selection register */
    /* Reset request selection for DMA1 Channelx */
    DMA1_CSELR->CSELR &= ~(DMA_CSELR_C1S << (hdma->ChannelIndex & 0x1cU));
 8009bac:	4b17      	ldr	r3, [pc, #92]	; (8009c0c <HAL_DMA_Init+0xec>)
 8009bae:	681a      	ldr	r2, [r3, #0]
 8009bb0:	687b      	ldr	r3, [r7, #4]
 8009bb2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009bb4:	211c      	movs	r1, #28
 8009bb6:	400b      	ands	r3, r1
 8009bb8:	210f      	movs	r1, #15
 8009bba:	4099      	lsls	r1, r3
 8009bbc:	000b      	movs	r3, r1
 8009bbe:	43d9      	mvns	r1, r3
 8009bc0:	4b12      	ldr	r3, [pc, #72]	; (8009c0c <HAL_DMA_Init+0xec>)
 8009bc2:	400a      	ands	r2, r1
 8009bc4:	601a      	str	r2, [r3, #0]

    /* Configure request selection for DMA1 Channelx */
    DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << (hdma->ChannelIndex & 0x1cU));
 8009bc6:	4b11      	ldr	r3, [pc, #68]	; (8009c0c <HAL_DMA_Init+0xec>)
 8009bc8:	6819      	ldr	r1, [r3, #0]
 8009bca:	687b      	ldr	r3, [r7, #4]
 8009bcc:	685a      	ldr	r2, [r3, #4]
 8009bce:	687b      	ldr	r3, [r7, #4]
 8009bd0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009bd2:	201c      	movs	r0, #28
 8009bd4:	4003      	ands	r3, r0
 8009bd6:	409a      	lsls	r2, r3
 8009bd8:	4b0c      	ldr	r3, [pc, #48]	; (8009c0c <HAL_DMA_Init+0xec>)
 8009bda:	430a      	orrs	r2, r1
 8009bdc:	601a      	str	r2, [r3, #0]
  }

  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8009bde:	687b      	ldr	r3, [r7, #4]
 8009be0:	2200      	movs	r2, #0
 8009be2:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
 8009be4:	687b      	ldr	r3, [r7, #4]
 8009be6:	2225      	movs	r2, #37	; 0x25
 8009be8:	2101      	movs	r1, #1
 8009bea:	5499      	strb	r1, [r3, r2]

  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;
 8009bec:	687b      	ldr	r3, [r7, #4]
 8009bee:	2224      	movs	r2, #36	; 0x24
 8009bf0:	2100      	movs	r1, #0
 8009bf2:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 8009bf4:	2300      	movs	r3, #0
}
 8009bf6:	0018      	movs	r0, r3
 8009bf8:	46bd      	mov	sp, r7
 8009bfa:	b004      	add	sp, #16
 8009bfc:	bd80      	pop	{r7, pc}
 8009bfe:	46c0      	nop			; (mov r8, r8)
 8009c00:	bffdfff8 	.word	0xbffdfff8
 8009c04:	40020000 	.word	0x40020000
 8009c08:	ffff800f 	.word	0xffff800f
 8009c0c:	400200a8 	.word	0x400200a8

08009c10 <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8009c10:	b580      	push	{r7, lr}
 8009c12:	b086      	sub	sp, #24
 8009c14:	af00      	add	r7, sp, #0
 8009c16:	60f8      	str	r0, [r7, #12]
 8009c18:	60b9      	str	r1, [r7, #8]
 8009c1a:	607a      	str	r2, [r7, #4]
 8009c1c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8009c1e:	2317      	movs	r3, #23
 8009c20:	18fb      	adds	r3, r7, r3
 8009c22:	2200      	movs	r2, #0
 8009c24:	701a      	strb	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
 8009c26:	68fb      	ldr	r3, [r7, #12]
 8009c28:	2224      	movs	r2, #36	; 0x24
 8009c2a:	5c9b      	ldrb	r3, [r3, r2]
 8009c2c:	2b01      	cmp	r3, #1
 8009c2e:	d101      	bne.n	8009c34 <HAL_DMA_Start_IT+0x24>
 8009c30:	2302      	movs	r3, #2
 8009c32:	e04f      	b.n	8009cd4 <HAL_DMA_Start_IT+0xc4>
 8009c34:	68fb      	ldr	r3, [r7, #12]
 8009c36:	2224      	movs	r2, #36	; 0x24
 8009c38:	2101      	movs	r1, #1
 8009c3a:	5499      	strb	r1, [r3, r2]

  if(HAL_DMA_STATE_READY == hdma->State)
 8009c3c:	68fb      	ldr	r3, [r7, #12]
 8009c3e:	2225      	movs	r2, #37	; 0x25
 8009c40:	5c9b      	ldrb	r3, [r3, r2]
 8009c42:	b2db      	uxtb	r3, r3
 8009c44:	2b01      	cmp	r3, #1
 8009c46:	d13a      	bne.n	8009cbe <HAL_DMA_Start_IT+0xae>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 8009c48:	68fb      	ldr	r3, [r7, #12]
 8009c4a:	2225      	movs	r2, #37	; 0x25
 8009c4c:	2102      	movs	r1, #2
 8009c4e:	5499      	strb	r1, [r3, r2]
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8009c50:	68fb      	ldr	r3, [r7, #12]
 8009c52:	2200      	movs	r2, #0
 8009c54:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
 8009c56:	68fb      	ldr	r3, [r7, #12]
 8009c58:	681b      	ldr	r3, [r3, #0]
 8009c5a:	681a      	ldr	r2, [r3, #0]
 8009c5c:	68fb      	ldr	r3, [r7, #12]
 8009c5e:	681b      	ldr	r3, [r3, #0]
 8009c60:	2101      	movs	r1, #1
 8009c62:	438a      	bics	r2, r1
 8009c64:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length & clear flags*/
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8009c66:	683b      	ldr	r3, [r7, #0]
 8009c68:	687a      	ldr	r2, [r7, #4]
 8009c6a:	68b9      	ldr	r1, [r7, #8]
 8009c6c:	68f8      	ldr	r0, [r7, #12]
 8009c6e:	f000 f92a 	bl	8009ec6 <DMA_SetConfig>

    /* Enable the transfer complete interrupt */
    /* Enable the transfer Error interrupt */
    if(NULL != hdma->XferHalfCpltCallback )
 8009c72:	68fb      	ldr	r3, [r7, #12]
 8009c74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009c76:	2b00      	cmp	r3, #0
 8009c78:	d008      	beq.n	8009c8c <HAL_DMA_Start_IT+0x7c>
    {
      /* Enable the Half transfer complete interrupt as well */
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8009c7a:	68fb      	ldr	r3, [r7, #12]
 8009c7c:	681b      	ldr	r3, [r3, #0]
 8009c7e:	681a      	ldr	r2, [r3, #0]
 8009c80:	68fb      	ldr	r3, [r7, #12]
 8009c82:	681b      	ldr	r3, [r3, #0]
 8009c84:	210e      	movs	r1, #14
 8009c86:	430a      	orrs	r2, r1
 8009c88:	601a      	str	r2, [r3, #0]
 8009c8a:	e00f      	b.n	8009cac <HAL_DMA_Start_IT+0x9c>
    }
    else
    {
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8009c8c:	68fb      	ldr	r3, [r7, #12]
 8009c8e:	681b      	ldr	r3, [r3, #0]
 8009c90:	681a      	ldr	r2, [r3, #0]
 8009c92:	68fb      	ldr	r3, [r7, #12]
 8009c94:	681b      	ldr	r3, [r3, #0]
 8009c96:	2104      	movs	r1, #4
 8009c98:	438a      	bics	r2, r1
 8009c9a:	601a      	str	r2, [r3, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 8009c9c:	68fb      	ldr	r3, [r7, #12]
 8009c9e:	681b      	ldr	r3, [r3, #0]
 8009ca0:	681a      	ldr	r2, [r3, #0]
 8009ca2:	68fb      	ldr	r3, [r7, #12]
 8009ca4:	681b      	ldr	r3, [r3, #0]
 8009ca6:	210a      	movs	r1, #10
 8009ca8:	430a      	orrs	r2, r1
 8009caa:	601a      	str	r2, [r3, #0]
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 8009cac:	68fb      	ldr	r3, [r7, #12]
 8009cae:	681b      	ldr	r3, [r3, #0]
 8009cb0:	681a      	ldr	r2, [r3, #0]
 8009cb2:	68fb      	ldr	r3, [r7, #12]
 8009cb4:	681b      	ldr	r3, [r3, #0]
 8009cb6:	2101      	movs	r1, #1
 8009cb8:	430a      	orrs	r2, r1
 8009cba:	601a      	str	r2, [r3, #0]
 8009cbc:	e007      	b.n	8009cce <HAL_DMA_Start_IT+0xbe>
  }
  else
  {
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8009cbe:	68fb      	ldr	r3, [r7, #12]
 8009cc0:	2224      	movs	r2, #36	; 0x24
 8009cc2:	2100      	movs	r1, #0
 8009cc4:	5499      	strb	r1, [r3, r2]

    /* Remain BUSY */
    status = HAL_BUSY;
 8009cc6:	2317      	movs	r3, #23
 8009cc8:	18fb      	adds	r3, r7, r3
 8009cca:	2202      	movs	r2, #2
 8009ccc:	701a      	strb	r2, [r3, #0]
  }
  return status;
 8009cce:	2317      	movs	r3, #23
 8009cd0:	18fb      	adds	r3, r7, r3
 8009cd2:	781b      	ldrb	r3, [r3, #0]
}
 8009cd4:	0018      	movs	r0, r3
 8009cd6:	46bd      	mov	sp, r7
 8009cd8:	b006      	add	sp, #24
 8009cda:	bd80      	pop	{r7, pc}

08009cdc <HAL_DMA_Abort_IT>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 8009cdc:	b580      	push	{r7, lr}
 8009cde:	b084      	sub	sp, #16
 8009ce0:	af00      	add	r7, sp, #0
 8009ce2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8009ce4:	210f      	movs	r1, #15
 8009ce6:	187b      	adds	r3, r7, r1
 8009ce8:	2200      	movs	r2, #0
 8009cea:	701a      	strb	r2, [r3, #0]

  if(HAL_DMA_STATE_BUSY != hdma->State)
 8009cec:	687b      	ldr	r3, [r7, #4]
 8009cee:	2225      	movs	r2, #37	; 0x25
 8009cf0:	5c9b      	ldrb	r3, [r3, r2]
 8009cf2:	b2db      	uxtb	r3, r3
 8009cf4:	2b02      	cmp	r3, #2
 8009cf6:	d006      	beq.n	8009d06 <HAL_DMA_Abort_IT+0x2a>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8009cf8:	687b      	ldr	r3, [r7, #4]
 8009cfa:	2204      	movs	r2, #4
 8009cfc:	63da      	str	r2, [r3, #60]	; 0x3c

    status = HAL_ERROR;
 8009cfe:	187b      	adds	r3, r7, r1
 8009d00:	2201      	movs	r2, #1
 8009d02:	701a      	strb	r2, [r3, #0]
 8009d04:	e02a      	b.n	8009d5c <HAL_DMA_Abort_IT+0x80>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8009d06:	687b      	ldr	r3, [r7, #4]
 8009d08:	681b      	ldr	r3, [r3, #0]
 8009d0a:	681a      	ldr	r2, [r3, #0]
 8009d0c:	687b      	ldr	r3, [r7, #4]
 8009d0e:	681b      	ldr	r3, [r3, #0]
 8009d10:	210e      	movs	r1, #14
 8009d12:	438a      	bics	r2, r1
 8009d14:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 8009d16:	687b      	ldr	r3, [r7, #4]
 8009d18:	681b      	ldr	r3, [r3, #0]
 8009d1a:	681a      	ldr	r2, [r3, #0]
 8009d1c:	687b      	ldr	r3, [r7, #4]
 8009d1e:	681b      	ldr	r3, [r3, #0]
 8009d20:	2101      	movs	r1, #1
 8009d22:	438a      	bics	r2, r1
 8009d24:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 8009d26:	687b      	ldr	r3, [r7, #4]
 8009d28:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009d2a:	221c      	movs	r2, #28
 8009d2c:	401a      	ands	r2, r3
 8009d2e:	687b      	ldr	r3, [r7, #4]
 8009d30:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009d32:	2101      	movs	r1, #1
 8009d34:	4091      	lsls	r1, r2
 8009d36:	000a      	movs	r2, r1
 8009d38:	605a      	str	r2, [r3, #4]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 8009d3a:	687b      	ldr	r3, [r7, #4]
 8009d3c:	2225      	movs	r2, #37	; 0x25
 8009d3e:	2101      	movs	r1, #1
 8009d40:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8009d42:	687b      	ldr	r3, [r7, #4]
 8009d44:	2224      	movs	r2, #36	; 0x24
 8009d46:	2100      	movs	r1, #0
 8009d48:	5499      	strb	r1, [r3, r2]

    /* Call User Abort callback */
    if(hdma->XferAbortCallback != NULL)
 8009d4a:	687b      	ldr	r3, [r7, #4]
 8009d4c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009d4e:	2b00      	cmp	r3, #0
 8009d50:	d004      	beq.n	8009d5c <HAL_DMA_Abort_IT+0x80>
    {
      hdma->XferAbortCallback(hdma);
 8009d52:	687b      	ldr	r3, [r7, #4]
 8009d54:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009d56:	687a      	ldr	r2, [r7, #4]
 8009d58:	0010      	movs	r0, r2
 8009d5a:	4798      	blx	r3
    }
  }
  return status;
 8009d5c:	230f      	movs	r3, #15
 8009d5e:	18fb      	adds	r3, r7, r3
 8009d60:	781b      	ldrb	r3, [r3, #0]
}
 8009d62:	0018      	movs	r0, r3
 8009d64:	46bd      	mov	sp, r7
 8009d66:	b004      	add	sp, #16
 8009d68:	bd80      	pop	{r7, pc}

08009d6a <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8009d6a:	b580      	push	{r7, lr}
 8009d6c:	b084      	sub	sp, #16
 8009d6e:	af00      	add	r7, sp, #0
 8009d70:	6078      	str	r0, [r7, #4]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8009d72:	687b      	ldr	r3, [r7, #4]
 8009d74:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009d76:	681b      	ldr	r3, [r3, #0]
 8009d78:	60fb      	str	r3, [r7, #12]
  uint32_t source_it = hdma->Instance->CCR;
 8009d7a:	687b      	ldr	r3, [r7, #4]
 8009d7c:	681b      	ldr	r3, [r3, #0]
 8009d7e:	681b      	ldr	r3, [r3, #0]
 8009d80:	60bb      	str	r3, [r7, #8]

  /* Half Transfer Complete Interrupt management ******************************/
  if ((0U != (flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU)))) && (0U != (source_it & DMA_IT_HT)))
 8009d82:	687b      	ldr	r3, [r7, #4]
 8009d84:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009d86:	221c      	movs	r2, #28
 8009d88:	4013      	ands	r3, r2
 8009d8a:	2204      	movs	r2, #4
 8009d8c:	409a      	lsls	r2, r3
 8009d8e:	0013      	movs	r3, r2
 8009d90:	68fa      	ldr	r2, [r7, #12]
 8009d92:	4013      	ands	r3, r2
 8009d94:	d026      	beq.n	8009de4 <HAL_DMA_IRQHandler+0x7a>
 8009d96:	68bb      	ldr	r3, [r7, #8]
 8009d98:	2204      	movs	r2, #4
 8009d9a:	4013      	ands	r3, r2
 8009d9c:	d022      	beq.n	8009de4 <HAL_DMA_IRQHandler+0x7a>
  {
      /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8009d9e:	687b      	ldr	r3, [r7, #4]
 8009da0:	681b      	ldr	r3, [r3, #0]
 8009da2:	681b      	ldr	r3, [r3, #0]
 8009da4:	2220      	movs	r2, #32
 8009da6:	4013      	ands	r3, r2
 8009da8:	d107      	bne.n	8009dba <HAL_DMA_IRQHandler+0x50>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8009daa:	687b      	ldr	r3, [r7, #4]
 8009dac:	681b      	ldr	r3, [r3, #0]
 8009dae:	681a      	ldr	r2, [r3, #0]
 8009db0:	687b      	ldr	r3, [r7, #4]
 8009db2:	681b      	ldr	r3, [r3, #0]
 8009db4:	2104      	movs	r1, #4
 8009db6:	438a      	bics	r2, r1
 8009db8:	601a      	str	r2, [r3, #0]
      }
      /* Clear the half transfer complete flag */
      hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1cU);
 8009dba:	687b      	ldr	r3, [r7, #4]
 8009dbc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009dbe:	221c      	movs	r2, #28
 8009dc0:	401a      	ands	r2, r3
 8009dc2:	687b      	ldr	r3, [r7, #4]
 8009dc4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009dc6:	2104      	movs	r1, #4
 8009dc8:	4091      	lsls	r1, r2
 8009dca:	000a      	movs	r2, r1
 8009dcc:	605a      	str	r2, [r3, #4]

      /* DMA peripheral state is not updated in Half Transfer */
      /* but in Transfer Complete case */

     if(hdma->XferHalfCpltCallback != NULL)
 8009dce:	687b      	ldr	r3, [r7, #4]
 8009dd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009dd2:	2b00      	cmp	r3, #0
 8009dd4:	d100      	bne.n	8009dd8 <HAL_DMA_IRQHandler+0x6e>
 8009dd6:	e071      	b.n	8009ebc <HAL_DMA_IRQHandler+0x152>
      {
        /* Half transfer callback */
        hdma->XferHalfCpltCallback(hdma);
 8009dd8:	687b      	ldr	r3, [r7, #4]
 8009dda:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009ddc:	687a      	ldr	r2, [r7, #4]
 8009dde:	0010      	movs	r0, r2
 8009de0:	4798      	blx	r3
     if(hdma->XferHalfCpltCallback != NULL)
 8009de2:	e06b      	b.n	8009ebc <HAL_DMA_IRQHandler+0x152>
      }
  }

  /* Transfer Complete Interrupt management ***********************************/
  else if ((0U != (flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1cU)))) && (0U != (source_it & DMA_IT_TC)))
 8009de4:	687b      	ldr	r3, [r7, #4]
 8009de6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009de8:	221c      	movs	r2, #28
 8009dea:	4013      	ands	r3, r2
 8009dec:	2202      	movs	r2, #2
 8009dee:	409a      	lsls	r2, r3
 8009df0:	0013      	movs	r3, r2
 8009df2:	68fa      	ldr	r2, [r7, #12]
 8009df4:	4013      	ands	r3, r2
 8009df6:	d02d      	beq.n	8009e54 <HAL_DMA_IRQHandler+0xea>
 8009df8:	68bb      	ldr	r3, [r7, #8]
 8009dfa:	2202      	movs	r2, #2
 8009dfc:	4013      	ands	r3, r2
 8009dfe:	d029      	beq.n	8009e54 <HAL_DMA_IRQHandler+0xea>
  {
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8009e00:	687b      	ldr	r3, [r7, #4]
 8009e02:	681b      	ldr	r3, [r3, #0]
 8009e04:	681b      	ldr	r3, [r3, #0]
 8009e06:	2220      	movs	r2, #32
 8009e08:	4013      	ands	r3, r2
 8009e0a:	d10b      	bne.n	8009e24 <HAL_DMA_IRQHandler+0xba>
    {
      /* Disable the transfer complete and error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8009e0c:	687b      	ldr	r3, [r7, #4]
 8009e0e:	681b      	ldr	r3, [r3, #0]
 8009e10:	681a      	ldr	r2, [r3, #0]
 8009e12:	687b      	ldr	r3, [r7, #4]
 8009e14:	681b      	ldr	r3, [r3, #0]
 8009e16:	210a      	movs	r1, #10
 8009e18:	438a      	bics	r2, r1
 8009e1a:	601a      	str	r2, [r3, #0]

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8009e1c:	687b      	ldr	r3, [r7, #4]
 8009e1e:	2225      	movs	r2, #37	; 0x25
 8009e20:	2101      	movs	r1, #1
 8009e22:	5499      	strb	r1, [r3, r2]
    }
    /* Clear the transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1cU));
 8009e24:	687b      	ldr	r3, [r7, #4]
 8009e26:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009e28:	221c      	movs	r2, #28
 8009e2a:	401a      	ands	r2, r3
 8009e2c:	687b      	ldr	r3, [r7, #4]
 8009e2e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009e30:	2102      	movs	r1, #2
 8009e32:	4091      	lsls	r1, r2
 8009e34:	000a      	movs	r2, r1
 8009e36:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8009e38:	687b      	ldr	r3, [r7, #4]
 8009e3a:	2224      	movs	r2, #36	; 0x24
 8009e3c:	2100      	movs	r1, #0
 8009e3e:	5499      	strb	r1, [r3, r2]

    if(hdma->XferCpltCallback != NULL)
 8009e40:	687b      	ldr	r3, [r7, #4]
 8009e42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009e44:	2b00      	cmp	r3, #0
 8009e46:	d039      	beq.n	8009ebc <HAL_DMA_IRQHandler+0x152>
    {
      /* Transfer complete callback */
      hdma->XferCpltCallback(hdma);
 8009e48:	687b      	ldr	r3, [r7, #4]
 8009e4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009e4c:	687a      	ldr	r2, [r7, #4]
 8009e4e:	0010      	movs	r0, r2
 8009e50:	4798      	blx	r3
    if(hdma->XferCpltCallback != NULL)
 8009e52:	e033      	b.n	8009ebc <HAL_DMA_IRQHandler+0x152>
    }
  }

  /* Transfer Error Interrupt management **************************************/
  else if ((0U != (flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1cU)))) && (0U != (source_it & DMA_IT_TE)))
 8009e54:	687b      	ldr	r3, [r7, #4]
 8009e56:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009e58:	221c      	movs	r2, #28
 8009e5a:	4013      	ands	r3, r2
 8009e5c:	2208      	movs	r2, #8
 8009e5e:	409a      	lsls	r2, r3
 8009e60:	0013      	movs	r3, r2
 8009e62:	68fa      	ldr	r2, [r7, #12]
 8009e64:	4013      	ands	r3, r2
 8009e66:	d02a      	beq.n	8009ebe <HAL_DMA_IRQHandler+0x154>
 8009e68:	68bb      	ldr	r3, [r7, #8]
 8009e6a:	2208      	movs	r2, #8
 8009e6c:	4013      	ands	r3, r2
 8009e6e:	d026      	beq.n	8009ebe <HAL_DMA_IRQHandler+0x154>
  {
    /* When a DMA transfer error occurs */
    /* A hardware clear of its EN bits is performed */
    /* Disable ALL DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8009e70:	687b      	ldr	r3, [r7, #4]
 8009e72:	681b      	ldr	r3, [r3, #0]
 8009e74:	681a      	ldr	r2, [r3, #0]
 8009e76:	687b      	ldr	r3, [r7, #4]
 8009e78:	681b      	ldr	r3, [r3, #0]
 8009e7a:	210e      	movs	r1, #14
 8009e7c:	438a      	bics	r2, r1
 8009e7e:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 8009e80:	687b      	ldr	r3, [r7, #4]
 8009e82:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009e84:	221c      	movs	r2, #28
 8009e86:	401a      	ands	r2, r3
 8009e88:	687b      	ldr	r3, [r7, #4]
 8009e8a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009e8c:	2101      	movs	r1, #1
 8009e8e:	4091      	lsls	r1, r2
 8009e90:	000a      	movs	r2, r1
 8009e92:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8009e94:	687b      	ldr	r3, [r7, #4]
 8009e96:	2201      	movs	r2, #1
 8009e98:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 8009e9a:	687b      	ldr	r3, [r7, #4]
 8009e9c:	2225      	movs	r2, #37	; 0x25
 8009e9e:	2101      	movs	r1, #1
 8009ea0:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8009ea2:	687b      	ldr	r3, [r7, #4]
 8009ea4:	2224      	movs	r2, #36	; 0x24
 8009ea6:	2100      	movs	r1, #0
 8009ea8:	5499      	strb	r1, [r3, r2]

    if (hdma->XferErrorCallback != NULL)
 8009eaa:	687b      	ldr	r3, [r7, #4]
 8009eac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009eae:	2b00      	cmp	r3, #0
 8009eb0:	d005      	beq.n	8009ebe <HAL_DMA_IRQHandler+0x154>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 8009eb2:	687b      	ldr	r3, [r7, #4]
 8009eb4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009eb6:	687a      	ldr	r2, [r7, #4]
 8009eb8:	0010      	movs	r0, r2
 8009eba:	4798      	blx	r3
  }
  else
  {
    /* Nothing To Do */
  }
  return;
 8009ebc:	46c0      	nop			; (mov r8, r8)
 8009ebe:	46c0      	nop			; (mov r8, r8)
}
 8009ec0:	46bd      	mov	sp, r7
 8009ec2:	b004      	add	sp, #16
 8009ec4:	bd80      	pop	{r7, pc}

08009ec6 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8009ec6:	b580      	push	{r7, lr}
 8009ec8:	b084      	sub	sp, #16
 8009eca:	af00      	add	r7, sp, #0
 8009ecc:	60f8      	str	r0, [r7, #12]
 8009ece:	60b9      	str	r1, [r7, #8]
 8009ed0:	607a      	str	r2, [r7, #4]
 8009ed2:	603b      	str	r3, [r7, #0]
  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 8009ed4:	68fb      	ldr	r3, [r7, #12]
 8009ed6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009ed8:	221c      	movs	r2, #28
 8009eda:	401a      	ands	r2, r3
 8009edc:	68fb      	ldr	r3, [r7, #12]
 8009ede:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009ee0:	2101      	movs	r1, #1
 8009ee2:	4091      	lsls	r1, r2
 8009ee4:	000a      	movs	r2, r1
 8009ee6:	605a      	str	r2, [r3, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 8009ee8:	68fb      	ldr	r3, [r7, #12]
 8009eea:	681b      	ldr	r3, [r3, #0]
 8009eec:	683a      	ldr	r2, [r7, #0]
 8009eee:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8009ef0:	68fb      	ldr	r3, [r7, #12]
 8009ef2:	689b      	ldr	r3, [r3, #8]
 8009ef4:	2b10      	cmp	r3, #16
 8009ef6:	d108      	bne.n	8009f0a <DMA_SetConfig+0x44>
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 8009ef8:	68fb      	ldr	r3, [r7, #12]
 8009efa:	681b      	ldr	r3, [r3, #0]
 8009efc:	687a      	ldr	r2, [r7, #4]
 8009efe:	609a      	str	r2, [r3, #8]

    /* Configure DMA Channel source address */
    hdma->Instance->CMAR = SrcAddress;
 8009f00:	68fb      	ldr	r3, [r7, #12]
 8009f02:	681b      	ldr	r3, [r3, #0]
 8009f04:	68ba      	ldr	r2, [r7, #8]
 8009f06:	60da      	str	r2, [r3, #12]
    hdma->Instance->CPAR = SrcAddress;

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
  }
}
 8009f08:	e007      	b.n	8009f1a <DMA_SetConfig+0x54>
    hdma->Instance->CPAR = SrcAddress;
 8009f0a:	68fb      	ldr	r3, [r7, #12]
 8009f0c:	681b      	ldr	r3, [r3, #0]
 8009f0e:	68ba      	ldr	r2, [r7, #8]
 8009f10:	609a      	str	r2, [r3, #8]
    hdma->Instance->CMAR = DstAddress;
 8009f12:	68fb      	ldr	r3, [r7, #12]
 8009f14:	681b      	ldr	r3, [r3, #0]
 8009f16:	687a      	ldr	r2, [r7, #4]
 8009f18:	60da      	str	r2, [r3, #12]
}
 8009f1a:	46c0      	nop			; (mov r8, r8)
 8009f1c:	46bd      	mov	sp, r7
 8009f1e:	b004      	add	sp, #16
 8009f20:	bd80      	pop	{r7, pc}
	...

08009f24 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *                    the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8009f24:	b580      	push	{r7, lr}
 8009f26:	b086      	sub	sp, #24
 8009f28:	af00      	add	r7, sp, #0
 8009f2a:	6078      	str	r0, [r7, #4]
 8009f2c:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 8009f2e:	2300      	movs	r3, #0
 8009f30:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 8009f32:	2300      	movs	r3, #0
 8009f34:	60fb      	str	r3, [r7, #12]
  uint32_t temp = 0x00U;
 8009f36:	2300      	movs	r3, #0
 8009f38:	613b      	str	r3, [r7, #16]
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,(GPIO_Init->Pin)));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 8009f3a:	e155      	b.n	800a1e8 <HAL_GPIO_Init+0x2c4>
  {
    /* Get the IO position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8009f3c:	683b      	ldr	r3, [r7, #0]
 8009f3e:	681b      	ldr	r3, [r3, #0]
 8009f40:	2101      	movs	r1, #1
 8009f42:	697a      	ldr	r2, [r7, #20]
 8009f44:	4091      	lsls	r1, r2
 8009f46:	000a      	movs	r2, r1
 8009f48:	4013      	ands	r3, r2
 8009f4a:	60fb      	str	r3, [r7, #12]
    
    if(iocurrent)
 8009f4c:	68fb      	ldr	r3, [r7, #12]
 8009f4e:	2b00      	cmp	r3, #0
 8009f50:	d100      	bne.n	8009f54 <HAL_GPIO_Init+0x30>
 8009f52:	e146      	b.n	800a1e2 <HAL_GPIO_Init+0x2be>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 8009f54:	683b      	ldr	r3, [r7, #0]
 8009f56:	685b      	ldr	r3, [r3, #4]
 8009f58:	2b02      	cmp	r3, #2
 8009f5a:	d003      	beq.n	8009f64 <HAL_GPIO_Init+0x40>
 8009f5c:	683b      	ldr	r3, [r7, #0]
 8009f5e:	685b      	ldr	r3, [r3, #4]
 8009f60:	2b12      	cmp	r3, #18
 8009f62:	d123      	bne.n	8009fac <HAL_GPIO_Init+0x88>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */ 
        temp = GPIOx->AFR[position >> 3U];
 8009f64:	697b      	ldr	r3, [r7, #20]
 8009f66:	08da      	lsrs	r2, r3, #3
 8009f68:	687b      	ldr	r3, [r7, #4]
 8009f6a:	3208      	adds	r2, #8
 8009f6c:	0092      	lsls	r2, r2, #2
 8009f6e:	58d3      	ldr	r3, [r2, r3]
 8009f70:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8009f72:	697b      	ldr	r3, [r7, #20]
 8009f74:	2207      	movs	r2, #7
 8009f76:	4013      	ands	r3, r2
 8009f78:	009b      	lsls	r3, r3, #2
 8009f7a:	220f      	movs	r2, #15
 8009f7c:	409a      	lsls	r2, r3
 8009f7e:	0013      	movs	r3, r2
 8009f80:	43da      	mvns	r2, r3
 8009f82:	693b      	ldr	r3, [r7, #16]
 8009f84:	4013      	ands	r3, r2
 8009f86:	613b      	str	r3, [r7, #16]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U)) ;
 8009f88:	683b      	ldr	r3, [r7, #0]
 8009f8a:	691a      	ldr	r2, [r3, #16]
 8009f8c:	697b      	ldr	r3, [r7, #20]
 8009f8e:	2107      	movs	r1, #7
 8009f90:	400b      	ands	r3, r1
 8009f92:	009b      	lsls	r3, r3, #2
 8009f94:	409a      	lsls	r2, r3
 8009f96:	0013      	movs	r3, r2
 8009f98:	693a      	ldr	r2, [r7, #16]
 8009f9a:	4313      	orrs	r3, r2
 8009f9c:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 8009f9e:	697b      	ldr	r3, [r7, #20]
 8009fa0:	08da      	lsrs	r2, r3, #3
 8009fa2:	687b      	ldr	r3, [r7, #4]
 8009fa4:	3208      	adds	r2, #8
 8009fa6:	0092      	lsls	r2, r2, #2
 8009fa8:	6939      	ldr	r1, [r7, #16]
 8009faa:	50d1      	str	r1, [r2, r3]
      } 

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8009fac:	683b      	ldr	r3, [r7, #0]
 8009fae:	685b      	ldr	r3, [r3, #4]
 8009fb0:	2b01      	cmp	r3, #1
 8009fb2:	d00b      	beq.n	8009fcc <HAL_GPIO_Init+0xa8>
 8009fb4:	683b      	ldr	r3, [r7, #0]
 8009fb6:	685b      	ldr	r3, [r3, #4]
 8009fb8:	2b02      	cmp	r3, #2
 8009fba:	d007      	beq.n	8009fcc <HAL_GPIO_Init+0xa8>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8009fbc:	683b      	ldr	r3, [r7, #0]
 8009fbe:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8009fc0:	2b11      	cmp	r3, #17
 8009fc2:	d003      	beq.n	8009fcc <HAL_GPIO_Init+0xa8>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8009fc4:	683b      	ldr	r3, [r7, #0]
 8009fc6:	685b      	ldr	r3, [r3, #4]
 8009fc8:	2b12      	cmp	r3, #18
 8009fca:	d130      	bne.n	800a02e <HAL_GPIO_Init+0x10a>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8009fcc:	687b      	ldr	r3, [r7, #4]
 8009fce:	689b      	ldr	r3, [r3, #8]
 8009fd0:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
 8009fd2:	697b      	ldr	r3, [r7, #20]
 8009fd4:	005b      	lsls	r3, r3, #1
 8009fd6:	2203      	movs	r2, #3
 8009fd8:	409a      	lsls	r2, r3
 8009fda:	0013      	movs	r3, r2
 8009fdc:	43da      	mvns	r2, r3
 8009fde:	693b      	ldr	r3, [r7, #16]
 8009fe0:	4013      	ands	r3, r2
 8009fe2:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8009fe4:	683b      	ldr	r3, [r7, #0]
 8009fe6:	68da      	ldr	r2, [r3, #12]
 8009fe8:	697b      	ldr	r3, [r7, #20]
 8009fea:	005b      	lsls	r3, r3, #1
 8009fec:	409a      	lsls	r2, r3
 8009fee:	0013      	movs	r3, r2
 8009ff0:	693a      	ldr	r2, [r7, #16]
 8009ff2:	4313      	orrs	r3, r2
 8009ff4:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 8009ff6:	687b      	ldr	r3, [r7, #4]
 8009ff8:	693a      	ldr	r2, [r7, #16]
 8009ffa:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp= GPIOx->OTYPER;
 8009ffc:	687b      	ldr	r3, [r7, #4]
 8009ffe:	685b      	ldr	r3, [r3, #4]
 800a000:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800a002:	2201      	movs	r2, #1
 800a004:	697b      	ldr	r3, [r7, #20]
 800a006:	409a      	lsls	r2, r3
 800a008:	0013      	movs	r3, r2
 800a00a:	43da      	mvns	r2, r3
 800a00c:	693b      	ldr	r3, [r7, #16]
 800a00e:	4013      	ands	r3, r2
 800a010:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 800a012:	683b      	ldr	r3, [r7, #0]
 800a014:	685b      	ldr	r3, [r3, #4]
 800a016:	091b      	lsrs	r3, r3, #4
 800a018:	2201      	movs	r2, #1
 800a01a:	401a      	ands	r2, r3
 800a01c:	697b      	ldr	r3, [r7, #20]
 800a01e:	409a      	lsls	r2, r3
 800a020:	0013      	movs	r3, r2
 800a022:	693a      	ldr	r2, [r7, #16]
 800a024:	4313      	orrs	r3, r2
 800a026:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 800a028:	687b      	ldr	r3, [r7, #4]
 800a02a:	693a      	ldr	r2, [r7, #16]
 800a02c:	605a      	str	r2, [r3, #4]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800a02e:	687b      	ldr	r3, [r7, #4]
 800a030:	681b      	ldr	r3, [r3, #0]
 800a032:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800a034:	697b      	ldr	r3, [r7, #20]
 800a036:	005b      	lsls	r3, r3, #1
 800a038:	2203      	movs	r2, #3
 800a03a:	409a      	lsls	r2, r3
 800a03c:	0013      	movs	r3, r2
 800a03e:	43da      	mvns	r2, r3
 800a040:	693b      	ldr	r3, [r7, #16]
 800a042:	4013      	ands	r3, r2
 800a044:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800a046:	683b      	ldr	r3, [r7, #0]
 800a048:	685b      	ldr	r3, [r3, #4]
 800a04a:	2203      	movs	r2, #3
 800a04c:	401a      	ands	r2, r3
 800a04e:	697b      	ldr	r3, [r7, #20]
 800a050:	005b      	lsls	r3, r3, #1
 800a052:	409a      	lsls	r2, r3
 800a054:	0013      	movs	r3, r2
 800a056:	693a      	ldr	r2, [r7, #16]
 800a058:	4313      	orrs	r3, r2
 800a05a:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 800a05c:	687b      	ldr	r3, [r7, #4]
 800a05e:	693a      	ldr	r2, [r7, #16]
 800a060:	601a      	str	r2, [r3, #0]

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 800a062:	687b      	ldr	r3, [r7, #4]
 800a064:	68db      	ldr	r3, [r3, #12]
 800a066:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800a068:	697b      	ldr	r3, [r7, #20]
 800a06a:	005b      	lsls	r3, r3, #1
 800a06c:	2203      	movs	r2, #3
 800a06e:	409a      	lsls	r2, r3
 800a070:	0013      	movs	r3, r2
 800a072:	43da      	mvns	r2, r3
 800a074:	693b      	ldr	r3, [r7, #16]
 800a076:	4013      	ands	r3, r2
 800a078:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Pull) << (position * 2U)); 
 800a07a:	683b      	ldr	r3, [r7, #0]
 800a07c:	689a      	ldr	r2, [r3, #8]
 800a07e:	697b      	ldr	r3, [r7, #20]
 800a080:	005b      	lsls	r3, r3, #1
 800a082:	409a      	lsls	r2, r3
 800a084:	0013      	movs	r3, r2
 800a086:	693a      	ldr	r2, [r7, #16]
 800a088:	4313      	orrs	r3, r2
 800a08a:	613b      	str	r3, [r7, #16]
      GPIOx->PUPDR = temp;
 800a08c:	687b      	ldr	r3, [r7, #4]
 800a08e:	693a      	ldr	r2, [r7, #16]
 800a090:	60da      	str	r2, [r3, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 800a092:	683b      	ldr	r3, [r7, #0]
 800a094:	685a      	ldr	r2, [r3, #4]
 800a096:	2380      	movs	r3, #128	; 0x80
 800a098:	055b      	lsls	r3, r3, #21
 800a09a:	4013      	ands	r3, r2
 800a09c:	d100      	bne.n	800a0a0 <HAL_GPIO_Init+0x17c>
 800a09e:	e0a0      	b.n	800a1e2 <HAL_GPIO_Init+0x2be>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a0a0:	4b57      	ldr	r3, [pc, #348]	; (800a200 <HAL_GPIO_Init+0x2dc>)
 800a0a2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800a0a4:	4b56      	ldr	r3, [pc, #344]	; (800a200 <HAL_GPIO_Init+0x2dc>)
 800a0a6:	2101      	movs	r1, #1
 800a0a8:	430a      	orrs	r2, r1
 800a0aa:	635a      	str	r2, [r3, #52]	; 0x34
        
        temp = SYSCFG->EXTICR[position >> 2U];
 800a0ac:	4a55      	ldr	r2, [pc, #340]	; (800a204 <HAL_GPIO_Init+0x2e0>)
 800a0ae:	697b      	ldr	r3, [r7, #20]
 800a0b0:	089b      	lsrs	r3, r3, #2
 800a0b2:	3302      	adds	r3, #2
 800a0b4:	009b      	lsls	r3, r3, #2
 800a0b6:	589b      	ldr	r3, [r3, r2]
 800a0b8:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 800a0ba:	697b      	ldr	r3, [r7, #20]
 800a0bc:	2203      	movs	r2, #3
 800a0be:	4013      	ands	r3, r2
 800a0c0:	009b      	lsls	r3, r3, #2
 800a0c2:	220f      	movs	r2, #15
 800a0c4:	409a      	lsls	r2, r3
 800a0c6:	0013      	movs	r3, r2
 800a0c8:	43da      	mvns	r2, r3
 800a0ca:	693b      	ldr	r3, [r7, #16]
 800a0cc:	4013      	ands	r3, r2
 800a0ce:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 800a0d0:	687a      	ldr	r2, [r7, #4]
 800a0d2:	23a0      	movs	r3, #160	; 0xa0
 800a0d4:	05db      	lsls	r3, r3, #23
 800a0d6:	429a      	cmp	r2, r3
 800a0d8:	d01f      	beq.n	800a11a <HAL_GPIO_Init+0x1f6>
 800a0da:	687b      	ldr	r3, [r7, #4]
 800a0dc:	4a4a      	ldr	r2, [pc, #296]	; (800a208 <HAL_GPIO_Init+0x2e4>)
 800a0de:	4293      	cmp	r3, r2
 800a0e0:	d019      	beq.n	800a116 <HAL_GPIO_Init+0x1f2>
 800a0e2:	687b      	ldr	r3, [r7, #4]
 800a0e4:	4a49      	ldr	r2, [pc, #292]	; (800a20c <HAL_GPIO_Init+0x2e8>)
 800a0e6:	4293      	cmp	r3, r2
 800a0e8:	d013      	beq.n	800a112 <HAL_GPIO_Init+0x1ee>
 800a0ea:	687b      	ldr	r3, [r7, #4]
 800a0ec:	4a48      	ldr	r2, [pc, #288]	; (800a210 <HAL_GPIO_Init+0x2ec>)
 800a0ee:	4293      	cmp	r3, r2
 800a0f0:	d00d      	beq.n	800a10e <HAL_GPIO_Init+0x1ea>
 800a0f2:	687b      	ldr	r3, [r7, #4]
 800a0f4:	4a47      	ldr	r2, [pc, #284]	; (800a214 <HAL_GPIO_Init+0x2f0>)
 800a0f6:	4293      	cmp	r3, r2
 800a0f8:	d007      	beq.n	800a10a <HAL_GPIO_Init+0x1e6>
 800a0fa:	687b      	ldr	r3, [r7, #4]
 800a0fc:	4a46      	ldr	r2, [pc, #280]	; (800a218 <HAL_GPIO_Init+0x2f4>)
 800a0fe:	4293      	cmp	r3, r2
 800a100:	d101      	bne.n	800a106 <HAL_GPIO_Init+0x1e2>
 800a102:	2305      	movs	r3, #5
 800a104:	e00a      	b.n	800a11c <HAL_GPIO_Init+0x1f8>
 800a106:	2306      	movs	r3, #6
 800a108:	e008      	b.n	800a11c <HAL_GPIO_Init+0x1f8>
 800a10a:	2304      	movs	r3, #4
 800a10c:	e006      	b.n	800a11c <HAL_GPIO_Init+0x1f8>
 800a10e:	2303      	movs	r3, #3
 800a110:	e004      	b.n	800a11c <HAL_GPIO_Init+0x1f8>
 800a112:	2302      	movs	r3, #2
 800a114:	e002      	b.n	800a11c <HAL_GPIO_Init+0x1f8>
 800a116:	2301      	movs	r3, #1
 800a118:	e000      	b.n	800a11c <HAL_GPIO_Init+0x1f8>
 800a11a:	2300      	movs	r3, #0
 800a11c:	697a      	ldr	r2, [r7, #20]
 800a11e:	2103      	movs	r1, #3
 800a120:	400a      	ands	r2, r1
 800a122:	0092      	lsls	r2, r2, #2
 800a124:	4093      	lsls	r3, r2
 800a126:	693a      	ldr	r2, [r7, #16]
 800a128:	4313      	orrs	r3, r2
 800a12a:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2U] = temp;
 800a12c:	4935      	ldr	r1, [pc, #212]	; (800a204 <HAL_GPIO_Init+0x2e0>)
 800a12e:	697b      	ldr	r3, [r7, #20]
 800a130:	089b      	lsrs	r3, r3, #2
 800a132:	3302      	adds	r3, #2
 800a134:	009b      	lsls	r3, r3, #2
 800a136:	693a      	ldr	r2, [r7, #16]
 800a138:	505a      	str	r2, [r3, r1]
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800a13a:	4b38      	ldr	r3, [pc, #224]	; (800a21c <HAL_GPIO_Init+0x2f8>)
 800a13c:	681b      	ldr	r3, [r3, #0]
 800a13e:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800a140:	68fb      	ldr	r3, [r7, #12]
 800a142:	43da      	mvns	r2, r3
 800a144:	693b      	ldr	r3, [r7, #16]
 800a146:	4013      	ands	r3, r2
 800a148:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800a14a:	683b      	ldr	r3, [r7, #0]
 800a14c:	685a      	ldr	r2, [r3, #4]
 800a14e:	2380      	movs	r3, #128	; 0x80
 800a150:	025b      	lsls	r3, r3, #9
 800a152:	4013      	ands	r3, r2
 800a154:	d003      	beq.n	800a15e <HAL_GPIO_Init+0x23a>
        {
          temp |= iocurrent;
 800a156:	693a      	ldr	r2, [r7, #16]
 800a158:	68fb      	ldr	r3, [r7, #12]
 800a15a:	4313      	orrs	r3, r2
 800a15c:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR = temp;
 800a15e:	4b2f      	ldr	r3, [pc, #188]	; (800a21c <HAL_GPIO_Init+0x2f8>)
 800a160:	693a      	ldr	r2, [r7, #16]
 800a162:	601a      	str	r2, [r3, #0]

        temp = EXTI->EMR;
 800a164:	4b2d      	ldr	r3, [pc, #180]	; (800a21c <HAL_GPIO_Init+0x2f8>)
 800a166:	685b      	ldr	r3, [r3, #4]
 800a168:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800a16a:	68fb      	ldr	r3, [r7, #12]
 800a16c:	43da      	mvns	r2, r3
 800a16e:	693b      	ldr	r3, [r7, #16]
 800a170:	4013      	ands	r3, r2
 800a172:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800a174:	683b      	ldr	r3, [r7, #0]
 800a176:	685a      	ldr	r2, [r3, #4]
 800a178:	2380      	movs	r3, #128	; 0x80
 800a17a:	029b      	lsls	r3, r3, #10
 800a17c:	4013      	ands	r3, r2
 800a17e:	d003      	beq.n	800a188 <HAL_GPIO_Init+0x264>
        {
          temp |= iocurrent;
 800a180:	693a      	ldr	r2, [r7, #16]
 800a182:	68fb      	ldr	r3, [r7, #12]
 800a184:	4313      	orrs	r3, r2
 800a186:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR = temp;
 800a188:	4b24      	ldr	r3, [pc, #144]	; (800a21c <HAL_GPIO_Init+0x2f8>)
 800a18a:	693a      	ldr	r2, [r7, #16]
 800a18c:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800a18e:	4b23      	ldr	r3, [pc, #140]	; (800a21c <HAL_GPIO_Init+0x2f8>)
 800a190:	689b      	ldr	r3, [r3, #8]
 800a192:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800a194:	68fb      	ldr	r3, [r7, #12]
 800a196:	43da      	mvns	r2, r3
 800a198:	693b      	ldr	r3, [r7, #16]
 800a19a:	4013      	ands	r3, r2
 800a19c:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800a19e:	683b      	ldr	r3, [r7, #0]
 800a1a0:	685a      	ldr	r2, [r3, #4]
 800a1a2:	2380      	movs	r3, #128	; 0x80
 800a1a4:	035b      	lsls	r3, r3, #13
 800a1a6:	4013      	ands	r3, r2
 800a1a8:	d003      	beq.n	800a1b2 <HAL_GPIO_Init+0x28e>
        {
          temp |= iocurrent;
 800a1aa:	693a      	ldr	r2, [r7, #16]
 800a1ac:	68fb      	ldr	r3, [r7, #12]
 800a1ae:	4313      	orrs	r3, r2
 800a1b0:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR = temp;
 800a1b2:	4b1a      	ldr	r3, [pc, #104]	; (800a21c <HAL_GPIO_Init+0x2f8>)
 800a1b4:	693a      	ldr	r2, [r7, #16]
 800a1b6:	609a      	str	r2, [r3, #8]

        temp = EXTI->FTSR;
 800a1b8:	4b18      	ldr	r3, [pc, #96]	; (800a21c <HAL_GPIO_Init+0x2f8>)
 800a1ba:	68db      	ldr	r3, [r3, #12]
 800a1bc:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800a1be:	68fb      	ldr	r3, [r7, #12]
 800a1c0:	43da      	mvns	r2, r3
 800a1c2:	693b      	ldr	r3, [r7, #16]
 800a1c4:	4013      	ands	r3, r2
 800a1c6:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800a1c8:	683b      	ldr	r3, [r7, #0]
 800a1ca:	685a      	ldr	r2, [r3, #4]
 800a1cc:	2380      	movs	r3, #128	; 0x80
 800a1ce:	039b      	lsls	r3, r3, #14
 800a1d0:	4013      	ands	r3, r2
 800a1d2:	d003      	beq.n	800a1dc <HAL_GPIO_Init+0x2b8>
        {
          temp |= iocurrent;
 800a1d4:	693a      	ldr	r2, [r7, #16]
 800a1d6:	68fb      	ldr	r3, [r7, #12]
 800a1d8:	4313      	orrs	r3, r2
 800a1da:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR = temp;
 800a1dc:	4b0f      	ldr	r3, [pc, #60]	; (800a21c <HAL_GPIO_Init+0x2f8>)
 800a1de:	693a      	ldr	r2, [r7, #16]
 800a1e0:	60da      	str	r2, [r3, #12]
      }
    }
    position++;
 800a1e2:	697b      	ldr	r3, [r7, #20]
 800a1e4:	3301      	adds	r3, #1
 800a1e6:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0)
 800a1e8:	683b      	ldr	r3, [r7, #0]
 800a1ea:	681a      	ldr	r2, [r3, #0]
 800a1ec:	697b      	ldr	r3, [r7, #20]
 800a1ee:	40da      	lsrs	r2, r3
 800a1f0:	1e13      	subs	r3, r2, #0
 800a1f2:	d000      	beq.n	800a1f6 <HAL_GPIO_Init+0x2d2>
 800a1f4:	e6a2      	b.n	8009f3c <HAL_GPIO_Init+0x18>
  }
}
 800a1f6:	46c0      	nop			; (mov r8, r8)
 800a1f8:	46c0      	nop			; (mov r8, r8)
 800a1fa:	46bd      	mov	sp, r7
 800a1fc:	b006      	add	sp, #24
 800a1fe:	bd80      	pop	{r7, pc}
 800a200:	40021000 	.word	0x40021000
 800a204:	40010000 	.word	0x40010000
 800a208:	50000400 	.word	0x50000400
 800a20c:	50000800 	.word	0x50000800
 800a210:	50000c00 	.word	0x50000c00
 800a214:	50001000 	.word	0x50001000
 800a218:	50001c00 	.word	0x50001c00
 800a21c:	40010400 	.word	0x40010400

0800a220 <HAL_GPIO_WritePin>:
  *                        GPIO_PIN_RESET: to clear the port pin
  *                        GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800a220:	b580      	push	{r7, lr}
 800a222:	b082      	sub	sp, #8
 800a224:	af00      	add	r7, sp, #0
 800a226:	6078      	str	r0, [r7, #4]
 800a228:	0008      	movs	r0, r1
 800a22a:	0011      	movs	r1, r2
 800a22c:	1cbb      	adds	r3, r7, #2
 800a22e:	1c02      	adds	r2, r0, #0
 800a230:	801a      	strh	r2, [r3, #0]
 800a232:	1c7b      	adds	r3, r7, #1
 800a234:	1c0a      	adds	r2, r1, #0
 800a236:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));
  
  if(PinState != GPIO_PIN_RESET)
 800a238:	1c7b      	adds	r3, r7, #1
 800a23a:	781b      	ldrb	r3, [r3, #0]
 800a23c:	2b00      	cmp	r3, #0
 800a23e:	d004      	beq.n	800a24a <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = GPIO_Pin;
 800a240:	1cbb      	adds	r3, r7, #2
 800a242:	881a      	ldrh	r2, [r3, #0]
 800a244:	687b      	ldr	r3, [r7, #4]
 800a246:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
  }
}
 800a248:	e003      	b.n	800a252 <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = GPIO_Pin ;
 800a24a:	1cbb      	adds	r3, r7, #2
 800a24c:	881a      	ldrh	r2, [r3, #0]
 800a24e:	687b      	ldr	r3, [r7, #4]
 800a250:	629a      	str	r2, [r3, #40]	; 0x28
}
 800a252:	46c0      	nop			; (mov r8, r8)
 800a254:	46bd      	mov	sp, r7
 800a256:	b002      	add	sp, #8
 800a258:	bd80      	pop	{r7, pc}
	...

0800a25c <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin Specifies the pins connected to the EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 800a25c:	b580      	push	{r7, lr}
 800a25e:	b082      	sub	sp, #8
 800a260:	af00      	add	r7, sp, #0
 800a262:	0002      	movs	r2, r0
 800a264:	1dbb      	adds	r3, r7, #6
 800a266:	801a      	strh	r2, [r3, #0]
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
 800a268:	4b09      	ldr	r3, [pc, #36]	; (800a290 <HAL_GPIO_EXTI_IRQHandler+0x34>)
 800a26a:	695b      	ldr	r3, [r3, #20]
 800a26c:	1dba      	adds	r2, r7, #6
 800a26e:	8812      	ldrh	r2, [r2, #0]
 800a270:	4013      	ands	r3, r2
 800a272:	d008      	beq.n	800a286 <HAL_GPIO_EXTI_IRQHandler+0x2a>
  { 
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 800a274:	4b06      	ldr	r3, [pc, #24]	; (800a290 <HAL_GPIO_EXTI_IRQHandler+0x34>)
 800a276:	1dba      	adds	r2, r7, #6
 800a278:	8812      	ldrh	r2, [r2, #0]
 800a27a:	615a      	str	r2, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 800a27c:	1dbb      	adds	r3, r7, #6
 800a27e:	881b      	ldrh	r3, [r3, #0]
 800a280:	0018      	movs	r0, r3
 800a282:	f012 fc8f 	bl	801cba4 <HAL_GPIO_EXTI_Callback>
  }
}
 800a286:	46c0      	nop			; (mov r8, r8)
 800a288:	46bd      	mov	sp, r7
 800a28a:	b002      	add	sp, #8
 800a28c:	bd80      	pop	{r7, pc}
 800a28e:	46c0      	nop			; (mov r8, r8)
 800a290:	40010400 	.word	0x40010400

0800a294 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 800a294:	b580      	push	{r7, lr}
 800a296:	b082      	sub	sp, #8
 800a298:	af00      	add	r7, sp, #0
 800a29a:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800a29c:	687b      	ldr	r3, [r7, #4]
 800a29e:	2b00      	cmp	r3, #0
 800a2a0:	d101      	bne.n	800a2a6 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 800a2a2:	2301      	movs	r3, #1
 800a2a4:	e082      	b.n	800a3ac <HAL_I2C_Init+0x118>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800a2a6:	687b      	ldr	r3, [r7, #4]
 800a2a8:	2241      	movs	r2, #65	; 0x41
 800a2aa:	5c9b      	ldrb	r3, [r3, r2]
 800a2ac:	b2db      	uxtb	r3, r3
 800a2ae:	2b00      	cmp	r3, #0
 800a2b0:	d107      	bne.n	800a2c2 <HAL_I2C_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800a2b2:	687b      	ldr	r3, [r7, #4]
 800a2b4:	2240      	movs	r2, #64	; 0x40
 800a2b6:	2100      	movs	r1, #0
 800a2b8:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 800a2ba:	687b      	ldr	r3, [r7, #4]
 800a2bc:	0018      	movs	r0, r3
 800a2be:	f000 f8af 	bl	800a420 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800a2c2:	687b      	ldr	r3, [r7, #4]
 800a2c4:	2241      	movs	r2, #65	; 0x41
 800a2c6:	2124      	movs	r1, #36	; 0x24
 800a2c8:	5499      	strb	r1, [r3, r2]

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800a2ca:	687b      	ldr	r3, [r7, #4]
 800a2cc:	681b      	ldr	r3, [r3, #0]
 800a2ce:	681a      	ldr	r2, [r3, #0]
 800a2d0:	687b      	ldr	r3, [r7, #4]
 800a2d2:	681b      	ldr	r3, [r3, #0]
 800a2d4:	2101      	movs	r1, #1
 800a2d6:	438a      	bics	r2, r1
 800a2d8:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800a2da:	687b      	ldr	r3, [r7, #4]
 800a2dc:	685a      	ldr	r2, [r3, #4]
 800a2de:	687b      	ldr	r3, [r7, #4]
 800a2e0:	681b      	ldr	r3, [r3, #0]
 800a2e2:	4934      	ldr	r1, [pc, #208]	; (800a3b4 <HAL_I2C_Init+0x120>)
 800a2e4:	400a      	ands	r2, r1
 800a2e6:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800a2e8:	687b      	ldr	r3, [r7, #4]
 800a2ea:	681b      	ldr	r3, [r3, #0]
 800a2ec:	689a      	ldr	r2, [r3, #8]
 800a2ee:	687b      	ldr	r3, [r7, #4]
 800a2f0:	681b      	ldr	r3, [r3, #0]
 800a2f2:	4931      	ldr	r1, [pc, #196]	; (800a3b8 <HAL_I2C_Init+0x124>)
 800a2f4:	400a      	ands	r2, r1
 800a2f6:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800a2f8:	687b      	ldr	r3, [r7, #4]
 800a2fa:	68db      	ldr	r3, [r3, #12]
 800a2fc:	2b01      	cmp	r3, #1
 800a2fe:	d108      	bne.n	800a312 <HAL_I2C_Init+0x7e>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800a300:	687b      	ldr	r3, [r7, #4]
 800a302:	689a      	ldr	r2, [r3, #8]
 800a304:	687b      	ldr	r3, [r7, #4]
 800a306:	681b      	ldr	r3, [r3, #0]
 800a308:	2180      	movs	r1, #128	; 0x80
 800a30a:	0209      	lsls	r1, r1, #8
 800a30c:	430a      	orrs	r2, r1
 800a30e:	609a      	str	r2, [r3, #8]
 800a310:	e007      	b.n	800a322 <HAL_I2C_Init+0x8e>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800a312:	687b      	ldr	r3, [r7, #4]
 800a314:	689a      	ldr	r2, [r3, #8]
 800a316:	687b      	ldr	r3, [r7, #4]
 800a318:	681b      	ldr	r3, [r3, #0]
 800a31a:	2184      	movs	r1, #132	; 0x84
 800a31c:	0209      	lsls	r1, r1, #8
 800a31e:	430a      	orrs	r2, r1
 800a320:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800a322:	687b      	ldr	r3, [r7, #4]
 800a324:	68db      	ldr	r3, [r3, #12]
 800a326:	2b02      	cmp	r3, #2
 800a328:	d104      	bne.n	800a334 <HAL_I2C_Init+0xa0>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 800a32a:	687b      	ldr	r3, [r7, #4]
 800a32c:	681b      	ldr	r3, [r3, #0]
 800a32e:	2280      	movs	r2, #128	; 0x80
 800a330:	0112      	lsls	r2, r2, #4
 800a332:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800a334:	687b      	ldr	r3, [r7, #4]
 800a336:	681b      	ldr	r3, [r3, #0]
 800a338:	685a      	ldr	r2, [r3, #4]
 800a33a:	687b      	ldr	r3, [r7, #4]
 800a33c:	681b      	ldr	r3, [r3, #0]
 800a33e:	491f      	ldr	r1, [pc, #124]	; (800a3bc <HAL_I2C_Init+0x128>)
 800a340:	430a      	orrs	r2, r1
 800a342:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800a344:	687b      	ldr	r3, [r7, #4]
 800a346:	681b      	ldr	r3, [r3, #0]
 800a348:	68da      	ldr	r2, [r3, #12]
 800a34a:	687b      	ldr	r3, [r7, #4]
 800a34c:	681b      	ldr	r3, [r3, #0]
 800a34e:	491a      	ldr	r1, [pc, #104]	; (800a3b8 <HAL_I2C_Init+0x124>)
 800a350:	400a      	ands	r2, r1
 800a352:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800a354:	687b      	ldr	r3, [r7, #4]
 800a356:	691a      	ldr	r2, [r3, #16]
 800a358:	687b      	ldr	r3, [r7, #4]
 800a35a:	695b      	ldr	r3, [r3, #20]
 800a35c:	431a      	orrs	r2, r3
 800a35e:	0011      	movs	r1, r2
 800a360:	687b      	ldr	r3, [r7, #4]
 800a362:	699b      	ldr	r3, [r3, #24]
 800a364:	021a      	lsls	r2, r3, #8
 800a366:	687b      	ldr	r3, [r7, #4]
 800a368:	681b      	ldr	r3, [r3, #0]
 800a36a:	430a      	orrs	r2, r1
 800a36c:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800a36e:	687b      	ldr	r3, [r7, #4]
 800a370:	69d9      	ldr	r1, [r3, #28]
 800a372:	687b      	ldr	r3, [r7, #4]
 800a374:	6a1a      	ldr	r2, [r3, #32]
 800a376:	687b      	ldr	r3, [r7, #4]
 800a378:	681b      	ldr	r3, [r3, #0]
 800a37a:	430a      	orrs	r2, r1
 800a37c:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 800a37e:	687b      	ldr	r3, [r7, #4]
 800a380:	681b      	ldr	r3, [r3, #0]
 800a382:	681a      	ldr	r2, [r3, #0]
 800a384:	687b      	ldr	r3, [r7, #4]
 800a386:	681b      	ldr	r3, [r3, #0]
 800a388:	2101      	movs	r1, #1
 800a38a:	430a      	orrs	r2, r1
 800a38c:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800a38e:	687b      	ldr	r3, [r7, #4]
 800a390:	2200      	movs	r2, #0
 800a392:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 800a394:	687b      	ldr	r3, [r7, #4]
 800a396:	2241      	movs	r2, #65	; 0x41
 800a398:	2120      	movs	r1, #32
 800a39a:	5499      	strb	r1, [r3, r2]
  hi2c->PreviousState = I2C_STATE_NONE;
 800a39c:	687b      	ldr	r3, [r7, #4]
 800a39e:	2200      	movs	r2, #0
 800a3a0:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800a3a2:	687b      	ldr	r3, [r7, #4]
 800a3a4:	2242      	movs	r2, #66	; 0x42
 800a3a6:	2100      	movs	r1, #0
 800a3a8:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800a3aa:	2300      	movs	r3, #0
}
 800a3ac:	0018      	movs	r0, r3
 800a3ae:	46bd      	mov	sp, r7
 800a3b0:	b002      	add	sp, #8
 800a3b2:	bd80      	pop	{r7, pc}
 800a3b4:	f0ffffff 	.word	0xf0ffffff
 800a3b8:	ffff7fff 	.word	0xffff7fff
 800a3bc:	02008000 	.word	0x02008000

0800a3c0 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
 800a3c0:	b580      	push	{r7, lr}
 800a3c2:	b082      	sub	sp, #8
 800a3c4:	af00      	add	r7, sp, #0
 800a3c6:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800a3c8:	687b      	ldr	r3, [r7, #4]
 800a3ca:	2b00      	cmp	r3, #0
 800a3cc:	d101      	bne.n	800a3d2 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
 800a3ce:	2301      	movs	r3, #1
 800a3d0:	e022      	b.n	800a418 <HAL_I2C_DeInit+0x58>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
 800a3d2:	687b      	ldr	r3, [r7, #4]
 800a3d4:	2241      	movs	r2, #65	; 0x41
 800a3d6:	2124      	movs	r1, #36	; 0x24
 800a3d8:	5499      	strb	r1, [r3, r2]

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
 800a3da:	687b      	ldr	r3, [r7, #4]
 800a3dc:	681b      	ldr	r3, [r3, #0]
 800a3de:	681a      	ldr	r2, [r3, #0]
 800a3e0:	687b      	ldr	r3, [r7, #4]
 800a3e2:	681b      	ldr	r3, [r3, #0]
 800a3e4:	2101      	movs	r1, #1
 800a3e6:	438a      	bics	r2, r1
 800a3e8:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
 800a3ea:	687b      	ldr	r3, [r7, #4]
 800a3ec:	0018      	movs	r0, r3
 800a3ee:	f000 f81f 	bl	800a430 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800a3f2:	687b      	ldr	r3, [r7, #4]
 800a3f4:	2200      	movs	r2, #0
 800a3f6:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
 800a3f8:	687b      	ldr	r3, [r7, #4]
 800a3fa:	2241      	movs	r2, #65	; 0x41
 800a3fc:	2100      	movs	r1, #0
 800a3fe:	5499      	strb	r1, [r3, r2]
  hi2c->PreviousState = I2C_STATE_NONE;
 800a400:	687b      	ldr	r3, [r7, #4]
 800a402:	2200      	movs	r2, #0
 800a404:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800a406:	687b      	ldr	r3, [r7, #4]
 800a408:	2242      	movs	r2, #66	; 0x42
 800a40a:	2100      	movs	r1, #0
 800a40c:	5499      	strb	r1, [r3, r2]

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
 800a40e:	687b      	ldr	r3, [r7, #4]
 800a410:	2240      	movs	r2, #64	; 0x40
 800a412:	2100      	movs	r1, #0
 800a414:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800a416:	2300      	movs	r3, #0
}
 800a418:	0018      	movs	r0, r3
 800a41a:	46bd      	mov	sp, r7
 800a41c:	b002      	add	sp, #8
 800a41e:	bd80      	pop	{r7, pc}

0800a420 <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
 800a420:	b580      	push	{r7, lr}
 800a422:	b082      	sub	sp, #8
 800a424:	af00      	add	r7, sp, #0
 800a426:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
 800a428:	46c0      	nop			; (mov r8, r8)
 800a42a:	46bd      	mov	sp, r7
 800a42c:	b002      	add	sp, #8
 800a42e:	bd80      	pop	{r7, pc}

0800a430 <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
 800a430:	b580      	push	{r7, lr}
 800a432:	b082      	sub	sp, #8
 800a434:	af00      	add	r7, sp, #0
 800a436:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
 800a438:	46c0      	nop			; (mov r8, r8)
 800a43a:	46bd      	mov	sp, r7
 800a43c:	b002      	add	sp, #8
 800a43e:	bd80      	pop	{r7, pc}

0800a440 <HAL_I2C_Mem_Write>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800a440:	b590      	push	{r4, r7, lr}
 800a442:	b089      	sub	sp, #36	; 0x24
 800a444:	af02      	add	r7, sp, #8
 800a446:	60f8      	str	r0, [r7, #12]
 800a448:	000c      	movs	r4, r1
 800a44a:	0010      	movs	r0, r2
 800a44c:	0019      	movs	r1, r3
 800a44e:	230a      	movs	r3, #10
 800a450:	18fb      	adds	r3, r7, r3
 800a452:	1c22      	adds	r2, r4, #0
 800a454:	801a      	strh	r2, [r3, #0]
 800a456:	2308      	movs	r3, #8
 800a458:	18fb      	adds	r3, r7, r3
 800a45a:	1c02      	adds	r2, r0, #0
 800a45c:	801a      	strh	r2, [r3, #0]
 800a45e:	1dbb      	adds	r3, r7, #6
 800a460:	1c0a      	adds	r2, r1, #0
 800a462:	801a      	strh	r2, [r3, #0]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800a464:	68fb      	ldr	r3, [r7, #12]
 800a466:	2241      	movs	r2, #65	; 0x41
 800a468:	5c9b      	ldrb	r3, [r3, r2]
 800a46a:	b2db      	uxtb	r3, r3
 800a46c:	2b20      	cmp	r3, #32
 800a46e:	d000      	beq.n	800a472 <HAL_I2C_Mem_Write+0x32>
 800a470:	e10c      	b.n	800a68c <HAL_I2C_Mem_Write+0x24c>
  {
    if ((pData == NULL) || (Size == 0U))
 800a472:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a474:	2b00      	cmp	r3, #0
 800a476:	d004      	beq.n	800a482 <HAL_I2C_Mem_Write+0x42>
 800a478:	232c      	movs	r3, #44	; 0x2c
 800a47a:	18fb      	adds	r3, r7, r3
 800a47c:	881b      	ldrh	r3, [r3, #0]
 800a47e:	2b00      	cmp	r3, #0
 800a480:	d105      	bne.n	800a48e <HAL_I2C_Mem_Write+0x4e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 800a482:	68fb      	ldr	r3, [r7, #12]
 800a484:	2280      	movs	r2, #128	; 0x80
 800a486:	0092      	lsls	r2, r2, #2
 800a488:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
 800a48a:	2301      	movs	r3, #1
 800a48c:	e0ff      	b.n	800a68e <HAL_I2C_Mem_Write+0x24e>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800a48e:	68fb      	ldr	r3, [r7, #12]
 800a490:	2240      	movs	r2, #64	; 0x40
 800a492:	5c9b      	ldrb	r3, [r3, r2]
 800a494:	2b01      	cmp	r3, #1
 800a496:	d101      	bne.n	800a49c <HAL_I2C_Mem_Write+0x5c>
 800a498:	2302      	movs	r3, #2
 800a49a:	e0f8      	b.n	800a68e <HAL_I2C_Mem_Write+0x24e>
 800a49c:	68fb      	ldr	r3, [r7, #12]
 800a49e:	2240      	movs	r2, #64	; 0x40
 800a4a0:	2101      	movs	r1, #1
 800a4a2:	5499      	strb	r1, [r3, r2]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800a4a4:	f7fe fe4c 	bl	8009140 <HAL_GetTick>
 800a4a8:	0003      	movs	r3, r0
 800a4aa:	617b      	str	r3, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800a4ac:	2380      	movs	r3, #128	; 0x80
 800a4ae:	0219      	lsls	r1, r3, #8
 800a4b0:	68f8      	ldr	r0, [r7, #12]
 800a4b2:	697b      	ldr	r3, [r7, #20]
 800a4b4:	9300      	str	r3, [sp, #0]
 800a4b6:	2319      	movs	r3, #25
 800a4b8:	2201      	movs	r2, #1
 800a4ba:	f000 fb17 	bl	800aaec <I2C_WaitOnFlagUntilTimeout>
 800a4be:	1e03      	subs	r3, r0, #0
 800a4c0:	d001      	beq.n	800a4c6 <HAL_I2C_Mem_Write+0x86>
    {
      return HAL_ERROR;
 800a4c2:	2301      	movs	r3, #1
 800a4c4:	e0e3      	b.n	800a68e <HAL_I2C_Mem_Write+0x24e>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 800a4c6:	68fb      	ldr	r3, [r7, #12]
 800a4c8:	2241      	movs	r2, #65	; 0x41
 800a4ca:	2121      	movs	r1, #33	; 0x21
 800a4cc:	5499      	strb	r1, [r3, r2]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 800a4ce:	68fb      	ldr	r3, [r7, #12]
 800a4d0:	2242      	movs	r2, #66	; 0x42
 800a4d2:	2140      	movs	r1, #64	; 0x40
 800a4d4:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800a4d6:	68fb      	ldr	r3, [r7, #12]
 800a4d8:	2200      	movs	r2, #0
 800a4da:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800a4dc:	68fb      	ldr	r3, [r7, #12]
 800a4de:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800a4e0:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 800a4e2:	68fb      	ldr	r3, [r7, #12]
 800a4e4:	222c      	movs	r2, #44	; 0x2c
 800a4e6:	18ba      	adds	r2, r7, r2
 800a4e8:	8812      	ldrh	r2, [r2, #0]
 800a4ea:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 800a4ec:	68fb      	ldr	r3, [r7, #12]
 800a4ee:	2200      	movs	r2, #0
 800a4f0:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 800a4f2:	1dbb      	adds	r3, r7, #6
 800a4f4:	881c      	ldrh	r4, [r3, #0]
 800a4f6:	2308      	movs	r3, #8
 800a4f8:	18fb      	adds	r3, r7, r3
 800a4fa:	881a      	ldrh	r2, [r3, #0]
 800a4fc:	230a      	movs	r3, #10
 800a4fe:	18fb      	adds	r3, r7, r3
 800a500:	8819      	ldrh	r1, [r3, #0]
 800a502:	68f8      	ldr	r0, [r7, #12]
 800a504:	697b      	ldr	r3, [r7, #20]
 800a506:	9301      	str	r3, [sp, #4]
 800a508:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a50a:	9300      	str	r3, [sp, #0]
 800a50c:	0023      	movs	r3, r4
 800a50e:	f000 fa05 	bl	800a91c <I2C_RequestMemoryWrite>
 800a512:	1e03      	subs	r3, r0, #0
 800a514:	d005      	beq.n	800a522 <HAL_I2C_Mem_Write+0xe2>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800a516:	68fb      	ldr	r3, [r7, #12]
 800a518:	2240      	movs	r2, #64	; 0x40
 800a51a:	2100      	movs	r1, #0
 800a51c:	5499      	strb	r1, [r3, r2]
      return HAL_ERROR;
 800a51e:	2301      	movs	r3, #1
 800a520:	e0b5      	b.n	800a68e <HAL_I2C_Mem_Write+0x24e>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800a522:	68fb      	ldr	r3, [r7, #12]
 800a524:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a526:	b29b      	uxth	r3, r3
 800a528:	2bff      	cmp	r3, #255	; 0xff
 800a52a:	d911      	bls.n	800a550 <HAL_I2C_Mem_Write+0x110>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800a52c:	68fb      	ldr	r3, [r7, #12]
 800a52e:	22ff      	movs	r2, #255	; 0xff
 800a530:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800a532:	68fb      	ldr	r3, [r7, #12]
 800a534:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a536:	b2da      	uxtb	r2, r3
 800a538:	2380      	movs	r3, #128	; 0x80
 800a53a:	045c      	lsls	r4, r3, #17
 800a53c:	230a      	movs	r3, #10
 800a53e:	18fb      	adds	r3, r7, r3
 800a540:	8819      	ldrh	r1, [r3, #0]
 800a542:	68f8      	ldr	r0, [r7, #12]
 800a544:	2300      	movs	r3, #0
 800a546:	9300      	str	r3, [sp, #0]
 800a548:	0023      	movs	r3, r4
 800a54a:	f000 fbef 	bl	800ad2c <I2C_TransferConfig>
 800a54e:	e012      	b.n	800a576 <HAL_I2C_Mem_Write+0x136>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800a550:	68fb      	ldr	r3, [r7, #12]
 800a552:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a554:	b29a      	uxth	r2, r3
 800a556:	68fb      	ldr	r3, [r7, #12]
 800a558:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800a55a:	68fb      	ldr	r3, [r7, #12]
 800a55c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a55e:	b2da      	uxtb	r2, r3
 800a560:	2380      	movs	r3, #128	; 0x80
 800a562:	049c      	lsls	r4, r3, #18
 800a564:	230a      	movs	r3, #10
 800a566:	18fb      	adds	r3, r7, r3
 800a568:	8819      	ldrh	r1, [r3, #0]
 800a56a:	68f8      	ldr	r0, [r7, #12]
 800a56c:	2300      	movs	r3, #0
 800a56e:	9300      	str	r3, [sp, #0]
 800a570:	0023      	movs	r3, r4
 800a572:	f000 fbdb 	bl	800ad2c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800a576:	697a      	ldr	r2, [r7, #20]
 800a578:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800a57a:	68fb      	ldr	r3, [r7, #12]
 800a57c:	0018      	movs	r0, r3
 800a57e:	f000 faf4 	bl	800ab6a <I2C_WaitOnTXISFlagUntilTimeout>
 800a582:	1e03      	subs	r3, r0, #0
 800a584:	d001      	beq.n	800a58a <HAL_I2C_Mem_Write+0x14a>
      {
        return HAL_ERROR;
 800a586:	2301      	movs	r3, #1
 800a588:	e081      	b.n	800a68e <HAL_I2C_Mem_Write+0x24e>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800a58a:	68fb      	ldr	r3, [r7, #12]
 800a58c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a58e:	781a      	ldrb	r2, [r3, #0]
 800a590:	68fb      	ldr	r3, [r7, #12]
 800a592:	681b      	ldr	r3, [r3, #0]
 800a594:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800a596:	68fb      	ldr	r3, [r7, #12]
 800a598:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a59a:	1c5a      	adds	r2, r3, #1
 800a59c:	68fb      	ldr	r3, [r7, #12]
 800a59e:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
 800a5a0:	68fb      	ldr	r3, [r7, #12]
 800a5a2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a5a4:	b29b      	uxth	r3, r3
 800a5a6:	3b01      	subs	r3, #1
 800a5a8:	b29a      	uxth	r2, r3
 800a5aa:	68fb      	ldr	r3, [r7, #12]
 800a5ac:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
 800a5ae:	68fb      	ldr	r3, [r7, #12]
 800a5b0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a5b2:	3b01      	subs	r3, #1
 800a5b4:	b29a      	uxth	r2, r3
 800a5b6:	68fb      	ldr	r3, [r7, #12]
 800a5b8:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800a5ba:	68fb      	ldr	r3, [r7, #12]
 800a5bc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a5be:	b29b      	uxth	r3, r3
 800a5c0:	2b00      	cmp	r3, #0
 800a5c2:	d03a      	beq.n	800a63a <HAL_I2C_Mem_Write+0x1fa>
 800a5c4:	68fb      	ldr	r3, [r7, #12]
 800a5c6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a5c8:	2b00      	cmp	r3, #0
 800a5ca:	d136      	bne.n	800a63a <HAL_I2C_Mem_Write+0x1fa>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800a5cc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800a5ce:	68f8      	ldr	r0, [r7, #12]
 800a5d0:	697b      	ldr	r3, [r7, #20]
 800a5d2:	9300      	str	r3, [sp, #0]
 800a5d4:	0013      	movs	r3, r2
 800a5d6:	2200      	movs	r2, #0
 800a5d8:	2180      	movs	r1, #128	; 0x80
 800a5da:	f000 fa87 	bl	800aaec <I2C_WaitOnFlagUntilTimeout>
 800a5de:	1e03      	subs	r3, r0, #0
 800a5e0:	d001      	beq.n	800a5e6 <HAL_I2C_Mem_Write+0x1a6>
        {
          return HAL_ERROR;
 800a5e2:	2301      	movs	r3, #1
 800a5e4:	e053      	b.n	800a68e <HAL_I2C_Mem_Write+0x24e>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800a5e6:	68fb      	ldr	r3, [r7, #12]
 800a5e8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a5ea:	b29b      	uxth	r3, r3
 800a5ec:	2bff      	cmp	r3, #255	; 0xff
 800a5ee:	d911      	bls.n	800a614 <HAL_I2C_Mem_Write+0x1d4>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800a5f0:	68fb      	ldr	r3, [r7, #12]
 800a5f2:	22ff      	movs	r2, #255	; 0xff
 800a5f4:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800a5f6:	68fb      	ldr	r3, [r7, #12]
 800a5f8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a5fa:	b2da      	uxtb	r2, r3
 800a5fc:	2380      	movs	r3, #128	; 0x80
 800a5fe:	045c      	lsls	r4, r3, #17
 800a600:	230a      	movs	r3, #10
 800a602:	18fb      	adds	r3, r7, r3
 800a604:	8819      	ldrh	r1, [r3, #0]
 800a606:	68f8      	ldr	r0, [r7, #12]
 800a608:	2300      	movs	r3, #0
 800a60a:	9300      	str	r3, [sp, #0]
 800a60c:	0023      	movs	r3, r4
 800a60e:	f000 fb8d 	bl	800ad2c <I2C_TransferConfig>
 800a612:	e012      	b.n	800a63a <HAL_I2C_Mem_Write+0x1fa>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800a614:	68fb      	ldr	r3, [r7, #12]
 800a616:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a618:	b29a      	uxth	r2, r3
 800a61a:	68fb      	ldr	r3, [r7, #12]
 800a61c:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800a61e:	68fb      	ldr	r3, [r7, #12]
 800a620:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a622:	b2da      	uxtb	r2, r3
 800a624:	2380      	movs	r3, #128	; 0x80
 800a626:	049c      	lsls	r4, r3, #18
 800a628:	230a      	movs	r3, #10
 800a62a:	18fb      	adds	r3, r7, r3
 800a62c:	8819      	ldrh	r1, [r3, #0]
 800a62e:	68f8      	ldr	r0, [r7, #12]
 800a630:	2300      	movs	r3, #0
 800a632:	9300      	str	r3, [sp, #0]
 800a634:	0023      	movs	r3, r4
 800a636:	f000 fb79 	bl	800ad2c <I2C_TransferConfig>
        }
      }

    }
    while (hi2c->XferCount > 0U);
 800a63a:	68fb      	ldr	r3, [r7, #12]
 800a63c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a63e:	b29b      	uxth	r3, r3
 800a640:	2b00      	cmp	r3, #0
 800a642:	d198      	bne.n	800a576 <HAL_I2C_Mem_Write+0x136>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800a644:	697a      	ldr	r2, [r7, #20]
 800a646:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800a648:	68fb      	ldr	r3, [r7, #12]
 800a64a:	0018      	movs	r0, r3
 800a64c:	f000 facc 	bl	800abe8 <I2C_WaitOnSTOPFlagUntilTimeout>
 800a650:	1e03      	subs	r3, r0, #0
 800a652:	d001      	beq.n	800a658 <HAL_I2C_Mem_Write+0x218>
    {
      return HAL_ERROR;
 800a654:	2301      	movs	r3, #1
 800a656:	e01a      	b.n	800a68e <HAL_I2C_Mem_Write+0x24e>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800a658:	68fb      	ldr	r3, [r7, #12]
 800a65a:	681b      	ldr	r3, [r3, #0]
 800a65c:	2220      	movs	r2, #32
 800a65e:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800a660:	68fb      	ldr	r3, [r7, #12]
 800a662:	681b      	ldr	r3, [r3, #0]
 800a664:	685a      	ldr	r2, [r3, #4]
 800a666:	68fb      	ldr	r3, [r7, #12]
 800a668:	681b      	ldr	r3, [r3, #0]
 800a66a:	490b      	ldr	r1, [pc, #44]	; (800a698 <HAL_I2C_Mem_Write+0x258>)
 800a66c:	400a      	ands	r2, r1
 800a66e:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 800a670:	68fb      	ldr	r3, [r7, #12]
 800a672:	2241      	movs	r2, #65	; 0x41
 800a674:	2120      	movs	r1, #32
 800a676:	5499      	strb	r1, [r3, r2]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800a678:	68fb      	ldr	r3, [r7, #12]
 800a67a:	2242      	movs	r2, #66	; 0x42
 800a67c:	2100      	movs	r1, #0
 800a67e:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800a680:	68fb      	ldr	r3, [r7, #12]
 800a682:	2240      	movs	r2, #64	; 0x40
 800a684:	2100      	movs	r1, #0
 800a686:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 800a688:	2300      	movs	r3, #0
 800a68a:	e000      	b.n	800a68e <HAL_I2C_Mem_Write+0x24e>
  }
  else
  {
    return HAL_BUSY;
 800a68c:	2302      	movs	r3, #2
  }
}
 800a68e:	0018      	movs	r0, r3
 800a690:	46bd      	mov	sp, r7
 800a692:	b007      	add	sp, #28
 800a694:	bd90      	pop	{r4, r7, pc}
 800a696:	46c0      	nop			; (mov r8, r8)
 800a698:	fe00e800 	.word	0xfe00e800

0800a69c <HAL_I2C_Mem_Read>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800a69c:	b590      	push	{r4, r7, lr}
 800a69e:	b089      	sub	sp, #36	; 0x24
 800a6a0:	af02      	add	r7, sp, #8
 800a6a2:	60f8      	str	r0, [r7, #12]
 800a6a4:	000c      	movs	r4, r1
 800a6a6:	0010      	movs	r0, r2
 800a6a8:	0019      	movs	r1, r3
 800a6aa:	230a      	movs	r3, #10
 800a6ac:	18fb      	adds	r3, r7, r3
 800a6ae:	1c22      	adds	r2, r4, #0
 800a6b0:	801a      	strh	r2, [r3, #0]
 800a6b2:	2308      	movs	r3, #8
 800a6b4:	18fb      	adds	r3, r7, r3
 800a6b6:	1c02      	adds	r2, r0, #0
 800a6b8:	801a      	strh	r2, [r3, #0]
 800a6ba:	1dbb      	adds	r3, r7, #6
 800a6bc:	1c0a      	adds	r2, r1, #0
 800a6be:	801a      	strh	r2, [r3, #0]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800a6c0:	68fb      	ldr	r3, [r7, #12]
 800a6c2:	2241      	movs	r2, #65	; 0x41
 800a6c4:	5c9b      	ldrb	r3, [r3, r2]
 800a6c6:	b2db      	uxtb	r3, r3
 800a6c8:	2b20      	cmp	r3, #32
 800a6ca:	d000      	beq.n	800a6ce <HAL_I2C_Mem_Read+0x32>
 800a6cc:	e110      	b.n	800a8f0 <HAL_I2C_Mem_Read+0x254>
  {
    if ((pData == NULL) || (Size == 0U))
 800a6ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a6d0:	2b00      	cmp	r3, #0
 800a6d2:	d004      	beq.n	800a6de <HAL_I2C_Mem_Read+0x42>
 800a6d4:	232c      	movs	r3, #44	; 0x2c
 800a6d6:	18fb      	adds	r3, r7, r3
 800a6d8:	881b      	ldrh	r3, [r3, #0]
 800a6da:	2b00      	cmp	r3, #0
 800a6dc:	d105      	bne.n	800a6ea <HAL_I2C_Mem_Read+0x4e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 800a6de:	68fb      	ldr	r3, [r7, #12]
 800a6e0:	2280      	movs	r2, #128	; 0x80
 800a6e2:	0092      	lsls	r2, r2, #2
 800a6e4:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
 800a6e6:	2301      	movs	r3, #1
 800a6e8:	e103      	b.n	800a8f2 <HAL_I2C_Mem_Read+0x256>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800a6ea:	68fb      	ldr	r3, [r7, #12]
 800a6ec:	2240      	movs	r2, #64	; 0x40
 800a6ee:	5c9b      	ldrb	r3, [r3, r2]
 800a6f0:	2b01      	cmp	r3, #1
 800a6f2:	d101      	bne.n	800a6f8 <HAL_I2C_Mem_Read+0x5c>
 800a6f4:	2302      	movs	r3, #2
 800a6f6:	e0fc      	b.n	800a8f2 <HAL_I2C_Mem_Read+0x256>
 800a6f8:	68fb      	ldr	r3, [r7, #12]
 800a6fa:	2240      	movs	r2, #64	; 0x40
 800a6fc:	2101      	movs	r1, #1
 800a6fe:	5499      	strb	r1, [r3, r2]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800a700:	f7fe fd1e 	bl	8009140 <HAL_GetTick>
 800a704:	0003      	movs	r3, r0
 800a706:	617b      	str	r3, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800a708:	2380      	movs	r3, #128	; 0x80
 800a70a:	0219      	lsls	r1, r3, #8
 800a70c:	68f8      	ldr	r0, [r7, #12]
 800a70e:	697b      	ldr	r3, [r7, #20]
 800a710:	9300      	str	r3, [sp, #0]
 800a712:	2319      	movs	r3, #25
 800a714:	2201      	movs	r2, #1
 800a716:	f000 f9e9 	bl	800aaec <I2C_WaitOnFlagUntilTimeout>
 800a71a:	1e03      	subs	r3, r0, #0
 800a71c:	d001      	beq.n	800a722 <HAL_I2C_Mem_Read+0x86>
    {
      return HAL_ERROR;
 800a71e:	2301      	movs	r3, #1
 800a720:	e0e7      	b.n	800a8f2 <HAL_I2C_Mem_Read+0x256>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 800a722:	68fb      	ldr	r3, [r7, #12]
 800a724:	2241      	movs	r2, #65	; 0x41
 800a726:	2122      	movs	r1, #34	; 0x22
 800a728:	5499      	strb	r1, [r3, r2]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 800a72a:	68fb      	ldr	r3, [r7, #12]
 800a72c:	2242      	movs	r2, #66	; 0x42
 800a72e:	2140      	movs	r1, #64	; 0x40
 800a730:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800a732:	68fb      	ldr	r3, [r7, #12]
 800a734:	2200      	movs	r2, #0
 800a736:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800a738:	68fb      	ldr	r3, [r7, #12]
 800a73a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800a73c:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 800a73e:	68fb      	ldr	r3, [r7, #12]
 800a740:	222c      	movs	r2, #44	; 0x2c
 800a742:	18ba      	adds	r2, r7, r2
 800a744:	8812      	ldrh	r2, [r2, #0]
 800a746:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 800a748:	68fb      	ldr	r3, [r7, #12]
 800a74a:	2200      	movs	r2, #0
 800a74c:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 800a74e:	1dbb      	adds	r3, r7, #6
 800a750:	881c      	ldrh	r4, [r3, #0]
 800a752:	2308      	movs	r3, #8
 800a754:	18fb      	adds	r3, r7, r3
 800a756:	881a      	ldrh	r2, [r3, #0]
 800a758:	230a      	movs	r3, #10
 800a75a:	18fb      	adds	r3, r7, r3
 800a75c:	8819      	ldrh	r1, [r3, #0]
 800a75e:	68f8      	ldr	r0, [r7, #12]
 800a760:	697b      	ldr	r3, [r7, #20]
 800a762:	9301      	str	r3, [sp, #4]
 800a764:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a766:	9300      	str	r3, [sp, #0]
 800a768:	0023      	movs	r3, r4
 800a76a:	f000 f93b 	bl	800a9e4 <I2C_RequestMemoryRead>
 800a76e:	1e03      	subs	r3, r0, #0
 800a770:	d005      	beq.n	800a77e <HAL_I2C_Mem_Read+0xe2>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800a772:	68fb      	ldr	r3, [r7, #12]
 800a774:	2240      	movs	r2, #64	; 0x40
 800a776:	2100      	movs	r1, #0
 800a778:	5499      	strb	r1, [r3, r2]
      return HAL_ERROR;
 800a77a:	2301      	movs	r3, #1
 800a77c:	e0b9      	b.n	800a8f2 <HAL_I2C_Mem_Read+0x256>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800a77e:	68fb      	ldr	r3, [r7, #12]
 800a780:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a782:	b29b      	uxth	r3, r3
 800a784:	2bff      	cmp	r3, #255	; 0xff
 800a786:	d911      	bls.n	800a7ac <HAL_I2C_Mem_Read+0x110>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800a788:	68fb      	ldr	r3, [r7, #12]
 800a78a:	22ff      	movs	r2, #255	; 0xff
 800a78c:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 800a78e:	68fb      	ldr	r3, [r7, #12]
 800a790:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a792:	b2da      	uxtb	r2, r3
 800a794:	2380      	movs	r3, #128	; 0x80
 800a796:	045c      	lsls	r4, r3, #17
 800a798:	230a      	movs	r3, #10
 800a79a:	18fb      	adds	r3, r7, r3
 800a79c:	8819      	ldrh	r1, [r3, #0]
 800a79e:	68f8      	ldr	r0, [r7, #12]
 800a7a0:	4b56      	ldr	r3, [pc, #344]	; (800a8fc <HAL_I2C_Mem_Read+0x260>)
 800a7a2:	9300      	str	r3, [sp, #0]
 800a7a4:	0023      	movs	r3, r4
 800a7a6:	f000 fac1 	bl	800ad2c <I2C_TransferConfig>
 800a7aa:	e012      	b.n	800a7d2 <HAL_I2C_Mem_Read+0x136>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800a7ac:	68fb      	ldr	r3, [r7, #12]
 800a7ae:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a7b0:	b29a      	uxth	r2, r3
 800a7b2:	68fb      	ldr	r3, [r7, #12]
 800a7b4:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 800a7b6:	68fb      	ldr	r3, [r7, #12]
 800a7b8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a7ba:	b2da      	uxtb	r2, r3
 800a7bc:	2380      	movs	r3, #128	; 0x80
 800a7be:	049c      	lsls	r4, r3, #18
 800a7c0:	230a      	movs	r3, #10
 800a7c2:	18fb      	adds	r3, r7, r3
 800a7c4:	8819      	ldrh	r1, [r3, #0]
 800a7c6:	68f8      	ldr	r0, [r7, #12]
 800a7c8:	4b4c      	ldr	r3, [pc, #304]	; (800a8fc <HAL_I2C_Mem_Read+0x260>)
 800a7ca:	9300      	str	r3, [sp, #0]
 800a7cc:	0023      	movs	r3, r4
 800a7ce:	f000 faad 	bl	800ad2c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 800a7d2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800a7d4:	68f8      	ldr	r0, [r7, #12]
 800a7d6:	697b      	ldr	r3, [r7, #20]
 800a7d8:	9300      	str	r3, [sp, #0]
 800a7da:	0013      	movs	r3, r2
 800a7dc:	2200      	movs	r2, #0
 800a7de:	2104      	movs	r1, #4
 800a7e0:	f000 f984 	bl	800aaec <I2C_WaitOnFlagUntilTimeout>
 800a7e4:	1e03      	subs	r3, r0, #0
 800a7e6:	d001      	beq.n	800a7ec <HAL_I2C_Mem_Read+0x150>
      {
        return HAL_ERROR;
 800a7e8:	2301      	movs	r3, #1
 800a7ea:	e082      	b.n	800a8f2 <HAL_I2C_Mem_Read+0x256>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800a7ec:	68fb      	ldr	r3, [r7, #12]
 800a7ee:	681b      	ldr	r3, [r3, #0]
 800a7f0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a7f2:	68fb      	ldr	r3, [r7, #12]
 800a7f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a7f6:	b2d2      	uxtb	r2, r2
 800a7f8:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800a7fa:	68fb      	ldr	r3, [r7, #12]
 800a7fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a7fe:	1c5a      	adds	r2, r3, #1
 800a800:	68fb      	ldr	r3, [r7, #12]
 800a802:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
 800a804:	68fb      	ldr	r3, [r7, #12]
 800a806:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a808:	3b01      	subs	r3, #1
 800a80a:	b29a      	uxth	r2, r3
 800a80c:	68fb      	ldr	r3, [r7, #12]
 800a80e:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 800a810:	68fb      	ldr	r3, [r7, #12]
 800a812:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a814:	b29b      	uxth	r3, r3
 800a816:	3b01      	subs	r3, #1
 800a818:	b29a      	uxth	r2, r3
 800a81a:	68fb      	ldr	r3, [r7, #12]
 800a81c:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800a81e:	68fb      	ldr	r3, [r7, #12]
 800a820:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a822:	b29b      	uxth	r3, r3
 800a824:	2b00      	cmp	r3, #0
 800a826:	d03a      	beq.n	800a89e <HAL_I2C_Mem_Read+0x202>
 800a828:	68fb      	ldr	r3, [r7, #12]
 800a82a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a82c:	2b00      	cmp	r3, #0
 800a82e:	d136      	bne.n	800a89e <HAL_I2C_Mem_Read+0x202>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800a830:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800a832:	68f8      	ldr	r0, [r7, #12]
 800a834:	697b      	ldr	r3, [r7, #20]
 800a836:	9300      	str	r3, [sp, #0]
 800a838:	0013      	movs	r3, r2
 800a83a:	2200      	movs	r2, #0
 800a83c:	2180      	movs	r1, #128	; 0x80
 800a83e:	f000 f955 	bl	800aaec <I2C_WaitOnFlagUntilTimeout>
 800a842:	1e03      	subs	r3, r0, #0
 800a844:	d001      	beq.n	800a84a <HAL_I2C_Mem_Read+0x1ae>
        {
          return HAL_ERROR;
 800a846:	2301      	movs	r3, #1
 800a848:	e053      	b.n	800a8f2 <HAL_I2C_Mem_Read+0x256>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800a84a:	68fb      	ldr	r3, [r7, #12]
 800a84c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a84e:	b29b      	uxth	r3, r3
 800a850:	2bff      	cmp	r3, #255	; 0xff
 800a852:	d911      	bls.n	800a878 <HAL_I2C_Mem_Read+0x1dc>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800a854:	68fb      	ldr	r3, [r7, #12]
 800a856:	22ff      	movs	r2, #255	; 0xff
 800a858:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800a85a:	68fb      	ldr	r3, [r7, #12]
 800a85c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a85e:	b2da      	uxtb	r2, r3
 800a860:	2380      	movs	r3, #128	; 0x80
 800a862:	045c      	lsls	r4, r3, #17
 800a864:	230a      	movs	r3, #10
 800a866:	18fb      	adds	r3, r7, r3
 800a868:	8819      	ldrh	r1, [r3, #0]
 800a86a:	68f8      	ldr	r0, [r7, #12]
 800a86c:	2300      	movs	r3, #0
 800a86e:	9300      	str	r3, [sp, #0]
 800a870:	0023      	movs	r3, r4
 800a872:	f000 fa5b 	bl	800ad2c <I2C_TransferConfig>
 800a876:	e012      	b.n	800a89e <HAL_I2C_Mem_Read+0x202>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800a878:	68fb      	ldr	r3, [r7, #12]
 800a87a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a87c:	b29a      	uxth	r2, r3
 800a87e:	68fb      	ldr	r3, [r7, #12]
 800a880:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800a882:	68fb      	ldr	r3, [r7, #12]
 800a884:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a886:	b2da      	uxtb	r2, r3
 800a888:	2380      	movs	r3, #128	; 0x80
 800a88a:	049c      	lsls	r4, r3, #18
 800a88c:	230a      	movs	r3, #10
 800a88e:	18fb      	adds	r3, r7, r3
 800a890:	8819      	ldrh	r1, [r3, #0]
 800a892:	68f8      	ldr	r0, [r7, #12]
 800a894:	2300      	movs	r3, #0
 800a896:	9300      	str	r3, [sp, #0]
 800a898:	0023      	movs	r3, r4
 800a89a:	f000 fa47 	bl	800ad2c <I2C_TransferConfig>
        }
      }
    }
    while (hi2c->XferCount > 0U);
 800a89e:	68fb      	ldr	r3, [r7, #12]
 800a8a0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800a8a2:	b29b      	uxth	r3, r3
 800a8a4:	2b00      	cmp	r3, #0
 800a8a6:	d194      	bne.n	800a7d2 <HAL_I2C_Mem_Read+0x136>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800a8a8:	697a      	ldr	r2, [r7, #20]
 800a8aa:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800a8ac:	68fb      	ldr	r3, [r7, #12]
 800a8ae:	0018      	movs	r0, r3
 800a8b0:	f000 f99a 	bl	800abe8 <I2C_WaitOnSTOPFlagUntilTimeout>
 800a8b4:	1e03      	subs	r3, r0, #0
 800a8b6:	d001      	beq.n	800a8bc <HAL_I2C_Mem_Read+0x220>
    {
      return HAL_ERROR;
 800a8b8:	2301      	movs	r3, #1
 800a8ba:	e01a      	b.n	800a8f2 <HAL_I2C_Mem_Read+0x256>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800a8bc:	68fb      	ldr	r3, [r7, #12]
 800a8be:	681b      	ldr	r3, [r3, #0]
 800a8c0:	2220      	movs	r2, #32
 800a8c2:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800a8c4:	68fb      	ldr	r3, [r7, #12]
 800a8c6:	681b      	ldr	r3, [r3, #0]
 800a8c8:	685a      	ldr	r2, [r3, #4]
 800a8ca:	68fb      	ldr	r3, [r7, #12]
 800a8cc:	681b      	ldr	r3, [r3, #0]
 800a8ce:	490c      	ldr	r1, [pc, #48]	; (800a900 <HAL_I2C_Mem_Read+0x264>)
 800a8d0:	400a      	ands	r2, r1
 800a8d2:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 800a8d4:	68fb      	ldr	r3, [r7, #12]
 800a8d6:	2241      	movs	r2, #65	; 0x41
 800a8d8:	2120      	movs	r1, #32
 800a8da:	5499      	strb	r1, [r3, r2]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800a8dc:	68fb      	ldr	r3, [r7, #12]
 800a8de:	2242      	movs	r2, #66	; 0x42
 800a8e0:	2100      	movs	r1, #0
 800a8e2:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800a8e4:	68fb      	ldr	r3, [r7, #12]
 800a8e6:	2240      	movs	r2, #64	; 0x40
 800a8e8:	2100      	movs	r1, #0
 800a8ea:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 800a8ec:	2300      	movs	r3, #0
 800a8ee:	e000      	b.n	800a8f2 <HAL_I2C_Mem_Read+0x256>
  }
  else
  {
    return HAL_BUSY;
 800a8f0:	2302      	movs	r3, #2
  }
}
 800a8f2:	0018      	movs	r0, r3
 800a8f4:	46bd      	mov	sp, r7
 800a8f6:	b007      	add	sp, #28
 800a8f8:	bd90      	pop	{r4, r7, pc}
 800a8fa:	46c0      	nop			; (mov r8, r8)
 800a8fc:	80002400 	.word	0x80002400
 800a900:	fe00e800 	.word	0xfe00e800

0800a904 <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
 800a904:	b580      	push	{r7, lr}
 800a906:	b082      	sub	sp, #8
 800a908:	af00      	add	r7, sp, #0
 800a90a:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
 800a90c:	687b      	ldr	r3, [r7, #4]
 800a90e:	2241      	movs	r2, #65	; 0x41
 800a910:	5c9b      	ldrb	r3, [r3, r2]
 800a912:	b2db      	uxtb	r3, r3
}
 800a914:	0018      	movs	r0, r3
 800a916:	46bd      	mov	sp, r7
 800a918:	b002      	add	sp, #8
 800a91a:	bd80      	pop	{r7, pc}

0800a91c <I2C_RequestMemoryWrite>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 800a91c:	b5b0      	push	{r4, r5, r7, lr}
 800a91e:	b086      	sub	sp, #24
 800a920:	af02      	add	r7, sp, #8
 800a922:	60f8      	str	r0, [r7, #12]
 800a924:	000c      	movs	r4, r1
 800a926:	0010      	movs	r0, r2
 800a928:	0019      	movs	r1, r3
 800a92a:	250a      	movs	r5, #10
 800a92c:	197b      	adds	r3, r7, r5
 800a92e:	1c22      	adds	r2, r4, #0
 800a930:	801a      	strh	r2, [r3, #0]
 800a932:	2308      	movs	r3, #8
 800a934:	18fb      	adds	r3, r7, r3
 800a936:	1c02      	adds	r2, r0, #0
 800a938:	801a      	strh	r2, [r3, #0]
 800a93a:	1dbb      	adds	r3, r7, #6
 800a93c:	1c0a      	adds	r2, r1, #0
 800a93e:	801a      	strh	r2, [r3, #0]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 800a940:	1dbb      	adds	r3, r7, #6
 800a942:	881b      	ldrh	r3, [r3, #0]
 800a944:	b2da      	uxtb	r2, r3
 800a946:	2380      	movs	r3, #128	; 0x80
 800a948:	045c      	lsls	r4, r3, #17
 800a94a:	197b      	adds	r3, r7, r5
 800a94c:	8819      	ldrh	r1, [r3, #0]
 800a94e:	68f8      	ldr	r0, [r7, #12]
 800a950:	4b23      	ldr	r3, [pc, #140]	; (800a9e0 <I2C_RequestMemoryWrite+0xc4>)
 800a952:	9300      	str	r3, [sp, #0]
 800a954:	0023      	movs	r3, r4
 800a956:	f000 f9e9 	bl	800ad2c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800a95a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a95c:	6a39      	ldr	r1, [r7, #32]
 800a95e:	68fb      	ldr	r3, [r7, #12]
 800a960:	0018      	movs	r0, r3
 800a962:	f000 f902 	bl	800ab6a <I2C_WaitOnTXISFlagUntilTimeout>
 800a966:	1e03      	subs	r3, r0, #0
 800a968:	d001      	beq.n	800a96e <I2C_RequestMemoryWrite+0x52>
  {
    return HAL_ERROR;
 800a96a:	2301      	movs	r3, #1
 800a96c:	e033      	b.n	800a9d6 <I2C_RequestMemoryWrite+0xba>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800a96e:	1dbb      	adds	r3, r7, #6
 800a970:	881b      	ldrh	r3, [r3, #0]
 800a972:	2b01      	cmp	r3, #1
 800a974:	d107      	bne.n	800a986 <I2C_RequestMemoryWrite+0x6a>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800a976:	2308      	movs	r3, #8
 800a978:	18fb      	adds	r3, r7, r3
 800a97a:	881b      	ldrh	r3, [r3, #0]
 800a97c:	b2da      	uxtb	r2, r3
 800a97e:	68fb      	ldr	r3, [r7, #12]
 800a980:	681b      	ldr	r3, [r3, #0]
 800a982:	629a      	str	r2, [r3, #40]	; 0x28
 800a984:	e019      	b.n	800a9ba <I2C_RequestMemoryWrite+0x9e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 800a986:	2308      	movs	r3, #8
 800a988:	18fb      	adds	r3, r7, r3
 800a98a:	881b      	ldrh	r3, [r3, #0]
 800a98c:	0a1b      	lsrs	r3, r3, #8
 800a98e:	b29b      	uxth	r3, r3
 800a990:	b2da      	uxtb	r2, r3
 800a992:	68fb      	ldr	r3, [r7, #12]
 800a994:	681b      	ldr	r3, [r3, #0]
 800a996:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800a998:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a99a:	6a39      	ldr	r1, [r7, #32]
 800a99c:	68fb      	ldr	r3, [r7, #12]
 800a99e:	0018      	movs	r0, r3
 800a9a0:	f000 f8e3 	bl	800ab6a <I2C_WaitOnTXISFlagUntilTimeout>
 800a9a4:	1e03      	subs	r3, r0, #0
 800a9a6:	d001      	beq.n	800a9ac <I2C_RequestMemoryWrite+0x90>
    {
      return HAL_ERROR;
 800a9a8:	2301      	movs	r3, #1
 800a9aa:	e014      	b.n	800a9d6 <I2C_RequestMemoryWrite+0xba>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800a9ac:	2308      	movs	r3, #8
 800a9ae:	18fb      	adds	r3, r7, r3
 800a9b0:	881b      	ldrh	r3, [r3, #0]
 800a9b2:	b2da      	uxtb	r2, r3
 800a9b4:	68fb      	ldr	r3, [r7, #12]
 800a9b6:	681b      	ldr	r3, [r3, #0]
 800a9b8:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 800a9ba:	6a3a      	ldr	r2, [r7, #32]
 800a9bc:	68f8      	ldr	r0, [r7, #12]
 800a9be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a9c0:	9300      	str	r3, [sp, #0]
 800a9c2:	0013      	movs	r3, r2
 800a9c4:	2200      	movs	r2, #0
 800a9c6:	2180      	movs	r1, #128	; 0x80
 800a9c8:	f000 f890 	bl	800aaec <I2C_WaitOnFlagUntilTimeout>
 800a9cc:	1e03      	subs	r3, r0, #0
 800a9ce:	d001      	beq.n	800a9d4 <I2C_RequestMemoryWrite+0xb8>
  {
    return HAL_ERROR;
 800a9d0:	2301      	movs	r3, #1
 800a9d2:	e000      	b.n	800a9d6 <I2C_RequestMemoryWrite+0xba>
  }

  return HAL_OK;
 800a9d4:	2300      	movs	r3, #0
}
 800a9d6:	0018      	movs	r0, r3
 800a9d8:	46bd      	mov	sp, r7
 800a9da:	b004      	add	sp, #16
 800a9dc:	bdb0      	pop	{r4, r5, r7, pc}
 800a9de:	46c0      	nop			; (mov r8, r8)
 800a9e0:	80002000 	.word	0x80002000

0800a9e4 <I2C_RequestMemoryRead>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 800a9e4:	b5b0      	push	{r4, r5, r7, lr}
 800a9e6:	b086      	sub	sp, #24
 800a9e8:	af02      	add	r7, sp, #8
 800a9ea:	60f8      	str	r0, [r7, #12]
 800a9ec:	000c      	movs	r4, r1
 800a9ee:	0010      	movs	r0, r2
 800a9f0:	0019      	movs	r1, r3
 800a9f2:	250a      	movs	r5, #10
 800a9f4:	197b      	adds	r3, r7, r5
 800a9f6:	1c22      	adds	r2, r4, #0
 800a9f8:	801a      	strh	r2, [r3, #0]
 800a9fa:	2308      	movs	r3, #8
 800a9fc:	18fb      	adds	r3, r7, r3
 800a9fe:	1c02      	adds	r2, r0, #0
 800aa00:	801a      	strh	r2, [r3, #0]
 800aa02:	1dbb      	adds	r3, r7, #6
 800aa04:	1c0a      	adds	r2, r1, #0
 800aa06:	801a      	strh	r2, [r3, #0]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 800aa08:	1dbb      	adds	r3, r7, #6
 800aa0a:	881b      	ldrh	r3, [r3, #0]
 800aa0c:	b2da      	uxtb	r2, r3
 800aa0e:	197b      	adds	r3, r7, r5
 800aa10:	8819      	ldrh	r1, [r3, #0]
 800aa12:	68f8      	ldr	r0, [r7, #12]
 800aa14:	4b23      	ldr	r3, [pc, #140]	; (800aaa4 <I2C_RequestMemoryRead+0xc0>)
 800aa16:	9300      	str	r3, [sp, #0]
 800aa18:	2300      	movs	r3, #0
 800aa1a:	f000 f987 	bl	800ad2c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800aa1e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800aa20:	6a39      	ldr	r1, [r7, #32]
 800aa22:	68fb      	ldr	r3, [r7, #12]
 800aa24:	0018      	movs	r0, r3
 800aa26:	f000 f8a0 	bl	800ab6a <I2C_WaitOnTXISFlagUntilTimeout>
 800aa2a:	1e03      	subs	r3, r0, #0
 800aa2c:	d001      	beq.n	800aa32 <I2C_RequestMemoryRead+0x4e>
  {
    return HAL_ERROR;
 800aa2e:	2301      	movs	r3, #1
 800aa30:	e033      	b.n	800aa9a <I2C_RequestMemoryRead+0xb6>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800aa32:	1dbb      	adds	r3, r7, #6
 800aa34:	881b      	ldrh	r3, [r3, #0]
 800aa36:	2b01      	cmp	r3, #1
 800aa38:	d107      	bne.n	800aa4a <I2C_RequestMemoryRead+0x66>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800aa3a:	2308      	movs	r3, #8
 800aa3c:	18fb      	adds	r3, r7, r3
 800aa3e:	881b      	ldrh	r3, [r3, #0]
 800aa40:	b2da      	uxtb	r2, r3
 800aa42:	68fb      	ldr	r3, [r7, #12]
 800aa44:	681b      	ldr	r3, [r3, #0]
 800aa46:	629a      	str	r2, [r3, #40]	; 0x28
 800aa48:	e019      	b.n	800aa7e <I2C_RequestMemoryRead+0x9a>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 800aa4a:	2308      	movs	r3, #8
 800aa4c:	18fb      	adds	r3, r7, r3
 800aa4e:	881b      	ldrh	r3, [r3, #0]
 800aa50:	0a1b      	lsrs	r3, r3, #8
 800aa52:	b29b      	uxth	r3, r3
 800aa54:	b2da      	uxtb	r2, r3
 800aa56:	68fb      	ldr	r3, [r7, #12]
 800aa58:	681b      	ldr	r3, [r3, #0]
 800aa5a:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800aa5c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800aa5e:	6a39      	ldr	r1, [r7, #32]
 800aa60:	68fb      	ldr	r3, [r7, #12]
 800aa62:	0018      	movs	r0, r3
 800aa64:	f000 f881 	bl	800ab6a <I2C_WaitOnTXISFlagUntilTimeout>
 800aa68:	1e03      	subs	r3, r0, #0
 800aa6a:	d001      	beq.n	800aa70 <I2C_RequestMemoryRead+0x8c>
    {
      return HAL_ERROR;
 800aa6c:	2301      	movs	r3, #1
 800aa6e:	e014      	b.n	800aa9a <I2C_RequestMemoryRead+0xb6>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800aa70:	2308      	movs	r3, #8
 800aa72:	18fb      	adds	r3, r7, r3
 800aa74:	881b      	ldrh	r3, [r3, #0]
 800aa76:	b2da      	uxtb	r2, r3
 800aa78:	68fb      	ldr	r3, [r7, #12]
 800aa7a:	681b      	ldr	r3, [r3, #0]
 800aa7c:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 800aa7e:	6a3a      	ldr	r2, [r7, #32]
 800aa80:	68f8      	ldr	r0, [r7, #12]
 800aa82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800aa84:	9300      	str	r3, [sp, #0]
 800aa86:	0013      	movs	r3, r2
 800aa88:	2200      	movs	r2, #0
 800aa8a:	2140      	movs	r1, #64	; 0x40
 800aa8c:	f000 f82e 	bl	800aaec <I2C_WaitOnFlagUntilTimeout>
 800aa90:	1e03      	subs	r3, r0, #0
 800aa92:	d001      	beq.n	800aa98 <I2C_RequestMemoryRead+0xb4>
  {
    return HAL_ERROR;
 800aa94:	2301      	movs	r3, #1
 800aa96:	e000      	b.n	800aa9a <I2C_RequestMemoryRead+0xb6>
  }

  return HAL_OK;
 800aa98:	2300      	movs	r3, #0
}
 800aa9a:	0018      	movs	r0, r3
 800aa9c:	46bd      	mov	sp, r7
 800aa9e:	b004      	add	sp, #16
 800aaa0:	bdb0      	pop	{r4, r5, r7, pc}
 800aaa2:	46c0      	nop			; (mov r8, r8)
 800aaa4:	80002000 	.word	0x80002000

0800aaa8 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
 800aaa8:	b580      	push	{r7, lr}
 800aaaa:	b082      	sub	sp, #8
 800aaac:	af00      	add	r7, sp, #0
 800aaae:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 800aab0:	687b      	ldr	r3, [r7, #4]
 800aab2:	681b      	ldr	r3, [r3, #0]
 800aab4:	699b      	ldr	r3, [r3, #24]
 800aab6:	2202      	movs	r2, #2
 800aab8:	4013      	ands	r3, r2
 800aaba:	2b02      	cmp	r3, #2
 800aabc:	d103      	bne.n	800aac6 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
 800aabe:	687b      	ldr	r3, [r7, #4]
 800aac0:	681b      	ldr	r3, [r3, #0]
 800aac2:	2200      	movs	r2, #0
 800aac4:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800aac6:	687b      	ldr	r3, [r7, #4]
 800aac8:	681b      	ldr	r3, [r3, #0]
 800aaca:	699b      	ldr	r3, [r3, #24]
 800aacc:	2201      	movs	r2, #1
 800aace:	4013      	ands	r3, r2
 800aad0:	2b01      	cmp	r3, #1
 800aad2:	d007      	beq.n	800aae4 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 800aad4:	687b      	ldr	r3, [r7, #4]
 800aad6:	681b      	ldr	r3, [r3, #0]
 800aad8:	699a      	ldr	r2, [r3, #24]
 800aada:	687b      	ldr	r3, [r7, #4]
 800aadc:	681b      	ldr	r3, [r3, #0]
 800aade:	2101      	movs	r1, #1
 800aae0:	430a      	orrs	r2, r1
 800aae2:	619a      	str	r2, [r3, #24]
  }
}
 800aae4:	46c0      	nop			; (mov r8, r8)
 800aae6:	46bd      	mov	sp, r7
 800aae8:	b002      	add	sp, #8
 800aaea:	bd80      	pop	{r7, pc}

0800aaec <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
 800aaec:	b580      	push	{r7, lr}
 800aaee:	b084      	sub	sp, #16
 800aaf0:	af00      	add	r7, sp, #0
 800aaf2:	60f8      	str	r0, [r7, #12]
 800aaf4:	60b9      	str	r1, [r7, #8]
 800aaf6:	603b      	str	r3, [r7, #0]
 800aaf8:	1dfb      	adds	r3, r7, #7
 800aafa:	701a      	strb	r2, [r3, #0]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800aafc:	e021      	b.n	800ab42 <I2C_WaitOnFlagUntilTimeout+0x56>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800aafe:	683b      	ldr	r3, [r7, #0]
 800ab00:	3301      	adds	r3, #1
 800ab02:	d01e      	beq.n	800ab42 <I2C_WaitOnFlagUntilTimeout+0x56>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ab04:	f7fe fb1c 	bl	8009140 <HAL_GetTick>
 800ab08:	0002      	movs	r2, r0
 800ab0a:	69bb      	ldr	r3, [r7, #24]
 800ab0c:	1ad3      	subs	r3, r2, r3
 800ab0e:	683a      	ldr	r2, [r7, #0]
 800ab10:	429a      	cmp	r2, r3
 800ab12:	d302      	bcc.n	800ab1a <I2C_WaitOnFlagUntilTimeout+0x2e>
 800ab14:	683b      	ldr	r3, [r7, #0]
 800ab16:	2b00      	cmp	r3, #0
 800ab18:	d113      	bne.n	800ab42 <I2C_WaitOnFlagUntilTimeout+0x56>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800ab1a:	68fb      	ldr	r3, [r7, #12]
 800ab1c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab1e:	2220      	movs	r2, #32
 800ab20:	431a      	orrs	r2, r3
 800ab22:	68fb      	ldr	r3, [r7, #12]
 800ab24:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800ab26:	68fb      	ldr	r3, [r7, #12]
 800ab28:	2241      	movs	r2, #65	; 0x41
 800ab2a:	2120      	movs	r1, #32
 800ab2c:	5499      	strb	r1, [r3, r2]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800ab2e:	68fb      	ldr	r3, [r7, #12]
 800ab30:	2242      	movs	r2, #66	; 0x42
 800ab32:	2100      	movs	r1, #0
 800ab34:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800ab36:	68fb      	ldr	r3, [r7, #12]
 800ab38:	2240      	movs	r2, #64	; 0x40
 800ab3a:	2100      	movs	r1, #0
 800ab3c:	5499      	strb	r1, [r3, r2]
        return HAL_ERROR;
 800ab3e:	2301      	movs	r3, #1
 800ab40:	e00f      	b.n	800ab62 <I2C_WaitOnFlagUntilTimeout+0x76>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800ab42:	68fb      	ldr	r3, [r7, #12]
 800ab44:	681b      	ldr	r3, [r3, #0]
 800ab46:	699b      	ldr	r3, [r3, #24]
 800ab48:	68ba      	ldr	r2, [r7, #8]
 800ab4a:	4013      	ands	r3, r2
 800ab4c:	68ba      	ldr	r2, [r7, #8]
 800ab4e:	1ad3      	subs	r3, r2, r3
 800ab50:	425a      	negs	r2, r3
 800ab52:	4153      	adcs	r3, r2
 800ab54:	b2db      	uxtb	r3, r3
 800ab56:	001a      	movs	r2, r3
 800ab58:	1dfb      	adds	r3, r7, #7
 800ab5a:	781b      	ldrb	r3, [r3, #0]
 800ab5c:	429a      	cmp	r2, r3
 800ab5e:	d0ce      	beq.n	800aafe <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 800ab60:	2300      	movs	r3, #0
}
 800ab62:	0018      	movs	r0, r3
 800ab64:	46bd      	mov	sp, r7
 800ab66:	b004      	add	sp, #16
 800ab68:	bd80      	pop	{r7, pc}

0800ab6a <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800ab6a:	b580      	push	{r7, lr}
 800ab6c:	b084      	sub	sp, #16
 800ab6e:	af00      	add	r7, sp, #0
 800ab70:	60f8      	str	r0, [r7, #12]
 800ab72:	60b9      	str	r1, [r7, #8]
 800ab74:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 800ab76:	e02b      	b.n	800abd0 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 800ab78:	687a      	ldr	r2, [r7, #4]
 800ab7a:	68b9      	ldr	r1, [r7, #8]
 800ab7c:	68fb      	ldr	r3, [r7, #12]
 800ab7e:	0018      	movs	r0, r3
 800ab80:	f000 f86e 	bl	800ac60 <I2C_IsAcknowledgeFailed>
 800ab84:	1e03      	subs	r3, r0, #0
 800ab86:	d001      	beq.n	800ab8c <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 800ab88:	2301      	movs	r3, #1
 800ab8a:	e029      	b.n	800abe0 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800ab8c:	68bb      	ldr	r3, [r7, #8]
 800ab8e:	3301      	adds	r3, #1
 800ab90:	d01e      	beq.n	800abd0 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ab92:	f7fe fad5 	bl	8009140 <HAL_GetTick>
 800ab96:	0002      	movs	r2, r0
 800ab98:	687b      	ldr	r3, [r7, #4]
 800ab9a:	1ad3      	subs	r3, r2, r3
 800ab9c:	68ba      	ldr	r2, [r7, #8]
 800ab9e:	429a      	cmp	r2, r3
 800aba0:	d302      	bcc.n	800aba8 <I2C_WaitOnTXISFlagUntilTimeout+0x3e>
 800aba2:	68bb      	ldr	r3, [r7, #8]
 800aba4:	2b00      	cmp	r3, #0
 800aba6:	d113      	bne.n	800abd0 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800aba8:	68fb      	ldr	r3, [r7, #12]
 800abaa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abac:	2220      	movs	r2, #32
 800abae:	431a      	orrs	r2, r3
 800abb0:	68fb      	ldr	r3, [r7, #12]
 800abb2:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800abb4:	68fb      	ldr	r3, [r7, #12]
 800abb6:	2241      	movs	r2, #65	; 0x41
 800abb8:	2120      	movs	r1, #32
 800abba:	5499      	strb	r1, [r3, r2]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800abbc:	68fb      	ldr	r3, [r7, #12]
 800abbe:	2242      	movs	r2, #66	; 0x42
 800abc0:	2100      	movs	r1, #0
 800abc2:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800abc4:	68fb      	ldr	r3, [r7, #12]
 800abc6:	2240      	movs	r2, #64	; 0x40
 800abc8:	2100      	movs	r1, #0
 800abca:	5499      	strb	r1, [r3, r2]

        return HAL_ERROR;
 800abcc:	2301      	movs	r3, #1
 800abce:	e007      	b.n	800abe0 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 800abd0:	68fb      	ldr	r3, [r7, #12]
 800abd2:	681b      	ldr	r3, [r3, #0]
 800abd4:	699b      	ldr	r3, [r3, #24]
 800abd6:	2202      	movs	r2, #2
 800abd8:	4013      	ands	r3, r2
 800abda:	2b02      	cmp	r3, #2
 800abdc:	d1cc      	bne.n	800ab78 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
 800abde:	2300      	movs	r3, #0
}
 800abe0:	0018      	movs	r0, r3
 800abe2:	46bd      	mov	sp, r7
 800abe4:	b004      	add	sp, #16
 800abe6:	bd80      	pop	{r7, pc}

0800abe8 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800abe8:	b580      	push	{r7, lr}
 800abea:	b084      	sub	sp, #16
 800abec:	af00      	add	r7, sp, #0
 800abee:	60f8      	str	r0, [r7, #12]
 800abf0:	60b9      	str	r1, [r7, #8]
 800abf2:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800abf4:	e028      	b.n	800ac48 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 800abf6:	687a      	ldr	r2, [r7, #4]
 800abf8:	68b9      	ldr	r1, [r7, #8]
 800abfa:	68fb      	ldr	r3, [r7, #12]
 800abfc:	0018      	movs	r0, r3
 800abfe:	f000 f82f 	bl	800ac60 <I2C_IsAcknowledgeFailed>
 800ac02:	1e03      	subs	r3, r0, #0
 800ac04:	d001      	beq.n	800ac0a <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 800ac06:	2301      	movs	r3, #1
 800ac08:	e026      	b.n	800ac58 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ac0a:	f7fe fa99 	bl	8009140 <HAL_GetTick>
 800ac0e:	0002      	movs	r2, r0
 800ac10:	687b      	ldr	r3, [r7, #4]
 800ac12:	1ad3      	subs	r3, r2, r3
 800ac14:	68ba      	ldr	r2, [r7, #8]
 800ac16:	429a      	cmp	r2, r3
 800ac18:	d302      	bcc.n	800ac20 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
 800ac1a:	68bb      	ldr	r3, [r7, #8]
 800ac1c:	2b00      	cmp	r3, #0
 800ac1e:	d113      	bne.n	800ac48 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800ac20:	68fb      	ldr	r3, [r7, #12]
 800ac22:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac24:	2220      	movs	r2, #32
 800ac26:	431a      	orrs	r2, r3
 800ac28:	68fb      	ldr	r3, [r7, #12]
 800ac2a:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800ac2c:	68fb      	ldr	r3, [r7, #12]
 800ac2e:	2241      	movs	r2, #65	; 0x41
 800ac30:	2120      	movs	r1, #32
 800ac32:	5499      	strb	r1, [r3, r2]
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800ac34:	68fb      	ldr	r3, [r7, #12]
 800ac36:	2242      	movs	r2, #66	; 0x42
 800ac38:	2100      	movs	r1, #0
 800ac3a:	5499      	strb	r1, [r3, r2]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800ac3c:	68fb      	ldr	r3, [r7, #12]
 800ac3e:	2240      	movs	r2, #64	; 0x40
 800ac40:	2100      	movs	r1, #0
 800ac42:	5499      	strb	r1, [r3, r2]

      return HAL_ERROR;
 800ac44:	2301      	movs	r3, #1
 800ac46:	e007      	b.n	800ac58 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800ac48:	68fb      	ldr	r3, [r7, #12]
 800ac4a:	681b      	ldr	r3, [r3, #0]
 800ac4c:	699b      	ldr	r3, [r3, #24]
 800ac4e:	2220      	movs	r2, #32
 800ac50:	4013      	ands	r3, r2
 800ac52:	2b20      	cmp	r3, #32
 800ac54:	d1cf      	bne.n	800abf6 <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
 800ac56:	2300      	movs	r3, #0
}
 800ac58:	0018      	movs	r0, r3
 800ac5a:	46bd      	mov	sp, r7
 800ac5c:	b004      	add	sp, #16
 800ac5e:	bd80      	pop	{r7, pc}

0800ac60 <I2C_IsAcknowledgeFailed>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800ac60:	b580      	push	{r7, lr}
 800ac62:	b084      	sub	sp, #16
 800ac64:	af00      	add	r7, sp, #0
 800ac66:	60f8      	str	r0, [r7, #12]
 800ac68:	60b9      	str	r1, [r7, #8]
 800ac6a:	607a      	str	r2, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800ac6c:	68fb      	ldr	r3, [r7, #12]
 800ac6e:	681b      	ldr	r3, [r3, #0]
 800ac70:	699b      	ldr	r3, [r3, #24]
 800ac72:	2210      	movs	r2, #16
 800ac74:	4013      	ands	r3, r2
 800ac76:	2b10      	cmp	r3, #16
 800ac78:	d151      	bne.n	800ad1e <I2C_IsAcknowledgeFailed+0xbe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800ac7a:	e021      	b.n	800acc0 <I2C_IsAcknowledgeFailed+0x60>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 800ac7c:	68bb      	ldr	r3, [r7, #8]
 800ac7e:	3301      	adds	r3, #1
 800ac80:	d01e      	beq.n	800acc0 <I2C_IsAcknowledgeFailed+0x60>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ac82:	f7fe fa5d 	bl	8009140 <HAL_GetTick>
 800ac86:	0002      	movs	r2, r0
 800ac88:	687b      	ldr	r3, [r7, #4]
 800ac8a:	1ad3      	subs	r3, r2, r3
 800ac8c:	68ba      	ldr	r2, [r7, #8]
 800ac8e:	429a      	cmp	r2, r3
 800ac90:	d302      	bcc.n	800ac98 <I2C_IsAcknowledgeFailed+0x38>
 800ac92:	68bb      	ldr	r3, [r7, #8]
 800ac94:	2b00      	cmp	r3, #0
 800ac96:	d113      	bne.n	800acc0 <I2C_IsAcknowledgeFailed+0x60>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800ac98:	68fb      	ldr	r3, [r7, #12]
 800ac9a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac9c:	2220      	movs	r2, #32
 800ac9e:	431a      	orrs	r2, r3
 800aca0:	68fb      	ldr	r3, [r7, #12]
 800aca2:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 800aca4:	68fb      	ldr	r3, [r7, #12]
 800aca6:	2241      	movs	r2, #65	; 0x41
 800aca8:	2120      	movs	r1, #32
 800acaa:	5499      	strb	r1, [r3, r2]
          hi2c->Mode = HAL_I2C_MODE_NONE;
 800acac:	68fb      	ldr	r3, [r7, #12]
 800acae:	2242      	movs	r2, #66	; 0x42
 800acb0:	2100      	movs	r1, #0
 800acb2:	5499      	strb	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 800acb4:	68fb      	ldr	r3, [r7, #12]
 800acb6:	2240      	movs	r2, #64	; 0x40
 800acb8:	2100      	movs	r1, #0
 800acba:	5499      	strb	r1, [r3, r2]

          return HAL_ERROR;
 800acbc:	2301      	movs	r3, #1
 800acbe:	e02f      	b.n	800ad20 <I2C_IsAcknowledgeFailed+0xc0>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800acc0:	68fb      	ldr	r3, [r7, #12]
 800acc2:	681b      	ldr	r3, [r3, #0]
 800acc4:	699b      	ldr	r3, [r3, #24]
 800acc6:	2220      	movs	r2, #32
 800acc8:	4013      	ands	r3, r2
 800acca:	2b20      	cmp	r3, #32
 800accc:	d1d6      	bne.n	800ac7c <I2C_IsAcknowledgeFailed+0x1c>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800acce:	68fb      	ldr	r3, [r7, #12]
 800acd0:	681b      	ldr	r3, [r3, #0]
 800acd2:	2210      	movs	r2, #16
 800acd4:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800acd6:	68fb      	ldr	r3, [r7, #12]
 800acd8:	681b      	ldr	r3, [r3, #0]
 800acda:	2220      	movs	r2, #32
 800acdc:	61da      	str	r2, [r3, #28]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
 800acde:	68fb      	ldr	r3, [r7, #12]
 800ace0:	0018      	movs	r0, r3
 800ace2:	f7ff fee1 	bl	800aaa8 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800ace6:	68fb      	ldr	r3, [r7, #12]
 800ace8:	681b      	ldr	r3, [r3, #0]
 800acea:	685a      	ldr	r2, [r3, #4]
 800acec:	68fb      	ldr	r3, [r7, #12]
 800acee:	681b      	ldr	r3, [r3, #0]
 800acf0:	490d      	ldr	r1, [pc, #52]	; (800ad28 <I2C_IsAcknowledgeFailed+0xc8>)
 800acf2:	400a      	ands	r2, r1
 800acf4:	605a      	str	r2, [r3, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800acf6:	68fb      	ldr	r3, [r7, #12]
 800acf8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800acfa:	2204      	movs	r2, #4
 800acfc:	431a      	orrs	r2, r3
 800acfe:	68fb      	ldr	r3, [r7, #12]
 800ad00:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 800ad02:	68fb      	ldr	r3, [r7, #12]
 800ad04:	2241      	movs	r2, #65	; 0x41
 800ad06:	2120      	movs	r1, #32
 800ad08:	5499      	strb	r1, [r3, r2]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800ad0a:	68fb      	ldr	r3, [r7, #12]
 800ad0c:	2242      	movs	r2, #66	; 0x42
 800ad0e:	2100      	movs	r1, #0
 800ad10:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800ad12:	68fb      	ldr	r3, [r7, #12]
 800ad14:	2240      	movs	r2, #64	; 0x40
 800ad16:	2100      	movs	r1, #0
 800ad18:	5499      	strb	r1, [r3, r2]

    return HAL_ERROR;
 800ad1a:	2301      	movs	r3, #1
 800ad1c:	e000      	b.n	800ad20 <I2C_IsAcknowledgeFailed+0xc0>
  }
  return HAL_OK;
 800ad1e:	2300      	movs	r3, #0
}
 800ad20:	0018      	movs	r0, r3
 800ad22:	46bd      	mov	sp, r7
 800ad24:	b004      	add	sp, #16
 800ad26:	bd80      	pop	{r7, pc}
 800ad28:	fe00e800 	.word	0xfe00e800

0800ad2c <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
 800ad2c:	b590      	push	{r4, r7, lr}
 800ad2e:	b085      	sub	sp, #20
 800ad30:	af00      	add	r7, sp, #0
 800ad32:	60f8      	str	r0, [r7, #12]
 800ad34:	0008      	movs	r0, r1
 800ad36:	0011      	movs	r1, r2
 800ad38:	607b      	str	r3, [r7, #4]
 800ad3a:	240a      	movs	r4, #10
 800ad3c:	193b      	adds	r3, r7, r4
 800ad3e:	1c02      	adds	r2, r0, #0
 800ad40:	801a      	strh	r2, [r3, #0]
 800ad42:	2009      	movs	r0, #9
 800ad44:	183b      	adds	r3, r7, r0
 800ad46:	1c0a      	adds	r2, r1, #0
 800ad48:	701a      	strb	r2, [r3, #0]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800ad4a:	68fb      	ldr	r3, [r7, #12]
 800ad4c:	681b      	ldr	r3, [r3, #0]
 800ad4e:	685b      	ldr	r3, [r3, #4]
 800ad50:	6a3a      	ldr	r2, [r7, #32]
 800ad52:	0d51      	lsrs	r1, r2, #21
 800ad54:	2280      	movs	r2, #128	; 0x80
 800ad56:	00d2      	lsls	r2, r2, #3
 800ad58:	400a      	ands	r2, r1
 800ad5a:	490e      	ldr	r1, [pc, #56]	; (800ad94 <I2C_TransferConfig+0x68>)
 800ad5c:	430a      	orrs	r2, r1
 800ad5e:	43d2      	mvns	r2, r2
 800ad60:	401a      	ands	r2, r3
 800ad62:	0011      	movs	r1, r2
 800ad64:	193b      	adds	r3, r7, r4
 800ad66:	881b      	ldrh	r3, [r3, #0]
 800ad68:	059b      	lsls	r3, r3, #22
 800ad6a:	0d9a      	lsrs	r2, r3, #22
 800ad6c:	183b      	adds	r3, r7, r0
 800ad6e:	781b      	ldrb	r3, [r3, #0]
 800ad70:	0418      	lsls	r0, r3, #16
 800ad72:	23ff      	movs	r3, #255	; 0xff
 800ad74:	041b      	lsls	r3, r3, #16
 800ad76:	4003      	ands	r3, r0
 800ad78:	431a      	orrs	r2, r3
 800ad7a:	687b      	ldr	r3, [r7, #4]
 800ad7c:	431a      	orrs	r2, r3
 800ad7e:	6a3b      	ldr	r3, [r7, #32]
 800ad80:	431a      	orrs	r2, r3
 800ad82:	68fb      	ldr	r3, [r7, #12]
 800ad84:	681b      	ldr	r3, [r3, #0]
 800ad86:	430a      	orrs	r2, r1
 800ad88:	605a      	str	r2, [r3, #4]
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
 800ad8a:	46c0      	nop			; (mov r8, r8)
 800ad8c:	46bd      	mov	sp, r7
 800ad8e:	b005      	add	sp, #20
 800ad90:	bd90      	pop	{r4, r7, pc}
 800ad92:	46c0      	nop			; (mov r8, r8)
 800ad94:	03ff63ff 	.word	0x03ff63ff

0800ad98 <HAL_PWR_DisablePVD>:
/**
  * @brief Disables the Power Voltage Detector(PVD).
  * @retval None
  */
void HAL_PWR_DisablePVD(void)
{
 800ad98:	b580      	push	{r7, lr}
 800ad9a:	af00      	add	r7, sp, #0
  /* Disable the power voltage detector */
  CLEAR_BIT(PWR->CR, PWR_CR_PVDE);
 800ad9c:	4b04      	ldr	r3, [pc, #16]	; (800adb0 <HAL_PWR_DisablePVD+0x18>)
 800ad9e:	681a      	ldr	r2, [r3, #0]
 800ada0:	4b03      	ldr	r3, [pc, #12]	; (800adb0 <HAL_PWR_DisablePVD+0x18>)
 800ada2:	2110      	movs	r1, #16
 800ada4:	438a      	bics	r2, r1
 800ada6:	601a      	str	r2, [r3, #0]
}
 800ada8:	46c0      	nop			; (mov r8, r8)
 800adaa:	46bd      	mov	sp, r7
 800adac:	bd80      	pop	{r7, pc}
 800adae:	46c0      	nop			; (mov r8, r8)
 800adb0:	40007000 	.word	0x40007000

0800adb4 <HAL_PWREx_EnableFastWakeUp>:
  *        Means, when ULP = 1 and FWU = 1 :VREFINT startup time is ignored when 
  *        exiting from low power mode.
  * @retval None
  */
void HAL_PWREx_EnableFastWakeUp(void)
{
 800adb4:	b580      	push	{r7, lr}
 800adb6:	af00      	add	r7, sp, #0
  /* Enable the fast wake up */
  SET_BIT(PWR->CR, PWR_CR_FWU);
 800adb8:	4b04      	ldr	r3, [pc, #16]	; (800adcc <HAL_PWREx_EnableFastWakeUp+0x18>)
 800adba:	681a      	ldr	r2, [r3, #0]
 800adbc:	4b03      	ldr	r3, [pc, #12]	; (800adcc <HAL_PWREx_EnableFastWakeUp+0x18>)
 800adbe:	2180      	movs	r1, #128	; 0x80
 800adc0:	00c9      	lsls	r1, r1, #3
 800adc2:	430a      	orrs	r2, r1
 800adc4:	601a      	str	r2, [r3, #0]
}
 800adc6:	46c0      	nop			; (mov r8, r8)
 800adc8:	46bd      	mov	sp, r7
 800adca:	bd80      	pop	{r7, pc}
 800adcc:	40007000 	.word	0x40007000

0800add0 <HAL_PWREx_EnableUltraLowPower>:
/**
  * @brief  Enables the Ultra Low Power mode
  * @retval None
  */
void HAL_PWREx_EnableUltraLowPower(void)
{
 800add0:	b580      	push	{r7, lr}
 800add2:	af00      	add	r7, sp, #0
  /* Enable the Ultra Low Power mode */
  SET_BIT(PWR->CR, PWR_CR_ULP);
 800add4:	4b04      	ldr	r3, [pc, #16]	; (800ade8 <HAL_PWREx_EnableUltraLowPower+0x18>)
 800add6:	681a      	ldr	r2, [r3, #0]
 800add8:	4b03      	ldr	r3, [pc, #12]	; (800ade8 <HAL_PWREx_EnableUltraLowPower+0x18>)
 800adda:	2180      	movs	r1, #128	; 0x80
 800addc:	0089      	lsls	r1, r1, #2
 800adde:	430a      	orrs	r2, r1
 800ade0:	601a      	str	r2, [r3, #0]
}
 800ade2:	46c0      	nop			; (mov r8, r8)
 800ade4:	46bd      	mov	sp, r7
 800ade6:	bd80      	pop	{r7, pc}
 800ade8:	40007000 	.word	0x40007000

0800adec <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800adec:	b5b0      	push	{r4, r5, r7, lr}
 800adee:	b08a      	sub	sp, #40	; 0x28
 800adf0:	af00      	add	r7, sp, #0
 800adf2:	6078      	str	r0, [r7, #4]
  uint32_t hsi_state;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check the parameters */
  if(RCC_OscInitStruct == NULL)
 800adf4:	687b      	ldr	r3, [r7, #4]
 800adf6:	2b00      	cmp	r3, #0
 800adf8:	d102      	bne.n	800ae00 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 800adfa:	2301      	movs	r3, #1
 800adfc:	f000 fbbb 	bl	800b576 <HAL_RCC_OscConfig+0x78a>
  }

  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800ae00:	4bc8      	ldr	r3, [pc, #800]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800ae02:	68db      	ldr	r3, [r3, #12]
 800ae04:	220c      	movs	r2, #12
 800ae06:	4013      	ands	r3, r2
 800ae08:	61fb      	str	r3, [r7, #28]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 800ae0a:	4bc6      	ldr	r3, [pc, #792]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800ae0c:	68da      	ldr	r2, [r3, #12]
 800ae0e:	2380      	movs	r3, #128	; 0x80
 800ae10:	025b      	lsls	r3, r3, #9
 800ae12:	4013      	ands	r3, r2
 800ae14:	61bb      	str	r3, [r7, #24]

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800ae16:	687b      	ldr	r3, [r7, #4]
 800ae18:	681b      	ldr	r3, [r3, #0]
 800ae1a:	2201      	movs	r2, #1
 800ae1c:	4013      	ands	r3, r2
 800ae1e:	d100      	bne.n	800ae22 <HAL_RCC_OscConfig+0x36>
 800ae20:	e07e      	b.n	800af20 <HAL_RCC_OscConfig+0x134>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 800ae22:	69fb      	ldr	r3, [r7, #28]
 800ae24:	2b08      	cmp	r3, #8
 800ae26:	d007      	beq.n	800ae38 <HAL_RCC_OscConfig+0x4c>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 800ae28:	69fb      	ldr	r3, [r7, #28]
 800ae2a:	2b0c      	cmp	r3, #12
 800ae2c:	d112      	bne.n	800ae54 <HAL_RCC_OscConfig+0x68>
 800ae2e:	69ba      	ldr	r2, [r7, #24]
 800ae30:	2380      	movs	r3, #128	; 0x80
 800ae32:	025b      	lsls	r3, r3, #9
 800ae34:	429a      	cmp	r2, r3
 800ae36:	d10d      	bne.n	800ae54 <HAL_RCC_OscConfig+0x68>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800ae38:	4bba      	ldr	r3, [pc, #744]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800ae3a:	681a      	ldr	r2, [r3, #0]
 800ae3c:	2380      	movs	r3, #128	; 0x80
 800ae3e:	029b      	lsls	r3, r3, #10
 800ae40:	4013      	ands	r3, r2
 800ae42:	d100      	bne.n	800ae46 <HAL_RCC_OscConfig+0x5a>
 800ae44:	e06b      	b.n	800af1e <HAL_RCC_OscConfig+0x132>
 800ae46:	687b      	ldr	r3, [r7, #4]
 800ae48:	685b      	ldr	r3, [r3, #4]
 800ae4a:	2b00      	cmp	r3, #0
 800ae4c:	d167      	bne.n	800af1e <HAL_RCC_OscConfig+0x132>
      {
        return HAL_ERROR;
 800ae4e:	2301      	movs	r3, #1
 800ae50:	f000 fb91 	bl	800b576 <HAL_RCC_OscConfig+0x78a>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800ae54:	687b      	ldr	r3, [r7, #4]
 800ae56:	685a      	ldr	r2, [r3, #4]
 800ae58:	2380      	movs	r3, #128	; 0x80
 800ae5a:	025b      	lsls	r3, r3, #9
 800ae5c:	429a      	cmp	r2, r3
 800ae5e:	d107      	bne.n	800ae70 <HAL_RCC_OscConfig+0x84>
 800ae60:	4bb0      	ldr	r3, [pc, #704]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800ae62:	681a      	ldr	r2, [r3, #0]
 800ae64:	4baf      	ldr	r3, [pc, #700]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800ae66:	2180      	movs	r1, #128	; 0x80
 800ae68:	0249      	lsls	r1, r1, #9
 800ae6a:	430a      	orrs	r2, r1
 800ae6c:	601a      	str	r2, [r3, #0]
 800ae6e:	e027      	b.n	800aec0 <HAL_RCC_OscConfig+0xd4>
 800ae70:	687b      	ldr	r3, [r7, #4]
 800ae72:	685a      	ldr	r2, [r3, #4]
 800ae74:	23a0      	movs	r3, #160	; 0xa0
 800ae76:	02db      	lsls	r3, r3, #11
 800ae78:	429a      	cmp	r2, r3
 800ae7a:	d10e      	bne.n	800ae9a <HAL_RCC_OscConfig+0xae>
 800ae7c:	4ba9      	ldr	r3, [pc, #676]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800ae7e:	681a      	ldr	r2, [r3, #0]
 800ae80:	4ba8      	ldr	r3, [pc, #672]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800ae82:	2180      	movs	r1, #128	; 0x80
 800ae84:	02c9      	lsls	r1, r1, #11
 800ae86:	430a      	orrs	r2, r1
 800ae88:	601a      	str	r2, [r3, #0]
 800ae8a:	4ba6      	ldr	r3, [pc, #664]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800ae8c:	681a      	ldr	r2, [r3, #0]
 800ae8e:	4ba5      	ldr	r3, [pc, #660]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800ae90:	2180      	movs	r1, #128	; 0x80
 800ae92:	0249      	lsls	r1, r1, #9
 800ae94:	430a      	orrs	r2, r1
 800ae96:	601a      	str	r2, [r3, #0]
 800ae98:	e012      	b.n	800aec0 <HAL_RCC_OscConfig+0xd4>
 800ae9a:	4ba2      	ldr	r3, [pc, #648]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800ae9c:	681a      	ldr	r2, [r3, #0]
 800ae9e:	4ba1      	ldr	r3, [pc, #644]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800aea0:	49a1      	ldr	r1, [pc, #644]	; (800b128 <HAL_RCC_OscConfig+0x33c>)
 800aea2:	400a      	ands	r2, r1
 800aea4:	601a      	str	r2, [r3, #0]
 800aea6:	4b9f      	ldr	r3, [pc, #636]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800aea8:	681a      	ldr	r2, [r3, #0]
 800aeaa:	2380      	movs	r3, #128	; 0x80
 800aeac:	025b      	lsls	r3, r3, #9
 800aeae:	4013      	ands	r3, r2
 800aeb0:	60fb      	str	r3, [r7, #12]
 800aeb2:	68fb      	ldr	r3, [r7, #12]
 800aeb4:	4b9b      	ldr	r3, [pc, #620]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800aeb6:	681a      	ldr	r2, [r3, #0]
 800aeb8:	4b9a      	ldr	r3, [pc, #616]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800aeba:	499c      	ldr	r1, [pc, #624]	; (800b12c <HAL_RCC_OscConfig+0x340>)
 800aebc:	400a      	ands	r2, r1
 800aebe:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800aec0:	687b      	ldr	r3, [r7, #4]
 800aec2:	685b      	ldr	r3, [r3, #4]
 800aec4:	2b00      	cmp	r3, #0
 800aec6:	d015      	beq.n	800aef4 <HAL_RCC_OscConfig+0x108>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800aec8:	f7fe f93a 	bl	8009140 <HAL_GetTick>
 800aecc:	0003      	movs	r3, r0
 800aece:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800aed0:	e009      	b.n	800aee6 <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800aed2:	f7fe f935 	bl	8009140 <HAL_GetTick>
 800aed6:	0002      	movs	r2, r0
 800aed8:	697b      	ldr	r3, [r7, #20]
 800aeda:	1ad3      	subs	r3, r2, r3
 800aedc:	2b64      	cmp	r3, #100	; 0x64
 800aede:	d902      	bls.n	800aee6 <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 800aee0:	2303      	movs	r3, #3
 800aee2:	f000 fb48 	bl	800b576 <HAL_RCC_OscConfig+0x78a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800aee6:	4b8f      	ldr	r3, [pc, #572]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800aee8:	681a      	ldr	r2, [r3, #0]
 800aeea:	2380      	movs	r3, #128	; 0x80
 800aeec:	029b      	lsls	r3, r3, #10
 800aeee:	4013      	ands	r3, r2
 800aef0:	d0ef      	beq.n	800aed2 <HAL_RCC_OscConfig+0xe6>
 800aef2:	e015      	b.n	800af20 <HAL_RCC_OscConfig+0x134>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800aef4:	f7fe f924 	bl	8009140 <HAL_GetTick>
 800aef8:	0003      	movs	r3, r0
 800aefa:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800aefc:	e008      	b.n	800af10 <HAL_RCC_OscConfig+0x124>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800aefe:	f7fe f91f 	bl	8009140 <HAL_GetTick>
 800af02:	0002      	movs	r2, r0
 800af04:	697b      	ldr	r3, [r7, #20]
 800af06:	1ad3      	subs	r3, r2, r3
 800af08:	2b64      	cmp	r3, #100	; 0x64
 800af0a:	d901      	bls.n	800af10 <HAL_RCC_OscConfig+0x124>
          {
            return HAL_TIMEOUT;
 800af0c:	2303      	movs	r3, #3
 800af0e:	e332      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800af10:	4b84      	ldr	r3, [pc, #528]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800af12:	681a      	ldr	r2, [r3, #0]
 800af14:	2380      	movs	r3, #128	; 0x80
 800af16:	029b      	lsls	r3, r3, #10
 800af18:	4013      	ands	r3, r2
 800af1a:	d1f0      	bne.n	800aefe <HAL_RCC_OscConfig+0x112>
 800af1c:	e000      	b.n	800af20 <HAL_RCC_OscConfig+0x134>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800af1e:	46c0      	nop			; (mov r8, r8)
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800af20:	687b      	ldr	r3, [r7, #4]
 800af22:	681b      	ldr	r3, [r3, #0]
 800af24:	2202      	movs	r2, #2
 800af26:	4013      	ands	r3, r2
 800af28:	d100      	bne.n	800af2c <HAL_RCC_OscConfig+0x140>
 800af2a:	e098      	b.n	800b05e <HAL_RCC_OscConfig+0x272>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    hsi_state = RCC_OscInitStruct->HSIState;
 800af2c:	687b      	ldr	r3, [r7, #4]
 800af2e:	68db      	ldr	r3, [r3, #12]
 800af30:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(RCC_CR_HSIOUTEN)
    if((hsi_state & RCC_HSI_OUTEN) != 0U)
 800af32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af34:	2220      	movs	r2, #32
 800af36:	4013      	ands	r3, r2
 800af38:	d009      	beq.n	800af4e <HAL_RCC_OscConfig+0x162>
    {
      /* HSI Output enable for timer requested */
      SET_BIT(RCC->CR, RCC_CR_HSIOUTEN);
 800af3a:	4b7a      	ldr	r3, [pc, #488]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800af3c:	681a      	ldr	r2, [r3, #0]
 800af3e:	4b79      	ldr	r3, [pc, #484]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800af40:	2120      	movs	r1, #32
 800af42:	430a      	orrs	r2, r1
 800af44:	601a      	str	r2, [r3, #0]

      hsi_state &= ~RCC_CR_HSIOUTEN;
 800af46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af48:	2220      	movs	r2, #32
 800af4a:	4393      	bics	r3, r2
 800af4c:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 800af4e:	69fb      	ldr	r3, [r7, #28]
 800af50:	2b04      	cmp	r3, #4
 800af52:	d005      	beq.n	800af60 <HAL_RCC_OscConfig+0x174>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 800af54:	69fb      	ldr	r3, [r7, #28]
 800af56:	2b0c      	cmp	r3, #12
 800af58:	d13d      	bne.n	800afd6 <HAL_RCC_OscConfig+0x1ea>
 800af5a:	69bb      	ldr	r3, [r7, #24]
 800af5c:	2b00      	cmp	r3, #0
 800af5e:	d13a      	bne.n	800afd6 <HAL_RCC_OscConfig+0x1ea>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (hsi_state == RCC_HSI_OFF))
 800af60:	4b70      	ldr	r3, [pc, #448]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800af62:	681b      	ldr	r3, [r3, #0]
 800af64:	2204      	movs	r2, #4
 800af66:	4013      	ands	r3, r2
 800af68:	d004      	beq.n	800af74 <HAL_RCC_OscConfig+0x188>
 800af6a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af6c:	2b00      	cmp	r3, #0
 800af6e:	d101      	bne.n	800af74 <HAL_RCC_OscConfig+0x188>
      {
        return HAL_ERROR;
 800af70:	2301      	movs	r3, #1
 800af72:	e300      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
      }
      /* Otherwise, just the calibration and HSI or HSIdiv4 are allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800af74:	4b6b      	ldr	r3, [pc, #428]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800af76:	685b      	ldr	r3, [r3, #4]
 800af78:	4a6d      	ldr	r2, [pc, #436]	; (800b130 <HAL_RCC_OscConfig+0x344>)
 800af7a:	4013      	ands	r3, r2
 800af7c:	0019      	movs	r1, r3
 800af7e:	687b      	ldr	r3, [r7, #4]
 800af80:	691b      	ldr	r3, [r3, #16]
 800af82:	021a      	lsls	r2, r3, #8
 800af84:	4b67      	ldr	r3, [pc, #412]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800af86:	430a      	orrs	r2, r1
 800af88:	605a      	str	r2, [r3, #4]

        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 800af8a:	4b66      	ldr	r3, [pc, #408]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800af8c:	681b      	ldr	r3, [r3, #0]
 800af8e:	2209      	movs	r2, #9
 800af90:	4393      	bics	r3, r2
 800af92:	0019      	movs	r1, r3
 800af94:	4b63      	ldr	r3, [pc, #396]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800af96:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800af98:	430a      	orrs	r2, r1
 800af9a:	601a      	str	r2, [r3, #0]
      }

      /* Update the SystemCoreClock global variable */
      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800af9c:	f000 fc20 	bl	800b7e0 <HAL_RCC_GetSysClockFreq>
 800afa0:	0001      	movs	r1, r0
 800afa2:	4b60      	ldr	r3, [pc, #384]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800afa4:	68db      	ldr	r3, [r3, #12]
 800afa6:	091b      	lsrs	r3, r3, #4
 800afa8:	220f      	movs	r2, #15
 800afaa:	4013      	ands	r3, r2
 800afac:	4a61      	ldr	r2, [pc, #388]	; (800b134 <HAL_RCC_OscConfig+0x348>)
 800afae:	5cd3      	ldrb	r3, [r2, r3]
 800afb0:	000a      	movs	r2, r1
 800afb2:	40da      	lsrs	r2, r3
 800afb4:	4b60      	ldr	r3, [pc, #384]	; (800b138 <HAL_RCC_OscConfig+0x34c>)
 800afb6:	601a      	str	r2, [r3, #0]

      /* Configure the source of time base considering new system clocks settings*/
      status = HAL_InitTick (TICK_INT_PRIORITY);
 800afb8:	2513      	movs	r5, #19
 800afba:	197c      	adds	r4, r7, r5
 800afbc:	2003      	movs	r0, #3
 800afbe:	f011 fd62 	bl	801ca86 <HAL_InitTick>
 800afc2:	0003      	movs	r3, r0
 800afc4:	7023      	strb	r3, [r4, #0]
      if(status != HAL_OK)
 800afc6:	002a      	movs	r2, r5
 800afc8:	18bb      	adds	r3, r7, r2
 800afca:	781b      	ldrb	r3, [r3, #0]
 800afcc:	2b00      	cmp	r3, #0
 800afce:	d046      	beq.n	800b05e <HAL_RCC_OscConfig+0x272>
      {
        return status;
 800afd0:	18bb      	adds	r3, r7, r2
 800afd2:	781b      	ldrb	r3, [r3, #0]
 800afd4:	e2cf      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
      }
    }
    else
    {
      /* Check the HSI State */
      if(hsi_state != RCC_HSI_OFF)
 800afd6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800afd8:	2b00      	cmp	r3, #0
 800afda:	d027      	beq.n	800b02c <HAL_RCC_OscConfig+0x240>
      {
        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 800afdc:	4b51      	ldr	r3, [pc, #324]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800afde:	681b      	ldr	r3, [r3, #0]
 800afe0:	2209      	movs	r2, #9
 800afe2:	4393      	bics	r3, r2
 800afe4:	0019      	movs	r1, r3
 800afe6:	4b4f      	ldr	r3, [pc, #316]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800afe8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800afea:	430a      	orrs	r2, r1
 800afec:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800afee:	f7fe f8a7 	bl	8009140 <HAL_GetTick>
 800aff2:	0003      	movs	r3, r0
 800aff4:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800aff6:	e008      	b.n	800b00a <HAL_RCC_OscConfig+0x21e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800aff8:	f7fe f8a2 	bl	8009140 <HAL_GetTick>
 800affc:	0002      	movs	r2, r0
 800affe:	697b      	ldr	r3, [r7, #20]
 800b000:	1ad3      	subs	r3, r2, r3
 800b002:	2b02      	cmp	r3, #2
 800b004:	d901      	bls.n	800b00a <HAL_RCC_OscConfig+0x21e>
          {
            return HAL_TIMEOUT;
 800b006:	2303      	movs	r3, #3
 800b008:	e2b5      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800b00a:	4b46      	ldr	r3, [pc, #280]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b00c:	681b      	ldr	r3, [r3, #0]
 800b00e:	2204      	movs	r2, #4
 800b010:	4013      	ands	r3, r2
 800b012:	d0f1      	beq.n	800aff8 <HAL_RCC_OscConfig+0x20c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800b014:	4b43      	ldr	r3, [pc, #268]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b016:	685b      	ldr	r3, [r3, #4]
 800b018:	4a45      	ldr	r2, [pc, #276]	; (800b130 <HAL_RCC_OscConfig+0x344>)
 800b01a:	4013      	ands	r3, r2
 800b01c:	0019      	movs	r1, r3
 800b01e:	687b      	ldr	r3, [r7, #4]
 800b020:	691b      	ldr	r3, [r3, #16]
 800b022:	021a      	lsls	r2, r3, #8
 800b024:	4b3f      	ldr	r3, [pc, #252]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b026:	430a      	orrs	r2, r1
 800b028:	605a      	str	r2, [r3, #4]
 800b02a:	e018      	b.n	800b05e <HAL_RCC_OscConfig+0x272>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800b02c:	4b3d      	ldr	r3, [pc, #244]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b02e:	681a      	ldr	r2, [r3, #0]
 800b030:	4b3c      	ldr	r3, [pc, #240]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b032:	2101      	movs	r1, #1
 800b034:	438a      	bics	r2, r1
 800b036:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b038:	f7fe f882 	bl	8009140 <HAL_GetTick>
 800b03c:	0003      	movs	r3, r0
 800b03e:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800b040:	e008      	b.n	800b054 <HAL_RCC_OscConfig+0x268>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800b042:	f7fe f87d 	bl	8009140 <HAL_GetTick>
 800b046:	0002      	movs	r2, r0
 800b048:	697b      	ldr	r3, [r7, #20]
 800b04a:	1ad3      	subs	r3, r2, r3
 800b04c:	2b02      	cmp	r3, #2
 800b04e:	d901      	bls.n	800b054 <HAL_RCC_OscConfig+0x268>
          {
            return HAL_TIMEOUT;
 800b050:	2303      	movs	r3, #3
 800b052:	e290      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800b054:	4b33      	ldr	r3, [pc, #204]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b056:	681b      	ldr	r3, [r3, #0]
 800b058:	2204      	movs	r2, #4
 800b05a:	4013      	ands	r3, r2
 800b05c:	d1f1      	bne.n	800b042 <HAL_RCC_OscConfig+0x256>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800b05e:	687b      	ldr	r3, [r7, #4]
 800b060:	681b      	ldr	r3, [r3, #0]
 800b062:	2210      	movs	r2, #16
 800b064:	4013      	ands	r3, r2
 800b066:	d100      	bne.n	800b06a <HAL_RCC_OscConfig+0x27e>
 800b068:	e09f      	b.n	800b1aa <HAL_RCC_OscConfig+0x3be>
  {
    /* When the MSI is used as system clock it will not be disabled */
    if((sysclk_source == RCC_CFGR_SWS_MSI) )
 800b06a:	69fb      	ldr	r3, [r7, #28]
 800b06c:	2b00      	cmp	r3, #0
 800b06e:	d13f      	bne.n	800b0f0 <HAL_RCC_OscConfig+0x304>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 800b070:	4b2c      	ldr	r3, [pc, #176]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b072:	681a      	ldr	r2, [r3, #0]
 800b074:	2380      	movs	r3, #128	; 0x80
 800b076:	009b      	lsls	r3, r3, #2
 800b078:	4013      	ands	r3, r2
 800b07a:	d005      	beq.n	800b088 <HAL_RCC_OscConfig+0x29c>
 800b07c:	687b      	ldr	r3, [r7, #4]
 800b07e:	69db      	ldr	r3, [r3, #28]
 800b080:	2b00      	cmp	r3, #0
 800b082:	d101      	bne.n	800b088 <HAL_RCC_OscConfig+0x29c>
      {
        return HAL_ERROR;
 800b084:	2301      	movs	r3, #1
 800b086:	e276      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800b088:	4b26      	ldr	r3, [pc, #152]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b08a:	685b      	ldr	r3, [r3, #4]
 800b08c:	4a2b      	ldr	r2, [pc, #172]	; (800b13c <HAL_RCC_OscConfig+0x350>)
 800b08e:	4013      	ands	r3, r2
 800b090:	0019      	movs	r1, r3
 800b092:	687b      	ldr	r3, [r7, #4]
 800b094:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b096:	4b23      	ldr	r3, [pc, #140]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b098:	430a      	orrs	r2, r1
 800b09a:	605a      	str	r2, [r3, #4]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800b09c:	4b21      	ldr	r3, [pc, #132]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b09e:	685b      	ldr	r3, [r3, #4]
 800b0a0:	021b      	lsls	r3, r3, #8
 800b0a2:	0a19      	lsrs	r1, r3, #8
 800b0a4:	687b      	ldr	r3, [r7, #4]
 800b0a6:	6a1b      	ldr	r3, [r3, #32]
 800b0a8:	061a      	lsls	r2, r3, #24
 800b0aa:	4b1e      	ldr	r3, [pc, #120]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b0ac:	430a      	orrs	r2, r1
 800b0ae:	605a      	str	r2, [r3, #4]


        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 800b0b0:	687b      	ldr	r3, [r7, #4]
 800b0b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b0b4:	0b5b      	lsrs	r3, r3, #13
 800b0b6:	3301      	adds	r3, #1
 800b0b8:	2280      	movs	r2, #128	; 0x80
 800b0ba:	0212      	lsls	r2, r2, #8
 800b0bc:	409a      	lsls	r2, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos)];
 800b0be:	4b19      	ldr	r3, [pc, #100]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b0c0:	68db      	ldr	r3, [r3, #12]
 800b0c2:	091b      	lsrs	r3, r3, #4
 800b0c4:	210f      	movs	r1, #15
 800b0c6:	400b      	ands	r3, r1
 800b0c8:	491a      	ldr	r1, [pc, #104]	; (800b134 <HAL_RCC_OscConfig+0x348>)
 800b0ca:	5ccb      	ldrb	r3, [r1, r3]
 800b0cc:	40da      	lsrs	r2, r3
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 800b0ce:	4b1a      	ldr	r3, [pc, #104]	; (800b138 <HAL_RCC_OscConfig+0x34c>)
 800b0d0:	601a      	str	r2, [r3, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick (TICK_INT_PRIORITY);
 800b0d2:	2513      	movs	r5, #19
 800b0d4:	197c      	adds	r4, r7, r5
 800b0d6:	2003      	movs	r0, #3
 800b0d8:	f011 fcd5 	bl	801ca86 <HAL_InitTick>
 800b0dc:	0003      	movs	r3, r0
 800b0de:	7023      	strb	r3, [r4, #0]
        if(status != HAL_OK)
 800b0e0:	002a      	movs	r2, r5
 800b0e2:	18bb      	adds	r3, r7, r2
 800b0e4:	781b      	ldrb	r3, [r3, #0]
 800b0e6:	2b00      	cmp	r3, #0
 800b0e8:	d05f      	beq.n	800b1aa <HAL_RCC_OscConfig+0x3be>
        {
          return status;
 800b0ea:	18bb      	adds	r3, r7, r2
 800b0ec:	781b      	ldrb	r3, [r3, #0]
 800b0ee:	e242      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
    {
      /* Check MSI State */
      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));

      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 800b0f0:	687b      	ldr	r3, [r7, #4]
 800b0f2:	69db      	ldr	r3, [r3, #28]
 800b0f4:	2b00      	cmp	r3, #0
 800b0f6:	d03e      	beq.n	800b176 <HAL_RCC_OscConfig+0x38a>
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 800b0f8:	4b0a      	ldr	r3, [pc, #40]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b0fa:	681a      	ldr	r2, [r3, #0]
 800b0fc:	4b09      	ldr	r3, [pc, #36]	; (800b124 <HAL_RCC_OscConfig+0x338>)
 800b0fe:	2180      	movs	r1, #128	; 0x80
 800b100:	0049      	lsls	r1, r1, #1
 800b102:	430a      	orrs	r2, r1
 800b104:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b106:	f7fe f81b 	bl	8009140 <HAL_GetTick>
 800b10a:	0003      	movs	r3, r0
 800b10c:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 800b10e:	e017      	b.n	800b140 <HAL_RCC_OscConfig+0x354>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800b110:	f7fe f816 	bl	8009140 <HAL_GetTick>
 800b114:	0002      	movs	r2, r0
 800b116:	697b      	ldr	r3, [r7, #20]
 800b118:	1ad3      	subs	r3, r2, r3
 800b11a:	2b02      	cmp	r3, #2
 800b11c:	d910      	bls.n	800b140 <HAL_RCC_OscConfig+0x354>
          {
            return HAL_TIMEOUT;
 800b11e:	2303      	movs	r3, #3
 800b120:	e229      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
 800b122:	46c0      	nop			; (mov r8, r8)
 800b124:	40021000 	.word	0x40021000
 800b128:	fffeffff 	.word	0xfffeffff
 800b12c:	fffbffff 	.word	0xfffbffff
 800b130:	ffffe0ff 	.word	0xffffe0ff
 800b134:	0801ee04 	.word	0x0801ee04
 800b138:	20000188 	.word	0x20000188
 800b13c:	ffff1fff 	.word	0xffff1fff
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 800b140:	4bca      	ldr	r3, [pc, #808]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b142:	681a      	ldr	r2, [r3, #0]
 800b144:	2380      	movs	r3, #128	; 0x80
 800b146:	009b      	lsls	r3, r3, #2
 800b148:	4013      	ands	r3, r2
 800b14a:	d0e1      	beq.n	800b110 <HAL_RCC_OscConfig+0x324>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800b14c:	4bc7      	ldr	r3, [pc, #796]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b14e:	685b      	ldr	r3, [r3, #4]
 800b150:	4ac7      	ldr	r2, [pc, #796]	; (800b470 <HAL_RCC_OscConfig+0x684>)
 800b152:	4013      	ands	r3, r2
 800b154:	0019      	movs	r1, r3
 800b156:	687b      	ldr	r3, [r7, #4]
 800b158:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b15a:	4bc4      	ldr	r3, [pc, #784]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b15c:	430a      	orrs	r2, r1
 800b15e:	605a      	str	r2, [r3, #4]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800b160:	4bc2      	ldr	r3, [pc, #776]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b162:	685b      	ldr	r3, [r3, #4]
 800b164:	021b      	lsls	r3, r3, #8
 800b166:	0a19      	lsrs	r1, r3, #8
 800b168:	687b      	ldr	r3, [r7, #4]
 800b16a:	6a1b      	ldr	r3, [r3, #32]
 800b16c:	061a      	lsls	r2, r3, #24
 800b16e:	4bbf      	ldr	r3, [pc, #764]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b170:	430a      	orrs	r2, r1
 800b172:	605a      	str	r2, [r3, #4]
 800b174:	e019      	b.n	800b1aa <HAL_RCC_OscConfig+0x3be>
      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 800b176:	4bbd      	ldr	r3, [pc, #756]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b178:	681a      	ldr	r2, [r3, #0]
 800b17a:	4bbc      	ldr	r3, [pc, #752]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b17c:	49bd      	ldr	r1, [pc, #756]	; (800b474 <HAL_RCC_OscConfig+0x688>)
 800b17e:	400a      	ands	r2, r1
 800b180:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b182:	f7fd ffdd 	bl	8009140 <HAL_GetTick>
 800b186:	0003      	movs	r3, r0
 800b188:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 800b18a:	e008      	b.n	800b19e <HAL_RCC_OscConfig+0x3b2>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800b18c:	f7fd ffd8 	bl	8009140 <HAL_GetTick>
 800b190:	0002      	movs	r2, r0
 800b192:	697b      	ldr	r3, [r7, #20]
 800b194:	1ad3      	subs	r3, r2, r3
 800b196:	2b02      	cmp	r3, #2
 800b198:	d901      	bls.n	800b19e <HAL_RCC_OscConfig+0x3b2>
          {
            return HAL_TIMEOUT;
 800b19a:	2303      	movs	r3, #3
 800b19c:	e1eb      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 800b19e:	4bb3      	ldr	r3, [pc, #716]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b1a0:	681a      	ldr	r2, [r3, #0]
 800b1a2:	2380      	movs	r3, #128	; 0x80
 800b1a4:	009b      	lsls	r3, r3, #2
 800b1a6:	4013      	ands	r3, r2
 800b1a8:	d1f0      	bne.n	800b18c <HAL_RCC_OscConfig+0x3a0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800b1aa:	687b      	ldr	r3, [r7, #4]
 800b1ac:	681b      	ldr	r3, [r3, #0]
 800b1ae:	2208      	movs	r2, #8
 800b1b0:	4013      	ands	r3, r2
 800b1b2:	d036      	beq.n	800b222 <HAL_RCC_OscConfig+0x436>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800b1b4:	687b      	ldr	r3, [r7, #4]
 800b1b6:	695b      	ldr	r3, [r3, #20]
 800b1b8:	2b00      	cmp	r3, #0
 800b1ba:	d019      	beq.n	800b1f0 <HAL_RCC_OscConfig+0x404>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800b1bc:	4bab      	ldr	r3, [pc, #684]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b1be:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b1c0:	4baa      	ldr	r3, [pc, #680]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b1c2:	2101      	movs	r1, #1
 800b1c4:	430a      	orrs	r2, r1
 800b1c6:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800b1c8:	f7fd ffba 	bl	8009140 <HAL_GetTick>
 800b1cc:	0003      	movs	r3, r0
 800b1ce:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 800b1d0:	e008      	b.n	800b1e4 <HAL_RCC_OscConfig+0x3f8>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800b1d2:	f7fd ffb5 	bl	8009140 <HAL_GetTick>
 800b1d6:	0002      	movs	r2, r0
 800b1d8:	697b      	ldr	r3, [r7, #20]
 800b1da:	1ad3      	subs	r3, r2, r3
 800b1dc:	2b02      	cmp	r3, #2
 800b1de:	d901      	bls.n	800b1e4 <HAL_RCC_OscConfig+0x3f8>
        {
          return HAL_TIMEOUT;
 800b1e0:	2303      	movs	r3, #3
 800b1e2:	e1c8      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 800b1e4:	4ba1      	ldr	r3, [pc, #644]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b1e6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800b1e8:	2202      	movs	r2, #2
 800b1ea:	4013      	ands	r3, r2
 800b1ec:	d0f1      	beq.n	800b1d2 <HAL_RCC_OscConfig+0x3e6>
 800b1ee:	e018      	b.n	800b222 <HAL_RCC_OscConfig+0x436>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800b1f0:	4b9e      	ldr	r3, [pc, #632]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b1f2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b1f4:	4b9d      	ldr	r3, [pc, #628]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b1f6:	2101      	movs	r1, #1
 800b1f8:	438a      	bics	r2, r1
 800b1fa:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800b1fc:	f7fd ffa0 	bl	8009140 <HAL_GetTick>
 800b200:	0003      	movs	r3, r0
 800b202:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800b204:	e008      	b.n	800b218 <HAL_RCC_OscConfig+0x42c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800b206:	f7fd ff9b 	bl	8009140 <HAL_GetTick>
 800b20a:	0002      	movs	r2, r0
 800b20c:	697b      	ldr	r3, [r7, #20]
 800b20e:	1ad3      	subs	r3, r2, r3
 800b210:	2b02      	cmp	r3, #2
 800b212:	d901      	bls.n	800b218 <HAL_RCC_OscConfig+0x42c>
        {
          return HAL_TIMEOUT;
 800b214:	2303      	movs	r3, #3
 800b216:	e1ae      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800b218:	4b94      	ldr	r3, [pc, #592]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b21a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800b21c:	2202      	movs	r2, #2
 800b21e:	4013      	ands	r3, r2
 800b220:	d1f1      	bne.n	800b206 <HAL_RCC_OscConfig+0x41a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800b222:	687b      	ldr	r3, [r7, #4]
 800b224:	681b      	ldr	r3, [r3, #0]
 800b226:	2204      	movs	r2, #4
 800b228:	4013      	ands	r3, r2
 800b22a:	d100      	bne.n	800b22e <HAL_RCC_OscConfig+0x442>
 800b22c:	e0ae      	b.n	800b38c <HAL_RCC_OscConfig+0x5a0>
  {
    FlagStatus       pwrclkchanged = RESET;
 800b22e:	2023      	movs	r0, #35	; 0x23
 800b230:	183b      	adds	r3, r7, r0
 800b232:	2200      	movs	r2, #0
 800b234:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800b236:	4b8d      	ldr	r3, [pc, #564]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b238:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b23a:	2380      	movs	r3, #128	; 0x80
 800b23c:	055b      	lsls	r3, r3, #21
 800b23e:	4013      	ands	r3, r2
 800b240:	d109      	bne.n	800b256 <HAL_RCC_OscConfig+0x46a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800b242:	4b8a      	ldr	r3, [pc, #552]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b244:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b246:	4b89      	ldr	r3, [pc, #548]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b248:	2180      	movs	r1, #128	; 0x80
 800b24a:	0549      	lsls	r1, r1, #21
 800b24c:	430a      	orrs	r2, r1
 800b24e:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 800b250:	183b      	adds	r3, r7, r0
 800b252:	2201      	movs	r2, #1
 800b254:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800b256:	4b88      	ldr	r3, [pc, #544]	; (800b478 <HAL_RCC_OscConfig+0x68c>)
 800b258:	681a      	ldr	r2, [r3, #0]
 800b25a:	2380      	movs	r3, #128	; 0x80
 800b25c:	005b      	lsls	r3, r3, #1
 800b25e:	4013      	ands	r3, r2
 800b260:	d11a      	bne.n	800b298 <HAL_RCC_OscConfig+0x4ac>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800b262:	4b85      	ldr	r3, [pc, #532]	; (800b478 <HAL_RCC_OscConfig+0x68c>)
 800b264:	681a      	ldr	r2, [r3, #0]
 800b266:	4b84      	ldr	r3, [pc, #528]	; (800b478 <HAL_RCC_OscConfig+0x68c>)
 800b268:	2180      	movs	r1, #128	; 0x80
 800b26a:	0049      	lsls	r1, r1, #1
 800b26c:	430a      	orrs	r2, r1
 800b26e:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800b270:	f7fd ff66 	bl	8009140 <HAL_GetTick>
 800b274:	0003      	movs	r3, r0
 800b276:	617b      	str	r3, [r7, #20]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800b278:	e008      	b.n	800b28c <HAL_RCC_OscConfig+0x4a0>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800b27a:	f7fd ff61 	bl	8009140 <HAL_GetTick>
 800b27e:	0002      	movs	r2, r0
 800b280:	697b      	ldr	r3, [r7, #20]
 800b282:	1ad3      	subs	r3, r2, r3
 800b284:	2b64      	cmp	r3, #100	; 0x64
 800b286:	d901      	bls.n	800b28c <HAL_RCC_OscConfig+0x4a0>
        {
          return HAL_TIMEOUT;
 800b288:	2303      	movs	r3, #3
 800b28a:	e174      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800b28c:	4b7a      	ldr	r3, [pc, #488]	; (800b478 <HAL_RCC_OscConfig+0x68c>)
 800b28e:	681a      	ldr	r2, [r3, #0]
 800b290:	2380      	movs	r3, #128	; 0x80
 800b292:	005b      	lsls	r3, r3, #1
 800b294:	4013      	ands	r3, r2
 800b296:	d0f0      	beq.n	800b27a <HAL_RCC_OscConfig+0x48e>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800b298:	687b      	ldr	r3, [r7, #4]
 800b29a:	689a      	ldr	r2, [r3, #8]
 800b29c:	2380      	movs	r3, #128	; 0x80
 800b29e:	005b      	lsls	r3, r3, #1
 800b2a0:	429a      	cmp	r2, r3
 800b2a2:	d107      	bne.n	800b2b4 <HAL_RCC_OscConfig+0x4c8>
 800b2a4:	4b71      	ldr	r3, [pc, #452]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b2a6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b2a8:	4b70      	ldr	r3, [pc, #448]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b2aa:	2180      	movs	r1, #128	; 0x80
 800b2ac:	0049      	lsls	r1, r1, #1
 800b2ae:	430a      	orrs	r2, r1
 800b2b0:	651a      	str	r2, [r3, #80]	; 0x50
 800b2b2:	e031      	b.n	800b318 <HAL_RCC_OscConfig+0x52c>
 800b2b4:	687b      	ldr	r3, [r7, #4]
 800b2b6:	689b      	ldr	r3, [r3, #8]
 800b2b8:	2b00      	cmp	r3, #0
 800b2ba:	d10c      	bne.n	800b2d6 <HAL_RCC_OscConfig+0x4ea>
 800b2bc:	4b6b      	ldr	r3, [pc, #428]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b2be:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b2c0:	4b6a      	ldr	r3, [pc, #424]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b2c2:	496c      	ldr	r1, [pc, #432]	; (800b474 <HAL_RCC_OscConfig+0x688>)
 800b2c4:	400a      	ands	r2, r1
 800b2c6:	651a      	str	r2, [r3, #80]	; 0x50
 800b2c8:	4b68      	ldr	r3, [pc, #416]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b2ca:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b2cc:	4b67      	ldr	r3, [pc, #412]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b2ce:	496b      	ldr	r1, [pc, #428]	; (800b47c <HAL_RCC_OscConfig+0x690>)
 800b2d0:	400a      	ands	r2, r1
 800b2d2:	651a      	str	r2, [r3, #80]	; 0x50
 800b2d4:	e020      	b.n	800b318 <HAL_RCC_OscConfig+0x52c>
 800b2d6:	687b      	ldr	r3, [r7, #4]
 800b2d8:	689a      	ldr	r2, [r3, #8]
 800b2da:	23a0      	movs	r3, #160	; 0xa0
 800b2dc:	00db      	lsls	r3, r3, #3
 800b2de:	429a      	cmp	r2, r3
 800b2e0:	d10e      	bne.n	800b300 <HAL_RCC_OscConfig+0x514>
 800b2e2:	4b62      	ldr	r3, [pc, #392]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b2e4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b2e6:	4b61      	ldr	r3, [pc, #388]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b2e8:	2180      	movs	r1, #128	; 0x80
 800b2ea:	00c9      	lsls	r1, r1, #3
 800b2ec:	430a      	orrs	r2, r1
 800b2ee:	651a      	str	r2, [r3, #80]	; 0x50
 800b2f0:	4b5e      	ldr	r3, [pc, #376]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b2f2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b2f4:	4b5d      	ldr	r3, [pc, #372]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b2f6:	2180      	movs	r1, #128	; 0x80
 800b2f8:	0049      	lsls	r1, r1, #1
 800b2fa:	430a      	orrs	r2, r1
 800b2fc:	651a      	str	r2, [r3, #80]	; 0x50
 800b2fe:	e00b      	b.n	800b318 <HAL_RCC_OscConfig+0x52c>
 800b300:	4b5a      	ldr	r3, [pc, #360]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b302:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b304:	4b59      	ldr	r3, [pc, #356]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b306:	495b      	ldr	r1, [pc, #364]	; (800b474 <HAL_RCC_OscConfig+0x688>)
 800b308:	400a      	ands	r2, r1
 800b30a:	651a      	str	r2, [r3, #80]	; 0x50
 800b30c:	4b57      	ldr	r3, [pc, #348]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b30e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b310:	4b56      	ldr	r3, [pc, #344]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b312:	495a      	ldr	r1, [pc, #360]	; (800b47c <HAL_RCC_OscConfig+0x690>)
 800b314:	400a      	ands	r2, r1
 800b316:	651a      	str	r2, [r3, #80]	; 0x50
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800b318:	687b      	ldr	r3, [r7, #4]
 800b31a:	689b      	ldr	r3, [r3, #8]
 800b31c:	2b00      	cmp	r3, #0
 800b31e:	d015      	beq.n	800b34c <HAL_RCC_OscConfig+0x560>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800b320:	f7fd ff0e 	bl	8009140 <HAL_GetTick>
 800b324:	0003      	movs	r3, r0
 800b326:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800b328:	e009      	b.n	800b33e <HAL_RCC_OscConfig+0x552>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800b32a:	f7fd ff09 	bl	8009140 <HAL_GetTick>
 800b32e:	0002      	movs	r2, r0
 800b330:	697b      	ldr	r3, [r7, #20]
 800b332:	1ad3      	subs	r3, r2, r3
 800b334:	4a52      	ldr	r2, [pc, #328]	; (800b480 <HAL_RCC_OscConfig+0x694>)
 800b336:	4293      	cmp	r3, r2
 800b338:	d901      	bls.n	800b33e <HAL_RCC_OscConfig+0x552>
        {
          return HAL_TIMEOUT;
 800b33a:	2303      	movs	r3, #3
 800b33c:	e11b      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800b33e:	4b4b      	ldr	r3, [pc, #300]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b340:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b342:	2380      	movs	r3, #128	; 0x80
 800b344:	009b      	lsls	r3, r3, #2
 800b346:	4013      	ands	r3, r2
 800b348:	d0ef      	beq.n	800b32a <HAL_RCC_OscConfig+0x53e>
 800b34a:	e014      	b.n	800b376 <HAL_RCC_OscConfig+0x58a>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800b34c:	f7fd fef8 	bl	8009140 <HAL_GetTick>
 800b350:	0003      	movs	r3, r0
 800b352:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800b354:	e009      	b.n	800b36a <HAL_RCC_OscConfig+0x57e>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800b356:	f7fd fef3 	bl	8009140 <HAL_GetTick>
 800b35a:	0002      	movs	r2, r0
 800b35c:	697b      	ldr	r3, [r7, #20]
 800b35e:	1ad3      	subs	r3, r2, r3
 800b360:	4a47      	ldr	r2, [pc, #284]	; (800b480 <HAL_RCC_OscConfig+0x694>)
 800b362:	4293      	cmp	r3, r2
 800b364:	d901      	bls.n	800b36a <HAL_RCC_OscConfig+0x57e>
        {
          return HAL_TIMEOUT;
 800b366:	2303      	movs	r3, #3
 800b368:	e105      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800b36a:	4b40      	ldr	r3, [pc, #256]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b36c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b36e:	2380      	movs	r3, #128	; 0x80
 800b370:	009b      	lsls	r3, r3, #2
 800b372:	4013      	ands	r3, r2
 800b374:	d1ef      	bne.n	800b356 <HAL_RCC_OscConfig+0x56a>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800b376:	2323      	movs	r3, #35	; 0x23
 800b378:	18fb      	adds	r3, r7, r3
 800b37a:	781b      	ldrb	r3, [r3, #0]
 800b37c:	2b01      	cmp	r3, #1
 800b37e:	d105      	bne.n	800b38c <HAL_RCC_OscConfig+0x5a0>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800b380:	4b3a      	ldr	r3, [pc, #232]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b382:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b384:	4b39      	ldr	r3, [pc, #228]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b386:	493f      	ldr	r1, [pc, #252]	; (800b484 <HAL_RCC_OscConfig+0x698>)
 800b388:	400a      	ands	r2, r1
 800b38a:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined(RCC_HSI48_SUPPORT)
  /*----------------------------- HSI48 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800b38c:	687b      	ldr	r3, [r7, #4]
 800b38e:	681b      	ldr	r3, [r3, #0]
 800b390:	2220      	movs	r2, #32
 800b392:	4013      	ands	r3, r2
 800b394:	d049      	beq.n	800b42a <HAL_RCC_OscConfig+0x63e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

      /* Check the HSI48 State */
      if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 800b396:	687b      	ldr	r3, [r7, #4]
 800b398:	699b      	ldr	r3, [r3, #24]
 800b39a:	2b00      	cmp	r3, #0
 800b39c:	d026      	beq.n	800b3ec <HAL_RCC_OscConfig+0x600>
      {
        /* Enable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_ENABLE();
 800b39e:	4b33      	ldr	r3, [pc, #204]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b3a0:	689a      	ldr	r2, [r3, #8]
 800b3a2:	4b32      	ldr	r3, [pc, #200]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b3a4:	2101      	movs	r1, #1
 800b3a6:	430a      	orrs	r2, r1
 800b3a8:	609a      	str	r2, [r3, #8]
 800b3aa:	4b30      	ldr	r3, [pc, #192]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b3ac:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800b3ae:	4b2f      	ldr	r3, [pc, #188]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b3b0:	2101      	movs	r1, #1
 800b3b2:	430a      	orrs	r2, r1
 800b3b4:	635a      	str	r2, [r3, #52]	; 0x34
 800b3b6:	4b34      	ldr	r3, [pc, #208]	; (800b488 <HAL_RCC_OscConfig+0x69c>)
 800b3b8:	6a1a      	ldr	r2, [r3, #32]
 800b3ba:	4b33      	ldr	r3, [pc, #204]	; (800b488 <HAL_RCC_OscConfig+0x69c>)
 800b3bc:	2180      	movs	r1, #128	; 0x80
 800b3be:	0189      	lsls	r1, r1, #6
 800b3c0:	430a      	orrs	r2, r1
 800b3c2:	621a      	str	r2, [r3, #32]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b3c4:	f7fd febc 	bl	8009140 <HAL_GetTick>
 800b3c8:	0003      	movs	r3, r0
 800b3ca:	617b      	str	r3, [r7, #20]

        /* Wait till HSI48 is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800b3cc:	e008      	b.n	800b3e0 <HAL_RCC_OscConfig+0x5f4>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800b3ce:	f7fd feb7 	bl	8009140 <HAL_GetTick>
 800b3d2:	0002      	movs	r2, r0
 800b3d4:	697b      	ldr	r3, [r7, #20]
 800b3d6:	1ad3      	subs	r3, r2, r3
 800b3d8:	2b02      	cmp	r3, #2
 800b3da:	d901      	bls.n	800b3e0 <HAL_RCC_OscConfig+0x5f4>
          {
            return HAL_TIMEOUT;
 800b3dc:	2303      	movs	r3, #3
 800b3de:	e0ca      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800b3e0:	4b22      	ldr	r3, [pc, #136]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b3e2:	689b      	ldr	r3, [r3, #8]
 800b3e4:	2202      	movs	r2, #2
 800b3e6:	4013      	ands	r3, r2
 800b3e8:	d0f1      	beq.n	800b3ce <HAL_RCC_OscConfig+0x5e2>
 800b3ea:	e01e      	b.n	800b42a <HAL_RCC_OscConfig+0x63e>
        }
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_DISABLE();
 800b3ec:	4b1f      	ldr	r3, [pc, #124]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b3ee:	689a      	ldr	r2, [r3, #8]
 800b3f0:	4b1e      	ldr	r3, [pc, #120]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b3f2:	2101      	movs	r1, #1
 800b3f4:	438a      	bics	r2, r1
 800b3f6:	609a      	str	r2, [r3, #8]
 800b3f8:	4b23      	ldr	r3, [pc, #140]	; (800b488 <HAL_RCC_OscConfig+0x69c>)
 800b3fa:	6a1a      	ldr	r2, [r3, #32]
 800b3fc:	4b22      	ldr	r3, [pc, #136]	; (800b488 <HAL_RCC_OscConfig+0x69c>)
 800b3fe:	4923      	ldr	r1, [pc, #140]	; (800b48c <HAL_RCC_OscConfig+0x6a0>)
 800b400:	400a      	ands	r2, r1
 800b402:	621a      	str	r2, [r3, #32]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b404:	f7fd fe9c 	bl	8009140 <HAL_GetTick>
 800b408:	0003      	movs	r3, r0
 800b40a:	617b      	str	r3, [r7, #20]

        /* Wait till HSI48 is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800b40c:	e008      	b.n	800b420 <HAL_RCC_OscConfig+0x634>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800b40e:	f7fd fe97 	bl	8009140 <HAL_GetTick>
 800b412:	0002      	movs	r2, r0
 800b414:	697b      	ldr	r3, [r7, #20]
 800b416:	1ad3      	subs	r3, r2, r3
 800b418:	2b02      	cmp	r3, #2
 800b41a:	d901      	bls.n	800b420 <HAL_RCC_OscConfig+0x634>
          {
            return HAL_TIMEOUT;
 800b41c:	2303      	movs	r3, #3
 800b41e:	e0aa      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800b420:	4b12      	ldr	r3, [pc, #72]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b422:	689b      	ldr	r3, [r3, #8]
 800b424:	2202      	movs	r2, #2
 800b426:	4013      	ands	r3, r2
 800b428:	d1f1      	bne.n	800b40e <HAL_RCC_OscConfig+0x622>
#endif /* RCC_HSI48_SUPPORT */

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800b42a:	687b      	ldr	r3, [r7, #4]
 800b42c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b42e:	2b00      	cmp	r3, #0
 800b430:	d100      	bne.n	800b434 <HAL_RCC_OscConfig+0x648>
 800b432:	e09f      	b.n	800b574 <HAL_RCC_OscConfig+0x788>
  {
    /* Check if the PLL is used as system clock or not */
    if(sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800b434:	69fb      	ldr	r3, [r7, #28]
 800b436:	2b0c      	cmp	r3, #12
 800b438:	d100      	bne.n	800b43c <HAL_RCC_OscConfig+0x650>
 800b43a:	e078      	b.n	800b52e <HAL_RCC_OscConfig+0x742>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800b43c:	687b      	ldr	r3, [r7, #4]
 800b43e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b440:	2b02      	cmp	r3, #2
 800b442:	d159      	bne.n	800b4f8 <HAL_RCC_OscConfig+0x70c>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800b444:	4b09      	ldr	r3, [pc, #36]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b446:	681a      	ldr	r2, [r3, #0]
 800b448:	4b08      	ldr	r3, [pc, #32]	; (800b46c <HAL_RCC_OscConfig+0x680>)
 800b44a:	4911      	ldr	r1, [pc, #68]	; (800b490 <HAL_RCC_OscConfig+0x6a4>)
 800b44c:	400a      	ands	r2, r1
 800b44e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b450:	f7fd fe76 	bl	8009140 <HAL_GetTick>
 800b454:	0003      	movs	r3, r0
 800b456:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800b458:	e01c      	b.n	800b494 <HAL_RCC_OscConfig+0x6a8>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800b45a:	f7fd fe71 	bl	8009140 <HAL_GetTick>
 800b45e:	0002      	movs	r2, r0
 800b460:	697b      	ldr	r3, [r7, #20]
 800b462:	1ad3      	subs	r3, r2, r3
 800b464:	2b02      	cmp	r3, #2
 800b466:	d915      	bls.n	800b494 <HAL_RCC_OscConfig+0x6a8>
          {
            return HAL_TIMEOUT;
 800b468:	2303      	movs	r3, #3
 800b46a:	e084      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
 800b46c:	40021000 	.word	0x40021000
 800b470:	ffff1fff 	.word	0xffff1fff
 800b474:	fffffeff 	.word	0xfffffeff
 800b478:	40007000 	.word	0x40007000
 800b47c:	fffffbff 	.word	0xfffffbff
 800b480:	00001388 	.word	0x00001388
 800b484:	efffffff 	.word	0xefffffff
 800b488:	40010000 	.word	0x40010000
 800b48c:	ffffdfff 	.word	0xffffdfff
 800b490:	feffffff 	.word	0xfeffffff
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800b494:	4b3a      	ldr	r3, [pc, #232]	; (800b580 <HAL_RCC_OscConfig+0x794>)
 800b496:	681a      	ldr	r2, [r3, #0]
 800b498:	2380      	movs	r3, #128	; 0x80
 800b49a:	049b      	lsls	r3, r3, #18
 800b49c:	4013      	ands	r3, r2
 800b49e:	d1dc      	bne.n	800b45a <HAL_RCC_OscConfig+0x66e>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800b4a0:	4b37      	ldr	r3, [pc, #220]	; (800b580 <HAL_RCC_OscConfig+0x794>)
 800b4a2:	68db      	ldr	r3, [r3, #12]
 800b4a4:	4a37      	ldr	r2, [pc, #220]	; (800b584 <HAL_RCC_OscConfig+0x798>)
 800b4a6:	4013      	ands	r3, r2
 800b4a8:	0019      	movs	r1, r3
 800b4aa:	687b      	ldr	r3, [r7, #4]
 800b4ac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b4ae:	687b      	ldr	r3, [r7, #4]
 800b4b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b4b2:	431a      	orrs	r2, r3
 800b4b4:	687b      	ldr	r3, [r7, #4]
 800b4b6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800b4b8:	431a      	orrs	r2, r3
 800b4ba:	4b31      	ldr	r3, [pc, #196]	; (800b580 <HAL_RCC_OscConfig+0x794>)
 800b4bc:	430a      	orrs	r2, r1
 800b4be:	60da      	str	r2, [r3, #12]
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800b4c0:	4b2f      	ldr	r3, [pc, #188]	; (800b580 <HAL_RCC_OscConfig+0x794>)
 800b4c2:	681a      	ldr	r2, [r3, #0]
 800b4c4:	4b2e      	ldr	r3, [pc, #184]	; (800b580 <HAL_RCC_OscConfig+0x794>)
 800b4c6:	2180      	movs	r1, #128	; 0x80
 800b4c8:	0449      	lsls	r1, r1, #17
 800b4ca:	430a      	orrs	r2, r1
 800b4cc:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b4ce:	f7fd fe37 	bl	8009140 <HAL_GetTick>
 800b4d2:	0003      	movs	r3, r0
 800b4d4:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 800b4d6:	e008      	b.n	800b4ea <HAL_RCC_OscConfig+0x6fe>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800b4d8:	f7fd fe32 	bl	8009140 <HAL_GetTick>
 800b4dc:	0002      	movs	r2, r0
 800b4de:	697b      	ldr	r3, [r7, #20]
 800b4e0:	1ad3      	subs	r3, r2, r3
 800b4e2:	2b02      	cmp	r3, #2
 800b4e4:	d901      	bls.n	800b4ea <HAL_RCC_OscConfig+0x6fe>
          {
            return HAL_TIMEOUT;
 800b4e6:	2303      	movs	r3, #3
 800b4e8:	e045      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 800b4ea:	4b25      	ldr	r3, [pc, #148]	; (800b580 <HAL_RCC_OscConfig+0x794>)
 800b4ec:	681a      	ldr	r2, [r3, #0]
 800b4ee:	2380      	movs	r3, #128	; 0x80
 800b4f0:	049b      	lsls	r3, r3, #18
 800b4f2:	4013      	ands	r3, r2
 800b4f4:	d0f0      	beq.n	800b4d8 <HAL_RCC_OscConfig+0x6ec>
 800b4f6:	e03d      	b.n	800b574 <HAL_RCC_OscConfig+0x788>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800b4f8:	4b21      	ldr	r3, [pc, #132]	; (800b580 <HAL_RCC_OscConfig+0x794>)
 800b4fa:	681a      	ldr	r2, [r3, #0]
 800b4fc:	4b20      	ldr	r3, [pc, #128]	; (800b580 <HAL_RCC_OscConfig+0x794>)
 800b4fe:	4922      	ldr	r1, [pc, #136]	; (800b588 <HAL_RCC_OscConfig+0x79c>)
 800b500:	400a      	ands	r2, r1
 800b502:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b504:	f7fd fe1c 	bl	8009140 <HAL_GetTick>
 800b508:	0003      	movs	r3, r0
 800b50a:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800b50c:	e008      	b.n	800b520 <HAL_RCC_OscConfig+0x734>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800b50e:	f7fd fe17 	bl	8009140 <HAL_GetTick>
 800b512:	0002      	movs	r2, r0
 800b514:	697b      	ldr	r3, [r7, #20]
 800b516:	1ad3      	subs	r3, r2, r3
 800b518:	2b02      	cmp	r3, #2
 800b51a:	d901      	bls.n	800b520 <HAL_RCC_OscConfig+0x734>
          {
            return HAL_TIMEOUT;
 800b51c:	2303      	movs	r3, #3
 800b51e:	e02a      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800b520:	4b17      	ldr	r3, [pc, #92]	; (800b580 <HAL_RCC_OscConfig+0x794>)
 800b522:	681a      	ldr	r2, [r3, #0]
 800b524:	2380      	movs	r3, #128	; 0x80
 800b526:	049b      	lsls	r3, r3, #18
 800b528:	4013      	ands	r3, r2
 800b52a:	d1f0      	bne.n	800b50e <HAL_RCC_OscConfig+0x722>
 800b52c:	e022      	b.n	800b574 <HAL_RCC_OscConfig+0x788>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800b52e:	687b      	ldr	r3, [r7, #4]
 800b530:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b532:	2b01      	cmp	r3, #1
 800b534:	d101      	bne.n	800b53a <HAL_RCC_OscConfig+0x74e>
      {
        return HAL_ERROR;
 800b536:	2301      	movs	r3, #1
 800b538:	e01d      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 800b53a:	4b11      	ldr	r3, [pc, #68]	; (800b580 <HAL_RCC_OscConfig+0x794>)
 800b53c:	68db      	ldr	r3, [r3, #12]
 800b53e:	61bb      	str	r3, [r7, #24]
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800b540:	69ba      	ldr	r2, [r7, #24]
 800b542:	2380      	movs	r3, #128	; 0x80
 800b544:	025b      	lsls	r3, r3, #9
 800b546:	401a      	ands	r2, r3
 800b548:	687b      	ldr	r3, [r7, #4]
 800b54a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b54c:	429a      	cmp	r2, r3
 800b54e:	d10f      	bne.n	800b570 <HAL_RCC_OscConfig+0x784>
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 800b550:	69ba      	ldr	r2, [r7, #24]
 800b552:	23f0      	movs	r3, #240	; 0xf0
 800b554:	039b      	lsls	r3, r3, #14
 800b556:	401a      	ands	r2, r3
 800b558:	687b      	ldr	r3, [r7, #4]
 800b55a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800b55c:	429a      	cmp	r2, r3
 800b55e:	d107      	bne.n	800b570 <HAL_RCC_OscConfig+0x784>
           (READ_BIT(pll_config, RCC_CFGR_PLLDIV) != RCC_OscInitStruct->PLL.PLLDIV))
 800b560:	69ba      	ldr	r2, [r7, #24]
 800b562:	23c0      	movs	r3, #192	; 0xc0
 800b564:	041b      	lsls	r3, r3, #16
 800b566:	401a      	ands	r2, r3
 800b568:	687b      	ldr	r3, [r7, #4]
 800b56a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 800b56c:	429a      	cmp	r2, r3
 800b56e:	d001      	beq.n	800b574 <HAL_RCC_OscConfig+0x788>
        {
          return HAL_ERROR;
 800b570:	2301      	movs	r3, #1
 800b572:	e000      	b.n	800b576 <HAL_RCC_OscConfig+0x78a>
        }
      }
    }
  }

  return HAL_OK;
 800b574:	2300      	movs	r3, #0
}
 800b576:	0018      	movs	r0, r3
 800b578:	46bd      	mov	sp, r7
 800b57a:	b00a      	add	sp, #40	; 0x28
 800b57c:	bdb0      	pop	{r4, r5, r7, pc}
 800b57e:	46c0      	nop			; (mov r8, r8)
 800b580:	40021000 	.word	0x40021000
 800b584:	ff02ffff 	.word	0xff02ffff
 800b588:	feffffff 	.word	0xfeffffff

0800b58c <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800b58c:	b5b0      	push	{r4, r5, r7, lr}
 800b58e:	b084      	sub	sp, #16
 800b590:	af00      	add	r7, sp, #0
 800b592:	6078      	str	r0, [r7, #4]
 800b594:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status;

  /* Check the parameters */
  if(RCC_ClkInitStruct == NULL)
 800b596:	687b      	ldr	r3, [r7, #4]
 800b598:	2b00      	cmp	r3, #0
 800b59a:	d101      	bne.n	800b5a0 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 800b59c:	2301      	movs	r3, #1
 800b59e:	e10d      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
  must be correctly programmed according to the frequency of the CPU clock
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800b5a0:	4b88      	ldr	r3, [pc, #544]	; (800b7c4 <HAL_RCC_ClockConfig+0x238>)
 800b5a2:	681b      	ldr	r3, [r3, #0]
 800b5a4:	2201      	movs	r2, #1
 800b5a6:	4013      	ands	r3, r2
 800b5a8:	683a      	ldr	r2, [r7, #0]
 800b5aa:	429a      	cmp	r2, r3
 800b5ac:	d911      	bls.n	800b5d2 <HAL_RCC_ClockConfig+0x46>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800b5ae:	4b85      	ldr	r3, [pc, #532]	; (800b7c4 <HAL_RCC_ClockConfig+0x238>)
 800b5b0:	681b      	ldr	r3, [r3, #0]
 800b5b2:	2201      	movs	r2, #1
 800b5b4:	4393      	bics	r3, r2
 800b5b6:	0019      	movs	r1, r3
 800b5b8:	4b82      	ldr	r3, [pc, #520]	; (800b7c4 <HAL_RCC_ClockConfig+0x238>)
 800b5ba:	683a      	ldr	r2, [r7, #0]
 800b5bc:	430a      	orrs	r2, r1
 800b5be:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800b5c0:	4b80      	ldr	r3, [pc, #512]	; (800b7c4 <HAL_RCC_ClockConfig+0x238>)
 800b5c2:	681b      	ldr	r3, [r3, #0]
 800b5c4:	2201      	movs	r2, #1
 800b5c6:	4013      	ands	r3, r2
 800b5c8:	683a      	ldr	r2, [r7, #0]
 800b5ca:	429a      	cmp	r2, r3
 800b5cc:	d001      	beq.n	800b5d2 <HAL_RCC_ClockConfig+0x46>
    {
      return HAL_ERROR;
 800b5ce:	2301      	movs	r3, #1
 800b5d0:	e0f4      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800b5d2:	687b      	ldr	r3, [r7, #4]
 800b5d4:	681b      	ldr	r3, [r3, #0]
 800b5d6:	2202      	movs	r2, #2
 800b5d8:	4013      	ands	r3, r2
 800b5da:	d009      	beq.n	800b5f0 <HAL_RCC_ClockConfig+0x64>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800b5dc:	4b7a      	ldr	r3, [pc, #488]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b5de:	68db      	ldr	r3, [r3, #12]
 800b5e0:	22f0      	movs	r2, #240	; 0xf0
 800b5e2:	4393      	bics	r3, r2
 800b5e4:	0019      	movs	r1, r3
 800b5e6:	687b      	ldr	r3, [r7, #4]
 800b5e8:	689a      	ldr	r2, [r3, #8]
 800b5ea:	4b77      	ldr	r3, [pc, #476]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b5ec:	430a      	orrs	r2, r1
 800b5ee:	60da      	str	r2, [r3, #12]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800b5f0:	687b      	ldr	r3, [r7, #4]
 800b5f2:	681b      	ldr	r3, [r3, #0]
 800b5f4:	2201      	movs	r2, #1
 800b5f6:	4013      	ands	r3, r2
 800b5f8:	d100      	bne.n	800b5fc <HAL_RCC_ClockConfig+0x70>
 800b5fa:	e089      	b.n	800b710 <HAL_RCC_ClockConfig+0x184>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800b5fc:	687b      	ldr	r3, [r7, #4]
 800b5fe:	685b      	ldr	r3, [r3, #4]
 800b600:	2b02      	cmp	r3, #2
 800b602:	d107      	bne.n	800b614 <HAL_RCC_ClockConfig+0x88>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800b604:	4b70      	ldr	r3, [pc, #448]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b606:	681a      	ldr	r2, [r3, #0]
 800b608:	2380      	movs	r3, #128	; 0x80
 800b60a:	029b      	lsls	r3, r3, #10
 800b60c:	4013      	ands	r3, r2
 800b60e:	d120      	bne.n	800b652 <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 800b610:	2301      	movs	r3, #1
 800b612:	e0d3      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800b614:	687b      	ldr	r3, [r7, #4]
 800b616:	685b      	ldr	r3, [r3, #4]
 800b618:	2b03      	cmp	r3, #3
 800b61a:	d107      	bne.n	800b62c <HAL_RCC_ClockConfig+0xa0>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800b61c:	4b6a      	ldr	r3, [pc, #424]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b61e:	681a      	ldr	r2, [r3, #0]
 800b620:	2380      	movs	r3, #128	; 0x80
 800b622:	049b      	lsls	r3, r3, #18
 800b624:	4013      	ands	r3, r2
 800b626:	d114      	bne.n	800b652 <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 800b628:	2301      	movs	r3, #1
 800b62a:	e0c7      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
      }
    }
    /* HSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 800b62c:	687b      	ldr	r3, [r7, #4]
 800b62e:	685b      	ldr	r3, [r3, #4]
 800b630:	2b01      	cmp	r3, #1
 800b632:	d106      	bne.n	800b642 <HAL_RCC_ClockConfig+0xb6>
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800b634:	4b64      	ldr	r3, [pc, #400]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b636:	681b      	ldr	r3, [r3, #0]
 800b638:	2204      	movs	r2, #4
 800b63a:	4013      	ands	r3, r2
 800b63c:	d109      	bne.n	800b652 <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 800b63e:	2301      	movs	r3, #1
 800b640:	e0bc      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
    }
    /* MSI is selected as System Clock Source */
    else
    {
      /* Check the MSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 800b642:	4b61      	ldr	r3, [pc, #388]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b644:	681a      	ldr	r2, [r3, #0]
 800b646:	2380      	movs	r3, #128	; 0x80
 800b648:	009b      	lsls	r3, r3, #2
 800b64a:	4013      	ands	r3, r2
 800b64c:	d101      	bne.n	800b652 <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 800b64e:	2301      	movs	r3, #1
 800b650:	e0b4      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800b652:	4b5d      	ldr	r3, [pc, #372]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b654:	68db      	ldr	r3, [r3, #12]
 800b656:	2203      	movs	r2, #3
 800b658:	4393      	bics	r3, r2
 800b65a:	0019      	movs	r1, r3
 800b65c:	687b      	ldr	r3, [r7, #4]
 800b65e:	685a      	ldr	r2, [r3, #4]
 800b660:	4b59      	ldr	r3, [pc, #356]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b662:	430a      	orrs	r2, r1
 800b664:	60da      	str	r2, [r3, #12]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 800b666:	f7fd fd6b 	bl	8009140 <HAL_GetTick>
 800b66a:	0003      	movs	r3, r0
 800b66c:	60fb      	str	r3, [r7, #12]

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800b66e:	687b      	ldr	r3, [r7, #4]
 800b670:	685b      	ldr	r3, [r3, #4]
 800b672:	2b02      	cmp	r3, #2
 800b674:	d111      	bne.n	800b69a <HAL_RCC_ClockConfig+0x10e>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800b676:	e009      	b.n	800b68c <HAL_RCC_ClockConfig+0x100>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800b678:	f7fd fd62 	bl	8009140 <HAL_GetTick>
 800b67c:	0002      	movs	r2, r0
 800b67e:	68fb      	ldr	r3, [r7, #12]
 800b680:	1ad3      	subs	r3, r2, r3
 800b682:	4a52      	ldr	r2, [pc, #328]	; (800b7cc <HAL_RCC_ClockConfig+0x240>)
 800b684:	4293      	cmp	r3, r2
 800b686:	d901      	bls.n	800b68c <HAL_RCC_ClockConfig+0x100>
        {
          return HAL_TIMEOUT;
 800b688:	2303      	movs	r3, #3
 800b68a:	e097      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800b68c:	4b4e      	ldr	r3, [pc, #312]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b68e:	68db      	ldr	r3, [r3, #12]
 800b690:	220c      	movs	r2, #12
 800b692:	4013      	ands	r3, r2
 800b694:	2b08      	cmp	r3, #8
 800b696:	d1ef      	bne.n	800b678 <HAL_RCC_ClockConfig+0xec>
 800b698:	e03a      	b.n	800b710 <HAL_RCC_ClockConfig+0x184>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800b69a:	687b      	ldr	r3, [r7, #4]
 800b69c:	685b      	ldr	r3, [r3, #4]
 800b69e:	2b03      	cmp	r3, #3
 800b6a0:	d111      	bne.n	800b6c6 <HAL_RCC_ClockConfig+0x13a>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800b6a2:	e009      	b.n	800b6b8 <HAL_RCC_ClockConfig+0x12c>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800b6a4:	f7fd fd4c 	bl	8009140 <HAL_GetTick>
 800b6a8:	0002      	movs	r2, r0
 800b6aa:	68fb      	ldr	r3, [r7, #12]
 800b6ac:	1ad3      	subs	r3, r2, r3
 800b6ae:	4a47      	ldr	r2, [pc, #284]	; (800b7cc <HAL_RCC_ClockConfig+0x240>)
 800b6b0:	4293      	cmp	r3, r2
 800b6b2:	d901      	bls.n	800b6b8 <HAL_RCC_ClockConfig+0x12c>
        {
          return HAL_TIMEOUT;
 800b6b4:	2303      	movs	r3, #3
 800b6b6:	e081      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800b6b8:	4b43      	ldr	r3, [pc, #268]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b6ba:	68db      	ldr	r3, [r3, #12]
 800b6bc:	220c      	movs	r2, #12
 800b6be:	4013      	ands	r3, r2
 800b6c0:	2b0c      	cmp	r3, #12
 800b6c2:	d1ef      	bne.n	800b6a4 <HAL_RCC_ClockConfig+0x118>
 800b6c4:	e024      	b.n	800b710 <HAL_RCC_ClockConfig+0x184>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 800b6c6:	687b      	ldr	r3, [r7, #4]
 800b6c8:	685b      	ldr	r3, [r3, #4]
 800b6ca:	2b01      	cmp	r3, #1
 800b6cc:	d11b      	bne.n	800b706 <HAL_RCC_ClockConfig+0x17a>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800b6ce:	e009      	b.n	800b6e4 <HAL_RCC_ClockConfig+0x158>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800b6d0:	f7fd fd36 	bl	8009140 <HAL_GetTick>
 800b6d4:	0002      	movs	r2, r0
 800b6d6:	68fb      	ldr	r3, [r7, #12]
 800b6d8:	1ad3      	subs	r3, r2, r3
 800b6da:	4a3c      	ldr	r2, [pc, #240]	; (800b7cc <HAL_RCC_ClockConfig+0x240>)
 800b6dc:	4293      	cmp	r3, r2
 800b6de:	d901      	bls.n	800b6e4 <HAL_RCC_ClockConfig+0x158>
        {
          return HAL_TIMEOUT;
 800b6e0:	2303      	movs	r3, #3
 800b6e2:	e06b      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800b6e4:	4b38      	ldr	r3, [pc, #224]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b6e6:	68db      	ldr	r3, [r3, #12]
 800b6e8:	220c      	movs	r2, #12
 800b6ea:	4013      	ands	r3, r2
 800b6ec:	2b04      	cmp	r3, #4
 800b6ee:	d1ef      	bne.n	800b6d0 <HAL_RCC_ClockConfig+0x144>
 800b6f0:	e00e      	b.n	800b710 <HAL_RCC_ClockConfig+0x184>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800b6f2:	f7fd fd25 	bl	8009140 <HAL_GetTick>
 800b6f6:	0002      	movs	r2, r0
 800b6f8:	68fb      	ldr	r3, [r7, #12]
 800b6fa:	1ad3      	subs	r3, r2, r3
 800b6fc:	4a33      	ldr	r2, [pc, #204]	; (800b7cc <HAL_RCC_ClockConfig+0x240>)
 800b6fe:	4293      	cmp	r3, r2
 800b700:	d901      	bls.n	800b706 <HAL_RCC_ClockConfig+0x17a>
        {
          return HAL_TIMEOUT;
 800b702:	2303      	movs	r3, #3
 800b704:	e05a      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 800b706:	4b30      	ldr	r3, [pc, #192]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b708:	68db      	ldr	r3, [r3, #12]
 800b70a:	220c      	movs	r2, #12
 800b70c:	4013      	ands	r3, r2
 800b70e:	d1f0      	bne.n	800b6f2 <HAL_RCC_ClockConfig+0x166>
        }
      }
    }
  }
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800b710:	4b2c      	ldr	r3, [pc, #176]	; (800b7c4 <HAL_RCC_ClockConfig+0x238>)
 800b712:	681b      	ldr	r3, [r3, #0]
 800b714:	2201      	movs	r2, #1
 800b716:	4013      	ands	r3, r2
 800b718:	683a      	ldr	r2, [r7, #0]
 800b71a:	429a      	cmp	r2, r3
 800b71c:	d211      	bcs.n	800b742 <HAL_RCC_ClockConfig+0x1b6>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800b71e:	4b29      	ldr	r3, [pc, #164]	; (800b7c4 <HAL_RCC_ClockConfig+0x238>)
 800b720:	681b      	ldr	r3, [r3, #0]
 800b722:	2201      	movs	r2, #1
 800b724:	4393      	bics	r3, r2
 800b726:	0019      	movs	r1, r3
 800b728:	4b26      	ldr	r3, [pc, #152]	; (800b7c4 <HAL_RCC_ClockConfig+0x238>)
 800b72a:	683a      	ldr	r2, [r7, #0]
 800b72c:	430a      	orrs	r2, r1
 800b72e:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800b730:	4b24      	ldr	r3, [pc, #144]	; (800b7c4 <HAL_RCC_ClockConfig+0x238>)
 800b732:	681b      	ldr	r3, [r3, #0]
 800b734:	2201      	movs	r2, #1
 800b736:	4013      	ands	r3, r2
 800b738:	683a      	ldr	r2, [r7, #0]
 800b73a:	429a      	cmp	r2, r3
 800b73c:	d001      	beq.n	800b742 <HAL_RCC_ClockConfig+0x1b6>
    {
      return HAL_ERROR;
 800b73e:	2301      	movs	r3, #1
 800b740:	e03c      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800b742:	687b      	ldr	r3, [r7, #4]
 800b744:	681b      	ldr	r3, [r3, #0]
 800b746:	2204      	movs	r2, #4
 800b748:	4013      	ands	r3, r2
 800b74a:	d009      	beq.n	800b760 <HAL_RCC_ClockConfig+0x1d4>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800b74c:	4b1e      	ldr	r3, [pc, #120]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b74e:	68db      	ldr	r3, [r3, #12]
 800b750:	4a1f      	ldr	r2, [pc, #124]	; (800b7d0 <HAL_RCC_ClockConfig+0x244>)
 800b752:	4013      	ands	r3, r2
 800b754:	0019      	movs	r1, r3
 800b756:	687b      	ldr	r3, [r7, #4]
 800b758:	68da      	ldr	r2, [r3, #12]
 800b75a:	4b1b      	ldr	r3, [pc, #108]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b75c:	430a      	orrs	r2, r1
 800b75e:	60da      	str	r2, [r3, #12]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800b760:	687b      	ldr	r3, [r7, #4]
 800b762:	681b      	ldr	r3, [r3, #0]
 800b764:	2208      	movs	r2, #8
 800b766:	4013      	ands	r3, r2
 800b768:	d00a      	beq.n	800b780 <HAL_RCC_ClockConfig+0x1f4>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800b76a:	4b17      	ldr	r3, [pc, #92]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b76c:	68db      	ldr	r3, [r3, #12]
 800b76e:	4a19      	ldr	r2, [pc, #100]	; (800b7d4 <HAL_RCC_ClockConfig+0x248>)
 800b770:	4013      	ands	r3, r2
 800b772:	0019      	movs	r1, r3
 800b774:	687b      	ldr	r3, [r7, #4]
 800b776:	691b      	ldr	r3, [r3, #16]
 800b778:	00da      	lsls	r2, r3, #3
 800b77a:	4b13      	ldr	r3, [pc, #76]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b77c:	430a      	orrs	r2, r1
 800b77e:	60da      	str	r2, [r3, #12]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800b780:	f000 f82e 	bl	800b7e0 <HAL_RCC_GetSysClockFreq>
 800b784:	0001      	movs	r1, r0
 800b786:	4b10      	ldr	r3, [pc, #64]	; (800b7c8 <HAL_RCC_ClockConfig+0x23c>)
 800b788:	68db      	ldr	r3, [r3, #12]
 800b78a:	091b      	lsrs	r3, r3, #4
 800b78c:	220f      	movs	r2, #15
 800b78e:	4013      	ands	r3, r2
 800b790:	4a11      	ldr	r2, [pc, #68]	; (800b7d8 <HAL_RCC_ClockConfig+0x24c>)
 800b792:	5cd3      	ldrb	r3, [r2, r3]
 800b794:	000a      	movs	r2, r1
 800b796:	40da      	lsrs	r2, r3
 800b798:	4b10      	ldr	r3, [pc, #64]	; (800b7dc <HAL_RCC_ClockConfig+0x250>)
 800b79a:	601a      	str	r2, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(TICK_INT_PRIORITY);
 800b79c:	250b      	movs	r5, #11
 800b79e:	197c      	adds	r4, r7, r5
 800b7a0:	2003      	movs	r0, #3
 800b7a2:	f011 f970 	bl	801ca86 <HAL_InitTick>
 800b7a6:	0003      	movs	r3, r0
 800b7a8:	7023      	strb	r3, [r4, #0]
  if(status != HAL_OK)
 800b7aa:	002a      	movs	r2, r5
 800b7ac:	18bb      	adds	r3, r7, r2
 800b7ae:	781b      	ldrb	r3, [r3, #0]
 800b7b0:	2b00      	cmp	r3, #0
 800b7b2:	d002      	beq.n	800b7ba <HAL_RCC_ClockConfig+0x22e>
  {
    return status;
 800b7b4:	18bb      	adds	r3, r7, r2
 800b7b6:	781b      	ldrb	r3, [r3, #0]
 800b7b8:	e000      	b.n	800b7bc <HAL_RCC_ClockConfig+0x230>
  }

  return HAL_OK;
 800b7ba:	2300      	movs	r3, #0
}
 800b7bc:	0018      	movs	r0, r3
 800b7be:	46bd      	mov	sp, r7
 800b7c0:	b004      	add	sp, #16
 800b7c2:	bdb0      	pop	{r4, r5, r7, pc}
 800b7c4:	40022000 	.word	0x40022000
 800b7c8:	40021000 	.word	0x40021000
 800b7cc:	00001388 	.word	0x00001388
 800b7d0:	fffff8ff 	.word	0xfffff8ff
 800b7d4:	ffffc7ff 	.word	0xffffc7ff
 800b7d8:	0801ee04 	.word	0x0801ee04
 800b7dc:	20000188 	.word	0x20000188

0800b7e0 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800b7e0:	b580      	push	{r7, lr}
 800b7e2:	b086      	sub	sp, #24
 800b7e4:	af00      	add	r7, sp, #0
  uint32_t tmpreg, pllm, plld, pllvco, msiclkrange;    /* no init needed */
  uint32_t sysclockfreq;

  tmpreg = RCC->CFGR;
 800b7e6:	4b3c      	ldr	r3, [pc, #240]	; (800b8d8 <HAL_RCC_GetSysClockFreq+0xf8>)
 800b7e8:	68db      	ldr	r3, [r3, #12]
 800b7ea:	60fb      	str	r3, [r7, #12]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 800b7ec:	68fb      	ldr	r3, [r7, #12]
 800b7ee:	220c      	movs	r2, #12
 800b7f0:	4013      	ands	r3, r2
 800b7f2:	2b0c      	cmp	r3, #12
 800b7f4:	d013      	beq.n	800b81e <HAL_RCC_GetSysClockFreq+0x3e>
 800b7f6:	d85c      	bhi.n	800b8b2 <HAL_RCC_GetSysClockFreq+0xd2>
 800b7f8:	2b04      	cmp	r3, #4
 800b7fa:	d002      	beq.n	800b802 <HAL_RCC_GetSysClockFreq+0x22>
 800b7fc:	2b08      	cmp	r3, #8
 800b7fe:	d00b      	beq.n	800b818 <HAL_RCC_GetSysClockFreq+0x38>
 800b800:	e057      	b.n	800b8b2 <HAL_RCC_GetSysClockFreq+0xd2>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 800b802:	4b35      	ldr	r3, [pc, #212]	; (800b8d8 <HAL_RCC_GetSysClockFreq+0xf8>)
 800b804:	681b      	ldr	r3, [r3, #0]
 800b806:	2210      	movs	r2, #16
 800b808:	4013      	ands	r3, r2
 800b80a:	d002      	beq.n	800b812 <HAL_RCC_GetSysClockFreq+0x32>
      {
        sysclockfreq =  (HSI_VALUE >> 2);
 800b80c:	4b33      	ldr	r3, [pc, #204]	; (800b8dc <HAL_RCC_GetSysClockFreq+0xfc>)
 800b80e:	613b      	str	r3, [r7, #16]
      }
      else
      {
        sysclockfreq =  HSI_VALUE;
      }
      break;
 800b810:	e05d      	b.n	800b8ce <HAL_RCC_GetSysClockFreq+0xee>
        sysclockfreq =  HSI_VALUE;
 800b812:	4b33      	ldr	r3, [pc, #204]	; (800b8e0 <HAL_RCC_GetSysClockFreq+0x100>)
 800b814:	613b      	str	r3, [r7, #16]
      break;
 800b816:	e05a      	b.n	800b8ce <HAL_RCC_GetSysClockFreq+0xee>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 800b818:	4b32      	ldr	r3, [pc, #200]	; (800b8e4 <HAL_RCC_GetSysClockFreq+0x104>)
 800b81a:	613b      	str	r3, [r7, #16]
      break;
 800b81c:	e057      	b.n	800b8ce <HAL_RCC_GetSysClockFreq+0xee>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_Pos];
 800b81e:	68fb      	ldr	r3, [r7, #12]
 800b820:	0c9b      	lsrs	r3, r3, #18
 800b822:	220f      	movs	r2, #15
 800b824:	4013      	ands	r3, r2
 800b826:	4a30      	ldr	r2, [pc, #192]	; (800b8e8 <HAL_RCC_GetSysClockFreq+0x108>)
 800b828:	5cd3      	ldrb	r3, [r2, r3]
 800b82a:	60bb      	str	r3, [r7, #8]
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_Pos) + 1U;
 800b82c:	68fb      	ldr	r3, [r7, #12]
 800b82e:	0d9b      	lsrs	r3, r3, #22
 800b830:	2203      	movs	r2, #3
 800b832:	4013      	ands	r3, r2
 800b834:	3301      	adds	r3, #1
 800b836:	607b      	str	r3, [r7, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800b838:	4b27      	ldr	r3, [pc, #156]	; (800b8d8 <HAL_RCC_GetSysClockFreq+0xf8>)
 800b83a:	68da      	ldr	r2, [r3, #12]
 800b83c:	2380      	movs	r3, #128	; 0x80
 800b83e:	025b      	lsls	r3, r3, #9
 800b840:	4013      	ands	r3, r2
 800b842:	d00f      	beq.n	800b864 <HAL_RCC_GetSysClockFreq+0x84>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE * pllm) / plld;
 800b844:	68b9      	ldr	r1, [r7, #8]
 800b846:	000a      	movs	r2, r1
 800b848:	0152      	lsls	r2, r2, #5
 800b84a:	1a52      	subs	r2, r2, r1
 800b84c:	0193      	lsls	r3, r2, #6
 800b84e:	1a9b      	subs	r3, r3, r2
 800b850:	00db      	lsls	r3, r3, #3
 800b852:	185b      	adds	r3, r3, r1
 800b854:	025b      	lsls	r3, r3, #9
 800b856:	6879      	ldr	r1, [r7, #4]
 800b858:	0018      	movs	r0, r3
 800b85a:	f7f4 fc5f 	bl	800011c <__udivsi3>
 800b85e:	0003      	movs	r3, r0
 800b860:	617b      	str	r3, [r7, #20]
 800b862:	e023      	b.n	800b8ac <HAL_RCC_GetSysClockFreq+0xcc>
      }
      else
      {
        if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 800b864:	4b1c      	ldr	r3, [pc, #112]	; (800b8d8 <HAL_RCC_GetSysClockFreq+0xf8>)
 800b866:	681b      	ldr	r3, [r3, #0]
 800b868:	2210      	movs	r2, #16
 800b86a:	4013      	ands	r3, r2
 800b86c:	d00f      	beq.n	800b88e <HAL_RCC_GetSysClockFreq+0xae>
        {
          pllvco = ((HSI_VALUE >> 2) * pllm) / plld;
 800b86e:	68b9      	ldr	r1, [r7, #8]
 800b870:	000a      	movs	r2, r1
 800b872:	0152      	lsls	r2, r2, #5
 800b874:	1a52      	subs	r2, r2, r1
 800b876:	0193      	lsls	r3, r2, #6
 800b878:	1a9b      	subs	r3, r3, r2
 800b87a:	00db      	lsls	r3, r3, #3
 800b87c:	185b      	adds	r3, r3, r1
 800b87e:	021b      	lsls	r3, r3, #8
 800b880:	6879      	ldr	r1, [r7, #4]
 800b882:	0018      	movs	r0, r3
 800b884:	f7f4 fc4a 	bl	800011c <__udivsi3>
 800b888:	0003      	movs	r3, r0
 800b88a:	617b      	str	r3, [r7, #20]
 800b88c:	e00e      	b.n	800b8ac <HAL_RCC_GetSysClockFreq+0xcc>
        }
        else
        {
         pllvco = (HSI_VALUE * pllm) / plld;
 800b88e:	68b9      	ldr	r1, [r7, #8]
 800b890:	000a      	movs	r2, r1
 800b892:	0152      	lsls	r2, r2, #5
 800b894:	1a52      	subs	r2, r2, r1
 800b896:	0193      	lsls	r3, r2, #6
 800b898:	1a9b      	subs	r3, r3, r2
 800b89a:	00db      	lsls	r3, r3, #3
 800b89c:	185b      	adds	r3, r3, r1
 800b89e:	029b      	lsls	r3, r3, #10
 800b8a0:	6879      	ldr	r1, [r7, #4]
 800b8a2:	0018      	movs	r0, r3
 800b8a4:	f7f4 fc3a 	bl	800011c <__udivsi3>
 800b8a8:	0003      	movs	r3, r0
 800b8aa:	617b      	str	r3, [r7, #20]
        }
      }
      sysclockfreq = pllvco;
 800b8ac:	697b      	ldr	r3, [r7, #20]
 800b8ae:	613b      	str	r3, [r7, #16]
      break;
 800b8b0:	e00d      	b.n	800b8ce <HAL_RCC_GetSysClockFreq+0xee>
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_Pos;
 800b8b2:	4b09      	ldr	r3, [pc, #36]	; (800b8d8 <HAL_RCC_GetSysClockFreq+0xf8>)
 800b8b4:	685b      	ldr	r3, [r3, #4]
 800b8b6:	0b5b      	lsrs	r3, r3, #13
 800b8b8:	2207      	movs	r2, #7
 800b8ba:	4013      	ands	r3, r2
 800b8bc:	603b      	str	r3, [r7, #0]
      sysclockfreq = (32768U * (1UL << (msiclkrange + 1U)));
 800b8be:	683b      	ldr	r3, [r7, #0]
 800b8c0:	3301      	adds	r3, #1
 800b8c2:	2280      	movs	r2, #128	; 0x80
 800b8c4:	0212      	lsls	r2, r2, #8
 800b8c6:	409a      	lsls	r2, r3
 800b8c8:	0013      	movs	r3, r2
 800b8ca:	613b      	str	r3, [r7, #16]
      break;
 800b8cc:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sysclockfreq;
 800b8ce:	693b      	ldr	r3, [r7, #16]
}
 800b8d0:	0018      	movs	r0, r3
 800b8d2:	46bd      	mov	sp, r7
 800b8d4:	b006      	add	sp, #24
 800b8d6:	bd80      	pop	{r7, pc}
 800b8d8:	40021000 	.word	0x40021000
 800b8dc:	003d0900 	.word	0x003d0900
 800b8e0:	00f42400 	.word	0x00f42400
 800b8e4:	007a1200 	.word	0x007a1200
 800b8e8:	0801ee1c 	.word	0x0801ee1c

0800b8ec <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800b8ec:	b580      	push	{r7, lr}
 800b8ee:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800b8f0:	4b02      	ldr	r3, [pc, #8]	; (800b8fc <HAL_RCC_GetHCLKFreq+0x10>)
 800b8f2:	681b      	ldr	r3, [r3, #0]
}
 800b8f4:	0018      	movs	r0, r3
 800b8f6:	46bd      	mov	sp, r7
 800b8f8:	bd80      	pop	{r7, pc}
 800b8fa:	46c0      	nop			; (mov r8, r8)
 800b8fc:	20000188 	.word	0x20000188

0800b900 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800b900:	b580      	push	{r7, lr}
 800b902:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800b904:	f7ff fff2 	bl	800b8ec <HAL_RCC_GetHCLKFreq>
 800b908:	0001      	movs	r1, r0
 800b90a:	4b06      	ldr	r3, [pc, #24]	; (800b924 <HAL_RCC_GetPCLK1Freq+0x24>)
 800b90c:	68db      	ldr	r3, [r3, #12]
 800b90e:	0a1b      	lsrs	r3, r3, #8
 800b910:	2207      	movs	r2, #7
 800b912:	4013      	ands	r3, r2
 800b914:	4a04      	ldr	r2, [pc, #16]	; (800b928 <HAL_RCC_GetPCLK1Freq+0x28>)
 800b916:	5cd3      	ldrb	r3, [r2, r3]
 800b918:	40d9      	lsrs	r1, r3
 800b91a:	000b      	movs	r3, r1
}
 800b91c:	0018      	movs	r0, r3
 800b91e:	46bd      	mov	sp, r7
 800b920:	bd80      	pop	{r7, pc}
 800b922:	46c0      	nop			; (mov r8, r8)
 800b924:	40021000 	.word	0x40021000
 800b928:	0801ee14 	.word	0x0801ee14

0800b92c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800b92c:	b580      	push	{r7, lr}
 800b92e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800b930:	f7ff ffdc 	bl	800b8ec <HAL_RCC_GetHCLKFreq>
 800b934:	0001      	movs	r1, r0
 800b936:	4b06      	ldr	r3, [pc, #24]	; (800b950 <HAL_RCC_GetPCLK2Freq+0x24>)
 800b938:	68db      	ldr	r3, [r3, #12]
 800b93a:	0adb      	lsrs	r3, r3, #11
 800b93c:	2207      	movs	r2, #7
 800b93e:	4013      	ands	r3, r2
 800b940:	4a04      	ldr	r2, [pc, #16]	; (800b954 <HAL_RCC_GetPCLK2Freq+0x28>)
 800b942:	5cd3      	ldrb	r3, [r2, r3]
 800b944:	40d9      	lsrs	r1, r3
 800b946:	000b      	movs	r3, r1
}
 800b948:	0018      	movs	r0, r3
 800b94a:	46bd      	mov	sp, r7
 800b94c:	bd80      	pop	{r7, pc}
 800b94e:	46c0      	nop			; (mov r8, r8)
 800b950:	40021000 	.word	0x40021000
 800b954:	0801ee14 	.word	0x0801ee14

0800b958 <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  * @note   If HAL_ERROR returned, first switch-OFF HSE clock oscillator with @ref HAL_RCC_OscConfig()
  *         to possibly update HSE divider.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800b958:	b580      	push	{r7, lr}
 800b95a:	b086      	sub	sp, #24
 800b95c:	af00      	add	r7, sp, #0
 800b95e:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800b960:	687b      	ldr	r3, [r7, #4]
 800b962:	681b      	ldr	r3, [r3, #0]
 800b964:	2220      	movs	r2, #32
 800b966:	4013      	ands	r3, r2
 800b968:	d100      	bne.n	800b96c <HAL_RCCEx_PeriphCLKConfig+0x14>
 800b96a:	e0c6      	b.n	800bafa <HAL_RCCEx_PeriphCLKConfig+0x1a2>
    {
      assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->LCDClockSelection));
    }
#endif /* LCD */

    FlagStatus       pwrclkchanged = RESET;
 800b96c:	2017      	movs	r0, #23
 800b96e:	183b      	adds	r3, r7, r0
 800b970:	2200      	movs	r2, #0
 800b972:	701a      	strb	r2, [r3, #0]

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800b974:	4b98      	ldr	r3, [pc, #608]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800b976:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b978:	2380      	movs	r3, #128	; 0x80
 800b97a:	055b      	lsls	r3, r3, #21
 800b97c:	4013      	ands	r3, r2
 800b97e:	d109      	bne.n	800b994 <HAL_RCCEx_PeriphCLKConfig+0x3c>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800b980:	4b95      	ldr	r3, [pc, #596]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800b982:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b984:	4b94      	ldr	r3, [pc, #592]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800b986:	2180      	movs	r1, #128	; 0x80
 800b988:	0549      	lsls	r1, r1, #21
 800b98a:	430a      	orrs	r2, r1
 800b98c:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 800b98e:	183b      	adds	r3, r7, r0
 800b990:	2201      	movs	r2, #1
 800b992:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800b994:	4b91      	ldr	r3, [pc, #580]	; (800bbdc <HAL_RCCEx_PeriphCLKConfig+0x284>)
 800b996:	681a      	ldr	r2, [r3, #0]
 800b998:	2380      	movs	r3, #128	; 0x80
 800b99a:	005b      	lsls	r3, r3, #1
 800b99c:	4013      	ands	r3, r2
 800b99e:	d11a      	bne.n	800b9d6 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800b9a0:	4b8e      	ldr	r3, [pc, #568]	; (800bbdc <HAL_RCCEx_PeriphCLKConfig+0x284>)
 800b9a2:	681a      	ldr	r2, [r3, #0]
 800b9a4:	4b8d      	ldr	r3, [pc, #564]	; (800bbdc <HAL_RCCEx_PeriphCLKConfig+0x284>)
 800b9a6:	2180      	movs	r1, #128	; 0x80
 800b9a8:	0049      	lsls	r1, r1, #1
 800b9aa:	430a      	orrs	r2, r1
 800b9ac:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800b9ae:	f7fd fbc7 	bl	8009140 <HAL_GetTick>
 800b9b2:	0003      	movs	r3, r0
 800b9b4:	613b      	str	r3, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800b9b6:	e008      	b.n	800b9ca <HAL_RCCEx_PeriphCLKConfig+0x72>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800b9b8:	f7fd fbc2 	bl	8009140 <HAL_GetTick>
 800b9bc:	0002      	movs	r2, r0
 800b9be:	693b      	ldr	r3, [r7, #16]
 800b9c0:	1ad3      	subs	r3, r2, r3
 800b9c2:	2b64      	cmp	r3, #100	; 0x64
 800b9c4:	d901      	bls.n	800b9ca <HAL_RCCEx_PeriphCLKConfig+0x72>
        {
          return HAL_TIMEOUT;
 800b9c6:	2303      	movs	r3, #3
 800b9c8:	e102      	b.n	800bbd0 <HAL_RCCEx_PeriphCLKConfig+0x278>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800b9ca:	4b84      	ldr	r3, [pc, #528]	; (800bbdc <HAL_RCCEx_PeriphCLKConfig+0x284>)
 800b9cc:	681a      	ldr	r2, [r3, #0]
 800b9ce:	2380      	movs	r3, #128	; 0x80
 800b9d0:	005b      	lsls	r3, r3, #1
 800b9d2:	4013      	ands	r3, r2
 800b9d4:	d0f0      	beq.n	800b9b8 <HAL_RCCEx_PeriphCLKConfig+0x60>
        }
      }
    }

    /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */
    temp_reg = (RCC->CR & RCC_CR_RTCPRE);
 800b9d6:	4b80      	ldr	r3, [pc, #512]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800b9d8:	681a      	ldr	r2, [r3, #0]
 800b9da:	23c0      	movs	r3, #192	; 0xc0
 800b9dc:	039b      	lsls	r3, r3, #14
 800b9de:	4013      	ands	r3, r2
 800b9e0:	60fb      	str	r3, [r7, #12]
    if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
 800b9e2:	687b      	ldr	r3, [r7, #4]
 800b9e4:	685a      	ldr	r2, [r3, #4]
 800b9e6:	23c0      	movs	r3, #192	; 0xc0
 800b9e8:	039b      	lsls	r3, r3, #14
 800b9ea:	4013      	ands	r3, r2
 800b9ec:	68fa      	ldr	r2, [r7, #12]
 800b9ee:	429a      	cmp	r2, r3
 800b9f0:	d013      	beq.n	800ba1a <HAL_RCCEx_PeriphCLKConfig+0xc2>
#if defined (LCD)
     || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
#endif /* LCD */
       )
    { /* Check HSE State */
      if ((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE)
 800b9f2:	687b      	ldr	r3, [r7, #4]
 800b9f4:	685a      	ldr	r2, [r3, #4]
 800b9f6:	23c0      	movs	r3, #192	; 0xc0
 800b9f8:	029b      	lsls	r3, r3, #10
 800b9fa:	401a      	ands	r2, r3
 800b9fc:	23c0      	movs	r3, #192	; 0xc0
 800b9fe:	029b      	lsls	r3, r3, #10
 800ba00:	429a      	cmp	r2, r3
 800ba02:	d10a      	bne.n	800ba1a <HAL_RCCEx_PeriphCLKConfig+0xc2>
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 800ba04:	4b74      	ldr	r3, [pc, #464]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800ba06:	681a      	ldr	r2, [r3, #0]
 800ba08:	2380      	movs	r3, #128	; 0x80
 800ba0a:	029b      	lsls	r3, r3, #10
 800ba0c:	401a      	ands	r2, r3
 800ba0e:	2380      	movs	r3, #128	; 0x80
 800ba10:	029b      	lsls	r3, r3, #10
 800ba12:	429a      	cmp	r2, r3
 800ba14:	d101      	bne.n	800ba1a <HAL_RCCEx_PeriphCLKConfig+0xc2>
        {
          /* To update HSE divider, first switch-OFF HSE clock oscillator*/
          return HAL_ERROR;
 800ba16:	2301      	movs	r3, #1
 800ba18:	e0da      	b.n	800bbd0 <HAL_RCCEx_PeriphCLKConfig+0x278>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
 800ba1a:	4b6f      	ldr	r3, [pc, #444]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800ba1c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ba1e:	23c0      	movs	r3, #192	; 0xc0
 800ba20:	029b      	lsls	r3, r3, #10
 800ba22:	4013      	ands	r3, r2
 800ba24:	60fb      	str	r3, [r7, #12]

    if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
 800ba26:	68fb      	ldr	r3, [r7, #12]
 800ba28:	2b00      	cmp	r3, #0
 800ba2a:	d03b      	beq.n	800baa4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
 800ba2c:	687b      	ldr	r3, [r7, #4]
 800ba2e:	685a      	ldr	r2, [r3, #4]
 800ba30:	23c0      	movs	r3, #192	; 0xc0
 800ba32:	029b      	lsls	r3, r3, #10
 800ba34:	4013      	ands	r3, r2
 800ba36:	68fa      	ldr	r2, [r7, #12]
 800ba38:	429a      	cmp	r2, r3
 800ba3a:	d033      	beq.n	800baa4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
      && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 800ba3c:	687b      	ldr	r3, [r7, #4]
 800ba3e:	681b      	ldr	r3, [r3, #0]
 800ba40:	2220      	movs	r2, #32
 800ba42:	4013      	ands	r3, r2
 800ba44:	d02e      	beq.n	800baa4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
       && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
#endif /* LCD */
     ))
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
 800ba46:	4b64      	ldr	r3, [pc, #400]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800ba48:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800ba4a:	4a65      	ldr	r2, [pc, #404]	; (800bbe0 <HAL_RCCEx_PeriphCLKConfig+0x288>)
 800ba4c:	4013      	ands	r3, r2
 800ba4e:	60fb      	str	r3, [r7, #12]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 800ba50:	4b61      	ldr	r3, [pc, #388]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800ba52:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ba54:	4b60      	ldr	r3, [pc, #384]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800ba56:	2180      	movs	r1, #128	; 0x80
 800ba58:	0309      	lsls	r1, r1, #12
 800ba5a:	430a      	orrs	r2, r1
 800ba5c:	651a      	str	r2, [r3, #80]	; 0x50
      __HAL_RCC_BACKUPRESET_RELEASE();
 800ba5e:	4b5e      	ldr	r3, [pc, #376]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800ba60:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ba62:	4b5d      	ldr	r3, [pc, #372]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800ba64:	495f      	ldr	r1, [pc, #380]	; (800bbe4 <HAL_RCCEx_PeriphCLKConfig+0x28c>)
 800ba66:	400a      	ands	r2, r1
 800ba68:	651a      	str	r2, [r3, #80]	; 0x50

      /* Restore the Content of CSR register */
      RCC->CSR = temp_reg;
 800ba6a:	4b5b      	ldr	r3, [pc, #364]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800ba6c:	68fa      	ldr	r2, [r7, #12]
 800ba6e:	651a      	str	r2, [r3, #80]	; 0x50

       /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
 800ba70:	68fa      	ldr	r2, [r7, #12]
 800ba72:	2380      	movs	r3, #128	; 0x80
 800ba74:	005b      	lsls	r3, r3, #1
 800ba76:	4013      	ands	r3, r2
 800ba78:	d014      	beq.n	800baa4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800ba7a:	f7fd fb61 	bl	8009140 <HAL_GetTick>
 800ba7e:	0003      	movs	r3, r0
 800ba80:	613b      	str	r3, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800ba82:	e009      	b.n	800ba98 <HAL_RCCEx_PeriphCLKConfig+0x140>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800ba84:	f7fd fb5c 	bl	8009140 <HAL_GetTick>
 800ba88:	0002      	movs	r2, r0
 800ba8a:	693b      	ldr	r3, [r7, #16]
 800ba8c:	1ad3      	subs	r3, r2, r3
 800ba8e:	4a56      	ldr	r2, [pc, #344]	; (800bbe8 <HAL_RCCEx_PeriphCLKConfig+0x290>)
 800ba90:	4293      	cmp	r3, r2
 800ba92:	d901      	bls.n	800ba98 <HAL_RCCEx_PeriphCLKConfig+0x140>
          {
            return HAL_TIMEOUT;
 800ba94:	2303      	movs	r3, #3
 800ba96:	e09b      	b.n	800bbd0 <HAL_RCCEx_PeriphCLKConfig+0x278>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800ba98:	4b4f      	ldr	r3, [pc, #316]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800ba9a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ba9c:	2380      	movs	r3, #128	; 0x80
 800ba9e:	009b      	lsls	r3, r3, #2
 800baa0:	4013      	ands	r3, r2
 800baa2:	d0ef      	beq.n	800ba84 <HAL_RCCEx_PeriphCLKConfig+0x12c>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800baa4:	687b      	ldr	r3, [r7, #4]
 800baa6:	685a      	ldr	r2, [r3, #4]
 800baa8:	23c0      	movs	r3, #192	; 0xc0
 800baaa:	029b      	lsls	r3, r3, #10
 800baac:	401a      	ands	r2, r3
 800baae:	23c0      	movs	r3, #192	; 0xc0
 800bab0:	029b      	lsls	r3, r3, #10
 800bab2:	429a      	cmp	r2, r3
 800bab4:	d10c      	bne.n	800bad0 <HAL_RCCEx_PeriphCLKConfig+0x178>
 800bab6:	4b48      	ldr	r3, [pc, #288]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bab8:	681b      	ldr	r3, [r3, #0]
 800baba:	4a4c      	ldr	r2, [pc, #304]	; (800bbec <HAL_RCCEx_PeriphCLKConfig+0x294>)
 800babc:	4013      	ands	r3, r2
 800babe:	0019      	movs	r1, r3
 800bac0:	687b      	ldr	r3, [r7, #4]
 800bac2:	685a      	ldr	r2, [r3, #4]
 800bac4:	23c0      	movs	r3, #192	; 0xc0
 800bac6:	039b      	lsls	r3, r3, #14
 800bac8:	401a      	ands	r2, r3
 800baca:	4b43      	ldr	r3, [pc, #268]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bacc:	430a      	orrs	r2, r1
 800bace:	601a      	str	r2, [r3, #0]
 800bad0:	4b41      	ldr	r3, [pc, #260]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bad2:	6d19      	ldr	r1, [r3, #80]	; 0x50
 800bad4:	687b      	ldr	r3, [r7, #4]
 800bad6:	685a      	ldr	r2, [r3, #4]
 800bad8:	23c0      	movs	r3, #192	; 0xc0
 800bada:	029b      	lsls	r3, r3, #10
 800badc:	401a      	ands	r2, r3
 800bade:	4b3e      	ldr	r3, [pc, #248]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bae0:	430a      	orrs	r2, r1
 800bae2:	651a      	str	r2, [r3, #80]	; 0x50

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800bae4:	2317      	movs	r3, #23
 800bae6:	18fb      	adds	r3, r7, r3
 800bae8:	781b      	ldrb	r3, [r3, #0]
 800baea:	2b01      	cmp	r3, #1
 800baec:	d105      	bne.n	800bafa <HAL_RCCEx_PeriphCLKConfig+0x1a2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800baee:	4b3a      	ldr	r3, [pc, #232]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800baf0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800baf2:	4b39      	ldr	r3, [pc, #228]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800baf4:	493e      	ldr	r1, [pc, #248]	; (800bbf0 <HAL_RCCEx_PeriphCLKConfig+0x298>)
 800baf6:	400a      	ands	r2, r1
 800baf8:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined (RCC_CCIPR_USART1SEL)
  /*------------------------------- USART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800bafa:	687b      	ldr	r3, [r7, #4]
 800bafc:	681b      	ldr	r3, [r3, #0]
 800bafe:	2201      	movs	r2, #1
 800bb00:	4013      	ands	r3, r2
 800bb02:	d009      	beq.n	800bb18 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800bb04:	4b34      	ldr	r3, [pc, #208]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bb06:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bb08:	2203      	movs	r2, #3
 800bb0a:	4393      	bics	r3, r2
 800bb0c:	0019      	movs	r1, r3
 800bb0e:	687b      	ldr	r3, [r7, #4]
 800bb10:	689a      	ldr	r2, [r3, #8]
 800bb12:	4b31      	ldr	r3, [pc, #196]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bb14:	430a      	orrs	r2, r1
 800bb16:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_USART1SEL */

  /*----------------------------- USART2 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800bb18:	687b      	ldr	r3, [r7, #4]
 800bb1a:	681b      	ldr	r3, [r3, #0]
 800bb1c:	2202      	movs	r2, #2
 800bb1e:	4013      	ands	r3, r2
 800bb20:	d009      	beq.n	800bb36 <HAL_RCCEx_PeriphCLKConfig+0x1de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800bb22:	4b2d      	ldr	r3, [pc, #180]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bb24:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bb26:	220c      	movs	r2, #12
 800bb28:	4393      	bics	r3, r2
 800bb2a:	0019      	movs	r1, r3
 800bb2c:	687b      	ldr	r3, [r7, #4]
 800bb2e:	68da      	ldr	r2, [r3, #12]
 800bb30:	4b29      	ldr	r3, [pc, #164]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bb32:	430a      	orrs	r2, r1
 800bb34:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ LPUART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800bb36:	687b      	ldr	r3, [r7, #4]
 800bb38:	681b      	ldr	r3, [r3, #0]
 800bb3a:	2204      	movs	r2, #4
 800bb3c:	4013      	ands	r3, r2
 800bb3e:	d009      	beq.n	800bb54 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800bb40:	4b25      	ldr	r3, [pc, #148]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bb42:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bb44:	4a2b      	ldr	r2, [pc, #172]	; (800bbf4 <HAL_RCCEx_PeriphCLKConfig+0x29c>)
 800bb46:	4013      	ands	r3, r2
 800bb48:	0019      	movs	r1, r3
 800bb4a:	687b      	ldr	r3, [r7, #4]
 800bb4c:	691a      	ldr	r2, [r3, #16]
 800bb4e:	4b22      	ldr	r3, [pc, #136]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bb50:	430a      	orrs	r2, r1
 800bb52:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800bb54:	687b      	ldr	r3, [r7, #4]
 800bb56:	681b      	ldr	r3, [r3, #0]
 800bb58:	2208      	movs	r2, #8
 800bb5a:	4013      	ands	r3, r2
 800bb5c:	d009      	beq.n	800bb72 <HAL_RCCEx_PeriphCLKConfig+0x21a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800bb5e:	4b1e      	ldr	r3, [pc, #120]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bb60:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bb62:	4a25      	ldr	r2, [pc, #148]	; (800bbf8 <HAL_RCCEx_PeriphCLKConfig+0x2a0>)
 800bb64:	4013      	ands	r3, r2
 800bb66:	0019      	movs	r1, r3
 800bb68:	687b      	ldr	r3, [r7, #4]
 800bb6a:	695a      	ldr	r2, [r3, #20]
 800bb6c:	4b1a      	ldr	r3, [pc, #104]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bb6e:	430a      	orrs	r2, r1
 800bb70:	64da      	str	r2, [r3, #76]	; 0x4c
  }

#if defined (RCC_CCIPR_I2C3SEL)
    /*------------------------------ I2C3 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800bb72:	687b      	ldr	r3, [r7, #4]
 800bb74:	681a      	ldr	r2, [r3, #0]
 800bb76:	2380      	movs	r3, #128	; 0x80
 800bb78:	005b      	lsls	r3, r3, #1
 800bb7a:	4013      	ands	r3, r2
 800bb7c:	d009      	beq.n	800bb92 <HAL_RCCEx_PeriphCLKConfig+0x23a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800bb7e:	4b16      	ldr	r3, [pc, #88]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bb80:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bb82:	4a17      	ldr	r2, [pc, #92]	; (800bbe0 <HAL_RCCEx_PeriphCLKConfig+0x288>)
 800bb84:	4013      	ands	r3, r2
 800bb86:	0019      	movs	r1, r3
 800bb88:	687b      	ldr	r3, [r7, #4]
 800bb8a:	699a      	ldr	r2, [r3, #24]
 800bb8c:	4b12      	ldr	r3, [pc, #72]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bb8e:	430a      	orrs	r2, r1
 800bb90:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_I2C3SEL */

#if defined(USB)
 /*---------------------------- USB and RNG configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 800bb92:	687b      	ldr	r3, [r7, #4]
 800bb94:	681b      	ldr	r3, [r3, #0]
 800bb96:	2240      	movs	r2, #64	; 0x40
 800bb98:	4013      	ands	r3, r2
 800bb9a:	d009      	beq.n	800bbb0 <HAL_RCCEx_PeriphCLKConfig+0x258>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800bb9c:	4b0e      	ldr	r3, [pc, #56]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bb9e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bba0:	4a16      	ldr	r2, [pc, #88]	; (800bbfc <HAL_RCCEx_PeriphCLKConfig+0x2a4>)
 800bba2:	4013      	ands	r3, r2
 800bba4:	0019      	movs	r1, r3
 800bba6:	687b      	ldr	r3, [r7, #4]
 800bba8:	6a1a      	ldr	r2, [r3, #32]
 800bbaa:	4b0b      	ldr	r3, [pc, #44]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bbac:	430a      	orrs	r2, r1
 800bbae:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* USB */

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 800bbb0:	687b      	ldr	r3, [r7, #4]
 800bbb2:	681b      	ldr	r3, [r3, #0]
 800bbb4:	2280      	movs	r2, #128	; 0x80
 800bbb6:	4013      	ands	r3, r2
 800bbb8:	d009      	beq.n	800bbce <HAL_RCCEx_PeriphCLKConfig+0x276>
  {
    assert_param(IS_RCC_LPTIMCLK(PeriphClkInit->LptimClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->LptimClockSelection);
 800bbba:	4b07      	ldr	r3, [pc, #28]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bbbc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bbbe:	4a10      	ldr	r2, [pc, #64]	; (800bc00 <HAL_RCCEx_PeriphCLKConfig+0x2a8>)
 800bbc0:	4013      	ands	r3, r2
 800bbc2:	0019      	movs	r1, r3
 800bbc4:	687b      	ldr	r3, [r7, #4]
 800bbc6:	69da      	ldr	r2, [r3, #28]
 800bbc8:	4b03      	ldr	r3, [pc, #12]	; (800bbd8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800bbca:	430a      	orrs	r2, r1
 800bbcc:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  return HAL_OK;
 800bbce:	2300      	movs	r3, #0
}
 800bbd0:	0018      	movs	r0, r3
 800bbd2:	46bd      	mov	sp, r7
 800bbd4:	b006      	add	sp, #24
 800bbd6:	bd80      	pop	{r7, pc}
 800bbd8:	40021000 	.word	0x40021000
 800bbdc:	40007000 	.word	0x40007000
 800bbe0:	fffcffff 	.word	0xfffcffff
 800bbe4:	fff7ffff 	.word	0xfff7ffff
 800bbe8:	00001388 	.word	0x00001388
 800bbec:	ffcfffff 	.word	0xffcfffff
 800bbf0:	efffffff 	.word	0xefffffff
 800bbf4:	fffff3ff 	.word	0xfffff3ff
 800bbf8:	ffffcfff 	.word	0xffffcfff
 800bbfc:	fbffffff 	.word	0xfbffffff
 800bc00:	fff3ffff 	.word	0xfff3ffff

0800bc04 <HAL_RTC_Init>:
  * @brief  Initialize the RTC peripheral
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 800bc04:	b580      	push	{r7, lr}
 800bc06:	b082      	sub	sp, #8
 800bc08:	af00      	add	r7, sp, #0
 800bc0a:	6078      	str	r0, [r7, #4]
  /* Check the RTC peripheral state */
  if (hrtc == NULL)
 800bc0c:	687b      	ldr	r3, [r7, #4]
 800bc0e:	2b00      	cmp	r3, #0
 800bc10:	d101      	bne.n	800bc16 <HAL_RTC_Init+0x12>
  {
    return HAL_ERROR;
 800bc12:	2301      	movs	r3, #1
 800bc14:	e08e      	b.n	800bd34 <HAL_RTC_Init+0x130>
    {
      hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    }
  }
#else
  if (hrtc->State == HAL_RTC_STATE_RESET)
 800bc16:	687b      	ldr	r3, [r7, #4]
 800bc18:	2221      	movs	r2, #33	; 0x21
 800bc1a:	5c9b      	ldrb	r3, [r3, r2]
 800bc1c:	b2db      	uxtb	r3, r3
 800bc1e:	2b00      	cmp	r3, #0
 800bc20:	d107      	bne.n	800bc32 <HAL_RTC_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    hrtc->Lock = HAL_UNLOCKED;
 800bc22:	687b      	ldr	r3, [r7, #4]
 800bc24:	2220      	movs	r2, #32
 800bc26:	2100      	movs	r1, #0
 800bc28:	5499      	strb	r1, [r3, r2]

    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
 800bc2a:	687b      	ldr	r3, [r7, #4]
 800bc2c:	0018      	movs	r0, r3
 800bc2e:	f010 ff63 	bl	801caf8 <HAL_RTC_MspInit>
  }
#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 800bc32:	687b      	ldr	r3, [r7, #4]
 800bc34:	2221      	movs	r2, #33	; 0x21
 800bc36:	2102      	movs	r1, #2
 800bc38:	5499      	strb	r1, [r3, r2]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800bc3a:	687b      	ldr	r3, [r7, #4]
 800bc3c:	681b      	ldr	r3, [r3, #0]
 800bc3e:	22ca      	movs	r2, #202	; 0xca
 800bc40:	625a      	str	r2, [r3, #36]	; 0x24
 800bc42:	687b      	ldr	r3, [r7, #4]
 800bc44:	681b      	ldr	r3, [r3, #0]
 800bc46:	2253      	movs	r2, #83	; 0x53
 800bc48:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode(hrtc) != HAL_OK)
 800bc4a:	687b      	ldr	r3, [r7, #4]
 800bc4c:	0018      	movs	r0, r3
 800bc4e:	f000 fca6 	bl	800c59e <RTC_EnterInitMode>
 800bc52:	1e03      	subs	r3, r0, #0
 800bc54:	d009      	beq.n	800bc6a <HAL_RTC_Init+0x66>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800bc56:	687b      	ldr	r3, [r7, #4]
 800bc58:	681b      	ldr	r3, [r3, #0]
 800bc5a:	22ff      	movs	r2, #255	; 0xff
 800bc5c:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 800bc5e:	687b      	ldr	r3, [r7, #4]
 800bc60:	2221      	movs	r2, #33	; 0x21
 800bc62:	2104      	movs	r1, #4
 800bc64:	5499      	strb	r1, [r3, r2]

    return HAL_ERROR;
 800bc66:	2301      	movs	r3, #1
 800bc68:	e064      	b.n	800bd34 <HAL_RTC_Init+0x130>
  }
  else
  {
    /* Clear RTC_CR FMT, OSEL and POL Bits */
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 800bc6a:	687b      	ldr	r3, [r7, #4]
 800bc6c:	681b      	ldr	r3, [r3, #0]
 800bc6e:	689a      	ldr	r2, [r3, #8]
 800bc70:	687b      	ldr	r3, [r7, #4]
 800bc72:	681b      	ldr	r3, [r3, #0]
 800bc74:	4931      	ldr	r1, [pc, #196]	; (800bd3c <HAL_RTC_Init+0x138>)
 800bc76:	400a      	ands	r2, r1
 800bc78:	609a      	str	r2, [r3, #8]
    /* Set RTC_CR register */
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 800bc7a:	687b      	ldr	r3, [r7, #4]
 800bc7c:	681b      	ldr	r3, [r3, #0]
 800bc7e:	6899      	ldr	r1, [r3, #8]
 800bc80:	687b      	ldr	r3, [r7, #4]
 800bc82:	685a      	ldr	r2, [r3, #4]
 800bc84:	687b      	ldr	r3, [r7, #4]
 800bc86:	691b      	ldr	r3, [r3, #16]
 800bc88:	431a      	orrs	r2, r3
 800bc8a:	687b      	ldr	r3, [r7, #4]
 800bc8c:	699b      	ldr	r3, [r3, #24]
 800bc8e:	431a      	orrs	r2, r3
 800bc90:	687b      	ldr	r3, [r7, #4]
 800bc92:	681b      	ldr	r3, [r3, #0]
 800bc94:	430a      	orrs	r2, r1
 800bc96:	609a      	str	r2, [r3, #8]

    /* Configure the RTC PRER */
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 800bc98:	687b      	ldr	r3, [r7, #4]
 800bc9a:	681b      	ldr	r3, [r3, #0]
 800bc9c:	687a      	ldr	r2, [r7, #4]
 800bc9e:	68d2      	ldr	r2, [r2, #12]
 800bca0:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 800bca2:	687b      	ldr	r3, [r7, #4]
 800bca4:	681b      	ldr	r3, [r3, #0]
 800bca6:	6919      	ldr	r1, [r3, #16]
 800bca8:	687b      	ldr	r3, [r7, #4]
 800bcaa:	689b      	ldr	r3, [r3, #8]
 800bcac:	041a      	lsls	r2, r3, #16
 800bcae:	687b      	ldr	r3, [r7, #4]
 800bcb0:	681b      	ldr	r3, [r3, #0]
 800bcb2:	430a      	orrs	r2, r1
 800bcb4:	611a      	str	r2, [r3, #16]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 800bcb6:	687b      	ldr	r3, [r7, #4]
 800bcb8:	681b      	ldr	r3, [r3, #0]
 800bcba:	68da      	ldr	r2, [r3, #12]
 800bcbc:	687b      	ldr	r3, [r7, #4]
 800bcbe:	681b      	ldr	r3, [r3, #0]
 800bcc0:	2180      	movs	r1, #128	; 0x80
 800bcc2:	438a      	bics	r2, r1
 800bcc4:	60da      	str	r2, [r3, #12]

    hrtc->Instance->OR &= (uint32_t)~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 800bcc6:	687b      	ldr	r3, [r7, #4]
 800bcc8:	681b      	ldr	r3, [r3, #0]
 800bcca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800bccc:	687b      	ldr	r3, [r7, #4]
 800bcce:	681b      	ldr	r3, [r3, #0]
 800bcd0:	2103      	movs	r1, #3
 800bcd2:	438a      	bics	r2, r1
 800bcd4:	64da      	str	r2, [r3, #76]	; 0x4c
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 800bcd6:	687b      	ldr	r3, [r7, #4]
 800bcd8:	681b      	ldr	r3, [r3, #0]
 800bcda:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 800bcdc:	687b      	ldr	r3, [r7, #4]
 800bcde:	69da      	ldr	r2, [r3, #28]
 800bce0:	687b      	ldr	r3, [r7, #4]
 800bce2:	695b      	ldr	r3, [r3, #20]
 800bce4:	431a      	orrs	r2, r3
 800bce6:	687b      	ldr	r3, [r7, #4]
 800bce8:	681b      	ldr	r3, [r3, #0]
 800bcea:	430a      	orrs	r2, r1
 800bcec:	64da      	str	r2, [r3, #76]	; 0x4c

    /* If CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
 800bcee:	687b      	ldr	r3, [r7, #4]
 800bcf0:	681b      	ldr	r3, [r3, #0]
 800bcf2:	689b      	ldr	r3, [r3, #8]
 800bcf4:	2220      	movs	r2, #32
 800bcf6:	4013      	ands	r3, r2
 800bcf8:	d113      	bne.n	800bd22 <HAL_RTC_Init+0x11e>
    {
      if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 800bcfa:	687b      	ldr	r3, [r7, #4]
 800bcfc:	0018      	movs	r0, r3
 800bcfe:	f000 fc27 	bl	800c550 <HAL_RTC_WaitForSynchro>
 800bd02:	1e03      	subs	r3, r0, #0
 800bd04:	d00d      	beq.n	800bd22 <HAL_RTC_Init+0x11e>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800bd06:	687b      	ldr	r3, [r7, #4]
 800bd08:	681b      	ldr	r3, [r3, #0]
 800bd0a:	22ff      	movs	r2, #255	; 0xff
 800bd0c:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;
 800bd0e:	687b      	ldr	r3, [r7, #4]
 800bd10:	2221      	movs	r2, #33	; 0x21
 800bd12:	2104      	movs	r1, #4
 800bd14:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 800bd16:	687b      	ldr	r3, [r7, #4]
 800bd18:	2220      	movs	r2, #32
 800bd1a:	2100      	movs	r1, #0
 800bd1c:	5499      	strb	r1, [r3, r2]

        return HAL_ERROR;
 800bd1e:	2301      	movs	r3, #1
 800bd20:	e008      	b.n	800bd34 <HAL_RTC_Init+0x130>
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800bd22:	687b      	ldr	r3, [r7, #4]
 800bd24:	681b      	ldr	r3, [r3, #0]
 800bd26:	22ff      	movs	r2, #255	; 0xff
 800bd28:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
 800bd2a:	687b      	ldr	r3, [r7, #4]
 800bd2c:	2221      	movs	r2, #33	; 0x21
 800bd2e:	2101      	movs	r1, #1
 800bd30:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 800bd32:	2300      	movs	r3, #0
  }
}
 800bd34:	0018      	movs	r0, r3
 800bd36:	46bd      	mov	sp, r7
 800bd38:	b002      	add	sp, #8
 800bd3a:	bd80      	pop	{r7, pc}
 800bd3c:	ff8fffbf 	.word	0xff8fffbf

0800bd40 <HAL_RTC_SetTime>:
  *            @arg RTC_FORMAT_BIN: Binary data format
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
 800bd40:	b590      	push	{r4, r7, lr}
 800bd42:	b087      	sub	sp, #28
 800bd44:	af00      	add	r7, sp, #0
 800bd46:	60f8      	str	r0, [r7, #12]
 800bd48:	60b9      	str	r1, [r7, #8]
 800bd4a:	607a      	str	r2, [r7, #4]
  assert_param(IS_RTC_FORMAT(Format));
  assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 800bd4c:	68fb      	ldr	r3, [r7, #12]
 800bd4e:	2220      	movs	r2, #32
 800bd50:	5c9b      	ldrb	r3, [r3, r2]
 800bd52:	2b01      	cmp	r3, #1
 800bd54:	d101      	bne.n	800bd5a <HAL_RTC_SetTime+0x1a>
 800bd56:	2302      	movs	r3, #2
 800bd58:	e0ad      	b.n	800beb6 <HAL_RTC_SetTime+0x176>
 800bd5a:	68fb      	ldr	r3, [r7, #12]
 800bd5c:	2220      	movs	r2, #32
 800bd5e:	2101      	movs	r1, #1
 800bd60:	5499      	strb	r1, [r3, r2]

  hrtc->State = HAL_RTC_STATE_BUSY;
 800bd62:	68fb      	ldr	r3, [r7, #12]
 800bd64:	2221      	movs	r2, #33	; 0x21
 800bd66:	2102      	movs	r1, #2
 800bd68:	5499      	strb	r1, [r3, r2]

  if (Format == RTC_FORMAT_BIN)
 800bd6a:	687b      	ldr	r3, [r7, #4]
 800bd6c:	2b00      	cmp	r3, #0
 800bd6e:	d125      	bne.n	800bdbc <HAL_RTC_SetTime+0x7c>
  {
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 800bd70:	68fb      	ldr	r3, [r7, #12]
 800bd72:	681b      	ldr	r3, [r3, #0]
 800bd74:	689b      	ldr	r3, [r3, #8]
 800bd76:	2240      	movs	r2, #64	; 0x40
 800bd78:	4013      	ands	r3, r2
 800bd7a:	d102      	bne.n	800bd82 <HAL_RTC_SetTime+0x42>
      assert_param(IS_RTC_HOUR12(sTime->Hours));
      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    }
    else
    {
      sTime->TimeFormat = 0x00U;
 800bd7c:	68bb      	ldr	r3, [r7, #8]
 800bd7e:	2200      	movs	r2, #0
 800bd80:	70da      	strb	r2, [r3, #3]
      assert_param(IS_RTC_HOUR24(sTime->Hours));
    }
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 800bd82:	68bb      	ldr	r3, [r7, #8]
 800bd84:	781b      	ldrb	r3, [r3, #0]
 800bd86:	0018      	movs	r0, r3
 800bd88:	f000 fc33 	bl	800c5f2 <RTC_ByteToBcd2>
 800bd8c:	0003      	movs	r3, r0
 800bd8e:	041c      	lsls	r4, r3, #16
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 800bd90:	68bb      	ldr	r3, [r7, #8]
 800bd92:	785b      	ldrb	r3, [r3, #1]
 800bd94:	0018      	movs	r0, r3
 800bd96:	f000 fc2c 	bl	800c5f2 <RTC_ByteToBcd2>
 800bd9a:	0003      	movs	r3, r0
 800bd9c:	021b      	lsls	r3, r3, #8
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 800bd9e:	431c      	orrs	r4, r3
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 800bda0:	68bb      	ldr	r3, [r7, #8]
 800bda2:	789b      	ldrb	r3, [r3, #2]
 800bda4:	0018      	movs	r0, r3
 800bda6:	f000 fc24 	bl	800c5f2 <RTC_ByteToBcd2>
 800bdaa:	0003      	movs	r3, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 800bdac:	0022      	movs	r2, r4
 800bdae:	431a      	orrs	r2, r3
                        (((uint32_t)sTime->TimeFormat) << 16U));
 800bdb0:	68bb      	ldr	r3, [r7, #8]
 800bdb2:	78db      	ldrb	r3, [r3, #3]
 800bdb4:	041b      	lsls	r3, r3, #16
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 800bdb6:	4313      	orrs	r3, r2
 800bdb8:	617b      	str	r3, [r7, #20]
 800bdba:	e017      	b.n	800bdec <HAL_RTC_SetTime+0xac>
  }
  else
  {
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 800bdbc:	68fb      	ldr	r3, [r7, #12]
 800bdbe:	681b      	ldr	r3, [r3, #0]
 800bdc0:	689b      	ldr	r3, [r3, #8]
 800bdc2:	2240      	movs	r2, #64	; 0x40
 800bdc4:	4013      	ands	r3, r2
 800bdc6:	d102      	bne.n	800bdce <HAL_RTC_SetTime+0x8e>
      assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sTime->Hours)));
      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    }
    else
    {
      sTime->TimeFormat = 0x00U;
 800bdc8:	68bb      	ldr	r3, [r7, #8]
 800bdca:	2200      	movs	r2, #0
 800bdcc:	70da      	strb	r2, [r3, #3]
      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    }
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 800bdce:	68bb      	ldr	r3, [r7, #8]
 800bdd0:	781b      	ldrb	r3, [r3, #0]
 800bdd2:	041a      	lsls	r2, r3, #16
              ((uint32_t)(sTime->Minutes) << 8U) | \
 800bdd4:	68bb      	ldr	r3, [r7, #8]
 800bdd6:	785b      	ldrb	r3, [r3, #1]
 800bdd8:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 800bdda:	4313      	orrs	r3, r2
              ((uint32_t)sTime->Seconds) | \
 800bddc:	68ba      	ldr	r2, [r7, #8]
 800bdde:	7892      	ldrb	r2, [r2, #2]
              ((uint32_t)(sTime->Minutes) << 8U) | \
 800bde0:	431a      	orrs	r2, r3
              ((uint32_t)(sTime->TimeFormat) << 16U));
 800bde2:	68bb      	ldr	r3, [r7, #8]
 800bde4:	78db      	ldrb	r3, [r3, #3]
 800bde6:	041b      	lsls	r3, r3, #16
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 800bde8:	4313      	orrs	r3, r2
 800bdea:	617b      	str	r3, [r7, #20]
  }
  UNUSED(tmpreg);
  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800bdec:	68fb      	ldr	r3, [r7, #12]
 800bdee:	681b      	ldr	r3, [r3, #0]
 800bdf0:	22ca      	movs	r2, #202	; 0xca
 800bdf2:	625a      	str	r2, [r3, #36]	; 0x24
 800bdf4:	68fb      	ldr	r3, [r7, #12]
 800bdf6:	681b      	ldr	r3, [r3, #0]
 800bdf8:	2253      	movs	r2, #83	; 0x53
 800bdfa:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode(hrtc) != HAL_OK)
 800bdfc:	68fb      	ldr	r3, [r7, #12]
 800bdfe:	0018      	movs	r0, r3
 800be00:	f000 fbcd 	bl	800c59e <RTC_EnterInitMode>
 800be04:	1e03      	subs	r3, r0, #0
 800be06:	d00d      	beq.n	800be24 <HAL_RTC_SetTime+0xe4>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800be08:	68fb      	ldr	r3, [r7, #12]
 800be0a:	681b      	ldr	r3, [r3, #0]
 800be0c:	22ff      	movs	r2, #255	; 0xff
 800be0e:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 800be10:	68fb      	ldr	r3, [r7, #12]
 800be12:	2221      	movs	r2, #33	; 0x21
 800be14:	2104      	movs	r1, #4
 800be16:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 800be18:	68fb      	ldr	r3, [r7, #12]
 800be1a:	2220      	movs	r2, #32
 800be1c:	2100      	movs	r1, #0
 800be1e:	5499      	strb	r1, [r3, r2]

    return HAL_ERROR;
 800be20:	2301      	movs	r3, #1
 800be22:	e048      	b.n	800beb6 <HAL_RTC_SetTime+0x176>
  }
  else
  {
    /* Set the RTC_TR register */
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 800be24:	68fb      	ldr	r3, [r7, #12]
 800be26:	681b      	ldr	r3, [r3, #0]
 800be28:	697a      	ldr	r2, [r7, #20]
 800be2a:	4925      	ldr	r1, [pc, #148]	; (800bec0 <HAL_RTC_SetTime+0x180>)
 800be2c:	400a      	ands	r2, r1
 800be2e:	601a      	str	r2, [r3, #0]

    /* Clear the bits to be configured */
    hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BKP);
 800be30:	68fb      	ldr	r3, [r7, #12]
 800be32:	681b      	ldr	r3, [r3, #0]
 800be34:	689a      	ldr	r2, [r3, #8]
 800be36:	68fb      	ldr	r3, [r7, #12]
 800be38:	681b      	ldr	r3, [r3, #0]
 800be3a:	4922      	ldr	r1, [pc, #136]	; (800bec4 <HAL_RTC_SetTime+0x184>)
 800be3c:	400a      	ands	r2, r1
 800be3e:	609a      	str	r2, [r3, #8]

    /* Configure the RTC_CR register */
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 800be40:	68fb      	ldr	r3, [r7, #12]
 800be42:	681b      	ldr	r3, [r3, #0]
 800be44:	6899      	ldr	r1, [r3, #8]
 800be46:	68bb      	ldr	r3, [r7, #8]
 800be48:	68da      	ldr	r2, [r3, #12]
 800be4a:	68bb      	ldr	r3, [r7, #8]
 800be4c:	691b      	ldr	r3, [r3, #16]
 800be4e:	431a      	orrs	r2, r3
 800be50:	68fb      	ldr	r3, [r7, #12]
 800be52:	681b      	ldr	r3, [r3, #0]
 800be54:	430a      	orrs	r2, r1
 800be56:	609a      	str	r2, [r3, #8]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 800be58:	68fb      	ldr	r3, [r7, #12]
 800be5a:	681b      	ldr	r3, [r3, #0]
 800be5c:	68da      	ldr	r2, [r3, #12]
 800be5e:	68fb      	ldr	r3, [r7, #12]
 800be60:	681b      	ldr	r3, [r3, #0]
 800be62:	2180      	movs	r1, #128	; 0x80
 800be64:	438a      	bics	r2, r1
 800be66:	60da      	str	r2, [r3, #12]

    /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
 800be68:	68fb      	ldr	r3, [r7, #12]
 800be6a:	681b      	ldr	r3, [r3, #0]
 800be6c:	689b      	ldr	r3, [r3, #8]
 800be6e:	2220      	movs	r2, #32
 800be70:	4013      	ands	r3, r2
 800be72:	d113      	bne.n	800be9c <HAL_RTC_SetTime+0x15c>
    {
      if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 800be74:	68fb      	ldr	r3, [r7, #12]
 800be76:	0018      	movs	r0, r3
 800be78:	f000 fb6a 	bl	800c550 <HAL_RTC_WaitForSynchro>
 800be7c:	1e03      	subs	r3, r0, #0
 800be7e:	d00d      	beq.n	800be9c <HAL_RTC_SetTime+0x15c>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800be80:	68fb      	ldr	r3, [r7, #12]
 800be82:	681b      	ldr	r3, [r3, #0]
 800be84:	22ff      	movs	r2, #255	; 0xff
 800be86:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;
 800be88:	68fb      	ldr	r3, [r7, #12]
 800be8a:	2221      	movs	r2, #33	; 0x21
 800be8c:	2104      	movs	r1, #4
 800be8e:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 800be90:	68fb      	ldr	r3, [r7, #12]
 800be92:	2220      	movs	r2, #32
 800be94:	2100      	movs	r1, #0
 800be96:	5499      	strb	r1, [r3, r2]

        return HAL_ERROR;
 800be98:	2301      	movs	r3, #1
 800be9a:	e00c      	b.n	800beb6 <HAL_RTC_SetTime+0x176>
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800be9c:	68fb      	ldr	r3, [r7, #12]
 800be9e:	681b      	ldr	r3, [r3, #0]
 800bea0:	22ff      	movs	r2, #255	; 0xff
 800bea2:	625a      	str	r2, [r3, #36]	; 0x24

    hrtc->State = HAL_RTC_STATE_READY;
 800bea4:	68fb      	ldr	r3, [r7, #12]
 800bea6:	2221      	movs	r2, #33	; 0x21
 800bea8:	2101      	movs	r1, #1
 800beaa:	5499      	strb	r1, [r3, r2]

    __HAL_UNLOCK(hrtc);
 800beac:	68fb      	ldr	r3, [r7, #12]
 800beae:	2220      	movs	r2, #32
 800beb0:	2100      	movs	r1, #0
 800beb2:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 800beb4:	2300      	movs	r3, #0
  }
}
 800beb6:	0018      	movs	r0, r3
 800beb8:	46bd      	mov	sp, r7
 800beba:	b007      	add	sp, #28
 800bebc:	bd90      	pop	{r4, r7, pc}
 800bebe:	46c0      	nop			; (mov r8, r8)
 800bec0:	007f7f7f 	.word	0x007f7f7f
 800bec4:	fffbffff 	.word	0xfffbffff

0800bec8 <HAL_RTC_GetTime>:
  *        Reading RTC current time locks the values in calendar shadow registers until Current date is read
  *        to ensure consistency between the time and date values.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
 800bec8:	b580      	push	{r7, lr}
 800beca:	b086      	sub	sp, #24
 800becc:	af00      	add	r7, sp, #0
 800bece:	60f8      	str	r0, [r7, #12]
 800bed0:	60b9      	str	r1, [r7, #8]
 800bed2:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Get subseconds structure field from the corresponding register*/
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 800bed4:	68fb      	ldr	r3, [r7, #12]
 800bed6:	681b      	ldr	r3, [r3, #0]
 800bed8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800beda:	68bb      	ldr	r3, [r7, #8]
 800bedc:	605a      	str	r2, [r3, #4]

  /* Get SecondFraction structure field from the corresponding register field*/
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 800bede:	68fb      	ldr	r3, [r7, #12]
 800bee0:	681b      	ldr	r3, [r3, #0]
 800bee2:	691b      	ldr	r3, [r3, #16]
 800bee4:	045b      	lsls	r3, r3, #17
 800bee6:	0c5a      	lsrs	r2, r3, #17
 800bee8:	68bb      	ldr	r3, [r7, #8]
 800beea:	609a      	str	r2, [r3, #8]

  /* Get the TR register */
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
 800beec:	68fb      	ldr	r3, [r7, #12]
 800beee:	681b      	ldr	r3, [r3, #0]
 800bef0:	681b      	ldr	r3, [r3, #0]
 800bef2:	4a22      	ldr	r2, [pc, #136]	; (800bf7c <HAL_RTC_GetTime+0xb4>)
 800bef4:	4013      	ands	r3, r2
 800bef6:	617b      	str	r3, [r7, #20]

  /* Fill the structure fields with the read parameters */
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
 800bef8:	697b      	ldr	r3, [r7, #20]
 800befa:	0c1b      	lsrs	r3, r3, #16
 800befc:	b2db      	uxtb	r3, r3
 800befe:	223f      	movs	r2, #63	; 0x3f
 800bf00:	4013      	ands	r3, r2
 800bf02:	b2da      	uxtb	r2, r3
 800bf04:	68bb      	ldr	r3, [r7, #8]
 800bf06:	701a      	strb	r2, [r3, #0]
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> 8U);
 800bf08:	697b      	ldr	r3, [r7, #20]
 800bf0a:	0a1b      	lsrs	r3, r3, #8
 800bf0c:	b2db      	uxtb	r3, r3
 800bf0e:	227f      	movs	r2, #127	; 0x7f
 800bf10:	4013      	ands	r3, r2
 800bf12:	b2da      	uxtb	r2, r3
 800bf14:	68bb      	ldr	r3, [r7, #8]
 800bf16:	705a      	strb	r2, [r3, #1]
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 800bf18:	697b      	ldr	r3, [r7, #20]
 800bf1a:	b2db      	uxtb	r3, r3
 800bf1c:	227f      	movs	r2, #127	; 0x7f
 800bf1e:	4013      	ands	r3, r2
 800bf20:	b2da      	uxtb	r2, r3
 800bf22:	68bb      	ldr	r3, [r7, #8]
 800bf24:	709a      	strb	r2, [r3, #2]
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16U);
 800bf26:	697b      	ldr	r3, [r7, #20]
 800bf28:	0c1b      	lsrs	r3, r3, #16
 800bf2a:	b2db      	uxtb	r3, r3
 800bf2c:	2240      	movs	r2, #64	; 0x40
 800bf2e:	4013      	ands	r3, r2
 800bf30:	b2da      	uxtb	r2, r3
 800bf32:	68bb      	ldr	r3, [r7, #8]
 800bf34:	70da      	strb	r2, [r3, #3]

  /* Check the input parameters format */
  if (Format == RTC_FORMAT_BIN)
 800bf36:	687b      	ldr	r3, [r7, #4]
 800bf38:	2b00      	cmp	r3, #0
 800bf3a:	d11a      	bne.n	800bf72 <HAL_RTC_GetTime+0xaa>
  {
    /* Convert the time structure parameters to Binary format */
    sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
 800bf3c:	68bb      	ldr	r3, [r7, #8]
 800bf3e:	781b      	ldrb	r3, [r3, #0]
 800bf40:	0018      	movs	r0, r3
 800bf42:	f000 fb7e 	bl	800c642 <RTC_Bcd2ToByte>
 800bf46:	0003      	movs	r3, r0
 800bf48:	001a      	movs	r2, r3
 800bf4a:	68bb      	ldr	r3, [r7, #8]
 800bf4c:	701a      	strb	r2, [r3, #0]
    sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
 800bf4e:	68bb      	ldr	r3, [r7, #8]
 800bf50:	785b      	ldrb	r3, [r3, #1]
 800bf52:	0018      	movs	r0, r3
 800bf54:	f000 fb75 	bl	800c642 <RTC_Bcd2ToByte>
 800bf58:	0003      	movs	r3, r0
 800bf5a:	001a      	movs	r2, r3
 800bf5c:	68bb      	ldr	r3, [r7, #8]
 800bf5e:	705a      	strb	r2, [r3, #1]
    sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
 800bf60:	68bb      	ldr	r3, [r7, #8]
 800bf62:	789b      	ldrb	r3, [r3, #2]
 800bf64:	0018      	movs	r0, r3
 800bf66:	f000 fb6c 	bl	800c642 <RTC_Bcd2ToByte>
 800bf6a:	0003      	movs	r3, r0
 800bf6c:	001a      	movs	r2, r3
 800bf6e:	68bb      	ldr	r3, [r7, #8]
 800bf70:	709a      	strb	r2, [r3, #2]
  }

  return HAL_OK;
 800bf72:	2300      	movs	r3, #0
}
 800bf74:	0018      	movs	r0, r3
 800bf76:	46bd      	mov	sp, r7
 800bf78:	b006      	add	sp, #24
 800bf7a:	bd80      	pop	{r7, pc}
 800bf7c:	007f7f7f 	.word	0x007f7f7f

0800bf80 <HAL_RTC_SetDate>:
  *            @arg RTC_FORMAT_BIN: Binary data format
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
 800bf80:	b590      	push	{r4, r7, lr}
 800bf82:	b087      	sub	sp, #28
 800bf84:	af00      	add	r7, sp, #0
 800bf86:	60f8      	str	r0, [r7, #12]
 800bf88:	60b9      	str	r1, [r7, #8]
 800bf8a:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 800bf8c:	68fb      	ldr	r3, [r7, #12]
 800bf8e:	2220      	movs	r2, #32
 800bf90:	5c9b      	ldrb	r3, [r3, r2]
 800bf92:	2b01      	cmp	r3, #1
 800bf94:	d101      	bne.n	800bf9a <HAL_RTC_SetDate+0x1a>
 800bf96:	2302      	movs	r3, #2
 800bf98:	e099      	b.n	800c0ce <HAL_RTC_SetDate+0x14e>
 800bf9a:	68fb      	ldr	r3, [r7, #12]
 800bf9c:	2220      	movs	r2, #32
 800bf9e:	2101      	movs	r1, #1
 800bfa0:	5499      	strb	r1, [r3, r2]

  hrtc->State = HAL_RTC_STATE_BUSY;
 800bfa2:	68fb      	ldr	r3, [r7, #12]
 800bfa4:	2221      	movs	r2, #33	; 0x21
 800bfa6:	2102      	movs	r1, #2
 800bfa8:	5499      	strb	r1, [r3, r2]

  if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 800bfaa:	687b      	ldr	r3, [r7, #4]
 800bfac:	2b00      	cmp	r3, #0
 800bfae:	d10e      	bne.n	800bfce <HAL_RTC_SetDate+0x4e>
 800bfb0:	68bb      	ldr	r3, [r7, #8]
 800bfb2:	785b      	ldrb	r3, [r3, #1]
 800bfb4:	001a      	movs	r2, r3
 800bfb6:	2310      	movs	r3, #16
 800bfb8:	4013      	ands	r3, r2
 800bfba:	d008      	beq.n	800bfce <HAL_RTC_SetDate+0x4e>
  {
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 800bfbc:	68bb      	ldr	r3, [r7, #8]
 800bfbe:	785b      	ldrb	r3, [r3, #1]
 800bfc0:	2210      	movs	r2, #16
 800bfc2:	4393      	bics	r3, r2
 800bfc4:	b2db      	uxtb	r3, r3
 800bfc6:	330a      	adds	r3, #10
 800bfc8:	b2da      	uxtb	r2, r3
 800bfca:	68bb      	ldr	r3, [r7, #8]
 800bfcc:	705a      	strb	r2, [r3, #1]
  }

  assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));

  if (Format == RTC_FORMAT_BIN)
 800bfce:	687b      	ldr	r3, [r7, #4]
 800bfd0:	2b00      	cmp	r3, #0
 800bfd2:	d11c      	bne.n	800c00e <HAL_RTC_SetDate+0x8e>
  {
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 800bfd4:	68bb      	ldr	r3, [r7, #8]
 800bfd6:	78db      	ldrb	r3, [r3, #3]
 800bfd8:	0018      	movs	r0, r3
 800bfda:	f000 fb0a 	bl	800c5f2 <RTC_ByteToBcd2>
 800bfde:	0003      	movs	r3, r0
 800bfe0:	041c      	lsls	r4, r3, #16
                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 800bfe2:	68bb      	ldr	r3, [r7, #8]
 800bfe4:	785b      	ldrb	r3, [r3, #1]
 800bfe6:	0018      	movs	r0, r3
 800bfe8:	f000 fb03 	bl	800c5f2 <RTC_ByteToBcd2>
 800bfec:	0003      	movs	r3, r0
 800bfee:	021b      	lsls	r3, r3, #8
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 800bff0:	431c      	orrs	r4, r3
                  ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 800bff2:	68bb      	ldr	r3, [r7, #8]
 800bff4:	789b      	ldrb	r3, [r3, #2]
 800bff6:	0018      	movs	r0, r3
 800bff8:	f000 fafb 	bl	800c5f2 <RTC_ByteToBcd2>
 800bffc:	0003      	movs	r3, r0
                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 800bffe:	0022      	movs	r2, r4
 800c000:	431a      	orrs	r2, r3
                  ((uint32_t)sDate->WeekDay << 13U));
 800c002:	68bb      	ldr	r3, [r7, #8]
 800c004:	781b      	ldrb	r3, [r3, #0]
 800c006:	035b      	lsls	r3, r3, #13
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 800c008:	4313      	orrs	r3, r2
 800c00a:	617b      	str	r3, [r7, #20]
 800c00c:	e00e      	b.n	800c02c <HAL_RTC_SetDate+0xac>
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
    assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));

    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 800c00e:	68bb      	ldr	r3, [r7, #8]
 800c010:	78db      	ldrb	r3, [r3, #3]
 800c012:	041a      	lsls	r2, r3, #16
                  (((uint32_t)sDate->Month) << 8U) | \
 800c014:	68bb      	ldr	r3, [r7, #8]
 800c016:	785b      	ldrb	r3, [r3, #1]
 800c018:	021b      	lsls	r3, r3, #8
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 800c01a:	4313      	orrs	r3, r2
                  ((uint32_t)sDate->Date) | \
 800c01c:	68ba      	ldr	r2, [r7, #8]
 800c01e:	7892      	ldrb	r2, [r2, #2]
                  (((uint32_t)sDate->Month) << 8U) | \
 800c020:	431a      	orrs	r2, r3
                  (((uint32_t)sDate->WeekDay) << 13U));
 800c022:	68bb      	ldr	r3, [r7, #8]
 800c024:	781b      	ldrb	r3, [r3, #0]
 800c026:	035b      	lsls	r3, r3, #13
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 800c028:	4313      	orrs	r3, r2
 800c02a:	617b      	str	r3, [r7, #20]
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800c02c:	68fb      	ldr	r3, [r7, #12]
 800c02e:	681b      	ldr	r3, [r3, #0]
 800c030:	22ca      	movs	r2, #202	; 0xca
 800c032:	625a      	str	r2, [r3, #36]	; 0x24
 800c034:	68fb      	ldr	r3, [r7, #12]
 800c036:	681b      	ldr	r3, [r3, #0]
 800c038:	2253      	movs	r2, #83	; 0x53
 800c03a:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode(hrtc) != HAL_OK)
 800c03c:	68fb      	ldr	r3, [r7, #12]
 800c03e:	0018      	movs	r0, r3
 800c040:	f000 faad 	bl	800c59e <RTC_EnterInitMode>
 800c044:	1e03      	subs	r3, r0, #0
 800c046:	d00d      	beq.n	800c064 <HAL_RTC_SetDate+0xe4>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800c048:	68fb      	ldr	r3, [r7, #12]
 800c04a:	681b      	ldr	r3, [r3, #0]
 800c04c:	22ff      	movs	r2, #255	; 0xff
 800c04e:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state*/
    hrtc->State = HAL_RTC_STATE_ERROR;
 800c050:	68fb      	ldr	r3, [r7, #12]
 800c052:	2221      	movs	r2, #33	; 0x21
 800c054:	2104      	movs	r1, #4
 800c056:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 800c058:	68fb      	ldr	r3, [r7, #12]
 800c05a:	2220      	movs	r2, #32
 800c05c:	2100      	movs	r1, #0
 800c05e:	5499      	strb	r1, [r3, r2]

    return HAL_ERROR;
 800c060:	2301      	movs	r3, #1
 800c062:	e034      	b.n	800c0ce <HAL_RTC_SetDate+0x14e>
  }
  else
  {
    /* Set the RTC_DR register */
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 800c064:	68fb      	ldr	r3, [r7, #12]
 800c066:	681b      	ldr	r3, [r3, #0]
 800c068:	697a      	ldr	r2, [r7, #20]
 800c06a:	491b      	ldr	r1, [pc, #108]	; (800c0d8 <HAL_RTC_SetDate+0x158>)
 800c06c:	400a      	ands	r2, r1
 800c06e:	605a      	str	r2, [r3, #4]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 800c070:	68fb      	ldr	r3, [r7, #12]
 800c072:	681b      	ldr	r3, [r3, #0]
 800c074:	68da      	ldr	r2, [r3, #12]
 800c076:	68fb      	ldr	r3, [r7, #12]
 800c078:	681b      	ldr	r3, [r3, #0]
 800c07a:	2180      	movs	r1, #128	; 0x80
 800c07c:	438a      	bics	r2, r1
 800c07e:	60da      	str	r2, [r3, #12]

    /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
 800c080:	68fb      	ldr	r3, [r7, #12]
 800c082:	681b      	ldr	r3, [r3, #0]
 800c084:	689b      	ldr	r3, [r3, #8]
 800c086:	2220      	movs	r2, #32
 800c088:	4013      	ands	r3, r2
 800c08a:	d113      	bne.n	800c0b4 <HAL_RTC_SetDate+0x134>
    {
      if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 800c08c:	68fb      	ldr	r3, [r7, #12]
 800c08e:	0018      	movs	r0, r3
 800c090:	f000 fa5e 	bl	800c550 <HAL_RTC_WaitForSynchro>
 800c094:	1e03      	subs	r3, r0, #0
 800c096:	d00d      	beq.n	800c0b4 <HAL_RTC_SetDate+0x134>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800c098:	68fb      	ldr	r3, [r7, #12]
 800c09a:	681b      	ldr	r3, [r3, #0]
 800c09c:	22ff      	movs	r2, #255	; 0xff
 800c09e:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;
 800c0a0:	68fb      	ldr	r3, [r7, #12]
 800c0a2:	2221      	movs	r2, #33	; 0x21
 800c0a4:	2104      	movs	r1, #4
 800c0a6:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 800c0a8:	68fb      	ldr	r3, [r7, #12]
 800c0aa:	2220      	movs	r2, #32
 800c0ac:	2100      	movs	r1, #0
 800c0ae:	5499      	strb	r1, [r3, r2]

        return HAL_ERROR;
 800c0b0:	2301      	movs	r3, #1
 800c0b2:	e00c      	b.n	800c0ce <HAL_RTC_SetDate+0x14e>
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800c0b4:	68fb      	ldr	r3, [r7, #12]
 800c0b6:	681b      	ldr	r3, [r3, #0]
 800c0b8:	22ff      	movs	r2, #255	; 0xff
 800c0ba:	625a      	str	r2, [r3, #36]	; 0x24

    hrtc->State = HAL_RTC_STATE_READY ;
 800c0bc:	68fb      	ldr	r3, [r7, #12]
 800c0be:	2221      	movs	r2, #33	; 0x21
 800c0c0:	2101      	movs	r1, #1
 800c0c2:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 800c0c4:	68fb      	ldr	r3, [r7, #12]
 800c0c6:	2220      	movs	r2, #32
 800c0c8:	2100      	movs	r1, #0
 800c0ca:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 800c0cc:	2300      	movs	r3, #0
  }
}
 800c0ce:	0018      	movs	r0, r3
 800c0d0:	46bd      	mov	sp, r7
 800c0d2:	b007      	add	sp, #28
 800c0d4:	bd90      	pop	{r4, r7, pc}
 800c0d6:	46c0      	nop			; (mov r8, r8)
 800c0d8:	00ffff3f 	.word	0x00ffff3f

0800c0dc <HAL_RTC_GetDate>:
  *        in the higher-order calendar shadow registers to ensure consistency between the time and date values.
  *        Reading RTC current time locks the values in calendar shadow registers until Current date is read.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
 800c0dc:	b580      	push	{r7, lr}
 800c0de:	b086      	sub	sp, #24
 800c0e0:	af00      	add	r7, sp, #0
 800c0e2:	60f8      	str	r0, [r7, #12]
 800c0e4:	60b9      	str	r1, [r7, #8]
 800c0e6:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Get the DR register */
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
 800c0e8:	68fb      	ldr	r3, [r7, #12]
 800c0ea:	681b      	ldr	r3, [r3, #0]
 800c0ec:	685b      	ldr	r3, [r3, #4]
 800c0ee:	4a21      	ldr	r2, [pc, #132]	; (800c174 <HAL_RTC_GetDate+0x98>)
 800c0f0:	4013      	ands	r3, r2
 800c0f2:	617b      	str	r3, [r7, #20]

  /* Fill the structure fields with the read parameters */
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16U);
 800c0f4:	697b      	ldr	r3, [r7, #20]
 800c0f6:	0c1b      	lsrs	r3, r3, #16
 800c0f8:	b2da      	uxtb	r2, r3
 800c0fa:	68bb      	ldr	r3, [r7, #8]
 800c0fc:	70da      	strb	r2, [r3, #3]
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
 800c0fe:	697b      	ldr	r3, [r7, #20]
 800c100:	0a1b      	lsrs	r3, r3, #8
 800c102:	b2db      	uxtb	r3, r3
 800c104:	221f      	movs	r2, #31
 800c106:	4013      	ands	r3, r2
 800c108:	b2da      	uxtb	r2, r3
 800c10a:	68bb      	ldr	r3, [r7, #8]
 800c10c:	705a      	strb	r2, [r3, #1]
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 800c10e:	697b      	ldr	r3, [r7, #20]
 800c110:	b2db      	uxtb	r3, r3
 800c112:	223f      	movs	r2, #63	; 0x3f
 800c114:	4013      	ands	r3, r2
 800c116:	b2da      	uxtb	r2, r3
 800c118:	68bb      	ldr	r3, [r7, #8]
 800c11a:	709a      	strb	r2, [r3, #2]
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13U);
 800c11c:	697b      	ldr	r3, [r7, #20]
 800c11e:	0b5b      	lsrs	r3, r3, #13
 800c120:	b2db      	uxtb	r3, r3
 800c122:	2207      	movs	r2, #7
 800c124:	4013      	ands	r3, r2
 800c126:	b2da      	uxtb	r2, r3
 800c128:	68bb      	ldr	r3, [r7, #8]
 800c12a:	701a      	strb	r2, [r3, #0]

  /* Check the input parameters format */
  if (Format == RTC_FORMAT_BIN)
 800c12c:	687b      	ldr	r3, [r7, #4]
 800c12e:	2b00      	cmp	r3, #0
 800c130:	d11a      	bne.n	800c168 <HAL_RTC_GetDate+0x8c>
  {
    /* Convert the date structure parameters to Binary format */
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
 800c132:	68bb      	ldr	r3, [r7, #8]
 800c134:	78db      	ldrb	r3, [r3, #3]
 800c136:	0018      	movs	r0, r3
 800c138:	f000 fa83 	bl	800c642 <RTC_Bcd2ToByte>
 800c13c:	0003      	movs	r3, r0
 800c13e:	001a      	movs	r2, r3
 800c140:	68bb      	ldr	r3, [r7, #8]
 800c142:	70da      	strb	r2, [r3, #3]
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
 800c144:	68bb      	ldr	r3, [r7, #8]
 800c146:	785b      	ldrb	r3, [r3, #1]
 800c148:	0018      	movs	r0, r3
 800c14a:	f000 fa7a 	bl	800c642 <RTC_Bcd2ToByte>
 800c14e:	0003      	movs	r3, r0
 800c150:	001a      	movs	r2, r3
 800c152:	68bb      	ldr	r3, [r7, #8]
 800c154:	705a      	strb	r2, [r3, #1]
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
 800c156:	68bb      	ldr	r3, [r7, #8]
 800c158:	789b      	ldrb	r3, [r3, #2]
 800c15a:	0018      	movs	r0, r3
 800c15c:	f000 fa71 	bl	800c642 <RTC_Bcd2ToByte>
 800c160:	0003      	movs	r3, r0
 800c162:	001a      	movs	r2, r3
 800c164:	68bb      	ldr	r3, [r7, #8]
 800c166:	709a      	strb	r2, [r3, #2]
  }
  return HAL_OK;
 800c168:	2300      	movs	r3, #0
}
 800c16a:	0018      	movs	r0, r3
 800c16c:	46bd      	mov	sp, r7
 800c16e:	b006      	add	sp, #24
 800c170:	bd80      	pop	{r7, pc}
 800c172:	46c0      	nop			; (mov r8, r8)
 800c174:	00ffff3f 	.word	0x00ffff3f

0800c178 <HAL_RTC_SetAlarm_IT>:
  *         is disabled (Use the HAL_RTC_DeactivateAlarm()).
  * @note   The HAL_RTC_SetTime() must be called before enabling the Alarm feature.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
{
 800c178:	b590      	push	{r4, r7, lr}
 800c17a:	b089      	sub	sp, #36	; 0x24
 800c17c:	af00      	add	r7, sp, #0
 800c17e:	60f8      	str	r0, [r7, #12]
 800c180:	60b9      	str	r1, [r7, #8]
 800c182:	607a      	str	r2, [r7, #4]
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 800c184:	68fb      	ldr	r3, [r7, #12]
 800c186:	2220      	movs	r2, #32
 800c188:	5c9b      	ldrb	r3, [r3, r2]
 800c18a:	2b01      	cmp	r3, #1
 800c18c:	d101      	bne.n	800c192 <HAL_RTC_SetAlarm_IT+0x1a>
 800c18e:	2302      	movs	r3, #2
 800c190:	e130      	b.n	800c3f4 <HAL_RTC_SetAlarm_IT+0x27c>
 800c192:	68fb      	ldr	r3, [r7, #12]
 800c194:	2220      	movs	r2, #32
 800c196:	2101      	movs	r1, #1
 800c198:	5499      	strb	r1, [r3, r2]

  hrtc->State = HAL_RTC_STATE_BUSY;
 800c19a:	68fb      	ldr	r3, [r7, #12]
 800c19c:	2221      	movs	r2, #33	; 0x21
 800c19e:	2102      	movs	r1, #2
 800c1a0:	5499      	strb	r1, [r3, r2]

  if (Format == RTC_FORMAT_BIN)
 800c1a2:	687b      	ldr	r3, [r7, #4]
 800c1a4:	2b00      	cmp	r3, #0
 800c1a6:	d136      	bne.n	800c216 <HAL_RTC_SetAlarm_IT+0x9e>
  {
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 800c1a8:	68fb      	ldr	r3, [r7, #12]
 800c1aa:	681b      	ldr	r3, [r3, #0]
 800c1ac:	689b      	ldr	r3, [r3, #8]
 800c1ae:	2240      	movs	r2, #64	; 0x40
 800c1b0:	4013      	ands	r3, r2
 800c1b2:	d102      	bne.n	800c1ba <HAL_RTC_SetAlarm_IT+0x42>
      assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
    }
    else
    {
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 800c1b4:	68bb      	ldr	r3, [r7, #8]
 800c1b6:	2200      	movs	r2, #0
 800c1b8:	70da      	strb	r2, [r3, #3]
    }
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 800c1ba:	68bb      	ldr	r3, [r7, #8]
 800c1bc:	781b      	ldrb	r3, [r3, #0]
 800c1be:	0018      	movs	r0, r3
 800c1c0:	f000 fa17 	bl	800c5f2 <RTC_ByteToBcd2>
 800c1c4:	0003      	movs	r3, r0
 800c1c6:	041c      	lsls	r4, r3, #16
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
 800c1c8:	68bb      	ldr	r3, [r7, #8]
 800c1ca:	785b      	ldrb	r3, [r3, #1]
 800c1cc:	0018      	movs	r0, r3
 800c1ce:	f000 fa10 	bl	800c5f2 <RTC_ByteToBcd2>
 800c1d2:	0003      	movs	r3, r0
 800c1d4:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 800c1d6:	431c      	orrs	r4, r3
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 800c1d8:	68bb      	ldr	r3, [r7, #8]
 800c1da:	789b      	ldrb	r3, [r3, #2]
 800c1dc:	0018      	movs	r0, r3
 800c1de:	f000 fa08 	bl	800c5f2 <RTC_ByteToBcd2>
 800c1e2:	0003      	movs	r3, r0
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
 800c1e4:	0022      	movs	r2, r4
 800c1e6:	431a      	orrs	r2, r3
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 800c1e8:	68bb      	ldr	r3, [r7, #8]
 800c1ea:	78db      	ldrb	r3, [r3, #3]
 800c1ec:	041b      	lsls	r3, r3, #16
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 800c1ee:	431a      	orrs	r2, r3
 800c1f0:	0014      	movs	r4, r2
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
 800c1f2:	68bb      	ldr	r3, [r7, #8]
 800c1f4:	2220      	movs	r2, #32
 800c1f6:	5c9b      	ldrb	r3, [r3, r2]
 800c1f8:	0018      	movs	r0, r3
 800c1fa:	f000 f9fa 	bl	800c5f2 <RTC_ByteToBcd2>
 800c1fe:	0003      	movs	r3, r0
 800c200:	061b      	lsls	r3, r3, #24
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 800c202:	0022      	movs	r2, r4
 800c204:	431a      	orrs	r2, r3
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
 800c206:	68bb      	ldr	r3, [r7, #8]
 800c208:	69db      	ldr	r3, [r3, #28]
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
 800c20a:	431a      	orrs	r2, r3
              ((uint32_t)sAlarm->AlarmMask));
 800c20c:	68bb      	ldr	r3, [r7, #8]
 800c20e:	695b      	ldr	r3, [r3, #20]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 800c210:	4313      	orrs	r3, r2
 800c212:	61fb      	str	r3, [r7, #28]
 800c214:	e022      	b.n	800c25c <HAL_RTC_SetAlarm_IT+0xe4>
  }
  else
  {
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 800c216:	68fb      	ldr	r3, [r7, #12]
 800c218:	681b      	ldr	r3, [r3, #0]
 800c21a:	689b      	ldr	r3, [r3, #8]
 800c21c:	2240      	movs	r2, #64	; 0x40
 800c21e:	4013      	ands	r3, r2
 800c220:	d102      	bne.n	800c228 <HAL_RTC_SetAlarm_IT+0xb0>
      assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
    }
    else
    {
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 800c222:	68bb      	ldr	r3, [r7, #8]
 800c224:	2200      	movs	r2, #0
 800c226:	70da      	strb	r2, [r3, #3]
    }
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
    }
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 800c228:	68bb      	ldr	r3, [r7, #8]
 800c22a:	781b      	ldrb	r3, [r3, #0]
 800c22c:	041a      	lsls	r2, r3, #16
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
 800c22e:	68bb      	ldr	r3, [r7, #8]
 800c230:	785b      	ldrb	r3, [r3, #1]
 800c232:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 800c234:	4313      	orrs	r3, r2
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
 800c236:	68ba      	ldr	r2, [r7, #8]
 800c238:	7892      	ldrb	r2, [r2, #2]
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
 800c23a:	431a      	orrs	r2, r3
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 800c23c:	68bb      	ldr	r3, [r7, #8]
 800c23e:	78db      	ldrb	r3, [r3, #3]
 800c240:	041b      	lsls	r3, r3, #16
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
 800c242:	431a      	orrs	r2, r3
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
 800c244:	68bb      	ldr	r3, [r7, #8]
 800c246:	2120      	movs	r1, #32
 800c248:	5c5b      	ldrb	r3, [r3, r1]
 800c24a:	061b      	lsls	r3, r3, #24
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 800c24c:	431a      	orrs	r2, r3
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
 800c24e:	68bb      	ldr	r3, [r7, #8]
 800c250:	69db      	ldr	r3, [r3, #28]
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
 800c252:	431a      	orrs	r2, r3
              ((uint32_t)sAlarm->AlarmMask));
 800c254:	68bb      	ldr	r3, [r7, #8]
 800c256:	695b      	ldr	r3, [r3, #20]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 800c258:	4313      	orrs	r3, r2
 800c25a:	61fb      	str	r3, [r7, #28]
  }
  /* Configure the Alarm A or Alarm B Sub Second registers */
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 800c25c:	68bb      	ldr	r3, [r7, #8]
 800c25e:	685a      	ldr	r2, [r3, #4]
 800c260:	68bb      	ldr	r3, [r7, #8]
 800c262:	699b      	ldr	r3, [r3, #24]
 800c264:	4313      	orrs	r3, r2
 800c266:	61bb      	str	r3, [r7, #24]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800c268:	68fb      	ldr	r3, [r7, #12]
 800c26a:	681b      	ldr	r3, [r3, #0]
 800c26c:	22ca      	movs	r2, #202	; 0xca
 800c26e:	625a      	str	r2, [r3, #36]	; 0x24
 800c270:	68fb      	ldr	r3, [r7, #12]
 800c272:	681b      	ldr	r3, [r3, #0]
 800c274:	2253      	movs	r2, #83	; 0x53
 800c276:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm register */
  if (sAlarm->Alarm == RTC_ALARM_A)
 800c278:	68bb      	ldr	r3, [r7, #8]
 800c27a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800c27c:	2380      	movs	r3, #128	; 0x80
 800c27e:	005b      	lsls	r3, r3, #1
 800c280:	429a      	cmp	r2, r3
 800c282:	d14e      	bne.n	800c322 <HAL_RTC_SetAlarm_IT+0x1aa>
  {
    /* Disable the Alarm A interrupt */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 800c284:	68fb      	ldr	r3, [r7, #12]
 800c286:	681b      	ldr	r3, [r3, #0]
 800c288:	689a      	ldr	r2, [r3, #8]
 800c28a:	68fb      	ldr	r3, [r7, #12]
 800c28c:	681b      	ldr	r3, [r3, #0]
 800c28e:	495b      	ldr	r1, [pc, #364]	; (800c3fc <HAL_RTC_SetAlarm_IT+0x284>)
 800c290:	400a      	ands	r2, r1
 800c292:	609a      	str	r2, [r3, #8]

    /* Clear flag alarm A */
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 800c294:	68fb      	ldr	r3, [r7, #12]
 800c296:	681b      	ldr	r3, [r3, #0]
 800c298:	68db      	ldr	r3, [r3, #12]
 800c29a:	22ff      	movs	r2, #255	; 0xff
 800c29c:	401a      	ands	r2, r3
 800c29e:	68fb      	ldr	r3, [r7, #12]
 800c2a0:	681b      	ldr	r3, [r3, #0]
 800c2a2:	4957      	ldr	r1, [pc, #348]	; (800c400 <HAL_RTC_SetAlarm_IT+0x288>)
 800c2a4:	430a      	orrs	r2, r1
 800c2a6:	60da      	str	r2, [r3, #12]

    tickstart = HAL_GetTick();
 800c2a8:	f7fc ff4a 	bl	8009140 <HAL_GetTick>
 800c2ac:	0003      	movs	r3, r0
 800c2ae:	617b      	str	r3, [r7, #20]
    /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
 800c2b0:	e016      	b.n	800c2e0 <HAL_RTC_SetAlarm_IT+0x168>
    {
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 800c2b2:	f7fc ff45 	bl	8009140 <HAL_GetTick>
 800c2b6:	0002      	movs	r2, r0
 800c2b8:	697b      	ldr	r3, [r7, #20]
 800c2ba:	1ad2      	subs	r2, r2, r3
 800c2bc:	23fa      	movs	r3, #250	; 0xfa
 800c2be:	009b      	lsls	r3, r3, #2
 800c2c0:	429a      	cmp	r2, r3
 800c2c2:	d90d      	bls.n	800c2e0 <HAL_RTC_SetAlarm_IT+0x168>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800c2c4:	68fb      	ldr	r3, [r7, #12]
 800c2c6:	681b      	ldr	r3, [r3, #0]
 800c2c8:	22ff      	movs	r2, #255	; 0xff
 800c2ca:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 800c2cc:	68fb      	ldr	r3, [r7, #12]
 800c2ce:	2221      	movs	r2, #33	; 0x21
 800c2d0:	2103      	movs	r1, #3
 800c2d2:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 800c2d4:	68fb      	ldr	r3, [r7, #12]
 800c2d6:	2220      	movs	r2, #32
 800c2d8:	2100      	movs	r1, #0
 800c2da:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 800c2dc:	2303      	movs	r3, #3
 800c2de:	e089      	b.n	800c3f4 <HAL_RTC_SetAlarm_IT+0x27c>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
 800c2e0:	68fb      	ldr	r3, [r7, #12]
 800c2e2:	681b      	ldr	r3, [r3, #0]
 800c2e4:	68db      	ldr	r3, [r3, #12]
 800c2e6:	2201      	movs	r2, #1
 800c2e8:	4013      	ands	r3, r2
 800c2ea:	d0e2      	beq.n	800c2b2 <HAL_RTC_SetAlarm_IT+0x13a>
      }
    }

    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
 800c2ec:	68fb      	ldr	r3, [r7, #12]
 800c2ee:	681b      	ldr	r3, [r3, #0]
 800c2f0:	69fa      	ldr	r2, [r7, #28]
 800c2f2:	61da      	str	r2, [r3, #28]
    /* Configure the Alarm A Sub Second register */
    hrtc->Instance->ALRMASSR = subsecondtmpreg;
 800c2f4:	68fb      	ldr	r3, [r7, #12]
 800c2f6:	681b      	ldr	r3, [r3, #0]
 800c2f8:	69ba      	ldr	r2, [r7, #24]
 800c2fa:	645a      	str	r2, [r3, #68]	; 0x44
    /* Configure the Alarm state: Enable Alarm */
    __HAL_RTC_ALARMA_ENABLE(hrtc);
 800c2fc:	68fb      	ldr	r3, [r7, #12]
 800c2fe:	681b      	ldr	r3, [r3, #0]
 800c300:	689a      	ldr	r2, [r3, #8]
 800c302:	68fb      	ldr	r3, [r7, #12]
 800c304:	681b      	ldr	r3, [r3, #0]
 800c306:	2180      	movs	r1, #128	; 0x80
 800c308:	0049      	lsls	r1, r1, #1
 800c30a:	430a      	orrs	r2, r1
 800c30c:	609a      	str	r2, [r3, #8]
    /* Configure the Alarm interrupt */
    __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRA);
 800c30e:	68fb      	ldr	r3, [r7, #12]
 800c310:	681b      	ldr	r3, [r3, #0]
 800c312:	689a      	ldr	r2, [r3, #8]
 800c314:	68fb      	ldr	r3, [r7, #12]
 800c316:	681b      	ldr	r3, [r3, #0]
 800c318:	2180      	movs	r1, #128	; 0x80
 800c31a:	0149      	lsls	r1, r1, #5
 800c31c:	430a      	orrs	r2, r1
 800c31e:	609a      	str	r2, [r3, #8]
 800c320:	e04d      	b.n	800c3be <HAL_RTC_SetAlarm_IT+0x246>
  }
  else
  {
    /* Disable the Alarm B interrupt */
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 800c322:	68fb      	ldr	r3, [r7, #12]
 800c324:	681b      	ldr	r3, [r3, #0]
 800c326:	689a      	ldr	r2, [r3, #8]
 800c328:	68fb      	ldr	r3, [r7, #12]
 800c32a:	681b      	ldr	r3, [r3, #0]
 800c32c:	4935      	ldr	r1, [pc, #212]	; (800c404 <HAL_RTC_SetAlarm_IT+0x28c>)
 800c32e:	400a      	ands	r2, r1
 800c330:	609a      	str	r2, [r3, #8]

    /* Clear flag alarm B */
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 800c332:	68fb      	ldr	r3, [r7, #12]
 800c334:	681b      	ldr	r3, [r3, #0]
 800c336:	68db      	ldr	r3, [r3, #12]
 800c338:	22ff      	movs	r2, #255	; 0xff
 800c33a:	401a      	ands	r2, r3
 800c33c:	68fb      	ldr	r3, [r7, #12]
 800c33e:	681b      	ldr	r3, [r3, #0]
 800c340:	4931      	ldr	r1, [pc, #196]	; (800c408 <HAL_RTC_SetAlarm_IT+0x290>)
 800c342:	430a      	orrs	r2, r1
 800c344:	60da      	str	r2, [r3, #12]

    tickstart = HAL_GetTick();
 800c346:	f7fc fefb 	bl	8009140 <HAL_GetTick>
 800c34a:	0003      	movs	r3, r0
 800c34c:	617b      	str	r3, [r7, #20]
    /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
 800c34e:	e016      	b.n	800c37e <HAL_RTC_SetAlarm_IT+0x206>
    {
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 800c350:	f7fc fef6 	bl	8009140 <HAL_GetTick>
 800c354:	0002      	movs	r2, r0
 800c356:	697b      	ldr	r3, [r7, #20]
 800c358:	1ad2      	subs	r2, r2, r3
 800c35a:	23fa      	movs	r3, #250	; 0xfa
 800c35c:	009b      	lsls	r3, r3, #2
 800c35e:	429a      	cmp	r2, r3
 800c360:	d90d      	bls.n	800c37e <HAL_RTC_SetAlarm_IT+0x206>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800c362:	68fb      	ldr	r3, [r7, #12]
 800c364:	681b      	ldr	r3, [r3, #0]
 800c366:	22ff      	movs	r2, #255	; 0xff
 800c368:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 800c36a:	68fb      	ldr	r3, [r7, #12]
 800c36c:	2221      	movs	r2, #33	; 0x21
 800c36e:	2103      	movs	r1, #3
 800c370:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 800c372:	68fb      	ldr	r3, [r7, #12]
 800c374:	2220      	movs	r2, #32
 800c376:	2100      	movs	r1, #0
 800c378:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 800c37a:	2303      	movs	r3, #3
 800c37c:	e03a      	b.n	800c3f4 <HAL_RTC_SetAlarm_IT+0x27c>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
 800c37e:	68fb      	ldr	r3, [r7, #12]
 800c380:	681b      	ldr	r3, [r3, #0]
 800c382:	68db      	ldr	r3, [r3, #12]
 800c384:	2202      	movs	r2, #2
 800c386:	4013      	ands	r3, r2
 800c388:	d0e2      	beq.n	800c350 <HAL_RTC_SetAlarm_IT+0x1d8>
      }
    }

    hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
 800c38a:	68fb      	ldr	r3, [r7, #12]
 800c38c:	681b      	ldr	r3, [r3, #0]
 800c38e:	69fa      	ldr	r2, [r7, #28]
 800c390:	621a      	str	r2, [r3, #32]
    /* Configure the Alarm B Sub Second register */
    hrtc->Instance->ALRMBSSR = subsecondtmpreg;
 800c392:	68fb      	ldr	r3, [r7, #12]
 800c394:	681b      	ldr	r3, [r3, #0]
 800c396:	69ba      	ldr	r2, [r7, #24]
 800c398:	649a      	str	r2, [r3, #72]	; 0x48
    /* Configure the Alarm state: Enable Alarm */
    __HAL_RTC_ALARMB_ENABLE(hrtc);
 800c39a:	68fb      	ldr	r3, [r7, #12]
 800c39c:	681b      	ldr	r3, [r3, #0]
 800c39e:	689a      	ldr	r2, [r3, #8]
 800c3a0:	68fb      	ldr	r3, [r7, #12]
 800c3a2:	681b      	ldr	r3, [r3, #0]
 800c3a4:	2180      	movs	r1, #128	; 0x80
 800c3a6:	0089      	lsls	r1, r1, #2
 800c3a8:	430a      	orrs	r2, r1
 800c3aa:	609a      	str	r2, [r3, #8]
    /* Configure the Alarm interrupt */
    __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
 800c3ac:	68fb      	ldr	r3, [r7, #12]
 800c3ae:	681b      	ldr	r3, [r3, #0]
 800c3b0:	689a      	ldr	r2, [r3, #8]
 800c3b2:	68fb      	ldr	r3, [r7, #12]
 800c3b4:	681b      	ldr	r3, [r3, #0]
 800c3b6:	2180      	movs	r1, #128	; 0x80
 800c3b8:	0189      	lsls	r1, r1, #6
 800c3ba:	430a      	orrs	r2, r1
 800c3bc:	609a      	str	r2, [r3, #8]
  }

  /* RTC Alarm Interrupt Configuration: EXTI configuration */
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 800c3be:	4b13      	ldr	r3, [pc, #76]	; (800c40c <HAL_RTC_SetAlarm_IT+0x294>)
 800c3c0:	681a      	ldr	r2, [r3, #0]
 800c3c2:	4b12      	ldr	r3, [pc, #72]	; (800c40c <HAL_RTC_SetAlarm_IT+0x294>)
 800c3c4:	2180      	movs	r1, #128	; 0x80
 800c3c6:	0289      	lsls	r1, r1, #10
 800c3c8:	430a      	orrs	r2, r1
 800c3ca:	601a      	str	r2, [r3, #0]

  __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();
 800c3cc:	4b0f      	ldr	r3, [pc, #60]	; (800c40c <HAL_RTC_SetAlarm_IT+0x294>)
 800c3ce:	689a      	ldr	r2, [r3, #8]
 800c3d0:	4b0e      	ldr	r3, [pc, #56]	; (800c40c <HAL_RTC_SetAlarm_IT+0x294>)
 800c3d2:	2180      	movs	r1, #128	; 0x80
 800c3d4:	0289      	lsls	r1, r1, #10
 800c3d6:	430a      	orrs	r2, r1
 800c3d8:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800c3da:	68fb      	ldr	r3, [r7, #12]
 800c3dc:	681b      	ldr	r3, [r3, #0]
 800c3de:	22ff      	movs	r2, #255	; 0xff
 800c3e0:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 800c3e2:	68fb      	ldr	r3, [r7, #12]
 800c3e4:	2221      	movs	r2, #33	; 0x21
 800c3e6:	2101      	movs	r1, #1
 800c3e8:	5499      	strb	r1, [r3, r2]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 800c3ea:	68fb      	ldr	r3, [r7, #12]
 800c3ec:	2220      	movs	r2, #32
 800c3ee:	2100      	movs	r1, #0
 800c3f0:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800c3f2:	2300      	movs	r3, #0
}
 800c3f4:	0018      	movs	r0, r3
 800c3f6:	46bd      	mov	sp, r7
 800c3f8:	b009      	add	sp, #36	; 0x24
 800c3fa:	bd90      	pop	{r4, r7, pc}
 800c3fc:	fffffeff 	.word	0xfffffeff
 800c400:	fffffe7f 	.word	0xfffffe7f
 800c404:	fffffdff 	.word	0xfffffdff
 800c408:	fffffd7f 	.word	0xfffffd7f
 800c40c:	40010400 	.word	0x40010400

0800c410 <HAL_RTC_DeactivateAlarm>:
  *            @arg RTC_ALARM_A:  AlarmA
  *            @arg RTC_ALARM_B:  AlarmB
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
{
 800c410:	b580      	push	{r7, lr}
 800c412:	b084      	sub	sp, #16
 800c414:	af00      	add	r7, sp, #0
 800c416:	6078      	str	r0, [r7, #4]
 800c418:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 800c41a:	687b      	ldr	r3, [r7, #4]
 800c41c:	2220      	movs	r2, #32
 800c41e:	5c9b      	ldrb	r3, [r3, r2]
 800c420:	2b01      	cmp	r3, #1
 800c422:	d101      	bne.n	800c428 <HAL_RTC_DeactivateAlarm+0x18>
 800c424:	2302      	movs	r3, #2
 800c426:	e086      	b.n	800c536 <HAL_RTC_DeactivateAlarm+0x126>
 800c428:	687b      	ldr	r3, [r7, #4]
 800c42a:	2220      	movs	r2, #32
 800c42c:	2101      	movs	r1, #1
 800c42e:	5499      	strb	r1, [r3, r2]

  hrtc->State = HAL_RTC_STATE_BUSY;
 800c430:	687b      	ldr	r3, [r7, #4]
 800c432:	2221      	movs	r2, #33	; 0x21
 800c434:	2102      	movs	r1, #2
 800c436:	5499      	strb	r1, [r3, r2]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800c438:	687b      	ldr	r3, [r7, #4]
 800c43a:	681b      	ldr	r3, [r3, #0]
 800c43c:	22ca      	movs	r2, #202	; 0xca
 800c43e:	625a      	str	r2, [r3, #36]	; 0x24
 800c440:	687b      	ldr	r3, [r7, #4]
 800c442:	681b      	ldr	r3, [r3, #0]
 800c444:	2253      	movs	r2, #83	; 0x53
 800c446:	625a      	str	r2, [r3, #36]	; 0x24

  if (Alarm == RTC_ALARM_A)
 800c448:	683a      	ldr	r2, [r7, #0]
 800c44a:	2380      	movs	r3, #128	; 0x80
 800c44c:	005b      	lsls	r3, r3, #1
 800c44e:	429a      	cmp	r2, r3
 800c450:	d132      	bne.n	800c4b8 <HAL_RTC_DeactivateAlarm+0xa8>
  {
    /* AlarmA */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 800c452:	687b      	ldr	r3, [r7, #4]
 800c454:	681b      	ldr	r3, [r3, #0]
 800c456:	689a      	ldr	r2, [r3, #8]
 800c458:	687b      	ldr	r3, [r7, #4]
 800c45a:	681b      	ldr	r3, [r3, #0]
 800c45c:	4938      	ldr	r1, [pc, #224]	; (800c540 <HAL_RTC_DeactivateAlarm+0x130>)
 800c45e:	400a      	ands	r2, r1
 800c460:	609a      	str	r2, [r3, #8]

    /* In case of interrupt mode is used, the interrupt source must disabled */
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
 800c462:	687b      	ldr	r3, [r7, #4]
 800c464:	681b      	ldr	r3, [r3, #0]
 800c466:	689a      	ldr	r2, [r3, #8]
 800c468:	687b      	ldr	r3, [r7, #4]
 800c46a:	681b      	ldr	r3, [r3, #0]
 800c46c:	4935      	ldr	r1, [pc, #212]	; (800c544 <HAL_RTC_DeactivateAlarm+0x134>)
 800c46e:	400a      	ands	r2, r1
 800c470:	609a      	str	r2, [r3, #8]

    tickstart = HAL_GetTick();
 800c472:	f7fc fe65 	bl	8009140 <HAL_GetTick>
 800c476:	0003      	movs	r3, r0
 800c478:	60fb      	str	r3, [r7, #12]

    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
 800c47a:	e016      	b.n	800c4aa <HAL_RTC_DeactivateAlarm+0x9a>
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 800c47c:	f7fc fe60 	bl	8009140 <HAL_GetTick>
 800c480:	0002      	movs	r2, r0
 800c482:	68fb      	ldr	r3, [r7, #12]
 800c484:	1ad2      	subs	r2, r2, r3
 800c486:	23fa      	movs	r3, #250	; 0xfa
 800c488:	009b      	lsls	r3, r3, #2
 800c48a:	429a      	cmp	r2, r3
 800c48c:	d90d      	bls.n	800c4aa <HAL_RTC_DeactivateAlarm+0x9a>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800c48e:	687b      	ldr	r3, [r7, #4]
 800c490:	681b      	ldr	r3, [r3, #0]
 800c492:	22ff      	movs	r2, #255	; 0xff
 800c494:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 800c496:	687b      	ldr	r3, [r7, #4]
 800c498:	2221      	movs	r2, #33	; 0x21
 800c49a:	2103      	movs	r1, #3
 800c49c:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 800c49e:	687b      	ldr	r3, [r7, #4]
 800c4a0:	2220      	movs	r2, #32
 800c4a2:	2100      	movs	r1, #0
 800c4a4:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 800c4a6:	2303      	movs	r3, #3
 800c4a8:	e045      	b.n	800c536 <HAL_RTC_DeactivateAlarm+0x126>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
 800c4aa:	687b      	ldr	r3, [r7, #4]
 800c4ac:	681b      	ldr	r3, [r3, #0]
 800c4ae:	68db      	ldr	r3, [r3, #12]
 800c4b0:	2201      	movs	r2, #1
 800c4b2:	4013      	ands	r3, r2
 800c4b4:	d0e2      	beq.n	800c47c <HAL_RTC_DeactivateAlarm+0x6c>
 800c4b6:	e031      	b.n	800c51c <HAL_RTC_DeactivateAlarm+0x10c>
    }
  }
  else
  {
    /* AlarmB */
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 800c4b8:	687b      	ldr	r3, [r7, #4]
 800c4ba:	681b      	ldr	r3, [r3, #0]
 800c4bc:	689a      	ldr	r2, [r3, #8]
 800c4be:	687b      	ldr	r3, [r7, #4]
 800c4c0:	681b      	ldr	r3, [r3, #0]
 800c4c2:	4921      	ldr	r1, [pc, #132]	; (800c548 <HAL_RTC_DeactivateAlarm+0x138>)
 800c4c4:	400a      	ands	r2, r1
 800c4c6:	609a      	str	r2, [r3, #8]

    /* In case of interrupt mode is used, the interrupt source must disabled */
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
 800c4c8:	687b      	ldr	r3, [r7, #4]
 800c4ca:	681b      	ldr	r3, [r3, #0]
 800c4cc:	689a      	ldr	r2, [r3, #8]
 800c4ce:	687b      	ldr	r3, [r7, #4]
 800c4d0:	681b      	ldr	r3, [r3, #0]
 800c4d2:	491e      	ldr	r1, [pc, #120]	; (800c54c <HAL_RTC_DeactivateAlarm+0x13c>)
 800c4d4:	400a      	ands	r2, r1
 800c4d6:	609a      	str	r2, [r3, #8]

    tickstart = HAL_GetTick();
 800c4d8:	f7fc fe32 	bl	8009140 <HAL_GetTick>
 800c4dc:	0003      	movs	r3, r0
 800c4de:	60fb      	str	r3, [r7, #12]

    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
 800c4e0:	e016      	b.n	800c510 <HAL_RTC_DeactivateAlarm+0x100>
    {
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 800c4e2:	f7fc fe2d 	bl	8009140 <HAL_GetTick>
 800c4e6:	0002      	movs	r2, r0
 800c4e8:	68fb      	ldr	r3, [r7, #12]
 800c4ea:	1ad2      	subs	r2, r2, r3
 800c4ec:	23fa      	movs	r3, #250	; 0xfa
 800c4ee:	009b      	lsls	r3, r3, #2
 800c4f0:	429a      	cmp	r2, r3
 800c4f2:	d90d      	bls.n	800c510 <HAL_RTC_DeactivateAlarm+0x100>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800c4f4:	687b      	ldr	r3, [r7, #4]
 800c4f6:	681b      	ldr	r3, [r3, #0]
 800c4f8:	22ff      	movs	r2, #255	; 0xff
 800c4fa:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 800c4fc:	687b      	ldr	r3, [r7, #4]
 800c4fe:	2221      	movs	r2, #33	; 0x21
 800c500:	2103      	movs	r1, #3
 800c502:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 800c504:	687b      	ldr	r3, [r7, #4]
 800c506:	2220      	movs	r2, #32
 800c508:	2100      	movs	r1, #0
 800c50a:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 800c50c:	2303      	movs	r3, #3
 800c50e:	e012      	b.n	800c536 <HAL_RTC_DeactivateAlarm+0x126>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
 800c510:	687b      	ldr	r3, [r7, #4]
 800c512:	681b      	ldr	r3, [r3, #0]
 800c514:	68db      	ldr	r3, [r3, #12]
 800c516:	2202      	movs	r2, #2
 800c518:	4013      	ands	r3, r2
 800c51a:	d0e2      	beq.n	800c4e2 <HAL_RTC_DeactivateAlarm+0xd2>
      }
    }
  }
  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800c51c:	687b      	ldr	r3, [r7, #4]
 800c51e:	681b      	ldr	r3, [r3, #0]
 800c520:	22ff      	movs	r2, #255	; 0xff
 800c522:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 800c524:	687b      	ldr	r3, [r7, #4]
 800c526:	2221      	movs	r2, #33	; 0x21
 800c528:	2101      	movs	r1, #1
 800c52a:	5499      	strb	r1, [r3, r2]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 800c52c:	687b      	ldr	r3, [r7, #4]
 800c52e:	2220      	movs	r2, #32
 800c530:	2100      	movs	r1, #0
 800c532:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800c534:	2300      	movs	r3, #0
}
 800c536:	0018      	movs	r0, r3
 800c538:	46bd      	mov	sp, r7
 800c53a:	b004      	add	sp, #16
 800c53c:	bd80      	pop	{r7, pc}
 800c53e:	46c0      	nop			; (mov r8, r8)
 800c540:	fffffeff 	.word	0xfffffeff
 800c544:	ffffefff 	.word	0xffffefff
 800c548:	fffffdff 	.word	0xfffffdff
 800c54c:	ffffdfff 	.word	0xffffdfff

0800c550 <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 800c550:	b580      	push	{r7, lr}
 800c552:	b084      	sub	sp, #16
 800c554:	af00      	add	r7, sp, #0
 800c556:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 800c558:	687b      	ldr	r3, [r7, #4]
 800c55a:	681b      	ldr	r3, [r3, #0]
 800c55c:	68da      	ldr	r2, [r3, #12]
 800c55e:	687b      	ldr	r3, [r7, #4]
 800c560:	681b      	ldr	r3, [r3, #0]
 800c562:	21a0      	movs	r1, #160	; 0xa0
 800c564:	438a      	bics	r2, r1
 800c566:	60da      	str	r2, [r3, #12]

  tickstart = HAL_GetTick();
 800c568:	f7fc fdea 	bl	8009140 <HAL_GetTick>
 800c56c:	0003      	movs	r3, r0
 800c56e:	60fb      	str	r3, [r7, #12]

  /* Wait the registers to be synchronised */
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 800c570:	e00a      	b.n	800c588 <HAL_RTC_WaitForSynchro+0x38>
  {
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 800c572:	f7fc fde5 	bl	8009140 <HAL_GetTick>
 800c576:	0002      	movs	r2, r0
 800c578:	68fb      	ldr	r3, [r7, #12]
 800c57a:	1ad2      	subs	r2, r2, r3
 800c57c:	23fa      	movs	r3, #250	; 0xfa
 800c57e:	009b      	lsls	r3, r3, #2
 800c580:	429a      	cmp	r2, r3
 800c582:	d901      	bls.n	800c588 <HAL_RTC_WaitForSynchro+0x38>
    {
      return HAL_TIMEOUT;
 800c584:	2303      	movs	r3, #3
 800c586:	e006      	b.n	800c596 <HAL_RTC_WaitForSynchro+0x46>
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 800c588:	687b      	ldr	r3, [r7, #4]
 800c58a:	681b      	ldr	r3, [r3, #0]
 800c58c:	68db      	ldr	r3, [r3, #12]
 800c58e:	2220      	movs	r2, #32
 800c590:	4013      	ands	r3, r2
 800c592:	d0ee      	beq.n	800c572 <HAL_RTC_WaitForSynchro+0x22>
    }
  }

  return HAL_OK;
 800c594:	2300      	movs	r3, #0
}
 800c596:	0018      	movs	r0, r3
 800c598:	46bd      	mov	sp, r7
 800c59a:	b004      	add	sp, #16
 800c59c:	bd80      	pop	{r7, pc}

0800c59e <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 800c59e:	b580      	push	{r7, lr}
 800c5a0:	b084      	sub	sp, #16
 800c5a2:	af00      	add	r7, sp, #0
 800c5a4:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check if the Initialization mode is set */
  if ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 800c5a6:	687b      	ldr	r3, [r7, #4]
 800c5a8:	681b      	ldr	r3, [r3, #0]
 800c5aa:	68db      	ldr	r3, [r3, #12]
 800c5ac:	2240      	movs	r2, #64	; 0x40
 800c5ae:	4013      	ands	r3, r2
 800c5b0:	d11a      	bne.n	800c5e8 <RTC_EnterInitMode+0x4a>
  {
    /* Set the Initialization mode */
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 800c5b2:	687b      	ldr	r3, [r7, #4]
 800c5b4:	681b      	ldr	r3, [r3, #0]
 800c5b6:	2201      	movs	r2, #1
 800c5b8:	4252      	negs	r2, r2
 800c5ba:	60da      	str	r2, [r3, #12]

    tickstart = HAL_GetTick();
 800c5bc:	f7fc fdc0 	bl	8009140 <HAL_GetTick>
 800c5c0:	0003      	movs	r3, r0
 800c5c2:	60fb      	str	r3, [r7, #12]
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 800c5c4:	e00a      	b.n	800c5dc <RTC_EnterInitMode+0x3e>
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 800c5c6:	f7fc fdbb 	bl	8009140 <HAL_GetTick>
 800c5ca:	0002      	movs	r2, r0
 800c5cc:	68fb      	ldr	r3, [r7, #12]
 800c5ce:	1ad2      	subs	r2, r2, r3
 800c5d0:	23fa      	movs	r3, #250	; 0xfa
 800c5d2:	009b      	lsls	r3, r3, #2
 800c5d4:	429a      	cmp	r2, r3
 800c5d6:	d901      	bls.n	800c5dc <RTC_EnterInitMode+0x3e>
      {
        return HAL_TIMEOUT;
 800c5d8:	2303      	movs	r3, #3
 800c5da:	e006      	b.n	800c5ea <RTC_EnterInitMode+0x4c>
    while ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 800c5dc:	687b      	ldr	r3, [r7, #4]
 800c5de:	681b      	ldr	r3, [r3, #0]
 800c5e0:	68db      	ldr	r3, [r3, #12]
 800c5e2:	2240      	movs	r2, #64	; 0x40
 800c5e4:	4013      	ands	r3, r2
 800c5e6:	d0ee      	beq.n	800c5c6 <RTC_EnterInitMode+0x28>
      }
    }
  }

  return HAL_OK;
 800c5e8:	2300      	movs	r3, #0
}
 800c5ea:	0018      	movs	r0, r3
 800c5ec:	46bd      	mov	sp, r7
 800c5ee:	b004      	add	sp, #16
 800c5f0:	bd80      	pop	{r7, pc}

0800c5f2 <RTC_ByteToBcd2>:
  * @brief  Convert a 2 digit decimal to BCD format.
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
 800c5f2:	b580      	push	{r7, lr}
 800c5f4:	b084      	sub	sp, #16
 800c5f6:	af00      	add	r7, sp, #0
 800c5f8:	0002      	movs	r2, r0
 800c5fa:	1dfb      	adds	r3, r7, #7
 800c5fc:	701a      	strb	r2, [r3, #0]
  uint32_t bcdhigh = 0U;
 800c5fe:	2300      	movs	r3, #0
 800c600:	60fb      	str	r3, [r7, #12]
  uint8_t Param = Value;
 800c602:	230b      	movs	r3, #11
 800c604:	18fb      	adds	r3, r7, r3
 800c606:	1dfa      	adds	r2, r7, #7
 800c608:	7812      	ldrb	r2, [r2, #0]
 800c60a:	701a      	strb	r2, [r3, #0]

  while (Param >= 10U)
 800c60c:	e008      	b.n	800c620 <RTC_ByteToBcd2+0x2e>
  {
    bcdhigh++;
 800c60e:	68fb      	ldr	r3, [r7, #12]
 800c610:	3301      	adds	r3, #1
 800c612:	60fb      	str	r3, [r7, #12]
    Param -= 10U;
 800c614:	220b      	movs	r2, #11
 800c616:	18bb      	adds	r3, r7, r2
 800c618:	18ba      	adds	r2, r7, r2
 800c61a:	7812      	ldrb	r2, [r2, #0]
 800c61c:	3a0a      	subs	r2, #10
 800c61e:	701a      	strb	r2, [r3, #0]
  while (Param >= 10U)
 800c620:	210b      	movs	r1, #11
 800c622:	187b      	adds	r3, r7, r1
 800c624:	781b      	ldrb	r3, [r3, #0]
 800c626:	2b09      	cmp	r3, #9
 800c628:	d8f1      	bhi.n	800c60e <RTC_ByteToBcd2+0x1c>
  }

  return ((uint8_t)(bcdhigh << 4U) | Param);
 800c62a:	68fb      	ldr	r3, [r7, #12]
 800c62c:	b2db      	uxtb	r3, r3
 800c62e:	011b      	lsls	r3, r3, #4
 800c630:	b2da      	uxtb	r2, r3
 800c632:	187b      	adds	r3, r7, r1
 800c634:	781b      	ldrb	r3, [r3, #0]
 800c636:	4313      	orrs	r3, r2
 800c638:	b2db      	uxtb	r3, r3
}
 800c63a:	0018      	movs	r0, r3
 800c63c:	46bd      	mov	sp, r7
 800c63e:	b004      	add	sp, #16
 800c640:	bd80      	pop	{r7, pc}

0800c642 <RTC_Bcd2ToByte>:
  * @brief  Convert from 2 digit BCD to Binary.
  * @param  Value BCD value to be converted
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
 800c642:	b580      	push	{r7, lr}
 800c644:	b084      	sub	sp, #16
 800c646:	af00      	add	r7, sp, #0
 800c648:	0002      	movs	r2, r0
 800c64a:	1dfb      	adds	r3, r7, #7
 800c64c:	701a      	strb	r2, [r3, #0]
  uint32_t tmp;
  tmp = (((uint32_t)Value & 0xF0U) >> 4U) * 10U;
 800c64e:	1dfb      	adds	r3, r7, #7
 800c650:	781b      	ldrb	r3, [r3, #0]
 800c652:	091b      	lsrs	r3, r3, #4
 800c654:	b2db      	uxtb	r3, r3
 800c656:	001a      	movs	r2, r3
 800c658:	0013      	movs	r3, r2
 800c65a:	009b      	lsls	r3, r3, #2
 800c65c:	189b      	adds	r3, r3, r2
 800c65e:	005b      	lsls	r3, r3, #1
 800c660:	60fb      	str	r3, [r7, #12]
  return (uint8_t)(tmp + ((uint32_t)Value & 0x0FU));
 800c662:	68fb      	ldr	r3, [r7, #12]
 800c664:	b2da      	uxtb	r2, r3
 800c666:	1dfb      	adds	r3, r7, #7
 800c668:	781b      	ldrb	r3, [r3, #0]
 800c66a:	210f      	movs	r1, #15
 800c66c:	400b      	ands	r3, r1
 800c66e:	b2db      	uxtb	r3, r3
 800c670:	18d3      	adds	r3, r2, r3
 800c672:	b2db      	uxtb	r3, r3
}
 800c674:	0018      	movs	r0, r3
 800c676:	46bd      	mov	sp, r7
 800c678:	b004      	add	sp, #16
 800c67a:	bd80      	pop	{r7, pc}

0800c67c <HAL_RTCEx_BKUPWrite>:
  *                                 specify the register.
  * @param  Data Data to be written in the specified RTC Backup data register.
  * @retval None
  */
void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)
{
 800c67c:	b580      	push	{r7, lr}
 800c67e:	b086      	sub	sp, #24
 800c680:	af00      	add	r7, sp, #0
 800c682:	60f8      	str	r0, [r7, #12]
 800c684:	60b9      	str	r1, [r7, #8]
 800c686:	607a      	str	r2, [r7, #4]
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (hrtc->Instance->BKP0R);
 800c688:	68fb      	ldr	r3, [r7, #12]
 800c68a:	681b      	ldr	r3, [r3, #0]
 800c68c:	3350      	adds	r3, #80	; 0x50
 800c68e:	617b      	str	r3, [r7, #20]
  tmp += (BackupRegister * 4U);
 800c690:	68bb      	ldr	r3, [r7, #8]
 800c692:	009b      	lsls	r3, r3, #2
 800c694:	697a      	ldr	r2, [r7, #20]
 800c696:	18d3      	adds	r3, r2, r3
 800c698:	617b      	str	r3, [r7, #20]

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 800c69a:	697b      	ldr	r3, [r7, #20]
 800c69c:	687a      	ldr	r2, [r7, #4]
 800c69e:	601a      	str	r2, [r3, #0]
}
 800c6a0:	46c0      	nop			; (mov r8, r8)
 800c6a2:	46bd      	mov	sp, r7
 800c6a4:	b006      	add	sp, #24
 800c6a6:	bd80      	pop	{r7, pc}

0800c6a8 <HAL_RTCEx_BKUPRead>:
  *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to
  *                                 specify the register.
  * @retval Read value
  */
uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)
{
 800c6a8:	b580      	push	{r7, lr}
 800c6aa:	b084      	sub	sp, #16
 800c6ac:	af00      	add	r7, sp, #0
 800c6ae:	6078      	str	r0, [r7, #4]
 800c6b0:	6039      	str	r1, [r7, #0]
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (hrtc->Instance->BKP0R);
 800c6b2:	687b      	ldr	r3, [r7, #4]
 800c6b4:	681b      	ldr	r3, [r3, #0]
 800c6b6:	3350      	adds	r3, #80	; 0x50
 800c6b8:	60fb      	str	r3, [r7, #12]
  tmp += (BackupRegister * 4U);
 800c6ba:	683b      	ldr	r3, [r7, #0]
 800c6bc:	009b      	lsls	r3, r3, #2
 800c6be:	68fa      	ldr	r2, [r7, #12]
 800c6c0:	18d3      	adds	r3, r2, r3
 800c6c2:	60fb      	str	r3, [r7, #12]

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 800c6c4:	68fb      	ldr	r3, [r7, #12]
 800c6c6:	681b      	ldr	r3, [r3, #0]
}
 800c6c8:	0018      	movs	r0, r3
 800c6ca:	46bd      	mov	sp, r7
 800c6cc:	b004      	add	sp, #16
 800c6ce:	bd80      	pop	{r7, pc}

0800c6d0 <HAL_RTCEx_EnableBypassShadow>:
  * @note   When the Bypass Shadow is enabled the calendar value are taken
  *         directly from the Calendar counter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
{
 800c6d0:	b580      	push	{r7, lr}
 800c6d2:	b082      	sub	sp, #8
 800c6d4:	af00      	add	r7, sp, #0
 800c6d6:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hrtc);
 800c6d8:	687b      	ldr	r3, [r7, #4]
 800c6da:	2220      	movs	r2, #32
 800c6dc:	5c9b      	ldrb	r3, [r3, r2]
 800c6de:	2b01      	cmp	r3, #1
 800c6e0:	d101      	bne.n	800c6e6 <HAL_RTCEx_EnableBypassShadow+0x16>
 800c6e2:	2302      	movs	r3, #2
 800c6e4:	e024      	b.n	800c730 <HAL_RTCEx_EnableBypassShadow+0x60>
 800c6e6:	687b      	ldr	r3, [r7, #4]
 800c6e8:	2220      	movs	r2, #32
 800c6ea:	2101      	movs	r1, #1
 800c6ec:	5499      	strb	r1, [r3, r2]

  hrtc->State = HAL_RTC_STATE_BUSY;
 800c6ee:	687b      	ldr	r3, [r7, #4]
 800c6f0:	2221      	movs	r2, #33	; 0x21
 800c6f2:	2102      	movs	r1, #2
 800c6f4:	5499      	strb	r1, [r3, r2]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800c6f6:	687b      	ldr	r3, [r7, #4]
 800c6f8:	681b      	ldr	r3, [r3, #0]
 800c6fa:	22ca      	movs	r2, #202	; 0xca
 800c6fc:	625a      	str	r2, [r3, #36]	; 0x24
 800c6fe:	687b      	ldr	r3, [r7, #4]
 800c700:	681b      	ldr	r3, [r3, #0]
 800c702:	2253      	movs	r2, #83	; 0x53
 800c704:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set the BYPSHAD bit */
  hrtc->Instance->CR |= (uint8_t)RTC_CR_BYPSHAD;
 800c706:	687b      	ldr	r3, [r7, #4]
 800c708:	681b      	ldr	r3, [r3, #0]
 800c70a:	689a      	ldr	r2, [r3, #8]
 800c70c:	687b      	ldr	r3, [r7, #4]
 800c70e:	681b      	ldr	r3, [r3, #0]
 800c710:	2120      	movs	r1, #32
 800c712:	430a      	orrs	r2, r1
 800c714:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800c716:	687b      	ldr	r3, [r7, #4]
 800c718:	681b      	ldr	r3, [r3, #0]
 800c71a:	22ff      	movs	r2, #255	; 0xff
 800c71c:	625a      	str	r2, [r3, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 800c71e:	687b      	ldr	r3, [r7, #4]
 800c720:	2221      	movs	r2, #33	; 0x21
 800c722:	2101      	movs	r1, #1
 800c724:	5499      	strb	r1, [r3, r2]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 800c726:	687b      	ldr	r3, [r7, #4]
 800c728:	2220      	movs	r2, #32
 800c72a:	2100      	movs	r1, #0
 800c72c:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800c72e:	2300      	movs	r3, #0
}
 800c730:	0018      	movs	r0, r3
 800c732:	46bd      	mov	sp, r7
 800c734:	b002      	add	sp, #8
 800c736:	bd80      	pop	{r7, pc}

0800c738 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 800c738:	b580      	push	{r7, lr}
 800c73a:	b082      	sub	sp, #8
 800c73c:	af00      	add	r7, sp, #0
 800c73e:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 800c740:	687b      	ldr	r3, [r7, #4]
 800c742:	2b00      	cmp	r3, #0
 800c744:	d101      	bne.n	800c74a <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 800c746:	2301      	movs	r3, #1
 800c748:	e059      	b.n	800c7fe <HAL_SPI_Init+0xc6>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800c74a:	687b      	ldr	r3, [r7, #4]
 800c74c:	2200      	movs	r2, #0
 800c74e:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800c750:	687b      	ldr	r3, [r7, #4]
 800c752:	2251      	movs	r2, #81	; 0x51
 800c754:	5c9b      	ldrb	r3, [r3, r2]
 800c756:	b2db      	uxtb	r3, r3
 800c758:	2b00      	cmp	r3, #0
 800c75a:	d107      	bne.n	800c76c <HAL_SPI_Init+0x34>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800c75c:	687b      	ldr	r3, [r7, #4]
 800c75e:	2250      	movs	r2, #80	; 0x50
 800c760:	2100      	movs	r1, #0
 800c762:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800c764:	687b      	ldr	r3, [r7, #4]
 800c766:	0018      	movs	r0, r3
 800c768:	f000 f850 	bl	800c80c <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 800c76c:	687b      	ldr	r3, [r7, #4]
 800c76e:	2251      	movs	r2, #81	; 0x51
 800c770:	2102      	movs	r1, #2
 800c772:	5499      	strb	r1, [r3, r2]

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800c774:	687b      	ldr	r3, [r7, #4]
 800c776:	681b      	ldr	r3, [r3, #0]
 800c778:	681a      	ldr	r2, [r3, #0]
 800c77a:	687b      	ldr	r3, [r7, #4]
 800c77c:	681b      	ldr	r3, [r3, #0]
 800c77e:	2140      	movs	r1, #64	; 0x40
 800c780:	438a      	bics	r2, r1
 800c782:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 800c784:	687b      	ldr	r3, [r7, #4]
 800c786:	685a      	ldr	r2, [r3, #4]
 800c788:	687b      	ldr	r3, [r7, #4]
 800c78a:	689b      	ldr	r3, [r3, #8]
 800c78c:	431a      	orrs	r2, r3
 800c78e:	687b      	ldr	r3, [r7, #4]
 800c790:	68db      	ldr	r3, [r3, #12]
 800c792:	431a      	orrs	r2, r3
 800c794:	687b      	ldr	r3, [r7, #4]
 800c796:	691b      	ldr	r3, [r3, #16]
 800c798:	431a      	orrs	r2, r3
 800c79a:	687b      	ldr	r3, [r7, #4]
 800c79c:	695b      	ldr	r3, [r3, #20]
 800c79e:	431a      	orrs	r2, r3
 800c7a0:	687b      	ldr	r3, [r7, #4]
 800c7a2:	6999      	ldr	r1, [r3, #24]
 800c7a4:	2380      	movs	r3, #128	; 0x80
 800c7a6:	009b      	lsls	r3, r3, #2
 800c7a8:	400b      	ands	r3, r1
 800c7aa:	431a      	orrs	r2, r3
 800c7ac:	687b      	ldr	r3, [r7, #4]
 800c7ae:	69db      	ldr	r3, [r3, #28]
 800c7b0:	431a      	orrs	r2, r3
 800c7b2:	687b      	ldr	r3, [r7, #4]
 800c7b4:	6a1b      	ldr	r3, [r3, #32]
 800c7b6:	431a      	orrs	r2, r3
 800c7b8:	0011      	movs	r1, r2
 800c7ba:	687b      	ldr	r3, [r7, #4]
 800c7bc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800c7be:	687b      	ldr	r3, [r7, #4]
 800c7c0:	681b      	ldr	r3, [r3, #0]
 800c7c2:	430a      	orrs	r2, r1
 800c7c4:	601a      	str	r2, [r3, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 800c7c6:	687b      	ldr	r3, [r7, #4]
 800c7c8:	699b      	ldr	r3, [r3, #24]
 800c7ca:	0c1b      	lsrs	r3, r3, #16
 800c7cc:	2204      	movs	r2, #4
 800c7ce:	4013      	ands	r3, r2
 800c7d0:	0019      	movs	r1, r3
 800c7d2:	687b      	ldr	r3, [r7, #4]
 800c7d4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800c7d6:	687b      	ldr	r3, [r7, #4]
 800c7d8:	681b      	ldr	r3, [r3, #0]
 800c7da:	430a      	orrs	r2, r1
 800c7dc:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800c7de:	687b      	ldr	r3, [r7, #4]
 800c7e0:	681b      	ldr	r3, [r3, #0]
 800c7e2:	69da      	ldr	r2, [r3, #28]
 800c7e4:	687b      	ldr	r3, [r7, #4]
 800c7e6:	681b      	ldr	r3, [r3, #0]
 800c7e8:	4907      	ldr	r1, [pc, #28]	; (800c808 <HAL_SPI_Init+0xd0>)
 800c7ea:	400a      	ands	r2, r1
 800c7ec:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800c7ee:	687b      	ldr	r3, [r7, #4]
 800c7f0:	2200      	movs	r2, #0
 800c7f2:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 800c7f4:	687b      	ldr	r3, [r7, #4]
 800c7f6:	2251      	movs	r2, #81	; 0x51
 800c7f8:	2101      	movs	r1, #1
 800c7fa:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800c7fc:	2300      	movs	r3, #0
}
 800c7fe:	0018      	movs	r0, r3
 800c800:	46bd      	mov	sp, r7
 800c802:	b002      	add	sp, #8
 800c804:	bd80      	pop	{r7, pc}
 800c806:	46c0      	nop			; (mov r8, r8)
 800c808:	fffff7ff 	.word	0xfffff7ff

0800c80c <HAL_SPI_MspInit>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
{
 800c80c:	b580      	push	{r7, lr}
 800c80e:	b082      	sub	sp, #8
 800c810:	af00      	add	r7, sp, #0
 800c812:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_MspInit should be implemented in the user file
   */
}
 800c814:	46c0      	nop			; (mov r8, r8)
 800c816:	46bd      	mov	sp, r7
 800c818:	b002      	add	sp, #8
 800c81a:	bd80      	pop	{r7, pc}

0800c81c <HAL_SPI_TransmitReceive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 800c81c:	b580      	push	{r7, lr}
 800c81e:	b08c      	sub	sp, #48	; 0x30
 800c820:	af00      	add	r7, sp, #0
 800c822:	60f8      	str	r0, [r7, #12]
 800c824:	60b9      	str	r1, [r7, #8]
 800c826:	607a      	str	r2, [r7, #4]
 800c828:	001a      	movs	r2, r3
 800c82a:	1cbb      	adds	r3, r7, #2
 800c82c:	801a      	strh	r2, [r3, #0]
  uint32_t             tmp_mode;
  HAL_SPI_StateTypeDef tmp_state;
  uint32_t             tickstart;

  /* Variable used to alternate Rx and Tx during transfer */
  uint32_t             txallowed = 1U;
 800c82e:	2301      	movs	r3, #1
 800c830:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_StatusTypeDef    errorcode = HAL_OK;
 800c832:	232b      	movs	r3, #43	; 0x2b
 800c834:	18fb      	adds	r3, r7, r3
 800c836:	2200      	movs	r2, #0
 800c838:	701a      	strb	r2, [r3, #0]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800c83a:	68fb      	ldr	r3, [r7, #12]
 800c83c:	2250      	movs	r2, #80	; 0x50
 800c83e:	5c9b      	ldrb	r3, [r3, r2]
 800c840:	2b01      	cmp	r3, #1
 800c842:	d101      	bne.n	800c848 <HAL_SPI_TransmitReceive+0x2c>
 800c844:	2302      	movs	r3, #2
 800c846:	e1a0      	b.n	800cb8a <HAL_SPI_TransmitReceive+0x36e>
 800c848:	68fb      	ldr	r3, [r7, #12]
 800c84a:	2250      	movs	r2, #80	; 0x50
 800c84c:	2101      	movs	r1, #1
 800c84e:	5499      	strb	r1, [r3, r2]

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 800c850:	f7fc fc76 	bl	8009140 <HAL_GetTick>
 800c854:	0003      	movs	r3, r0
 800c856:	627b      	str	r3, [r7, #36]	; 0x24

  /* Init temporary variables */
  tmp_state           = hspi->State;
 800c858:	2023      	movs	r0, #35	; 0x23
 800c85a:	183b      	adds	r3, r7, r0
 800c85c:	68fa      	ldr	r2, [r7, #12]
 800c85e:	2151      	movs	r1, #81	; 0x51
 800c860:	5c52      	ldrb	r2, [r2, r1]
 800c862:	701a      	strb	r2, [r3, #0]
  tmp_mode            = hspi->Init.Mode;
 800c864:	68fb      	ldr	r3, [r7, #12]
 800c866:	685b      	ldr	r3, [r3, #4]
 800c868:	61fb      	str	r3, [r7, #28]
  initial_TxXferCount = Size;
 800c86a:	231a      	movs	r3, #26
 800c86c:	18fb      	adds	r3, r7, r3
 800c86e:	1cba      	adds	r2, r7, #2
 800c870:	8812      	ldrh	r2, [r2, #0]
 800c872:	801a      	strh	r2, [r3, #0]

  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 800c874:	183b      	adds	r3, r7, r0
 800c876:	781b      	ldrb	r3, [r3, #0]
 800c878:	2b01      	cmp	r3, #1
 800c87a:	d011      	beq.n	800c8a0 <HAL_SPI_TransmitReceive+0x84>
 800c87c:	69fa      	ldr	r2, [r7, #28]
 800c87e:	2382      	movs	r3, #130	; 0x82
 800c880:	005b      	lsls	r3, r3, #1
 800c882:	429a      	cmp	r2, r3
 800c884:	d107      	bne.n	800c896 <HAL_SPI_TransmitReceive+0x7a>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 800c886:	68fb      	ldr	r3, [r7, #12]
 800c888:	689b      	ldr	r3, [r3, #8]
 800c88a:	2b00      	cmp	r3, #0
 800c88c:	d103      	bne.n	800c896 <HAL_SPI_TransmitReceive+0x7a>
 800c88e:	183b      	adds	r3, r7, r0
 800c890:	781b      	ldrb	r3, [r3, #0]
 800c892:	2b04      	cmp	r3, #4
 800c894:	d004      	beq.n	800c8a0 <HAL_SPI_TransmitReceive+0x84>
  {
    errorcode = HAL_BUSY;
 800c896:	232b      	movs	r3, #43	; 0x2b
 800c898:	18fb      	adds	r3, r7, r3
 800c89a:	2202      	movs	r2, #2
 800c89c:	701a      	strb	r2, [r3, #0]
    goto error;
 800c89e:	e169      	b.n	800cb74 <HAL_SPI_TransmitReceive+0x358>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 800c8a0:	68bb      	ldr	r3, [r7, #8]
 800c8a2:	2b00      	cmp	r3, #0
 800c8a4:	d006      	beq.n	800c8b4 <HAL_SPI_TransmitReceive+0x98>
 800c8a6:	687b      	ldr	r3, [r7, #4]
 800c8a8:	2b00      	cmp	r3, #0
 800c8aa:	d003      	beq.n	800c8b4 <HAL_SPI_TransmitReceive+0x98>
 800c8ac:	1cbb      	adds	r3, r7, #2
 800c8ae:	881b      	ldrh	r3, [r3, #0]
 800c8b0:	2b00      	cmp	r3, #0
 800c8b2:	d104      	bne.n	800c8be <HAL_SPI_TransmitReceive+0xa2>
  {
    errorcode = HAL_ERROR;
 800c8b4:	232b      	movs	r3, #43	; 0x2b
 800c8b6:	18fb      	adds	r3, r7, r3
 800c8b8:	2201      	movs	r2, #1
 800c8ba:	701a      	strb	r2, [r3, #0]
    goto error;
 800c8bc:	e15a      	b.n	800cb74 <HAL_SPI_TransmitReceive+0x358>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 800c8be:	68fb      	ldr	r3, [r7, #12]
 800c8c0:	2251      	movs	r2, #81	; 0x51
 800c8c2:	5c9b      	ldrb	r3, [r3, r2]
 800c8c4:	b2db      	uxtb	r3, r3
 800c8c6:	2b04      	cmp	r3, #4
 800c8c8:	d003      	beq.n	800c8d2 <HAL_SPI_TransmitReceive+0xb6>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 800c8ca:	68fb      	ldr	r3, [r7, #12]
 800c8cc:	2251      	movs	r2, #81	; 0x51
 800c8ce:	2105      	movs	r1, #5
 800c8d0:	5499      	strb	r1, [r3, r2]
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800c8d2:	68fb      	ldr	r3, [r7, #12]
 800c8d4:	2200      	movs	r2, #0
 800c8d6:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 800c8d8:	68fb      	ldr	r3, [r7, #12]
 800c8da:	687a      	ldr	r2, [r7, #4]
 800c8dc:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->RxXferCount = Size;
 800c8de:	68fb      	ldr	r3, [r7, #12]
 800c8e0:	1cba      	adds	r2, r7, #2
 800c8e2:	8812      	ldrh	r2, [r2, #0]
 800c8e4:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->RxXferSize  = Size;
 800c8e6:	68fb      	ldr	r3, [r7, #12]
 800c8e8:	1cba      	adds	r2, r7, #2
 800c8ea:	8812      	ldrh	r2, [r2, #0]
 800c8ec:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 800c8ee:	68fb      	ldr	r3, [r7, #12]
 800c8f0:	68ba      	ldr	r2, [r7, #8]
 800c8f2:	631a      	str	r2, [r3, #48]	; 0x30
  hspi->TxXferCount = Size;
 800c8f4:	68fb      	ldr	r3, [r7, #12]
 800c8f6:	1cba      	adds	r2, r7, #2
 800c8f8:	8812      	ldrh	r2, [r2, #0]
 800c8fa:	86da      	strh	r2, [r3, #54]	; 0x36
  hspi->TxXferSize  = Size;
 800c8fc:	68fb      	ldr	r3, [r7, #12]
 800c8fe:	1cba      	adds	r2, r7, #2
 800c900:	8812      	ldrh	r2, [r2, #0]
 800c902:	869a      	strh	r2, [r3, #52]	; 0x34

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 800c904:	68fb      	ldr	r3, [r7, #12]
 800c906:	2200      	movs	r2, #0
 800c908:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->TxISR       = NULL;
 800c90a:	68fb      	ldr	r3, [r7, #12]
 800c90c:	2200      	movs	r2, #0
 800c90e:	645a      	str	r2, [r3, #68]	; 0x44
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800c910:	68fb      	ldr	r3, [r7, #12]
 800c912:	681b      	ldr	r3, [r3, #0]
 800c914:	681b      	ldr	r3, [r3, #0]
 800c916:	2240      	movs	r2, #64	; 0x40
 800c918:	4013      	ands	r3, r2
 800c91a:	2b40      	cmp	r3, #64	; 0x40
 800c91c:	d007      	beq.n	800c92e <HAL_SPI_TransmitReceive+0x112>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 800c91e:	68fb      	ldr	r3, [r7, #12]
 800c920:	681b      	ldr	r3, [r3, #0]
 800c922:	681a      	ldr	r2, [r3, #0]
 800c924:	68fb      	ldr	r3, [r7, #12]
 800c926:	681b      	ldr	r3, [r3, #0]
 800c928:	2140      	movs	r1, #64	; 0x40
 800c92a:	430a      	orrs	r2, r1
 800c92c:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 800c92e:	68fb      	ldr	r3, [r7, #12]
 800c930:	68da      	ldr	r2, [r3, #12]
 800c932:	2380      	movs	r3, #128	; 0x80
 800c934:	011b      	lsls	r3, r3, #4
 800c936:	429a      	cmp	r2, r3
 800c938:	d000      	beq.n	800c93c <HAL_SPI_TransmitReceive+0x120>
 800c93a:	e07a      	b.n	800ca32 <HAL_SPI_TransmitReceive+0x216>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 800c93c:	68fb      	ldr	r3, [r7, #12]
 800c93e:	685b      	ldr	r3, [r3, #4]
 800c940:	2b00      	cmp	r3, #0
 800c942:	d004      	beq.n	800c94e <HAL_SPI_TransmitReceive+0x132>
 800c944:	231a      	movs	r3, #26
 800c946:	18fb      	adds	r3, r7, r3
 800c948:	881b      	ldrh	r3, [r3, #0]
 800c94a:	2b01      	cmp	r3, #1
 800c94c:	d166      	bne.n	800ca1c <HAL_SPI_TransmitReceive+0x200>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800c94e:	68fb      	ldr	r3, [r7, #12]
 800c950:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c952:	881a      	ldrh	r2, [r3, #0]
 800c954:	68fb      	ldr	r3, [r7, #12]
 800c956:	681b      	ldr	r3, [r3, #0]
 800c958:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 800c95a:	68fb      	ldr	r3, [r7, #12]
 800c95c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c95e:	1c9a      	adds	r2, r3, #2
 800c960:	68fb      	ldr	r3, [r7, #12]
 800c962:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 800c964:	68fb      	ldr	r3, [r7, #12]
 800c966:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800c968:	b29b      	uxth	r3, r3
 800c96a:	3b01      	subs	r3, #1
 800c96c:	b29a      	uxth	r2, r3
 800c96e:	68fb      	ldr	r3, [r7, #12]
 800c970:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800c972:	e053      	b.n	800ca1c <HAL_SPI_TransmitReceive+0x200>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 800c974:	68fb      	ldr	r3, [r7, #12]
 800c976:	681b      	ldr	r3, [r3, #0]
 800c978:	689b      	ldr	r3, [r3, #8]
 800c97a:	2202      	movs	r2, #2
 800c97c:	4013      	ands	r3, r2
 800c97e:	2b02      	cmp	r3, #2
 800c980:	d11b      	bne.n	800c9ba <HAL_SPI_TransmitReceive+0x19e>
 800c982:	68fb      	ldr	r3, [r7, #12]
 800c984:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800c986:	b29b      	uxth	r3, r3
 800c988:	2b00      	cmp	r3, #0
 800c98a:	d016      	beq.n	800c9ba <HAL_SPI_TransmitReceive+0x19e>
 800c98c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c98e:	2b01      	cmp	r3, #1
 800c990:	d113      	bne.n	800c9ba <HAL_SPI_TransmitReceive+0x19e>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800c992:	68fb      	ldr	r3, [r7, #12]
 800c994:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c996:	881a      	ldrh	r2, [r3, #0]
 800c998:	68fb      	ldr	r3, [r7, #12]
 800c99a:	681b      	ldr	r3, [r3, #0]
 800c99c:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 800c99e:	68fb      	ldr	r3, [r7, #12]
 800c9a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c9a2:	1c9a      	adds	r2, r3, #2
 800c9a4:	68fb      	ldr	r3, [r7, #12]
 800c9a6:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 800c9a8:	68fb      	ldr	r3, [r7, #12]
 800c9aa:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800c9ac:	b29b      	uxth	r3, r3
 800c9ae:	3b01      	subs	r3, #1
 800c9b0:	b29a      	uxth	r2, r3
 800c9b2:	68fb      	ldr	r3, [r7, #12]
 800c9b4:	86da      	strh	r2, [r3, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 800c9b6:	2300      	movs	r3, #0
 800c9b8:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Check RXNE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 800c9ba:	68fb      	ldr	r3, [r7, #12]
 800c9bc:	681b      	ldr	r3, [r3, #0]
 800c9be:	689b      	ldr	r3, [r3, #8]
 800c9c0:	2201      	movs	r2, #1
 800c9c2:	4013      	ands	r3, r2
 800c9c4:	2b01      	cmp	r3, #1
 800c9c6:	d119      	bne.n	800c9fc <HAL_SPI_TransmitReceive+0x1e0>
 800c9c8:	68fb      	ldr	r3, [r7, #12]
 800c9ca:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800c9cc:	b29b      	uxth	r3, r3
 800c9ce:	2b00      	cmp	r3, #0
 800c9d0:	d014      	beq.n	800c9fc <HAL_SPI_TransmitReceive+0x1e0>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 800c9d2:	68fb      	ldr	r3, [r7, #12]
 800c9d4:	681b      	ldr	r3, [r3, #0]
 800c9d6:	68da      	ldr	r2, [r3, #12]
 800c9d8:	68fb      	ldr	r3, [r7, #12]
 800c9da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c9dc:	b292      	uxth	r2, r2
 800c9de:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 800c9e0:	68fb      	ldr	r3, [r7, #12]
 800c9e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c9e4:	1c9a      	adds	r2, r3, #2
 800c9e6:	68fb      	ldr	r3, [r7, #12]
 800c9e8:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 800c9ea:	68fb      	ldr	r3, [r7, #12]
 800c9ec:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800c9ee:	b29b      	uxth	r3, r3
 800c9f0:	3b01      	subs	r3, #1
 800c9f2:	b29a      	uxth	r2, r3
 800c9f4:	68fb      	ldr	r3, [r7, #12]
 800c9f6:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 800c9f8:	2301      	movs	r3, #1
 800c9fa:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 800c9fc:	f7fc fba0 	bl	8009140 <HAL_GetTick>
 800ca00:	0002      	movs	r2, r0
 800ca02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ca04:	1ad3      	subs	r3, r2, r3
 800ca06:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800ca08:	429a      	cmp	r2, r3
 800ca0a:	d807      	bhi.n	800ca1c <HAL_SPI_TransmitReceive+0x200>
 800ca0c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ca0e:	3301      	adds	r3, #1
 800ca10:	d004      	beq.n	800ca1c <HAL_SPI_TransmitReceive+0x200>
      {
        errorcode = HAL_TIMEOUT;
 800ca12:	232b      	movs	r3, #43	; 0x2b
 800ca14:	18fb      	adds	r3, r7, r3
 800ca16:	2203      	movs	r2, #3
 800ca18:	701a      	strb	r2, [r3, #0]
        goto error;
 800ca1a:	e0ab      	b.n	800cb74 <HAL_SPI_TransmitReceive+0x358>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800ca1c:	68fb      	ldr	r3, [r7, #12]
 800ca1e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800ca20:	b29b      	uxth	r3, r3
 800ca22:	2b00      	cmp	r3, #0
 800ca24:	d1a6      	bne.n	800c974 <HAL_SPI_TransmitReceive+0x158>
 800ca26:	68fb      	ldr	r3, [r7, #12]
 800ca28:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800ca2a:	b29b      	uxth	r3, r3
 800ca2c:	2b00      	cmp	r3, #0
 800ca2e:	d1a1      	bne.n	800c974 <HAL_SPI_TransmitReceive+0x158>
 800ca30:	e07f      	b.n	800cb32 <HAL_SPI_TransmitReceive+0x316>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 800ca32:	68fb      	ldr	r3, [r7, #12]
 800ca34:	685b      	ldr	r3, [r3, #4]
 800ca36:	2b00      	cmp	r3, #0
 800ca38:	d005      	beq.n	800ca46 <HAL_SPI_TransmitReceive+0x22a>
 800ca3a:	231a      	movs	r3, #26
 800ca3c:	18fb      	adds	r3, r7, r3
 800ca3e:	881b      	ldrh	r3, [r3, #0]
 800ca40:	2b01      	cmp	r3, #1
 800ca42:	d000      	beq.n	800ca46 <HAL_SPI_TransmitReceive+0x22a>
 800ca44:	e06b      	b.n	800cb1e <HAL_SPI_TransmitReceive+0x302>
    {
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 800ca46:	68fb      	ldr	r3, [r7, #12]
 800ca48:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ca4a:	68fb      	ldr	r3, [r7, #12]
 800ca4c:	681b      	ldr	r3, [r3, #0]
 800ca4e:	330c      	adds	r3, #12
 800ca50:	7812      	ldrb	r2, [r2, #0]
 800ca52:	701a      	strb	r2, [r3, #0]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 800ca54:	68fb      	ldr	r3, [r7, #12]
 800ca56:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ca58:	1c5a      	adds	r2, r3, #1
 800ca5a:	68fb      	ldr	r3, [r7, #12]
 800ca5c:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 800ca5e:	68fb      	ldr	r3, [r7, #12]
 800ca60:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800ca62:	b29b      	uxth	r3, r3
 800ca64:	3b01      	subs	r3, #1
 800ca66:	b29a      	uxth	r2, r3
 800ca68:	68fb      	ldr	r3, [r7, #12]
 800ca6a:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800ca6c:	e057      	b.n	800cb1e <HAL_SPI_TransmitReceive+0x302>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 800ca6e:	68fb      	ldr	r3, [r7, #12]
 800ca70:	681b      	ldr	r3, [r3, #0]
 800ca72:	689b      	ldr	r3, [r3, #8]
 800ca74:	2202      	movs	r2, #2
 800ca76:	4013      	ands	r3, r2
 800ca78:	2b02      	cmp	r3, #2
 800ca7a:	d11c      	bne.n	800cab6 <HAL_SPI_TransmitReceive+0x29a>
 800ca7c:	68fb      	ldr	r3, [r7, #12]
 800ca7e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800ca80:	b29b      	uxth	r3, r3
 800ca82:	2b00      	cmp	r3, #0
 800ca84:	d017      	beq.n	800cab6 <HAL_SPI_TransmitReceive+0x29a>
 800ca86:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ca88:	2b01      	cmp	r3, #1
 800ca8a:	d114      	bne.n	800cab6 <HAL_SPI_TransmitReceive+0x29a>
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 800ca8c:	68fb      	ldr	r3, [r7, #12]
 800ca8e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ca90:	68fb      	ldr	r3, [r7, #12]
 800ca92:	681b      	ldr	r3, [r3, #0]
 800ca94:	330c      	adds	r3, #12
 800ca96:	7812      	ldrb	r2, [r2, #0]
 800ca98:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr++;
 800ca9a:	68fb      	ldr	r3, [r7, #12]
 800ca9c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ca9e:	1c5a      	adds	r2, r3, #1
 800caa0:	68fb      	ldr	r3, [r7, #12]
 800caa2:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 800caa4:	68fb      	ldr	r3, [r7, #12]
 800caa6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800caa8:	b29b      	uxth	r3, r3
 800caaa:	3b01      	subs	r3, #1
 800caac:	b29a      	uxth	r2, r3
 800caae:	68fb      	ldr	r3, [r7, #12]
 800cab0:	86da      	strh	r2, [r3, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 800cab2:	2300      	movs	r3, #0
 800cab4:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 800cab6:	68fb      	ldr	r3, [r7, #12]
 800cab8:	681b      	ldr	r3, [r3, #0]
 800caba:	689b      	ldr	r3, [r3, #8]
 800cabc:	2201      	movs	r2, #1
 800cabe:	4013      	ands	r3, r2
 800cac0:	2b01      	cmp	r3, #1
 800cac2:	d119      	bne.n	800caf8 <HAL_SPI_TransmitReceive+0x2dc>
 800cac4:	68fb      	ldr	r3, [r7, #12]
 800cac6:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800cac8:	b29b      	uxth	r3, r3
 800caca:	2b00      	cmp	r3, #0
 800cacc:	d014      	beq.n	800caf8 <HAL_SPI_TransmitReceive+0x2dc>
      {
        (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 800cace:	68fb      	ldr	r3, [r7, #12]
 800cad0:	681b      	ldr	r3, [r3, #0]
 800cad2:	68da      	ldr	r2, [r3, #12]
 800cad4:	68fb      	ldr	r3, [r7, #12]
 800cad6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800cad8:	b2d2      	uxtb	r2, r2
 800cada:	701a      	strb	r2, [r3, #0]
        hspi->pRxBuffPtr++;
 800cadc:	68fb      	ldr	r3, [r7, #12]
 800cade:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800cae0:	1c5a      	adds	r2, r3, #1
 800cae2:	68fb      	ldr	r3, [r7, #12]
 800cae4:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 800cae6:	68fb      	ldr	r3, [r7, #12]
 800cae8:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800caea:	b29b      	uxth	r3, r3
 800caec:	3b01      	subs	r3, #1
 800caee:	b29a      	uxth	r2, r3
 800caf0:	68fb      	ldr	r3, [r7, #12]
 800caf2:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 800caf4:	2301      	movs	r3, #1
 800caf6:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 800caf8:	f7fc fb22 	bl	8009140 <HAL_GetTick>
 800cafc:	0002      	movs	r2, r0
 800cafe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cb00:	1ad3      	subs	r3, r2, r3
 800cb02:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800cb04:	429a      	cmp	r2, r3
 800cb06:	d802      	bhi.n	800cb0e <HAL_SPI_TransmitReceive+0x2f2>
 800cb08:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800cb0a:	3301      	adds	r3, #1
 800cb0c:	d102      	bne.n	800cb14 <HAL_SPI_TransmitReceive+0x2f8>
 800cb0e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800cb10:	2b00      	cmp	r3, #0
 800cb12:	d104      	bne.n	800cb1e <HAL_SPI_TransmitReceive+0x302>
      {
        errorcode = HAL_TIMEOUT;
 800cb14:	232b      	movs	r3, #43	; 0x2b
 800cb16:	18fb      	adds	r3, r7, r3
 800cb18:	2203      	movs	r2, #3
 800cb1a:	701a      	strb	r2, [r3, #0]
        goto error;
 800cb1c:	e02a      	b.n	800cb74 <HAL_SPI_TransmitReceive+0x358>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800cb1e:	68fb      	ldr	r3, [r7, #12]
 800cb20:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800cb22:	b29b      	uxth	r3, r3
 800cb24:	2b00      	cmp	r3, #0
 800cb26:	d1a2      	bne.n	800ca6e <HAL_SPI_TransmitReceive+0x252>
 800cb28:	68fb      	ldr	r3, [r7, #12]
 800cb2a:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800cb2c:	b29b      	uxth	r3, r3
 800cb2e:	2b00      	cmp	r3, #0
 800cb30:	d19d      	bne.n	800ca6e <HAL_SPI_TransmitReceive+0x252>
    errorcode = HAL_ERROR;
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 800cb32:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cb34:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800cb36:	68fb      	ldr	r3, [r7, #12]
 800cb38:	0018      	movs	r0, r3
 800cb3a:	f000 f89b 	bl	800cc74 <SPI_EndRxTxTransaction>
 800cb3e:	1e03      	subs	r3, r0, #0
 800cb40:	d007      	beq.n	800cb52 <HAL_SPI_TransmitReceive+0x336>
  {
    errorcode = HAL_ERROR;
 800cb42:	232b      	movs	r3, #43	; 0x2b
 800cb44:	18fb      	adds	r3, r7, r3
 800cb46:	2201      	movs	r2, #1
 800cb48:	701a      	strb	r2, [r3, #0]
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 800cb4a:	68fb      	ldr	r3, [r7, #12]
 800cb4c:	2220      	movs	r2, #32
 800cb4e:	655a      	str	r2, [r3, #84]	; 0x54
    goto error;
 800cb50:	e010      	b.n	800cb74 <HAL_SPI_TransmitReceive+0x358>
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800cb52:	68fb      	ldr	r3, [r7, #12]
 800cb54:	689b      	ldr	r3, [r3, #8]
 800cb56:	2b00      	cmp	r3, #0
 800cb58:	d10b      	bne.n	800cb72 <HAL_SPI_TransmitReceive+0x356>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800cb5a:	2300      	movs	r3, #0
 800cb5c:	617b      	str	r3, [r7, #20]
 800cb5e:	68fb      	ldr	r3, [r7, #12]
 800cb60:	681b      	ldr	r3, [r3, #0]
 800cb62:	68db      	ldr	r3, [r3, #12]
 800cb64:	617b      	str	r3, [r7, #20]
 800cb66:	68fb      	ldr	r3, [r7, #12]
 800cb68:	681b      	ldr	r3, [r3, #0]
 800cb6a:	689b      	ldr	r3, [r3, #8]
 800cb6c:	617b      	str	r3, [r7, #20]
 800cb6e:	697b      	ldr	r3, [r7, #20]
 800cb70:	e000      	b.n	800cb74 <HAL_SPI_TransmitReceive+0x358>
  }

error :
 800cb72:	46c0      	nop			; (mov r8, r8)
  hspi->State = HAL_SPI_STATE_READY;
 800cb74:	68fb      	ldr	r3, [r7, #12]
 800cb76:	2251      	movs	r2, #81	; 0x51
 800cb78:	2101      	movs	r1, #1
 800cb7a:	5499      	strb	r1, [r3, r2]
  __HAL_UNLOCK(hspi);
 800cb7c:	68fb      	ldr	r3, [r7, #12]
 800cb7e:	2250      	movs	r2, #80	; 0x50
 800cb80:	2100      	movs	r1, #0
 800cb82:	5499      	strb	r1, [r3, r2]
  return errorcode;
 800cb84:	232b      	movs	r3, #43	; 0x2b
 800cb86:	18fb      	adds	r3, r7, r3
 800cb88:	781b      	ldrb	r3, [r3, #0]
}
 800cb8a:	0018      	movs	r0, r3
 800cb8c:	46bd      	mov	sp, r7
 800cb8e:	b00c      	add	sp, #48	; 0x30
 800cb90:	bd80      	pop	{r7, pc}
	...

0800cb94 <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 800cb94:	b580      	push	{r7, lr}
 800cb96:	b084      	sub	sp, #16
 800cb98:	af00      	add	r7, sp, #0
 800cb9a:	60f8      	str	r0, [r7, #12]
 800cb9c:	60b9      	str	r1, [r7, #8]
 800cb9e:	603b      	str	r3, [r7, #0]
 800cba0:	1dfb      	adds	r3, r7, #7
 800cba2:	701a      	strb	r2, [r3, #0]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800cba4:	e050      	b.n	800cc48 <SPI_WaitFlagStateUntilTimeout+0xb4>
  {
    if (Timeout != HAL_MAX_DELAY)
 800cba6:	683b      	ldr	r3, [r7, #0]
 800cba8:	3301      	adds	r3, #1
 800cbaa:	d04d      	beq.n	800cc48 <SPI_WaitFlagStateUntilTimeout+0xb4>
    {
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 800cbac:	f7fc fac8 	bl	8009140 <HAL_GetTick>
 800cbb0:	0002      	movs	r2, r0
 800cbb2:	69bb      	ldr	r3, [r7, #24]
 800cbb4:	1ad3      	subs	r3, r2, r3
 800cbb6:	683a      	ldr	r2, [r7, #0]
 800cbb8:	429a      	cmp	r2, r3
 800cbba:	d902      	bls.n	800cbc2 <SPI_WaitFlagStateUntilTimeout+0x2e>
 800cbbc:	683b      	ldr	r3, [r7, #0]
 800cbbe:	2b00      	cmp	r3, #0
 800cbc0:	d142      	bne.n	800cc48 <SPI_WaitFlagStateUntilTimeout+0xb4>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800cbc2:	68fb      	ldr	r3, [r7, #12]
 800cbc4:	681b      	ldr	r3, [r3, #0]
 800cbc6:	685a      	ldr	r2, [r3, #4]
 800cbc8:	68fb      	ldr	r3, [r7, #12]
 800cbca:	681b      	ldr	r3, [r3, #0]
 800cbcc:	21e0      	movs	r1, #224	; 0xe0
 800cbce:	438a      	bics	r2, r1
 800cbd0:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800cbd2:	68fb      	ldr	r3, [r7, #12]
 800cbd4:	685a      	ldr	r2, [r3, #4]
 800cbd6:	2382      	movs	r3, #130	; 0x82
 800cbd8:	005b      	lsls	r3, r3, #1
 800cbda:	429a      	cmp	r2, r3
 800cbdc:	d113      	bne.n	800cc06 <SPI_WaitFlagStateUntilTimeout+0x72>
 800cbde:	68fb      	ldr	r3, [r7, #12]
 800cbe0:	689a      	ldr	r2, [r3, #8]
 800cbe2:	2380      	movs	r3, #128	; 0x80
 800cbe4:	021b      	lsls	r3, r3, #8
 800cbe6:	429a      	cmp	r2, r3
 800cbe8:	d005      	beq.n	800cbf6 <SPI_WaitFlagStateUntilTimeout+0x62>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800cbea:	68fb      	ldr	r3, [r7, #12]
 800cbec:	689a      	ldr	r2, [r3, #8]
 800cbee:	2380      	movs	r3, #128	; 0x80
 800cbf0:	00db      	lsls	r3, r3, #3
 800cbf2:	429a      	cmp	r2, r3
 800cbf4:	d107      	bne.n	800cc06 <SPI_WaitFlagStateUntilTimeout+0x72>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800cbf6:	68fb      	ldr	r3, [r7, #12]
 800cbf8:	681b      	ldr	r3, [r3, #0]
 800cbfa:	681a      	ldr	r2, [r3, #0]
 800cbfc:	68fb      	ldr	r3, [r7, #12]
 800cbfe:	681b      	ldr	r3, [r3, #0]
 800cc00:	2140      	movs	r1, #64	; 0x40
 800cc02:	438a      	bics	r2, r1
 800cc04:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800cc06:	68fb      	ldr	r3, [r7, #12]
 800cc08:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800cc0a:	2380      	movs	r3, #128	; 0x80
 800cc0c:	019b      	lsls	r3, r3, #6
 800cc0e:	429a      	cmp	r2, r3
 800cc10:	d110      	bne.n	800cc34 <SPI_WaitFlagStateUntilTimeout+0xa0>
        {
          SPI_RESET_CRC(hspi);
 800cc12:	68fb      	ldr	r3, [r7, #12]
 800cc14:	681b      	ldr	r3, [r3, #0]
 800cc16:	681a      	ldr	r2, [r3, #0]
 800cc18:	68fb      	ldr	r3, [r7, #12]
 800cc1a:	681b      	ldr	r3, [r3, #0]
 800cc1c:	4914      	ldr	r1, [pc, #80]	; (800cc70 <SPI_WaitFlagStateUntilTimeout+0xdc>)
 800cc1e:	400a      	ands	r2, r1
 800cc20:	601a      	str	r2, [r3, #0]
 800cc22:	68fb      	ldr	r3, [r7, #12]
 800cc24:	681b      	ldr	r3, [r3, #0]
 800cc26:	681a      	ldr	r2, [r3, #0]
 800cc28:	68fb      	ldr	r3, [r7, #12]
 800cc2a:	681b      	ldr	r3, [r3, #0]
 800cc2c:	2180      	movs	r1, #128	; 0x80
 800cc2e:	0189      	lsls	r1, r1, #6
 800cc30:	430a      	orrs	r2, r1
 800cc32:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 800cc34:	68fb      	ldr	r3, [r7, #12]
 800cc36:	2251      	movs	r2, #81	; 0x51
 800cc38:	2101      	movs	r1, #1
 800cc3a:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 800cc3c:	68fb      	ldr	r3, [r7, #12]
 800cc3e:	2250      	movs	r2, #80	; 0x50
 800cc40:	2100      	movs	r1, #0
 800cc42:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 800cc44:	2303      	movs	r3, #3
 800cc46:	e00f      	b.n	800cc68 <SPI_WaitFlagStateUntilTimeout+0xd4>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800cc48:	68fb      	ldr	r3, [r7, #12]
 800cc4a:	681b      	ldr	r3, [r3, #0]
 800cc4c:	689b      	ldr	r3, [r3, #8]
 800cc4e:	68ba      	ldr	r2, [r7, #8]
 800cc50:	4013      	ands	r3, r2
 800cc52:	68ba      	ldr	r2, [r7, #8]
 800cc54:	1ad3      	subs	r3, r2, r3
 800cc56:	425a      	negs	r2, r3
 800cc58:	4153      	adcs	r3, r2
 800cc5a:	b2db      	uxtb	r3, r3
 800cc5c:	001a      	movs	r2, r3
 800cc5e:	1dfb      	adds	r3, r7, #7
 800cc60:	781b      	ldrb	r3, [r3, #0]
 800cc62:	429a      	cmp	r2, r3
 800cc64:	d19f      	bne.n	800cba6 <SPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }

  return HAL_OK;
 800cc66:	2300      	movs	r3, #0
}
 800cc68:	0018      	movs	r0, r3
 800cc6a:	46bd      	mov	sp, r7
 800cc6c:	b004      	add	sp, #16
 800cc6e:	bd80      	pop	{r7, pc}
 800cc70:	ffffdfff 	.word	0xffffdfff

0800cc74 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 800cc74:	b580      	push	{r7, lr}
 800cc76:	b086      	sub	sp, #24
 800cc78:	af02      	add	r7, sp, #8
 800cc7a:	60f8      	str	r0, [r7, #12]
 800cc7c:	60b9      	str	r1, [r7, #8]
 800cc7e:	607a      	str	r2, [r7, #4]
  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 800cc80:	68fb      	ldr	r3, [r7, #12]
 800cc82:	685a      	ldr	r2, [r3, #4]
 800cc84:	2382      	movs	r3, #130	; 0x82
 800cc86:	005b      	lsls	r3, r3, #1
 800cc88:	429a      	cmp	r2, r3
 800cc8a:	d112      	bne.n	800ccb2 <SPI_EndRxTxTransaction+0x3e>
  {
    /* Control the BSY flag */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 800cc8c:	68ba      	ldr	r2, [r7, #8]
 800cc8e:	68f8      	ldr	r0, [r7, #12]
 800cc90:	687b      	ldr	r3, [r7, #4]
 800cc92:	9300      	str	r3, [sp, #0]
 800cc94:	0013      	movs	r3, r2
 800cc96:	2200      	movs	r2, #0
 800cc98:	2180      	movs	r1, #128	; 0x80
 800cc9a:	f7ff ff7b 	bl	800cb94 <SPI_WaitFlagStateUntilTimeout>
 800cc9e:	1e03      	subs	r3, r0, #0
 800cca0:	d020      	beq.n	800cce4 <SPI_EndRxTxTransaction+0x70>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800cca2:	68fb      	ldr	r3, [r7, #12]
 800cca4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800cca6:	2220      	movs	r2, #32
 800cca8:	431a      	orrs	r2, r3
 800ccaa:	68fb      	ldr	r3, [r7, #12]
 800ccac:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_TIMEOUT;
 800ccae:	2303      	movs	r3, #3
 800ccb0:	e019      	b.n	800cce6 <SPI_EndRxTxTransaction+0x72>
    }
  }
  else
  {
    /* Control RXNE flag in case of Full-Duplex transfer */
    if (hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
 800ccb2:	68fb      	ldr	r3, [r7, #12]
 800ccb4:	2251      	movs	r2, #81	; 0x51
 800ccb6:	5c9b      	ldrb	r3, [r3, r2]
 800ccb8:	b2db      	uxtb	r3, r3
 800ccba:	2b05      	cmp	r3, #5
 800ccbc:	d112      	bne.n	800cce4 <SPI_EndRxTxTransaction+0x70>
    {
      /* Wait the RXNE reset */
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 800ccbe:	68ba      	ldr	r2, [r7, #8]
 800ccc0:	68f8      	ldr	r0, [r7, #12]
 800ccc2:	687b      	ldr	r3, [r7, #4]
 800ccc4:	9300      	str	r3, [sp, #0]
 800ccc6:	0013      	movs	r3, r2
 800ccc8:	2200      	movs	r2, #0
 800ccca:	2101      	movs	r1, #1
 800cccc:	f7ff ff62 	bl	800cb94 <SPI_WaitFlagStateUntilTimeout>
 800ccd0:	1e03      	subs	r3, r0, #0
 800ccd2:	d007      	beq.n	800cce4 <SPI_EndRxTxTransaction+0x70>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800ccd4:	68fb      	ldr	r3, [r7, #12]
 800ccd6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ccd8:	2220      	movs	r2, #32
 800ccda:	431a      	orrs	r2, r3
 800ccdc:	68fb      	ldr	r3, [r7, #12]
 800ccde:	655a      	str	r2, [r3, #84]	; 0x54
        return HAL_TIMEOUT;
 800cce0:	2303      	movs	r3, #3
 800cce2:	e000      	b.n	800cce6 <SPI_EndRxTxTransaction+0x72>
      }
    }
  }
  return HAL_OK;
 800cce4:	2300      	movs	r3, #0
}
 800cce6:	0018      	movs	r0, r3
 800cce8:	46bd      	mov	sp, r7
 800ccea:	b004      	add	sp, #16
 800ccec:	bd80      	pop	{r7, pc}
	...

0800ccf0 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800ccf0:	b580      	push	{r7, lr}
 800ccf2:	b082      	sub	sp, #8
 800ccf4:	af00      	add	r7, sp, #0
 800ccf6:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 800ccf8:	687b      	ldr	r3, [r7, #4]
 800ccfa:	2b00      	cmp	r3, #0
 800ccfc:	d101      	bne.n	800cd02 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800ccfe:	2301      	movs	r3, #1
 800cd00:	e044      	b.n	800cd8c <HAL_UART_Init+0x9c>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 800cd02:	687b      	ldr	r3, [r7, #4]
 800cd04:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800cd06:	2b00      	cmp	r3, #0
 800cd08:	d107      	bne.n	800cd1a <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800cd0a:	687b      	ldr	r3, [r7, #4]
 800cd0c:	2270      	movs	r2, #112	; 0x70
 800cd0e:	2100      	movs	r1, #0
 800cd10:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800cd12:	687b      	ldr	r3, [r7, #4]
 800cd14:	0018      	movs	r0, r3
 800cd16:	f010 fb3f 	bl	801d398 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800cd1a:	687b      	ldr	r3, [r7, #4]
 800cd1c:	2224      	movs	r2, #36	; 0x24
 800cd1e:	675a      	str	r2, [r3, #116]	; 0x74

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 800cd20:	687b      	ldr	r3, [r7, #4]
 800cd22:	681b      	ldr	r3, [r3, #0]
 800cd24:	681a      	ldr	r2, [r3, #0]
 800cd26:	687b      	ldr	r3, [r7, #4]
 800cd28:	681b      	ldr	r3, [r3, #0]
 800cd2a:	2101      	movs	r1, #1
 800cd2c:	438a      	bics	r2, r1
 800cd2e:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 800cd30:	687b      	ldr	r3, [r7, #4]
 800cd32:	0018      	movs	r0, r3
 800cd34:	f000 f9f4 	bl	800d120 <UART_SetConfig>
 800cd38:	0003      	movs	r3, r0
 800cd3a:	2b01      	cmp	r3, #1
 800cd3c:	d101      	bne.n	800cd42 <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 800cd3e:	2301      	movs	r3, #1
 800cd40:	e024      	b.n	800cd8c <HAL_UART_Init+0x9c>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800cd42:	687b      	ldr	r3, [r7, #4]
 800cd44:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800cd46:	2b00      	cmp	r3, #0
 800cd48:	d003      	beq.n	800cd52 <HAL_UART_Init+0x62>
  {
    UART_AdvFeatureConfig(huart);
 800cd4a:	687b      	ldr	r3, [r7, #4]
 800cd4c:	0018      	movs	r0, r3
 800cd4e:	f000 fd1d 	bl	800d78c <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800cd52:	687b      	ldr	r3, [r7, #4]
 800cd54:	681b      	ldr	r3, [r3, #0]
 800cd56:	685a      	ldr	r2, [r3, #4]
 800cd58:	687b      	ldr	r3, [r7, #4]
 800cd5a:	681b      	ldr	r3, [r3, #0]
 800cd5c:	490d      	ldr	r1, [pc, #52]	; (800cd94 <HAL_UART_Init+0xa4>)
 800cd5e:	400a      	ands	r2, r1
 800cd60:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800cd62:	687b      	ldr	r3, [r7, #4]
 800cd64:	681b      	ldr	r3, [r3, #0]
 800cd66:	689a      	ldr	r2, [r3, #8]
 800cd68:	687b      	ldr	r3, [r7, #4]
 800cd6a:	681b      	ldr	r3, [r3, #0]
 800cd6c:	212a      	movs	r1, #42	; 0x2a
 800cd6e:	438a      	bics	r2, r1
 800cd70:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 800cd72:	687b      	ldr	r3, [r7, #4]
 800cd74:	681b      	ldr	r3, [r3, #0]
 800cd76:	681a      	ldr	r2, [r3, #0]
 800cd78:	687b      	ldr	r3, [r7, #4]
 800cd7a:	681b      	ldr	r3, [r3, #0]
 800cd7c:	2101      	movs	r1, #1
 800cd7e:	430a      	orrs	r2, r1
 800cd80:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 800cd82:	687b      	ldr	r3, [r7, #4]
 800cd84:	0018      	movs	r0, r3
 800cd86:	f000 fdb5 	bl	800d8f4 <UART_CheckIdleState>
 800cd8a:	0003      	movs	r3, r0
}
 800cd8c:	0018      	movs	r0, r3
 800cd8e:	46bd      	mov	sp, r7
 800cd90:	b002      	add	sp, #8
 800cd92:	bd80      	pop	{r7, pc}
 800cd94:	ffffb7ff 	.word	0xffffb7ff

0800cd98 <HAL_UART_Transmit_DMA>:
  * @param pData Pointer to data buffer.
  * @param Size  Amount of data to be sent.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 800cd98:	b580      	push	{r7, lr}
 800cd9a:	b084      	sub	sp, #16
 800cd9c:	af00      	add	r7, sp, #0
 800cd9e:	60f8      	str	r0, [r7, #12]
 800cda0:	60b9      	str	r1, [r7, #8]
 800cda2:	1dbb      	adds	r3, r7, #6
 800cda4:	801a      	strh	r2, [r3, #0]
  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800cda6:	68fb      	ldr	r3, [r7, #12]
 800cda8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800cdaa:	2b20      	cmp	r3, #32
 800cdac:	d000      	beq.n	800cdb0 <HAL_UART_Transmit_DMA+0x18>
 800cdae:	e077      	b.n	800cea0 <HAL_UART_Transmit_DMA+0x108>
  {
    if ((pData == NULL) || (Size == 0U))
 800cdb0:	68bb      	ldr	r3, [r7, #8]
 800cdb2:	2b00      	cmp	r3, #0
 800cdb4:	d003      	beq.n	800cdbe <HAL_UART_Transmit_DMA+0x26>
 800cdb6:	1dbb      	adds	r3, r7, #6
 800cdb8:	881b      	ldrh	r3, [r3, #0]
 800cdba:	2b00      	cmp	r3, #0
 800cdbc:	d101      	bne.n	800cdc2 <HAL_UART_Transmit_DMA+0x2a>
    {
      return HAL_ERROR;
 800cdbe:	2301      	movs	r3, #1
 800cdc0:	e06f      	b.n	800cea2 <HAL_UART_Transmit_DMA+0x10a>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data copy into TDR will be
       handled by DMA from a u16 frontier. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800cdc2:	68fb      	ldr	r3, [r7, #12]
 800cdc4:	689a      	ldr	r2, [r3, #8]
 800cdc6:	2380      	movs	r3, #128	; 0x80
 800cdc8:	015b      	lsls	r3, r3, #5
 800cdca:	429a      	cmp	r2, r3
 800cdcc:	d109      	bne.n	800cde2 <HAL_UART_Transmit_DMA+0x4a>
 800cdce:	68fb      	ldr	r3, [r7, #12]
 800cdd0:	691b      	ldr	r3, [r3, #16]
 800cdd2:	2b00      	cmp	r3, #0
 800cdd4:	d105      	bne.n	800cde2 <HAL_UART_Transmit_DMA+0x4a>
    {
      if ((((uint32_t)pData) & 1) != 0)
 800cdd6:	68bb      	ldr	r3, [r7, #8]
 800cdd8:	2201      	movs	r2, #1
 800cdda:	4013      	ands	r3, r2
 800cddc:	d001      	beq.n	800cde2 <HAL_UART_Transmit_DMA+0x4a>
      {
        return  HAL_ERROR;
 800cdde:	2301      	movs	r3, #1
 800cde0:	e05f      	b.n	800cea2 <HAL_UART_Transmit_DMA+0x10a>
      }
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 800cde2:	68fb      	ldr	r3, [r7, #12]
 800cde4:	2270      	movs	r2, #112	; 0x70
 800cde6:	5c9b      	ldrb	r3, [r3, r2]
 800cde8:	2b01      	cmp	r3, #1
 800cdea:	d101      	bne.n	800cdf0 <HAL_UART_Transmit_DMA+0x58>
 800cdec:	2302      	movs	r3, #2
 800cdee:	e058      	b.n	800cea2 <HAL_UART_Transmit_DMA+0x10a>
 800cdf0:	68fb      	ldr	r3, [r7, #12]
 800cdf2:	2270      	movs	r2, #112	; 0x70
 800cdf4:	2101      	movs	r1, #1
 800cdf6:	5499      	strb	r1, [r3, r2]

    huart->pTxBuffPtr  = pData;
 800cdf8:	68fb      	ldr	r3, [r7, #12]
 800cdfa:	68ba      	ldr	r2, [r7, #8]
 800cdfc:	64da      	str	r2, [r3, #76]	; 0x4c
    huart->TxXferSize  = Size;
 800cdfe:	68fb      	ldr	r3, [r7, #12]
 800ce00:	1dba      	adds	r2, r7, #6
 800ce02:	2150      	movs	r1, #80	; 0x50
 800ce04:	8812      	ldrh	r2, [r2, #0]
 800ce06:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
 800ce08:	68fb      	ldr	r3, [r7, #12]
 800ce0a:	1dba      	adds	r2, r7, #6
 800ce0c:	2152      	movs	r1, #82	; 0x52
 800ce0e:	8812      	ldrh	r2, [r2, #0]
 800ce10:	525a      	strh	r2, [r3, r1]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800ce12:	68fb      	ldr	r3, [r7, #12]
 800ce14:	2200      	movs	r2, #0
 800ce16:	67da      	str	r2, [r3, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800ce18:	68fb      	ldr	r3, [r7, #12]
 800ce1a:	2221      	movs	r2, #33	; 0x21
 800ce1c:	675a      	str	r2, [r3, #116]	; 0x74

    if (huart->hdmatx != NULL)
 800ce1e:	68fb      	ldr	r3, [r7, #12]
 800ce20:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ce22:	2b00      	cmp	r3, #0
 800ce24:	d02a      	beq.n	800ce7c <HAL_UART_Transmit_DMA+0xe4>
    {
      /* Set the UART DMA transfer complete callback */
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 800ce26:	68fb      	ldr	r3, [r7, #12]
 800ce28:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ce2a:	4a20      	ldr	r2, [pc, #128]	; (800ceac <HAL_UART_Transmit_DMA+0x114>)
 800ce2c:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Set the UART DMA Half transfer complete callback */
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 800ce2e:	68fb      	ldr	r3, [r7, #12]
 800ce30:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ce32:	4a1f      	ldr	r2, [pc, #124]	; (800ceb0 <HAL_UART_Transmit_DMA+0x118>)
 800ce34:	631a      	str	r2, [r3, #48]	; 0x30

      /* Set the DMA error callback */
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 800ce36:	68fb      	ldr	r3, [r7, #12]
 800ce38:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ce3a:	4a1e      	ldr	r2, [pc, #120]	; (800ceb4 <HAL_UART_Transmit_DMA+0x11c>)
 800ce3c:	635a      	str	r2, [r3, #52]	; 0x34

      /* Set the DMA abort callback */
      huart->hdmatx->XferAbortCallback = NULL;
 800ce3e:	68fb      	ldr	r3, [r7, #12]
 800ce40:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ce42:	2200      	movs	r2, #0
 800ce44:	639a      	str	r2, [r3, #56]	; 0x38

      /* Enable the UART transmit DMA channel */
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 800ce46:	68fb      	ldr	r3, [r7, #12]
 800ce48:	6e98      	ldr	r0, [r3, #104]	; 0x68
 800ce4a:	68fb      	ldr	r3, [r7, #12]
 800ce4c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800ce4e:	0019      	movs	r1, r3
 800ce50:	68fb      	ldr	r3, [r7, #12]
 800ce52:	681b      	ldr	r3, [r3, #0]
 800ce54:	3328      	adds	r3, #40	; 0x28
 800ce56:	001a      	movs	r2, r3
 800ce58:	1dbb      	adds	r3, r7, #6
 800ce5a:	881b      	ldrh	r3, [r3, #0]
 800ce5c:	f7fc fed8 	bl	8009c10 <HAL_DMA_Start_IT>
 800ce60:	1e03      	subs	r3, r0, #0
 800ce62:	d00b      	beq.n	800ce7c <HAL_UART_Transmit_DMA+0xe4>
      {
        /* Set error code to DMA */
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 800ce64:	68fb      	ldr	r3, [r7, #12]
 800ce66:	2210      	movs	r2, #16
 800ce68:	67da      	str	r2, [r3, #124]	; 0x7c

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 800ce6a:	68fb      	ldr	r3, [r7, #12]
 800ce6c:	2270      	movs	r2, #112	; 0x70
 800ce6e:	2100      	movs	r1, #0
 800ce70:	5499      	strb	r1, [r3, r2]

        /* Restore huart->gState to ready */
        huart->gState = HAL_UART_STATE_READY;
 800ce72:	68fb      	ldr	r3, [r7, #12]
 800ce74:	2220      	movs	r2, #32
 800ce76:	675a      	str	r2, [r3, #116]	; 0x74

        return HAL_ERROR;
 800ce78:	2301      	movs	r3, #1
 800ce7a:	e012      	b.n	800cea2 <HAL_UART_Transmit_DMA+0x10a>
      }
    }
    /* Clear the TC flag in the ICR register */
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 800ce7c:	68fb      	ldr	r3, [r7, #12]
 800ce7e:	681b      	ldr	r3, [r3, #0]
 800ce80:	2240      	movs	r2, #64	; 0x40
 800ce82:	621a      	str	r2, [r3, #32]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 800ce84:	68fb      	ldr	r3, [r7, #12]
 800ce86:	2270      	movs	r2, #112	; 0x70
 800ce88:	2100      	movs	r1, #0
 800ce8a:	5499      	strb	r1, [r3, r2]

    /* Enable the DMA transfer for transmit request by setting the DMAT bit
    in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800ce8c:	68fb      	ldr	r3, [r7, #12]
 800ce8e:	681b      	ldr	r3, [r3, #0]
 800ce90:	689a      	ldr	r2, [r3, #8]
 800ce92:	68fb      	ldr	r3, [r7, #12]
 800ce94:	681b      	ldr	r3, [r3, #0]
 800ce96:	2180      	movs	r1, #128	; 0x80
 800ce98:	430a      	orrs	r2, r1
 800ce9a:	609a      	str	r2, [r3, #8]

    return HAL_OK;
 800ce9c:	2300      	movs	r3, #0
 800ce9e:	e000      	b.n	800cea2 <HAL_UART_Transmit_DMA+0x10a>
  }
  else
  {
    return HAL_BUSY;
 800cea0:	2302      	movs	r3, #2
  }
}
 800cea2:	0018      	movs	r0, r3
 800cea4:	46bd      	mov	sp, r7
 800cea6:	b004      	add	sp, #16
 800cea8:	bd80      	pop	{r7, pc}
 800ceaa:	46c0      	nop			; (mov r8, r8)
 800ceac:	0800da79 	.word	0x0800da79
 800ceb0:	0800dacd 	.word	0x0800dacd
 800ceb4:	0800daeb 	.word	0x0800daeb

0800ceb8 <HAL_UART_IRQHandler>:
  * @brief Handle UART interrupt request.
  * @param huart UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 800ceb8:	b580      	push	{r7, lr}
 800ceba:	b088      	sub	sp, #32
 800cebc:	af00      	add	r7, sp, #0
 800cebe:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 800cec0:	687b      	ldr	r3, [r7, #4]
 800cec2:	681b      	ldr	r3, [r3, #0]
 800cec4:	69db      	ldr	r3, [r3, #28]
 800cec6:	61fb      	str	r3, [r7, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 800cec8:	687b      	ldr	r3, [r7, #4]
 800ceca:	681b      	ldr	r3, [r3, #0]
 800cecc:	681b      	ldr	r3, [r3, #0]
 800cece:	61bb      	str	r3, [r7, #24]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 800ced0:	687b      	ldr	r3, [r7, #4]
 800ced2:	681b      	ldr	r3, [r3, #0]
 800ced4:	689b      	ldr	r3, [r3, #8]
 800ced6:	617b      	str	r3, [r7, #20]

  uint32_t errorflags;
  uint32_t errorcode;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
 800ced8:	69fb      	ldr	r3, [r7, #28]
 800ceda:	220f      	movs	r2, #15
 800cedc:	4013      	ands	r3, r2
 800cede:	613b      	str	r3, [r7, #16]
  if (errorflags == 0U)
 800cee0:	693b      	ldr	r3, [r7, #16]
 800cee2:	2b00      	cmp	r3, #0
 800cee4:	d112      	bne.n	800cf0c <HAL_UART_IRQHandler+0x54>
  {
    /* UART in mode Receiver ---------------------------------------------------*/
    if (((isrflags & USART_ISR_RXNE) != 0U)
 800cee6:	69fb      	ldr	r3, [r7, #28]
 800cee8:	2220      	movs	r2, #32
 800ceea:	4013      	ands	r3, r2
 800ceec:	d00e      	beq.n	800cf0c <HAL_UART_IRQHandler+0x54>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 800ceee:	69bb      	ldr	r3, [r7, #24]
 800cef0:	2220      	movs	r2, #32
 800cef2:	4013      	ands	r3, r2
 800cef4:	d00a      	beq.n	800cf0c <HAL_UART_IRQHandler+0x54>
    {
      if (huart->RxISR != NULL)
 800cef6:	687b      	ldr	r3, [r7, #4]
 800cef8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800cefa:	2b00      	cmp	r3, #0
 800cefc:	d100      	bne.n	800cf00 <HAL_UART_IRQHandler+0x48>
 800cefe:	e0f5      	b.n	800d0ec <HAL_UART_IRQHandler+0x234>
      {
        huart->RxISR(huart);
 800cf00:	687b      	ldr	r3, [r7, #4]
 800cf02:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800cf04:	687a      	ldr	r2, [r7, #4]
 800cf06:	0010      	movs	r0, r2
 800cf08:	4798      	blx	r3
      }
      return;
 800cf0a:	e0ef      	b.n	800d0ec <HAL_UART_IRQHandler+0x234>
    }
  }

  /* If some errors occur */
  if ((errorflags != 0U)
 800cf0c:	693b      	ldr	r3, [r7, #16]
 800cf0e:	2b00      	cmp	r3, #0
 800cf10:	d100      	bne.n	800cf14 <HAL_UART_IRQHandler+0x5c>
 800cf12:	e0b8      	b.n	800d086 <HAL_UART_IRQHandler+0x1ce>
      && (((cr3its & USART_CR3_EIE) != 0U)
 800cf14:	697b      	ldr	r3, [r7, #20]
 800cf16:	2201      	movs	r2, #1
 800cf18:	4013      	ands	r3, r2
 800cf1a:	d105      	bne.n	800cf28 <HAL_UART_IRQHandler+0x70>
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != 0U)))
 800cf1c:	69ba      	ldr	r2, [r7, #24]
 800cf1e:	2390      	movs	r3, #144	; 0x90
 800cf20:	005b      	lsls	r3, r3, #1
 800cf22:	4013      	ands	r3, r2
 800cf24:	d100      	bne.n	800cf28 <HAL_UART_IRQHandler+0x70>
 800cf26:	e0ae      	b.n	800d086 <HAL_UART_IRQHandler+0x1ce>
  {
    /* UART parity error interrupt occurred -------------------------------------*/
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 800cf28:	69fb      	ldr	r3, [r7, #28]
 800cf2a:	2201      	movs	r2, #1
 800cf2c:	4013      	ands	r3, r2
 800cf2e:	d00e      	beq.n	800cf4e <HAL_UART_IRQHandler+0x96>
 800cf30:	69ba      	ldr	r2, [r7, #24]
 800cf32:	2380      	movs	r3, #128	; 0x80
 800cf34:	005b      	lsls	r3, r3, #1
 800cf36:	4013      	ands	r3, r2
 800cf38:	d009      	beq.n	800cf4e <HAL_UART_IRQHandler+0x96>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 800cf3a:	687b      	ldr	r3, [r7, #4]
 800cf3c:	681b      	ldr	r3, [r3, #0]
 800cf3e:	2201      	movs	r2, #1
 800cf40:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_PE;
 800cf42:	687b      	ldr	r3, [r7, #4]
 800cf44:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cf46:	2201      	movs	r2, #1
 800cf48:	431a      	orrs	r2, r3
 800cf4a:	687b      	ldr	r3, [r7, #4]
 800cf4c:	67da      	str	r2, [r3, #124]	; 0x7c
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800cf4e:	69fb      	ldr	r3, [r7, #28]
 800cf50:	2202      	movs	r2, #2
 800cf52:	4013      	ands	r3, r2
 800cf54:	d00d      	beq.n	800cf72 <HAL_UART_IRQHandler+0xba>
 800cf56:	697b      	ldr	r3, [r7, #20]
 800cf58:	2201      	movs	r2, #1
 800cf5a:	4013      	ands	r3, r2
 800cf5c:	d009      	beq.n	800cf72 <HAL_UART_IRQHandler+0xba>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 800cf5e:	687b      	ldr	r3, [r7, #4]
 800cf60:	681b      	ldr	r3, [r3, #0]
 800cf62:	2202      	movs	r2, #2
 800cf64:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_FE;
 800cf66:	687b      	ldr	r3, [r7, #4]
 800cf68:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cf6a:	2204      	movs	r2, #4
 800cf6c:	431a      	orrs	r2, r3
 800cf6e:	687b      	ldr	r3, [r7, #4]
 800cf70:	67da      	str	r2, [r3, #124]	; 0x7c
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800cf72:	69fb      	ldr	r3, [r7, #28]
 800cf74:	2204      	movs	r2, #4
 800cf76:	4013      	ands	r3, r2
 800cf78:	d00d      	beq.n	800cf96 <HAL_UART_IRQHandler+0xde>
 800cf7a:	697b      	ldr	r3, [r7, #20]
 800cf7c:	2201      	movs	r2, #1
 800cf7e:	4013      	ands	r3, r2
 800cf80:	d009      	beq.n	800cf96 <HAL_UART_IRQHandler+0xde>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 800cf82:	687b      	ldr	r3, [r7, #4]
 800cf84:	681b      	ldr	r3, [r3, #0]
 800cf86:	2204      	movs	r2, #4
 800cf88:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_NE;
 800cf8a:	687b      	ldr	r3, [r7, #4]
 800cf8c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cf8e:	2202      	movs	r2, #2
 800cf90:	431a      	orrs	r2, r3
 800cf92:	687b      	ldr	r3, [r7, #4]
 800cf94:	67da      	str	r2, [r3, #124]	; 0x7c
    }

    /* UART Over-Run interrupt occurred -----------------------------------------*/
    if (((isrflags & USART_ISR_ORE) != 0U)
 800cf96:	69fb      	ldr	r3, [r7, #28]
 800cf98:	2208      	movs	r2, #8
 800cf9a:	4013      	ands	r3, r2
 800cf9c:	d011      	beq.n	800cfc2 <HAL_UART_IRQHandler+0x10a>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 800cf9e:	69bb      	ldr	r3, [r7, #24]
 800cfa0:	2220      	movs	r2, #32
 800cfa2:	4013      	ands	r3, r2
 800cfa4:	d103      	bne.n	800cfae <HAL_UART_IRQHandler+0xf6>
            ((cr3its & USART_CR3_EIE) != 0U)))
 800cfa6:	697b      	ldr	r3, [r7, #20]
 800cfa8:	2201      	movs	r2, #1
 800cfaa:	4013      	ands	r3, r2
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 800cfac:	d009      	beq.n	800cfc2 <HAL_UART_IRQHandler+0x10a>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800cfae:	687b      	ldr	r3, [r7, #4]
 800cfb0:	681b      	ldr	r3, [r3, #0]
 800cfb2:	2208      	movs	r2, #8
 800cfb4:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 800cfb6:	687b      	ldr	r3, [r7, #4]
 800cfb8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cfba:	2208      	movs	r2, #8
 800cfbc:	431a      	orrs	r2, r3
 800cfbe:	687b      	ldr	r3, [r7, #4]
 800cfc0:	67da      	str	r2, [r3, #124]	; 0x7c
    }

    /* Call UART Error Call back function if need be --------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800cfc2:	687b      	ldr	r3, [r7, #4]
 800cfc4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cfc6:	2b00      	cmp	r3, #0
 800cfc8:	d100      	bne.n	800cfcc <HAL_UART_IRQHandler+0x114>
 800cfca:	e091      	b.n	800d0f0 <HAL_UART_IRQHandler+0x238>
    {
      /* UART in mode Receiver ---------------------------------------------------*/
      if (((isrflags & USART_ISR_RXNE) != 0U)
 800cfcc:	69fb      	ldr	r3, [r7, #28]
 800cfce:	2220      	movs	r2, #32
 800cfd0:	4013      	ands	r3, r2
 800cfd2:	d00c      	beq.n	800cfee <HAL_UART_IRQHandler+0x136>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 800cfd4:	69bb      	ldr	r3, [r7, #24]
 800cfd6:	2220      	movs	r2, #32
 800cfd8:	4013      	ands	r3, r2
 800cfda:	d008      	beq.n	800cfee <HAL_UART_IRQHandler+0x136>
      {
        if (huart->RxISR != NULL)
 800cfdc:	687b      	ldr	r3, [r7, #4]
 800cfde:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800cfe0:	2b00      	cmp	r3, #0
 800cfe2:	d004      	beq.n	800cfee <HAL_UART_IRQHandler+0x136>
        {
          huart->RxISR(huart);
 800cfe4:	687b      	ldr	r3, [r7, #4]
 800cfe6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800cfe8:	687a      	ldr	r2, [r7, #4]
 800cfea:	0010      	movs	r0, r2
 800cfec:	4798      	blx	r3
        }
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      errorcode = huart->ErrorCode;
 800cfee:	687b      	ldr	r3, [r7, #4]
 800cff0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cff2:	60fb      	str	r3, [r7, #12]
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800cff4:	687b      	ldr	r3, [r7, #4]
 800cff6:	681b      	ldr	r3, [r3, #0]
 800cff8:	689b      	ldr	r3, [r3, #8]
 800cffa:	2240      	movs	r2, #64	; 0x40
 800cffc:	4013      	ands	r3, r2
 800cffe:	2b40      	cmp	r3, #64	; 0x40
 800d000:	d003      	beq.n	800d00a <HAL_UART_IRQHandler+0x152>
          ((errorcode & HAL_UART_ERROR_ORE) != 0U))
 800d002:	68fb      	ldr	r3, [r7, #12]
 800d004:	2208      	movs	r2, #8
 800d006:	4013      	ands	r3, r2
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800d008:	d033      	beq.n	800d072 <HAL_UART_IRQHandler+0x1ba>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 800d00a:	687b      	ldr	r3, [r7, #4]
 800d00c:	0018      	movs	r0, r3
 800d00e:	f000 fd13 	bl	800da38 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800d012:	687b      	ldr	r3, [r7, #4]
 800d014:	681b      	ldr	r3, [r3, #0]
 800d016:	689b      	ldr	r3, [r3, #8]
 800d018:	2240      	movs	r2, #64	; 0x40
 800d01a:	4013      	ands	r3, r2
 800d01c:	2b40      	cmp	r3, #64	; 0x40
 800d01e:	d123      	bne.n	800d068 <HAL_UART_IRQHandler+0x1b0>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800d020:	687b      	ldr	r3, [r7, #4]
 800d022:	681b      	ldr	r3, [r3, #0]
 800d024:	689a      	ldr	r2, [r3, #8]
 800d026:	687b      	ldr	r3, [r7, #4]
 800d028:	681b      	ldr	r3, [r3, #0]
 800d02a:	2140      	movs	r1, #64	; 0x40
 800d02c:	438a      	bics	r2, r1
 800d02e:	609a      	str	r2, [r3, #8]

          /* Abort the UART DMA Rx channel */
          if (huart->hdmarx != NULL)
 800d030:	687b      	ldr	r3, [r7, #4]
 800d032:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d034:	2b00      	cmp	r3, #0
 800d036:	d012      	beq.n	800d05e <HAL_UART_IRQHandler+0x1a6>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 800d038:	687b      	ldr	r3, [r7, #4]
 800d03a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d03c:	4a2f      	ldr	r2, [pc, #188]	; (800d0fc <HAL_UART_IRQHandler+0x244>)
 800d03e:	639a      	str	r2, [r3, #56]	; 0x38

            /* Abort DMA RX */
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800d040:	687b      	ldr	r3, [r7, #4]
 800d042:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d044:	0018      	movs	r0, r3
 800d046:	f7fc fe49 	bl	8009cdc <HAL_DMA_Abort_IT>
 800d04a:	1e03      	subs	r3, r0, #0
 800d04c:	d019      	beq.n	800d082 <HAL_UART_IRQHandler+0x1ca>
            {
              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800d04e:	687b      	ldr	r3, [r7, #4]
 800d050:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d052:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800d054:	687b      	ldr	r3, [r7, #4]
 800d056:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800d058:	0018      	movs	r0, r3
 800d05a:	4790      	blx	r2
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800d05c:	e011      	b.n	800d082 <HAL_UART_IRQHandler+0x1ca>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 800d05e:	687b      	ldr	r3, [r7, #4]
 800d060:	0018      	movs	r0, r3
 800d062:	f000 f855 	bl	800d110 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800d066:	e00c      	b.n	800d082 <HAL_UART_IRQHandler+0x1ca>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 800d068:	687b      	ldr	r3, [r7, #4]
 800d06a:	0018      	movs	r0, r3
 800d06c:	f000 f850 	bl	800d110 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800d070:	e007      	b.n	800d082 <HAL_UART_IRQHandler+0x1ca>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 800d072:	687b      	ldr	r3, [r7, #4]
 800d074:	0018      	movs	r0, r3
 800d076:	f000 f84b 	bl	800d110 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d07a:	687b      	ldr	r3, [r7, #4]
 800d07c:	2200      	movs	r2, #0
 800d07e:	67da      	str	r2, [r3, #124]	; 0x7c
      }
    }
    return;
 800d080:	e036      	b.n	800d0f0 <HAL_UART_IRQHandler+0x238>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800d082:	46c0      	nop			; (mov r8, r8)
    return;
 800d084:	e034      	b.n	800d0f0 <HAL_UART_IRQHandler+0x238>

  } /* End if some error occurs */

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 800d086:	69fa      	ldr	r2, [r7, #28]
 800d088:	2380      	movs	r3, #128	; 0x80
 800d08a:	035b      	lsls	r3, r3, #13
 800d08c:	4013      	ands	r3, r2
 800d08e:	d00e      	beq.n	800d0ae <HAL_UART_IRQHandler+0x1f6>
 800d090:	697a      	ldr	r2, [r7, #20]
 800d092:	2380      	movs	r3, #128	; 0x80
 800d094:	03db      	lsls	r3, r3, #15
 800d096:	4013      	ands	r3, r2
 800d098:	d009      	beq.n	800d0ae <HAL_UART_IRQHandler+0x1f6>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 800d09a:	687b      	ldr	r3, [r7, #4]
 800d09c:	681b      	ldr	r3, [r3, #0]
 800d09e:	2280      	movs	r2, #128	; 0x80
 800d0a0:	0352      	lsls	r2, r2, #13
 800d0a2:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Wakeup Callback */
    huart->WakeupCallback(huart);
#else
    /* Call legacy weak Wakeup Callback */
    HAL_UARTEx_WakeupCallback(huart);
 800d0a4:	687b      	ldr	r3, [r7, #4]
 800d0a6:	0018      	movs	r0, r3
 800d0a8:	f000 fd8f 	bl	800dbca <HAL_UARTEx_WakeupCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 800d0ac:	e023      	b.n	800d0f6 <HAL_UART_IRQHandler+0x23e>
  }

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_ISR_TXE) != 0U)
 800d0ae:	69fb      	ldr	r3, [r7, #28]
 800d0b0:	2280      	movs	r2, #128	; 0x80
 800d0b2:	4013      	ands	r3, r2
 800d0b4:	d00d      	beq.n	800d0d2 <HAL_UART_IRQHandler+0x21a>
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 800d0b6:	69bb      	ldr	r3, [r7, #24]
 800d0b8:	2280      	movs	r2, #128	; 0x80
 800d0ba:	4013      	ands	r3, r2
 800d0bc:	d009      	beq.n	800d0d2 <HAL_UART_IRQHandler+0x21a>
  {
    if (huart->TxISR != NULL)
 800d0be:	687b      	ldr	r3, [r7, #4]
 800d0c0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800d0c2:	2b00      	cmp	r3, #0
 800d0c4:	d016      	beq.n	800d0f4 <HAL_UART_IRQHandler+0x23c>
    {
      huart->TxISR(huart);
 800d0c6:	687b      	ldr	r3, [r7, #4]
 800d0c8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800d0ca:	687a      	ldr	r2, [r7, #4]
 800d0cc:	0010      	movs	r0, r2
 800d0ce:	4798      	blx	r3
    }
    return;
 800d0d0:	e010      	b.n	800d0f4 <HAL_UART_IRQHandler+0x23c>
  }

  /* UART in mode Transmitter (transmission end) -----------------------------*/
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 800d0d2:	69fb      	ldr	r3, [r7, #28]
 800d0d4:	2240      	movs	r2, #64	; 0x40
 800d0d6:	4013      	ands	r3, r2
 800d0d8:	d00d      	beq.n	800d0f6 <HAL_UART_IRQHandler+0x23e>
 800d0da:	69bb      	ldr	r3, [r7, #24]
 800d0dc:	2240      	movs	r2, #64	; 0x40
 800d0de:	4013      	ands	r3, r2
 800d0e0:	d009      	beq.n	800d0f6 <HAL_UART_IRQHandler+0x23e>
  {
    UART_EndTransmit_IT(huart);
 800d0e2:	687b      	ldr	r3, [r7, #4]
 800d0e4:	0018      	movs	r0, r3
 800d0e6:	f000 fd56 	bl	800db96 <UART_EndTransmit_IT>
    return;
 800d0ea:	e004      	b.n	800d0f6 <HAL_UART_IRQHandler+0x23e>
      return;
 800d0ec:	46c0      	nop			; (mov r8, r8)
 800d0ee:	e002      	b.n	800d0f6 <HAL_UART_IRQHandler+0x23e>
    return;
 800d0f0:	46c0      	nop			; (mov r8, r8)
 800d0f2:	e000      	b.n	800d0f6 <HAL_UART_IRQHandler+0x23e>
    return;
 800d0f4:	46c0      	nop			; (mov r8, r8)
  }

}
 800d0f6:	46bd      	mov	sp, r7
 800d0f8:	b008      	add	sp, #32
 800d0fa:	bd80      	pop	{r7, pc}
 800d0fc:	0800db69 	.word	0x0800db69

0800d100 <HAL_UART_TxHalfCpltCallback>:
  * @brief  Tx Half Transfer completed callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 800d100:	b580      	push	{r7, lr}
 800d102:	b082      	sub	sp, #8
 800d104:	af00      	add	r7, sp, #0
 800d106:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_TxHalfCpltCallback can be implemented in the user file.
   */
}
 800d108:	46c0      	nop			; (mov r8, r8)
 800d10a:	46bd      	mov	sp, r7
 800d10c:	b002      	add	sp, #8
 800d10e:	bd80      	pop	{r7, pc}

0800d110 <HAL_UART_ErrorCallback>:
  * @brief  UART error callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 800d110:	b580      	push	{r7, lr}
 800d112:	b082      	sub	sp, #8
 800d114:	af00      	add	r7, sp, #0
 800d116:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file.
   */
}
 800d118:	46c0      	nop			; (mov r8, r8)
 800d11a:	46bd      	mov	sp, r7
 800d11c:	b002      	add	sp, #8
 800d11e:	bd80      	pop	{r7, pc}

0800d120 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 800d120:	b5b0      	push	{r4, r5, r7, lr}
 800d122:	b08e      	sub	sp, #56	; 0x38
 800d124:	af00      	add	r7, sp, #0
 800d126:	61f8      	str	r0, [r7, #28]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
 800d128:	231b      	movs	r3, #27
 800d12a:	2218      	movs	r2, #24
 800d12c:	4694      	mov	ip, r2
 800d12e:	44bc      	add	ip, r7
 800d130:	4463      	add	r3, ip
 800d132:	2210      	movs	r2, #16
 800d134:	701a      	strb	r2, [r3, #0]
  uint32_t usartdiv                   = 0x00000000U;
 800d136:	2300      	movs	r3, #0
 800d138:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_StatusTypeDef ret               = HAL_OK;
 800d13a:	2313      	movs	r3, #19
 800d13c:	2218      	movs	r2, #24
 800d13e:	4694      	mov	ip, r2
 800d140:	44bc      	add	ip, r7
 800d142:	4463      	add	r3, ip
 800d144:	2200      	movs	r2, #0
 800d146:	701a      	strb	r2, [r3, #0]
  uint32_t lpuart_ker_ck_pres         = 0x00000000U;
 800d148:	2300      	movs	r3, #0
 800d14a:	627b      	str	r3, [r7, #36]	; 0x24
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800d14c:	69fb      	ldr	r3, [r7, #28]
 800d14e:	689a      	ldr	r2, [r3, #8]
 800d150:	69fb      	ldr	r3, [r7, #28]
 800d152:	691b      	ldr	r3, [r3, #16]
 800d154:	431a      	orrs	r2, r3
 800d156:	69fb      	ldr	r3, [r7, #28]
 800d158:	695b      	ldr	r3, [r3, #20]
 800d15a:	431a      	orrs	r2, r3
 800d15c:	69fb      	ldr	r3, [r7, #28]
 800d15e:	69db      	ldr	r3, [r3, #28]
 800d160:	4313      	orrs	r3, r2
 800d162:	637b      	str	r3, [r7, #52]	; 0x34
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800d164:	69fb      	ldr	r3, [r7, #28]
 800d166:	681b      	ldr	r3, [r3, #0]
 800d168:	681b      	ldr	r3, [r3, #0]
 800d16a:	4ab0      	ldr	r2, [pc, #704]	; (800d42c <UART_SetConfig+0x30c>)
 800d16c:	4013      	ands	r3, r2
 800d16e:	0019      	movs	r1, r3
 800d170:	69fb      	ldr	r3, [r7, #28]
 800d172:	681b      	ldr	r3, [r3, #0]
 800d174:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d176:	430a      	orrs	r2, r1
 800d178:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800d17a:	69fb      	ldr	r3, [r7, #28]
 800d17c:	681b      	ldr	r3, [r3, #0]
 800d17e:	685b      	ldr	r3, [r3, #4]
 800d180:	4aab      	ldr	r2, [pc, #684]	; (800d430 <UART_SetConfig+0x310>)
 800d182:	4013      	ands	r3, r2
 800d184:	0019      	movs	r1, r3
 800d186:	69fb      	ldr	r3, [r7, #28]
 800d188:	68da      	ldr	r2, [r3, #12]
 800d18a:	69fb      	ldr	r3, [r7, #28]
 800d18c:	681b      	ldr	r3, [r3, #0]
 800d18e:	430a      	orrs	r2, r1
 800d190:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800d192:	69fb      	ldr	r3, [r7, #28]
 800d194:	699b      	ldr	r3, [r3, #24]
 800d196:	637b      	str	r3, [r7, #52]	; 0x34

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800d198:	69fb      	ldr	r3, [r7, #28]
 800d19a:	681b      	ldr	r3, [r3, #0]
 800d19c:	4aa5      	ldr	r2, [pc, #660]	; (800d434 <UART_SetConfig+0x314>)
 800d19e:	4293      	cmp	r3, r2
 800d1a0:	d004      	beq.n	800d1ac <UART_SetConfig+0x8c>
  {
    tmpreg |= huart->Init.OneBitSampling;
 800d1a2:	69fb      	ldr	r3, [r7, #28]
 800d1a4:	6a1b      	ldr	r3, [r3, #32]
 800d1a6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d1a8:	4313      	orrs	r3, r2
 800d1aa:	637b      	str	r3, [r7, #52]	; 0x34
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800d1ac:	69fb      	ldr	r3, [r7, #28]
 800d1ae:	681b      	ldr	r3, [r3, #0]
 800d1b0:	689b      	ldr	r3, [r3, #8]
 800d1b2:	4aa1      	ldr	r2, [pc, #644]	; (800d438 <UART_SetConfig+0x318>)
 800d1b4:	4013      	ands	r3, r2
 800d1b6:	0019      	movs	r1, r3
 800d1b8:	69fb      	ldr	r3, [r7, #28]
 800d1ba:	681b      	ldr	r3, [r3, #0]
 800d1bc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d1be:	430a      	orrs	r2, r1
 800d1c0:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800d1c2:	69fb      	ldr	r3, [r7, #28]
 800d1c4:	681b      	ldr	r3, [r3, #0]
 800d1c6:	4a9d      	ldr	r2, [pc, #628]	; (800d43c <UART_SetConfig+0x31c>)
 800d1c8:	4293      	cmp	r3, r2
 800d1ca:	d136      	bne.n	800d23a <UART_SetConfig+0x11a>
 800d1cc:	4b9c      	ldr	r3, [pc, #624]	; (800d440 <UART_SetConfig+0x320>)
 800d1ce:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800d1d0:	2203      	movs	r2, #3
 800d1d2:	4013      	ands	r3, r2
 800d1d4:	2b03      	cmp	r3, #3
 800d1d6:	d020      	beq.n	800d21a <UART_SetConfig+0xfa>
 800d1d8:	d827      	bhi.n	800d22a <UART_SetConfig+0x10a>
 800d1da:	2b02      	cmp	r3, #2
 800d1dc:	d00d      	beq.n	800d1fa <UART_SetConfig+0xda>
 800d1de:	d824      	bhi.n	800d22a <UART_SetConfig+0x10a>
 800d1e0:	2b00      	cmp	r3, #0
 800d1e2:	d002      	beq.n	800d1ea <UART_SetConfig+0xca>
 800d1e4:	2b01      	cmp	r3, #1
 800d1e6:	d010      	beq.n	800d20a <UART_SetConfig+0xea>
 800d1e8:	e01f      	b.n	800d22a <UART_SetConfig+0x10a>
 800d1ea:	231b      	movs	r3, #27
 800d1ec:	2218      	movs	r2, #24
 800d1ee:	4694      	mov	ip, r2
 800d1f0:	44bc      	add	ip, r7
 800d1f2:	4463      	add	r3, ip
 800d1f4:	2201      	movs	r2, #1
 800d1f6:	701a      	strb	r2, [r3, #0]
 800d1f8:	e0c5      	b.n	800d386 <UART_SetConfig+0x266>
 800d1fa:	231b      	movs	r3, #27
 800d1fc:	2218      	movs	r2, #24
 800d1fe:	4694      	mov	ip, r2
 800d200:	44bc      	add	ip, r7
 800d202:	4463      	add	r3, ip
 800d204:	2202      	movs	r2, #2
 800d206:	701a      	strb	r2, [r3, #0]
 800d208:	e0bd      	b.n	800d386 <UART_SetConfig+0x266>
 800d20a:	231b      	movs	r3, #27
 800d20c:	2218      	movs	r2, #24
 800d20e:	4694      	mov	ip, r2
 800d210:	44bc      	add	ip, r7
 800d212:	4463      	add	r3, ip
 800d214:	2204      	movs	r2, #4
 800d216:	701a      	strb	r2, [r3, #0]
 800d218:	e0b5      	b.n	800d386 <UART_SetConfig+0x266>
 800d21a:	231b      	movs	r3, #27
 800d21c:	2218      	movs	r2, #24
 800d21e:	4694      	mov	ip, r2
 800d220:	44bc      	add	ip, r7
 800d222:	4463      	add	r3, ip
 800d224:	2208      	movs	r2, #8
 800d226:	701a      	strb	r2, [r3, #0]
 800d228:	e0ad      	b.n	800d386 <UART_SetConfig+0x266>
 800d22a:	231b      	movs	r3, #27
 800d22c:	2218      	movs	r2, #24
 800d22e:	4694      	mov	ip, r2
 800d230:	44bc      	add	ip, r7
 800d232:	4463      	add	r3, ip
 800d234:	2210      	movs	r2, #16
 800d236:	701a      	strb	r2, [r3, #0]
 800d238:	e0a5      	b.n	800d386 <UART_SetConfig+0x266>
 800d23a:	69fb      	ldr	r3, [r7, #28]
 800d23c:	681b      	ldr	r3, [r3, #0]
 800d23e:	4a81      	ldr	r2, [pc, #516]	; (800d444 <UART_SetConfig+0x324>)
 800d240:	4293      	cmp	r3, r2
 800d242:	d136      	bne.n	800d2b2 <UART_SetConfig+0x192>
 800d244:	4b7e      	ldr	r3, [pc, #504]	; (800d440 <UART_SetConfig+0x320>)
 800d246:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800d248:	220c      	movs	r2, #12
 800d24a:	4013      	ands	r3, r2
 800d24c:	2b0c      	cmp	r3, #12
 800d24e:	d020      	beq.n	800d292 <UART_SetConfig+0x172>
 800d250:	d827      	bhi.n	800d2a2 <UART_SetConfig+0x182>
 800d252:	2b08      	cmp	r3, #8
 800d254:	d00d      	beq.n	800d272 <UART_SetConfig+0x152>
 800d256:	d824      	bhi.n	800d2a2 <UART_SetConfig+0x182>
 800d258:	2b00      	cmp	r3, #0
 800d25a:	d002      	beq.n	800d262 <UART_SetConfig+0x142>
 800d25c:	2b04      	cmp	r3, #4
 800d25e:	d010      	beq.n	800d282 <UART_SetConfig+0x162>
 800d260:	e01f      	b.n	800d2a2 <UART_SetConfig+0x182>
 800d262:	231b      	movs	r3, #27
 800d264:	2218      	movs	r2, #24
 800d266:	4694      	mov	ip, r2
 800d268:	44bc      	add	ip, r7
 800d26a:	4463      	add	r3, ip
 800d26c:	2200      	movs	r2, #0
 800d26e:	701a      	strb	r2, [r3, #0]
 800d270:	e089      	b.n	800d386 <UART_SetConfig+0x266>
 800d272:	231b      	movs	r3, #27
 800d274:	2218      	movs	r2, #24
 800d276:	4694      	mov	ip, r2
 800d278:	44bc      	add	ip, r7
 800d27a:	4463      	add	r3, ip
 800d27c:	2202      	movs	r2, #2
 800d27e:	701a      	strb	r2, [r3, #0]
 800d280:	e081      	b.n	800d386 <UART_SetConfig+0x266>
 800d282:	231b      	movs	r3, #27
 800d284:	2218      	movs	r2, #24
 800d286:	4694      	mov	ip, r2
 800d288:	44bc      	add	ip, r7
 800d28a:	4463      	add	r3, ip
 800d28c:	2204      	movs	r2, #4
 800d28e:	701a      	strb	r2, [r3, #0]
 800d290:	e079      	b.n	800d386 <UART_SetConfig+0x266>
 800d292:	231b      	movs	r3, #27
 800d294:	2218      	movs	r2, #24
 800d296:	4694      	mov	ip, r2
 800d298:	44bc      	add	ip, r7
 800d29a:	4463      	add	r3, ip
 800d29c:	2208      	movs	r2, #8
 800d29e:	701a      	strb	r2, [r3, #0]
 800d2a0:	e071      	b.n	800d386 <UART_SetConfig+0x266>
 800d2a2:	231b      	movs	r3, #27
 800d2a4:	2218      	movs	r2, #24
 800d2a6:	4694      	mov	ip, r2
 800d2a8:	44bc      	add	ip, r7
 800d2aa:	4463      	add	r3, ip
 800d2ac:	2210      	movs	r2, #16
 800d2ae:	701a      	strb	r2, [r3, #0]
 800d2b0:	e069      	b.n	800d386 <UART_SetConfig+0x266>
 800d2b2:	69fb      	ldr	r3, [r7, #28]
 800d2b4:	681b      	ldr	r3, [r3, #0]
 800d2b6:	4a64      	ldr	r2, [pc, #400]	; (800d448 <UART_SetConfig+0x328>)
 800d2b8:	4293      	cmp	r3, r2
 800d2ba:	d107      	bne.n	800d2cc <UART_SetConfig+0x1ac>
 800d2bc:	231b      	movs	r3, #27
 800d2be:	2218      	movs	r2, #24
 800d2c0:	4694      	mov	ip, r2
 800d2c2:	44bc      	add	ip, r7
 800d2c4:	4463      	add	r3, ip
 800d2c6:	2200      	movs	r2, #0
 800d2c8:	701a      	strb	r2, [r3, #0]
 800d2ca:	e05c      	b.n	800d386 <UART_SetConfig+0x266>
 800d2cc:	69fb      	ldr	r3, [r7, #28]
 800d2ce:	681b      	ldr	r3, [r3, #0]
 800d2d0:	4a5e      	ldr	r2, [pc, #376]	; (800d44c <UART_SetConfig+0x32c>)
 800d2d2:	4293      	cmp	r3, r2
 800d2d4:	d107      	bne.n	800d2e6 <UART_SetConfig+0x1c6>
 800d2d6:	231b      	movs	r3, #27
 800d2d8:	2218      	movs	r2, #24
 800d2da:	4694      	mov	ip, r2
 800d2dc:	44bc      	add	ip, r7
 800d2de:	4463      	add	r3, ip
 800d2e0:	2200      	movs	r2, #0
 800d2e2:	701a      	strb	r2, [r3, #0]
 800d2e4:	e04f      	b.n	800d386 <UART_SetConfig+0x266>
 800d2e6:	69fb      	ldr	r3, [r7, #28]
 800d2e8:	681b      	ldr	r3, [r3, #0]
 800d2ea:	4a52      	ldr	r2, [pc, #328]	; (800d434 <UART_SetConfig+0x314>)
 800d2ec:	4293      	cmp	r3, r2
 800d2ee:	d143      	bne.n	800d378 <UART_SetConfig+0x258>
 800d2f0:	4b53      	ldr	r3, [pc, #332]	; (800d440 <UART_SetConfig+0x320>)
 800d2f2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800d2f4:	23c0      	movs	r3, #192	; 0xc0
 800d2f6:	011b      	lsls	r3, r3, #4
 800d2f8:	4013      	ands	r3, r2
 800d2fa:	22c0      	movs	r2, #192	; 0xc0
 800d2fc:	0112      	lsls	r2, r2, #4
 800d2fe:	4293      	cmp	r3, r2
 800d300:	d02a      	beq.n	800d358 <UART_SetConfig+0x238>
 800d302:	22c0      	movs	r2, #192	; 0xc0
 800d304:	0112      	lsls	r2, r2, #4
 800d306:	4293      	cmp	r3, r2
 800d308:	d82e      	bhi.n	800d368 <UART_SetConfig+0x248>
 800d30a:	2280      	movs	r2, #128	; 0x80
 800d30c:	0112      	lsls	r2, r2, #4
 800d30e:	4293      	cmp	r3, r2
 800d310:	d012      	beq.n	800d338 <UART_SetConfig+0x218>
 800d312:	2280      	movs	r2, #128	; 0x80
 800d314:	0112      	lsls	r2, r2, #4
 800d316:	4293      	cmp	r3, r2
 800d318:	d826      	bhi.n	800d368 <UART_SetConfig+0x248>
 800d31a:	2b00      	cmp	r3, #0
 800d31c:	d004      	beq.n	800d328 <UART_SetConfig+0x208>
 800d31e:	2280      	movs	r2, #128	; 0x80
 800d320:	00d2      	lsls	r2, r2, #3
 800d322:	4293      	cmp	r3, r2
 800d324:	d010      	beq.n	800d348 <UART_SetConfig+0x228>
 800d326:	e01f      	b.n	800d368 <UART_SetConfig+0x248>
 800d328:	231b      	movs	r3, #27
 800d32a:	2218      	movs	r2, #24
 800d32c:	4694      	mov	ip, r2
 800d32e:	44bc      	add	ip, r7
 800d330:	4463      	add	r3, ip
 800d332:	2200      	movs	r2, #0
 800d334:	701a      	strb	r2, [r3, #0]
 800d336:	e026      	b.n	800d386 <UART_SetConfig+0x266>
 800d338:	231b      	movs	r3, #27
 800d33a:	2218      	movs	r2, #24
 800d33c:	4694      	mov	ip, r2
 800d33e:	44bc      	add	ip, r7
 800d340:	4463      	add	r3, ip
 800d342:	2202      	movs	r2, #2
 800d344:	701a      	strb	r2, [r3, #0]
 800d346:	e01e      	b.n	800d386 <UART_SetConfig+0x266>
 800d348:	231b      	movs	r3, #27
 800d34a:	2218      	movs	r2, #24
 800d34c:	4694      	mov	ip, r2
 800d34e:	44bc      	add	ip, r7
 800d350:	4463      	add	r3, ip
 800d352:	2204      	movs	r2, #4
 800d354:	701a      	strb	r2, [r3, #0]
 800d356:	e016      	b.n	800d386 <UART_SetConfig+0x266>
 800d358:	231b      	movs	r3, #27
 800d35a:	2218      	movs	r2, #24
 800d35c:	4694      	mov	ip, r2
 800d35e:	44bc      	add	ip, r7
 800d360:	4463      	add	r3, ip
 800d362:	2208      	movs	r2, #8
 800d364:	701a      	strb	r2, [r3, #0]
 800d366:	e00e      	b.n	800d386 <UART_SetConfig+0x266>
 800d368:	231b      	movs	r3, #27
 800d36a:	2218      	movs	r2, #24
 800d36c:	4694      	mov	ip, r2
 800d36e:	44bc      	add	ip, r7
 800d370:	4463      	add	r3, ip
 800d372:	2210      	movs	r2, #16
 800d374:	701a      	strb	r2, [r3, #0]
 800d376:	e006      	b.n	800d386 <UART_SetConfig+0x266>
 800d378:	231b      	movs	r3, #27
 800d37a:	2218      	movs	r2, #24
 800d37c:	4694      	mov	ip, r2
 800d37e:	44bc      	add	ip, r7
 800d380:	4463      	add	r3, ip
 800d382:	2210      	movs	r2, #16
 800d384:	701a      	strb	r2, [r3, #0]

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 800d386:	69fb      	ldr	r3, [r7, #28]
 800d388:	681b      	ldr	r3, [r3, #0]
 800d38a:	4a2a      	ldr	r2, [pc, #168]	; (800d434 <UART_SetConfig+0x314>)
 800d38c:	4293      	cmp	r3, r2
 800d38e:	d000      	beq.n	800d392 <UART_SetConfig+0x272>
 800d390:	e09d      	b.n	800d4ce <UART_SetConfig+0x3ae>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 800d392:	231b      	movs	r3, #27
 800d394:	2218      	movs	r2, #24
 800d396:	4694      	mov	ip, r2
 800d398:	44bc      	add	ip, r7
 800d39a:	4463      	add	r3, ip
 800d39c:	781b      	ldrb	r3, [r3, #0]
 800d39e:	2b08      	cmp	r3, #8
 800d3a0:	d01d      	beq.n	800d3de <UART_SetConfig+0x2be>
 800d3a2:	dc20      	bgt.n	800d3e6 <UART_SetConfig+0x2c6>
 800d3a4:	2b04      	cmp	r3, #4
 800d3a6:	d015      	beq.n	800d3d4 <UART_SetConfig+0x2b4>
 800d3a8:	dc1d      	bgt.n	800d3e6 <UART_SetConfig+0x2c6>
 800d3aa:	2b00      	cmp	r3, #0
 800d3ac:	d002      	beq.n	800d3b4 <UART_SetConfig+0x294>
 800d3ae:	2b02      	cmp	r3, #2
 800d3b0:	d005      	beq.n	800d3be <UART_SetConfig+0x29e>
 800d3b2:	e018      	b.n	800d3e6 <UART_SetConfig+0x2c6>
    {
      case UART_CLOCKSOURCE_PCLK1:
        lpuart_ker_ck_pres = HAL_RCC_GetPCLK1Freq();
 800d3b4:	f7fe faa4 	bl	800b900 <HAL_RCC_GetPCLK1Freq>
 800d3b8:	0003      	movs	r3, r0
 800d3ba:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 800d3bc:	e01b      	b.n	800d3f6 <UART_SetConfig+0x2d6>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800d3be:	4b20      	ldr	r3, [pc, #128]	; (800d440 <UART_SetConfig+0x320>)
 800d3c0:	681b      	ldr	r3, [r3, #0]
 800d3c2:	2210      	movs	r2, #16
 800d3c4:	4013      	ands	r3, r2
 800d3c6:	d002      	beq.n	800d3ce <UART_SetConfig+0x2ae>
        {
          lpuart_ker_ck_pres = (uint32_t)(HSI_VALUE >> 2U);
 800d3c8:	4b21      	ldr	r3, [pc, #132]	; (800d450 <UART_SetConfig+0x330>)
 800d3ca:	627b      	str	r3, [r7, #36]	; 0x24
        }
        else
        {
          lpuart_ker_ck_pres = (uint32_t)HSI_VALUE;
        }
        break;
 800d3cc:	e013      	b.n	800d3f6 <UART_SetConfig+0x2d6>
          lpuart_ker_ck_pres = (uint32_t)HSI_VALUE;
 800d3ce:	4b21      	ldr	r3, [pc, #132]	; (800d454 <UART_SetConfig+0x334>)
 800d3d0:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 800d3d2:	e010      	b.n	800d3f6 <UART_SetConfig+0x2d6>
      case UART_CLOCKSOURCE_SYSCLK:
        lpuart_ker_ck_pres = HAL_RCC_GetSysClockFreq();
 800d3d4:	f7fe fa04 	bl	800b7e0 <HAL_RCC_GetSysClockFreq>
 800d3d8:	0003      	movs	r3, r0
 800d3da:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 800d3dc:	e00b      	b.n	800d3f6 <UART_SetConfig+0x2d6>
      case UART_CLOCKSOURCE_LSE:
        lpuart_ker_ck_pres = (uint32_t)LSE_VALUE;
 800d3de:	2380      	movs	r3, #128	; 0x80
 800d3e0:	021b      	lsls	r3, r3, #8
 800d3e2:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 800d3e4:	e007      	b.n	800d3f6 <UART_SetConfig+0x2d6>
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 800d3e6:	2313      	movs	r3, #19
 800d3e8:	2218      	movs	r2, #24
 800d3ea:	4694      	mov	ip, r2
 800d3ec:	44bc      	add	ip, r7
 800d3ee:	4463      	add	r3, ip
 800d3f0:	2201      	movs	r2, #1
 800d3f2:	701a      	strb	r2, [r3, #0]
        break;
 800d3f4:	46c0      	nop			; (mov r8, r8)
    }

    /* if proper clock source reported */
    if (lpuart_ker_ck_pres != 0U)
 800d3f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d3f8:	2b00      	cmp	r3, #0
 800d3fa:	d100      	bne.n	800d3fe <UART_SetConfig+0x2de>
 800d3fc:	e1a8      	b.n	800d750 <UART_SetConfig+0x630>
    {
      /* ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800d3fe:	69fb      	ldr	r3, [r7, #28]
 800d400:	685a      	ldr	r2, [r3, #4]
 800d402:	0013      	movs	r3, r2
 800d404:	005b      	lsls	r3, r3, #1
 800d406:	189b      	adds	r3, r3, r2
 800d408:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d40a:	429a      	cmp	r2, r3
 800d40c:	d305      	bcc.n	800d41a <UART_SetConfig+0x2fa>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 800d40e:	69fb      	ldr	r3, [r7, #28]
 800d410:	685b      	ldr	r3, [r3, #4]
 800d412:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800d414:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d416:	429a      	cmp	r2, r3
 800d418:	d91e      	bls.n	800d458 <UART_SetConfig+0x338>
      {
        ret = HAL_ERROR;
 800d41a:	2313      	movs	r3, #19
 800d41c:	2218      	movs	r2, #24
 800d41e:	4694      	mov	ip, r2
 800d420:	44bc      	add	ip, r7
 800d422:	4463      	add	r3, ip
 800d424:	2201      	movs	r2, #1
 800d426:	701a      	strb	r2, [r3, #0]
 800d428:	e192      	b.n	800d750 <UART_SetConfig+0x630>
 800d42a:	46c0      	nop			; (mov r8, r8)
 800d42c:	efff69f3 	.word	0xefff69f3
 800d430:	ffffcfff 	.word	0xffffcfff
 800d434:	40004800 	.word	0x40004800
 800d438:	fffff4ff 	.word	0xfffff4ff
 800d43c:	40013800 	.word	0x40013800
 800d440:	40021000 	.word	0x40021000
 800d444:	40004400 	.word	0x40004400
 800d448:	40004c00 	.word	0x40004c00
 800d44c:	40005000 	.word	0x40005000
 800d450:	003d0900 	.word	0x003d0900
 800d454:	00f42400 	.word	0x00f42400
      }
      else
      {
        usartdiv = (uint32_t)(UART_DIV_LPUART(lpuart_ker_ck_pres, huart->Init.BaudRate));
 800d458:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d45a:	613b      	str	r3, [r7, #16]
 800d45c:	2300      	movs	r3, #0
 800d45e:	617b      	str	r3, [r7, #20]
 800d460:	6939      	ldr	r1, [r7, #16]
 800d462:	697a      	ldr	r2, [r7, #20]
 800d464:	000b      	movs	r3, r1
 800d466:	0e1b      	lsrs	r3, r3, #24
 800d468:	0010      	movs	r0, r2
 800d46a:	0205      	lsls	r5, r0, #8
 800d46c:	431d      	orrs	r5, r3
 800d46e:	000b      	movs	r3, r1
 800d470:	021c      	lsls	r4, r3, #8
 800d472:	69fb      	ldr	r3, [r7, #28]
 800d474:	685b      	ldr	r3, [r3, #4]
 800d476:	085b      	lsrs	r3, r3, #1
 800d478:	60bb      	str	r3, [r7, #8]
 800d47a:	2300      	movs	r3, #0
 800d47c:	60fb      	str	r3, [r7, #12]
 800d47e:	68b8      	ldr	r0, [r7, #8]
 800d480:	68f9      	ldr	r1, [r7, #12]
 800d482:	1900      	adds	r0, r0, r4
 800d484:	4169      	adcs	r1, r5
 800d486:	69fb      	ldr	r3, [r7, #28]
 800d488:	685b      	ldr	r3, [r3, #4]
 800d48a:	603b      	str	r3, [r7, #0]
 800d48c:	2300      	movs	r3, #0
 800d48e:	607b      	str	r3, [r7, #4]
 800d490:	683a      	ldr	r2, [r7, #0]
 800d492:	687b      	ldr	r3, [r7, #4]
 800d494:	f7f3 f830 	bl	80004f8 <__aeabi_uldivmod>
 800d498:	0002      	movs	r2, r0
 800d49a:	000b      	movs	r3, r1
 800d49c:	0013      	movs	r3, r2
 800d49e:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* It is forbidden to write values lower than 0x300 in the LPUART_BRR register */
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800d4a0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d4a2:	23c0      	movs	r3, #192	; 0xc0
 800d4a4:	009b      	lsls	r3, r3, #2
 800d4a6:	429a      	cmp	r2, r3
 800d4a8:	d309      	bcc.n	800d4be <UART_SetConfig+0x39e>
 800d4aa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d4ac:	2380      	movs	r3, #128	; 0x80
 800d4ae:	035b      	lsls	r3, r3, #13
 800d4b0:	429a      	cmp	r2, r3
 800d4b2:	d204      	bcs.n	800d4be <UART_SetConfig+0x39e>
        {
          huart->Instance->BRR = usartdiv;
 800d4b4:	69fb      	ldr	r3, [r7, #28]
 800d4b6:	681b      	ldr	r3, [r3, #0]
 800d4b8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d4ba:	60da      	str	r2, [r3, #12]
 800d4bc:	e148      	b.n	800d750 <UART_SetConfig+0x630>
        }
        else
        {
          ret = HAL_ERROR;
 800d4be:	2313      	movs	r3, #19
 800d4c0:	2218      	movs	r2, #24
 800d4c2:	4694      	mov	ip, r2
 800d4c4:	44bc      	add	ip, r7
 800d4c6:	4463      	add	r3, ip
 800d4c8:	2201      	movs	r2, #1
 800d4ca:	701a      	strb	r2, [r3, #0]
 800d4cc:	e140      	b.n	800d750 <UART_SetConfig+0x630>
        }
      } /*   if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) || (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (lpuart_ker_ck_pres != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800d4ce:	69fb      	ldr	r3, [r7, #28]
 800d4d0:	69da      	ldr	r2, [r3, #28]
 800d4d2:	2380      	movs	r3, #128	; 0x80
 800d4d4:	021b      	lsls	r3, r3, #8
 800d4d6:	429a      	cmp	r2, r3
 800d4d8:	d000      	beq.n	800d4dc <UART_SetConfig+0x3bc>
 800d4da:	e0aa      	b.n	800d632 <UART_SetConfig+0x512>
  {
    switch (clocksource)
 800d4dc:	231b      	movs	r3, #27
 800d4de:	2218      	movs	r2, #24
 800d4e0:	4694      	mov	ip, r2
 800d4e2:	44bc      	add	ip, r7
 800d4e4:	4463      	add	r3, ip
 800d4e6:	781b      	ldrb	r3, [r3, #0]
 800d4e8:	2b08      	cmp	r3, #8
 800d4ea:	d86d      	bhi.n	800d5c8 <UART_SetConfig+0x4a8>
 800d4ec:	009a      	lsls	r2, r3, #2
 800d4ee:	4ba0      	ldr	r3, [pc, #640]	; (800d770 <UART_SetConfig+0x650>)
 800d4f0:	18d3      	adds	r3, r2, r3
 800d4f2:	681b      	ldr	r3, [r3, #0]
 800d4f4:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800d4f6:	f7fe fa03 	bl	800b900 <HAL_RCC_GetPCLK1Freq>
 800d4fa:	0003      	movs	r3, r0
 800d4fc:	005a      	lsls	r2, r3, #1
 800d4fe:	69fb      	ldr	r3, [r7, #28]
 800d500:	685b      	ldr	r3, [r3, #4]
 800d502:	085b      	lsrs	r3, r3, #1
 800d504:	18d2      	adds	r2, r2, r3
 800d506:	69fb      	ldr	r3, [r7, #28]
 800d508:	685b      	ldr	r3, [r3, #4]
 800d50a:	0019      	movs	r1, r3
 800d50c:	0010      	movs	r0, r2
 800d50e:	f7f2 fe05 	bl	800011c <__udivsi3>
 800d512:	0003      	movs	r3, r0
 800d514:	b29b      	uxth	r3, r3
 800d516:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d518:	e05e      	b.n	800d5d8 <UART_SetConfig+0x4b8>
      case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800d51a:	f7fe fa07 	bl	800b92c <HAL_RCC_GetPCLK2Freq>
 800d51e:	0003      	movs	r3, r0
 800d520:	005a      	lsls	r2, r3, #1
 800d522:	69fb      	ldr	r3, [r7, #28]
 800d524:	685b      	ldr	r3, [r3, #4]
 800d526:	085b      	lsrs	r3, r3, #1
 800d528:	18d2      	adds	r2, r2, r3
 800d52a:	69fb      	ldr	r3, [r7, #28]
 800d52c:	685b      	ldr	r3, [r3, #4]
 800d52e:	0019      	movs	r1, r3
 800d530:	0010      	movs	r0, r2
 800d532:	f7f2 fdf3 	bl	800011c <__udivsi3>
 800d536:	0003      	movs	r3, r0
 800d538:	b29b      	uxth	r3, r3
 800d53a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d53c:	e04c      	b.n	800d5d8 <UART_SetConfig+0x4b8>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800d53e:	4b8d      	ldr	r3, [pc, #564]	; (800d774 <UART_SetConfig+0x654>)
 800d540:	681b      	ldr	r3, [r3, #0]
 800d542:	2210      	movs	r2, #16
 800d544:	4013      	ands	r3, r2
 800d546:	d00e      	beq.n	800d566 <UART_SetConfig+0x446>
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING8((HSI_VALUE >> 2U), huart->Init.BaudRate));
 800d548:	69fb      	ldr	r3, [r7, #28]
 800d54a:	685b      	ldr	r3, [r3, #4]
 800d54c:	085b      	lsrs	r3, r3, #1
 800d54e:	4a8a      	ldr	r2, [pc, #552]	; (800d778 <UART_SetConfig+0x658>)
 800d550:	189a      	adds	r2, r3, r2
 800d552:	69fb      	ldr	r3, [r7, #28]
 800d554:	685b      	ldr	r3, [r3, #4]
 800d556:	0019      	movs	r1, r3
 800d558:	0010      	movs	r0, r2
 800d55a:	f7f2 fddf 	bl	800011c <__udivsi3>
 800d55e:	0003      	movs	r3, r0
 800d560:	b29b      	uxth	r3, r3
 800d562:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
        }
        break;
 800d564:	e038      	b.n	800d5d8 <UART_SetConfig+0x4b8>
          usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 800d566:	69fb      	ldr	r3, [r7, #28]
 800d568:	685b      	ldr	r3, [r3, #4]
 800d56a:	085b      	lsrs	r3, r3, #1
 800d56c:	4a83      	ldr	r2, [pc, #524]	; (800d77c <UART_SetConfig+0x65c>)
 800d56e:	189a      	adds	r2, r3, r2
 800d570:	69fb      	ldr	r3, [r7, #28]
 800d572:	685b      	ldr	r3, [r3, #4]
 800d574:	0019      	movs	r1, r3
 800d576:	0010      	movs	r0, r2
 800d578:	f7f2 fdd0 	bl	800011c <__udivsi3>
 800d57c:	0003      	movs	r3, r0
 800d57e:	b29b      	uxth	r3, r3
 800d580:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d582:	e029      	b.n	800d5d8 <UART_SetConfig+0x4b8>
      case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800d584:	f7fe f92c 	bl	800b7e0 <HAL_RCC_GetSysClockFreq>
 800d588:	0003      	movs	r3, r0
 800d58a:	005a      	lsls	r2, r3, #1
 800d58c:	69fb      	ldr	r3, [r7, #28]
 800d58e:	685b      	ldr	r3, [r3, #4]
 800d590:	085b      	lsrs	r3, r3, #1
 800d592:	18d2      	adds	r2, r2, r3
 800d594:	69fb      	ldr	r3, [r7, #28]
 800d596:	685b      	ldr	r3, [r3, #4]
 800d598:	0019      	movs	r1, r3
 800d59a:	0010      	movs	r0, r2
 800d59c:	f7f2 fdbe 	bl	800011c <__udivsi3>
 800d5a0:	0003      	movs	r3, r0
 800d5a2:	b29b      	uxth	r3, r3
 800d5a4:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d5a6:	e017      	b.n	800d5d8 <UART_SetConfig+0x4b8>
      case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 800d5a8:	69fb      	ldr	r3, [r7, #28]
 800d5aa:	685b      	ldr	r3, [r3, #4]
 800d5ac:	085b      	lsrs	r3, r3, #1
 800d5ae:	2280      	movs	r2, #128	; 0x80
 800d5b0:	0252      	lsls	r2, r2, #9
 800d5b2:	189a      	adds	r2, r3, r2
 800d5b4:	69fb      	ldr	r3, [r7, #28]
 800d5b6:	685b      	ldr	r3, [r3, #4]
 800d5b8:	0019      	movs	r1, r3
 800d5ba:	0010      	movs	r0, r2
 800d5bc:	f7f2 fdae 	bl	800011c <__udivsi3>
 800d5c0:	0003      	movs	r3, r0
 800d5c2:	b29b      	uxth	r3, r3
 800d5c4:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d5c6:	e007      	b.n	800d5d8 <UART_SetConfig+0x4b8>
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 800d5c8:	2313      	movs	r3, #19
 800d5ca:	2218      	movs	r2, #24
 800d5cc:	4694      	mov	ip, r2
 800d5ce:	44bc      	add	ip, r7
 800d5d0:	4463      	add	r3, ip
 800d5d2:	2201      	movs	r2, #1
 800d5d4:	701a      	strb	r2, [r3, #0]
        break;
 800d5d6:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800d5d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d5da:	2b0f      	cmp	r3, #15
 800d5dc:	d921      	bls.n	800d622 <UART_SetConfig+0x502>
 800d5de:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d5e0:	2380      	movs	r3, #128	; 0x80
 800d5e2:	025b      	lsls	r3, r3, #9
 800d5e4:	429a      	cmp	r2, r3
 800d5e6:	d21c      	bcs.n	800d622 <UART_SetConfig+0x502>
    {
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800d5e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d5ea:	b29a      	uxth	r2, r3
 800d5ec:	200a      	movs	r0, #10
 800d5ee:	2418      	movs	r4, #24
 800d5f0:	193b      	adds	r3, r7, r4
 800d5f2:	181b      	adds	r3, r3, r0
 800d5f4:	210f      	movs	r1, #15
 800d5f6:	438a      	bics	r2, r1
 800d5f8:	801a      	strh	r2, [r3, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800d5fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d5fc:	085b      	lsrs	r3, r3, #1
 800d5fe:	b29b      	uxth	r3, r3
 800d600:	2207      	movs	r2, #7
 800d602:	4013      	ands	r3, r2
 800d604:	b299      	uxth	r1, r3
 800d606:	193b      	adds	r3, r7, r4
 800d608:	181b      	adds	r3, r3, r0
 800d60a:	193a      	adds	r2, r7, r4
 800d60c:	1812      	adds	r2, r2, r0
 800d60e:	8812      	ldrh	r2, [r2, #0]
 800d610:	430a      	orrs	r2, r1
 800d612:	801a      	strh	r2, [r3, #0]
      huart->Instance->BRR = brrtemp;
 800d614:	69fb      	ldr	r3, [r7, #28]
 800d616:	681b      	ldr	r3, [r3, #0]
 800d618:	193a      	adds	r2, r7, r4
 800d61a:	1812      	adds	r2, r2, r0
 800d61c:	8812      	ldrh	r2, [r2, #0]
 800d61e:	60da      	str	r2, [r3, #12]
 800d620:	e096      	b.n	800d750 <UART_SetConfig+0x630>
    }
    else
    {
      ret = HAL_ERROR;
 800d622:	2313      	movs	r3, #19
 800d624:	2218      	movs	r2, #24
 800d626:	4694      	mov	ip, r2
 800d628:	44bc      	add	ip, r7
 800d62a:	4463      	add	r3, ip
 800d62c:	2201      	movs	r2, #1
 800d62e:	701a      	strb	r2, [r3, #0]
 800d630:	e08e      	b.n	800d750 <UART_SetConfig+0x630>
    }
  }
  else
  {
    switch (clocksource)
 800d632:	231b      	movs	r3, #27
 800d634:	2218      	movs	r2, #24
 800d636:	4694      	mov	ip, r2
 800d638:	44bc      	add	ip, r7
 800d63a:	4463      	add	r3, ip
 800d63c:	781b      	ldrb	r3, [r3, #0]
 800d63e:	2b08      	cmp	r3, #8
 800d640:	d86a      	bhi.n	800d718 <UART_SetConfig+0x5f8>
 800d642:	009a      	lsls	r2, r3, #2
 800d644:	4b4e      	ldr	r3, [pc, #312]	; (800d780 <UART_SetConfig+0x660>)
 800d646:	18d3      	adds	r3, r2, r3
 800d648:	681b      	ldr	r3, [r3, #0]
 800d64a:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800d64c:	f7fe f958 	bl	800b900 <HAL_RCC_GetPCLK1Freq>
 800d650:	0002      	movs	r2, r0
 800d652:	69fb      	ldr	r3, [r7, #28]
 800d654:	685b      	ldr	r3, [r3, #4]
 800d656:	085b      	lsrs	r3, r3, #1
 800d658:	18d2      	adds	r2, r2, r3
 800d65a:	69fb      	ldr	r3, [r7, #28]
 800d65c:	685b      	ldr	r3, [r3, #4]
 800d65e:	0019      	movs	r1, r3
 800d660:	0010      	movs	r0, r2
 800d662:	f7f2 fd5b 	bl	800011c <__udivsi3>
 800d666:	0003      	movs	r3, r0
 800d668:	b29b      	uxth	r3, r3
 800d66a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d66c:	e05c      	b.n	800d728 <UART_SetConfig+0x608>
      case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800d66e:	f7fe f95d 	bl	800b92c <HAL_RCC_GetPCLK2Freq>
 800d672:	0002      	movs	r2, r0
 800d674:	69fb      	ldr	r3, [r7, #28]
 800d676:	685b      	ldr	r3, [r3, #4]
 800d678:	085b      	lsrs	r3, r3, #1
 800d67a:	18d2      	adds	r2, r2, r3
 800d67c:	69fb      	ldr	r3, [r7, #28]
 800d67e:	685b      	ldr	r3, [r3, #4]
 800d680:	0019      	movs	r1, r3
 800d682:	0010      	movs	r0, r2
 800d684:	f7f2 fd4a 	bl	800011c <__udivsi3>
 800d688:	0003      	movs	r3, r0
 800d68a:	b29b      	uxth	r3, r3
 800d68c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d68e:	e04b      	b.n	800d728 <UART_SetConfig+0x608>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800d690:	4b38      	ldr	r3, [pc, #224]	; (800d774 <UART_SetConfig+0x654>)
 800d692:	681b      	ldr	r3, [r3, #0]
 800d694:	2210      	movs	r2, #16
 800d696:	4013      	ands	r3, r2
 800d698:	d00e      	beq.n	800d6b8 <UART_SetConfig+0x598>
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING16((HSI_VALUE >> 2U), huart->Init.BaudRate));
 800d69a:	69fb      	ldr	r3, [r7, #28]
 800d69c:	685b      	ldr	r3, [r3, #4]
 800d69e:	085b      	lsrs	r3, r3, #1
 800d6a0:	4a38      	ldr	r2, [pc, #224]	; (800d784 <UART_SetConfig+0x664>)
 800d6a2:	189a      	adds	r2, r3, r2
 800d6a4:	69fb      	ldr	r3, [r7, #28]
 800d6a6:	685b      	ldr	r3, [r3, #4]
 800d6a8:	0019      	movs	r1, r3
 800d6aa:	0010      	movs	r0, r2
 800d6ac:	f7f2 fd36 	bl	800011c <__udivsi3>
 800d6b0:	0003      	movs	r3, r0
 800d6b2:	b29b      	uxth	r3, r3
 800d6b4:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
        }
        break;
 800d6b6:	e037      	b.n	800d728 <UART_SetConfig+0x608>
          usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 800d6b8:	69fb      	ldr	r3, [r7, #28]
 800d6ba:	685b      	ldr	r3, [r3, #4]
 800d6bc:	085b      	lsrs	r3, r3, #1
 800d6be:	4a32      	ldr	r2, [pc, #200]	; (800d788 <UART_SetConfig+0x668>)
 800d6c0:	189a      	adds	r2, r3, r2
 800d6c2:	69fb      	ldr	r3, [r7, #28]
 800d6c4:	685b      	ldr	r3, [r3, #4]
 800d6c6:	0019      	movs	r1, r3
 800d6c8:	0010      	movs	r0, r2
 800d6ca:	f7f2 fd27 	bl	800011c <__udivsi3>
 800d6ce:	0003      	movs	r3, r0
 800d6d0:	b29b      	uxth	r3, r3
 800d6d2:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d6d4:	e028      	b.n	800d728 <UART_SetConfig+0x608>
      case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800d6d6:	f7fe f883 	bl	800b7e0 <HAL_RCC_GetSysClockFreq>
 800d6da:	0002      	movs	r2, r0
 800d6dc:	69fb      	ldr	r3, [r7, #28]
 800d6de:	685b      	ldr	r3, [r3, #4]
 800d6e0:	085b      	lsrs	r3, r3, #1
 800d6e2:	18d2      	adds	r2, r2, r3
 800d6e4:	69fb      	ldr	r3, [r7, #28]
 800d6e6:	685b      	ldr	r3, [r3, #4]
 800d6e8:	0019      	movs	r1, r3
 800d6ea:	0010      	movs	r0, r2
 800d6ec:	f7f2 fd16 	bl	800011c <__udivsi3>
 800d6f0:	0003      	movs	r3, r0
 800d6f2:	b29b      	uxth	r3, r3
 800d6f4:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d6f6:	e017      	b.n	800d728 <UART_SetConfig+0x608>
      case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 800d6f8:	69fb      	ldr	r3, [r7, #28]
 800d6fa:	685b      	ldr	r3, [r3, #4]
 800d6fc:	085b      	lsrs	r3, r3, #1
 800d6fe:	2280      	movs	r2, #128	; 0x80
 800d700:	0212      	lsls	r2, r2, #8
 800d702:	189a      	adds	r2, r3, r2
 800d704:	69fb      	ldr	r3, [r7, #28]
 800d706:	685b      	ldr	r3, [r3, #4]
 800d708:	0019      	movs	r1, r3
 800d70a:	0010      	movs	r0, r2
 800d70c:	f7f2 fd06 	bl	800011c <__udivsi3>
 800d710:	0003      	movs	r3, r0
 800d712:	b29b      	uxth	r3, r3
 800d714:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800d716:	e007      	b.n	800d728 <UART_SetConfig+0x608>
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 800d718:	2313      	movs	r3, #19
 800d71a:	2218      	movs	r2, #24
 800d71c:	4694      	mov	ip, r2
 800d71e:	44bc      	add	ip, r7
 800d720:	4463      	add	r3, ip
 800d722:	2201      	movs	r2, #1
 800d724:	701a      	strb	r2, [r3, #0]
        break;
 800d726:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800d728:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d72a:	2b0f      	cmp	r3, #15
 800d72c:	d909      	bls.n	800d742 <UART_SetConfig+0x622>
 800d72e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d730:	2380      	movs	r3, #128	; 0x80
 800d732:	025b      	lsls	r3, r3, #9
 800d734:	429a      	cmp	r2, r3
 800d736:	d204      	bcs.n	800d742 <UART_SetConfig+0x622>
    {
      huart->Instance->BRR = usartdiv;
 800d738:	69fb      	ldr	r3, [r7, #28]
 800d73a:	681b      	ldr	r3, [r3, #0]
 800d73c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d73e:	60da      	str	r2, [r3, #12]
 800d740:	e006      	b.n	800d750 <UART_SetConfig+0x630>
    }
    else
    {
      ret = HAL_ERROR;
 800d742:	2313      	movs	r3, #19
 800d744:	2218      	movs	r2, #24
 800d746:	4694      	mov	ip, r2
 800d748:	44bc      	add	ip, r7
 800d74a:	4463      	add	r3, ip
 800d74c:	2201      	movs	r2, #1
 800d74e:	701a      	strb	r2, [r3, #0]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 800d750:	69fb      	ldr	r3, [r7, #28]
 800d752:	2200      	movs	r2, #0
 800d754:	661a      	str	r2, [r3, #96]	; 0x60
  huart->TxISR = NULL;
 800d756:	69fb      	ldr	r3, [r7, #28]
 800d758:	2200      	movs	r2, #0
 800d75a:	665a      	str	r2, [r3, #100]	; 0x64

  return ret;
 800d75c:	2313      	movs	r3, #19
 800d75e:	2218      	movs	r2, #24
 800d760:	4694      	mov	ip, r2
 800d762:	44bc      	add	ip, r7
 800d764:	4463      	add	r3, ip
 800d766:	781b      	ldrb	r3, [r3, #0]
}
 800d768:	0018      	movs	r0, r3
 800d76a:	46bd      	mov	sp, r7
 800d76c:	b00e      	add	sp, #56	; 0x38
 800d76e:	bdb0      	pop	{r4, r5, r7, pc}
 800d770:	0801ee28 	.word	0x0801ee28
 800d774:	40021000 	.word	0x40021000
 800d778:	007a1200 	.word	0x007a1200
 800d77c:	01e84800 	.word	0x01e84800
 800d780:	0801ee4c 	.word	0x0801ee4c
 800d784:	003d0900 	.word	0x003d0900
 800d788:	00f42400 	.word	0x00f42400

0800d78c <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 800d78c:	b580      	push	{r7, lr}
 800d78e:	b082      	sub	sp, #8
 800d790:	af00      	add	r7, sp, #0
 800d792:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800d794:	687b      	ldr	r3, [r7, #4]
 800d796:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d798:	2201      	movs	r2, #1
 800d79a:	4013      	ands	r3, r2
 800d79c:	d00b      	beq.n	800d7b6 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800d79e:	687b      	ldr	r3, [r7, #4]
 800d7a0:	681b      	ldr	r3, [r3, #0]
 800d7a2:	685b      	ldr	r3, [r3, #4]
 800d7a4:	4a4a      	ldr	r2, [pc, #296]	; (800d8d0 <UART_AdvFeatureConfig+0x144>)
 800d7a6:	4013      	ands	r3, r2
 800d7a8:	0019      	movs	r1, r3
 800d7aa:	687b      	ldr	r3, [r7, #4]
 800d7ac:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d7ae:	687b      	ldr	r3, [r7, #4]
 800d7b0:	681b      	ldr	r3, [r3, #0]
 800d7b2:	430a      	orrs	r2, r1
 800d7b4:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800d7b6:	687b      	ldr	r3, [r7, #4]
 800d7b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d7ba:	2202      	movs	r2, #2
 800d7bc:	4013      	ands	r3, r2
 800d7be:	d00b      	beq.n	800d7d8 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800d7c0:	687b      	ldr	r3, [r7, #4]
 800d7c2:	681b      	ldr	r3, [r3, #0]
 800d7c4:	685b      	ldr	r3, [r3, #4]
 800d7c6:	4a43      	ldr	r2, [pc, #268]	; (800d8d4 <UART_AdvFeatureConfig+0x148>)
 800d7c8:	4013      	ands	r3, r2
 800d7ca:	0019      	movs	r1, r3
 800d7cc:	687b      	ldr	r3, [r7, #4]
 800d7ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d7d0:	687b      	ldr	r3, [r7, #4]
 800d7d2:	681b      	ldr	r3, [r3, #0]
 800d7d4:	430a      	orrs	r2, r1
 800d7d6:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800d7d8:	687b      	ldr	r3, [r7, #4]
 800d7da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d7dc:	2204      	movs	r2, #4
 800d7de:	4013      	ands	r3, r2
 800d7e0:	d00b      	beq.n	800d7fa <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800d7e2:	687b      	ldr	r3, [r7, #4]
 800d7e4:	681b      	ldr	r3, [r3, #0]
 800d7e6:	685b      	ldr	r3, [r3, #4]
 800d7e8:	4a3b      	ldr	r2, [pc, #236]	; (800d8d8 <UART_AdvFeatureConfig+0x14c>)
 800d7ea:	4013      	ands	r3, r2
 800d7ec:	0019      	movs	r1, r3
 800d7ee:	687b      	ldr	r3, [r7, #4]
 800d7f0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800d7f2:	687b      	ldr	r3, [r7, #4]
 800d7f4:	681b      	ldr	r3, [r3, #0]
 800d7f6:	430a      	orrs	r2, r1
 800d7f8:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800d7fa:	687b      	ldr	r3, [r7, #4]
 800d7fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d7fe:	2208      	movs	r2, #8
 800d800:	4013      	ands	r3, r2
 800d802:	d00b      	beq.n	800d81c <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800d804:	687b      	ldr	r3, [r7, #4]
 800d806:	681b      	ldr	r3, [r3, #0]
 800d808:	685b      	ldr	r3, [r3, #4]
 800d80a:	4a34      	ldr	r2, [pc, #208]	; (800d8dc <UART_AdvFeatureConfig+0x150>)
 800d80c:	4013      	ands	r3, r2
 800d80e:	0019      	movs	r1, r3
 800d810:	687b      	ldr	r3, [r7, #4]
 800d812:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d814:	687b      	ldr	r3, [r7, #4]
 800d816:	681b      	ldr	r3, [r3, #0]
 800d818:	430a      	orrs	r2, r1
 800d81a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800d81c:	687b      	ldr	r3, [r7, #4]
 800d81e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d820:	2210      	movs	r2, #16
 800d822:	4013      	ands	r3, r2
 800d824:	d00b      	beq.n	800d83e <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800d826:	687b      	ldr	r3, [r7, #4]
 800d828:	681b      	ldr	r3, [r3, #0]
 800d82a:	689b      	ldr	r3, [r3, #8]
 800d82c:	4a2c      	ldr	r2, [pc, #176]	; (800d8e0 <UART_AdvFeatureConfig+0x154>)
 800d82e:	4013      	ands	r3, r2
 800d830:	0019      	movs	r1, r3
 800d832:	687b      	ldr	r3, [r7, #4]
 800d834:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800d836:	687b      	ldr	r3, [r7, #4]
 800d838:	681b      	ldr	r3, [r3, #0]
 800d83a:	430a      	orrs	r2, r1
 800d83c:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800d83e:	687b      	ldr	r3, [r7, #4]
 800d840:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d842:	2220      	movs	r2, #32
 800d844:	4013      	ands	r3, r2
 800d846:	d00b      	beq.n	800d860 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800d848:	687b      	ldr	r3, [r7, #4]
 800d84a:	681b      	ldr	r3, [r3, #0]
 800d84c:	689b      	ldr	r3, [r3, #8]
 800d84e:	4a25      	ldr	r2, [pc, #148]	; (800d8e4 <UART_AdvFeatureConfig+0x158>)
 800d850:	4013      	ands	r3, r2
 800d852:	0019      	movs	r1, r3
 800d854:	687b      	ldr	r3, [r7, #4]
 800d856:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800d858:	687b      	ldr	r3, [r7, #4]
 800d85a:	681b      	ldr	r3, [r3, #0]
 800d85c:	430a      	orrs	r2, r1
 800d85e:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800d860:	687b      	ldr	r3, [r7, #4]
 800d862:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d864:	2240      	movs	r2, #64	; 0x40
 800d866:	4013      	ands	r3, r2
 800d868:	d01d      	beq.n	800d8a6 <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800d86a:	687b      	ldr	r3, [r7, #4]
 800d86c:	681b      	ldr	r3, [r3, #0]
 800d86e:	685b      	ldr	r3, [r3, #4]
 800d870:	4a1d      	ldr	r2, [pc, #116]	; (800d8e8 <UART_AdvFeatureConfig+0x15c>)
 800d872:	4013      	ands	r3, r2
 800d874:	0019      	movs	r1, r3
 800d876:	687b      	ldr	r3, [r7, #4]
 800d878:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800d87a:	687b      	ldr	r3, [r7, #4]
 800d87c:	681b      	ldr	r3, [r3, #0]
 800d87e:	430a      	orrs	r2, r1
 800d880:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800d882:	687b      	ldr	r3, [r7, #4]
 800d884:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800d886:	2380      	movs	r3, #128	; 0x80
 800d888:	035b      	lsls	r3, r3, #13
 800d88a:	429a      	cmp	r2, r3
 800d88c:	d10b      	bne.n	800d8a6 <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800d88e:	687b      	ldr	r3, [r7, #4]
 800d890:	681b      	ldr	r3, [r3, #0]
 800d892:	685b      	ldr	r3, [r3, #4]
 800d894:	4a15      	ldr	r2, [pc, #84]	; (800d8ec <UART_AdvFeatureConfig+0x160>)
 800d896:	4013      	ands	r3, r2
 800d898:	0019      	movs	r1, r3
 800d89a:	687b      	ldr	r3, [r7, #4]
 800d89c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800d89e:	687b      	ldr	r3, [r7, #4]
 800d8a0:	681b      	ldr	r3, [r3, #0]
 800d8a2:	430a      	orrs	r2, r1
 800d8a4:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800d8a6:	687b      	ldr	r3, [r7, #4]
 800d8a8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d8aa:	2280      	movs	r2, #128	; 0x80
 800d8ac:	4013      	ands	r3, r2
 800d8ae:	d00b      	beq.n	800d8c8 <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800d8b0:	687b      	ldr	r3, [r7, #4]
 800d8b2:	681b      	ldr	r3, [r3, #0]
 800d8b4:	685b      	ldr	r3, [r3, #4]
 800d8b6:	4a0e      	ldr	r2, [pc, #56]	; (800d8f0 <UART_AdvFeatureConfig+0x164>)
 800d8b8:	4013      	ands	r3, r2
 800d8ba:	0019      	movs	r1, r3
 800d8bc:	687b      	ldr	r3, [r7, #4]
 800d8be:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800d8c0:	687b      	ldr	r3, [r7, #4]
 800d8c2:	681b      	ldr	r3, [r3, #0]
 800d8c4:	430a      	orrs	r2, r1
 800d8c6:	605a      	str	r2, [r3, #4]
  }
}
 800d8c8:	46c0      	nop			; (mov r8, r8)
 800d8ca:	46bd      	mov	sp, r7
 800d8cc:	b002      	add	sp, #8
 800d8ce:	bd80      	pop	{r7, pc}
 800d8d0:	fffdffff 	.word	0xfffdffff
 800d8d4:	fffeffff 	.word	0xfffeffff
 800d8d8:	fffbffff 	.word	0xfffbffff
 800d8dc:	ffff7fff 	.word	0xffff7fff
 800d8e0:	ffffefff 	.word	0xffffefff
 800d8e4:	ffffdfff 	.word	0xffffdfff
 800d8e8:	ffefffff 	.word	0xffefffff
 800d8ec:	ff9fffff 	.word	0xff9fffff
 800d8f0:	fff7ffff 	.word	0xfff7ffff

0800d8f4 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800d8f4:	b580      	push	{r7, lr}
 800d8f6:	b086      	sub	sp, #24
 800d8f8:	af02      	add	r7, sp, #8
 800d8fa:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d8fc:	687b      	ldr	r3, [r7, #4]
 800d8fe:	2200      	movs	r2, #0
 800d900:	67da      	str	r2, [r3, #124]	; 0x7c

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 800d902:	f7fb fc1d 	bl	8009140 <HAL_GetTick>
 800d906:	0003      	movs	r3, r0
 800d908:	60fb      	str	r3, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800d90a:	687b      	ldr	r3, [r7, #4]
 800d90c:	681b      	ldr	r3, [r3, #0]
 800d90e:	681b      	ldr	r3, [r3, #0]
 800d910:	2208      	movs	r2, #8
 800d912:	4013      	ands	r3, r2
 800d914:	2b08      	cmp	r3, #8
 800d916:	d10c      	bne.n	800d932 <UART_CheckIdleState+0x3e>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800d918:	68fb      	ldr	r3, [r7, #12]
 800d91a:	2280      	movs	r2, #128	; 0x80
 800d91c:	0391      	lsls	r1, r2, #14
 800d91e:	6878      	ldr	r0, [r7, #4]
 800d920:	4a15      	ldr	r2, [pc, #84]	; (800d978 <UART_CheckIdleState+0x84>)
 800d922:	9200      	str	r2, [sp, #0]
 800d924:	2200      	movs	r2, #0
 800d926:	f000 f829 	bl	800d97c <UART_WaitOnFlagUntilTimeout>
 800d92a:	1e03      	subs	r3, r0, #0
 800d92c:	d001      	beq.n	800d932 <UART_CheckIdleState+0x3e>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800d92e:	2303      	movs	r3, #3
 800d930:	e01e      	b.n	800d970 <UART_CheckIdleState+0x7c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800d932:	687b      	ldr	r3, [r7, #4]
 800d934:	681b      	ldr	r3, [r3, #0]
 800d936:	681b      	ldr	r3, [r3, #0]
 800d938:	2204      	movs	r2, #4
 800d93a:	4013      	ands	r3, r2
 800d93c:	2b04      	cmp	r3, #4
 800d93e:	d10c      	bne.n	800d95a <UART_CheckIdleState+0x66>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800d940:	68fb      	ldr	r3, [r7, #12]
 800d942:	2280      	movs	r2, #128	; 0x80
 800d944:	03d1      	lsls	r1, r2, #15
 800d946:	6878      	ldr	r0, [r7, #4]
 800d948:	4a0b      	ldr	r2, [pc, #44]	; (800d978 <UART_CheckIdleState+0x84>)
 800d94a:	9200      	str	r2, [sp, #0]
 800d94c:	2200      	movs	r2, #0
 800d94e:	f000 f815 	bl	800d97c <UART_WaitOnFlagUntilTimeout>
 800d952:	1e03      	subs	r3, r0, #0
 800d954:	d001      	beq.n	800d95a <UART_CheckIdleState+0x66>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800d956:	2303      	movs	r3, #3
 800d958:	e00a      	b.n	800d970 <UART_CheckIdleState+0x7c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 800d95a:	687b      	ldr	r3, [r7, #4]
 800d95c:	2220      	movs	r2, #32
 800d95e:	675a      	str	r2, [r3, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_READY;
 800d960:	687b      	ldr	r3, [r7, #4]
 800d962:	2220      	movs	r2, #32
 800d964:	679a      	str	r2, [r3, #120]	; 0x78

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800d966:	687b      	ldr	r3, [r7, #4]
 800d968:	2270      	movs	r2, #112	; 0x70
 800d96a:	2100      	movs	r1, #0
 800d96c:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800d96e:	2300      	movs	r3, #0
}
 800d970:	0018      	movs	r0, r3
 800d972:	46bd      	mov	sp, r7
 800d974:	b004      	add	sp, #16
 800d976:	bd80      	pop	{r7, pc}
 800d978:	01ffffff 	.word	0x01ffffff

0800d97c <UART_WaitOnFlagUntilTimeout>:
  * @param Tickstart Tick start value
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 800d97c:	b580      	push	{r7, lr}
 800d97e:	b084      	sub	sp, #16
 800d980:	af00      	add	r7, sp, #0
 800d982:	60f8      	str	r0, [r7, #12]
 800d984:	60b9      	str	r1, [r7, #8]
 800d986:	603b      	str	r3, [r7, #0]
 800d988:	1dfb      	adds	r3, r7, #7
 800d98a:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800d98c:	e029      	b.n	800d9e2 <UART_WaitOnFlagUntilTimeout+0x66>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800d98e:	69bb      	ldr	r3, [r7, #24]
 800d990:	3301      	adds	r3, #1
 800d992:	d026      	beq.n	800d9e2 <UART_WaitOnFlagUntilTimeout+0x66>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800d994:	f7fb fbd4 	bl	8009140 <HAL_GetTick>
 800d998:	0002      	movs	r2, r0
 800d99a:	683b      	ldr	r3, [r7, #0]
 800d99c:	1ad3      	subs	r3, r2, r3
 800d99e:	69ba      	ldr	r2, [r7, #24]
 800d9a0:	429a      	cmp	r2, r3
 800d9a2:	d302      	bcc.n	800d9aa <UART_WaitOnFlagUntilTimeout+0x2e>
 800d9a4:	69bb      	ldr	r3, [r7, #24]
 800d9a6:	2b00      	cmp	r3, #0
 800d9a8:	d11b      	bne.n	800d9e2 <UART_WaitOnFlagUntilTimeout+0x66>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800d9aa:	68fb      	ldr	r3, [r7, #12]
 800d9ac:	681b      	ldr	r3, [r3, #0]
 800d9ae:	681a      	ldr	r2, [r3, #0]
 800d9b0:	68fb      	ldr	r3, [r7, #12]
 800d9b2:	681b      	ldr	r3, [r3, #0]
 800d9b4:	4915      	ldr	r1, [pc, #84]	; (800da0c <UART_WaitOnFlagUntilTimeout+0x90>)
 800d9b6:	400a      	ands	r2, r1
 800d9b8:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800d9ba:	68fb      	ldr	r3, [r7, #12]
 800d9bc:	681b      	ldr	r3, [r3, #0]
 800d9be:	689a      	ldr	r2, [r3, #8]
 800d9c0:	68fb      	ldr	r3, [r7, #12]
 800d9c2:	681b      	ldr	r3, [r3, #0]
 800d9c4:	2101      	movs	r1, #1
 800d9c6:	438a      	bics	r2, r1
 800d9c8:	609a      	str	r2, [r3, #8]

        huart->gState = HAL_UART_STATE_READY;
 800d9ca:	68fb      	ldr	r3, [r7, #12]
 800d9cc:	2220      	movs	r2, #32
 800d9ce:	675a      	str	r2, [r3, #116]	; 0x74
        huart->RxState = HAL_UART_STATE_READY;
 800d9d0:	68fb      	ldr	r3, [r7, #12]
 800d9d2:	2220      	movs	r2, #32
 800d9d4:	679a      	str	r2, [r3, #120]	; 0x78

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 800d9d6:	68fb      	ldr	r3, [r7, #12]
 800d9d8:	2270      	movs	r2, #112	; 0x70
 800d9da:	2100      	movs	r1, #0
 800d9dc:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 800d9de:	2303      	movs	r3, #3
 800d9e0:	e00f      	b.n	800da02 <UART_WaitOnFlagUntilTimeout+0x86>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800d9e2:	68fb      	ldr	r3, [r7, #12]
 800d9e4:	681b      	ldr	r3, [r3, #0]
 800d9e6:	69db      	ldr	r3, [r3, #28]
 800d9e8:	68ba      	ldr	r2, [r7, #8]
 800d9ea:	4013      	ands	r3, r2
 800d9ec:	68ba      	ldr	r2, [r7, #8]
 800d9ee:	1ad3      	subs	r3, r2, r3
 800d9f0:	425a      	negs	r2, r3
 800d9f2:	4153      	adcs	r3, r2
 800d9f4:	b2db      	uxtb	r3, r3
 800d9f6:	001a      	movs	r2, r3
 800d9f8:	1dfb      	adds	r3, r7, #7
 800d9fa:	781b      	ldrb	r3, [r3, #0]
 800d9fc:	429a      	cmp	r2, r3
 800d9fe:	d0c6      	beq.n	800d98e <UART_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 800da00:	2300      	movs	r3, #0
}
 800da02:	0018      	movs	r0, r3
 800da04:	46bd      	mov	sp, r7
 800da06:	b004      	add	sp, #16
 800da08:	bd80      	pop	{r7, pc}
 800da0a:	46c0      	nop			; (mov r8, r8)
 800da0c:	fffffe5f 	.word	0xfffffe5f

0800da10 <UART_EndTxTransfer>:
  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
 800da10:	b580      	push	{r7, lr}
 800da12:	b082      	sub	sp, #8
 800da14:	af00      	add	r7, sp, #0
 800da16:	6078      	str	r0, [r7, #4]
  /* Disable TXEIE and TCIE interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 800da18:	687b      	ldr	r3, [r7, #4]
 800da1a:	681b      	ldr	r3, [r3, #0]
 800da1c:	681a      	ldr	r2, [r3, #0]
 800da1e:	687b      	ldr	r3, [r7, #4]
 800da20:	681b      	ldr	r3, [r3, #0]
 800da22:	21c0      	movs	r1, #192	; 0xc0
 800da24:	438a      	bics	r2, r1
 800da26:	601a      	str	r2, [r3, #0]

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800da28:	687b      	ldr	r3, [r7, #4]
 800da2a:	2220      	movs	r2, #32
 800da2c:	675a      	str	r2, [r3, #116]	; 0x74
}
 800da2e:	46c0      	nop			; (mov r8, r8)
 800da30:	46bd      	mov	sp, r7
 800da32:	b002      	add	sp, #8
 800da34:	bd80      	pop	{r7, pc}
	...

0800da38 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 800da38:	b580      	push	{r7, lr}
 800da3a:	b082      	sub	sp, #8
 800da3c:	af00      	add	r7, sp, #0
 800da3e:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800da40:	687b      	ldr	r3, [r7, #4]
 800da42:	681b      	ldr	r3, [r3, #0]
 800da44:	681a      	ldr	r2, [r3, #0]
 800da46:	687b      	ldr	r3, [r7, #4]
 800da48:	681b      	ldr	r3, [r3, #0]
 800da4a:	490a      	ldr	r1, [pc, #40]	; (800da74 <UART_EndRxTransfer+0x3c>)
 800da4c:	400a      	ands	r2, r1
 800da4e:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800da50:	687b      	ldr	r3, [r7, #4]
 800da52:	681b      	ldr	r3, [r3, #0]
 800da54:	689a      	ldr	r2, [r3, #8]
 800da56:	687b      	ldr	r3, [r7, #4]
 800da58:	681b      	ldr	r3, [r3, #0]
 800da5a:	2101      	movs	r1, #1
 800da5c:	438a      	bics	r2, r1
 800da5e:	609a      	str	r2, [r3, #8]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 800da60:	687b      	ldr	r3, [r7, #4]
 800da62:	2220      	movs	r2, #32
 800da64:	679a      	str	r2, [r3, #120]	; 0x78

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 800da66:	687b      	ldr	r3, [r7, #4]
 800da68:	2200      	movs	r2, #0
 800da6a:	661a      	str	r2, [r3, #96]	; 0x60
}
 800da6c:	46c0      	nop			; (mov r8, r8)
 800da6e:	46bd      	mov	sp, r7
 800da70:	b002      	add	sp, #8
 800da72:	bd80      	pop	{r7, pc}
 800da74:	fffffedf 	.word	0xfffffedf

0800da78 <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 800da78:	b580      	push	{r7, lr}
 800da7a:	b084      	sub	sp, #16
 800da7c:	af00      	add	r7, sp, #0
 800da7e:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800da80:	687b      	ldr	r3, [r7, #4]
 800da82:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800da84:	60fb      	str	r3, [r7, #12]

  /* DMA Normal mode */
  if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
 800da86:	687b      	ldr	r3, [r7, #4]
 800da88:	681b      	ldr	r3, [r3, #0]
 800da8a:	681b      	ldr	r3, [r3, #0]
 800da8c:	2220      	movs	r2, #32
 800da8e:	4013      	ands	r3, r2
 800da90:	d114      	bne.n	800dabc <UART_DMATransmitCplt+0x44>
  {
    huart->TxXferCount = 0U;
 800da92:	68fb      	ldr	r3, [r7, #12]
 800da94:	2252      	movs	r2, #82	; 0x52
 800da96:	2100      	movs	r1, #0
 800da98:	5299      	strh	r1, [r3, r2]

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800da9a:	68fb      	ldr	r3, [r7, #12]
 800da9c:	681b      	ldr	r3, [r3, #0]
 800da9e:	689a      	ldr	r2, [r3, #8]
 800daa0:	68fb      	ldr	r3, [r7, #12]
 800daa2:	681b      	ldr	r3, [r3, #0]
 800daa4:	2180      	movs	r1, #128	; 0x80
 800daa6:	438a      	bics	r2, r1
 800daa8:	609a      	str	r2, [r3, #8]

    /* Enable the UART Transmit Complete Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800daaa:	68fb      	ldr	r3, [r7, #12]
 800daac:	681b      	ldr	r3, [r3, #0]
 800daae:	681a      	ldr	r2, [r3, #0]
 800dab0:	68fb      	ldr	r3, [r7, #12]
 800dab2:	681b      	ldr	r3, [r3, #0]
 800dab4:	2140      	movs	r1, #64	; 0x40
 800dab6:	430a      	orrs	r2, r1
 800dab8:	601a      	str	r2, [r3, #0]
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 800daba:	e003      	b.n	800dac4 <UART_DMATransmitCplt+0x4c>
    HAL_UART_TxCpltCallback(huart);
 800dabc:	68fb      	ldr	r3, [r7, #12]
 800dabe:	0018      	movs	r0, r3
 800dac0:	f00f fc44 	bl	801d34c <HAL_UART_TxCpltCallback>
}
 800dac4:	46c0      	nop			; (mov r8, r8)
 800dac6:	46bd      	mov	sp, r7
 800dac8:	b004      	add	sp, #16
 800daca:	bd80      	pop	{r7, pc}

0800dacc <UART_DMATxHalfCplt>:
  * @brief DMA UART transmit process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800dacc:	b580      	push	{r7, lr}
 800dace:	b084      	sub	sp, #16
 800dad0:	af00      	add	r7, sp, #0
 800dad2:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800dad4:	687b      	ldr	r3, [r7, #4]
 800dad6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800dad8:	60fb      	str	r3, [r7, #12]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx Half complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx Half complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 800dada:	68fb      	ldr	r3, [r7, #12]
 800dadc:	0018      	movs	r0, r3
 800dade:	f7ff fb0f 	bl	800d100 <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800dae2:	46c0      	nop			; (mov r8, r8)
 800dae4:	46bd      	mov	sp, r7
 800dae6:	b004      	add	sp, #16
 800dae8:	bd80      	pop	{r7, pc}

0800daea <UART_DMAError>:
  * @brief DMA UART communication error callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
 800daea:	b580      	push	{r7, lr}
 800daec:	b086      	sub	sp, #24
 800daee:	af00      	add	r7, sp, #0
 800daf0:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800daf2:	687b      	ldr	r3, [r7, #4]
 800daf4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800daf6:	617b      	str	r3, [r7, #20]

  const HAL_UART_StateTypeDef gstate = huart->gState;
 800daf8:	697b      	ldr	r3, [r7, #20]
 800dafa:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800dafc:	613b      	str	r3, [r7, #16]
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 800dafe:	697b      	ldr	r3, [r7, #20]
 800db00:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800db02:	60fb      	str	r3, [r7, #12]

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 800db04:	697b      	ldr	r3, [r7, #20]
 800db06:	681b      	ldr	r3, [r3, #0]
 800db08:	689b      	ldr	r3, [r3, #8]
 800db0a:	2280      	movs	r2, #128	; 0x80
 800db0c:	4013      	ands	r3, r2
 800db0e:	2b80      	cmp	r3, #128	; 0x80
 800db10:	d10a      	bne.n	800db28 <UART_DMAError+0x3e>
 800db12:	693b      	ldr	r3, [r7, #16]
 800db14:	2b21      	cmp	r3, #33	; 0x21
 800db16:	d107      	bne.n	800db28 <UART_DMAError+0x3e>
      (gstate == HAL_UART_STATE_BUSY_TX))
  {
    huart->TxXferCount = 0U;
 800db18:	697b      	ldr	r3, [r7, #20]
 800db1a:	2252      	movs	r2, #82	; 0x52
 800db1c:	2100      	movs	r1, #0
 800db1e:	5299      	strh	r1, [r3, r2]
    UART_EndTxTransfer(huart);
 800db20:	697b      	ldr	r3, [r7, #20]
 800db22:	0018      	movs	r0, r3
 800db24:	f7ff ff74 	bl	800da10 <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 800db28:	697b      	ldr	r3, [r7, #20]
 800db2a:	681b      	ldr	r3, [r3, #0]
 800db2c:	689b      	ldr	r3, [r3, #8]
 800db2e:	2240      	movs	r2, #64	; 0x40
 800db30:	4013      	ands	r3, r2
 800db32:	2b40      	cmp	r3, #64	; 0x40
 800db34:	d10a      	bne.n	800db4c <UART_DMAError+0x62>
 800db36:	68fb      	ldr	r3, [r7, #12]
 800db38:	2b22      	cmp	r3, #34	; 0x22
 800db3a:	d107      	bne.n	800db4c <UART_DMAError+0x62>
      (rxstate == HAL_UART_STATE_BUSY_RX))
  {
    huart->RxXferCount = 0U;
 800db3c:	697b      	ldr	r3, [r7, #20]
 800db3e:	225a      	movs	r2, #90	; 0x5a
 800db40:	2100      	movs	r1, #0
 800db42:	5299      	strh	r1, [r3, r2]
    UART_EndRxTransfer(huart);
 800db44:	697b      	ldr	r3, [r7, #20]
 800db46:	0018      	movs	r0, r3
 800db48:	f7ff ff76 	bl	800da38 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 800db4c:	697b      	ldr	r3, [r7, #20]
 800db4e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800db50:	2210      	movs	r2, #16
 800db52:	431a      	orrs	r2, r3
 800db54:	697b      	ldr	r3, [r7, #20]
 800db56:	67da      	str	r2, [r3, #124]	; 0x7c
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 800db58:	697b      	ldr	r3, [r7, #20]
 800db5a:	0018      	movs	r0, r3
 800db5c:	f7ff fad8 	bl	800d110 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800db60:	46c0      	nop			; (mov r8, r8)
 800db62:	46bd      	mov	sp, r7
 800db64:	b006      	add	sp, #24
 800db66:	bd80      	pop	{r7, pc}

0800db68 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 800db68:	b580      	push	{r7, lr}
 800db6a:	b084      	sub	sp, #16
 800db6c:	af00      	add	r7, sp, #0
 800db6e:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800db70:	687b      	ldr	r3, [r7, #4]
 800db72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800db74:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0U;
 800db76:	68fb      	ldr	r3, [r7, #12]
 800db78:	225a      	movs	r2, #90	; 0x5a
 800db7a:	2100      	movs	r1, #0
 800db7c:	5299      	strh	r1, [r3, r2]
  huart->TxXferCount = 0U;
 800db7e:	68fb      	ldr	r3, [r7, #12]
 800db80:	2252      	movs	r2, #82	; 0x52
 800db82:	2100      	movs	r1, #0
 800db84:	5299      	strh	r1, [r3, r2]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 800db86:	68fb      	ldr	r3, [r7, #12]
 800db88:	0018      	movs	r0, r3
 800db8a:	f7ff fac1 	bl	800d110 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800db8e:	46c0      	nop			; (mov r8, r8)
 800db90:	46bd      	mov	sp, r7
 800db92:	b004      	add	sp, #16
 800db94:	bd80      	pop	{r7, pc}

0800db96 <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 800db96:	b580      	push	{r7, lr}
 800db98:	b082      	sub	sp, #8
 800db9a:	af00      	add	r7, sp, #0
 800db9c:	6078      	str	r0, [r7, #4]
  /* Disable the UART Transmit Complete Interrupt */
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800db9e:	687b      	ldr	r3, [r7, #4]
 800dba0:	681b      	ldr	r3, [r3, #0]
 800dba2:	681a      	ldr	r2, [r3, #0]
 800dba4:	687b      	ldr	r3, [r7, #4]
 800dba6:	681b      	ldr	r3, [r3, #0]
 800dba8:	2140      	movs	r1, #64	; 0x40
 800dbaa:	438a      	bics	r2, r1
 800dbac:	601a      	str	r2, [r3, #0]

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800dbae:	687b      	ldr	r3, [r7, #4]
 800dbb0:	2220      	movs	r2, #32
 800dbb2:	675a      	str	r2, [r3, #116]	; 0x74

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 800dbb4:	687b      	ldr	r3, [r7, #4]
 800dbb6:	2200      	movs	r2, #0
 800dbb8:	665a      	str	r2, [r3, #100]	; 0x64
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 800dbba:	687b      	ldr	r3, [r7, #4]
 800dbbc:	0018      	movs	r0, r3
 800dbbe:	f00f fbc5 	bl	801d34c <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800dbc2:	46c0      	nop			; (mov r8, r8)
 800dbc4:	46bd      	mov	sp, r7
 800dbc6:	b002      	add	sp, #8
 800dbc8:	bd80      	pop	{r7, pc}

0800dbca <HAL_UARTEx_WakeupCallback>:
  * @brief UART wakeup from Stop mode callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
{
 800dbca:	b580      	push	{r7, lr}
 800dbcc:	b082      	sub	sp, #8
 800dbce:	af00      	add	r7, sp, #0
 800dbd0:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 800dbd2:	46c0      	nop			; (mov r8, r8)
 800dbd4:	46bd      	mov	sp, r7
 800dbd6:	b002      	add	sp, #8
 800dbd8:	bd80      	pop	{r7, pc}

0800dbda <copy_block>:
#  define block_copy_nn(d, s, l)    copy_block_nn(d, s, l)
#  define block_copy(d, s)          copy_block(d, s)
#endif

static void copy_block( void *d, const void *s )
{
 800dbda:	b580      	push	{r7, lr}
 800dbdc:	b082      	sub	sp, #8
 800dbde:	af00      	add	r7, sp, #0
 800dbe0:	6078      	str	r0, [r7, #4]
 800dbe2:	6039      	str	r1, [r7, #0]
    ((uint32_t*)d)[ 0] = ((uint32_t*)s)[ 0];
    ((uint32_t*)d)[ 1] = ((uint32_t*)s)[ 1];
    ((uint32_t*)d)[ 2] = ((uint32_t*)s)[ 2];
    ((uint32_t*)d)[ 3] = ((uint32_t*)s)[ 3];
#else
    ((uint8_t*)d)[ 0] = ((uint8_t*)s)[ 0];
 800dbe4:	683b      	ldr	r3, [r7, #0]
 800dbe6:	781a      	ldrb	r2, [r3, #0]
 800dbe8:	687b      	ldr	r3, [r7, #4]
 800dbea:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 1] = ((uint8_t*)s)[ 1];
 800dbec:	687b      	ldr	r3, [r7, #4]
 800dbee:	3301      	adds	r3, #1
 800dbf0:	683a      	ldr	r2, [r7, #0]
 800dbf2:	7852      	ldrb	r2, [r2, #1]
 800dbf4:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 2] = ((uint8_t*)s)[ 2];
 800dbf6:	687b      	ldr	r3, [r7, #4]
 800dbf8:	3302      	adds	r3, #2
 800dbfa:	683a      	ldr	r2, [r7, #0]
 800dbfc:	7892      	ldrb	r2, [r2, #2]
 800dbfe:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 3] = ((uint8_t*)s)[ 3];
 800dc00:	687b      	ldr	r3, [r7, #4]
 800dc02:	3303      	adds	r3, #3
 800dc04:	683a      	ldr	r2, [r7, #0]
 800dc06:	78d2      	ldrb	r2, [r2, #3]
 800dc08:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 4] = ((uint8_t*)s)[ 4];
 800dc0a:	687b      	ldr	r3, [r7, #4]
 800dc0c:	3304      	adds	r3, #4
 800dc0e:	683a      	ldr	r2, [r7, #0]
 800dc10:	7912      	ldrb	r2, [r2, #4]
 800dc12:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 5] = ((uint8_t*)s)[ 5];
 800dc14:	687b      	ldr	r3, [r7, #4]
 800dc16:	3305      	adds	r3, #5
 800dc18:	683a      	ldr	r2, [r7, #0]
 800dc1a:	7952      	ldrb	r2, [r2, #5]
 800dc1c:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 6] = ((uint8_t*)s)[ 6];
 800dc1e:	687b      	ldr	r3, [r7, #4]
 800dc20:	3306      	adds	r3, #6
 800dc22:	683a      	ldr	r2, [r7, #0]
 800dc24:	7992      	ldrb	r2, [r2, #6]
 800dc26:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 7] = ((uint8_t*)s)[ 7];
 800dc28:	687b      	ldr	r3, [r7, #4]
 800dc2a:	3307      	adds	r3, #7
 800dc2c:	683a      	ldr	r2, [r7, #0]
 800dc2e:	79d2      	ldrb	r2, [r2, #7]
 800dc30:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 8] = ((uint8_t*)s)[ 8];
 800dc32:	687b      	ldr	r3, [r7, #4]
 800dc34:	3308      	adds	r3, #8
 800dc36:	683a      	ldr	r2, [r7, #0]
 800dc38:	7a12      	ldrb	r2, [r2, #8]
 800dc3a:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 9] = ((uint8_t*)s)[ 9];
 800dc3c:	687b      	ldr	r3, [r7, #4]
 800dc3e:	3309      	adds	r3, #9
 800dc40:	683a      	ldr	r2, [r7, #0]
 800dc42:	7a52      	ldrb	r2, [r2, #9]
 800dc44:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[10] = ((uint8_t*)s)[10];
 800dc46:	687b      	ldr	r3, [r7, #4]
 800dc48:	330a      	adds	r3, #10
 800dc4a:	683a      	ldr	r2, [r7, #0]
 800dc4c:	7a92      	ldrb	r2, [r2, #10]
 800dc4e:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[11] = ((uint8_t*)s)[11];
 800dc50:	687b      	ldr	r3, [r7, #4]
 800dc52:	330b      	adds	r3, #11
 800dc54:	683a      	ldr	r2, [r7, #0]
 800dc56:	7ad2      	ldrb	r2, [r2, #11]
 800dc58:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[12] = ((uint8_t*)s)[12];
 800dc5a:	687b      	ldr	r3, [r7, #4]
 800dc5c:	330c      	adds	r3, #12
 800dc5e:	683a      	ldr	r2, [r7, #0]
 800dc60:	7b12      	ldrb	r2, [r2, #12]
 800dc62:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[13] = ((uint8_t*)s)[13];
 800dc64:	687b      	ldr	r3, [r7, #4]
 800dc66:	330d      	adds	r3, #13
 800dc68:	683a      	ldr	r2, [r7, #0]
 800dc6a:	7b52      	ldrb	r2, [r2, #13]
 800dc6c:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[14] = ((uint8_t*)s)[14];
 800dc6e:	687b      	ldr	r3, [r7, #4]
 800dc70:	330e      	adds	r3, #14
 800dc72:	683a      	ldr	r2, [r7, #0]
 800dc74:	7b92      	ldrb	r2, [r2, #14]
 800dc76:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[15] = ((uint8_t*)s)[15];
 800dc78:	687b      	ldr	r3, [r7, #4]
 800dc7a:	330f      	adds	r3, #15
 800dc7c:	683a      	ldr	r2, [r7, #0]
 800dc7e:	7bd2      	ldrb	r2, [r2, #15]
 800dc80:	701a      	strb	r2, [r3, #0]
#endif
}
 800dc82:	46c0      	nop			; (mov r8, r8)
 800dc84:	46bd      	mov	sp, r7
 800dc86:	b002      	add	sp, #8
 800dc88:	bd80      	pop	{r7, pc}

0800dc8a <copy_block_nn>:

static void copy_block_nn( uint8_t * d, const uint8_t *s, uint8_t nn )
{
 800dc8a:	b580      	push	{r7, lr}
 800dc8c:	b084      	sub	sp, #16
 800dc8e:	af00      	add	r7, sp, #0
 800dc90:	60f8      	str	r0, [r7, #12]
 800dc92:	60b9      	str	r1, [r7, #8]
 800dc94:	1dfb      	adds	r3, r7, #7
 800dc96:	701a      	strb	r2, [r3, #0]
    while( nn-- )
 800dc98:	e007      	b.n	800dcaa <copy_block_nn+0x20>
        //*((uint8_t*)d)++ = *((uint8_t*)s)++;
        *d++ = *s++;
 800dc9a:	68ba      	ldr	r2, [r7, #8]
 800dc9c:	1c53      	adds	r3, r2, #1
 800dc9e:	60bb      	str	r3, [r7, #8]
 800dca0:	68fb      	ldr	r3, [r7, #12]
 800dca2:	1c59      	adds	r1, r3, #1
 800dca4:	60f9      	str	r1, [r7, #12]
 800dca6:	7812      	ldrb	r2, [r2, #0]
 800dca8:	701a      	strb	r2, [r3, #0]
    while( nn-- )
 800dcaa:	1dfb      	adds	r3, r7, #7
 800dcac:	781b      	ldrb	r3, [r3, #0]
 800dcae:	1dfa      	adds	r2, r7, #7
 800dcb0:	1e59      	subs	r1, r3, #1
 800dcb2:	7011      	strb	r1, [r2, #0]
 800dcb4:	2b00      	cmp	r3, #0
 800dcb6:	d1f0      	bne.n	800dc9a <copy_block_nn+0x10>
}
 800dcb8:	46c0      	nop			; (mov r8, r8)
 800dcba:	46c0      	nop			; (mov r8, r8)
 800dcbc:	46bd      	mov	sp, r7
 800dcbe:	b004      	add	sp, #16
 800dcc0:	bd80      	pop	{r7, pc}

0800dcc2 <xor_block>:

static void xor_block( void *d, const void *s )
{
 800dcc2:	b580      	push	{r7, lr}
 800dcc4:	b082      	sub	sp, #8
 800dcc6:	af00      	add	r7, sp, #0
 800dcc8:	6078      	str	r0, [r7, #4]
 800dcca:	6039      	str	r1, [r7, #0]
    ((uint32_t*)d)[ 0] ^= ((uint32_t*)s)[ 0];
    ((uint32_t*)d)[ 1] ^= ((uint32_t*)s)[ 1];
    ((uint32_t*)d)[ 2] ^= ((uint32_t*)s)[ 2];
    ((uint32_t*)d)[ 3] ^= ((uint32_t*)s)[ 3];
#else
    ((uint8_t*)d)[ 0] ^= ((uint8_t*)s)[ 0];
 800dccc:	687b      	ldr	r3, [r7, #4]
 800dcce:	781a      	ldrb	r2, [r3, #0]
 800dcd0:	683b      	ldr	r3, [r7, #0]
 800dcd2:	781b      	ldrb	r3, [r3, #0]
 800dcd4:	4053      	eors	r3, r2
 800dcd6:	b2da      	uxtb	r2, r3
 800dcd8:	687b      	ldr	r3, [r7, #4]
 800dcda:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 1] ^= ((uint8_t*)s)[ 1];
 800dcdc:	687b      	ldr	r3, [r7, #4]
 800dcde:	3301      	adds	r3, #1
 800dce0:	7819      	ldrb	r1, [r3, #0]
 800dce2:	683b      	ldr	r3, [r7, #0]
 800dce4:	3301      	adds	r3, #1
 800dce6:	781a      	ldrb	r2, [r3, #0]
 800dce8:	687b      	ldr	r3, [r7, #4]
 800dcea:	3301      	adds	r3, #1
 800dcec:	404a      	eors	r2, r1
 800dcee:	b2d2      	uxtb	r2, r2
 800dcf0:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 2] ^= ((uint8_t*)s)[ 2];
 800dcf2:	687b      	ldr	r3, [r7, #4]
 800dcf4:	3302      	adds	r3, #2
 800dcf6:	7819      	ldrb	r1, [r3, #0]
 800dcf8:	683b      	ldr	r3, [r7, #0]
 800dcfa:	3302      	adds	r3, #2
 800dcfc:	781a      	ldrb	r2, [r3, #0]
 800dcfe:	687b      	ldr	r3, [r7, #4]
 800dd00:	3302      	adds	r3, #2
 800dd02:	404a      	eors	r2, r1
 800dd04:	b2d2      	uxtb	r2, r2
 800dd06:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 3] ^= ((uint8_t*)s)[ 3];
 800dd08:	687b      	ldr	r3, [r7, #4]
 800dd0a:	3303      	adds	r3, #3
 800dd0c:	7819      	ldrb	r1, [r3, #0]
 800dd0e:	683b      	ldr	r3, [r7, #0]
 800dd10:	3303      	adds	r3, #3
 800dd12:	781a      	ldrb	r2, [r3, #0]
 800dd14:	687b      	ldr	r3, [r7, #4]
 800dd16:	3303      	adds	r3, #3
 800dd18:	404a      	eors	r2, r1
 800dd1a:	b2d2      	uxtb	r2, r2
 800dd1c:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 4] ^= ((uint8_t*)s)[ 4];
 800dd1e:	687b      	ldr	r3, [r7, #4]
 800dd20:	3304      	adds	r3, #4
 800dd22:	7819      	ldrb	r1, [r3, #0]
 800dd24:	683b      	ldr	r3, [r7, #0]
 800dd26:	3304      	adds	r3, #4
 800dd28:	781a      	ldrb	r2, [r3, #0]
 800dd2a:	687b      	ldr	r3, [r7, #4]
 800dd2c:	3304      	adds	r3, #4
 800dd2e:	404a      	eors	r2, r1
 800dd30:	b2d2      	uxtb	r2, r2
 800dd32:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 5] ^= ((uint8_t*)s)[ 5];
 800dd34:	687b      	ldr	r3, [r7, #4]
 800dd36:	3305      	adds	r3, #5
 800dd38:	7819      	ldrb	r1, [r3, #0]
 800dd3a:	683b      	ldr	r3, [r7, #0]
 800dd3c:	3305      	adds	r3, #5
 800dd3e:	781a      	ldrb	r2, [r3, #0]
 800dd40:	687b      	ldr	r3, [r7, #4]
 800dd42:	3305      	adds	r3, #5
 800dd44:	404a      	eors	r2, r1
 800dd46:	b2d2      	uxtb	r2, r2
 800dd48:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 6] ^= ((uint8_t*)s)[ 6];
 800dd4a:	687b      	ldr	r3, [r7, #4]
 800dd4c:	3306      	adds	r3, #6
 800dd4e:	7819      	ldrb	r1, [r3, #0]
 800dd50:	683b      	ldr	r3, [r7, #0]
 800dd52:	3306      	adds	r3, #6
 800dd54:	781a      	ldrb	r2, [r3, #0]
 800dd56:	687b      	ldr	r3, [r7, #4]
 800dd58:	3306      	adds	r3, #6
 800dd5a:	404a      	eors	r2, r1
 800dd5c:	b2d2      	uxtb	r2, r2
 800dd5e:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 7] ^= ((uint8_t*)s)[ 7];
 800dd60:	687b      	ldr	r3, [r7, #4]
 800dd62:	3307      	adds	r3, #7
 800dd64:	7819      	ldrb	r1, [r3, #0]
 800dd66:	683b      	ldr	r3, [r7, #0]
 800dd68:	3307      	adds	r3, #7
 800dd6a:	781a      	ldrb	r2, [r3, #0]
 800dd6c:	687b      	ldr	r3, [r7, #4]
 800dd6e:	3307      	adds	r3, #7
 800dd70:	404a      	eors	r2, r1
 800dd72:	b2d2      	uxtb	r2, r2
 800dd74:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 8] ^= ((uint8_t*)s)[ 8];
 800dd76:	687b      	ldr	r3, [r7, #4]
 800dd78:	3308      	adds	r3, #8
 800dd7a:	7819      	ldrb	r1, [r3, #0]
 800dd7c:	683b      	ldr	r3, [r7, #0]
 800dd7e:	3308      	adds	r3, #8
 800dd80:	781a      	ldrb	r2, [r3, #0]
 800dd82:	687b      	ldr	r3, [r7, #4]
 800dd84:	3308      	adds	r3, #8
 800dd86:	404a      	eors	r2, r1
 800dd88:	b2d2      	uxtb	r2, r2
 800dd8a:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 9] ^= ((uint8_t*)s)[ 9];
 800dd8c:	687b      	ldr	r3, [r7, #4]
 800dd8e:	3309      	adds	r3, #9
 800dd90:	7819      	ldrb	r1, [r3, #0]
 800dd92:	683b      	ldr	r3, [r7, #0]
 800dd94:	3309      	adds	r3, #9
 800dd96:	781a      	ldrb	r2, [r3, #0]
 800dd98:	687b      	ldr	r3, [r7, #4]
 800dd9a:	3309      	adds	r3, #9
 800dd9c:	404a      	eors	r2, r1
 800dd9e:	b2d2      	uxtb	r2, r2
 800dda0:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[10] ^= ((uint8_t*)s)[10];
 800dda2:	687b      	ldr	r3, [r7, #4]
 800dda4:	330a      	adds	r3, #10
 800dda6:	7819      	ldrb	r1, [r3, #0]
 800dda8:	683b      	ldr	r3, [r7, #0]
 800ddaa:	330a      	adds	r3, #10
 800ddac:	781a      	ldrb	r2, [r3, #0]
 800ddae:	687b      	ldr	r3, [r7, #4]
 800ddb0:	330a      	adds	r3, #10
 800ddb2:	404a      	eors	r2, r1
 800ddb4:	b2d2      	uxtb	r2, r2
 800ddb6:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[11] ^= ((uint8_t*)s)[11];
 800ddb8:	687b      	ldr	r3, [r7, #4]
 800ddba:	330b      	adds	r3, #11
 800ddbc:	7819      	ldrb	r1, [r3, #0]
 800ddbe:	683b      	ldr	r3, [r7, #0]
 800ddc0:	330b      	adds	r3, #11
 800ddc2:	781a      	ldrb	r2, [r3, #0]
 800ddc4:	687b      	ldr	r3, [r7, #4]
 800ddc6:	330b      	adds	r3, #11
 800ddc8:	404a      	eors	r2, r1
 800ddca:	b2d2      	uxtb	r2, r2
 800ddcc:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[12] ^= ((uint8_t*)s)[12];
 800ddce:	687b      	ldr	r3, [r7, #4]
 800ddd0:	330c      	adds	r3, #12
 800ddd2:	7819      	ldrb	r1, [r3, #0]
 800ddd4:	683b      	ldr	r3, [r7, #0]
 800ddd6:	330c      	adds	r3, #12
 800ddd8:	781a      	ldrb	r2, [r3, #0]
 800ddda:	687b      	ldr	r3, [r7, #4]
 800dddc:	330c      	adds	r3, #12
 800ddde:	404a      	eors	r2, r1
 800dde0:	b2d2      	uxtb	r2, r2
 800dde2:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[13] ^= ((uint8_t*)s)[13];
 800dde4:	687b      	ldr	r3, [r7, #4]
 800dde6:	330d      	adds	r3, #13
 800dde8:	7819      	ldrb	r1, [r3, #0]
 800ddea:	683b      	ldr	r3, [r7, #0]
 800ddec:	330d      	adds	r3, #13
 800ddee:	781a      	ldrb	r2, [r3, #0]
 800ddf0:	687b      	ldr	r3, [r7, #4]
 800ddf2:	330d      	adds	r3, #13
 800ddf4:	404a      	eors	r2, r1
 800ddf6:	b2d2      	uxtb	r2, r2
 800ddf8:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[14] ^= ((uint8_t*)s)[14];
 800ddfa:	687b      	ldr	r3, [r7, #4]
 800ddfc:	330e      	adds	r3, #14
 800ddfe:	7819      	ldrb	r1, [r3, #0]
 800de00:	683b      	ldr	r3, [r7, #0]
 800de02:	330e      	adds	r3, #14
 800de04:	781a      	ldrb	r2, [r3, #0]
 800de06:	687b      	ldr	r3, [r7, #4]
 800de08:	330e      	adds	r3, #14
 800de0a:	404a      	eors	r2, r1
 800de0c:	b2d2      	uxtb	r2, r2
 800de0e:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[15] ^= ((uint8_t*)s)[15];
 800de10:	687b      	ldr	r3, [r7, #4]
 800de12:	330f      	adds	r3, #15
 800de14:	7819      	ldrb	r1, [r3, #0]
 800de16:	683b      	ldr	r3, [r7, #0]
 800de18:	330f      	adds	r3, #15
 800de1a:	781a      	ldrb	r2, [r3, #0]
 800de1c:	687b      	ldr	r3, [r7, #4]
 800de1e:	330f      	adds	r3, #15
 800de20:	404a      	eors	r2, r1
 800de22:	b2d2      	uxtb	r2, r2
 800de24:	701a      	strb	r2, [r3, #0]
#endif
}
 800de26:	46c0      	nop			; (mov r8, r8)
 800de28:	46bd      	mov	sp, r7
 800de2a:	b002      	add	sp, #8
 800de2c:	bd80      	pop	{r7, pc}

0800de2e <copy_and_key>:

static void copy_and_key( void *d, const void *s, const void *k )
{
 800de2e:	b580      	push	{r7, lr}
 800de30:	b084      	sub	sp, #16
 800de32:	af00      	add	r7, sp, #0
 800de34:	60f8      	str	r0, [r7, #12]
 800de36:	60b9      	str	r1, [r7, #8]
 800de38:	607a      	str	r2, [r7, #4]
    ((uint32_t*)d)[ 0] = ((uint32_t*)s)[ 0] ^ ((uint32_t*)k)[ 0];
    ((uint32_t*)d)[ 1] = ((uint32_t*)s)[ 1] ^ ((uint32_t*)k)[ 1];
    ((uint32_t*)d)[ 2] = ((uint32_t*)s)[ 2] ^ ((uint32_t*)k)[ 2];
    ((uint32_t*)d)[ 3] = ((uint32_t*)s)[ 3] ^ ((uint32_t*)k)[ 3];
#elif 1
    ((uint8_t*)d)[ 0] = ((uint8_t*)s)[ 0] ^ ((uint8_t*)k)[ 0];
 800de3a:	68bb      	ldr	r3, [r7, #8]
 800de3c:	781a      	ldrb	r2, [r3, #0]
 800de3e:	687b      	ldr	r3, [r7, #4]
 800de40:	781b      	ldrb	r3, [r3, #0]
 800de42:	4053      	eors	r3, r2
 800de44:	b2da      	uxtb	r2, r3
 800de46:	68fb      	ldr	r3, [r7, #12]
 800de48:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 1] = ((uint8_t*)s)[ 1] ^ ((uint8_t*)k)[ 1];
 800de4a:	68bb      	ldr	r3, [r7, #8]
 800de4c:	3301      	adds	r3, #1
 800de4e:	7819      	ldrb	r1, [r3, #0]
 800de50:	687b      	ldr	r3, [r7, #4]
 800de52:	3301      	adds	r3, #1
 800de54:	781a      	ldrb	r2, [r3, #0]
 800de56:	68fb      	ldr	r3, [r7, #12]
 800de58:	3301      	adds	r3, #1
 800de5a:	404a      	eors	r2, r1
 800de5c:	b2d2      	uxtb	r2, r2
 800de5e:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 2] = ((uint8_t*)s)[ 2] ^ ((uint8_t*)k)[ 2];
 800de60:	68bb      	ldr	r3, [r7, #8]
 800de62:	3302      	adds	r3, #2
 800de64:	7819      	ldrb	r1, [r3, #0]
 800de66:	687b      	ldr	r3, [r7, #4]
 800de68:	3302      	adds	r3, #2
 800de6a:	781a      	ldrb	r2, [r3, #0]
 800de6c:	68fb      	ldr	r3, [r7, #12]
 800de6e:	3302      	adds	r3, #2
 800de70:	404a      	eors	r2, r1
 800de72:	b2d2      	uxtb	r2, r2
 800de74:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 3] = ((uint8_t*)s)[ 3] ^ ((uint8_t*)k)[ 3];
 800de76:	68bb      	ldr	r3, [r7, #8]
 800de78:	3303      	adds	r3, #3
 800de7a:	7819      	ldrb	r1, [r3, #0]
 800de7c:	687b      	ldr	r3, [r7, #4]
 800de7e:	3303      	adds	r3, #3
 800de80:	781a      	ldrb	r2, [r3, #0]
 800de82:	68fb      	ldr	r3, [r7, #12]
 800de84:	3303      	adds	r3, #3
 800de86:	404a      	eors	r2, r1
 800de88:	b2d2      	uxtb	r2, r2
 800de8a:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 4] = ((uint8_t*)s)[ 4] ^ ((uint8_t*)k)[ 4];
 800de8c:	68bb      	ldr	r3, [r7, #8]
 800de8e:	3304      	adds	r3, #4
 800de90:	7819      	ldrb	r1, [r3, #0]
 800de92:	687b      	ldr	r3, [r7, #4]
 800de94:	3304      	adds	r3, #4
 800de96:	781a      	ldrb	r2, [r3, #0]
 800de98:	68fb      	ldr	r3, [r7, #12]
 800de9a:	3304      	adds	r3, #4
 800de9c:	404a      	eors	r2, r1
 800de9e:	b2d2      	uxtb	r2, r2
 800dea0:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 5] = ((uint8_t*)s)[ 5] ^ ((uint8_t*)k)[ 5];
 800dea2:	68bb      	ldr	r3, [r7, #8]
 800dea4:	3305      	adds	r3, #5
 800dea6:	7819      	ldrb	r1, [r3, #0]
 800dea8:	687b      	ldr	r3, [r7, #4]
 800deaa:	3305      	adds	r3, #5
 800deac:	781a      	ldrb	r2, [r3, #0]
 800deae:	68fb      	ldr	r3, [r7, #12]
 800deb0:	3305      	adds	r3, #5
 800deb2:	404a      	eors	r2, r1
 800deb4:	b2d2      	uxtb	r2, r2
 800deb6:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 6] = ((uint8_t*)s)[ 6] ^ ((uint8_t*)k)[ 6];
 800deb8:	68bb      	ldr	r3, [r7, #8]
 800deba:	3306      	adds	r3, #6
 800debc:	7819      	ldrb	r1, [r3, #0]
 800debe:	687b      	ldr	r3, [r7, #4]
 800dec0:	3306      	adds	r3, #6
 800dec2:	781a      	ldrb	r2, [r3, #0]
 800dec4:	68fb      	ldr	r3, [r7, #12]
 800dec6:	3306      	adds	r3, #6
 800dec8:	404a      	eors	r2, r1
 800deca:	b2d2      	uxtb	r2, r2
 800decc:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 7] = ((uint8_t*)s)[ 7] ^ ((uint8_t*)k)[ 7];
 800dece:	68bb      	ldr	r3, [r7, #8]
 800ded0:	3307      	adds	r3, #7
 800ded2:	7819      	ldrb	r1, [r3, #0]
 800ded4:	687b      	ldr	r3, [r7, #4]
 800ded6:	3307      	adds	r3, #7
 800ded8:	781a      	ldrb	r2, [r3, #0]
 800deda:	68fb      	ldr	r3, [r7, #12]
 800dedc:	3307      	adds	r3, #7
 800dede:	404a      	eors	r2, r1
 800dee0:	b2d2      	uxtb	r2, r2
 800dee2:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 8] = ((uint8_t*)s)[ 8] ^ ((uint8_t*)k)[ 8];
 800dee4:	68bb      	ldr	r3, [r7, #8]
 800dee6:	3308      	adds	r3, #8
 800dee8:	7819      	ldrb	r1, [r3, #0]
 800deea:	687b      	ldr	r3, [r7, #4]
 800deec:	3308      	adds	r3, #8
 800deee:	781a      	ldrb	r2, [r3, #0]
 800def0:	68fb      	ldr	r3, [r7, #12]
 800def2:	3308      	adds	r3, #8
 800def4:	404a      	eors	r2, r1
 800def6:	b2d2      	uxtb	r2, r2
 800def8:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[ 9] = ((uint8_t*)s)[ 9] ^ ((uint8_t*)k)[ 9];
 800defa:	68bb      	ldr	r3, [r7, #8]
 800defc:	3309      	adds	r3, #9
 800defe:	7819      	ldrb	r1, [r3, #0]
 800df00:	687b      	ldr	r3, [r7, #4]
 800df02:	3309      	adds	r3, #9
 800df04:	781a      	ldrb	r2, [r3, #0]
 800df06:	68fb      	ldr	r3, [r7, #12]
 800df08:	3309      	adds	r3, #9
 800df0a:	404a      	eors	r2, r1
 800df0c:	b2d2      	uxtb	r2, r2
 800df0e:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[10] = ((uint8_t*)s)[10] ^ ((uint8_t*)k)[10];
 800df10:	68bb      	ldr	r3, [r7, #8]
 800df12:	330a      	adds	r3, #10
 800df14:	7819      	ldrb	r1, [r3, #0]
 800df16:	687b      	ldr	r3, [r7, #4]
 800df18:	330a      	adds	r3, #10
 800df1a:	781a      	ldrb	r2, [r3, #0]
 800df1c:	68fb      	ldr	r3, [r7, #12]
 800df1e:	330a      	adds	r3, #10
 800df20:	404a      	eors	r2, r1
 800df22:	b2d2      	uxtb	r2, r2
 800df24:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[11] = ((uint8_t*)s)[11] ^ ((uint8_t*)k)[11];
 800df26:	68bb      	ldr	r3, [r7, #8]
 800df28:	330b      	adds	r3, #11
 800df2a:	7819      	ldrb	r1, [r3, #0]
 800df2c:	687b      	ldr	r3, [r7, #4]
 800df2e:	330b      	adds	r3, #11
 800df30:	781a      	ldrb	r2, [r3, #0]
 800df32:	68fb      	ldr	r3, [r7, #12]
 800df34:	330b      	adds	r3, #11
 800df36:	404a      	eors	r2, r1
 800df38:	b2d2      	uxtb	r2, r2
 800df3a:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[12] = ((uint8_t*)s)[12] ^ ((uint8_t*)k)[12];
 800df3c:	68bb      	ldr	r3, [r7, #8]
 800df3e:	330c      	adds	r3, #12
 800df40:	7819      	ldrb	r1, [r3, #0]
 800df42:	687b      	ldr	r3, [r7, #4]
 800df44:	330c      	adds	r3, #12
 800df46:	781a      	ldrb	r2, [r3, #0]
 800df48:	68fb      	ldr	r3, [r7, #12]
 800df4a:	330c      	adds	r3, #12
 800df4c:	404a      	eors	r2, r1
 800df4e:	b2d2      	uxtb	r2, r2
 800df50:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[13] = ((uint8_t*)s)[13] ^ ((uint8_t*)k)[13];
 800df52:	68bb      	ldr	r3, [r7, #8]
 800df54:	330d      	adds	r3, #13
 800df56:	7819      	ldrb	r1, [r3, #0]
 800df58:	687b      	ldr	r3, [r7, #4]
 800df5a:	330d      	adds	r3, #13
 800df5c:	781a      	ldrb	r2, [r3, #0]
 800df5e:	68fb      	ldr	r3, [r7, #12]
 800df60:	330d      	adds	r3, #13
 800df62:	404a      	eors	r2, r1
 800df64:	b2d2      	uxtb	r2, r2
 800df66:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[14] = ((uint8_t*)s)[14] ^ ((uint8_t*)k)[14];
 800df68:	68bb      	ldr	r3, [r7, #8]
 800df6a:	330e      	adds	r3, #14
 800df6c:	7819      	ldrb	r1, [r3, #0]
 800df6e:	687b      	ldr	r3, [r7, #4]
 800df70:	330e      	adds	r3, #14
 800df72:	781a      	ldrb	r2, [r3, #0]
 800df74:	68fb      	ldr	r3, [r7, #12]
 800df76:	330e      	adds	r3, #14
 800df78:	404a      	eors	r2, r1
 800df7a:	b2d2      	uxtb	r2, r2
 800df7c:	701a      	strb	r2, [r3, #0]
    ((uint8_t*)d)[15] = ((uint8_t*)s)[15] ^ ((uint8_t*)k)[15];
 800df7e:	68bb      	ldr	r3, [r7, #8]
 800df80:	330f      	adds	r3, #15
 800df82:	7819      	ldrb	r1, [r3, #0]
 800df84:	687b      	ldr	r3, [r7, #4]
 800df86:	330f      	adds	r3, #15
 800df88:	781a      	ldrb	r2, [r3, #0]
 800df8a:	68fb      	ldr	r3, [r7, #12]
 800df8c:	330f      	adds	r3, #15
 800df8e:	404a      	eors	r2, r1
 800df90:	b2d2      	uxtb	r2, r2
 800df92:	701a      	strb	r2, [r3, #0]
#else
    block_copy(d, s);
    xor_block(d, k);
#endif
}
 800df94:	46c0      	nop			; (mov r8, r8)
 800df96:	46bd      	mov	sp, r7
 800df98:	b004      	add	sp, #16
 800df9a:	bd80      	pop	{r7, pc}

0800df9c <add_round_key>:

static void add_round_key( uint8_t d[N_BLOCK], const uint8_t k[N_BLOCK] )
{
 800df9c:	b580      	push	{r7, lr}
 800df9e:	b082      	sub	sp, #8
 800dfa0:	af00      	add	r7, sp, #0
 800dfa2:	6078      	str	r0, [r7, #4]
 800dfa4:	6039      	str	r1, [r7, #0]
    xor_block(d, k);
 800dfa6:	683a      	ldr	r2, [r7, #0]
 800dfa8:	687b      	ldr	r3, [r7, #4]
 800dfaa:	0011      	movs	r1, r2
 800dfac:	0018      	movs	r0, r3
 800dfae:	f7ff fe88 	bl	800dcc2 <xor_block>
}
 800dfb2:	46c0      	nop			; (mov r8, r8)
 800dfb4:	46bd      	mov	sp, r7
 800dfb6:	b002      	add	sp, #8
 800dfb8:	bd80      	pop	{r7, pc}
	...

0800dfbc <shift_sub_rows>:

static void shift_sub_rows( uint8_t st[N_BLOCK] )
{   uint8_t tt;
 800dfbc:	b580      	push	{r7, lr}
 800dfbe:	b084      	sub	sp, #16
 800dfc0:	af00      	add	r7, sp, #0
 800dfc2:	6078      	str	r0, [r7, #4]

    st[ 0] = s_box(st[ 0]); st[ 4] = s_box(st[ 4]);
 800dfc4:	687b      	ldr	r3, [r7, #4]
 800dfc6:	781b      	ldrb	r3, [r3, #0]
 800dfc8:	001a      	movs	r2, r3
 800dfca:	4b4c      	ldr	r3, [pc, #304]	; (800e0fc <shift_sub_rows+0x140>)
 800dfcc:	5c9a      	ldrb	r2, [r3, r2]
 800dfce:	687b      	ldr	r3, [r7, #4]
 800dfd0:	701a      	strb	r2, [r3, #0]
 800dfd2:	687b      	ldr	r3, [r7, #4]
 800dfd4:	3304      	adds	r3, #4
 800dfd6:	781b      	ldrb	r3, [r3, #0]
 800dfd8:	0019      	movs	r1, r3
 800dfda:	687b      	ldr	r3, [r7, #4]
 800dfdc:	3304      	adds	r3, #4
 800dfde:	4a47      	ldr	r2, [pc, #284]	; (800e0fc <shift_sub_rows+0x140>)
 800dfe0:	5c52      	ldrb	r2, [r2, r1]
 800dfe2:	701a      	strb	r2, [r3, #0]
    st[ 8] = s_box(st[ 8]); st[12] = s_box(st[12]);
 800dfe4:	687b      	ldr	r3, [r7, #4]
 800dfe6:	3308      	adds	r3, #8
 800dfe8:	781b      	ldrb	r3, [r3, #0]
 800dfea:	0019      	movs	r1, r3
 800dfec:	687b      	ldr	r3, [r7, #4]
 800dfee:	3308      	adds	r3, #8
 800dff0:	4a42      	ldr	r2, [pc, #264]	; (800e0fc <shift_sub_rows+0x140>)
 800dff2:	5c52      	ldrb	r2, [r2, r1]
 800dff4:	701a      	strb	r2, [r3, #0]
 800dff6:	687b      	ldr	r3, [r7, #4]
 800dff8:	330c      	adds	r3, #12
 800dffa:	781b      	ldrb	r3, [r3, #0]
 800dffc:	0019      	movs	r1, r3
 800dffe:	687b      	ldr	r3, [r7, #4]
 800e000:	330c      	adds	r3, #12
 800e002:	4a3e      	ldr	r2, [pc, #248]	; (800e0fc <shift_sub_rows+0x140>)
 800e004:	5c52      	ldrb	r2, [r2, r1]
 800e006:	701a      	strb	r2, [r3, #0]

    tt = st[1]; st[ 1] = s_box(st[ 5]); st[ 5] = s_box(st[ 9]);
 800e008:	200f      	movs	r0, #15
 800e00a:	183b      	adds	r3, r7, r0
 800e00c:	687a      	ldr	r2, [r7, #4]
 800e00e:	7852      	ldrb	r2, [r2, #1]
 800e010:	701a      	strb	r2, [r3, #0]
 800e012:	687b      	ldr	r3, [r7, #4]
 800e014:	3305      	adds	r3, #5
 800e016:	781b      	ldrb	r3, [r3, #0]
 800e018:	0019      	movs	r1, r3
 800e01a:	687b      	ldr	r3, [r7, #4]
 800e01c:	3301      	adds	r3, #1
 800e01e:	4a37      	ldr	r2, [pc, #220]	; (800e0fc <shift_sub_rows+0x140>)
 800e020:	5c52      	ldrb	r2, [r2, r1]
 800e022:	701a      	strb	r2, [r3, #0]
 800e024:	687b      	ldr	r3, [r7, #4]
 800e026:	3309      	adds	r3, #9
 800e028:	781b      	ldrb	r3, [r3, #0]
 800e02a:	0019      	movs	r1, r3
 800e02c:	687b      	ldr	r3, [r7, #4]
 800e02e:	3305      	adds	r3, #5
 800e030:	4a32      	ldr	r2, [pc, #200]	; (800e0fc <shift_sub_rows+0x140>)
 800e032:	5c52      	ldrb	r2, [r2, r1]
 800e034:	701a      	strb	r2, [r3, #0]
    st[ 9] = s_box(st[13]); st[13] = s_box( tt );
 800e036:	687b      	ldr	r3, [r7, #4]
 800e038:	330d      	adds	r3, #13
 800e03a:	781b      	ldrb	r3, [r3, #0]
 800e03c:	0019      	movs	r1, r3
 800e03e:	687b      	ldr	r3, [r7, #4]
 800e040:	3309      	adds	r3, #9
 800e042:	4a2e      	ldr	r2, [pc, #184]	; (800e0fc <shift_sub_rows+0x140>)
 800e044:	5c52      	ldrb	r2, [r2, r1]
 800e046:	701a      	strb	r2, [r3, #0]
 800e048:	183b      	adds	r3, r7, r0
 800e04a:	781a      	ldrb	r2, [r3, #0]
 800e04c:	687b      	ldr	r3, [r7, #4]
 800e04e:	330d      	adds	r3, #13
 800e050:	492a      	ldr	r1, [pc, #168]	; (800e0fc <shift_sub_rows+0x140>)
 800e052:	5c8a      	ldrb	r2, [r1, r2]
 800e054:	701a      	strb	r2, [r3, #0]

    tt = st[2]; st[ 2] = s_box(st[10]); st[10] = s_box( tt );
 800e056:	183b      	adds	r3, r7, r0
 800e058:	687a      	ldr	r2, [r7, #4]
 800e05a:	7892      	ldrb	r2, [r2, #2]
 800e05c:	701a      	strb	r2, [r3, #0]
 800e05e:	687b      	ldr	r3, [r7, #4]
 800e060:	330a      	adds	r3, #10
 800e062:	781b      	ldrb	r3, [r3, #0]
 800e064:	0019      	movs	r1, r3
 800e066:	687b      	ldr	r3, [r7, #4]
 800e068:	3302      	adds	r3, #2
 800e06a:	4a24      	ldr	r2, [pc, #144]	; (800e0fc <shift_sub_rows+0x140>)
 800e06c:	5c52      	ldrb	r2, [r2, r1]
 800e06e:	701a      	strb	r2, [r3, #0]
 800e070:	183b      	adds	r3, r7, r0
 800e072:	781a      	ldrb	r2, [r3, #0]
 800e074:	687b      	ldr	r3, [r7, #4]
 800e076:	330a      	adds	r3, #10
 800e078:	4920      	ldr	r1, [pc, #128]	; (800e0fc <shift_sub_rows+0x140>)
 800e07a:	5c8a      	ldrb	r2, [r1, r2]
 800e07c:	701a      	strb	r2, [r3, #0]
    tt = st[6]; st[ 6] = s_box(st[14]); st[14] = s_box( tt );
 800e07e:	183b      	adds	r3, r7, r0
 800e080:	687a      	ldr	r2, [r7, #4]
 800e082:	7992      	ldrb	r2, [r2, #6]
 800e084:	701a      	strb	r2, [r3, #0]
 800e086:	687b      	ldr	r3, [r7, #4]
 800e088:	330e      	adds	r3, #14
 800e08a:	781b      	ldrb	r3, [r3, #0]
 800e08c:	0019      	movs	r1, r3
 800e08e:	687b      	ldr	r3, [r7, #4]
 800e090:	3306      	adds	r3, #6
 800e092:	4a1a      	ldr	r2, [pc, #104]	; (800e0fc <shift_sub_rows+0x140>)
 800e094:	5c52      	ldrb	r2, [r2, r1]
 800e096:	701a      	strb	r2, [r3, #0]
 800e098:	183b      	adds	r3, r7, r0
 800e09a:	781a      	ldrb	r2, [r3, #0]
 800e09c:	687b      	ldr	r3, [r7, #4]
 800e09e:	330e      	adds	r3, #14
 800e0a0:	4916      	ldr	r1, [pc, #88]	; (800e0fc <shift_sub_rows+0x140>)
 800e0a2:	5c8a      	ldrb	r2, [r1, r2]
 800e0a4:	701a      	strb	r2, [r3, #0]

    tt = st[15]; st[15] = s_box(st[11]); st[11] = s_box(st[ 7]);
 800e0a6:	183b      	adds	r3, r7, r0
 800e0a8:	687a      	ldr	r2, [r7, #4]
 800e0aa:	7bd2      	ldrb	r2, [r2, #15]
 800e0ac:	701a      	strb	r2, [r3, #0]
 800e0ae:	687b      	ldr	r3, [r7, #4]
 800e0b0:	330b      	adds	r3, #11
 800e0b2:	781b      	ldrb	r3, [r3, #0]
 800e0b4:	0019      	movs	r1, r3
 800e0b6:	687b      	ldr	r3, [r7, #4]
 800e0b8:	330f      	adds	r3, #15
 800e0ba:	4a10      	ldr	r2, [pc, #64]	; (800e0fc <shift_sub_rows+0x140>)
 800e0bc:	5c52      	ldrb	r2, [r2, r1]
 800e0be:	701a      	strb	r2, [r3, #0]
 800e0c0:	687b      	ldr	r3, [r7, #4]
 800e0c2:	3307      	adds	r3, #7
 800e0c4:	781b      	ldrb	r3, [r3, #0]
 800e0c6:	0019      	movs	r1, r3
 800e0c8:	687b      	ldr	r3, [r7, #4]
 800e0ca:	330b      	adds	r3, #11
 800e0cc:	4a0b      	ldr	r2, [pc, #44]	; (800e0fc <shift_sub_rows+0x140>)
 800e0ce:	5c52      	ldrb	r2, [r2, r1]
 800e0d0:	701a      	strb	r2, [r3, #0]
    st[ 7] = s_box(st[ 3]); st[ 3] = s_box( tt );
 800e0d2:	687b      	ldr	r3, [r7, #4]
 800e0d4:	3303      	adds	r3, #3
 800e0d6:	781b      	ldrb	r3, [r3, #0]
 800e0d8:	0019      	movs	r1, r3
 800e0da:	687b      	ldr	r3, [r7, #4]
 800e0dc:	3307      	adds	r3, #7
 800e0de:	4a07      	ldr	r2, [pc, #28]	; (800e0fc <shift_sub_rows+0x140>)
 800e0e0:	5c52      	ldrb	r2, [r2, r1]
 800e0e2:	701a      	strb	r2, [r3, #0]
 800e0e4:	183b      	adds	r3, r7, r0
 800e0e6:	781a      	ldrb	r2, [r3, #0]
 800e0e8:	687b      	ldr	r3, [r7, #4]
 800e0ea:	3303      	adds	r3, #3
 800e0ec:	4903      	ldr	r1, [pc, #12]	; (800e0fc <shift_sub_rows+0x140>)
 800e0ee:	5c8a      	ldrb	r2, [r1, r2]
 800e0f0:	701a      	strb	r2, [r3, #0]
}
 800e0f2:	46c0      	nop			; (mov r8, r8)
 800e0f4:	46bd      	mov	sp, r7
 800e0f6:	b004      	add	sp, #16
 800e0f8:	bd80      	pop	{r7, pc}
 800e0fa:	46c0      	nop			; (mov r8, r8)
 800e0fc:	0801ee70 	.word	0x0801ee70

0800e100 <mix_sub_columns>:

#endif

#if defined( VERSION_1 )
  static void mix_sub_columns( uint8_t dt[N_BLOCK] )
  { uint8_t st[N_BLOCK];
 800e100:	b590      	push	{r4, r7, lr}
 800e102:	b087      	sub	sp, #28
 800e104:	af00      	add	r7, sp, #0
 800e106:	6078      	str	r0, [r7, #4]
    block_copy(st, dt);
 800e108:	687a      	ldr	r2, [r7, #4]
 800e10a:	2408      	movs	r4, #8
 800e10c:	193b      	adds	r3, r7, r4
 800e10e:	0011      	movs	r1, r2
 800e110:	0018      	movs	r0, r3
 800e112:	f7ff fd62 	bl	800dbda <copy_block>
#else
  static void mix_sub_columns( uint8_t dt[N_BLOCK], uint8_t st[N_BLOCK] )
  {
#endif
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800e116:	0020      	movs	r0, r4
 800e118:	183b      	adds	r3, r7, r0
 800e11a:	781b      	ldrb	r3, [r3, #0]
 800e11c:	001a      	movs	r2, r3
 800e11e:	4be8      	ldr	r3, [pc, #928]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e120:	5c9a      	ldrb	r2, [r3, r2]
 800e122:	183b      	adds	r3, r7, r0
 800e124:	795b      	ldrb	r3, [r3, #5]
 800e126:	0019      	movs	r1, r3
 800e128:	4be6      	ldr	r3, [pc, #920]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e12a:	5c5b      	ldrb	r3, [r3, r1]
 800e12c:	4053      	eors	r3, r2
 800e12e:	b2da      	uxtb	r2, r3
 800e130:	183b      	adds	r3, r7, r0
 800e132:	7a9b      	ldrb	r3, [r3, #10]
 800e134:	0019      	movs	r1, r3
 800e136:	4be4      	ldr	r3, [pc, #912]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e138:	5c5b      	ldrb	r3, [r3, r1]
 800e13a:	4053      	eors	r3, r2
 800e13c:	b2da      	uxtb	r2, r3
 800e13e:	183b      	adds	r3, r7, r0
 800e140:	7bdb      	ldrb	r3, [r3, #15]
 800e142:	0019      	movs	r1, r3
 800e144:	4be0      	ldr	r3, [pc, #896]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e146:	5c5b      	ldrb	r3, [r3, r1]
 800e148:	4053      	eors	r3, r2
 800e14a:	b2da      	uxtb	r2, r3
 800e14c:	687b      	ldr	r3, [r7, #4]
 800e14e:	701a      	strb	r2, [r3, #0]
    dt[ 1] = s_box(st[0]) ^ gfm2_sb(st[5]) ^ gfm3_sb(st[10]) ^ s_box(st[15]);
 800e150:	183b      	adds	r3, r7, r0
 800e152:	781b      	ldrb	r3, [r3, #0]
 800e154:	001a      	movs	r2, r3
 800e156:	4bdc      	ldr	r3, [pc, #880]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e158:	5c9a      	ldrb	r2, [r3, r2]
 800e15a:	183b      	adds	r3, r7, r0
 800e15c:	795b      	ldrb	r3, [r3, #5]
 800e15e:	0019      	movs	r1, r3
 800e160:	4bd7      	ldr	r3, [pc, #860]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e162:	5c5b      	ldrb	r3, [r3, r1]
 800e164:	4053      	eors	r3, r2
 800e166:	b2da      	uxtb	r2, r3
 800e168:	183b      	adds	r3, r7, r0
 800e16a:	7a9b      	ldrb	r3, [r3, #10]
 800e16c:	0019      	movs	r1, r3
 800e16e:	4bd5      	ldr	r3, [pc, #852]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e170:	5c5b      	ldrb	r3, [r3, r1]
 800e172:	4053      	eors	r3, r2
 800e174:	b2d9      	uxtb	r1, r3
 800e176:	183b      	adds	r3, r7, r0
 800e178:	7bdb      	ldrb	r3, [r3, #15]
 800e17a:	001a      	movs	r2, r3
 800e17c:	4bd2      	ldr	r3, [pc, #840]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e17e:	5c9a      	ldrb	r2, [r3, r2]
 800e180:	687b      	ldr	r3, [r7, #4]
 800e182:	3301      	adds	r3, #1
 800e184:	404a      	eors	r2, r1
 800e186:	b2d2      	uxtb	r2, r2
 800e188:	701a      	strb	r2, [r3, #0]
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
 800e18a:	183b      	adds	r3, r7, r0
 800e18c:	781b      	ldrb	r3, [r3, #0]
 800e18e:	001a      	movs	r2, r3
 800e190:	4bcd      	ldr	r3, [pc, #820]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e192:	5c9a      	ldrb	r2, [r3, r2]
 800e194:	183b      	adds	r3, r7, r0
 800e196:	795b      	ldrb	r3, [r3, #5]
 800e198:	0019      	movs	r1, r3
 800e19a:	4bcb      	ldr	r3, [pc, #812]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e19c:	5c5b      	ldrb	r3, [r3, r1]
 800e19e:	4053      	eors	r3, r2
 800e1a0:	b2da      	uxtb	r2, r3
 800e1a2:	183b      	adds	r3, r7, r0
 800e1a4:	7a9b      	ldrb	r3, [r3, #10]
 800e1a6:	0019      	movs	r1, r3
 800e1a8:	4bc5      	ldr	r3, [pc, #788]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e1aa:	5c5b      	ldrb	r3, [r3, r1]
 800e1ac:	4053      	eors	r3, r2
 800e1ae:	b2d9      	uxtb	r1, r3
 800e1b0:	183b      	adds	r3, r7, r0
 800e1b2:	7bdb      	ldrb	r3, [r3, #15]
 800e1b4:	001a      	movs	r2, r3
 800e1b6:	4bc3      	ldr	r3, [pc, #780]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e1b8:	5c9a      	ldrb	r2, [r3, r2]
 800e1ba:	687b      	ldr	r3, [r7, #4]
 800e1bc:	3302      	adds	r3, #2
 800e1be:	404a      	eors	r2, r1
 800e1c0:	b2d2      	uxtb	r2, r2
 800e1c2:	701a      	strb	r2, [r3, #0]
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
 800e1c4:	183b      	adds	r3, r7, r0
 800e1c6:	781b      	ldrb	r3, [r3, #0]
 800e1c8:	001a      	movs	r2, r3
 800e1ca:	4bbe      	ldr	r3, [pc, #760]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e1cc:	5c9a      	ldrb	r2, [r3, r2]
 800e1ce:	183b      	adds	r3, r7, r0
 800e1d0:	795b      	ldrb	r3, [r3, #5]
 800e1d2:	0019      	movs	r1, r3
 800e1d4:	4bbc      	ldr	r3, [pc, #752]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e1d6:	5c5b      	ldrb	r3, [r3, r1]
 800e1d8:	4053      	eors	r3, r2
 800e1da:	b2da      	uxtb	r2, r3
 800e1dc:	183b      	adds	r3, r7, r0
 800e1de:	7a9b      	ldrb	r3, [r3, #10]
 800e1e0:	0019      	movs	r1, r3
 800e1e2:	4bb9      	ldr	r3, [pc, #740]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e1e4:	5c5b      	ldrb	r3, [r3, r1]
 800e1e6:	4053      	eors	r3, r2
 800e1e8:	b2d9      	uxtb	r1, r3
 800e1ea:	183b      	adds	r3, r7, r0
 800e1ec:	7bdb      	ldrb	r3, [r3, #15]
 800e1ee:	001a      	movs	r2, r3
 800e1f0:	4bb3      	ldr	r3, [pc, #716]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e1f2:	5c9a      	ldrb	r2, [r3, r2]
 800e1f4:	687b      	ldr	r3, [r7, #4]
 800e1f6:	3303      	adds	r3, #3
 800e1f8:	404a      	eors	r2, r1
 800e1fa:	b2d2      	uxtb	r2, r2
 800e1fc:	701a      	strb	r2, [r3, #0]

    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800e1fe:	183b      	adds	r3, r7, r0
 800e200:	791b      	ldrb	r3, [r3, #4]
 800e202:	001a      	movs	r2, r3
 800e204:	4bae      	ldr	r3, [pc, #696]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e206:	5c9a      	ldrb	r2, [r3, r2]
 800e208:	183b      	adds	r3, r7, r0
 800e20a:	7a5b      	ldrb	r3, [r3, #9]
 800e20c:	0019      	movs	r1, r3
 800e20e:	4bad      	ldr	r3, [pc, #692]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e210:	5c5b      	ldrb	r3, [r3, r1]
 800e212:	4053      	eors	r3, r2
 800e214:	b2da      	uxtb	r2, r3
 800e216:	183b      	adds	r3, r7, r0
 800e218:	7b9b      	ldrb	r3, [r3, #14]
 800e21a:	0019      	movs	r1, r3
 800e21c:	4baa      	ldr	r3, [pc, #680]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e21e:	5c5b      	ldrb	r3, [r3, r1]
 800e220:	4053      	eors	r3, r2
 800e222:	b2d9      	uxtb	r1, r3
 800e224:	183b      	adds	r3, r7, r0
 800e226:	78db      	ldrb	r3, [r3, #3]
 800e228:	001a      	movs	r2, r3
 800e22a:	4ba7      	ldr	r3, [pc, #668]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e22c:	5c9a      	ldrb	r2, [r3, r2]
 800e22e:	687b      	ldr	r3, [r7, #4]
 800e230:	3304      	adds	r3, #4
 800e232:	404a      	eors	r2, r1
 800e234:	b2d2      	uxtb	r2, r2
 800e236:	701a      	strb	r2, [r3, #0]
    dt[ 5] = s_box(st[4]) ^ gfm2_sb(st[9]) ^ gfm3_sb(st[14]) ^ s_box(st[3]);
 800e238:	183b      	adds	r3, r7, r0
 800e23a:	791b      	ldrb	r3, [r3, #4]
 800e23c:	001a      	movs	r2, r3
 800e23e:	4ba2      	ldr	r3, [pc, #648]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e240:	5c9a      	ldrb	r2, [r3, r2]
 800e242:	183b      	adds	r3, r7, r0
 800e244:	7a5b      	ldrb	r3, [r3, #9]
 800e246:	0019      	movs	r1, r3
 800e248:	4b9d      	ldr	r3, [pc, #628]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e24a:	5c5b      	ldrb	r3, [r3, r1]
 800e24c:	4053      	eors	r3, r2
 800e24e:	b2da      	uxtb	r2, r3
 800e250:	183b      	adds	r3, r7, r0
 800e252:	7b9b      	ldrb	r3, [r3, #14]
 800e254:	0019      	movs	r1, r3
 800e256:	4b9b      	ldr	r3, [pc, #620]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e258:	5c5b      	ldrb	r3, [r3, r1]
 800e25a:	4053      	eors	r3, r2
 800e25c:	b2d9      	uxtb	r1, r3
 800e25e:	183b      	adds	r3, r7, r0
 800e260:	78db      	ldrb	r3, [r3, #3]
 800e262:	001a      	movs	r2, r3
 800e264:	4b98      	ldr	r3, [pc, #608]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e266:	5c9a      	ldrb	r2, [r3, r2]
 800e268:	687b      	ldr	r3, [r7, #4]
 800e26a:	3305      	adds	r3, #5
 800e26c:	404a      	eors	r2, r1
 800e26e:	b2d2      	uxtb	r2, r2
 800e270:	701a      	strb	r2, [r3, #0]
    dt[ 6] = s_box(st[4]) ^ s_box(st[9]) ^ gfm2_sb(st[14]) ^ gfm3_sb(st[3]);
 800e272:	183b      	adds	r3, r7, r0
 800e274:	791b      	ldrb	r3, [r3, #4]
 800e276:	001a      	movs	r2, r3
 800e278:	4b93      	ldr	r3, [pc, #588]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e27a:	5c9a      	ldrb	r2, [r3, r2]
 800e27c:	183b      	adds	r3, r7, r0
 800e27e:	7a5b      	ldrb	r3, [r3, #9]
 800e280:	0019      	movs	r1, r3
 800e282:	4b91      	ldr	r3, [pc, #580]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e284:	5c5b      	ldrb	r3, [r3, r1]
 800e286:	4053      	eors	r3, r2
 800e288:	b2da      	uxtb	r2, r3
 800e28a:	183b      	adds	r3, r7, r0
 800e28c:	7b9b      	ldrb	r3, [r3, #14]
 800e28e:	0019      	movs	r1, r3
 800e290:	4b8b      	ldr	r3, [pc, #556]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e292:	5c5b      	ldrb	r3, [r3, r1]
 800e294:	4053      	eors	r3, r2
 800e296:	b2d9      	uxtb	r1, r3
 800e298:	183b      	adds	r3, r7, r0
 800e29a:	78db      	ldrb	r3, [r3, #3]
 800e29c:	001a      	movs	r2, r3
 800e29e:	4b89      	ldr	r3, [pc, #548]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e2a0:	5c9a      	ldrb	r2, [r3, r2]
 800e2a2:	687b      	ldr	r3, [r7, #4]
 800e2a4:	3306      	adds	r3, #6
 800e2a6:	404a      	eors	r2, r1
 800e2a8:	b2d2      	uxtb	r2, r2
 800e2aa:	701a      	strb	r2, [r3, #0]
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
 800e2ac:	183b      	adds	r3, r7, r0
 800e2ae:	791b      	ldrb	r3, [r3, #4]
 800e2b0:	001a      	movs	r2, r3
 800e2b2:	4b84      	ldr	r3, [pc, #528]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e2b4:	5c9a      	ldrb	r2, [r3, r2]
 800e2b6:	183b      	adds	r3, r7, r0
 800e2b8:	7a5b      	ldrb	r3, [r3, #9]
 800e2ba:	0019      	movs	r1, r3
 800e2bc:	4b82      	ldr	r3, [pc, #520]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e2be:	5c5b      	ldrb	r3, [r3, r1]
 800e2c0:	4053      	eors	r3, r2
 800e2c2:	b2da      	uxtb	r2, r3
 800e2c4:	183b      	adds	r3, r7, r0
 800e2c6:	7b9b      	ldrb	r3, [r3, #14]
 800e2c8:	0019      	movs	r1, r3
 800e2ca:	4b7f      	ldr	r3, [pc, #508]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e2cc:	5c5b      	ldrb	r3, [r3, r1]
 800e2ce:	4053      	eors	r3, r2
 800e2d0:	b2d9      	uxtb	r1, r3
 800e2d2:	183b      	adds	r3, r7, r0
 800e2d4:	78db      	ldrb	r3, [r3, #3]
 800e2d6:	001a      	movs	r2, r3
 800e2d8:	4b79      	ldr	r3, [pc, #484]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e2da:	5c9a      	ldrb	r2, [r3, r2]
 800e2dc:	687b      	ldr	r3, [r7, #4]
 800e2de:	3307      	adds	r3, #7
 800e2e0:	404a      	eors	r2, r1
 800e2e2:	b2d2      	uxtb	r2, r2
 800e2e4:	701a      	strb	r2, [r3, #0]

    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800e2e6:	183b      	adds	r3, r7, r0
 800e2e8:	7a1b      	ldrb	r3, [r3, #8]
 800e2ea:	001a      	movs	r2, r3
 800e2ec:	4b74      	ldr	r3, [pc, #464]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e2ee:	5c9a      	ldrb	r2, [r3, r2]
 800e2f0:	183b      	adds	r3, r7, r0
 800e2f2:	7b5b      	ldrb	r3, [r3, #13]
 800e2f4:	0019      	movs	r1, r3
 800e2f6:	4b73      	ldr	r3, [pc, #460]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e2f8:	5c5b      	ldrb	r3, [r3, r1]
 800e2fa:	4053      	eors	r3, r2
 800e2fc:	b2da      	uxtb	r2, r3
 800e2fe:	183b      	adds	r3, r7, r0
 800e300:	789b      	ldrb	r3, [r3, #2]
 800e302:	0019      	movs	r1, r3
 800e304:	4b70      	ldr	r3, [pc, #448]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e306:	5c5b      	ldrb	r3, [r3, r1]
 800e308:	4053      	eors	r3, r2
 800e30a:	b2d9      	uxtb	r1, r3
 800e30c:	183b      	adds	r3, r7, r0
 800e30e:	79db      	ldrb	r3, [r3, #7]
 800e310:	001a      	movs	r2, r3
 800e312:	4b6d      	ldr	r3, [pc, #436]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e314:	5c9a      	ldrb	r2, [r3, r2]
 800e316:	687b      	ldr	r3, [r7, #4]
 800e318:	3308      	adds	r3, #8
 800e31a:	404a      	eors	r2, r1
 800e31c:	b2d2      	uxtb	r2, r2
 800e31e:	701a      	strb	r2, [r3, #0]
    dt[ 9] = s_box(st[8]) ^ gfm2_sb(st[13]) ^ gfm3_sb(st[2]) ^ s_box(st[7]);
 800e320:	183b      	adds	r3, r7, r0
 800e322:	7a1b      	ldrb	r3, [r3, #8]
 800e324:	001a      	movs	r2, r3
 800e326:	4b68      	ldr	r3, [pc, #416]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e328:	5c9a      	ldrb	r2, [r3, r2]
 800e32a:	183b      	adds	r3, r7, r0
 800e32c:	7b5b      	ldrb	r3, [r3, #13]
 800e32e:	0019      	movs	r1, r3
 800e330:	4b63      	ldr	r3, [pc, #396]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e332:	5c5b      	ldrb	r3, [r3, r1]
 800e334:	4053      	eors	r3, r2
 800e336:	b2da      	uxtb	r2, r3
 800e338:	183b      	adds	r3, r7, r0
 800e33a:	789b      	ldrb	r3, [r3, #2]
 800e33c:	0019      	movs	r1, r3
 800e33e:	4b61      	ldr	r3, [pc, #388]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e340:	5c5b      	ldrb	r3, [r3, r1]
 800e342:	4053      	eors	r3, r2
 800e344:	b2d9      	uxtb	r1, r3
 800e346:	183b      	adds	r3, r7, r0
 800e348:	79db      	ldrb	r3, [r3, #7]
 800e34a:	001a      	movs	r2, r3
 800e34c:	4b5e      	ldr	r3, [pc, #376]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e34e:	5c9a      	ldrb	r2, [r3, r2]
 800e350:	687b      	ldr	r3, [r7, #4]
 800e352:	3309      	adds	r3, #9
 800e354:	404a      	eors	r2, r1
 800e356:	b2d2      	uxtb	r2, r2
 800e358:	701a      	strb	r2, [r3, #0]
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
 800e35a:	183b      	adds	r3, r7, r0
 800e35c:	7a1b      	ldrb	r3, [r3, #8]
 800e35e:	001a      	movs	r2, r3
 800e360:	4b59      	ldr	r3, [pc, #356]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e362:	5c9a      	ldrb	r2, [r3, r2]
 800e364:	183b      	adds	r3, r7, r0
 800e366:	7b5b      	ldrb	r3, [r3, #13]
 800e368:	0019      	movs	r1, r3
 800e36a:	4b57      	ldr	r3, [pc, #348]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e36c:	5c5b      	ldrb	r3, [r3, r1]
 800e36e:	4053      	eors	r3, r2
 800e370:	b2da      	uxtb	r2, r3
 800e372:	183b      	adds	r3, r7, r0
 800e374:	789b      	ldrb	r3, [r3, #2]
 800e376:	0019      	movs	r1, r3
 800e378:	4b51      	ldr	r3, [pc, #324]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e37a:	5c5b      	ldrb	r3, [r3, r1]
 800e37c:	4053      	eors	r3, r2
 800e37e:	b2d9      	uxtb	r1, r3
 800e380:	183b      	adds	r3, r7, r0
 800e382:	79db      	ldrb	r3, [r3, #7]
 800e384:	001a      	movs	r2, r3
 800e386:	4b4f      	ldr	r3, [pc, #316]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e388:	5c9a      	ldrb	r2, [r3, r2]
 800e38a:	687b      	ldr	r3, [r7, #4]
 800e38c:	330a      	adds	r3, #10
 800e38e:	404a      	eors	r2, r1
 800e390:	b2d2      	uxtb	r2, r2
 800e392:	701a      	strb	r2, [r3, #0]
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
 800e394:	183b      	adds	r3, r7, r0
 800e396:	7a1b      	ldrb	r3, [r3, #8]
 800e398:	001a      	movs	r2, r3
 800e39a:	4b4a      	ldr	r3, [pc, #296]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e39c:	5c9a      	ldrb	r2, [r3, r2]
 800e39e:	183b      	adds	r3, r7, r0
 800e3a0:	7b5b      	ldrb	r3, [r3, #13]
 800e3a2:	0019      	movs	r1, r3
 800e3a4:	4b48      	ldr	r3, [pc, #288]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e3a6:	5c5b      	ldrb	r3, [r3, r1]
 800e3a8:	4053      	eors	r3, r2
 800e3aa:	b2da      	uxtb	r2, r3
 800e3ac:	183b      	adds	r3, r7, r0
 800e3ae:	789b      	ldrb	r3, [r3, #2]
 800e3b0:	0019      	movs	r1, r3
 800e3b2:	4b45      	ldr	r3, [pc, #276]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e3b4:	5c5b      	ldrb	r3, [r3, r1]
 800e3b6:	4053      	eors	r3, r2
 800e3b8:	b2d9      	uxtb	r1, r3
 800e3ba:	183b      	adds	r3, r7, r0
 800e3bc:	79db      	ldrb	r3, [r3, #7]
 800e3be:	001a      	movs	r2, r3
 800e3c0:	4b3f      	ldr	r3, [pc, #252]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e3c2:	5c9a      	ldrb	r2, [r3, r2]
 800e3c4:	687b      	ldr	r3, [r7, #4]
 800e3c6:	330b      	adds	r3, #11
 800e3c8:	404a      	eors	r2, r1
 800e3ca:	b2d2      	uxtb	r2, r2
 800e3cc:	701a      	strb	r2, [r3, #0]

    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800e3ce:	183b      	adds	r3, r7, r0
 800e3d0:	7b1b      	ldrb	r3, [r3, #12]
 800e3d2:	001a      	movs	r2, r3
 800e3d4:	4b3a      	ldr	r3, [pc, #232]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e3d6:	5c9a      	ldrb	r2, [r3, r2]
 800e3d8:	183b      	adds	r3, r7, r0
 800e3da:	785b      	ldrb	r3, [r3, #1]
 800e3dc:	0019      	movs	r1, r3
 800e3de:	4b39      	ldr	r3, [pc, #228]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e3e0:	5c5b      	ldrb	r3, [r3, r1]
 800e3e2:	4053      	eors	r3, r2
 800e3e4:	b2da      	uxtb	r2, r3
 800e3e6:	183b      	adds	r3, r7, r0
 800e3e8:	799b      	ldrb	r3, [r3, #6]
 800e3ea:	0019      	movs	r1, r3
 800e3ec:	4b36      	ldr	r3, [pc, #216]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e3ee:	5c5b      	ldrb	r3, [r3, r1]
 800e3f0:	4053      	eors	r3, r2
 800e3f2:	b2d9      	uxtb	r1, r3
 800e3f4:	183b      	adds	r3, r7, r0
 800e3f6:	7adb      	ldrb	r3, [r3, #11]
 800e3f8:	001a      	movs	r2, r3
 800e3fa:	4b33      	ldr	r3, [pc, #204]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e3fc:	5c9a      	ldrb	r2, [r3, r2]
 800e3fe:	687b      	ldr	r3, [r7, #4]
 800e400:	330c      	adds	r3, #12
 800e402:	404a      	eors	r2, r1
 800e404:	b2d2      	uxtb	r2, r2
 800e406:	701a      	strb	r2, [r3, #0]
    dt[13] = s_box(st[12]) ^ gfm2_sb(st[1]) ^ gfm3_sb(st[6]) ^ s_box(st[11]);
 800e408:	183b      	adds	r3, r7, r0
 800e40a:	7b1b      	ldrb	r3, [r3, #12]
 800e40c:	001a      	movs	r2, r3
 800e40e:	4b2e      	ldr	r3, [pc, #184]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e410:	5c9a      	ldrb	r2, [r3, r2]
 800e412:	183b      	adds	r3, r7, r0
 800e414:	785b      	ldrb	r3, [r3, #1]
 800e416:	0019      	movs	r1, r3
 800e418:	4b29      	ldr	r3, [pc, #164]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e41a:	5c5b      	ldrb	r3, [r3, r1]
 800e41c:	4053      	eors	r3, r2
 800e41e:	b2da      	uxtb	r2, r3
 800e420:	183b      	adds	r3, r7, r0
 800e422:	799b      	ldrb	r3, [r3, #6]
 800e424:	0019      	movs	r1, r3
 800e426:	4b27      	ldr	r3, [pc, #156]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e428:	5c5b      	ldrb	r3, [r3, r1]
 800e42a:	4053      	eors	r3, r2
 800e42c:	b2d9      	uxtb	r1, r3
 800e42e:	183b      	adds	r3, r7, r0
 800e430:	7adb      	ldrb	r3, [r3, #11]
 800e432:	001a      	movs	r2, r3
 800e434:	4b24      	ldr	r3, [pc, #144]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e436:	5c9a      	ldrb	r2, [r3, r2]
 800e438:	687b      	ldr	r3, [r7, #4]
 800e43a:	330d      	adds	r3, #13
 800e43c:	404a      	eors	r2, r1
 800e43e:	b2d2      	uxtb	r2, r2
 800e440:	701a      	strb	r2, [r3, #0]
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
 800e442:	183b      	adds	r3, r7, r0
 800e444:	7b1b      	ldrb	r3, [r3, #12]
 800e446:	001a      	movs	r2, r3
 800e448:	4b1f      	ldr	r3, [pc, #124]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e44a:	5c9a      	ldrb	r2, [r3, r2]
 800e44c:	183b      	adds	r3, r7, r0
 800e44e:	785b      	ldrb	r3, [r3, #1]
 800e450:	0019      	movs	r1, r3
 800e452:	4b1d      	ldr	r3, [pc, #116]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e454:	5c5b      	ldrb	r3, [r3, r1]
 800e456:	4053      	eors	r3, r2
 800e458:	b2da      	uxtb	r2, r3
 800e45a:	183b      	adds	r3, r7, r0
 800e45c:	799b      	ldrb	r3, [r3, #6]
 800e45e:	0019      	movs	r1, r3
 800e460:	4b17      	ldr	r3, [pc, #92]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e462:	5c5b      	ldrb	r3, [r3, r1]
 800e464:	4053      	eors	r3, r2
 800e466:	b2d9      	uxtb	r1, r3
 800e468:	183b      	adds	r3, r7, r0
 800e46a:	7adb      	ldrb	r3, [r3, #11]
 800e46c:	001a      	movs	r2, r3
 800e46e:	4b15      	ldr	r3, [pc, #84]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e470:	5c9a      	ldrb	r2, [r3, r2]
 800e472:	687b      	ldr	r3, [r7, #4]
 800e474:	330e      	adds	r3, #14
 800e476:	404a      	eors	r2, r1
 800e478:	b2d2      	uxtb	r2, r2
 800e47a:	701a      	strb	r2, [r3, #0]
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
 800e47c:	183b      	adds	r3, r7, r0
 800e47e:	7b1b      	ldrb	r3, [r3, #12]
 800e480:	001a      	movs	r2, r3
 800e482:	4b10      	ldr	r3, [pc, #64]	; (800e4c4 <mix_sub_columns+0x3c4>)
 800e484:	5c9a      	ldrb	r2, [r3, r2]
 800e486:	183b      	adds	r3, r7, r0
 800e488:	785b      	ldrb	r3, [r3, #1]
 800e48a:	0019      	movs	r1, r3
 800e48c:	4b0e      	ldr	r3, [pc, #56]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e48e:	5c5b      	ldrb	r3, [r3, r1]
 800e490:	4053      	eors	r3, r2
 800e492:	b2da      	uxtb	r2, r3
 800e494:	183b      	adds	r3, r7, r0
 800e496:	799b      	ldrb	r3, [r3, #6]
 800e498:	0019      	movs	r1, r3
 800e49a:	4b0b      	ldr	r3, [pc, #44]	; (800e4c8 <mix_sub_columns+0x3c8>)
 800e49c:	5c5b      	ldrb	r3, [r3, r1]
 800e49e:	4053      	eors	r3, r2
 800e4a0:	b2d9      	uxtb	r1, r3
 800e4a2:	183b      	adds	r3, r7, r0
 800e4a4:	7adb      	ldrb	r3, [r3, #11]
 800e4a6:	001a      	movs	r2, r3
 800e4a8:	4b05      	ldr	r3, [pc, #20]	; (800e4c0 <mix_sub_columns+0x3c0>)
 800e4aa:	5c9a      	ldrb	r2, [r3, r2]
 800e4ac:	687b      	ldr	r3, [r7, #4]
 800e4ae:	330f      	adds	r3, #15
 800e4b0:	404a      	eors	r2, r1
 800e4b2:	b2d2      	uxtb	r2, r2
 800e4b4:	701a      	strb	r2, [r3, #0]
  }
 800e4b6:	46c0      	nop			; (mov r8, r8)
 800e4b8:	46bd      	mov	sp, r7
 800e4ba:	b007      	add	sp, #28
 800e4bc:	bd90      	pop	{r4, r7, pc}
 800e4be:	46c0      	nop			; (mov r8, r8)
 800e4c0:	0801ef70 	.word	0x0801ef70
 800e4c4:	0801f070 	.word	0x0801f070
 800e4c8:	0801ee70 	.word	0x0801ee70

0800e4cc <aes_set_key>:
#if defined( AES_ENC_PREKEYED ) || defined( AES_DEC_PREKEYED )

/*  Set the cipher key for the pre-keyed version */

return_type aes_set_key( const uint8_t key[], length_type keylen, aes_context ctx[1] )
{
 800e4cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e4ce:	b087      	sub	sp, #28
 800e4d0:	af00      	add	r7, sp, #0
 800e4d2:	60f8      	str	r0, [r7, #12]
 800e4d4:	607a      	str	r2, [r7, #4]
 800e4d6:	200b      	movs	r0, #11
 800e4d8:	183b      	adds	r3, r7, r0
 800e4da:	1c0a      	adds	r2, r1, #0
 800e4dc:	701a      	strb	r2, [r3, #0]
    uint8_t cc, rc, hi;

    switch( keylen )
 800e4de:	183b      	adds	r3, r7, r0
 800e4e0:	781b      	ldrb	r3, [r3, #0]
 800e4e2:	3b10      	subs	r3, #16
 800e4e4:	2210      	movs	r2, #16
 800e4e6:	429a      	cmp	r2, r3
 800e4e8:	4192      	sbcs	r2, r2
 800e4ea:	4252      	negs	r2, r2
 800e4ec:	b2d2      	uxtb	r2, r2
 800e4ee:	2a00      	cmp	r2, #0
 800e4f0:	d109      	bne.n	800e506 <aes_set_key+0x3a>
 800e4f2:	2201      	movs	r2, #1
 800e4f4:	409a      	lsls	r2, r3
 800e4f6:	0013      	movs	r3, r2
 800e4f8:	4a90      	ldr	r2, [pc, #576]	; (800e73c <aes_set_key+0x270>)
 800e4fa:	4013      	ands	r3, r2
 800e4fc:	1e5a      	subs	r2, r3, #1
 800e4fe:	4193      	sbcs	r3, r2
 800e500:	b2db      	uxtb	r3, r3
 800e502:	2b00      	cmp	r3, #0
 800e504:	d105      	bne.n	800e512 <aes_set_key+0x46>
    case 16:
    case 24:
    case 32:
        break;
    default:
        ctx->rnd = 0;
 800e506:	687b      	ldr	r3, [r7, #4]
 800e508:	22f0      	movs	r2, #240	; 0xf0
 800e50a:	2100      	movs	r1, #0
 800e50c:	5499      	strb	r1, [r3, r2]
        return ( uint8_t )-1;
 800e50e:	23ff      	movs	r3, #255	; 0xff
 800e510:	e10f      	b.n	800e732 <aes_set_key+0x266>
        break;
 800e512:	46c0      	nop			; (mov r8, r8)
    }
    block_copy_nn(ctx->ksch, key, keylen);
 800e514:	6878      	ldr	r0, [r7, #4]
 800e516:	240b      	movs	r4, #11
 800e518:	193b      	adds	r3, r7, r4
 800e51a:	781a      	ldrb	r2, [r3, #0]
 800e51c:	68fb      	ldr	r3, [r7, #12]
 800e51e:	0019      	movs	r1, r3
 800e520:	f7ff fbb3 	bl	800dc8a <copy_block_nn>
    hi = (keylen + 28) << 2;
 800e524:	0020      	movs	r0, r4
 800e526:	183b      	adds	r3, r7, r0
 800e528:	781b      	ldrb	r3, [r3, #0]
 800e52a:	331c      	adds	r3, #28
 800e52c:	b2da      	uxtb	r2, r3
 800e52e:	2111      	movs	r1, #17
 800e530:	187b      	adds	r3, r7, r1
 800e532:	0092      	lsls	r2, r2, #2
 800e534:	701a      	strb	r2, [r3, #0]
    ctx->rnd = (hi >> 4) - 1;
 800e536:	187b      	adds	r3, r7, r1
 800e538:	781b      	ldrb	r3, [r3, #0]
 800e53a:	091b      	lsrs	r3, r3, #4
 800e53c:	b2db      	uxtb	r3, r3
 800e53e:	3b01      	subs	r3, #1
 800e540:	b2d9      	uxtb	r1, r3
 800e542:	687b      	ldr	r3, [r7, #4]
 800e544:	22f0      	movs	r2, #240	; 0xf0
 800e546:	5499      	strb	r1, [r3, r2]
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800e548:	2317      	movs	r3, #23
 800e54a:	18fb      	adds	r3, r7, r3
 800e54c:	183a      	adds	r2, r7, r0
 800e54e:	7812      	ldrb	r2, [r2, #0]
 800e550:	701a      	strb	r2, [r3, #0]
 800e552:	2316      	movs	r3, #22
 800e554:	18fb      	adds	r3, r7, r3
 800e556:	2201      	movs	r2, #1
 800e558:	701a      	strb	r2, [r3, #0]
 800e55a:	e0e0      	b.n	800e71e <aes_set_key+0x252>
    {   uint8_t tt, t0, t1, t2, t3;

        t0 = ctx->ksch[cc - 4];
 800e55c:	2017      	movs	r0, #23
 800e55e:	183b      	adds	r3, r7, r0
 800e560:	781b      	ldrb	r3, [r3, #0]
 800e562:	1f1a      	subs	r2, r3, #4
 800e564:	2415      	movs	r4, #21
 800e566:	193b      	adds	r3, r7, r4
 800e568:	6879      	ldr	r1, [r7, #4]
 800e56a:	5c8a      	ldrb	r2, [r1, r2]
 800e56c:	701a      	strb	r2, [r3, #0]
        t1 = ctx->ksch[cc - 3];
 800e56e:	183b      	adds	r3, r7, r0
 800e570:	781b      	ldrb	r3, [r3, #0]
 800e572:	1eda      	subs	r2, r3, #3
 800e574:	2514      	movs	r5, #20
 800e576:	197b      	adds	r3, r7, r5
 800e578:	6879      	ldr	r1, [r7, #4]
 800e57a:	5c8a      	ldrb	r2, [r1, r2]
 800e57c:	701a      	strb	r2, [r3, #0]
        t2 = ctx->ksch[cc - 2];
 800e57e:	183b      	adds	r3, r7, r0
 800e580:	781b      	ldrb	r3, [r3, #0]
 800e582:	1e9a      	subs	r2, r3, #2
 800e584:	2613      	movs	r6, #19
 800e586:	19bb      	adds	r3, r7, r6
 800e588:	6879      	ldr	r1, [r7, #4]
 800e58a:	5c8a      	ldrb	r2, [r1, r2]
 800e58c:	701a      	strb	r2, [r3, #0]
        t3 = ctx->ksch[cc - 1];
 800e58e:	183b      	adds	r3, r7, r0
 800e590:	781b      	ldrb	r3, [r3, #0]
 800e592:	1e5a      	subs	r2, r3, #1
 800e594:	2312      	movs	r3, #18
 800e596:	18fb      	adds	r3, r7, r3
 800e598:	6879      	ldr	r1, [r7, #4]
 800e59a:	5c8a      	ldrb	r2, [r1, r2]
 800e59c:	701a      	strb	r2, [r3, #0]
        if( cc % keylen == 0 )
 800e59e:	183a      	adds	r2, r7, r0
 800e5a0:	210b      	movs	r1, #11
 800e5a2:	187b      	adds	r3, r7, r1
 800e5a4:	7812      	ldrb	r2, [r2, #0]
 800e5a6:	781b      	ldrb	r3, [r3, #0]
 800e5a8:	0019      	movs	r1, r3
 800e5aa:	0010      	movs	r0, r2
 800e5ac:	f7f1 fe3c 	bl	8000228 <__aeabi_uidivmod>
 800e5b0:	000b      	movs	r3, r1
 800e5b2:	b2db      	uxtb	r3, r3
 800e5b4:	2b00      	cmp	r3, #0
 800e5b6:	d13b      	bne.n	800e630 <aes_set_key+0x164>
        {
            tt = t0;
 800e5b8:	2210      	movs	r2, #16
 800e5ba:	18bb      	adds	r3, r7, r2
 800e5bc:	193a      	adds	r2, r7, r4
 800e5be:	7812      	ldrb	r2, [r2, #0]
 800e5c0:	701a      	strb	r2, [r3, #0]
            t0 = s_box(t1) ^ rc;
 800e5c2:	197b      	adds	r3, r7, r5
 800e5c4:	781b      	ldrb	r3, [r3, #0]
 800e5c6:	4a5e      	ldr	r2, [pc, #376]	; (800e740 <aes_set_key+0x274>)
 800e5c8:	5cd1      	ldrb	r1, [r2, r3]
 800e5ca:	193b      	adds	r3, r7, r4
 800e5cc:	2016      	movs	r0, #22
 800e5ce:	183a      	adds	r2, r7, r0
 800e5d0:	7812      	ldrb	r2, [r2, #0]
 800e5d2:	404a      	eors	r2, r1
 800e5d4:	701a      	strb	r2, [r3, #0]
            t1 = s_box(t2);
 800e5d6:	19bb      	adds	r3, r7, r6
 800e5d8:	781a      	ldrb	r2, [r3, #0]
 800e5da:	197b      	adds	r3, r7, r5
 800e5dc:	4958      	ldr	r1, [pc, #352]	; (800e740 <aes_set_key+0x274>)
 800e5de:	5c8a      	ldrb	r2, [r1, r2]
 800e5e0:	701a      	strb	r2, [r3, #0]
            t2 = s_box(t3);
 800e5e2:	2412      	movs	r4, #18
 800e5e4:	193b      	adds	r3, r7, r4
 800e5e6:	781a      	ldrb	r2, [r3, #0]
 800e5e8:	19bb      	adds	r3, r7, r6
 800e5ea:	4955      	ldr	r1, [pc, #340]	; (800e740 <aes_set_key+0x274>)
 800e5ec:	5c8a      	ldrb	r2, [r1, r2]
 800e5ee:	701a      	strb	r2, [r3, #0]
            t3 = s_box(tt);
 800e5f0:	2210      	movs	r2, #16
 800e5f2:	18bb      	adds	r3, r7, r2
 800e5f4:	781a      	ldrb	r2, [r3, #0]
 800e5f6:	193b      	adds	r3, r7, r4
 800e5f8:	4951      	ldr	r1, [pc, #324]	; (800e740 <aes_set_key+0x274>)
 800e5fa:	5c8a      	ldrb	r2, [r1, r2]
 800e5fc:	701a      	strb	r2, [r3, #0]
            rc = f2(rc);
 800e5fe:	183b      	adds	r3, r7, r0
 800e600:	781b      	ldrb	r3, [r3, #0]
 800e602:	005b      	lsls	r3, r3, #1
 800e604:	b25a      	sxtb	r2, r3
 800e606:	0004      	movs	r4, r0
 800e608:	183b      	adds	r3, r7, r0
 800e60a:	781b      	ldrb	r3, [r3, #0]
 800e60c:	09db      	lsrs	r3, r3, #7
 800e60e:	b2db      	uxtb	r3, r3
 800e610:	1c19      	adds	r1, r3, #0
 800e612:	1c0b      	adds	r3, r1, #0
 800e614:	18db      	adds	r3, r3, r3
 800e616:	185b      	adds	r3, r3, r1
 800e618:	1c19      	adds	r1, r3, #0
 800e61a:	00c8      	lsls	r0, r1, #3
 800e61c:	1c19      	adds	r1, r3, #0
 800e61e:	1c03      	adds	r3, r0, #0
 800e620:	18cb      	adds	r3, r1, r3
 800e622:	b2db      	uxtb	r3, r3
 800e624:	b25b      	sxtb	r3, r3
 800e626:	4053      	eors	r3, r2
 800e628:	b25a      	sxtb	r2, r3
 800e62a:	193b      	adds	r3, r7, r4
 800e62c:	701a      	strb	r2, [r3, #0]
 800e62e:	e02d      	b.n	800e68c <aes_set_key+0x1c0>
        }
        else if( keylen > 24 && cc % keylen == 16 )
 800e630:	210b      	movs	r1, #11
 800e632:	187b      	adds	r3, r7, r1
 800e634:	781b      	ldrb	r3, [r3, #0]
 800e636:	2b18      	cmp	r3, #24
 800e638:	d928      	bls.n	800e68c <aes_set_key+0x1c0>
 800e63a:	2317      	movs	r3, #23
 800e63c:	18fa      	adds	r2, r7, r3
 800e63e:	187b      	adds	r3, r7, r1
 800e640:	7812      	ldrb	r2, [r2, #0]
 800e642:	781b      	ldrb	r3, [r3, #0]
 800e644:	0019      	movs	r1, r3
 800e646:	0010      	movs	r0, r2
 800e648:	f7f1 fdee 	bl	8000228 <__aeabi_uidivmod>
 800e64c:	000b      	movs	r3, r1
 800e64e:	b2db      	uxtb	r3, r3
 800e650:	2b10      	cmp	r3, #16
 800e652:	d11b      	bne.n	800e68c <aes_set_key+0x1c0>
        {
            t0 = s_box(t0);
 800e654:	2115      	movs	r1, #21
 800e656:	187b      	adds	r3, r7, r1
 800e658:	781a      	ldrb	r2, [r3, #0]
 800e65a:	187b      	adds	r3, r7, r1
 800e65c:	4938      	ldr	r1, [pc, #224]	; (800e740 <aes_set_key+0x274>)
 800e65e:	5c8a      	ldrb	r2, [r1, r2]
 800e660:	701a      	strb	r2, [r3, #0]
            t1 = s_box(t1);
 800e662:	2114      	movs	r1, #20
 800e664:	187b      	adds	r3, r7, r1
 800e666:	781a      	ldrb	r2, [r3, #0]
 800e668:	187b      	adds	r3, r7, r1
 800e66a:	4935      	ldr	r1, [pc, #212]	; (800e740 <aes_set_key+0x274>)
 800e66c:	5c8a      	ldrb	r2, [r1, r2]
 800e66e:	701a      	strb	r2, [r3, #0]
            t2 = s_box(t2);
 800e670:	2113      	movs	r1, #19
 800e672:	187b      	adds	r3, r7, r1
 800e674:	781a      	ldrb	r2, [r3, #0]
 800e676:	187b      	adds	r3, r7, r1
 800e678:	4931      	ldr	r1, [pc, #196]	; (800e740 <aes_set_key+0x274>)
 800e67a:	5c8a      	ldrb	r2, [r1, r2]
 800e67c:	701a      	strb	r2, [r3, #0]
            t3 = s_box(t3);
 800e67e:	2112      	movs	r1, #18
 800e680:	187b      	adds	r3, r7, r1
 800e682:	781a      	ldrb	r2, [r3, #0]
 800e684:	187b      	adds	r3, r7, r1
 800e686:	492e      	ldr	r1, [pc, #184]	; (800e740 <aes_set_key+0x274>)
 800e688:	5c8a      	ldrb	r2, [r1, r2]
 800e68a:	701a      	strb	r2, [r3, #0]
        }
        tt = cc - keylen;
 800e68c:	2410      	movs	r4, #16
 800e68e:	193b      	adds	r3, r7, r4
 800e690:	2017      	movs	r0, #23
 800e692:	1839      	adds	r1, r7, r0
 800e694:	220b      	movs	r2, #11
 800e696:	18ba      	adds	r2, r7, r2
 800e698:	7809      	ldrb	r1, [r1, #0]
 800e69a:	7812      	ldrb	r2, [r2, #0]
 800e69c:	1a8a      	subs	r2, r1, r2
 800e69e:	701a      	strb	r2, [r3, #0]
        ctx->ksch[cc + 0] = ctx->ksch[tt + 0] ^ t0;
 800e6a0:	193b      	adds	r3, r7, r4
 800e6a2:	781b      	ldrb	r3, [r3, #0]
 800e6a4:	687a      	ldr	r2, [r7, #4]
 800e6a6:	5cd1      	ldrb	r1, [r2, r3]
 800e6a8:	183b      	adds	r3, r7, r0
 800e6aa:	781b      	ldrb	r3, [r3, #0]
 800e6ac:	2215      	movs	r2, #21
 800e6ae:	18ba      	adds	r2, r7, r2
 800e6b0:	7812      	ldrb	r2, [r2, #0]
 800e6b2:	404a      	eors	r2, r1
 800e6b4:	b2d1      	uxtb	r1, r2
 800e6b6:	687a      	ldr	r2, [r7, #4]
 800e6b8:	54d1      	strb	r1, [r2, r3]
        ctx->ksch[cc + 1] = ctx->ksch[tt + 1] ^ t1;
 800e6ba:	193b      	adds	r3, r7, r4
 800e6bc:	781b      	ldrb	r3, [r3, #0]
 800e6be:	3301      	adds	r3, #1
 800e6c0:	687a      	ldr	r2, [r7, #4]
 800e6c2:	5cd1      	ldrb	r1, [r2, r3]
 800e6c4:	183b      	adds	r3, r7, r0
 800e6c6:	781b      	ldrb	r3, [r3, #0]
 800e6c8:	3301      	adds	r3, #1
 800e6ca:	2214      	movs	r2, #20
 800e6cc:	18ba      	adds	r2, r7, r2
 800e6ce:	7812      	ldrb	r2, [r2, #0]
 800e6d0:	404a      	eors	r2, r1
 800e6d2:	b2d1      	uxtb	r1, r2
 800e6d4:	687a      	ldr	r2, [r7, #4]
 800e6d6:	54d1      	strb	r1, [r2, r3]
        ctx->ksch[cc + 2] = ctx->ksch[tt + 2] ^ t2;
 800e6d8:	193b      	adds	r3, r7, r4
 800e6da:	781b      	ldrb	r3, [r3, #0]
 800e6dc:	3302      	adds	r3, #2
 800e6de:	687a      	ldr	r2, [r7, #4]
 800e6e0:	5cd1      	ldrb	r1, [r2, r3]
 800e6e2:	183b      	adds	r3, r7, r0
 800e6e4:	781b      	ldrb	r3, [r3, #0]
 800e6e6:	3302      	adds	r3, #2
 800e6e8:	2213      	movs	r2, #19
 800e6ea:	18ba      	adds	r2, r7, r2
 800e6ec:	7812      	ldrb	r2, [r2, #0]
 800e6ee:	404a      	eors	r2, r1
 800e6f0:	b2d1      	uxtb	r1, r2
 800e6f2:	687a      	ldr	r2, [r7, #4]
 800e6f4:	54d1      	strb	r1, [r2, r3]
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
 800e6f6:	193b      	adds	r3, r7, r4
 800e6f8:	781b      	ldrb	r3, [r3, #0]
 800e6fa:	3303      	adds	r3, #3
 800e6fc:	687a      	ldr	r2, [r7, #4]
 800e6fe:	5cd1      	ldrb	r1, [r2, r3]
 800e700:	183b      	adds	r3, r7, r0
 800e702:	781b      	ldrb	r3, [r3, #0]
 800e704:	3303      	adds	r3, #3
 800e706:	2212      	movs	r2, #18
 800e708:	18ba      	adds	r2, r7, r2
 800e70a:	7812      	ldrb	r2, [r2, #0]
 800e70c:	404a      	eors	r2, r1
 800e70e:	b2d1      	uxtb	r1, r2
 800e710:	687a      	ldr	r2, [r7, #4]
 800e712:	54d1      	strb	r1, [r2, r3]
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800e714:	183b      	adds	r3, r7, r0
 800e716:	183a      	adds	r2, r7, r0
 800e718:	7812      	ldrb	r2, [r2, #0]
 800e71a:	3204      	adds	r2, #4
 800e71c:	701a      	strb	r2, [r3, #0]
 800e71e:	2317      	movs	r3, #23
 800e720:	18fa      	adds	r2, r7, r3
 800e722:	2311      	movs	r3, #17
 800e724:	18fb      	adds	r3, r7, r3
 800e726:	7812      	ldrb	r2, [r2, #0]
 800e728:	781b      	ldrb	r3, [r3, #0]
 800e72a:	429a      	cmp	r2, r3
 800e72c:	d200      	bcs.n	800e730 <aes_set_key+0x264>
 800e72e:	e715      	b.n	800e55c <aes_set_key+0x90>
    }
    return 0;
 800e730:	2300      	movs	r3, #0
}
 800e732:	0018      	movs	r0, r3
 800e734:	46bd      	mov	sp, r7
 800e736:	b007      	add	sp, #28
 800e738:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e73a:	46c0      	nop			; (mov r8, r8)
 800e73c:	00010101 	.word	0x00010101
 800e740:	0801ee70 	.word	0x0801ee70

0800e744 <aes_encrypt>:
#if defined( AES_ENC_PREKEYED )

/*  Encrypt a single block of 16 bytes */

return_type aes_encrypt( const uint8_t in[N_BLOCK], uint8_t  out[N_BLOCK], const aes_context ctx[1] )
{
 800e744:	b5b0      	push	{r4, r5, r7, lr}
 800e746:	b08a      	sub	sp, #40	; 0x28
 800e748:	af00      	add	r7, sp, #0
 800e74a:	60f8      	str	r0, [r7, #12]
 800e74c:	60b9      	str	r1, [r7, #8]
 800e74e:	607a      	str	r2, [r7, #4]
    if( ctx->rnd )
 800e750:	687b      	ldr	r3, [r7, #4]
 800e752:	22f0      	movs	r2, #240	; 0xf0
 800e754:	5c9b      	ldrb	r3, [r3, r2]
 800e756:	2b00      	cmp	r3, #0
 800e758:	d039      	beq.n	800e7ce <aes_encrypt+0x8a>
    {
        uint8_t s1[N_BLOCK], r;
        copy_and_key( s1, in, ctx->ksch );
 800e75a:	687a      	ldr	r2, [r7, #4]
 800e75c:	68f9      	ldr	r1, [r7, #12]
 800e75e:	2314      	movs	r3, #20
 800e760:	18fb      	adds	r3, r7, r3
 800e762:	0018      	movs	r0, r3
 800e764:	f7ff fb63 	bl	800de2e <copy_and_key>

        for( r = 1 ; r < ctx->rnd ; ++r )
 800e768:	2327      	movs	r3, #39	; 0x27
 800e76a:	18fb      	adds	r3, r7, r3
 800e76c:	2201      	movs	r2, #1
 800e76e:	701a      	strb	r2, [r3, #0]
 800e770:	e014      	b.n	800e79c <aes_encrypt+0x58>
#if defined( VERSION_1 )
        {
            mix_sub_columns( s1 );
 800e772:	2514      	movs	r5, #20
 800e774:	197b      	adds	r3, r7, r5
 800e776:	0018      	movs	r0, r3
 800e778:	f7ff fcc2 	bl	800e100 <mix_sub_columns>
            add_round_key( s1, ctx->ksch + r * N_BLOCK);
 800e77c:	687b      	ldr	r3, [r7, #4]
 800e77e:	2427      	movs	r4, #39	; 0x27
 800e780:	193a      	adds	r2, r7, r4
 800e782:	7812      	ldrb	r2, [r2, #0]
 800e784:	0112      	lsls	r2, r2, #4
 800e786:	189a      	adds	r2, r3, r2
 800e788:	197b      	adds	r3, r7, r5
 800e78a:	0011      	movs	r1, r2
 800e78c:	0018      	movs	r0, r3
 800e78e:	f7ff fc05 	bl	800df9c <add_round_key>
        for( r = 1 ; r < ctx->rnd ; ++r )
 800e792:	193b      	adds	r3, r7, r4
 800e794:	193a      	adds	r2, r7, r4
 800e796:	7812      	ldrb	r2, [r2, #0]
 800e798:	3201      	adds	r2, #1
 800e79a:	701a      	strb	r2, [r3, #0]
 800e79c:	687b      	ldr	r3, [r7, #4]
 800e79e:	22f0      	movs	r2, #240	; 0xf0
 800e7a0:	5c9b      	ldrb	r3, [r3, r2]
 800e7a2:	2427      	movs	r4, #39	; 0x27
 800e7a4:	193a      	adds	r2, r7, r4
 800e7a6:	7812      	ldrb	r2, [r2, #0]
 800e7a8:	429a      	cmp	r2, r3
 800e7aa:	d3e2      	bcc.n	800e772 <aes_encrypt+0x2e>
        {   uint8_t s2[N_BLOCK];
            mix_sub_columns( s2, s1 );
            copy_and_key( s1, s2, ctx->ksch + r * N_BLOCK);
        }
#endif
        shift_sub_rows( s1 );
 800e7ac:	2514      	movs	r5, #20
 800e7ae:	197b      	adds	r3, r7, r5
 800e7b0:	0018      	movs	r0, r3
 800e7b2:	f7ff fc03 	bl	800dfbc <shift_sub_rows>
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
 800e7b6:	687b      	ldr	r3, [r7, #4]
 800e7b8:	193a      	adds	r2, r7, r4
 800e7ba:	7812      	ldrb	r2, [r2, #0]
 800e7bc:	0112      	lsls	r2, r2, #4
 800e7be:	189a      	adds	r2, r3, r2
 800e7c0:	1979      	adds	r1, r7, r5
 800e7c2:	68bb      	ldr	r3, [r7, #8]
 800e7c4:	0018      	movs	r0, r3
 800e7c6:	f7ff fb32 	bl	800de2e <copy_and_key>
    }
    else
        return ( uint8_t )-1;
    return 0;
 800e7ca:	2300      	movs	r3, #0
 800e7cc:	e000      	b.n	800e7d0 <aes_encrypt+0x8c>
        return ( uint8_t )-1;
 800e7ce:	23ff      	movs	r3, #255	; 0xff
}
 800e7d0:	0018      	movs	r0, r3
 800e7d2:	46bd      	mov	sp, r7
 800e7d4:	b00a      	add	sp, #40	; 0x28
 800e7d6:	bdb0      	pop	{r4, r5, r7, pc}

0800e7d8 <AES_CMAC_Init>:
        }                          \
    } while (0) \


void AES_CMAC_Init(AES_CMAC_CTX *ctx)
{
 800e7d8:	b580      	push	{r7, lr}
 800e7da:	b082      	sub	sp, #8
 800e7dc:	af00      	add	r7, sp, #0
 800e7de:	6078      	str	r0, [r7, #4]
            memset1(ctx->X, 0, sizeof ctx->X);
 800e7e0:	687b      	ldr	r3, [r7, #4]
 800e7e2:	33f1      	adds	r3, #241	; 0xf1
 800e7e4:	2210      	movs	r2, #16
 800e7e6:	2100      	movs	r1, #0
 800e7e8:	0018      	movs	r0, r3
 800e7ea:	f00c feeb 	bl	801b5c4 <memset1>
            ctx->M_n = 0;
 800e7ee:	687a      	ldr	r2, [r7, #4]
 800e7f0:	238a      	movs	r3, #138	; 0x8a
 800e7f2:	005b      	lsls	r3, r3, #1
 800e7f4:	2100      	movs	r1, #0
 800e7f6:	50d1      	str	r1, [r2, r3]
        memset1(ctx->rijndael.ksch, '\0', 240);
 800e7f8:	687b      	ldr	r3, [r7, #4]
 800e7fa:	22f0      	movs	r2, #240	; 0xf0
 800e7fc:	2100      	movs	r1, #0
 800e7fe:	0018      	movs	r0, r3
 800e800:	f00c fee0 	bl	801b5c4 <memset1>
}
 800e804:	46c0      	nop			; (mov r8, r8)
 800e806:	46bd      	mov	sp, r7
 800e808:	b002      	add	sp, #8
 800e80a:	bd80      	pop	{r7, pc}

0800e80c <AES_CMAC_SetKey>:
    
void AES_CMAC_SetKey(AES_CMAC_CTX *ctx, const uint8_t key[AES_CMAC_KEY_LENGTH])
{
 800e80c:	b580      	push	{r7, lr}
 800e80e:	b082      	sub	sp, #8
 800e810:	af00      	add	r7, sp, #0
 800e812:	6078      	str	r0, [r7, #4]
 800e814:	6039      	str	r1, [r7, #0]
           //rijndael_set_key_enc_only(&ctx->rijndael, key, 128);
       aes_set_key( key, AES_CMAC_KEY_LENGTH, &ctx->rijndael);
 800e816:	687a      	ldr	r2, [r7, #4]
 800e818:	683b      	ldr	r3, [r7, #0]
 800e81a:	2110      	movs	r1, #16
 800e81c:	0018      	movs	r0, r3
 800e81e:	f7ff fe55 	bl	800e4cc <aes_set_key>
}
 800e822:	46c0      	nop			; (mov r8, r8)
 800e824:	46bd      	mov	sp, r7
 800e826:	b002      	add	sp, #8
 800e828:	bd80      	pop	{r7, pc}

0800e82a <AES_CMAC_Update>:
    
void AES_CMAC_Update(AES_CMAC_CTX *ctx, const uint8_t *data, uint32_t len)
{
 800e82a:	b590      	push	{r4, r7, lr}
 800e82c:	b08d      	sub	sp, #52	; 0x34
 800e82e:	af00      	add	r7, sp, #0
 800e830:	60f8      	str	r0, [r7, #12]
 800e832:	60b9      	str	r1, [r7, #8]
 800e834:	607a      	str	r2, [r7, #4]
            uint32_t mlen;
        uint8_t in[16];
    
            if (ctx->M_n > 0) {
 800e836:	68fa      	ldr	r2, [r7, #12]
 800e838:	238a      	movs	r3, #138	; 0x8a
 800e83a:	005b      	lsls	r3, r3, #1
 800e83c:	58d3      	ldr	r3, [r2, r3]
 800e83e:	2b00      	cmp	r3, #0
 800e840:	d100      	bne.n	800e844 <AES_CMAC_Update+0x1a>
 800e842:	e097      	b.n	800e974 <AES_CMAC_Update+0x14a>
                  mlen = MIN(16 - ctx->M_n, len);
 800e844:	68fa      	ldr	r2, [r7, #12]
 800e846:	238a      	movs	r3, #138	; 0x8a
 800e848:	005b      	lsls	r3, r3, #1
 800e84a:	58d3      	ldr	r3, [r2, r3]
 800e84c:	2210      	movs	r2, #16
 800e84e:	1ad2      	subs	r2, r2, r3
 800e850:	687b      	ldr	r3, [r7, #4]
 800e852:	4293      	cmp	r3, r2
 800e854:	d900      	bls.n	800e858 <AES_CMAC_Update+0x2e>
 800e856:	0013      	movs	r3, r2
 800e858:	627b      	str	r3, [r7, #36]	; 0x24
                    memcpy1(ctx->M_last + ctx->M_n, data, mlen);
 800e85a:	68fb      	ldr	r3, [r7, #12]
 800e85c:	1c9a      	adds	r2, r3, #2
 800e85e:	32ff      	adds	r2, #255	; 0xff
 800e860:	68f9      	ldr	r1, [r7, #12]
 800e862:	238a      	movs	r3, #138	; 0x8a
 800e864:	005b      	lsls	r3, r3, #1
 800e866:	58cb      	ldr	r3, [r1, r3]
 800e868:	18d3      	adds	r3, r2, r3
 800e86a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e86c:	b292      	uxth	r2, r2
 800e86e:	68b9      	ldr	r1, [r7, #8]
 800e870:	0018      	movs	r0, r3
 800e872:	f00c fe69 	bl	801b548 <memcpy1>
                    ctx->M_n += mlen;
 800e876:	68fa      	ldr	r2, [r7, #12]
 800e878:	238a      	movs	r3, #138	; 0x8a
 800e87a:	005b      	lsls	r3, r3, #1
 800e87c:	58d2      	ldr	r2, [r2, r3]
 800e87e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e880:	18d1      	adds	r1, r2, r3
 800e882:	68fa      	ldr	r2, [r7, #12]
 800e884:	238a      	movs	r3, #138	; 0x8a
 800e886:	005b      	lsls	r3, r3, #1
 800e888:	50d1      	str	r1, [r2, r3]
                    if (ctx->M_n < 16 || len == mlen)
 800e88a:	68fa      	ldr	r2, [r7, #12]
 800e88c:	238a      	movs	r3, #138	; 0x8a
 800e88e:	005b      	lsls	r3, r3, #1
 800e890:	58d3      	ldr	r3, [r2, r3]
 800e892:	2b0f      	cmp	r3, #15
 800e894:	d800      	bhi.n	800e898 <AES_CMAC_Update+0x6e>
 800e896:	e07f      	b.n	800e998 <AES_CMAC_Update+0x16e>
 800e898:	687a      	ldr	r2, [r7, #4]
 800e89a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e89c:	429a      	cmp	r2, r3
 800e89e:	d100      	bne.n	800e8a2 <AES_CMAC_Update+0x78>
 800e8a0:	e07a      	b.n	800e998 <AES_CMAC_Update+0x16e>
                            return;
                   XOR(ctx->M_last, ctx->X);
 800e8a2:	2300      	movs	r3, #0
 800e8a4:	62fb      	str	r3, [r7, #44]	; 0x2c
 800e8a6:	e018      	b.n	800e8da <AES_CMAC_Update+0xb0>
 800e8a8:	68fa      	ldr	r2, [r7, #12]
 800e8aa:	21f1      	movs	r1, #241	; 0xf1
 800e8ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e8ae:	18d3      	adds	r3, r2, r3
 800e8b0:	185b      	adds	r3, r3, r1
 800e8b2:	781a      	ldrb	r2, [r3, #0]
 800e8b4:	68f8      	ldr	r0, [r7, #12]
 800e8b6:	2302      	movs	r3, #2
 800e8b8:	33ff      	adds	r3, #255	; 0xff
 800e8ba:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800e8bc:	1841      	adds	r1, r0, r1
 800e8be:	18cb      	adds	r3, r1, r3
 800e8c0:	781b      	ldrb	r3, [r3, #0]
 800e8c2:	4053      	eors	r3, r2
 800e8c4:	b2d8      	uxtb	r0, r3
 800e8c6:	68fa      	ldr	r2, [r7, #12]
 800e8c8:	21f1      	movs	r1, #241	; 0xf1
 800e8ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e8cc:	18d3      	adds	r3, r2, r3
 800e8ce:	185b      	adds	r3, r3, r1
 800e8d0:	1c02      	adds	r2, r0, #0
 800e8d2:	701a      	strb	r2, [r3, #0]
 800e8d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e8d6:	3301      	adds	r3, #1
 800e8d8:	62fb      	str	r3, [r7, #44]	; 0x2c
 800e8da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e8dc:	2b0f      	cmp	r3, #15
 800e8de:	dde3      	ble.n	800e8a8 <AES_CMAC_Update+0x7e>
                    //rijndael_encrypt(&ctx->rijndael, ctx->X, ctx->X);
            aes_encrypt( ctx->X, ctx->X, &ctx->rijndael);
 800e8e0:	68fb      	ldr	r3, [r7, #12]
 800e8e2:	33f1      	adds	r3, #241	; 0xf1
 800e8e4:	0018      	movs	r0, r3
 800e8e6:	68fb      	ldr	r3, [r7, #12]
 800e8e8:	33f1      	adds	r3, #241	; 0xf1
 800e8ea:	68fa      	ldr	r2, [r7, #12]
 800e8ec:	0019      	movs	r1, r3
 800e8ee:	f7ff ff29 	bl	800e744 <aes_encrypt>
                    data += mlen;
 800e8f2:	68ba      	ldr	r2, [r7, #8]
 800e8f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e8f6:	18d3      	adds	r3, r2, r3
 800e8f8:	60bb      	str	r3, [r7, #8]
                    len -= mlen;
 800e8fa:	687a      	ldr	r2, [r7, #4]
 800e8fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e8fe:	1ad3      	subs	r3, r2, r3
 800e900:	607b      	str	r3, [r7, #4]
            }
            while (len > 16) {      /* not last block */
 800e902:	e037      	b.n	800e974 <AES_CMAC_Update+0x14a>

                    XOR(data, ctx->X);
 800e904:	2300      	movs	r3, #0
 800e906:	62bb      	str	r3, [r7, #40]	; 0x28
 800e908:	e015      	b.n	800e936 <AES_CMAC_Update+0x10c>
 800e90a:	68fa      	ldr	r2, [r7, #12]
 800e90c:	21f1      	movs	r1, #241	; 0xf1
 800e90e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e910:	18d3      	adds	r3, r2, r3
 800e912:	185b      	adds	r3, r3, r1
 800e914:	781a      	ldrb	r2, [r3, #0]
 800e916:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e918:	68b9      	ldr	r1, [r7, #8]
 800e91a:	18cb      	adds	r3, r1, r3
 800e91c:	781b      	ldrb	r3, [r3, #0]
 800e91e:	4053      	eors	r3, r2
 800e920:	b2d8      	uxtb	r0, r3
 800e922:	68fa      	ldr	r2, [r7, #12]
 800e924:	21f1      	movs	r1, #241	; 0xf1
 800e926:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e928:	18d3      	adds	r3, r2, r3
 800e92a:	185b      	adds	r3, r3, r1
 800e92c:	1c02      	adds	r2, r0, #0
 800e92e:	701a      	strb	r2, [r3, #0]
 800e930:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e932:	3301      	adds	r3, #1
 800e934:	62bb      	str	r3, [r7, #40]	; 0x28
 800e936:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e938:	2b0f      	cmp	r3, #15
 800e93a:	dde6      	ble.n	800e90a <AES_CMAC_Update+0xe0>
                    //rijndael_encrypt(&ctx->rijndael, ctx->X, ctx->X);

                    memcpy1(in, &ctx->X[0], 16); //Bestela ez du ondo iten
 800e93c:	68fb      	ldr	r3, [r7, #12]
 800e93e:	33f1      	adds	r3, #241	; 0xf1
 800e940:	0019      	movs	r1, r3
 800e942:	2414      	movs	r4, #20
 800e944:	193b      	adds	r3, r7, r4
 800e946:	2210      	movs	r2, #16
 800e948:	0018      	movs	r0, r3
 800e94a:	f00c fdfd 	bl	801b548 <memcpy1>
            aes_encrypt( in, in, &ctx->rijndael);
 800e94e:	68fa      	ldr	r2, [r7, #12]
 800e950:	1939      	adds	r1, r7, r4
 800e952:	193b      	adds	r3, r7, r4
 800e954:	0018      	movs	r0, r3
 800e956:	f7ff fef5 	bl	800e744 <aes_encrypt>
                    memcpy1(&ctx->X[0], in, 16);
 800e95a:	68fb      	ldr	r3, [r7, #12]
 800e95c:	33f1      	adds	r3, #241	; 0xf1
 800e95e:	1939      	adds	r1, r7, r4
 800e960:	2210      	movs	r2, #16
 800e962:	0018      	movs	r0, r3
 800e964:	f00c fdf0 	bl	801b548 <memcpy1>

                    data += 16;
 800e968:	68bb      	ldr	r3, [r7, #8]
 800e96a:	3310      	adds	r3, #16
 800e96c:	60bb      	str	r3, [r7, #8]
                    len -= 16;
 800e96e:	687b      	ldr	r3, [r7, #4]
 800e970:	3b10      	subs	r3, #16
 800e972:	607b      	str	r3, [r7, #4]
            while (len > 16) {      /* not last block */
 800e974:	687b      	ldr	r3, [r7, #4]
 800e976:	2b10      	cmp	r3, #16
 800e978:	d8c4      	bhi.n	800e904 <AES_CMAC_Update+0xda>
            }
            /* potential last block, save it */
            memcpy1(ctx->M_last, data, len);
 800e97a:	68fb      	ldr	r3, [r7, #12]
 800e97c:	3302      	adds	r3, #2
 800e97e:	33ff      	adds	r3, #255	; 0xff
 800e980:	687a      	ldr	r2, [r7, #4]
 800e982:	b292      	uxth	r2, r2
 800e984:	68b9      	ldr	r1, [r7, #8]
 800e986:	0018      	movs	r0, r3
 800e988:	f00c fdde 	bl	801b548 <memcpy1>
            ctx->M_n = len;
 800e98c:	68fa      	ldr	r2, [r7, #12]
 800e98e:	238a      	movs	r3, #138	; 0x8a
 800e990:	005b      	lsls	r3, r3, #1
 800e992:	6879      	ldr	r1, [r7, #4]
 800e994:	50d1      	str	r1, [r2, r3]
 800e996:	e000      	b.n	800e99a <AES_CMAC_Update+0x170>
                            return;
 800e998:	46c0      	nop			; (mov r8, r8)
}
 800e99a:	46bd      	mov	sp, r7
 800e99c:	b00d      	add	sp, #52	; 0x34
 800e99e:	bd90      	pop	{r4, r7, pc}

0800e9a0 <AES_CMAC_Final>:
   
void AES_CMAC_Final(uint8_t digest[AES_CMAC_DIGEST_LENGTH], AES_CMAC_CTX *ctx)
{
 800e9a0:	b590      	push	{r4, r7, lr}
 800e9a2:	b093      	sub	sp, #76	; 0x4c
 800e9a4:	af00      	add	r7, sp, #0
 800e9a6:	6078      	str	r0, [r7, #4]
 800e9a8:	6039      	str	r1, [r7, #0]
            uint8_t K[16];
        uint8_t in[16];
            /* generate subkey K1 */
            memset1(K, '\0', 16);
 800e9aa:	241c      	movs	r4, #28
 800e9ac:	193b      	adds	r3, r7, r4
 800e9ae:	2210      	movs	r2, #16
 800e9b0:	2100      	movs	r1, #0
 800e9b2:	0018      	movs	r0, r3
 800e9b4:	f00c fe06 	bl	801b5c4 <memset1>

            //rijndael_encrypt(&ctx->rijndael, K, K);

            aes_encrypt( K, K, &ctx->rijndael);
 800e9b8:	683a      	ldr	r2, [r7, #0]
 800e9ba:	1939      	adds	r1, r7, r4
 800e9bc:	193b      	adds	r3, r7, r4
 800e9be:	0018      	movs	r0, r3
 800e9c0:	f7ff fec0 	bl	800e744 <aes_encrypt>

            if (K[0] & 0x80) {
 800e9c4:	193b      	adds	r3, r7, r4
 800e9c6:	781b      	ldrb	r3, [r3, #0]
 800e9c8:	b25b      	sxtb	r3, r3
 800e9ca:	2b00      	cmp	r3, #0
 800e9cc:	da2e      	bge.n	800ea2c <AES_CMAC_Final+0x8c>
                    LSHIFT(K, K);
 800e9ce:	2300      	movs	r3, #0
 800e9d0:	647b      	str	r3, [r7, #68]	; 0x44
 800e9d2:	e018      	b.n	800ea06 <AES_CMAC_Final+0x66>
 800e9d4:	201c      	movs	r0, #28
 800e9d6:	183a      	adds	r2, r7, r0
 800e9d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e9da:	18d3      	adds	r3, r2, r3
 800e9dc:	781b      	ldrb	r3, [r3, #0]
 800e9de:	005b      	lsls	r3, r3, #1
 800e9e0:	b25a      	sxtb	r2, r3
 800e9e2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e9e4:	3301      	adds	r3, #1
 800e9e6:	1839      	adds	r1, r7, r0
 800e9e8:	5ccb      	ldrb	r3, [r1, r3]
 800e9ea:	09db      	lsrs	r3, r3, #7
 800e9ec:	b2db      	uxtb	r3, r3
 800e9ee:	b25b      	sxtb	r3, r3
 800e9f0:	4313      	orrs	r3, r2
 800e9f2:	b25b      	sxtb	r3, r3
 800e9f4:	b2d9      	uxtb	r1, r3
 800e9f6:	183a      	adds	r2, r7, r0
 800e9f8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e9fa:	18d3      	adds	r3, r2, r3
 800e9fc:	1c0a      	adds	r2, r1, #0
 800e9fe:	701a      	strb	r2, [r3, #0]
 800ea00:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ea02:	3301      	adds	r3, #1
 800ea04:	647b      	str	r3, [r7, #68]	; 0x44
 800ea06:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ea08:	2b0e      	cmp	r3, #14
 800ea0a:	dde3      	ble.n	800e9d4 <AES_CMAC_Final+0x34>
 800ea0c:	211c      	movs	r1, #28
 800ea0e:	187b      	adds	r3, r7, r1
 800ea10:	7bdb      	ldrb	r3, [r3, #15]
 800ea12:	18db      	adds	r3, r3, r3
 800ea14:	b2da      	uxtb	r2, r3
 800ea16:	187b      	adds	r3, r7, r1
 800ea18:	73da      	strb	r2, [r3, #15]
                   K[15] ^= 0x87;
 800ea1a:	187b      	adds	r3, r7, r1
 800ea1c:	7bdb      	ldrb	r3, [r3, #15]
 800ea1e:	2279      	movs	r2, #121	; 0x79
 800ea20:	4252      	negs	r2, r2
 800ea22:	4053      	eors	r3, r2
 800ea24:	b2da      	uxtb	r2, r3
 800ea26:	187b      	adds	r3, r7, r1
 800ea28:	73da      	strb	r2, [r3, #15]
 800ea2a:	e025      	b.n	800ea78 <AES_CMAC_Final+0xd8>
            } else
                    LSHIFT(K, K);
 800ea2c:	2300      	movs	r3, #0
 800ea2e:	643b      	str	r3, [r7, #64]	; 0x40
 800ea30:	e018      	b.n	800ea64 <AES_CMAC_Final+0xc4>
 800ea32:	201c      	movs	r0, #28
 800ea34:	183a      	adds	r2, r7, r0
 800ea36:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ea38:	18d3      	adds	r3, r2, r3
 800ea3a:	781b      	ldrb	r3, [r3, #0]
 800ea3c:	005b      	lsls	r3, r3, #1
 800ea3e:	b25a      	sxtb	r2, r3
 800ea40:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ea42:	3301      	adds	r3, #1
 800ea44:	1839      	adds	r1, r7, r0
 800ea46:	5ccb      	ldrb	r3, [r1, r3]
 800ea48:	09db      	lsrs	r3, r3, #7
 800ea4a:	b2db      	uxtb	r3, r3
 800ea4c:	b25b      	sxtb	r3, r3
 800ea4e:	4313      	orrs	r3, r2
 800ea50:	b25b      	sxtb	r3, r3
 800ea52:	b2d9      	uxtb	r1, r3
 800ea54:	183a      	adds	r2, r7, r0
 800ea56:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ea58:	18d3      	adds	r3, r2, r3
 800ea5a:	1c0a      	adds	r2, r1, #0
 800ea5c:	701a      	strb	r2, [r3, #0]
 800ea5e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ea60:	3301      	adds	r3, #1
 800ea62:	643b      	str	r3, [r7, #64]	; 0x40
 800ea64:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ea66:	2b0e      	cmp	r3, #14
 800ea68:	dde3      	ble.n	800ea32 <AES_CMAC_Final+0x92>
 800ea6a:	211c      	movs	r1, #28
 800ea6c:	187b      	adds	r3, r7, r1
 800ea6e:	7bdb      	ldrb	r3, [r3, #15]
 800ea70:	18db      	adds	r3, r3, r3
 800ea72:	b2da      	uxtb	r2, r3
 800ea74:	187b      	adds	r3, r7, r1
 800ea76:	73da      	strb	r2, [r3, #15]


            if (ctx->M_n == 16) {
 800ea78:	683a      	ldr	r2, [r7, #0]
 800ea7a:	238a      	movs	r3, #138	; 0x8a
 800ea7c:	005b      	lsls	r3, r3, #1
 800ea7e:	58d3      	ldr	r3, [r2, r3]
 800ea80:	2b10      	cmp	r3, #16
 800ea82:	d11f      	bne.n	800eac4 <AES_CMAC_Final+0x124>
                    /* last block was a complete block */
                    XOR(K, ctx->M_last);
 800ea84:	2300      	movs	r3, #0
 800ea86:	63fb      	str	r3, [r7, #60]	; 0x3c
 800ea88:	e018      	b.n	800eabc <AES_CMAC_Final+0x11c>
 800ea8a:	6839      	ldr	r1, [r7, #0]
 800ea8c:	2302      	movs	r3, #2
 800ea8e:	33ff      	adds	r3, #255	; 0xff
 800ea90:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800ea92:	188a      	adds	r2, r1, r2
 800ea94:	18d3      	adds	r3, r2, r3
 800ea96:	781a      	ldrb	r2, [r3, #0]
 800ea98:	231c      	movs	r3, #28
 800ea9a:	18f9      	adds	r1, r7, r3
 800ea9c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ea9e:	18cb      	adds	r3, r1, r3
 800eaa0:	781b      	ldrb	r3, [r3, #0]
 800eaa2:	4053      	eors	r3, r2
 800eaa4:	b2d8      	uxtb	r0, r3
 800eaa6:	6839      	ldr	r1, [r7, #0]
 800eaa8:	2302      	movs	r3, #2
 800eaaa:	33ff      	adds	r3, #255	; 0xff
 800eaac:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800eaae:	188a      	adds	r2, r1, r2
 800eab0:	18d3      	adds	r3, r2, r3
 800eab2:	1c02      	adds	r2, r0, #0
 800eab4:	701a      	strb	r2, [r3, #0]
 800eab6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800eab8:	3301      	adds	r3, #1
 800eaba:	63fb      	str	r3, [r7, #60]	; 0x3c
 800eabc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800eabe:	2b0f      	cmp	r3, #15
 800eac0:	dde3      	ble.n	800ea8a <AES_CMAC_Final+0xea>
 800eac2:	e09f      	b.n	800ec04 <AES_CMAC_Final+0x264>

           } else {
                   /* generate subkey K2 */
                  if (K[0] & 0x80) {
 800eac4:	231c      	movs	r3, #28
 800eac6:	18fb      	adds	r3, r7, r3
 800eac8:	781b      	ldrb	r3, [r3, #0]
 800eaca:	b25b      	sxtb	r3, r3
 800eacc:	2b00      	cmp	r3, #0
 800eace:	da2e      	bge.n	800eb2e <AES_CMAC_Final+0x18e>
                          LSHIFT(K, K);
 800ead0:	2300      	movs	r3, #0
 800ead2:	63bb      	str	r3, [r7, #56]	; 0x38
 800ead4:	e018      	b.n	800eb08 <AES_CMAC_Final+0x168>
 800ead6:	201c      	movs	r0, #28
 800ead8:	183a      	adds	r2, r7, r0
 800eada:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eadc:	18d3      	adds	r3, r2, r3
 800eade:	781b      	ldrb	r3, [r3, #0]
 800eae0:	005b      	lsls	r3, r3, #1
 800eae2:	b25a      	sxtb	r2, r3
 800eae4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eae6:	3301      	adds	r3, #1
 800eae8:	1839      	adds	r1, r7, r0
 800eaea:	5ccb      	ldrb	r3, [r1, r3]
 800eaec:	09db      	lsrs	r3, r3, #7
 800eaee:	b2db      	uxtb	r3, r3
 800eaf0:	b25b      	sxtb	r3, r3
 800eaf2:	4313      	orrs	r3, r2
 800eaf4:	b25b      	sxtb	r3, r3
 800eaf6:	b2d9      	uxtb	r1, r3
 800eaf8:	183a      	adds	r2, r7, r0
 800eafa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eafc:	18d3      	adds	r3, r2, r3
 800eafe:	1c0a      	adds	r2, r1, #0
 800eb00:	701a      	strb	r2, [r3, #0]
 800eb02:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eb04:	3301      	adds	r3, #1
 800eb06:	63bb      	str	r3, [r7, #56]	; 0x38
 800eb08:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eb0a:	2b0e      	cmp	r3, #14
 800eb0c:	dde3      	ble.n	800ead6 <AES_CMAC_Final+0x136>
 800eb0e:	211c      	movs	r1, #28
 800eb10:	187b      	adds	r3, r7, r1
 800eb12:	7bdb      	ldrb	r3, [r3, #15]
 800eb14:	18db      	adds	r3, r3, r3
 800eb16:	b2da      	uxtb	r2, r3
 800eb18:	187b      	adds	r3, r7, r1
 800eb1a:	73da      	strb	r2, [r3, #15]
                          K[15] ^= 0x87;
 800eb1c:	187b      	adds	r3, r7, r1
 800eb1e:	7bdb      	ldrb	r3, [r3, #15]
 800eb20:	2279      	movs	r2, #121	; 0x79
 800eb22:	4252      	negs	r2, r2
 800eb24:	4053      	eors	r3, r2
 800eb26:	b2da      	uxtb	r2, r3
 800eb28:	187b      	adds	r3, r7, r1
 800eb2a:	73da      	strb	r2, [r3, #15]
 800eb2c:	e025      	b.n	800eb7a <AES_CMAC_Final+0x1da>
                  } else
                           LSHIFT(K, K);
 800eb2e:	2300      	movs	r3, #0
 800eb30:	637b      	str	r3, [r7, #52]	; 0x34
 800eb32:	e018      	b.n	800eb66 <AES_CMAC_Final+0x1c6>
 800eb34:	201c      	movs	r0, #28
 800eb36:	183a      	adds	r2, r7, r0
 800eb38:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eb3a:	18d3      	adds	r3, r2, r3
 800eb3c:	781b      	ldrb	r3, [r3, #0]
 800eb3e:	005b      	lsls	r3, r3, #1
 800eb40:	b25a      	sxtb	r2, r3
 800eb42:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eb44:	3301      	adds	r3, #1
 800eb46:	1839      	adds	r1, r7, r0
 800eb48:	5ccb      	ldrb	r3, [r1, r3]
 800eb4a:	09db      	lsrs	r3, r3, #7
 800eb4c:	b2db      	uxtb	r3, r3
 800eb4e:	b25b      	sxtb	r3, r3
 800eb50:	4313      	orrs	r3, r2
 800eb52:	b25b      	sxtb	r3, r3
 800eb54:	b2d9      	uxtb	r1, r3
 800eb56:	183a      	adds	r2, r7, r0
 800eb58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eb5a:	18d3      	adds	r3, r2, r3
 800eb5c:	1c0a      	adds	r2, r1, #0
 800eb5e:	701a      	strb	r2, [r3, #0]
 800eb60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eb62:	3301      	adds	r3, #1
 800eb64:	637b      	str	r3, [r7, #52]	; 0x34
 800eb66:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eb68:	2b0e      	cmp	r3, #14
 800eb6a:	dde3      	ble.n	800eb34 <AES_CMAC_Final+0x194>
 800eb6c:	211c      	movs	r1, #28
 800eb6e:	187b      	adds	r3, r7, r1
 800eb70:	7bdb      	ldrb	r3, [r3, #15]
 800eb72:	18db      	adds	r3, r3, r3
 800eb74:	b2da      	uxtb	r2, r3
 800eb76:	187b      	adds	r3, r7, r1
 800eb78:	73da      	strb	r2, [r3, #15]

                   /* padding(M_last) */
                   ctx->M_last[ctx->M_n] = 0x80;
 800eb7a:	683a      	ldr	r2, [r7, #0]
 800eb7c:	238a      	movs	r3, #138	; 0x8a
 800eb7e:	005b      	lsls	r3, r3, #1
 800eb80:	58d2      	ldr	r2, [r2, r3]
 800eb82:	6839      	ldr	r1, [r7, #0]
 800eb84:	2302      	movs	r3, #2
 800eb86:	33ff      	adds	r3, #255	; 0xff
 800eb88:	188a      	adds	r2, r1, r2
 800eb8a:	18d3      	adds	r3, r2, r3
 800eb8c:	2280      	movs	r2, #128	; 0x80
 800eb8e:	701a      	strb	r2, [r3, #0]
                   while (++ctx->M_n < 16)
 800eb90:	e00a      	b.n	800eba8 <AES_CMAC_Final+0x208>
                         ctx->M_last[ctx->M_n] = 0;
 800eb92:	683a      	ldr	r2, [r7, #0]
 800eb94:	238a      	movs	r3, #138	; 0x8a
 800eb96:	005b      	lsls	r3, r3, #1
 800eb98:	58d2      	ldr	r2, [r2, r3]
 800eb9a:	6839      	ldr	r1, [r7, #0]
 800eb9c:	2302      	movs	r3, #2
 800eb9e:	33ff      	adds	r3, #255	; 0xff
 800eba0:	188a      	adds	r2, r1, r2
 800eba2:	18d3      	adds	r3, r2, r3
 800eba4:	2200      	movs	r2, #0
 800eba6:	701a      	strb	r2, [r3, #0]
                   while (++ctx->M_n < 16)
 800eba8:	683a      	ldr	r2, [r7, #0]
 800ebaa:	238a      	movs	r3, #138	; 0x8a
 800ebac:	005b      	lsls	r3, r3, #1
 800ebae:	58d3      	ldr	r3, [r2, r3]
 800ebb0:	1c59      	adds	r1, r3, #1
 800ebb2:	683a      	ldr	r2, [r7, #0]
 800ebb4:	238a      	movs	r3, #138	; 0x8a
 800ebb6:	005b      	lsls	r3, r3, #1
 800ebb8:	50d1      	str	r1, [r2, r3]
 800ebba:	683a      	ldr	r2, [r7, #0]
 800ebbc:	238a      	movs	r3, #138	; 0x8a
 800ebbe:	005b      	lsls	r3, r3, #1
 800ebc0:	58d3      	ldr	r3, [r2, r3]
 800ebc2:	2b0f      	cmp	r3, #15
 800ebc4:	d9e5      	bls.n	800eb92 <AES_CMAC_Final+0x1f2>
   
                  XOR(K, ctx->M_last);
 800ebc6:	2300      	movs	r3, #0
 800ebc8:	633b      	str	r3, [r7, #48]	; 0x30
 800ebca:	e018      	b.n	800ebfe <AES_CMAC_Final+0x25e>
 800ebcc:	6839      	ldr	r1, [r7, #0]
 800ebce:	2302      	movs	r3, #2
 800ebd0:	33ff      	adds	r3, #255	; 0xff
 800ebd2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800ebd4:	188a      	adds	r2, r1, r2
 800ebd6:	18d3      	adds	r3, r2, r3
 800ebd8:	781a      	ldrb	r2, [r3, #0]
 800ebda:	231c      	movs	r3, #28
 800ebdc:	18f9      	adds	r1, r7, r3
 800ebde:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ebe0:	18cb      	adds	r3, r1, r3
 800ebe2:	781b      	ldrb	r3, [r3, #0]
 800ebe4:	4053      	eors	r3, r2
 800ebe6:	b2d8      	uxtb	r0, r3
 800ebe8:	6839      	ldr	r1, [r7, #0]
 800ebea:	2302      	movs	r3, #2
 800ebec:	33ff      	adds	r3, #255	; 0xff
 800ebee:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800ebf0:	188a      	adds	r2, r1, r2
 800ebf2:	18d3      	adds	r3, r2, r3
 800ebf4:	1c02      	adds	r2, r0, #0
 800ebf6:	701a      	strb	r2, [r3, #0]
 800ebf8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ebfa:	3301      	adds	r3, #1
 800ebfc:	633b      	str	r3, [r7, #48]	; 0x30
 800ebfe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ec00:	2b0f      	cmp	r3, #15
 800ec02:	dde3      	ble.n	800ebcc <AES_CMAC_Final+0x22c>


           }
           XOR(ctx->M_last, ctx->X);
 800ec04:	2300      	movs	r3, #0
 800ec06:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ec08:	e018      	b.n	800ec3c <AES_CMAC_Final+0x29c>
 800ec0a:	683a      	ldr	r2, [r7, #0]
 800ec0c:	21f1      	movs	r1, #241	; 0xf1
 800ec0e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ec10:	18d3      	adds	r3, r2, r3
 800ec12:	185b      	adds	r3, r3, r1
 800ec14:	781a      	ldrb	r2, [r3, #0]
 800ec16:	6838      	ldr	r0, [r7, #0]
 800ec18:	2302      	movs	r3, #2
 800ec1a:	33ff      	adds	r3, #255	; 0xff
 800ec1c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800ec1e:	1841      	adds	r1, r0, r1
 800ec20:	18cb      	adds	r3, r1, r3
 800ec22:	781b      	ldrb	r3, [r3, #0]
 800ec24:	4053      	eors	r3, r2
 800ec26:	b2d8      	uxtb	r0, r3
 800ec28:	683a      	ldr	r2, [r7, #0]
 800ec2a:	21f1      	movs	r1, #241	; 0xf1
 800ec2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ec2e:	18d3      	adds	r3, r2, r3
 800ec30:	185b      	adds	r3, r3, r1
 800ec32:	1c02      	adds	r2, r0, #0
 800ec34:	701a      	strb	r2, [r3, #0]
 800ec36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ec38:	3301      	adds	r3, #1
 800ec3a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ec3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ec3e:	2b0f      	cmp	r3, #15
 800ec40:	dde3      	ble.n	800ec0a <AES_CMAC_Final+0x26a>

           //rijndael_encrypt(&ctx->rijndael, ctx->X, digest);

       memcpy1(in, &ctx->X[0], 16); //Bestela ez du ondo iten
 800ec42:	683b      	ldr	r3, [r7, #0]
 800ec44:	33f1      	adds	r3, #241	; 0xf1
 800ec46:	0019      	movs	r1, r3
 800ec48:	240c      	movs	r4, #12
 800ec4a:	193b      	adds	r3, r7, r4
 800ec4c:	2210      	movs	r2, #16
 800ec4e:	0018      	movs	r0, r3
 800ec50:	f00c fc7a 	bl	801b548 <memcpy1>
       aes_encrypt(in, digest, &ctx->rijndael);
 800ec54:	683a      	ldr	r2, [r7, #0]
 800ec56:	6879      	ldr	r1, [r7, #4]
 800ec58:	193b      	adds	r3, r7, r4
 800ec5a:	0018      	movs	r0, r3
 800ec5c:	f7ff fd72 	bl	800e744 <aes_encrypt>
           memset1(K, 0, sizeof K);
 800ec60:	231c      	movs	r3, #28
 800ec62:	18fb      	adds	r3, r7, r3
 800ec64:	2210      	movs	r2, #16
 800ec66:	2100      	movs	r1, #0
 800ec68:	0018      	movs	r0, r3
 800ec6a:	f00c fcab 	bl	801b5c4 <memset1>

}
 800ec6e:	46c0      	nop			; (mov r8, r8)
 800ec70:	46bd      	mov	sp, r7
 800ec72:	b013      	add	sp, #76	; 0x4c
 800ec74:	bd90      	pop	{r4, r7, pc}
	...

0800ec78 <GetKeyByID>:
 * \param[IN]  keyID          - Key identifier
 * \param[OUT] keyItem        - Key item reference
 * \retval                    - Status of the operation
 */
SecureElementStatus_t GetKeyByID( KeyIdentifier_t keyID, Key_t** keyItem )
{
 800ec78:	b590      	push	{r4, r7, lr}
 800ec7a:	b085      	sub	sp, #20
 800ec7c:	af00      	add	r7, sp, #0
 800ec7e:	0002      	movs	r2, r0
 800ec80:	6039      	str	r1, [r7, #0]
 800ec82:	1dfb      	adds	r3, r7, #7
 800ec84:	701a      	strb	r2, [r3, #0]
    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 800ec86:	230f      	movs	r3, #15
 800ec88:	18fb      	adds	r3, r7, r3
 800ec8a:	2200      	movs	r2, #0
 800ec8c:	701a      	strb	r2, [r3, #0]
 800ec8e:	e024      	b.n	800ecda <GetKeyByID+0x62>
    {
        if( SeNvmCtx.KeyList[i].KeyID == keyID )
 800ec90:	240f      	movs	r4, #15
 800ec92:	193b      	adds	r3, r7, r4
 800ec94:	781a      	ldrb	r2, [r3, #0]
 800ec96:	4816      	ldr	r0, [pc, #88]	; (800ecf0 <GetKeyByID+0x78>)
 800ec98:	238b      	movs	r3, #139	; 0x8b
 800ec9a:	0099      	lsls	r1, r3, #2
 800ec9c:	0013      	movs	r3, r2
 800ec9e:	011b      	lsls	r3, r3, #4
 800eca0:	189b      	adds	r3, r3, r2
 800eca2:	18c3      	adds	r3, r0, r3
 800eca4:	185b      	adds	r3, r3, r1
 800eca6:	781b      	ldrb	r3, [r3, #0]
 800eca8:	1dfa      	adds	r2, r7, #7
 800ecaa:	7812      	ldrb	r2, [r2, #0]
 800ecac:	429a      	cmp	r2, r3
 800ecae:	d10e      	bne.n	800ecce <GetKeyByID+0x56>
        {
            *keyItem = &( SeNvmCtx.KeyList[i] );
 800ecb0:	193b      	adds	r3, r7, r4
 800ecb2:	781a      	ldrb	r2, [r3, #0]
 800ecb4:	0013      	movs	r3, r2
 800ecb6:	011b      	lsls	r3, r3, #4
 800ecb8:	189b      	adds	r3, r3, r2
 800ecba:	228a      	movs	r2, #138	; 0x8a
 800ecbc:	0092      	lsls	r2, r2, #2
 800ecbe:	189a      	adds	r2, r3, r2
 800ecc0:	4b0b      	ldr	r3, [pc, #44]	; (800ecf0 <GetKeyByID+0x78>)
 800ecc2:	18d3      	adds	r3, r2, r3
 800ecc4:	1d1a      	adds	r2, r3, #4
 800ecc6:	683b      	ldr	r3, [r7, #0]
 800ecc8:	601a      	str	r2, [r3, #0]
            return SECURE_ELEMENT_SUCCESS;
 800ecca:	2300      	movs	r3, #0
 800eccc:	e00b      	b.n	800ece6 <GetKeyByID+0x6e>
    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 800ecce:	210f      	movs	r1, #15
 800ecd0:	187b      	adds	r3, r7, r1
 800ecd2:	781a      	ldrb	r2, [r3, #0]
 800ecd4:	187b      	adds	r3, r7, r1
 800ecd6:	3201      	adds	r2, #1
 800ecd8:	701a      	strb	r2, [r3, #0]
 800ecda:	230f      	movs	r3, #15
 800ecdc:	18fb      	adds	r3, r7, r3
 800ecde:	781b      	ldrb	r3, [r3, #0]
 800ece0:	2b17      	cmp	r3, #23
 800ece2:	d9d5      	bls.n	800ec90 <GetKeyByID+0x18>
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800ece4:	2303      	movs	r3, #3
}
 800ece6:	0018      	movs	r0, r3
 800ece8:	46bd      	mov	sp, r7
 800ecea:	b005      	add	sp, #20
 800ecec:	bd90      	pop	{r4, r7, pc}
 800ecee:	46c0      	nop			; (mov r8, r8)
 800ecf0:	20000524 	.word	0x20000524

0800ecf4 <DummyCB>:

/*
 * Dummy callback in case if the user provides NULL function pointer
 */
static void DummyCB( void )
{
 800ecf4:	b580      	push	{r7, lr}
 800ecf6:	af00      	add	r7, sp, #0
    return;
 800ecf8:	46c0      	nop			; (mov r8, r8)
}
 800ecfa:	46bd      	mov	sp, r7
 800ecfc:	bd80      	pop	{r7, pc}
	...

0800ed00 <ComputeCmac>:
 * \param[IN]  keyID          - Key identifier to determine the AES key to be used
 * \param[OUT] cmac           - Computed cmac
 * \retval                    - Status of the operation
 */
static SecureElementStatus_t ComputeCmac( uint8_t *micBxBuffer, uint8_t *buffer, uint16_t size, KeyIdentifier_t keyID, uint32_t* cmac )
{
 800ed00:	b5b0      	push	{r4, r5, r7, lr}
 800ed02:	b08a      	sub	sp, #40	; 0x28
 800ed04:	af00      	add	r7, sp, #0
 800ed06:	60f8      	str	r0, [r7, #12]
 800ed08:	60b9      	str	r1, [r7, #8]
 800ed0a:	0019      	movs	r1, r3
 800ed0c:	1dbb      	adds	r3, r7, #6
 800ed0e:	801a      	strh	r2, [r3, #0]
 800ed10:	1d7b      	adds	r3, r7, #5
 800ed12:	1c0a      	adds	r2, r1, #0
 800ed14:	701a      	strb	r2, [r3, #0]
    if( ( buffer == NULL ) || ( cmac == NULL ) )
 800ed16:	68bb      	ldr	r3, [r7, #8]
 800ed18:	2b00      	cmp	r3, #0
 800ed1a:	d002      	beq.n	800ed22 <ComputeCmac+0x22>
 800ed1c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ed1e:	2b00      	cmp	r3, #0
 800ed20:	d101      	bne.n	800ed26 <ComputeCmac+0x26>
    {
        return SECURE_ELEMENT_ERROR_NPE;
 800ed22:	2302      	movs	r3, #2
 800ed24:	e045      	b.n	800edb2 <ComputeCmac+0xb2>
    }

    uint8_t Cmac[16];

    AES_CMAC_Init( SeNvmCtx.AesCmacCtx );
 800ed26:	4b25      	ldr	r3, [pc, #148]	; (800edbc <ComputeCmac+0xbc>)
 800ed28:	0018      	movs	r0, r3
 800ed2a:	f7ff fd55 	bl	800e7d8 <AES_CMAC_Init>

    Key_t* keyItem;
    SecureElementStatus_t retval = GetKeyByID( keyID, &keyItem );
 800ed2e:	2527      	movs	r5, #39	; 0x27
 800ed30:	197c      	adds	r4, r7, r5
 800ed32:	2310      	movs	r3, #16
 800ed34:	18fa      	adds	r2, r7, r3
 800ed36:	1d7b      	adds	r3, r7, #5
 800ed38:	781b      	ldrb	r3, [r3, #0]
 800ed3a:	0011      	movs	r1, r2
 800ed3c:	0018      	movs	r0, r3
 800ed3e:	f7ff ff9b 	bl	800ec78 <GetKeyByID>
 800ed42:	0003      	movs	r3, r0
 800ed44:	7023      	strb	r3, [r4, #0]

    if( retval == SECURE_ELEMENT_SUCCESS )
 800ed46:	197b      	adds	r3, r7, r5
 800ed48:	781b      	ldrb	r3, [r3, #0]
 800ed4a:	2b00      	cmp	r3, #0
 800ed4c:	d12e      	bne.n	800edac <ComputeCmac+0xac>
    {
        AES_CMAC_SetKey( SeNvmCtx.AesCmacCtx, keyItem->KeyValue );
 800ed4e:	693b      	ldr	r3, [r7, #16]
 800ed50:	1c5a      	adds	r2, r3, #1
 800ed52:	4b1a      	ldr	r3, [pc, #104]	; (800edbc <ComputeCmac+0xbc>)
 800ed54:	0011      	movs	r1, r2
 800ed56:	0018      	movs	r0, r3
 800ed58:	f7ff fd58 	bl	800e80c <AES_CMAC_SetKey>

        if( micBxBuffer != NULL )
 800ed5c:	68fb      	ldr	r3, [r7, #12]
 800ed5e:	2b00      	cmp	r3, #0
 800ed60:	d005      	beq.n	800ed6e <ComputeCmac+0x6e>
        {
            AES_CMAC_Update( SeNvmCtx.AesCmacCtx, micBxBuffer, 16 );
 800ed62:	68f9      	ldr	r1, [r7, #12]
 800ed64:	4b15      	ldr	r3, [pc, #84]	; (800edbc <ComputeCmac+0xbc>)
 800ed66:	2210      	movs	r2, #16
 800ed68:	0018      	movs	r0, r3
 800ed6a:	f7ff fd5e 	bl	800e82a <AES_CMAC_Update>
        }

        AES_CMAC_Update( SeNvmCtx.AesCmacCtx, buffer, size );
 800ed6e:	1dbb      	adds	r3, r7, #6
 800ed70:	881a      	ldrh	r2, [r3, #0]
 800ed72:	68b9      	ldr	r1, [r7, #8]
 800ed74:	4b11      	ldr	r3, [pc, #68]	; (800edbc <ComputeCmac+0xbc>)
 800ed76:	0018      	movs	r0, r3
 800ed78:	f7ff fd57 	bl	800e82a <AES_CMAC_Update>

        AES_CMAC_Final( Cmac, SeNvmCtx.AesCmacCtx );
 800ed7c:	4a0f      	ldr	r2, [pc, #60]	; (800edbc <ComputeCmac+0xbc>)
 800ed7e:	2414      	movs	r4, #20
 800ed80:	193b      	adds	r3, r7, r4
 800ed82:	0011      	movs	r1, r2
 800ed84:	0018      	movs	r0, r3
 800ed86:	f7ff fe0b 	bl	800e9a0 <AES_CMAC_Final>

        // Bring into the required format
        *cmac = ( uint32_t )( ( uint32_t ) Cmac[3] << 24 | ( uint32_t ) Cmac[2] << 16 | ( uint32_t ) Cmac[1] << 8 | ( uint32_t ) Cmac[0] );
 800ed8a:	0021      	movs	r1, r4
 800ed8c:	187b      	adds	r3, r7, r1
 800ed8e:	78db      	ldrb	r3, [r3, #3]
 800ed90:	061a      	lsls	r2, r3, #24
 800ed92:	187b      	adds	r3, r7, r1
 800ed94:	789b      	ldrb	r3, [r3, #2]
 800ed96:	041b      	lsls	r3, r3, #16
 800ed98:	431a      	orrs	r2, r3
 800ed9a:	187b      	adds	r3, r7, r1
 800ed9c:	785b      	ldrb	r3, [r3, #1]
 800ed9e:	021b      	lsls	r3, r3, #8
 800eda0:	4313      	orrs	r3, r2
 800eda2:	187a      	adds	r2, r7, r1
 800eda4:	7812      	ldrb	r2, [r2, #0]
 800eda6:	431a      	orrs	r2, r3
 800eda8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800edaa:	601a      	str	r2, [r3, #0]
    }

    return retval;
 800edac:	2327      	movs	r3, #39	; 0x27
 800edae:	18fb      	adds	r3, r7, r3
 800edb0:	781b      	ldrb	r3, [r3, #0]
}
 800edb2:	0018      	movs	r0, r3
 800edb4:	46bd      	mov	sp, r7
 800edb6:	b00a      	add	sp, #40	; 0x28
 800edb8:	bdb0      	pop	{r4, r5, r7, pc}
 800edba:	46c0      	nop			; (mov r8, r8)
 800edbc:	20000638 	.word	0x20000638

0800edc0 <SecureElementInit>:
/*
 * API functions
 */

SecureElementStatus_t SecureElementInit( SecureElementNvmEvent seNvmCtxChanged )
{
 800edc0:	b5b0      	push	{r4, r5, r7, lr}
 800edc2:	b088      	sub	sp, #32
 800edc4:	af00      	add	r7, sp, #0
 800edc6:	6078      	str	r0, [r7, #4]
    uint8_t itr = 0;
 800edc8:	241f      	movs	r4, #31
 800edca:	193b      	adds	r3, r7, r4
 800edcc:	2200      	movs	r2, #0
 800edce:	701a      	strb	r2, [r3, #0]
    uint8_t zeroKey[16] = { 0 };
 800edd0:	250c      	movs	r5, #12
 800edd2:	197b      	adds	r3, r7, r5
 800edd4:	2200      	movs	r2, #0
 800edd6:	601a      	str	r2, [r3, #0]
 800edd8:	3304      	adds	r3, #4
 800edda:	220c      	movs	r2, #12
 800eddc:	2100      	movs	r1, #0
 800edde:	0018      	movs	r0, r3
 800ede0:	f00e fbb8 	bl	801d554 <memset>

    // Initialize with defaults
    SeNvmCtx.KeyList[itr++].KeyID = APP_KEY;
 800ede4:	193b      	adds	r3, r7, r4
 800ede6:	781b      	ldrb	r3, [r3, #0]
 800ede8:	193a      	adds	r2, r7, r4
 800edea:	1c59      	adds	r1, r3, #1
 800edec:	7011      	strb	r1, [r2, #0]
 800edee:	0018      	movs	r0, r3
 800edf0:	49d0      	ldr	r1, [pc, #832]	; (800f134 <SecureElementInit+0x374>)
 800edf2:	238b      	movs	r3, #139	; 0x8b
 800edf4:	009a      	lsls	r2, r3, #2
 800edf6:	0003      	movs	r3, r0
 800edf8:	011b      	lsls	r3, r3, #4
 800edfa:	181b      	adds	r3, r3, r0
 800edfc:	18cb      	adds	r3, r1, r3
 800edfe:	189b      	adds	r3, r3, r2
 800ee00:	2200      	movs	r2, #0
 800ee02:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = GEN_APP_KEY;
 800ee04:	193b      	adds	r3, r7, r4
 800ee06:	781b      	ldrb	r3, [r3, #0]
 800ee08:	193a      	adds	r2, r7, r4
 800ee0a:	1c59      	adds	r1, r3, #1
 800ee0c:	7011      	strb	r1, [r2, #0]
 800ee0e:	0018      	movs	r0, r3
 800ee10:	49c8      	ldr	r1, [pc, #800]	; (800f134 <SecureElementInit+0x374>)
 800ee12:	238b      	movs	r3, #139	; 0x8b
 800ee14:	009a      	lsls	r2, r3, #2
 800ee16:	0003      	movs	r3, r0
 800ee18:	011b      	lsls	r3, r3, #4
 800ee1a:	181b      	adds	r3, r3, r0
 800ee1c:	18cb      	adds	r3, r1, r3
 800ee1e:	189b      	adds	r3, r3, r2
 800ee20:	2201      	movs	r2, #1
 800ee22:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = NWK_KEY;
 800ee24:	193b      	adds	r3, r7, r4
 800ee26:	781b      	ldrb	r3, [r3, #0]
 800ee28:	193a      	adds	r2, r7, r4
 800ee2a:	1c59      	adds	r1, r3, #1
 800ee2c:	7011      	strb	r1, [r2, #0]
 800ee2e:	0018      	movs	r0, r3
 800ee30:	49c0      	ldr	r1, [pc, #768]	; (800f134 <SecureElementInit+0x374>)
 800ee32:	238b      	movs	r3, #139	; 0x8b
 800ee34:	009a      	lsls	r2, r3, #2
 800ee36:	0003      	movs	r3, r0
 800ee38:	011b      	lsls	r3, r3, #4
 800ee3a:	181b      	adds	r3, r3, r0
 800ee3c:	18cb      	adds	r3, r1, r3
 800ee3e:	189b      	adds	r3, r3, r2
 800ee40:	2202      	movs	r2, #2
 800ee42:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = J_S_INT_KEY;
 800ee44:	193b      	adds	r3, r7, r4
 800ee46:	781b      	ldrb	r3, [r3, #0]
 800ee48:	193a      	adds	r2, r7, r4
 800ee4a:	1c59      	adds	r1, r3, #1
 800ee4c:	7011      	strb	r1, [r2, #0]
 800ee4e:	0018      	movs	r0, r3
 800ee50:	49b8      	ldr	r1, [pc, #736]	; (800f134 <SecureElementInit+0x374>)
 800ee52:	238b      	movs	r3, #139	; 0x8b
 800ee54:	009a      	lsls	r2, r3, #2
 800ee56:	0003      	movs	r3, r0
 800ee58:	011b      	lsls	r3, r3, #4
 800ee5a:	181b      	adds	r3, r3, r0
 800ee5c:	18cb      	adds	r3, r1, r3
 800ee5e:	189b      	adds	r3, r3, r2
 800ee60:	2203      	movs	r2, #3
 800ee62:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = J_S_ENC_KEY;
 800ee64:	193b      	adds	r3, r7, r4
 800ee66:	781b      	ldrb	r3, [r3, #0]
 800ee68:	193a      	adds	r2, r7, r4
 800ee6a:	1c59      	adds	r1, r3, #1
 800ee6c:	7011      	strb	r1, [r2, #0]
 800ee6e:	0018      	movs	r0, r3
 800ee70:	49b0      	ldr	r1, [pc, #704]	; (800f134 <SecureElementInit+0x374>)
 800ee72:	238b      	movs	r3, #139	; 0x8b
 800ee74:	009a      	lsls	r2, r3, #2
 800ee76:	0003      	movs	r3, r0
 800ee78:	011b      	lsls	r3, r3, #4
 800ee7a:	181b      	adds	r3, r3, r0
 800ee7c:	18cb      	adds	r3, r1, r3
 800ee7e:	189b      	adds	r3, r3, r2
 800ee80:	2204      	movs	r2, #4
 800ee82:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = F_NWK_S_INT_KEY;
 800ee84:	193b      	adds	r3, r7, r4
 800ee86:	781b      	ldrb	r3, [r3, #0]
 800ee88:	193a      	adds	r2, r7, r4
 800ee8a:	1c59      	adds	r1, r3, #1
 800ee8c:	7011      	strb	r1, [r2, #0]
 800ee8e:	0018      	movs	r0, r3
 800ee90:	49a8      	ldr	r1, [pc, #672]	; (800f134 <SecureElementInit+0x374>)
 800ee92:	238b      	movs	r3, #139	; 0x8b
 800ee94:	009a      	lsls	r2, r3, #2
 800ee96:	0003      	movs	r3, r0
 800ee98:	011b      	lsls	r3, r3, #4
 800ee9a:	181b      	adds	r3, r3, r0
 800ee9c:	18cb      	adds	r3, r1, r3
 800ee9e:	189b      	adds	r3, r3, r2
 800eea0:	2205      	movs	r2, #5
 800eea2:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = S_NWK_S_INT_KEY;
 800eea4:	193b      	adds	r3, r7, r4
 800eea6:	781b      	ldrb	r3, [r3, #0]
 800eea8:	193a      	adds	r2, r7, r4
 800eeaa:	1c59      	adds	r1, r3, #1
 800eeac:	7011      	strb	r1, [r2, #0]
 800eeae:	0018      	movs	r0, r3
 800eeb0:	49a0      	ldr	r1, [pc, #640]	; (800f134 <SecureElementInit+0x374>)
 800eeb2:	238b      	movs	r3, #139	; 0x8b
 800eeb4:	009a      	lsls	r2, r3, #2
 800eeb6:	0003      	movs	r3, r0
 800eeb8:	011b      	lsls	r3, r3, #4
 800eeba:	181b      	adds	r3, r3, r0
 800eebc:	18cb      	adds	r3, r1, r3
 800eebe:	189b      	adds	r3, r3, r2
 800eec0:	2206      	movs	r2, #6
 800eec2:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = NWK_S_ENC_KEY;
 800eec4:	193b      	adds	r3, r7, r4
 800eec6:	781b      	ldrb	r3, [r3, #0]
 800eec8:	193a      	adds	r2, r7, r4
 800eeca:	1c59      	adds	r1, r3, #1
 800eecc:	7011      	strb	r1, [r2, #0]
 800eece:	0018      	movs	r0, r3
 800eed0:	4998      	ldr	r1, [pc, #608]	; (800f134 <SecureElementInit+0x374>)
 800eed2:	238b      	movs	r3, #139	; 0x8b
 800eed4:	009a      	lsls	r2, r3, #2
 800eed6:	0003      	movs	r3, r0
 800eed8:	011b      	lsls	r3, r3, #4
 800eeda:	181b      	adds	r3, r3, r0
 800eedc:	18cb      	adds	r3, r1, r3
 800eede:	189b      	adds	r3, r3, r2
 800eee0:	2207      	movs	r2, #7
 800eee2:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = APP_S_KEY;
 800eee4:	193b      	adds	r3, r7, r4
 800eee6:	781b      	ldrb	r3, [r3, #0]
 800eee8:	193a      	adds	r2, r7, r4
 800eeea:	1c59      	adds	r1, r3, #1
 800eeec:	7011      	strb	r1, [r2, #0]
 800eeee:	0018      	movs	r0, r3
 800eef0:	4990      	ldr	r1, [pc, #576]	; (800f134 <SecureElementInit+0x374>)
 800eef2:	238b      	movs	r3, #139	; 0x8b
 800eef4:	009a      	lsls	r2, r3, #2
 800eef6:	0003      	movs	r3, r0
 800eef8:	011b      	lsls	r3, r3, #4
 800eefa:	181b      	adds	r3, r3, r0
 800eefc:	18cb      	adds	r3, r1, r3
 800eefe:	189b      	adds	r3, r3, r2
 800ef00:	2208      	movs	r2, #8
 800ef02:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_ROOT_KEY;
 800ef04:	193b      	adds	r3, r7, r4
 800ef06:	781b      	ldrb	r3, [r3, #0]
 800ef08:	193a      	adds	r2, r7, r4
 800ef0a:	1c59      	adds	r1, r3, #1
 800ef0c:	7011      	strb	r1, [r2, #0]
 800ef0e:	0018      	movs	r0, r3
 800ef10:	4988      	ldr	r1, [pc, #544]	; (800f134 <SecureElementInit+0x374>)
 800ef12:	238b      	movs	r3, #139	; 0x8b
 800ef14:	009a      	lsls	r2, r3, #2
 800ef16:	0003      	movs	r3, r0
 800ef18:	011b      	lsls	r3, r3, #4
 800ef1a:	181b      	adds	r3, r3, r0
 800ef1c:	18cb      	adds	r3, r1, r3
 800ef1e:	189b      	adds	r3, r3, r2
 800ef20:	2209      	movs	r2, #9
 800ef22:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_KE_KEY;
 800ef24:	193b      	adds	r3, r7, r4
 800ef26:	781b      	ldrb	r3, [r3, #0]
 800ef28:	193a      	adds	r2, r7, r4
 800ef2a:	1c59      	adds	r1, r3, #1
 800ef2c:	7011      	strb	r1, [r2, #0]
 800ef2e:	0018      	movs	r0, r3
 800ef30:	4980      	ldr	r1, [pc, #512]	; (800f134 <SecureElementInit+0x374>)
 800ef32:	238b      	movs	r3, #139	; 0x8b
 800ef34:	009a      	lsls	r2, r3, #2
 800ef36:	0003      	movs	r3, r0
 800ef38:	011b      	lsls	r3, r3, #4
 800ef3a:	181b      	adds	r3, r3, r0
 800ef3c:	18cb      	adds	r3, r1, r3
 800ef3e:	189b      	adds	r3, r3, r2
 800ef40:	227f      	movs	r2, #127	; 0x7f
 800ef42:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_KEY_0;
 800ef44:	193b      	adds	r3, r7, r4
 800ef46:	781b      	ldrb	r3, [r3, #0]
 800ef48:	193a      	adds	r2, r7, r4
 800ef4a:	1c59      	adds	r1, r3, #1
 800ef4c:	7011      	strb	r1, [r2, #0]
 800ef4e:	0018      	movs	r0, r3
 800ef50:	4978      	ldr	r1, [pc, #480]	; (800f134 <SecureElementInit+0x374>)
 800ef52:	238b      	movs	r3, #139	; 0x8b
 800ef54:	009a      	lsls	r2, r3, #2
 800ef56:	0003      	movs	r3, r0
 800ef58:	011b      	lsls	r3, r3, #4
 800ef5a:	181b      	adds	r3, r3, r0
 800ef5c:	18cb      	adds	r3, r1, r3
 800ef5e:	189b      	adds	r3, r3, r2
 800ef60:	2280      	movs	r2, #128	; 0x80
 800ef62:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_APP_S_KEY_0;
 800ef64:	193b      	adds	r3, r7, r4
 800ef66:	781b      	ldrb	r3, [r3, #0]
 800ef68:	193a      	adds	r2, r7, r4
 800ef6a:	1c59      	adds	r1, r3, #1
 800ef6c:	7011      	strb	r1, [r2, #0]
 800ef6e:	0018      	movs	r0, r3
 800ef70:	4970      	ldr	r1, [pc, #448]	; (800f134 <SecureElementInit+0x374>)
 800ef72:	238b      	movs	r3, #139	; 0x8b
 800ef74:	009a      	lsls	r2, r3, #2
 800ef76:	0003      	movs	r3, r0
 800ef78:	011b      	lsls	r3, r3, #4
 800ef7a:	181b      	adds	r3, r3, r0
 800ef7c:	18cb      	adds	r3, r1, r3
 800ef7e:	189b      	adds	r3, r3, r2
 800ef80:	2281      	movs	r2, #129	; 0x81
 800ef82:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_NWK_S_KEY_0;
 800ef84:	193b      	adds	r3, r7, r4
 800ef86:	781b      	ldrb	r3, [r3, #0]
 800ef88:	193a      	adds	r2, r7, r4
 800ef8a:	1c59      	adds	r1, r3, #1
 800ef8c:	7011      	strb	r1, [r2, #0]
 800ef8e:	0018      	movs	r0, r3
 800ef90:	4968      	ldr	r1, [pc, #416]	; (800f134 <SecureElementInit+0x374>)
 800ef92:	238b      	movs	r3, #139	; 0x8b
 800ef94:	009a      	lsls	r2, r3, #2
 800ef96:	0003      	movs	r3, r0
 800ef98:	011b      	lsls	r3, r3, #4
 800ef9a:	181b      	adds	r3, r3, r0
 800ef9c:	18cb      	adds	r3, r1, r3
 800ef9e:	189b      	adds	r3, r3, r2
 800efa0:	2282      	movs	r2, #130	; 0x82
 800efa2:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_KEY_1;
 800efa4:	193b      	adds	r3, r7, r4
 800efa6:	781b      	ldrb	r3, [r3, #0]
 800efa8:	193a      	adds	r2, r7, r4
 800efaa:	1c59      	adds	r1, r3, #1
 800efac:	7011      	strb	r1, [r2, #0]
 800efae:	0018      	movs	r0, r3
 800efb0:	4960      	ldr	r1, [pc, #384]	; (800f134 <SecureElementInit+0x374>)
 800efb2:	238b      	movs	r3, #139	; 0x8b
 800efb4:	009a      	lsls	r2, r3, #2
 800efb6:	0003      	movs	r3, r0
 800efb8:	011b      	lsls	r3, r3, #4
 800efba:	181b      	adds	r3, r3, r0
 800efbc:	18cb      	adds	r3, r1, r3
 800efbe:	189b      	adds	r3, r3, r2
 800efc0:	2283      	movs	r2, #131	; 0x83
 800efc2:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_APP_S_KEY_1;
 800efc4:	193b      	adds	r3, r7, r4
 800efc6:	781b      	ldrb	r3, [r3, #0]
 800efc8:	193a      	adds	r2, r7, r4
 800efca:	1c59      	adds	r1, r3, #1
 800efcc:	7011      	strb	r1, [r2, #0]
 800efce:	0018      	movs	r0, r3
 800efd0:	4958      	ldr	r1, [pc, #352]	; (800f134 <SecureElementInit+0x374>)
 800efd2:	238b      	movs	r3, #139	; 0x8b
 800efd4:	009a      	lsls	r2, r3, #2
 800efd6:	0003      	movs	r3, r0
 800efd8:	011b      	lsls	r3, r3, #4
 800efda:	181b      	adds	r3, r3, r0
 800efdc:	18cb      	adds	r3, r1, r3
 800efde:	189b      	adds	r3, r3, r2
 800efe0:	2284      	movs	r2, #132	; 0x84
 800efe2:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_NWK_S_KEY_1;
 800efe4:	193b      	adds	r3, r7, r4
 800efe6:	781b      	ldrb	r3, [r3, #0]
 800efe8:	193a      	adds	r2, r7, r4
 800efea:	1c59      	adds	r1, r3, #1
 800efec:	7011      	strb	r1, [r2, #0]
 800efee:	0018      	movs	r0, r3
 800eff0:	4950      	ldr	r1, [pc, #320]	; (800f134 <SecureElementInit+0x374>)
 800eff2:	238b      	movs	r3, #139	; 0x8b
 800eff4:	009a      	lsls	r2, r3, #2
 800eff6:	0003      	movs	r3, r0
 800eff8:	011b      	lsls	r3, r3, #4
 800effa:	181b      	adds	r3, r3, r0
 800effc:	18cb      	adds	r3, r1, r3
 800effe:	189b      	adds	r3, r3, r2
 800f000:	2285      	movs	r2, #133	; 0x85
 800f002:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_KEY_2;
 800f004:	193b      	adds	r3, r7, r4
 800f006:	781b      	ldrb	r3, [r3, #0]
 800f008:	193a      	adds	r2, r7, r4
 800f00a:	1c59      	adds	r1, r3, #1
 800f00c:	7011      	strb	r1, [r2, #0]
 800f00e:	0018      	movs	r0, r3
 800f010:	4948      	ldr	r1, [pc, #288]	; (800f134 <SecureElementInit+0x374>)
 800f012:	238b      	movs	r3, #139	; 0x8b
 800f014:	009a      	lsls	r2, r3, #2
 800f016:	0003      	movs	r3, r0
 800f018:	011b      	lsls	r3, r3, #4
 800f01a:	181b      	adds	r3, r3, r0
 800f01c:	18cb      	adds	r3, r1, r3
 800f01e:	189b      	adds	r3, r3, r2
 800f020:	2286      	movs	r2, #134	; 0x86
 800f022:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_APP_S_KEY_2;
 800f024:	193b      	adds	r3, r7, r4
 800f026:	781b      	ldrb	r3, [r3, #0]
 800f028:	193a      	adds	r2, r7, r4
 800f02a:	1c59      	adds	r1, r3, #1
 800f02c:	7011      	strb	r1, [r2, #0]
 800f02e:	0018      	movs	r0, r3
 800f030:	4940      	ldr	r1, [pc, #256]	; (800f134 <SecureElementInit+0x374>)
 800f032:	238b      	movs	r3, #139	; 0x8b
 800f034:	009a      	lsls	r2, r3, #2
 800f036:	0003      	movs	r3, r0
 800f038:	011b      	lsls	r3, r3, #4
 800f03a:	181b      	adds	r3, r3, r0
 800f03c:	18cb      	adds	r3, r1, r3
 800f03e:	189b      	adds	r3, r3, r2
 800f040:	2287      	movs	r2, #135	; 0x87
 800f042:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_NWK_S_KEY_2;
 800f044:	193b      	adds	r3, r7, r4
 800f046:	781b      	ldrb	r3, [r3, #0]
 800f048:	193a      	adds	r2, r7, r4
 800f04a:	1c59      	adds	r1, r3, #1
 800f04c:	7011      	strb	r1, [r2, #0]
 800f04e:	0018      	movs	r0, r3
 800f050:	4938      	ldr	r1, [pc, #224]	; (800f134 <SecureElementInit+0x374>)
 800f052:	238b      	movs	r3, #139	; 0x8b
 800f054:	009a      	lsls	r2, r3, #2
 800f056:	0003      	movs	r3, r0
 800f058:	011b      	lsls	r3, r3, #4
 800f05a:	181b      	adds	r3, r3, r0
 800f05c:	18cb      	adds	r3, r1, r3
 800f05e:	189b      	adds	r3, r3, r2
 800f060:	2288      	movs	r2, #136	; 0x88
 800f062:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_KEY_3;
 800f064:	193b      	adds	r3, r7, r4
 800f066:	781b      	ldrb	r3, [r3, #0]
 800f068:	193a      	adds	r2, r7, r4
 800f06a:	1c59      	adds	r1, r3, #1
 800f06c:	7011      	strb	r1, [r2, #0]
 800f06e:	0018      	movs	r0, r3
 800f070:	4930      	ldr	r1, [pc, #192]	; (800f134 <SecureElementInit+0x374>)
 800f072:	238b      	movs	r3, #139	; 0x8b
 800f074:	009a      	lsls	r2, r3, #2
 800f076:	0003      	movs	r3, r0
 800f078:	011b      	lsls	r3, r3, #4
 800f07a:	181b      	adds	r3, r3, r0
 800f07c:	18cb      	adds	r3, r1, r3
 800f07e:	189b      	adds	r3, r3, r2
 800f080:	2289      	movs	r2, #137	; 0x89
 800f082:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_APP_S_KEY_3;
 800f084:	193b      	adds	r3, r7, r4
 800f086:	781b      	ldrb	r3, [r3, #0]
 800f088:	193a      	adds	r2, r7, r4
 800f08a:	1c59      	adds	r1, r3, #1
 800f08c:	7011      	strb	r1, [r2, #0]
 800f08e:	0018      	movs	r0, r3
 800f090:	4928      	ldr	r1, [pc, #160]	; (800f134 <SecureElementInit+0x374>)
 800f092:	238b      	movs	r3, #139	; 0x8b
 800f094:	009a      	lsls	r2, r3, #2
 800f096:	0003      	movs	r3, r0
 800f098:	011b      	lsls	r3, r3, #4
 800f09a:	181b      	adds	r3, r3, r0
 800f09c:	18cb      	adds	r3, r1, r3
 800f09e:	189b      	adds	r3, r3, r2
 800f0a0:	228a      	movs	r2, #138	; 0x8a
 800f0a2:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr++].KeyID = MC_NWK_S_KEY_3;
 800f0a4:	193b      	adds	r3, r7, r4
 800f0a6:	781b      	ldrb	r3, [r3, #0]
 800f0a8:	193a      	adds	r2, r7, r4
 800f0aa:	1c59      	adds	r1, r3, #1
 800f0ac:	7011      	strb	r1, [r2, #0]
 800f0ae:	0018      	movs	r0, r3
 800f0b0:	4920      	ldr	r1, [pc, #128]	; (800f134 <SecureElementInit+0x374>)
 800f0b2:	238b      	movs	r3, #139	; 0x8b
 800f0b4:	009a      	lsls	r2, r3, #2
 800f0b6:	0003      	movs	r3, r0
 800f0b8:	011b      	lsls	r3, r3, #4
 800f0ba:	181b      	adds	r3, r3, r0
 800f0bc:	18cb      	adds	r3, r1, r3
 800f0be:	189b      	adds	r3, r3, r2
 800f0c0:	228b      	movs	r2, #139	; 0x8b
 800f0c2:	701a      	strb	r2, [r3, #0]
    SeNvmCtx.KeyList[itr].KeyID = SLOT_RAND_ZERO_KEY;
 800f0c4:	193b      	adds	r3, r7, r4
 800f0c6:	781a      	ldrb	r2, [r3, #0]
 800f0c8:	481a      	ldr	r0, [pc, #104]	; (800f134 <SecureElementInit+0x374>)
 800f0ca:	238b      	movs	r3, #139	; 0x8b
 800f0cc:	0099      	lsls	r1, r3, #2
 800f0ce:	0013      	movs	r3, r2
 800f0d0:	011b      	lsls	r3, r3, #4
 800f0d2:	189b      	adds	r3, r3, r2
 800f0d4:	18c3      	adds	r3, r0, r3
 800f0d6:	185b      	adds	r3, r3, r1
 800f0d8:	228c      	movs	r2, #140	; 0x8c
 800f0da:	701a      	strb	r2, [r3, #0]

    // Set standard keys
    memcpy1( SeNvmCtx.KeyList[itr].KeyValue, zeroKey, KEY_SIZE );
 800f0dc:	193b      	adds	r3, r7, r4
 800f0de:	781a      	ldrb	r2, [r3, #0]
 800f0e0:	0013      	movs	r3, r2
 800f0e2:	011b      	lsls	r3, r3, #4
 800f0e4:	189b      	adds	r3, r3, r2
 800f0e6:	228a      	movs	r2, #138	; 0x8a
 800f0e8:	0092      	lsls	r2, r2, #2
 800f0ea:	189a      	adds	r2, r3, r2
 800f0ec:	4b11      	ldr	r3, [pc, #68]	; (800f134 <SecureElementInit+0x374>)
 800f0ee:	18d3      	adds	r3, r2, r3
 800f0f0:	3305      	adds	r3, #5
 800f0f2:	1979      	adds	r1, r7, r5
 800f0f4:	2210      	movs	r2, #16
 800f0f6:	0018      	movs	r0, r3
 800f0f8:	f00c fa26 	bl	801b548 <memcpy1>

    memset1( SeNvmCtx.DevEui, 0, SE_EUI_SIZE );
 800f0fc:	4b0d      	ldr	r3, [pc, #52]	; (800f134 <SecureElementInit+0x374>)
 800f0fe:	2210      	movs	r2, #16
 800f100:	2100      	movs	r1, #0
 800f102:	0018      	movs	r0, r3
 800f104:	f00c fa5e 	bl	801b5c4 <memset1>
    memset1( SeNvmCtx.JoinEui, 0, SE_EUI_SIZE );
 800f108:	4b0b      	ldr	r3, [pc, #44]	; (800f138 <SecureElementInit+0x378>)
 800f10a:	2210      	movs	r2, #16
 800f10c:	2100      	movs	r1, #0
 800f10e:	0018      	movs	r0, r3
 800f110:	f00c fa58 	bl	801b5c4 <memset1>

    // Assign callback
    if( seNvmCtxChanged != 0 )
 800f114:	687b      	ldr	r3, [r7, #4]
 800f116:	2b00      	cmp	r3, #0
 800f118:	d003      	beq.n	800f122 <SecureElementInit+0x362>
    {
        SeNvmCtxChanged = seNvmCtxChanged;
 800f11a:	4b08      	ldr	r3, [pc, #32]	; (800f13c <SecureElementInit+0x37c>)
 800f11c:	687a      	ldr	r2, [r7, #4]
 800f11e:	601a      	str	r2, [r3, #0]
 800f120:	e002      	b.n	800f128 <SecureElementInit+0x368>
    }
    else
    {
        SeNvmCtxChanged = DummyCB;
 800f122:	4b06      	ldr	r3, [pc, #24]	; (800f13c <SecureElementInit+0x37c>)
 800f124:	4a06      	ldr	r2, [pc, #24]	; (800f140 <SecureElementInit+0x380>)
 800f126:	601a      	str	r2, [r3, #0]
    }

    return SECURE_ELEMENT_SUCCESS;
 800f128:	2300      	movs	r3, #0
}
 800f12a:	0018      	movs	r0, r3
 800f12c:	46bd      	mov	sp, r7
 800f12e:	b008      	add	sp, #32
 800f130:	bdb0      	pop	{r4, r5, r7, pc}
 800f132:	46c0      	nop			; (mov r8, r8)
 800f134:	20000524 	.word	0x20000524
 800f138:	20000534 	.word	0x20000534
 800f13c:	200008e8 	.word	0x200008e8
 800f140:	0800ecf5 	.word	0x0800ecf5

0800f144 <SecureElementRestoreNvmCtx>:

SecureElementStatus_t SecureElementRestoreNvmCtx( void* seNvmCtx )
{
 800f144:	b580      	push	{r7, lr}
 800f146:	b082      	sub	sp, #8
 800f148:	af00      	add	r7, sp, #0
 800f14a:	6078      	str	r0, [r7, #4]
    // Restore nvm context
    if( seNvmCtx != 0 )
 800f14c:	687b      	ldr	r3, [r7, #4]
 800f14e:	2b00      	cmp	r3, #0
 800f150:	d008      	beq.n	800f164 <SecureElementRestoreNvmCtx+0x20>
    {
        memcpy1( ( uint8_t* ) &SeNvmCtx, ( uint8_t* ) seNvmCtx, sizeof( SeNvmCtx ) );
 800f152:	23f1      	movs	r3, #241	; 0xf1
 800f154:	009a      	lsls	r2, r3, #2
 800f156:	6879      	ldr	r1, [r7, #4]
 800f158:	4b05      	ldr	r3, [pc, #20]	; (800f170 <SecureElementRestoreNvmCtx+0x2c>)
 800f15a:	0018      	movs	r0, r3
 800f15c:	f00c f9f4 	bl	801b548 <memcpy1>
        return SECURE_ELEMENT_SUCCESS;
 800f160:	2300      	movs	r3, #0
 800f162:	e000      	b.n	800f166 <SecureElementRestoreNvmCtx+0x22>
    }
    else
    {
        return SECURE_ELEMENT_ERROR_NPE;
 800f164:	2302      	movs	r3, #2
    }
}
 800f166:	0018      	movs	r0, r3
 800f168:	46bd      	mov	sp, r7
 800f16a:	b002      	add	sp, #8
 800f16c:	bd80      	pop	{r7, pc}
 800f16e:	46c0      	nop			; (mov r8, r8)
 800f170:	20000524 	.word	0x20000524

0800f174 <SecureElementGetNvmCtx>:

void* SecureElementGetNvmCtx( size_t* seNvmCtxSize )
{
 800f174:	b580      	push	{r7, lr}
 800f176:	b082      	sub	sp, #8
 800f178:	af00      	add	r7, sp, #0
 800f17a:	6078      	str	r0, [r7, #4]
    *seNvmCtxSize = sizeof( SeNvmCtx );
 800f17c:	687b      	ldr	r3, [r7, #4]
 800f17e:	22f1      	movs	r2, #241	; 0xf1
 800f180:	0092      	lsls	r2, r2, #2
 800f182:	601a      	str	r2, [r3, #0]
    return &SeNvmCtx;
 800f184:	4b02      	ldr	r3, [pc, #8]	; (800f190 <SecureElementGetNvmCtx+0x1c>)
}
 800f186:	0018      	movs	r0, r3
 800f188:	46bd      	mov	sp, r7
 800f18a:	b002      	add	sp, #8
 800f18c:	bd80      	pop	{r7, pc}
 800f18e:	46c0      	nop			; (mov r8, r8)
 800f190:	20000524 	.word	0x20000524

0800f194 <SecureElementSetKey>:

SecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )
{
 800f194:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f196:	b089      	sub	sp, #36	; 0x24
 800f198:	af00      	add	r7, sp, #0
 800f19a:	0002      	movs	r2, r0
 800f19c:	6039      	str	r1, [r7, #0]
 800f19e:	1dfb      	adds	r3, r7, #7
 800f1a0:	701a      	strb	r2, [r3, #0]
    if( key == NULL )
 800f1a2:	683b      	ldr	r3, [r7, #0]
 800f1a4:	2b00      	cmp	r3, #0
 800f1a6:	d101      	bne.n	800f1ac <SecureElementSetKey+0x18>
    {
        return SECURE_ELEMENT_ERROR_NPE;
 800f1a8:	2302      	movs	r3, #2
 800f1aa:	e074      	b.n	800f296 <SecureElementSetKey+0x102>
    }

    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 800f1ac:	231f      	movs	r3, #31
 800f1ae:	18fb      	adds	r3, r7, r3
 800f1b0:	2200      	movs	r2, #0
 800f1b2:	701a      	strb	r2, [r3, #0]
 800f1b4:	e069      	b.n	800f28a <SecureElementSetKey+0xf6>
    {
        if( SeNvmCtx.KeyList[i].KeyID == keyID )
 800f1b6:	231f      	movs	r3, #31
 800f1b8:	18fb      	adds	r3, r7, r3
 800f1ba:	781a      	ldrb	r2, [r3, #0]
 800f1bc:	4838      	ldr	r0, [pc, #224]	; (800f2a0 <SecureElementSetKey+0x10c>)
 800f1be:	238b      	movs	r3, #139	; 0x8b
 800f1c0:	0099      	lsls	r1, r3, #2
 800f1c2:	0013      	movs	r3, r2
 800f1c4:	011b      	lsls	r3, r3, #4
 800f1c6:	189b      	adds	r3, r3, r2
 800f1c8:	18c3      	adds	r3, r0, r3
 800f1ca:	185b      	adds	r3, r3, r1
 800f1cc:	781b      	ldrb	r3, [r3, #0]
 800f1ce:	1dfa      	adds	r2, r7, #7
 800f1d0:	7812      	ldrb	r2, [r2, #0]
 800f1d2:	429a      	cmp	r2, r3
 800f1d4:	d153      	bne.n	800f27e <SecureElementSetKey+0xea>
        {
            if( ( keyID == MC_KEY_0 ) || ( keyID == MC_KEY_1 ) || ( keyID == MC_KEY_2 ) || ( keyID == MC_KEY_3 ) )
 800f1d6:	1dfb      	adds	r3, r7, #7
 800f1d8:	781b      	ldrb	r3, [r3, #0]
 800f1da:	2b80      	cmp	r3, #128	; 0x80
 800f1dc:	d00b      	beq.n	800f1f6 <SecureElementSetKey+0x62>
 800f1de:	1dfb      	adds	r3, r7, #7
 800f1e0:	781b      	ldrb	r3, [r3, #0]
 800f1e2:	2b83      	cmp	r3, #131	; 0x83
 800f1e4:	d007      	beq.n	800f1f6 <SecureElementSetKey+0x62>
 800f1e6:	1dfb      	adds	r3, r7, #7
 800f1e8:	781b      	ldrb	r3, [r3, #0]
 800f1ea:	2b86      	cmp	r3, #134	; 0x86
 800f1ec:	d003      	beq.n	800f1f6 <SecureElementSetKey+0x62>
 800f1ee:	1dfb      	adds	r3, r7, #7
 800f1f0:	781b      	ldrb	r3, [r3, #0]
 800f1f2:	2b89      	cmp	r3, #137	; 0x89
 800f1f4:	d12d      	bne.n	800f252 <SecureElementSetKey+0xbe>
            {  // Decrypt the key if its a Mckey
                SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
 800f1f6:	251e      	movs	r5, #30
 800f1f8:	197b      	adds	r3, r7, r5
 800f1fa:	2206      	movs	r2, #6
 800f1fc:	701a      	strb	r2, [r3, #0]
                uint8_t decryptedKey[16] = { 0 };
 800f1fe:	260c      	movs	r6, #12
 800f200:	19bb      	adds	r3, r7, r6
 800f202:	2200      	movs	r2, #0
 800f204:	601a      	str	r2, [r3, #0]
 800f206:	3304      	adds	r3, #4
 800f208:	220c      	movs	r2, #12
 800f20a:	2100      	movs	r1, #0
 800f20c:	0018      	movs	r0, r3
 800f20e:	f00e f9a1 	bl	801d554 <memset>

                retval = SecureElementAesEncrypt( key, 16, MC_KE_KEY, decryptedKey );
 800f212:	197c      	adds	r4, r7, r5
 800f214:	19bb      	adds	r3, r7, r6
 800f216:	6838      	ldr	r0, [r7, #0]
 800f218:	227f      	movs	r2, #127	; 0x7f
 800f21a:	2110      	movs	r1, #16
 800f21c:	f000 f8a6 	bl	800f36c <SecureElementAesEncrypt>
 800f220:	0003      	movs	r3, r0
 800f222:	7023      	strb	r3, [r4, #0]

                memcpy1( SeNvmCtx.KeyList[i].KeyValue, decryptedKey, KEY_SIZE );
 800f224:	231f      	movs	r3, #31
 800f226:	18fb      	adds	r3, r7, r3
 800f228:	781a      	ldrb	r2, [r3, #0]
 800f22a:	0013      	movs	r3, r2
 800f22c:	011b      	lsls	r3, r3, #4
 800f22e:	189b      	adds	r3, r3, r2
 800f230:	228a      	movs	r2, #138	; 0x8a
 800f232:	0092      	lsls	r2, r2, #2
 800f234:	189a      	adds	r2, r3, r2
 800f236:	4b1a      	ldr	r3, [pc, #104]	; (800f2a0 <SecureElementSetKey+0x10c>)
 800f238:	18d3      	adds	r3, r2, r3
 800f23a:	3305      	adds	r3, #5
 800f23c:	19b9      	adds	r1, r7, r6
 800f23e:	2210      	movs	r2, #16
 800f240:	0018      	movs	r0, r3
 800f242:	f00c f981 	bl	801b548 <memcpy1>
                SeNvmCtxChanged( );
 800f246:	4b17      	ldr	r3, [pc, #92]	; (800f2a4 <SecureElementSetKey+0x110>)
 800f248:	681b      	ldr	r3, [r3, #0]
 800f24a:	4798      	blx	r3

                return retval;
 800f24c:	197b      	adds	r3, r7, r5
 800f24e:	781b      	ldrb	r3, [r3, #0]
 800f250:	e021      	b.n	800f296 <SecureElementSetKey+0x102>
            }
            else
            {
                memcpy1( SeNvmCtx.KeyList[i].KeyValue, key, KEY_SIZE );
 800f252:	231f      	movs	r3, #31
 800f254:	18fb      	adds	r3, r7, r3
 800f256:	781a      	ldrb	r2, [r3, #0]
 800f258:	0013      	movs	r3, r2
 800f25a:	011b      	lsls	r3, r3, #4
 800f25c:	189b      	adds	r3, r3, r2
 800f25e:	228a      	movs	r2, #138	; 0x8a
 800f260:	0092      	lsls	r2, r2, #2
 800f262:	189a      	adds	r2, r3, r2
 800f264:	4b0e      	ldr	r3, [pc, #56]	; (800f2a0 <SecureElementSetKey+0x10c>)
 800f266:	18d3      	adds	r3, r2, r3
 800f268:	3305      	adds	r3, #5
 800f26a:	6839      	ldr	r1, [r7, #0]
 800f26c:	2210      	movs	r2, #16
 800f26e:	0018      	movs	r0, r3
 800f270:	f00c f96a 	bl	801b548 <memcpy1>
                SeNvmCtxChanged( );
 800f274:	4b0b      	ldr	r3, [pc, #44]	; (800f2a4 <SecureElementSetKey+0x110>)
 800f276:	681b      	ldr	r3, [r3, #0]
 800f278:	4798      	blx	r3
                return SECURE_ELEMENT_SUCCESS;
 800f27a:	2300      	movs	r3, #0
 800f27c:	e00b      	b.n	800f296 <SecureElementSetKey+0x102>
    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 800f27e:	211f      	movs	r1, #31
 800f280:	187b      	adds	r3, r7, r1
 800f282:	781a      	ldrb	r2, [r3, #0]
 800f284:	187b      	adds	r3, r7, r1
 800f286:	3201      	adds	r2, #1
 800f288:	701a      	strb	r2, [r3, #0]
 800f28a:	231f      	movs	r3, #31
 800f28c:	18fb      	adds	r3, r7, r3
 800f28e:	781b      	ldrb	r3, [r3, #0]
 800f290:	2b17      	cmp	r3, #23
 800f292:	d990      	bls.n	800f1b6 <SecureElementSetKey+0x22>
            }
        }
    }

    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800f294:	2303      	movs	r3, #3
}
 800f296:	0018      	movs	r0, r3
 800f298:	46bd      	mov	sp, r7
 800f29a:	b009      	add	sp, #36	; 0x24
 800f29c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800f29e:	46c0      	nop			; (mov r8, r8)
 800f2a0:	20000524 	.word	0x20000524
 800f2a4:	200008e8 	.word	0x200008e8

0800f2a8 <SecureElementComputeAesCmac>:

SecureElementStatus_t SecureElementComputeAesCmac( uint8_t *micBxBuffer, uint8_t *buffer, uint16_t size, KeyIdentifier_t keyID, uint32_t* cmac )
{
 800f2a8:	b590      	push	{r4, r7, lr}
 800f2aa:	b087      	sub	sp, #28
 800f2ac:	af02      	add	r7, sp, #8
 800f2ae:	60f8      	str	r0, [r7, #12]
 800f2b0:	60b9      	str	r1, [r7, #8]
 800f2b2:	0019      	movs	r1, r3
 800f2b4:	1dbb      	adds	r3, r7, #6
 800f2b6:	801a      	strh	r2, [r3, #0]
 800f2b8:	1d7b      	adds	r3, r7, #5
 800f2ba:	1c0a      	adds	r2, r1, #0
 800f2bc:	701a      	strb	r2, [r3, #0]
    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )
 800f2be:	1d7b      	adds	r3, r7, #5
 800f2c0:	781b      	ldrb	r3, [r3, #0]
 800f2c2:	2b7e      	cmp	r3, #126	; 0x7e
 800f2c4:	d901      	bls.n	800f2ca <SecureElementComputeAesCmac+0x22>
    {
        //Never accept multicast key identifier for cmac computation
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800f2c6:	2303      	movs	r3, #3
 800f2c8:	e00b      	b.n	800f2e2 <SecureElementComputeAesCmac+0x3a>
    }

    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
 800f2ca:	1d7b      	adds	r3, r7, #5
 800f2cc:	781c      	ldrb	r4, [r3, #0]
 800f2ce:	1dbb      	adds	r3, r7, #6
 800f2d0:	881a      	ldrh	r2, [r3, #0]
 800f2d2:	68b9      	ldr	r1, [r7, #8]
 800f2d4:	68f8      	ldr	r0, [r7, #12]
 800f2d6:	6a3b      	ldr	r3, [r7, #32]
 800f2d8:	9300      	str	r3, [sp, #0]
 800f2da:	0023      	movs	r3, r4
 800f2dc:	f7ff fd10 	bl	800ed00 <ComputeCmac>
 800f2e0:	0003      	movs	r3, r0
}
 800f2e2:	0018      	movs	r0, r3
 800f2e4:	46bd      	mov	sp, r7
 800f2e6:	b005      	add	sp, #20
 800f2e8:	bd90      	pop	{r4, r7, pc}

0800f2ea <SecureElementVerifyAesCmac>:

SecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac, KeyIdentifier_t keyID )
{
 800f2ea:	b5b0      	push	{r4, r5, r7, lr}
 800f2ec:	b088      	sub	sp, #32
 800f2ee:	af02      	add	r7, sp, #8
 800f2f0:	60f8      	str	r0, [r7, #12]
 800f2f2:	0008      	movs	r0, r1
 800f2f4:	607a      	str	r2, [r7, #4]
 800f2f6:	0019      	movs	r1, r3
 800f2f8:	230a      	movs	r3, #10
 800f2fa:	18fb      	adds	r3, r7, r3
 800f2fc:	1c02      	adds	r2, r0, #0
 800f2fe:	801a      	strh	r2, [r3, #0]
 800f300:	2309      	movs	r3, #9
 800f302:	18fb      	adds	r3, r7, r3
 800f304:	1c0a      	adds	r2, r1, #0
 800f306:	701a      	strb	r2, [r3, #0]
    if( buffer == NULL )
 800f308:	68fb      	ldr	r3, [r7, #12]
 800f30a:	2b00      	cmp	r3, #0
 800f30c:	d101      	bne.n	800f312 <SecureElementVerifyAesCmac+0x28>
    {
        return SECURE_ELEMENT_ERROR_NPE;
 800f30e:	2302      	movs	r3, #2
 800f310:	e028      	b.n	800f364 <SecureElementVerifyAesCmac+0x7a>
    }

    SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
 800f312:	2517      	movs	r5, #23
 800f314:	197b      	adds	r3, r7, r5
 800f316:	2206      	movs	r2, #6
 800f318:	701a      	strb	r2, [r3, #0]
    uint32_t compCmac = 0;
 800f31a:	2300      	movs	r3, #0
 800f31c:	613b      	str	r3, [r7, #16]
    retval = ComputeCmac( NULL, buffer, size, keyID, &compCmac );
 800f31e:	197c      	adds	r4, r7, r5
 800f320:	2309      	movs	r3, #9
 800f322:	18fb      	adds	r3, r7, r3
 800f324:	7818      	ldrb	r0, [r3, #0]
 800f326:	230a      	movs	r3, #10
 800f328:	18fb      	adds	r3, r7, r3
 800f32a:	881a      	ldrh	r2, [r3, #0]
 800f32c:	68f9      	ldr	r1, [r7, #12]
 800f32e:	2310      	movs	r3, #16
 800f330:	18fb      	adds	r3, r7, r3
 800f332:	9300      	str	r3, [sp, #0]
 800f334:	0003      	movs	r3, r0
 800f336:	2000      	movs	r0, #0
 800f338:	f7ff fce2 	bl	800ed00 <ComputeCmac>
 800f33c:	0003      	movs	r3, r0
 800f33e:	7023      	strb	r3, [r4, #0]
    if( retval != SECURE_ELEMENT_SUCCESS )
 800f340:	197b      	adds	r3, r7, r5
 800f342:	781b      	ldrb	r3, [r3, #0]
 800f344:	2b00      	cmp	r3, #0
 800f346:	d002      	beq.n	800f34e <SecureElementVerifyAesCmac+0x64>
    {
        return retval;
 800f348:	197b      	adds	r3, r7, r5
 800f34a:	781b      	ldrb	r3, [r3, #0]
 800f34c:	e00a      	b.n	800f364 <SecureElementVerifyAesCmac+0x7a>
    }

    if( expectedCmac != compCmac )
 800f34e:	693b      	ldr	r3, [r7, #16]
 800f350:	687a      	ldr	r2, [r7, #4]
 800f352:	429a      	cmp	r2, r3
 800f354:	d003      	beq.n	800f35e <SecureElementVerifyAesCmac+0x74>
    {
        retval = SECURE_ELEMENT_FAIL_CMAC;
 800f356:	2317      	movs	r3, #23
 800f358:	18fb      	adds	r3, r7, r3
 800f35a:	2201      	movs	r2, #1
 800f35c:	701a      	strb	r2, [r3, #0]
    }

    return retval;
 800f35e:	2317      	movs	r3, #23
 800f360:	18fb      	adds	r3, r7, r3
 800f362:	781b      	ldrb	r3, [r3, #0]
}
 800f364:	0018      	movs	r0, r3
 800f366:	46bd      	mov	sp, r7
 800f368:	b006      	add	sp, #24
 800f36a:	bdb0      	pop	{r4, r5, r7, pc}

0800f36c <SecureElementAesEncrypt>:

SecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID, uint8_t* encBuffer )
{
 800f36c:	b5b0      	push	{r4, r5, r7, lr}
 800f36e:	b086      	sub	sp, #24
 800f370:	af00      	add	r7, sp, #0
 800f372:	60f8      	str	r0, [r7, #12]
 800f374:	0008      	movs	r0, r1
 800f376:	0011      	movs	r1, r2
 800f378:	607b      	str	r3, [r7, #4]
 800f37a:	230a      	movs	r3, #10
 800f37c:	18fb      	adds	r3, r7, r3
 800f37e:	1c02      	adds	r2, r0, #0
 800f380:	801a      	strh	r2, [r3, #0]
 800f382:	2309      	movs	r3, #9
 800f384:	18fb      	adds	r3, r7, r3
 800f386:	1c0a      	adds	r2, r1, #0
 800f388:	701a      	strb	r2, [r3, #0]
    if( buffer == NULL || encBuffer == NULL )
 800f38a:	68fb      	ldr	r3, [r7, #12]
 800f38c:	2b00      	cmp	r3, #0
 800f38e:	d002      	beq.n	800f396 <SecureElementAesEncrypt+0x2a>
 800f390:	687b      	ldr	r3, [r7, #4]
 800f392:	2b00      	cmp	r3, #0
 800f394:	d101      	bne.n	800f39a <SecureElementAesEncrypt+0x2e>
    {
        return SECURE_ELEMENT_ERROR_NPE;
 800f396:	2302      	movs	r3, #2
 800f398:	e04c      	b.n	800f434 <SecureElementAesEncrypt+0xc8>
    }

    // Check if the size is divisible by 16,
    if( ( size % 16 ) != 0 )
 800f39a:	230a      	movs	r3, #10
 800f39c:	18fb      	adds	r3, r7, r3
 800f39e:	881b      	ldrh	r3, [r3, #0]
 800f3a0:	220f      	movs	r2, #15
 800f3a2:	4013      	ands	r3, r2
 800f3a4:	b29b      	uxth	r3, r3
 800f3a6:	2b00      	cmp	r3, #0
 800f3a8:	d001      	beq.n	800f3ae <SecureElementAesEncrypt+0x42>
    {
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 800f3aa:	2305      	movs	r3, #5
 800f3ac:	e042      	b.n	800f434 <SecureElementAesEncrypt+0xc8>
    }

    memset1( SeNvmCtx.AesContext.ksch, '\0', 240 );
 800f3ae:	4b23      	ldr	r3, [pc, #140]	; (800f43c <SecureElementAesEncrypt+0xd0>)
 800f3b0:	22f0      	movs	r2, #240	; 0xf0
 800f3b2:	2100      	movs	r1, #0
 800f3b4:	0018      	movs	r0, r3
 800f3b6:	f00c f905 	bl	801b5c4 <memset1>

    Key_t* pItem;
    SecureElementStatus_t retval = GetKeyByID( keyID, &pItem );
 800f3ba:	2516      	movs	r5, #22
 800f3bc:	197c      	adds	r4, r7, r5
 800f3be:	2310      	movs	r3, #16
 800f3c0:	18fa      	adds	r2, r7, r3
 800f3c2:	2309      	movs	r3, #9
 800f3c4:	18fb      	adds	r3, r7, r3
 800f3c6:	781b      	ldrb	r3, [r3, #0]
 800f3c8:	0011      	movs	r1, r2
 800f3ca:	0018      	movs	r0, r3
 800f3cc:	f7ff fc54 	bl	800ec78 <GetKeyByID>
 800f3d0:	0003      	movs	r3, r0
 800f3d2:	7023      	strb	r3, [r4, #0]

    if( retval == SECURE_ELEMENT_SUCCESS )
 800f3d4:	197b      	adds	r3, r7, r5
 800f3d6:	781b      	ldrb	r3, [r3, #0]
 800f3d8:	2b00      	cmp	r3, #0
 800f3da:	d128      	bne.n	800f42e <SecureElementAesEncrypt+0xc2>
    {
        aes_set_key( pItem->KeyValue, 16, &SeNvmCtx.AesContext );
 800f3dc:	693b      	ldr	r3, [r7, #16]
 800f3de:	3301      	adds	r3, #1
 800f3e0:	4a16      	ldr	r2, [pc, #88]	; (800f43c <SecureElementAesEncrypt+0xd0>)
 800f3e2:	2110      	movs	r1, #16
 800f3e4:	0018      	movs	r0, r3
 800f3e6:	f7ff f871 	bl	800e4cc <aes_set_key>

        uint8_t block = 0;
 800f3ea:	2317      	movs	r3, #23
 800f3ec:	18fb      	adds	r3, r7, r3
 800f3ee:	2200      	movs	r2, #0
 800f3f0:	701a      	strb	r2, [r3, #0]

        while( size != 0 )
 800f3f2:	e017      	b.n	800f424 <SecureElementAesEncrypt+0xb8>
        {
            aes_encrypt( &buffer[block], &encBuffer[block], &SeNvmCtx.AesContext );
 800f3f4:	2417      	movs	r4, #23
 800f3f6:	193b      	adds	r3, r7, r4
 800f3f8:	781b      	ldrb	r3, [r3, #0]
 800f3fa:	68fa      	ldr	r2, [r7, #12]
 800f3fc:	18d0      	adds	r0, r2, r3
 800f3fe:	193b      	adds	r3, r7, r4
 800f400:	781b      	ldrb	r3, [r3, #0]
 800f402:	687a      	ldr	r2, [r7, #4]
 800f404:	18d3      	adds	r3, r2, r3
 800f406:	4a0d      	ldr	r2, [pc, #52]	; (800f43c <SecureElementAesEncrypt+0xd0>)
 800f408:	0019      	movs	r1, r3
 800f40a:	f7ff f99b 	bl	800e744 <aes_encrypt>
            block = block + 16;
 800f40e:	193b      	adds	r3, r7, r4
 800f410:	193a      	adds	r2, r7, r4
 800f412:	7812      	ldrb	r2, [r2, #0]
 800f414:	3210      	adds	r2, #16
 800f416:	701a      	strb	r2, [r3, #0]
            size = size - 16;
 800f418:	220a      	movs	r2, #10
 800f41a:	18bb      	adds	r3, r7, r2
 800f41c:	18ba      	adds	r2, r7, r2
 800f41e:	8812      	ldrh	r2, [r2, #0]
 800f420:	3a10      	subs	r2, #16
 800f422:	801a      	strh	r2, [r3, #0]
        while( size != 0 )
 800f424:	230a      	movs	r3, #10
 800f426:	18fb      	adds	r3, r7, r3
 800f428:	881b      	ldrh	r3, [r3, #0]
 800f42a:	2b00      	cmp	r3, #0
 800f42c:	d1e2      	bne.n	800f3f4 <SecureElementAesEncrypt+0x88>
        }
    }
    return retval;
 800f42e:	2316      	movs	r3, #22
 800f430:	18fb      	adds	r3, r7, r3
 800f432:	781b      	ldrb	r3, [r3, #0]
}
 800f434:	0018      	movs	r0, r3
 800f436:	46bd      	mov	sp, r7
 800f438:	b006      	add	sp, #24
 800f43a:	bdb0      	pop	{r4, r5, r7, pc}
 800f43c:	20000544 	.word	0x20000544

0800f440 <SecureElementDeriveAndStoreKey>:

SecureElementStatus_t SecureElementDeriveAndStoreKey( Version_t version, uint8_t* input, KeyIdentifier_t rootKeyID, KeyIdentifier_t targetKeyID )
{
 800f440:	b5b0      	push	{r4, r5, r7, lr}
 800f442:	b08a      	sub	sp, #40	; 0x28
 800f444:	af00      	add	r7, sp, #0
 800f446:	60f8      	str	r0, [r7, #12]
 800f448:	60b9      	str	r1, [r7, #8]
 800f44a:	0019      	movs	r1, r3
 800f44c:	1dfb      	adds	r3, r7, #7
 800f44e:	701a      	strb	r2, [r3, #0]
 800f450:	1dbb      	adds	r3, r7, #6
 800f452:	1c0a      	adds	r2, r1, #0
 800f454:	701a      	strb	r2, [r3, #0]
    if( input == NULL )
 800f456:	68bb      	ldr	r3, [r7, #8]
 800f458:	2b00      	cmp	r3, #0
 800f45a:	d101      	bne.n	800f460 <SecureElementDeriveAndStoreKey+0x20>
    {
        return SECURE_ELEMENT_ERROR_NPE;
 800f45c:	2302      	movs	r3, #2
 800f45e:	e048      	b.n	800f4f2 <SecureElementDeriveAndStoreKey+0xb2>
    }

    SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
 800f460:	2327      	movs	r3, #39	; 0x27
 800f462:	18fb      	adds	r3, r7, r3
 800f464:	2206      	movs	r2, #6
 800f466:	701a      	strb	r2, [r3, #0]
    uint8_t key[16] = { 0 };
 800f468:	2314      	movs	r3, #20
 800f46a:	18fb      	adds	r3, r7, r3
 800f46c:	2200      	movs	r2, #0
 800f46e:	601a      	str	r2, [r3, #0]
 800f470:	3304      	adds	r3, #4
 800f472:	220c      	movs	r2, #12
 800f474:	2100      	movs	r1, #0
 800f476:	0018      	movs	r0, r3
 800f478:	f00e f86c 	bl	801d554 <memset>

    // In case of MC_KE_KEY, prevent other keys than NwkKey or AppKey for LoRaWAN 1.1 or later
    if( targetKeyID == MC_KE_KEY )
 800f47c:	1dbb      	adds	r3, r7, #6
 800f47e:	781b      	ldrb	r3, [r3, #0]
 800f480:	2b7f      	cmp	r3, #127	; 0x7f
 800f482:	d10e      	bne.n	800f4a2 <SecureElementDeriveAndStoreKey+0x62>
    {
        if( ( ( rootKeyID == APP_KEY ) && ( version.Fields.Minor == 0 ) ) || ( rootKeyID == NWK_KEY ) )
 800f484:	1dfb      	adds	r3, r7, #7
 800f486:	781b      	ldrb	r3, [r3, #0]
 800f488:	2b00      	cmp	r3, #0
 800f48a:	d104      	bne.n	800f496 <SecureElementDeriveAndStoreKey+0x56>
 800f48c:	230c      	movs	r3, #12
 800f48e:	18fb      	adds	r3, r7, r3
 800f490:	789b      	ldrb	r3, [r3, #2]
 800f492:	2b00      	cmp	r3, #0
 800f494:	d003      	beq.n	800f49e <SecureElementDeriveAndStoreKey+0x5e>
 800f496:	1dfb      	adds	r3, r7, #7
 800f498:	781b      	ldrb	r3, [r3, #0]
 800f49a:	2b02      	cmp	r3, #2
 800f49c:	d101      	bne.n	800f4a2 <SecureElementDeriveAndStoreKey+0x62>
        {
            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800f49e:	2303      	movs	r3, #3
 800f4a0:	e027      	b.n	800f4f2 <SecureElementDeriveAndStoreKey+0xb2>
        }
    }

    // Derive key
    retval = SecureElementAesEncrypt( input, 16, rootKeyID, key );
 800f4a2:	2527      	movs	r5, #39	; 0x27
 800f4a4:	197c      	adds	r4, r7, r5
 800f4a6:	2314      	movs	r3, #20
 800f4a8:	18f9      	adds	r1, r7, r3
 800f4aa:	1dfb      	adds	r3, r7, #7
 800f4ac:	781a      	ldrb	r2, [r3, #0]
 800f4ae:	68b8      	ldr	r0, [r7, #8]
 800f4b0:	000b      	movs	r3, r1
 800f4b2:	2110      	movs	r1, #16
 800f4b4:	f7ff ff5a 	bl	800f36c <SecureElementAesEncrypt>
 800f4b8:	0003      	movs	r3, r0
 800f4ba:	7023      	strb	r3, [r4, #0]
    if( retval != SECURE_ELEMENT_SUCCESS )
 800f4bc:	197b      	adds	r3, r7, r5
 800f4be:	781b      	ldrb	r3, [r3, #0]
 800f4c0:	2b00      	cmp	r3, #0
 800f4c2:	d002      	beq.n	800f4ca <SecureElementDeriveAndStoreKey+0x8a>
    {
        return retval;
 800f4c4:	197b      	adds	r3, r7, r5
 800f4c6:	781b      	ldrb	r3, [r3, #0]
 800f4c8:	e013      	b.n	800f4f2 <SecureElementDeriveAndStoreKey+0xb2>
    }

    // Store key
    retval = SecureElementSetKey( targetKeyID, key );
 800f4ca:	2527      	movs	r5, #39	; 0x27
 800f4cc:	197c      	adds	r4, r7, r5
 800f4ce:	2314      	movs	r3, #20
 800f4d0:	18fa      	adds	r2, r7, r3
 800f4d2:	1dbb      	adds	r3, r7, #6
 800f4d4:	781b      	ldrb	r3, [r3, #0]
 800f4d6:	0011      	movs	r1, r2
 800f4d8:	0018      	movs	r0, r3
 800f4da:	f7ff fe5b 	bl	800f194 <SecureElementSetKey>
 800f4de:	0003      	movs	r3, r0
 800f4e0:	7023      	strb	r3, [r4, #0]
    if( retval != SECURE_ELEMENT_SUCCESS )
 800f4e2:	197b      	adds	r3, r7, r5
 800f4e4:	781b      	ldrb	r3, [r3, #0]
 800f4e6:	2b00      	cmp	r3, #0
 800f4e8:	d002      	beq.n	800f4f0 <SecureElementDeriveAndStoreKey+0xb0>
    {
        return retval;
 800f4ea:	197b      	adds	r3, r7, r5
 800f4ec:	781b      	ldrb	r3, [r3, #0]
 800f4ee:	e000      	b.n	800f4f2 <SecureElementDeriveAndStoreKey+0xb2>
    }

    return SECURE_ELEMENT_SUCCESS;
 800f4f0:	2300      	movs	r3, #0
}
 800f4f2:	0018      	movs	r0, r3
 800f4f4:	46bd      	mov	sp, r7
 800f4f6:	b00a      	add	sp, #40	; 0x28
 800f4f8:	bdb0      	pop	{r4, r5, r7, pc}
	...

0800f4fc <SecureElementRandomNumber>:

SecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )
{
 800f4fc:	b580      	push	{r7, lr}
 800f4fe:	b082      	sub	sp, #8
 800f500:	af00      	add	r7, sp, #0
 800f502:	6078      	str	r0, [r7, #4]
    if( randomNum == NULL )
 800f504:	687b      	ldr	r3, [r7, #4]
 800f506:	2b00      	cmp	r3, #0
 800f508:	d101      	bne.n	800f50e <SecureElementRandomNumber+0x12>
    {
        return SECURE_ELEMENT_ERROR_NPE;
 800f50a:	2302      	movs	r3, #2
 800f50c:	e006      	b.n	800f51c <SecureElementRandomNumber+0x20>
    }
    *randomNum = Radio.Random( );
 800f50e:	4b05      	ldr	r3, [pc, #20]	; (800f524 <SecureElementRandomNumber+0x28>)
 800f510:	69db      	ldr	r3, [r3, #28]
 800f512:	4798      	blx	r3
 800f514:	0002      	movs	r2, r0
 800f516:	687b      	ldr	r3, [r7, #4]
 800f518:	601a      	str	r2, [r3, #0]
    return SECURE_ELEMENT_SUCCESS;
 800f51a:	2300      	movs	r3, #0
}
 800f51c:	0018      	movs	r0, r3
 800f51e:	46bd      	mov	sp, r7
 800f520:	b002      	add	sp, #8
 800f522:	bd80      	pop	{r7, pc}
 800f524:	0801ebd0 	.word	0x0801ebd0

0800f528 <SecureElementSetDevEui>:

SecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )
{
 800f528:	b580      	push	{r7, lr}
 800f52a:	b082      	sub	sp, #8
 800f52c:	af00      	add	r7, sp, #0
 800f52e:	6078      	str	r0, [r7, #4]
    if( devEui == NULL )
 800f530:	687b      	ldr	r3, [r7, #4]
 800f532:	2b00      	cmp	r3, #0
 800f534:	d101      	bne.n	800f53a <SecureElementSetDevEui+0x12>
    {
        return SECURE_ELEMENT_ERROR_NPE;
 800f536:	2302      	movs	r3, #2
 800f538:	e009      	b.n	800f54e <SecureElementSetDevEui+0x26>
    }
    memcpy1( SeNvmCtx.DevEui, devEui, SE_EUI_SIZE );
 800f53a:	6879      	ldr	r1, [r7, #4]
 800f53c:	4b06      	ldr	r3, [pc, #24]	; (800f558 <SecureElementSetDevEui+0x30>)
 800f53e:	2210      	movs	r2, #16
 800f540:	0018      	movs	r0, r3
 800f542:	f00c f801 	bl	801b548 <memcpy1>
    SeNvmCtxChanged( );
 800f546:	4b05      	ldr	r3, [pc, #20]	; (800f55c <SecureElementSetDevEui+0x34>)
 800f548:	681b      	ldr	r3, [r3, #0]
 800f54a:	4798      	blx	r3
    return SECURE_ELEMENT_SUCCESS;
 800f54c:	2300      	movs	r3, #0
}
 800f54e:	0018      	movs	r0, r3
 800f550:	46bd      	mov	sp, r7
 800f552:	b002      	add	sp, #8
 800f554:	bd80      	pop	{r7, pc}
 800f556:	46c0      	nop			; (mov r8, r8)
 800f558:	20000524 	.word	0x20000524
 800f55c:	200008e8 	.word	0x200008e8

0800f560 <SecureElementGetDevEui>:

uint8_t* SecureElementGetDevEui( void )
{
 800f560:	b580      	push	{r7, lr}
 800f562:	af00      	add	r7, sp, #0
    return SeNvmCtx.DevEui;
 800f564:	4b01      	ldr	r3, [pc, #4]	; (800f56c <SecureElementGetDevEui+0xc>)
}
 800f566:	0018      	movs	r0, r3
 800f568:	46bd      	mov	sp, r7
 800f56a:	bd80      	pop	{r7, pc}
 800f56c:	20000524 	.word	0x20000524

0800f570 <SecureElementSetJoinEui>:

SecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )
{
 800f570:	b580      	push	{r7, lr}
 800f572:	b082      	sub	sp, #8
 800f574:	af00      	add	r7, sp, #0
 800f576:	6078      	str	r0, [r7, #4]
    if( joinEui == NULL )
 800f578:	687b      	ldr	r3, [r7, #4]
 800f57a:	2b00      	cmp	r3, #0
 800f57c:	d101      	bne.n	800f582 <SecureElementSetJoinEui+0x12>
    {
        return SECURE_ELEMENT_ERROR_NPE;
 800f57e:	2302      	movs	r3, #2
 800f580:	e009      	b.n	800f596 <SecureElementSetJoinEui+0x26>
    }
    memcpy1( SeNvmCtx.JoinEui, joinEui, SE_EUI_SIZE );
 800f582:	6879      	ldr	r1, [r7, #4]
 800f584:	4b06      	ldr	r3, [pc, #24]	; (800f5a0 <SecureElementSetJoinEui+0x30>)
 800f586:	2210      	movs	r2, #16
 800f588:	0018      	movs	r0, r3
 800f58a:	f00b ffdd 	bl	801b548 <memcpy1>
    SeNvmCtxChanged( );
 800f58e:	4b05      	ldr	r3, [pc, #20]	; (800f5a4 <SecureElementSetJoinEui+0x34>)
 800f590:	681b      	ldr	r3, [r3, #0]
 800f592:	4798      	blx	r3
    return SECURE_ELEMENT_SUCCESS;
 800f594:	2300      	movs	r3, #0
}
 800f596:	0018      	movs	r0, r3
 800f598:	46bd      	mov	sp, r7
 800f59a:	b002      	add	sp, #8
 800f59c:	bd80      	pop	{r7, pc}
 800f59e:	46c0      	nop			; (mov r8, r8)
 800f5a0:	20000534 	.word	0x20000534
 800f5a4:	200008e8 	.word	0x200008e8

0800f5a8 <SecureElementGetJoinEui>:

uint8_t* SecureElementGetJoinEui( void )
{
 800f5a8:	b580      	push	{r7, lr}
 800f5aa:	af00      	add	r7, sp, #0
    return SeNvmCtx.JoinEui;
 800f5ac:	4b01      	ldr	r3, [pc, #4]	; (800f5b4 <SecureElementGetJoinEui+0xc>)
}
 800f5ae:	0018      	movs	r0, r3
 800f5b0:	46bd      	mov	sp, r7
 800f5b2:	bd80      	pop	{r7, pc}
 800f5b4:	20000534 	.word	0x20000534

0800f5b8 <OnRadioTxDone>:
    int16_t Rssi;
    int8_t Snr;
}RxDoneParams;

static void OnRadioTxDone( void )
{
 800f5b8:	b5b0      	push	{r4, r5, r7, lr}
 800f5ba:	b084      	sub	sp, #16
 800f5bc:	af00      	add	r7, sp, #0
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 800f5be:	f00b fde0 	bl	801b182 <TimerGetCurrentTime>
 800f5c2:	0002      	movs	r2, r0
 800f5c4:	4b1e      	ldr	r3, [pc, #120]	; (800f640 <OnRadioTxDone+0x88>)
 800f5c6:	601a      	str	r2, [r3, #0]
    MacCtx.LastTxSysTime = SysTimeGet( );
 800f5c8:	4d1e      	ldr	r5, [pc, #120]	; (800f644 <OnRadioTxDone+0x8c>)
 800f5ca:	23ce      	movs	r3, #206	; 0xce
 800f5cc:	009c      	lsls	r4, r3, #2
 800f5ce:	003b      	movs	r3, r7
 800f5d0:	0018      	movs	r0, r3
 800f5d2:	f00b fbe6 	bl	801ada2 <SysTimeGet>
 800f5d6:	003a      	movs	r2, r7
 800f5d8:	192b      	adds	r3, r5, r4
 800f5da:	ca03      	ldmia	r2!, {r0, r1}
 800f5dc:	c303      	stmia	r3!, {r0, r1}

    LoRaMacRadioEvents.Events.TxDone = 1;
 800f5de:	4b1a      	ldr	r3, [pc, #104]	; (800f648 <OnRadioTxDone+0x90>)
 800f5e0:	781a      	ldrb	r2, [r3, #0]
 800f5e2:	2110      	movs	r1, #16
 800f5e4:	430a      	orrs	r2, r1
 800f5e6:	701a      	strb	r2, [r3, #0]

    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800f5e8:	4a16      	ldr	r2, [pc, #88]	; (800f644 <OnRadioTxDone+0x8c>)
 800f5ea:	23d2      	movs	r3, #210	; 0xd2
 800f5ec:	009b      	lsls	r3, r3, #2
 800f5ee:	58d3      	ldr	r3, [r2, r3]
 800f5f0:	2b00      	cmp	r3, #0
 800f5f2:	d00c      	beq.n	800f60e <OnRadioTxDone+0x56>
 800f5f4:	4a13      	ldr	r2, [pc, #76]	; (800f644 <OnRadioTxDone+0x8c>)
 800f5f6:	23d2      	movs	r3, #210	; 0xd2
 800f5f8:	009b      	lsls	r3, r3, #2
 800f5fa:	58d3      	ldr	r3, [r2, r3]
 800f5fc:	68db      	ldr	r3, [r3, #12]
 800f5fe:	2b00      	cmp	r3, #0
 800f600:	d005      	beq.n	800f60e <OnRadioTxDone+0x56>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 800f602:	4a10      	ldr	r2, [pc, #64]	; (800f644 <OnRadioTxDone+0x8c>)
 800f604:	23d2      	movs	r3, #210	; 0xd2
 800f606:	009b      	lsls	r3, r3, #2
 800f608:	58d3      	ldr	r3, [r2, r3]
 800f60a:	68db      	ldr	r3, [r3, #12]
 800f60c:	4798      	blx	r3
    }
#if !defined(NO_MAC_PRINTF)
    PRINTNOW(); PRINTF("PHY txDone\n\r" );
 800f60e:	2408      	movs	r4, #8
 800f610:	193b      	adds	r3, r7, r4
 800f612:	0018      	movs	r0, r3
 800f614:	f00b fbfd 	bl	801ae12 <SysTimeGetMcuTime>
 800f618:	0022      	movs	r2, r4
 800f61a:	18bb      	adds	r3, r7, r2
 800f61c:	6819      	ldr	r1, [r3, #0]
 800f61e:	18bb      	adds	r3, r7, r2
 800f620:	2204      	movs	r2, #4
 800f622:	5e9b      	ldrsh	r3, [r3, r2]
 800f624:	001a      	movs	r2, r3
 800f626:	4b09      	ldr	r3, [pc, #36]	; (800f64c <OnRadioTxDone+0x94>)
 800f628:	0018      	movs	r0, r3
 800f62a:	f00b fe7b 	bl	801b324 <TraceSend>
 800f62e:	4b08      	ldr	r3, [pc, #32]	; (800f650 <OnRadioTxDone+0x98>)
 800f630:	0018      	movs	r0, r3
 800f632:	f00b fe77 	bl	801b324 <TraceSend>
#endif
}
 800f636:	46c0      	nop			; (mov r8, r8)
 800f638:	46bd      	mov	sp, r7
 800f63a:	b004      	add	sp, #16
 800f63c:	bdb0      	pop	{r4, r5, r7, pc}
 800f63e:	46c0      	nop			; (mov r8, r8)
 800f640:	200017e0 	.word	0x200017e0
 800f644:	200008ec 	.word	0x200008ec
 800f648:	20000f50 	.word	0x20000f50
 800f64c:	0801f180 	.word	0x0801f180
 800f650:	0801f18c 	.word	0x0801f18c

0800f654 <OnRadioRxDone>:

static void OnRadioRxDone( uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr )
{
 800f654:	b5b0      	push	{r4, r5, r7, lr}
 800f656:	b086      	sub	sp, #24
 800f658:	af00      	add	r7, sp, #0
 800f65a:	60f8      	str	r0, [r7, #12]
 800f65c:	000c      	movs	r4, r1
 800f65e:	0010      	movs	r0, r2
 800f660:	0019      	movs	r1, r3
 800f662:	250a      	movs	r5, #10
 800f664:	197b      	adds	r3, r7, r5
 800f666:	1c22      	adds	r2, r4, #0
 800f668:	801a      	strh	r2, [r3, #0]
 800f66a:	2408      	movs	r4, #8
 800f66c:	193b      	adds	r3, r7, r4
 800f66e:	1c02      	adds	r2, r0, #0
 800f670:	801a      	strh	r2, [r3, #0]
 800f672:	1dfb      	adds	r3, r7, #7
 800f674:	1c0a      	adds	r2, r1, #0
 800f676:	701a      	strb	r2, [r3, #0]
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 800f678:	f00b fd83 	bl	801b182 <TimerGetCurrentTime>
 800f67c:	0002      	movs	r2, r0
 800f67e:	4b20      	ldr	r3, [pc, #128]	; (800f700 <OnRadioRxDone+0xac>)
 800f680:	601a      	str	r2, [r3, #0]
    RxDoneParams.Payload = payload;
 800f682:	4b1f      	ldr	r3, [pc, #124]	; (800f700 <OnRadioRxDone+0xac>)
 800f684:	68fa      	ldr	r2, [r7, #12]
 800f686:	605a      	str	r2, [r3, #4]
    RxDoneParams.Size = size;
 800f688:	4b1d      	ldr	r3, [pc, #116]	; (800f700 <OnRadioRxDone+0xac>)
 800f68a:	197a      	adds	r2, r7, r5
 800f68c:	8812      	ldrh	r2, [r2, #0]
 800f68e:	811a      	strh	r2, [r3, #8]
    RxDoneParams.Rssi = rssi;
 800f690:	4b1b      	ldr	r3, [pc, #108]	; (800f700 <OnRadioRxDone+0xac>)
 800f692:	193a      	adds	r2, r7, r4
 800f694:	8812      	ldrh	r2, [r2, #0]
 800f696:	815a      	strh	r2, [r3, #10]
    RxDoneParams.Snr = snr;
 800f698:	4b19      	ldr	r3, [pc, #100]	; (800f700 <OnRadioRxDone+0xac>)
 800f69a:	1dfa      	adds	r2, r7, #7
 800f69c:	7812      	ldrb	r2, [r2, #0]
 800f69e:	731a      	strb	r2, [r3, #12]

    LoRaMacRadioEvents.Events.RxDone = 1;
 800f6a0:	4b18      	ldr	r3, [pc, #96]	; (800f704 <OnRadioRxDone+0xb0>)
 800f6a2:	781a      	ldrb	r2, [r3, #0]
 800f6a4:	2108      	movs	r1, #8
 800f6a6:	430a      	orrs	r2, r1
 800f6a8:	701a      	strb	r2, [r3, #0]

    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800f6aa:	4a17      	ldr	r2, [pc, #92]	; (800f708 <OnRadioRxDone+0xb4>)
 800f6ac:	23d2      	movs	r3, #210	; 0xd2
 800f6ae:	009b      	lsls	r3, r3, #2
 800f6b0:	58d3      	ldr	r3, [r2, r3]
 800f6b2:	2b00      	cmp	r3, #0
 800f6b4:	d00c      	beq.n	800f6d0 <OnRadioRxDone+0x7c>
 800f6b6:	4a14      	ldr	r2, [pc, #80]	; (800f708 <OnRadioRxDone+0xb4>)
 800f6b8:	23d2      	movs	r3, #210	; 0xd2
 800f6ba:	009b      	lsls	r3, r3, #2
 800f6bc:	58d3      	ldr	r3, [r2, r3]
 800f6be:	68db      	ldr	r3, [r3, #12]
 800f6c0:	2b00      	cmp	r3, #0
 800f6c2:	d005      	beq.n	800f6d0 <OnRadioRxDone+0x7c>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 800f6c4:	4a10      	ldr	r2, [pc, #64]	; (800f708 <OnRadioRxDone+0xb4>)
 800f6c6:	23d2      	movs	r3, #210	; 0xd2
 800f6c8:	009b      	lsls	r3, r3, #2
 800f6ca:	58d3      	ldr	r3, [r2, r3]
 800f6cc:	68db      	ldr	r3, [r3, #12]
 800f6ce:	4798      	blx	r3
    }
#if !defined(NO_MAC_PRINTF)
    PRINTNOW(); PRINTF("PHY rxDone\n\r" );
 800f6d0:	2410      	movs	r4, #16
 800f6d2:	193b      	adds	r3, r7, r4
 800f6d4:	0018      	movs	r0, r3
 800f6d6:	f00b fb9c 	bl	801ae12 <SysTimeGetMcuTime>
 800f6da:	0022      	movs	r2, r4
 800f6dc:	18bb      	adds	r3, r7, r2
 800f6de:	6819      	ldr	r1, [r3, #0]
 800f6e0:	18bb      	adds	r3, r7, r2
 800f6e2:	2204      	movs	r2, #4
 800f6e4:	5e9b      	ldrsh	r3, [r3, r2]
 800f6e6:	001a      	movs	r2, r3
 800f6e8:	4b08      	ldr	r3, [pc, #32]	; (800f70c <OnRadioRxDone+0xb8>)
 800f6ea:	0018      	movs	r0, r3
 800f6ec:	f00b fe1a 	bl	801b324 <TraceSend>
 800f6f0:	4b07      	ldr	r3, [pc, #28]	; (800f710 <OnRadioRxDone+0xbc>)
 800f6f2:	0018      	movs	r0, r3
 800f6f4:	f00b fe16 	bl	801b324 <TraceSend>
#endif
}
 800f6f8:	46c0      	nop			; (mov r8, r8)
 800f6fa:	46bd      	mov	sp, r7
 800f6fc:	b006      	add	sp, #24
 800f6fe:	bdb0      	pop	{r4, r5, r7, pc}
 800f700:	200017e4 	.word	0x200017e4
 800f704:	20000f50 	.word	0x20000f50
 800f708:	200008ec 	.word	0x200008ec
 800f70c:	0801f180 	.word	0x0801f180
 800f710:	0801f19c 	.word	0x0801f19c

0800f714 <OnRadioTxTimeout>:

static void OnRadioTxTimeout( void )
{
 800f714:	b580      	push	{r7, lr}
 800f716:	b082      	sub	sp, #8
 800f718:	af00      	add	r7, sp, #0
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 800f71a:	4b17      	ldr	r3, [pc, #92]	; (800f778 <OnRadioTxTimeout+0x64>)
 800f71c:	781a      	ldrb	r2, [r3, #0]
 800f71e:	2104      	movs	r1, #4
 800f720:	430a      	orrs	r2, r1
 800f722:	701a      	strb	r2, [r3, #0]

    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800f724:	4a15      	ldr	r2, [pc, #84]	; (800f77c <OnRadioTxTimeout+0x68>)
 800f726:	23d2      	movs	r3, #210	; 0xd2
 800f728:	009b      	lsls	r3, r3, #2
 800f72a:	58d3      	ldr	r3, [r2, r3]
 800f72c:	2b00      	cmp	r3, #0
 800f72e:	d00c      	beq.n	800f74a <OnRadioTxTimeout+0x36>
 800f730:	4a12      	ldr	r2, [pc, #72]	; (800f77c <OnRadioTxTimeout+0x68>)
 800f732:	23d2      	movs	r3, #210	; 0xd2
 800f734:	009b      	lsls	r3, r3, #2
 800f736:	58d3      	ldr	r3, [r2, r3]
 800f738:	68db      	ldr	r3, [r3, #12]
 800f73a:	2b00      	cmp	r3, #0
 800f73c:	d005      	beq.n	800f74a <OnRadioTxTimeout+0x36>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 800f73e:	4a0f      	ldr	r2, [pc, #60]	; (800f77c <OnRadioTxTimeout+0x68>)
 800f740:	23d2      	movs	r3, #210	; 0xd2
 800f742:	009b      	lsls	r3, r3, #2
 800f744:	58d3      	ldr	r3, [r2, r3]
 800f746:	68db      	ldr	r3, [r3, #12]
 800f748:	4798      	blx	r3
    }
#if !defined(NO_MAC_PRINTF)
    PRINTNOW(); PRINTF("PHY txTimeOut\n\r" );
 800f74a:	003b      	movs	r3, r7
 800f74c:	0018      	movs	r0, r3
 800f74e:	f00b fb60 	bl	801ae12 <SysTimeGetMcuTime>
 800f752:	003b      	movs	r3, r7
 800f754:	6819      	ldr	r1, [r3, #0]
 800f756:	003b      	movs	r3, r7
 800f758:	2204      	movs	r2, #4
 800f75a:	5e9b      	ldrsh	r3, [r3, r2]
 800f75c:	001a      	movs	r2, r3
 800f75e:	4b08      	ldr	r3, [pc, #32]	; (800f780 <OnRadioTxTimeout+0x6c>)
 800f760:	0018      	movs	r0, r3
 800f762:	f00b fddf 	bl	801b324 <TraceSend>
 800f766:	4b07      	ldr	r3, [pc, #28]	; (800f784 <OnRadioTxTimeout+0x70>)
 800f768:	0018      	movs	r0, r3
 800f76a:	f00b fddb 	bl	801b324 <TraceSend>
#endif
}
 800f76e:	46c0      	nop			; (mov r8, r8)
 800f770:	46bd      	mov	sp, r7
 800f772:	b002      	add	sp, #8
 800f774:	bd80      	pop	{r7, pc}
 800f776:	46c0      	nop			; (mov r8, r8)
 800f778:	20000f50 	.word	0x20000f50
 800f77c:	200008ec 	.word	0x200008ec
 800f780:	0801f180 	.word	0x0801f180
 800f784:	0801f1ac 	.word	0x0801f1ac

0800f788 <OnRadioRxError>:

static void OnRadioRxError( void )
{
 800f788:	b580      	push	{r7, lr}
 800f78a:	af00      	add	r7, sp, #0
    LoRaMacRadioEvents.Events.RxError = 1;
 800f78c:	4b0d      	ldr	r3, [pc, #52]	; (800f7c4 <OnRadioRxError+0x3c>)
 800f78e:	781a      	ldrb	r2, [r3, #0]
 800f790:	2102      	movs	r1, #2
 800f792:	430a      	orrs	r2, r1
 800f794:	701a      	strb	r2, [r3, #0]

    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800f796:	4a0c      	ldr	r2, [pc, #48]	; (800f7c8 <OnRadioRxError+0x40>)
 800f798:	23d2      	movs	r3, #210	; 0xd2
 800f79a:	009b      	lsls	r3, r3, #2
 800f79c:	58d3      	ldr	r3, [r2, r3]
 800f79e:	2b00      	cmp	r3, #0
 800f7a0:	d00c      	beq.n	800f7bc <OnRadioRxError+0x34>
 800f7a2:	4a09      	ldr	r2, [pc, #36]	; (800f7c8 <OnRadioRxError+0x40>)
 800f7a4:	23d2      	movs	r3, #210	; 0xd2
 800f7a6:	009b      	lsls	r3, r3, #2
 800f7a8:	58d3      	ldr	r3, [r2, r3]
 800f7aa:	68db      	ldr	r3, [r3, #12]
 800f7ac:	2b00      	cmp	r3, #0
 800f7ae:	d005      	beq.n	800f7bc <OnRadioRxError+0x34>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 800f7b0:	4a05      	ldr	r2, [pc, #20]	; (800f7c8 <OnRadioRxError+0x40>)
 800f7b2:	23d2      	movs	r3, #210	; 0xd2
 800f7b4:	009b      	lsls	r3, r3, #2
 800f7b6:	58d3      	ldr	r3, [r2, r3]
 800f7b8:	68db      	ldr	r3, [r3, #12]
 800f7ba:	4798      	blx	r3
    }
}
 800f7bc:	46c0      	nop			; (mov r8, r8)
 800f7be:	46bd      	mov	sp, r7
 800f7c0:	bd80      	pop	{r7, pc}
 800f7c2:	46c0      	nop			; (mov r8, r8)
 800f7c4:	20000f50 	.word	0x20000f50
 800f7c8:	200008ec 	.word	0x200008ec

0800f7cc <OnRadioRxTimeout>:

static void OnRadioRxTimeout( void )
{
 800f7cc:	b580      	push	{r7, lr}
 800f7ce:	b082      	sub	sp, #8
 800f7d0:	af00      	add	r7, sp, #0
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 800f7d2:	4b17      	ldr	r3, [pc, #92]	; (800f830 <OnRadioRxTimeout+0x64>)
 800f7d4:	781a      	ldrb	r2, [r3, #0]
 800f7d6:	2101      	movs	r1, #1
 800f7d8:	430a      	orrs	r2, r1
 800f7da:	701a      	strb	r2, [r3, #0]

    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800f7dc:	4a15      	ldr	r2, [pc, #84]	; (800f834 <OnRadioRxTimeout+0x68>)
 800f7de:	23d2      	movs	r3, #210	; 0xd2
 800f7e0:	009b      	lsls	r3, r3, #2
 800f7e2:	58d3      	ldr	r3, [r2, r3]
 800f7e4:	2b00      	cmp	r3, #0
 800f7e6:	d00c      	beq.n	800f802 <OnRadioRxTimeout+0x36>
 800f7e8:	4a12      	ldr	r2, [pc, #72]	; (800f834 <OnRadioRxTimeout+0x68>)
 800f7ea:	23d2      	movs	r3, #210	; 0xd2
 800f7ec:	009b      	lsls	r3, r3, #2
 800f7ee:	58d3      	ldr	r3, [r2, r3]
 800f7f0:	68db      	ldr	r3, [r3, #12]
 800f7f2:	2b00      	cmp	r3, #0
 800f7f4:	d005      	beq.n	800f802 <OnRadioRxTimeout+0x36>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 800f7f6:	4a0f      	ldr	r2, [pc, #60]	; (800f834 <OnRadioRxTimeout+0x68>)
 800f7f8:	23d2      	movs	r3, #210	; 0xd2
 800f7fa:	009b      	lsls	r3, r3, #2
 800f7fc:	58d3      	ldr	r3, [r2, r3]
 800f7fe:	68db      	ldr	r3, [r3, #12]
 800f800:	4798      	blx	r3
    }
#if !defined(NO_MAC_PRINTF)
    PRINTNOW(); PRINTF("PHY rxTimeOut\n\r" );
 800f802:	003b      	movs	r3, r7
 800f804:	0018      	movs	r0, r3
 800f806:	f00b fb04 	bl	801ae12 <SysTimeGetMcuTime>
 800f80a:	003b      	movs	r3, r7
 800f80c:	6819      	ldr	r1, [r3, #0]
 800f80e:	003b      	movs	r3, r7
 800f810:	2204      	movs	r2, #4
 800f812:	5e9b      	ldrsh	r3, [r3, r2]
 800f814:	001a      	movs	r2, r3
 800f816:	4b08      	ldr	r3, [pc, #32]	; (800f838 <OnRadioRxTimeout+0x6c>)
 800f818:	0018      	movs	r0, r3
 800f81a:	f00b fd83 	bl	801b324 <TraceSend>
 800f81e:	4b07      	ldr	r3, [pc, #28]	; (800f83c <OnRadioRxTimeout+0x70>)
 800f820:	0018      	movs	r0, r3
 800f822:	f00b fd7f 	bl	801b324 <TraceSend>
#endif
}
 800f826:	46c0      	nop			; (mov r8, r8)
 800f828:	46bd      	mov	sp, r7
 800f82a:	b002      	add	sp, #8
 800f82c:	bd80      	pop	{r7, pc}
 800f82e:	46c0      	nop			; (mov r8, r8)
 800f830:	20000f50 	.word	0x20000f50
 800f834:	200008ec 	.word	0x200008ec
 800f838:	0801f180 	.word	0x0801f180
 800f83c:	0801f1bc 	.word	0x0801f1bc

0800f840 <UpdateRxSlotIdleState>:

static void UpdateRxSlotIdleState( void )
{
 800f840:	b580      	push	{r7, lr}
 800f842:	af00      	add	r7, sp, #0
    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )
 800f844:	4b0a      	ldr	r3, [pc, #40]	; (800f870 <UpdateRxSlotIdleState+0x30>)
 800f846:	4a0b      	ldr	r2, [pc, #44]	; (800f874 <UpdateRxSlotIdleState+0x34>)
 800f848:	589b      	ldr	r3, [r3, r2]
 800f84a:	22f0      	movs	r2, #240	; 0xf0
 800f84c:	5c9b      	ldrb	r3, [r3, r2]
 800f84e:	2b02      	cmp	r3, #2
 800f850:	d005      	beq.n	800f85e <UpdateRxSlotIdleState+0x1e>
    {
        MacCtx.RxSlot = RX_SLOT_NONE;
 800f852:	4a07      	ldr	r2, [pc, #28]	; (800f870 <UpdateRxSlotIdleState+0x30>)
 800f854:	2390      	movs	r3, #144	; 0x90
 800f856:	00db      	lsls	r3, r3, #3
 800f858:	2106      	movs	r1, #6
 800f85a:	54d1      	strb	r1, [r2, r3]
    }
    else
    {
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
    }
}
 800f85c:	e004      	b.n	800f868 <UpdateRxSlotIdleState+0x28>
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
 800f85e:	4a04      	ldr	r2, [pc, #16]	; (800f870 <UpdateRxSlotIdleState+0x30>)
 800f860:	2390      	movs	r3, #144	; 0x90
 800f862:	00db      	lsls	r3, r3, #3
 800f864:	2102      	movs	r1, #2
 800f866:	54d1      	strb	r1, [r2, r3]
}
 800f868:	46c0      	nop			; (mov r8, r8)
 800f86a:	46bd      	mov	sp, r7
 800f86c:	bd80      	pop	{r7, pc}
 800f86e:	46c0      	nop			; (mov r8, r8)
 800f870:	200008ec 	.word	0x200008ec
 800f874:	00000484 	.word	0x00000484

0800f878 <ProcessRadioTxDone>:

static void ProcessRadioTxDone( void )
{
 800f878:	b580      	push	{r7, lr}
 800f87a:	b084      	sub	sp, #16
 800f87c:	af00      	add	r7, sp, #0
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    SetBandTxDoneParams_t txDone;

    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )
 800f87e:	4b4a      	ldr	r3, [pc, #296]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f880:	4a4a      	ldr	r2, [pc, #296]	; (800f9ac <ProcessRadioTxDone+0x134>)
 800f882:	589b      	ldr	r3, [r3, r2]
 800f884:	22f0      	movs	r2, #240	; 0xf0
 800f886:	5c9b      	ldrb	r3, [r3, r2]
 800f888:	2b02      	cmp	r3, #2
 800f88a:	d002      	beq.n	800f892 <ProcessRadioTxDone+0x1a>
    {
        Radio.Sleep( );
 800f88c:	4b48      	ldr	r3, [pc, #288]	; (800f9b0 <ProcessRadioTxDone+0x138>)
 800f88e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f890:	4798      	blx	r3
    }
    // Setup timers
    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay );
 800f892:	4a45      	ldr	r2, [pc, #276]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f894:	23ec      	movs	r3, #236	; 0xec
 800f896:	009b      	lsls	r3, r3, #2
 800f898:	58d2      	ldr	r2, [r2, r3]
 800f89a:	4b46      	ldr	r3, [pc, #280]	; (800f9b4 <ProcessRadioTxDone+0x13c>)
 800f89c:	0011      	movs	r1, r2
 800f89e:	0018      	movs	r0, r3
 800f8a0:	f00b fc4a 	bl	801b138 <TimerSetValue>
    TimerStart( &MacCtx.RxWindowTimer1 );
 800f8a4:	4b43      	ldr	r3, [pc, #268]	; (800f9b4 <ProcessRadioTxDone+0x13c>)
 800f8a6:	0018      	movs	r0, r3
 800f8a8:	f00b faec 	bl	801ae84 <TimerStart>
    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay );
 800f8ac:	4a3e      	ldr	r2, [pc, #248]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f8ae:	23ed      	movs	r3, #237	; 0xed
 800f8b0:	009b      	lsls	r3, r3, #2
 800f8b2:	58d2      	ldr	r2, [r2, r3]
 800f8b4:	4b40      	ldr	r3, [pc, #256]	; (800f9b8 <ProcessRadioTxDone+0x140>)
 800f8b6:	0011      	movs	r1, r2
 800f8b8:	0018      	movs	r0, r3
 800f8ba:	f00b fc3d 	bl	801b138 <TimerSetValue>
    TimerStart( &MacCtx.RxWindowTimer2 );
 800f8be:	4b3e      	ldr	r3, [pc, #248]	; (800f9b8 <ProcessRadioTxDone+0x140>)
 800f8c0:	0018      	movs	r0, r3
 800f8c2:	f00b fadf 	bl	801ae84 <TimerStart>

    if( ( MacCtx.NvmCtx->DeviceClass == CLASS_C ) || ( MacCtx.NodeAckRequested == true ) )
 800f8c6:	4b38      	ldr	r3, [pc, #224]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f8c8:	4a38      	ldr	r2, [pc, #224]	; (800f9ac <ProcessRadioTxDone+0x134>)
 800f8ca:	589b      	ldr	r3, [r3, r2]
 800f8cc:	22f0      	movs	r2, #240	; 0xf0
 800f8ce:	5c9b      	ldrb	r3, [r3, r2]
 800f8d0:	2b02      	cmp	r3, #2
 800f8d2:	d004      	beq.n	800f8de <ProcessRadioTxDone+0x66>
 800f8d4:	4b34      	ldr	r3, [pc, #208]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f8d6:	4a39      	ldr	r2, [pc, #228]	; (800f9bc <ProcessRadioTxDone+0x144>)
 800f8d8:	5c9b      	ldrb	r3, [r3, r2]
 800f8da:	2b00      	cmp	r3, #0
 800f8dc:	d021      	beq.n	800f922 <ProcessRadioTxDone+0xaa>
    {
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 800f8de:	210c      	movs	r1, #12
 800f8e0:	187b      	adds	r3, r7, r1
 800f8e2:	2216      	movs	r2, #22
 800f8e4:	701a      	strb	r2, [r3, #0]
        phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 800f8e6:	4b30      	ldr	r3, [pc, #192]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f8e8:	4a30      	ldr	r2, [pc, #192]	; (800f9ac <ProcessRadioTxDone+0x134>)
 800f8ea:	589b      	ldr	r3, [r3, r2]
 800f8ec:	781b      	ldrb	r3, [r3, #0]
 800f8ee:	187a      	adds	r2, r7, r1
 800f8f0:	0011      	movs	r1, r2
 800f8f2:	0018      	movs	r0, r3
 800f8f4:	f007 fe13 	bl	801751e <RegionGetPhyParam>
 800f8f8:	0003      	movs	r3, r0
 800f8fa:	001a      	movs	r2, r3
 800f8fc:	2108      	movs	r1, #8
 800f8fe:	187b      	adds	r3, r7, r1
 800f900:	601a      	str	r2, [r3, #0]
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 800f902:	4a29      	ldr	r2, [pc, #164]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f904:	23ed      	movs	r3, #237	; 0xed
 800f906:	009b      	lsls	r3, r3, #2
 800f908:	58d2      	ldr	r2, [r2, r3]
 800f90a:	187b      	adds	r3, r7, r1
 800f90c:	681b      	ldr	r3, [r3, #0]
 800f90e:	18d2      	adds	r2, r2, r3
 800f910:	4b2b      	ldr	r3, [pc, #172]	; (800f9c0 <ProcessRadioTxDone+0x148>)
 800f912:	0011      	movs	r1, r2
 800f914:	0018      	movs	r0, r3
 800f916:	f00b fc0f 	bl	801b138 <TimerSetValue>
        TimerStart( &MacCtx.AckTimeoutTimer );
 800f91a:	4b29      	ldr	r3, [pc, #164]	; (800f9c0 <ProcessRadioTxDone+0x148>)
 800f91c:	0018      	movs	r0, r3
 800f91e:	f00b fab1 	bl	801ae84 <TimerStart>
    }

    // Store last Tx channel
    MacCtx.NvmCtx->LastTxChannel = MacCtx.Channel;
 800f922:	4b21      	ldr	r3, [pc, #132]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f924:	4a21      	ldr	r2, [pc, #132]	; (800f9ac <ProcessRadioTxDone+0x134>)
 800f926:	589a      	ldr	r2, [r3, r2]
 800f928:	4b1f      	ldr	r3, [pc, #124]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f92a:	4926      	ldr	r1, [pc, #152]	; (800f9c4 <ProcessRadioTxDone+0x14c>)
 800f92c:	5c59      	ldrb	r1, [r3, r1]
 800f92e:	239f      	movs	r3, #159	; 0x9f
 800f930:	005b      	lsls	r3, r3, #1
 800f932:	54d1      	strb	r1, [r2, r3]
    // Update last tx done time for the current channel
    txDone.Channel = MacCtx.Channel;
 800f934:	4b1c      	ldr	r3, [pc, #112]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f936:	4a23      	ldr	r2, [pc, #140]	; (800f9c4 <ProcessRadioTxDone+0x14c>)
 800f938:	5c9a      	ldrb	r2, [r3, r2]
 800f93a:	003b      	movs	r3, r7
 800f93c:	701a      	strb	r2, [r3, #0]
    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )
 800f93e:	4b1a      	ldr	r3, [pc, #104]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f940:	4a1a      	ldr	r2, [pc, #104]	; (800f9ac <ProcessRadioTxDone+0x134>)
 800f942:	589a      	ldr	r2, [r3, r2]
 800f944:	23ea      	movs	r3, #234	; 0xea
 800f946:	005b      	lsls	r3, r3, #1
 800f948:	5cd3      	ldrb	r3, [r2, r3]
 800f94a:	2b00      	cmp	r3, #0
 800f94c:	d103      	bne.n	800f956 <ProcessRadioTxDone+0xde>
    {
        txDone.Joined  = false;
 800f94e:	003b      	movs	r3, r7
 800f950:	2200      	movs	r2, #0
 800f952:	705a      	strb	r2, [r3, #1]
 800f954:	e002      	b.n	800f95c <ProcessRadioTxDone+0xe4>
    }
    else
    {
        txDone.Joined  = true;
 800f956:	003b      	movs	r3, r7
 800f958:	2201      	movs	r2, #1
 800f95a:	705a      	strb	r2, [r3, #1]
    }
    txDone.LastTxDoneTime = TxDoneParams.CurTime;
 800f95c:	4b1a      	ldr	r3, [pc, #104]	; (800f9c8 <ProcessRadioTxDone+0x150>)
 800f95e:	681a      	ldr	r2, [r3, #0]
 800f960:	003b      	movs	r3, r7
 800f962:	605a      	str	r2, [r3, #4]
    RegionSetBandTxDone( MacCtx.NvmCtx->Region, &txDone );
 800f964:	4b10      	ldr	r3, [pc, #64]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f966:	4a11      	ldr	r2, [pc, #68]	; (800f9ac <ProcessRadioTxDone+0x134>)
 800f968:	589b      	ldr	r3, [r3, r2]
 800f96a:	781b      	ldrb	r3, [r3, #0]
 800f96c:	003a      	movs	r2, r7
 800f96e:	0011      	movs	r1, r2
 800f970:	0018      	movs	r0, r3
 800f972:	f007 fdfc 	bl	801756e <RegionSetBandTxDone>
    // Update Aggregated last tx done time
    MacCtx.NvmCtx->LastTxDoneTime = TxDoneParams.CurTime;
 800f976:	4b0c      	ldr	r3, [pc, #48]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f978:	4a0c      	ldr	r2, [pc, #48]	; (800f9ac <ProcessRadioTxDone+0x134>)
 800f97a:	589a      	ldr	r2, [r3, r2]
 800f97c:	4b12      	ldr	r3, [pc, #72]	; (800f9c8 <ProcessRadioTxDone+0x150>)
 800f97e:	6819      	ldr	r1, [r3, #0]
 800f980:	23e2      	movs	r3, #226	; 0xe2
 800f982:	005b      	lsls	r3, r3, #1
 800f984:	50d1      	str	r1, [r2, r3]

    if( MacCtx.NodeAckRequested == false )
 800f986:	4b08      	ldr	r3, [pc, #32]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f988:	4a0c      	ldr	r2, [pc, #48]	; (800f9bc <ProcessRadioTxDone+0x144>)
 800f98a:	5c9b      	ldrb	r3, [r3, r2]
 800f98c:	2201      	movs	r2, #1
 800f98e:	4053      	eors	r3, r2
 800f990:	b2db      	uxtb	r3, r3
 800f992:	2b00      	cmp	r3, #0
 800f994:	d003      	beq.n	800f99e <ProcessRadioTxDone+0x126>
    {
        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 800f996:	4b04      	ldr	r3, [pc, #16]	; (800f9a8 <ProcessRadioTxDone+0x130>)
 800f998:	4a0c      	ldr	r2, [pc, #48]	; (800f9cc <ProcessRadioTxDone+0x154>)
 800f99a:	2100      	movs	r1, #0
 800f99c:	5499      	strb	r1, [r3, r2]
    }
}
 800f99e:	46c0      	nop			; (mov r8, r8)
 800f9a0:	46bd      	mov	sp, r7
 800f9a2:	b004      	add	sp, #16
 800f9a4:	bd80      	pop	{r7, pc}
 800f9a6:	46c0      	nop			; (mov r8, r8)
 800f9a8:	200008ec 	.word	0x200008ec
 800f9ac:	00000484 	.word	0x00000484
 800f9b0:	0801ebd0 	.word	0x0801ebd0
 800f9b4:	20000c6c 	.word	0x20000c6c
 800f9b8:	20000c84 	.word	0x20000c84
 800f9bc:	00000414 	.word	0x00000414
 800f9c0:	20000ce4 	.word	0x20000ce4
 800f9c4:	00000415 	.word	0x00000415
 800f9c8:	200017e0 	.word	0x200017e0
 800f9cc:	0000043d 	.word	0x0000043d

0800f9d0 <PrepareRxDoneAbort>:

static void PrepareRxDoneAbort( void )
{
 800f9d0:	b580      	push	{r7, lr}
 800f9d2:	af00      	add	r7, sp, #0
    MacCtx.MacState |= LORAMAC_RX_ABORT;
 800f9d4:	4a11      	ldr	r2, [pc, #68]	; (800fa1c <PrepareRxDoneAbort+0x4c>)
 800f9d6:	23d0      	movs	r3, #208	; 0xd0
 800f9d8:	009b      	lsls	r3, r3, #2
 800f9da:	58d3      	ldr	r3, [r2, r3]
 800f9dc:	2280      	movs	r2, #128	; 0x80
 800f9de:	431a      	orrs	r2, r3
 800f9e0:	0011      	movs	r1, r2
 800f9e2:	4a0e      	ldr	r2, [pc, #56]	; (800fa1c <PrepareRxDoneAbort+0x4c>)
 800f9e4:	23d0      	movs	r3, #208	; 0xd0
 800f9e6:	009b      	lsls	r3, r3, #2
 800f9e8:	50d1      	str	r1, [r2, r3]

    if( MacCtx.NodeAckRequested == true )
 800f9ea:	4b0c      	ldr	r3, [pc, #48]	; (800fa1c <PrepareRxDoneAbort+0x4c>)
 800f9ec:	4a0c      	ldr	r2, [pc, #48]	; (800fa20 <PrepareRxDoneAbort+0x50>)
 800f9ee:	5c9b      	ldrb	r3, [r3, r2]
 800f9f0:	2b00      	cmp	r3, #0
 800f9f2:	d002      	beq.n	800f9fa <PrepareRxDoneAbort+0x2a>
    {
        OnAckTimeoutTimerEvent( NULL );
 800f9f4:	2000      	movs	r0, #0
 800f9f6:	f001 f9bb 	bl	8010d70 <OnAckTimeoutTimerEvent>
    }

    MacCtx.MacFlags.Bits.McpsInd = 1;
 800f9fa:	4b08      	ldr	r3, [pc, #32]	; (800fa1c <PrepareRxDoneAbort+0x4c>)
 800f9fc:	4a09      	ldr	r2, [pc, #36]	; (800fa24 <PrepareRxDoneAbort+0x54>)
 800f9fe:	5c99      	ldrb	r1, [r3, r2]
 800fa00:	2002      	movs	r0, #2
 800fa02:	4301      	orrs	r1, r0
 800fa04:	5499      	strb	r1, [r3, r2]
    MacCtx.MacFlags.Bits.MacDone = 1;
 800fa06:	4b05      	ldr	r3, [pc, #20]	; (800fa1c <PrepareRxDoneAbort+0x4c>)
 800fa08:	4a06      	ldr	r2, [pc, #24]	; (800fa24 <PrepareRxDoneAbort+0x54>)
 800fa0a:	5c99      	ldrb	r1, [r3, r2]
 800fa0c:	2020      	movs	r0, #32
 800fa0e:	4301      	orrs	r1, r0
 800fa10:	5499      	strb	r1, [r3, r2]

    UpdateRxSlotIdleState( );
 800fa12:	f7ff ff15 	bl	800f840 <UpdateRxSlotIdleState>
}
 800fa16:	46c0      	nop			; (mov r8, r8)
 800fa18:	46bd      	mov	sp, r7
 800fa1a:	bd80      	pop	{r7, pc}
 800fa1c:	200008ec 	.word	0x200008ec
 800fa20:	00000414 	.word	0x00000414
 800fa24:	00000481 	.word	0x00000481

0800fa28 <ProcessRadioRxDone>:

static void ProcessRadioRxDone( void )
{
 800fa28:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fa2a:	b0a7      	sub	sp, #156	; 0x9c
 800fa2c:	af04      	add	r7, sp, #16
    LoRaMacHeader_t macHdr;
    ApplyCFListParams_t applyCFList;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;
 800fa2e:	2380      	movs	r3, #128	; 0x80
 800fa30:	18fb      	adds	r3, r7, r3
 800fa32:	2213      	movs	r2, #19
 800fa34:	701a      	strb	r2, [r3, #0]

    LoRaMacMessageData_t macMsgData;
    LoRaMacMessageJoinAccept_t macMsgJoinAccept;
    uint8_t *payload = RxDoneParams.Payload;
 800fa36:	4bdd      	ldr	r3, [pc, #884]	; (800fdac <ProcessRadioRxDone+0x384>)
 800fa38:	685b      	ldr	r3, [r3, #4]
 800fa3a:	67fb      	str	r3, [r7, #124]	; 0x7c
    uint16_t size = RxDoneParams.Size;
 800fa3c:	267a      	movs	r6, #122	; 0x7a
 800fa3e:	19bb      	adds	r3, r7, r6
 800fa40:	4ada      	ldr	r2, [pc, #872]	; (800fdac <ProcessRadioRxDone+0x384>)
 800fa42:	8912      	ldrh	r2, [r2, #8]
 800fa44:	801a      	strh	r2, [r3, #0]
    int16_t rssi = RxDoneParams.Rssi;
 800fa46:	2478      	movs	r4, #120	; 0x78
 800fa48:	193b      	adds	r3, r7, r4
 800fa4a:	4ad8      	ldr	r2, [pc, #864]	; (800fdac <ProcessRadioRxDone+0x384>)
 800fa4c:	8952      	ldrh	r2, [r2, #10]
 800fa4e:	801a      	strh	r2, [r3, #0]
    int8_t snr = RxDoneParams.Snr;
 800fa50:	2577      	movs	r5, #119	; 0x77
 800fa52:	197b      	adds	r3, r7, r5
 800fa54:	4ad5      	ldr	r2, [pc, #852]	; (800fdac <ProcessRadioRxDone+0x384>)
 800fa56:	7b12      	ldrb	r2, [r2, #12]
 800fa58:	701a      	strb	r2, [r3, #0]

    uint8_t pktHeaderLen = 0;
 800fa5a:	2376      	movs	r3, #118	; 0x76
 800fa5c:	18fb      	adds	r3, r7, r3
 800fa5e:	2200      	movs	r2, #0
 800fa60:	701a      	strb	r2, [r3, #0]

    uint32_t downLinkCounter = 0;
 800fa62:	2300      	movs	r3, #0
 800fa64:	60bb      	str	r3, [r7, #8]
    uint32_t address = MacCtx.NvmCtx->DevAddr;
 800fa66:	4bd2      	ldr	r3, [pc, #840]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fa68:	4ad2      	ldr	r2, [pc, #840]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fa6a:	589b      	ldr	r3, [r3, r2]
 800fa6c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800fa6e:	2284      	movs	r2, #132	; 0x84
 800fa70:	18ba      	adds	r2, r7, r2
 800fa72:	6013      	str	r3, [r2, #0]
    uint8_t multicast = 0;
 800fa74:	2383      	movs	r3, #131	; 0x83
 800fa76:	18fb      	adds	r3, r7, r3
 800fa78:	2200      	movs	r2, #0
 800fa7a:	701a      	strb	r2, [r3, #0]
    AddressIdentifier_t addrID = UNICAST_DEV_ADDR;
 800fa7c:	2382      	movs	r3, #130	; 0x82
 800fa7e:	18fb      	adds	r3, r7, r3
 800fa80:	2204      	movs	r2, #4
 800fa82:	701a      	strb	r2, [r3, #0]
    FCntIdentifier_t fCntID;

    MacCtx.McpsConfirm.AckReceived = false;
 800fa84:	4aca      	ldr	r2, [pc, #808]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fa86:	2388      	movs	r3, #136	; 0x88
 800fa88:	00db      	lsls	r3, r3, #3
 800fa8a:	2100      	movs	r1, #0
 800fa8c:	54d1      	strb	r1, [r2, r3]
    MacCtx.McpsIndication.Rssi = rssi;
 800fa8e:	4bc8      	ldr	r3, [pc, #800]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fa90:	193a      	adds	r2, r7, r4
 800fa92:	49c9      	ldr	r1, [pc, #804]	; (800fdb8 <ProcessRadioRxDone+0x390>)
 800fa94:	8812      	ldrh	r2, [r2, #0]
 800fa96:	525a      	strh	r2, [r3, r1]
    MacCtx.McpsIndication.Snr = snr;
 800fa98:	4bc5      	ldr	r3, [pc, #788]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fa9a:	197a      	adds	r2, r7, r5
 800fa9c:	49c7      	ldr	r1, [pc, #796]	; (800fdbc <ProcessRadioRxDone+0x394>)
 800fa9e:	7812      	ldrb	r2, [r2, #0]
 800faa0:	545a      	strb	r2, [r3, r1]
    MacCtx.McpsIndication.RxSlot = MacCtx.RxSlot;
 800faa2:	4ac3      	ldr	r2, [pc, #780]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800faa4:	2390      	movs	r3, #144	; 0x90
 800faa6:	00db      	lsls	r3, r3, #3
 800faa8:	5cd1      	ldrb	r1, [r2, r3]
 800faaa:	4bc1      	ldr	r3, [pc, #772]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800faac:	4ac4      	ldr	r2, [pc, #784]	; (800fdc0 <ProcessRadioRxDone+0x398>)
 800faae:	5499      	strb	r1, [r3, r2]
    MacCtx.McpsIndication.Port = 0;
 800fab0:	4bbf      	ldr	r3, [pc, #764]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fab2:	4ac4      	ldr	r2, [pc, #784]	; (800fdc4 <ProcessRadioRxDone+0x39c>)
 800fab4:	2100      	movs	r1, #0
 800fab6:	5499      	strb	r1, [r3, r2]
    MacCtx.McpsIndication.Multicast = 0;
 800fab8:	4bbd      	ldr	r3, [pc, #756]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800faba:	4ac3      	ldr	r2, [pc, #780]	; (800fdc8 <ProcessRadioRxDone+0x3a0>)
 800fabc:	2100      	movs	r1, #0
 800fabe:	5499      	strb	r1, [r3, r2]
    MacCtx.McpsIndication.FramePending = 0;
 800fac0:	4bbb      	ldr	r3, [pc, #748]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fac2:	4ac2      	ldr	r2, [pc, #776]	; (800fdcc <ProcessRadioRxDone+0x3a4>)
 800fac4:	2100      	movs	r1, #0
 800fac6:	5499      	strb	r1, [r3, r2]
    MacCtx.McpsIndication.Buffer = NULL;
 800fac8:	4bb9      	ldr	r3, [pc, #740]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800faca:	4ac1      	ldr	r2, [pc, #772]	; (800fdd0 <ProcessRadioRxDone+0x3a8>)
 800facc:	2100      	movs	r1, #0
 800face:	5099      	str	r1, [r3, r2]
    MacCtx.McpsIndication.BufferSize = 0;
 800fad0:	4ab7      	ldr	r2, [pc, #732]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fad2:	2385      	movs	r3, #133	; 0x85
 800fad4:	00db      	lsls	r3, r3, #3
 800fad6:	2100      	movs	r1, #0
 800fad8:	54d1      	strb	r1, [r2, r3]
    MacCtx.McpsIndication.RxData = false;
 800fada:	4bb5      	ldr	r3, [pc, #724]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fadc:	4abd      	ldr	r2, [pc, #756]	; (800fdd4 <ProcessRadioRxDone+0x3ac>)
 800fade:	2100      	movs	r1, #0
 800fae0:	5499      	strb	r1, [r3, r2]
    MacCtx.McpsIndication.AckReceived = false;
 800fae2:	4bb3      	ldr	r3, [pc, #716]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fae4:	4abc      	ldr	r2, [pc, #752]	; (800fdd8 <ProcessRadioRxDone+0x3b0>)
 800fae6:	2100      	movs	r1, #0
 800fae8:	5499      	strb	r1, [r3, r2]
    MacCtx.McpsIndication.DownLinkCounter = 0;
 800faea:	4ab1      	ldr	r2, [pc, #708]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800faec:	2386      	movs	r3, #134	; 0x86
 800faee:	00db      	lsls	r3, r3, #3
 800faf0:	2100      	movs	r1, #0
 800faf2:	50d1      	str	r1, [r2, r3]
    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 800faf4:	4bae      	ldr	r3, [pc, #696]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800faf6:	4ab9      	ldr	r2, [pc, #740]	; (800fddc <ProcessRadioRxDone+0x3b4>)
 800faf8:	2100      	movs	r1, #0
 800fafa:	5499      	strb	r1, [r3, r2]
    MacCtx.McpsIndication.DevAddress = 0;
 800fafc:	4bac      	ldr	r3, [pc, #688]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fafe:	4ab8      	ldr	r2, [pc, #736]	; (800fde0 <ProcessRadioRxDone+0x3b8>)
 800fb00:	2100      	movs	r1, #0
 800fb02:	5099      	str	r1, [r3, r2]
    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;
 800fb04:	4aaa      	ldr	r2, [pc, #680]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fb06:	2387      	movs	r3, #135	; 0x87
 800fb08:	00db      	lsls	r3, r3, #3
 800fb0a:	2100      	movs	r1, #0
 800fb0c:	54d1      	strb	r1, [r2, r3]

    Radio.Sleep( );
 800fb0e:	4bb5      	ldr	r3, [pc, #724]	; (800fde4 <ProcessRadioRxDone+0x3bc>)
 800fb10:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800fb12:	4798      	blx	r3
    TimerStop( &MacCtx.RxWindowTimer2 );
 800fb14:	4bb4      	ldr	r3, [pc, #720]	; (800fde8 <ProcessRadioRxDone+0x3c0>)
 800fb16:	0018      	movs	r0, r3
 800fb18:	f00b fa90 	bl	801b03c <TimerStop>

    // This function must be called even if we are not in class b mode yet.
    if( LoRaMacClassBRxBeacon( payload, size ) == true )
 800fb1c:	19bb      	adds	r3, r7, r6
 800fb1e:	881a      	ldrh	r2, [r3, #0]
 800fb20:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800fb22:	0011      	movs	r1, r2
 800fb24:	0018      	movs	r0, r3
 800fb26:	f005 fa7d 	bl	8015024 <LoRaMacClassBRxBeacon>
 800fb2a:	1e03      	subs	r3, r0, #0
 800fb2c:	d00c      	beq.n	800fb48 <ProcessRadioRxDone+0x120>
    {
        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;
 800fb2e:	4ba0      	ldr	r3, [pc, #640]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fb30:	193a      	adds	r2, r7, r4
 800fb32:	49ae      	ldr	r1, [pc, #696]	; (800fdec <ProcessRadioRxDone+0x3c4>)
 800fb34:	8812      	ldrh	r2, [r2, #0]
 800fb36:	525a      	strh	r2, [r3, r1]
        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;
 800fb38:	4a9d      	ldr	r2, [pc, #628]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fb3a:	1979      	adds	r1, r7, r5
 800fb3c:	238f      	movs	r3, #143	; 0x8f
 800fb3e:	00db      	lsls	r3, r3, #3
 800fb40:	7809      	ldrb	r1, [r1, #0]
 800fb42:	54d1      	strb	r1, [r2, r3]
        return;
 800fb44:	f000 fc84 	bl	8010450 <ProcessRadioRxDone+0xa28>
    }
    // Check if we expect a ping or a multicast slot.
    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )
 800fb48:	4b99      	ldr	r3, [pc, #612]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fb4a:	4a9a      	ldr	r2, [pc, #616]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fb4c:	589b      	ldr	r3, [r3, r2]
 800fb4e:	22f0      	movs	r2, #240	; 0xf0
 800fb50:	5c9b      	ldrb	r3, [r3, r2]
 800fb52:	2b01      	cmp	r3, #1
 800fb54:	d11c      	bne.n	800fb90 <ProcessRadioRxDone+0x168>
    {
        if( LoRaMacClassBIsPingExpected( ) == true )
 800fb56:	f005 fa77 	bl	8015048 <LoRaMacClassBIsPingExpected>
 800fb5a:	1e03      	subs	r3, r0, #0
 800fb5c:	d00a      	beq.n	800fb74 <ProcessRadioRxDone+0x14c>
        {
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 800fb5e:	2000      	movs	r0, #0
 800fb60:	f005 fa2e 	bl	8014fc0 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 800fb64:	2000      	movs	r0, #0
 800fb66:	f005 fa4d 	bl	8015004 <LoRaMacClassBPingSlotTimerEvent>
            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;
 800fb6a:	4b91      	ldr	r3, [pc, #580]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fb6c:	4a94      	ldr	r2, [pc, #592]	; (800fdc0 <ProcessRadioRxDone+0x398>)
 800fb6e:	2104      	movs	r1, #4
 800fb70:	5499      	strb	r1, [r3, r2]
 800fb72:	e00d      	b.n	800fb90 <ProcessRadioRxDone+0x168>
        }
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 800fb74:	f005 fa6e 	bl	8015054 <LoRaMacClassBIsMulticastExpected>
 800fb78:	1e03      	subs	r3, r0, #0
 800fb7a:	d009      	beq.n	800fb90 <ProcessRadioRxDone+0x168>
        {
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 800fb7c:	2000      	movs	r0, #0
 800fb7e:	f005 fa29 	bl	8014fd4 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 800fb82:	2000      	movs	r0, #0
 800fb84:	f005 fa46 	bl	8015014 <LoRaMacClassBMulticastSlotTimerEvent>
            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 800fb88:	4b89      	ldr	r3, [pc, #548]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fb8a:	4a8d      	ldr	r2, [pc, #564]	; (800fdc0 <ProcessRadioRxDone+0x398>)
 800fb8c:	2105      	movs	r1, #5
 800fb8e:	5499      	strb	r1, [r3, r2]
        }
    }

    macHdr.Value = payload[pktHeaderLen++];
 800fb90:	2276      	movs	r2, #118	; 0x76
 800fb92:	18bb      	adds	r3, r7, r2
 800fb94:	781b      	ldrb	r3, [r3, #0]
 800fb96:	18ba      	adds	r2, r7, r2
 800fb98:	1c59      	adds	r1, r3, #1
 800fb9a:	7011      	strb	r1, [r2, #0]
 800fb9c:	001a      	movs	r2, r3
 800fb9e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800fba0:	189b      	adds	r3, r3, r2
 800fba2:	781a      	ldrb	r2, [r3, #0]
 800fba4:	2174      	movs	r1, #116	; 0x74
 800fba6:	187b      	adds	r3, r7, r1
 800fba8:	701a      	strb	r2, [r3, #0]

    switch( macHdr.Bits.MType )
 800fbaa:	187b      	adds	r3, r7, r1
 800fbac:	781b      	ldrb	r3, [r3, #0]
 800fbae:	061b      	lsls	r3, r3, #24
 800fbb0:	0f5b      	lsrs	r3, r3, #29
 800fbb2:	b2db      	uxtb	r3, r3
 800fbb4:	2b07      	cmp	r3, #7
 800fbb6:	d101      	bne.n	800fbbc <ProcessRadioRxDone+0x194>
 800fbb8:	f000 fbf2 	bl	80103a0 <ProcessRadioRxDone+0x978>
 800fbbc:	dd01      	ble.n	800fbc2 <ProcessRadioRxDone+0x19a>
 800fbbe:	f000 fc1e 	bl	80103fe <ProcessRadioRxDone+0x9d6>
 800fbc2:	2b05      	cmp	r3, #5
 800fbc4:	d100      	bne.n	800fbc8 <ProcessRadioRxDone+0x1a0>
 800fbc6:	e115      	b.n	800fdf4 <ProcessRadioRxDone+0x3cc>
 800fbc8:	dd01      	ble.n	800fbce <ProcessRadioRxDone+0x1a6>
 800fbca:	f000 fc18 	bl	80103fe <ProcessRadioRxDone+0x9d6>
 800fbce:	2b01      	cmp	r3, #1
 800fbd0:	d004      	beq.n	800fbdc <ProcessRadioRxDone+0x1b4>
 800fbd2:	2b03      	cmp	r3, #3
 800fbd4:	d100      	bne.n	800fbd8 <ProcessRadioRxDone+0x1b0>
 800fbd6:	e111      	b.n	800fdfc <ProcessRadioRxDone+0x3d4>
 800fbd8:	f000 fc11 	bl	80103fe <ProcessRadioRxDone+0x9d6>
    {
        case FRAME_TYPE_JOIN_ACCEPT:
            macMsgJoinAccept.Buffer = payload;
 800fbdc:	210c      	movs	r1, #12
 800fbde:	187b      	adds	r3, r7, r1
 800fbe0:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800fbe2:	601a      	str	r2, [r3, #0]
            macMsgJoinAccept.BufSize = size;
 800fbe4:	237a      	movs	r3, #122	; 0x7a
 800fbe6:	18fb      	adds	r3, r7, r3
 800fbe8:	881b      	ldrh	r3, [r3, #0]
 800fbea:	b2da      	uxtb	r2, r3
 800fbec:	187b      	adds	r3, r7, r1
 800fbee:	711a      	strb	r2, [r3, #4]

            // Abort in case if the device isn't joined yet and no rejoin request is ongoing.
            if( MacCtx.NvmCtx->NetworkActivation != ACTIVATION_TYPE_NONE )
 800fbf0:	4b6f      	ldr	r3, [pc, #444]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fbf2:	4a70      	ldr	r2, [pc, #448]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fbf4:	589a      	ldr	r2, [r3, r2]
 800fbf6:	23ea      	movs	r3, #234	; 0xea
 800fbf8:	005b      	lsls	r3, r3, #1
 800fbfa:	5cd3      	ldrb	r3, [r2, r3]
 800fbfc:	2b00      	cmp	r3, #0
 800fbfe:	d007      	beq.n	800fc10 <ProcessRadioRxDone+0x1e8>
            {
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800fc00:	4b6b      	ldr	r3, [pc, #428]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fc02:	4a7b      	ldr	r2, [pc, #492]	; (800fdf0 <ProcessRadioRxDone+0x3c8>)
 800fc04:	2101      	movs	r1, #1
 800fc06:	5499      	strb	r1, [r3, r2]
                PrepareRxDoneAbort( );
 800fc08:	f7ff fee2 	bl	800f9d0 <PrepareRxDoneAbort>
                return;
 800fc0c:	f000 fc20 	bl	8010450 <ProcessRadioRxDone+0xa28>
            }
            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );
 800fc10:	f7ff fcca 	bl	800f5a8 <SecureElementGetJoinEui>
 800fc14:	0001      	movs	r1, r0
 800fc16:	2680      	movs	r6, #128	; 0x80
 800fc18:	19bc      	adds	r4, r7, r6
 800fc1a:	250c      	movs	r5, #12
 800fc1c:	197b      	adds	r3, r7, r5
 800fc1e:	001a      	movs	r2, r3
 800fc20:	20ff      	movs	r0, #255	; 0xff
 800fc22:	f006 fcf9 	bl	8016618 <LoRaMacCryptoHandleJoinAccept>
 800fc26:	0003      	movs	r3, r0
 800fc28:	7023      	strb	r3, [r4, #0]

            if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus )
 800fc2a:	19bb      	adds	r3, r7, r6
 800fc2c:	781b      	ldrb	r3, [r3, #0]
 800fc2e:	2b00      	cmp	r3, #0
 800fc30:	d000      	beq.n	800fc34 <ProcessRadioRxDone+0x20c>
 800fc32:	e0b0      	b.n	800fd96 <ProcessRadioRxDone+0x36e>
            {
                // Network ID
                MacCtx.NvmCtx->NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];
 800fc34:	002c      	movs	r4, r5
 800fc36:	193b      	adds	r3, r7, r4
 800fc38:	7a59      	ldrb	r1, [r3, #9]
 800fc3a:	4b5d      	ldr	r3, [pc, #372]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fc3c:	4a5d      	ldr	r2, [pc, #372]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fc3e:	589b      	ldr	r3, [r3, r2]
 800fc40:	000a      	movs	r2, r1
 800fc42:	649a      	str	r2, [r3, #72]	; 0x48
                MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );
 800fc44:	4b5a      	ldr	r3, [pc, #360]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fc46:	4a5b      	ldr	r2, [pc, #364]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fc48:	589b      	ldr	r3, [r3, r2]
 800fc4a:	6c99      	ldr	r1, [r3, #72]	; 0x48
 800fc4c:	193b      	adds	r3, r7, r4
 800fc4e:	7a9b      	ldrb	r3, [r3, #10]
 800fc50:	021a      	lsls	r2, r3, #8
 800fc52:	4b57      	ldr	r3, [pc, #348]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fc54:	4857      	ldr	r0, [pc, #348]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fc56:	581b      	ldr	r3, [r3, r0]
 800fc58:	430a      	orrs	r2, r1
 800fc5a:	649a      	str	r2, [r3, #72]	; 0x48
                MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 800fc5c:	4b54      	ldr	r3, [pc, #336]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fc5e:	4a55      	ldr	r2, [pc, #340]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fc60:	589b      	ldr	r3, [r3, r2]
 800fc62:	6c99      	ldr	r1, [r3, #72]	; 0x48
 800fc64:	193b      	adds	r3, r7, r4
 800fc66:	7adb      	ldrb	r3, [r3, #11]
 800fc68:	041a      	lsls	r2, r3, #16
 800fc6a:	4b51      	ldr	r3, [pc, #324]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fc6c:	4851      	ldr	r0, [pc, #324]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fc6e:	581b      	ldr	r3, [r3, r0]
 800fc70:	430a      	orrs	r2, r1
 800fc72:	649a      	str	r2, [r3, #72]	; 0x48

                // Device Address
                MacCtx.NvmCtx->DevAddr = macMsgJoinAccept.DevAddr;
 800fc74:	4b4e      	ldr	r3, [pc, #312]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fc76:	4a4f      	ldr	r2, [pc, #316]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fc78:	589b      	ldr	r3, [r3, r2]
 800fc7a:	0020      	movs	r0, r4
 800fc7c:	183a      	adds	r2, r7, r0
 800fc7e:	68d2      	ldr	r2, [r2, #12]
 800fc80:	64da      	str	r2, [r3, #76]	; 0x4c

                // DLSettings
                MacCtx.NvmCtx->MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 800fc82:	183b      	adds	r3, r7, r0
 800fc84:	7c1b      	ldrb	r3, [r3, #16]
 800fc86:	065b      	lsls	r3, r3, #25
 800fc88:	0f5b      	lsrs	r3, r3, #29
 800fc8a:	b2d9      	uxtb	r1, r3
 800fc8c:	4b48      	ldr	r3, [pc, #288]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fc8e:	4a49      	ldr	r2, [pc, #292]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fc90:	589a      	ldr	r2, [r3, r2]
 800fc92:	231a      	movs	r3, #26
 800fc94:	33ff      	adds	r3, #255	; 0xff
 800fc96:	54d1      	strb	r1, [r2, r3]
                MacCtx.NvmCtx->MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 800fc98:	183b      	adds	r3, r7, r0
 800fc9a:	7c1b      	ldrb	r3, [r3, #16]
 800fc9c:	071b      	lsls	r3, r3, #28
 800fc9e:	0f1b      	lsrs	r3, r3, #28
 800fca0:	b2d9      	uxtb	r1, r3
 800fca2:	4b43      	ldr	r3, [pc, #268]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fca4:	4a43      	ldr	r2, [pc, #268]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fca6:	589a      	ldr	r2, [r3, r2]
 800fca8:	2390      	movs	r3, #144	; 0x90
 800fcaa:	005b      	lsls	r3, r3, #1
 800fcac:	54d1      	strb	r1, [r2, r3]
                MacCtx.NvmCtx->MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 800fcae:	183b      	adds	r3, r7, r0
 800fcb0:	7c1b      	ldrb	r3, [r3, #16]
 800fcb2:	071b      	lsls	r3, r3, #28
 800fcb4:	0f1b      	lsrs	r3, r3, #28
 800fcb6:	b2d9      	uxtb	r1, r3
 800fcb8:	4b3d      	ldr	r3, [pc, #244]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fcba:	4a3e      	ldr	r2, [pc, #248]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fcbc:	589a      	ldr	r2, [r3, r2]
 800fcbe:	2394      	movs	r3, #148	; 0x94
 800fcc0:	005b      	lsls	r3, r3, #1
 800fcc2:	54d1      	strb	r1, [r2, r3]

                // RxDelay
                MacCtx.NvmCtx->MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;
 800fcc4:	183b      	adds	r3, r7, r0
 800fcc6:	7c59      	ldrb	r1, [r3, #17]
 800fcc8:	4b39      	ldr	r3, [pc, #228]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fcca:	4a3a      	ldr	r2, [pc, #232]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fccc:	589a      	ldr	r2, [r3, r2]
 800fcce:	2384      	movs	r3, #132	; 0x84
 800fcd0:	005b      	lsls	r3, r3, #1
 800fcd2:	50d1      	str	r1, [r2, r3]
                if( MacCtx.NvmCtx->MacParams.ReceiveDelay1 == 0 )
 800fcd4:	4b36      	ldr	r3, [pc, #216]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fcd6:	4a37      	ldr	r2, [pc, #220]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fcd8:	589a      	ldr	r2, [r3, r2]
 800fcda:	2384      	movs	r3, #132	; 0x84
 800fcdc:	005b      	lsls	r3, r3, #1
 800fcde:	58d3      	ldr	r3, [r2, r3]
 800fce0:	2b00      	cmp	r3, #0
 800fce2:	d106      	bne.n	800fcf2 <ProcessRadioRxDone+0x2ca>
                {
                    MacCtx.NvmCtx->MacParams.ReceiveDelay1 = 1;
 800fce4:	4b32      	ldr	r3, [pc, #200]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fce6:	4a33      	ldr	r2, [pc, #204]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fce8:	589a      	ldr	r2, [r3, r2]
 800fcea:	2384      	movs	r3, #132	; 0x84
 800fcec:	005b      	lsls	r3, r3, #1
 800fcee:	2101      	movs	r1, #1
 800fcf0:	50d1      	str	r1, [r2, r3]
                }
                MacCtx.NvmCtx->MacParams.ReceiveDelay1 *= 1000;
 800fcf2:	4b2f      	ldr	r3, [pc, #188]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fcf4:	4a2f      	ldr	r2, [pc, #188]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fcf6:	589a      	ldr	r2, [r3, r2]
 800fcf8:	2384      	movs	r3, #132	; 0x84
 800fcfa:	005b      	lsls	r3, r3, #1
 800fcfc:	58d2      	ldr	r2, [r2, r3]
 800fcfe:	4b2c      	ldr	r3, [pc, #176]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fd00:	492c      	ldr	r1, [pc, #176]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fd02:	5859      	ldr	r1, [r3, r1]
 800fd04:	0013      	movs	r3, r2
 800fd06:	015b      	lsls	r3, r3, #5
 800fd08:	1a9b      	subs	r3, r3, r2
 800fd0a:	009b      	lsls	r3, r3, #2
 800fd0c:	189b      	adds	r3, r3, r2
 800fd0e:	00db      	lsls	r3, r3, #3
 800fd10:	001a      	movs	r2, r3
 800fd12:	2384      	movs	r3, #132	; 0x84
 800fd14:	005b      	lsls	r3, r3, #1
 800fd16:	50ca      	str	r2, [r1, r3]
                MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + 1000;
 800fd18:	4b25      	ldr	r3, [pc, #148]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fd1a:	4a26      	ldr	r2, [pc, #152]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fd1c:	589a      	ldr	r2, [r3, r2]
 800fd1e:	2384      	movs	r3, #132	; 0x84
 800fd20:	005b      	lsls	r3, r3, #1
 800fd22:	58d3      	ldr	r3, [r2, r3]
 800fd24:	4a22      	ldr	r2, [pc, #136]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fd26:	4923      	ldr	r1, [pc, #140]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fd28:	5852      	ldr	r2, [r2, r1]
 800fd2a:	21fa      	movs	r1, #250	; 0xfa
 800fd2c:	0089      	lsls	r1, r1, #2
 800fd2e:	1859      	adds	r1, r3, r1
 800fd30:	2386      	movs	r3, #134	; 0x86
 800fd32:	005b      	lsls	r3, r3, #1
 800fd34:	50d1      	str	r1, [r2, r3]

                MacCtx.NvmCtx->Version.Fields.Minor = 0;
 800fd36:	4b1e      	ldr	r3, [pc, #120]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fd38:	4a1e      	ldr	r2, [pc, #120]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fd3a:	589a      	ldr	r2, [r3, r2]
 800fd3c:	23e9      	movs	r3, #233	; 0xe9
 800fd3e:	005b      	lsls	r3, r3, #1
 800fd40:	2100      	movs	r1, #0
 800fd42:	54d1      	strb	r1, [r2, r3]

                // Apply CF list
                applyCFList.Payload = macMsgJoinAccept.CFList;
 800fd44:	216c      	movs	r1, #108	; 0x6c
 800fd46:	187b      	adds	r3, r7, r1
 800fd48:	220c      	movs	r2, #12
 800fd4a:	18ba      	adds	r2, r7, r2
 800fd4c:	3212      	adds	r2, #18
 800fd4e:	601a      	str	r2, [r3, #0]
                // Size of the regular payload is 12. Plus 1 byte MHDR and 4 bytes MIC
                applyCFList.Size = size - 17;
 800fd50:	237a      	movs	r3, #122	; 0x7a
 800fd52:	18fb      	adds	r3, r7, r3
 800fd54:	881b      	ldrh	r3, [r3, #0]
 800fd56:	b2db      	uxtb	r3, r3
 800fd58:	3b11      	subs	r3, #17
 800fd5a:	b2da      	uxtb	r2, r3
 800fd5c:	187b      	adds	r3, r7, r1
 800fd5e:	711a      	strb	r2, [r3, #4]

                RegionApplyCFList( MacCtx.NvmCtx->Region, &applyCFList );
 800fd60:	4b13      	ldr	r3, [pc, #76]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fd62:	4a14      	ldr	r2, [pc, #80]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fd64:	589b      	ldr	r3, [r3, r2]
 800fd66:	781b      	ldrb	r3, [r3, #0]
 800fd68:	187a      	adds	r2, r7, r1
 800fd6a:	0011      	movs	r1, r2
 800fd6c:	0018      	movs	r0, r3
 800fd6e:	f007 fc5a 	bl	8017626 <RegionApplyCFList>

                MacCtx.NvmCtx->NetworkActivation = ACTIVATION_TYPE_OTAA;
 800fd72:	4b0f      	ldr	r3, [pc, #60]	; (800fdb0 <ProcessRadioRxDone+0x388>)
 800fd74:	4a0f      	ldr	r2, [pc, #60]	; (800fdb4 <ProcessRadioRxDone+0x38c>)
 800fd76:	589a      	ldr	r2, [r3, r2]
 800fd78:	23ea      	movs	r3, #234	; 0xea
 800fd7a:	005b      	lsls	r3, r3, #1
 800fd7c:	2102      	movs	r1, #2
 800fd7e:	54d1      	strb	r1, [r2, r3]

                // MLME handling
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 800fd80:	2000      	movs	r0, #0
 800fd82:	f005 fe17 	bl	80159b4 <LoRaMacConfirmQueueIsCmdActive>
 800fd86:	1e03      	subs	r3, r0, #0
 800fd88:	d100      	bne.n	800fd8c <ProcessRadioRxDone+0x364>
 800fd8a:	e33f      	b.n	801040c <ProcessRadioRxDone+0x9e4>
                {
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN );
 800fd8c:	2100      	movs	r1, #0
 800fd8e:	2000      	movs	r0, #0
 800fd90:	f005 fd8c 	bl	80158ac <LoRaMacConfirmQueueSetStatus>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
                {
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
                }
            }
            break;
 800fd94:	e33a      	b.n	801040c <ProcessRadioRxDone+0x9e4>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 800fd96:	2000      	movs	r0, #0
 800fd98:	f005 fe0c 	bl	80159b4 <LoRaMacConfirmQueueIsCmdActive>
 800fd9c:	1e03      	subs	r3, r0, #0
 800fd9e:	d100      	bne.n	800fda2 <ProcessRadioRxDone+0x37a>
 800fda0:	e334      	b.n	801040c <ProcessRadioRxDone+0x9e4>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 800fda2:	2100      	movs	r1, #0
 800fda4:	2007      	movs	r0, #7
 800fda6:	f005 fd81 	bl	80158ac <LoRaMacConfirmQueueSetStatus>
            break;
 800fdaa:	e32f      	b.n	801040c <ProcessRadioRxDone+0x9e4>
 800fdac:	200017e4 	.word	0x200017e4
 800fdb0:	200008ec 	.word	0x200008ec
 800fdb4:	00000484 	.word	0x00000484
 800fdb8:	0000042a 	.word	0x0000042a
 800fdbc:	0000042c 	.word	0x0000042c
 800fdc0:	0000042d 	.word	0x0000042d
 800fdc4:	0000041f 	.word	0x0000041f
 800fdc8:	0000041e 	.word	0x0000041e
 800fdcc:	00000421 	.word	0x00000421
 800fdd0:	00000424 	.word	0x00000424
 800fdd4:	00000429 	.word	0x00000429
 800fdd8:	0000042e 	.word	0x0000042e
 800fddc:	0000041c 	.word	0x0000041c
 800fde0:	00000434 	.word	0x00000434
 800fde4:	0801ebd0 	.word	0x0801ebd0
 800fde8:	20000c84 	.word	0x20000c84
 800fdec:	00000476 	.word	0x00000476
 800fdf0:	0000041d 	.word	0x0000041d
        case FRAME_TYPE_DATA_CONFIRMED_DOWN:
            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 800fdf4:	4bca      	ldr	r3, [pc, #808]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800fdf6:	4acb      	ldr	r2, [pc, #812]	; (8010124 <ProcessRadioRxDone+0x6fc>)
 800fdf8:	2101      	movs	r1, #1
 800fdfa:	5499      	strb	r1, [r3, r2]
            // Intentional fall through
        case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:
            // Check if the received payload size is valid
            getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;
 800fdfc:	4bc8      	ldr	r3, [pc, #800]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800fdfe:	4aca      	ldr	r2, [pc, #808]	; (8010128 <ProcessRadioRxDone+0x700>)
 800fe00:	589a      	ldr	r2, [r3, r2]
 800fe02:	232e      	movs	r3, #46	; 0x2e
 800fe04:	33ff      	adds	r3, #255	; 0xff
 800fe06:	5cd2      	ldrb	r2, [r2, r3]
 800fe08:	2168      	movs	r1, #104	; 0x68
 800fe0a:	187b      	adds	r3, r7, r1
 800fe0c:	709a      	strb	r2, [r3, #2]
            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;
 800fe0e:	4ac4      	ldr	r2, [pc, #784]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800fe10:	2384      	movs	r3, #132	; 0x84
 800fe12:	00db      	lsls	r3, r3, #3
 800fe14:	5cd3      	ldrb	r3, [r2, r3]
 800fe16:	b25a      	sxtb	r2, r3
 800fe18:	187b      	adds	r3, r7, r1
 800fe1a:	705a      	strb	r2, [r3, #1]
            getPhy.Attribute = PHY_MAX_PAYLOAD;
 800fe1c:	187b      	adds	r3, r7, r1
 800fe1e:	220d      	movs	r2, #13
 800fe20:	701a      	strb	r2, [r3, #0]

            // Get the maximum payload length
            if( MacCtx.NvmCtx->RepeaterSupport == true )
 800fe22:	4bbf      	ldr	r3, [pc, #764]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800fe24:	4ac0      	ldr	r2, [pc, #768]	; (8010128 <ProcessRadioRxDone+0x700>)
 800fe26:	589a      	ldr	r2, [r3, r2]
 800fe28:	2340      	movs	r3, #64	; 0x40
 800fe2a:	33ff      	adds	r3, #255	; 0xff
 800fe2c:	5cd3      	ldrb	r3, [r2, r3]
 800fe2e:	2b00      	cmp	r3, #0
 800fe30:	d002      	beq.n	800fe38 <ProcessRadioRxDone+0x410>
            {
                getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 800fe32:	187b      	adds	r3, r7, r1
 800fe34:	220e      	movs	r2, #14
 800fe36:	701a      	strb	r2, [r3, #0]
            }
            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 800fe38:	4bb9      	ldr	r3, [pc, #740]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800fe3a:	4abb      	ldr	r2, [pc, #748]	; (8010128 <ProcessRadioRxDone+0x700>)
 800fe3c:	589b      	ldr	r3, [r3, r2]
 800fe3e:	781b      	ldrb	r3, [r3, #0]
 800fe40:	2268      	movs	r2, #104	; 0x68
 800fe42:	18ba      	adds	r2, r7, r2
 800fe44:	0011      	movs	r1, r2
 800fe46:	0018      	movs	r0, r3
 800fe48:	f007 fb69 	bl	801751e <RegionGetPhyParam>
 800fe4c:	0003      	movs	r3, r0
 800fe4e:	001a      	movs	r2, r3
 800fe50:	2364      	movs	r3, #100	; 0x64
 800fe52:	18fb      	adds	r3, r7, r3
 800fe54:	601a      	str	r2, [r3, #0]
            if( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORA_MAC_FRMPAYLOAD_OVERHEAD ) ) > ( int16_t )phyParam.Value )
 800fe56:	237a      	movs	r3, #122	; 0x7a
 800fe58:	18fb      	adds	r3, r7, r3
 800fe5a:	881b      	ldrh	r3, [r3, #0]
 800fe5c:	3b0d      	subs	r3, #13
 800fe5e:	b29b      	uxth	r3, r3
 800fe60:	b21b      	sxth	r3, r3
 800fe62:	1c1a      	adds	r2, r3, #0
 800fe64:	b213      	sxth	r3, r2
 800fe66:	2b00      	cmp	r3, #0
 800fe68:	da01      	bge.n	800fe6e <ProcessRadioRxDone+0x446>
 800fe6a:	2300      	movs	r3, #0
 800fe6c:	1c1a      	adds	r2, r3, #0
 800fe6e:	b212      	sxth	r2, r2
 800fe70:	2364      	movs	r3, #100	; 0x64
 800fe72:	18fb      	adds	r3, r7, r3
 800fe74:	681b      	ldr	r3, [r3, #0]
 800fe76:	b21b      	sxth	r3, r3
 800fe78:	429a      	cmp	r2, r3
 800fe7a:	dd06      	ble.n	800fe8a <ProcessRadioRxDone+0x462>
            {
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800fe7c:	4ba8      	ldr	r3, [pc, #672]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800fe7e:	4aab      	ldr	r2, [pc, #684]	; (801012c <ProcessRadioRxDone+0x704>)
 800fe80:	2101      	movs	r1, #1
 800fe82:	5499      	strb	r1, [r3, r2]
                PrepareRxDoneAbort( );
 800fe84:	f7ff fda4 	bl	800f9d0 <PrepareRxDoneAbort>
                return;
 800fe88:	e2e2      	b.n	8010450 <ProcessRadioRxDone+0xa28>
            }
            macMsgData.Buffer = payload;
 800fe8a:	2134      	movs	r1, #52	; 0x34
 800fe8c:	187b      	adds	r3, r7, r1
 800fe8e:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800fe90:	601a      	str	r2, [r3, #0]
            macMsgData.BufSize = size;
 800fe92:	237a      	movs	r3, #122	; 0x7a
 800fe94:	18fb      	adds	r3, r7, r3
 800fe96:	881b      	ldrh	r3, [r3, #0]
 800fe98:	b2da      	uxtb	r2, r3
 800fe9a:	187b      	adds	r3, r7, r1
 800fe9c:	711a      	strb	r2, [r3, #4]
            macMsgData.FRMPayload = MacCtx.RxPayload;
 800fe9e:	187b      	adds	r3, r7, r1
 800fea0:	4aa3      	ldr	r2, [pc, #652]	; (8010130 <ProcessRadioRxDone+0x708>)
 800fea2:	625a      	str	r2, [r3, #36]	; 0x24
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 800fea4:	0008      	movs	r0, r1
 800fea6:	187b      	adds	r3, r7, r1
 800fea8:	2228      	movs	r2, #40	; 0x28
 800feaa:	21ff      	movs	r1, #255	; 0xff
 800feac:	5499      	strb	r1, [r3, r2]

            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 800feae:	183b      	adds	r3, r7, r0
 800feb0:	0018      	movs	r0, r3
 800feb2:	f007 f84d 	bl	8016f50 <LoRaMacParserData>
 800feb6:	1e03      	subs	r3, r0, #0
 800feb8:	d006      	beq.n	800fec8 <ProcessRadioRxDone+0x4a0>
            {
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800feba:	4b99      	ldr	r3, [pc, #612]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800febc:	4a9b      	ldr	r2, [pc, #620]	; (801012c <ProcessRadioRxDone+0x704>)
 800febe:	2101      	movs	r1, #1
 800fec0:	5499      	strb	r1, [r3, r2]
                PrepareRxDoneAbort( );
 800fec2:	f7ff fd85 	bl	800f9d0 <PrepareRxDoneAbort>
                return;
 800fec6:	e2c3      	b.n	8010450 <ProcessRadioRxDone+0xa28>
            }

            // Store device address
            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;
 800fec8:	2034      	movs	r0, #52	; 0x34
 800feca:	183b      	adds	r3, r7, r0
 800fecc:	689a      	ldr	r2, [r3, #8]
 800fece:	4b94      	ldr	r3, [pc, #592]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800fed0:	4998      	ldr	r1, [pc, #608]	; (8010134 <ProcessRadioRxDone+0x70c>)
 800fed2:	505a      	str	r2, [r3, r1]

            FType_t fType;
            if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) )
 800fed4:	1dba      	adds	r2, r7, #6
 800fed6:	183b      	adds	r3, r7, r0
 800fed8:	0011      	movs	r1, r2
 800feda:	0018      	movs	r0, r3
 800fedc:	f002 fff2 	bl	8012ec4 <DetermineFrameType>
 800fee0:	1e03      	subs	r3, r0, #0
 800fee2:	d006      	beq.n	800fef2 <ProcessRadioRxDone+0x4ca>
            {
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800fee4:	4b8e      	ldr	r3, [pc, #568]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800fee6:	4a91      	ldr	r2, [pc, #580]	; (801012c <ProcessRadioRxDone+0x704>)
 800fee8:	2101      	movs	r1, #1
 800feea:	5499      	strb	r1, [r3, r2]
                PrepareRxDoneAbort( );
 800feec:	f7ff fd70 	bl	800f9d0 <PrepareRxDoneAbort>
                return;
 800fef0:	e2ae      	b.n	8010450 <ProcessRadioRxDone+0xa28>
            }

            //Check if it is a multicast message
            multicast = 0;
 800fef2:	2383      	movs	r3, #131	; 0x83
 800fef4:	18fb      	adds	r3, r7, r3
 800fef6:	2200      	movs	r2, #0
 800fef8:	701a      	strb	r2, [r3, #0]
            downLinkCounter = 0;
 800fefa:	2300      	movs	r3, #0
 800fefc:	60bb      	str	r3, [r7, #8]
            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 800fefe:	2381      	movs	r3, #129	; 0x81
 800ff00:	18fb      	adds	r3, r7, r3
 800ff02:	2200      	movs	r2, #0
 800ff04:	701a      	strb	r2, [r3, #0]
 800ff06:	e065      	b.n	800ffd4 <ProcessRadioRxDone+0x5ac>
            {
                if( ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 800ff08:	4b85      	ldr	r3, [pc, #532]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800ff0a:	4a87      	ldr	r2, [pc, #540]	; (8010128 <ProcessRadioRxDone+0x700>)
 800ff0c:	5899      	ldr	r1, [r3, r2]
 800ff0e:	2481      	movs	r4, #129	; 0x81
 800ff10:	193b      	adds	r3, r7, r4
 800ff12:	781a      	ldrb	r2, [r3, #0]
 800ff14:	0013      	movs	r3, r2
 800ff16:	009b      	lsls	r3, r3, #2
 800ff18:	189b      	adds	r3, r3, r2
 800ff1a:	00db      	lsls	r3, r3, #3
 800ff1c:	18cb      	adds	r3, r1, r3
 800ff1e:	3354      	adds	r3, #84	; 0x54
 800ff20:	681a      	ldr	r2, [r3, #0]
 800ff22:	2334      	movs	r3, #52	; 0x34
 800ff24:	18fb      	adds	r3, r7, r3
 800ff26:	689b      	ldr	r3, [r3, #8]
 800ff28:	429a      	cmp	r2, r3
 800ff2a:	d14d      	bne.n	800ffc8 <ProcessRadioRxDone+0x5a0>
                    ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.IsEnabled == true ) )
 800ff2c:	4b7c      	ldr	r3, [pc, #496]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800ff2e:	4a7e      	ldr	r2, [pc, #504]	; (8010128 <ProcessRadioRxDone+0x700>)
 800ff30:	5899      	ldr	r1, [r3, r2]
 800ff32:	193b      	adds	r3, r7, r4
 800ff34:	781a      	ldrb	r2, [r3, #0]
 800ff36:	2051      	movs	r0, #81	; 0x51
 800ff38:	0013      	movs	r3, r2
 800ff3a:	009b      	lsls	r3, r3, #2
 800ff3c:	189b      	adds	r3, r3, r2
 800ff3e:	00db      	lsls	r3, r3, #3
 800ff40:	18cb      	adds	r3, r1, r3
 800ff42:	181b      	adds	r3, r3, r0
 800ff44:	781b      	ldrb	r3, [r3, #0]
                if( ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 800ff46:	2b00      	cmp	r3, #0
 800ff48:	d03e      	beq.n	800ffc8 <ProcessRadioRxDone+0x5a0>
                {
                    multicast = 1;
 800ff4a:	2383      	movs	r3, #131	; 0x83
 800ff4c:	18fb      	adds	r3, r7, r3
 800ff4e:	2201      	movs	r2, #1
 800ff50:	701a      	strb	r2, [r3, #0]
                    addrID = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.GroupID;
 800ff52:	4b73      	ldr	r3, [pc, #460]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800ff54:	4a74      	ldr	r2, [pc, #464]	; (8010128 <ProcessRadioRxDone+0x700>)
 800ff56:	5898      	ldr	r0, [r3, r2]
 800ff58:	0025      	movs	r5, r4
 800ff5a:	193b      	adds	r3, r7, r4
 800ff5c:	781a      	ldrb	r2, [r3, #0]
 800ff5e:	2382      	movs	r3, #130	; 0x82
 800ff60:	18f9      	adds	r1, r7, r3
 800ff62:	2452      	movs	r4, #82	; 0x52
 800ff64:	0013      	movs	r3, r2
 800ff66:	009b      	lsls	r3, r3, #2
 800ff68:	189b      	adds	r3, r3, r2
 800ff6a:	00db      	lsls	r3, r3, #3
 800ff6c:	18c3      	adds	r3, r0, r3
 800ff6e:	191b      	adds	r3, r3, r4
 800ff70:	781b      	ldrb	r3, [r3, #0]
 800ff72:	700b      	strb	r3, [r1, #0]
                    downLinkCounter = *( MacCtx.NvmCtx->MulticastChannelList[i].DownLinkCounter );
 800ff74:	4b6a      	ldr	r3, [pc, #424]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800ff76:	4a6c      	ldr	r2, [pc, #432]	; (8010128 <ProcessRadioRxDone+0x700>)
 800ff78:	5899      	ldr	r1, [r3, r2]
 800ff7a:	002c      	movs	r4, r5
 800ff7c:	193b      	adds	r3, r7, r4
 800ff7e:	781a      	ldrb	r2, [r3, #0]
 800ff80:	0013      	movs	r3, r2
 800ff82:	009b      	lsls	r3, r3, #2
 800ff84:	189b      	adds	r3, r3, r2
 800ff86:	00db      	lsls	r3, r3, #3
 800ff88:	18cb      	adds	r3, r1, r3
 800ff8a:	336c      	adds	r3, #108	; 0x6c
 800ff8c:	681b      	ldr	r3, [r3, #0]
 800ff8e:	681b      	ldr	r3, [r3, #0]
 800ff90:	60bb      	str	r3, [r7, #8]
                    address = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address;
 800ff92:	4b63      	ldr	r3, [pc, #396]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800ff94:	4a64      	ldr	r2, [pc, #400]	; (8010128 <ProcessRadioRxDone+0x700>)
 800ff96:	5899      	ldr	r1, [r3, r2]
 800ff98:	193b      	adds	r3, r7, r4
 800ff9a:	781a      	ldrb	r2, [r3, #0]
 800ff9c:	0013      	movs	r3, r2
 800ff9e:	009b      	lsls	r3, r3, #2
 800ffa0:	189b      	adds	r3, r3, r2
 800ffa2:	00db      	lsls	r3, r3, #3
 800ffa4:	18cb      	adds	r3, r1, r3
 800ffa6:	3354      	adds	r3, #84	; 0x54
 800ffa8:	681b      	ldr	r3, [r3, #0]
 800ffaa:	2284      	movs	r2, #132	; 0x84
 800ffac:	18ba      	adds	r2, r7, r2
 800ffae:	6013      	str	r3, [r2, #0]
                    if( MacCtx.NvmCtx->DeviceClass == CLASS_C )
 800ffb0:	4b5b      	ldr	r3, [pc, #364]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800ffb2:	4a5d      	ldr	r2, [pc, #372]	; (8010128 <ProcessRadioRxDone+0x700>)
 800ffb4:	589b      	ldr	r3, [r3, r2]
 800ffb6:	22f0      	movs	r2, #240	; 0xf0
 800ffb8:	5c9b      	ldrb	r3, [r3, r2]
 800ffba:	2b02      	cmp	r3, #2
 800ffbc:	d110      	bne.n	800ffe0 <ProcessRadioRxDone+0x5b8>
                    {
                        MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 800ffbe:	4b58      	ldr	r3, [pc, #352]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800ffc0:	4a5d      	ldr	r2, [pc, #372]	; (8010138 <ProcessRadioRxDone+0x710>)
 800ffc2:	2103      	movs	r1, #3
 800ffc4:	5499      	strb	r1, [r3, r2]
                    }
                    break;
 800ffc6:	e00b      	b.n	800ffe0 <ProcessRadioRxDone+0x5b8>
            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 800ffc8:	2181      	movs	r1, #129	; 0x81
 800ffca:	187b      	adds	r3, r7, r1
 800ffcc:	781a      	ldrb	r2, [r3, #0]
 800ffce:	187b      	adds	r3, r7, r1
 800ffd0:	3201      	adds	r2, #1
 800ffd2:	701a      	strb	r2, [r3, #0]
 800ffd4:	2381      	movs	r3, #129	; 0x81
 800ffd6:	18fb      	adds	r3, r7, r3
 800ffd8:	781b      	ldrb	r3, [r3, #0]
 800ffda:	2b03      	cmp	r3, #3
 800ffdc:	d994      	bls.n	800ff08 <ProcessRadioRxDone+0x4e0>
 800ffde:	e000      	b.n	800ffe2 <ProcessRadioRxDone+0x5ba>
                    break;
 800ffe0:	46c0      	nop			; (mov r8, r8)
                }
            }

            // Get maximum allowed counter difference
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 800ffe2:	2168      	movs	r1, #104	; 0x68
 800ffe4:	187b      	adds	r3, r7, r1
 800ffe6:	2215      	movs	r2, #21
 800ffe8:	701a      	strb	r2, [r3, #0]
            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 800ffea:	4b4d      	ldr	r3, [pc, #308]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 800ffec:	4a4e      	ldr	r2, [pc, #312]	; (8010128 <ProcessRadioRxDone+0x700>)
 800ffee:	589b      	ldr	r3, [r3, r2]
 800fff0:	781b      	ldrb	r3, [r3, #0]
 800fff2:	187a      	adds	r2, r7, r1
 800fff4:	0011      	movs	r1, r2
 800fff6:	0018      	movs	r0, r3
 800fff8:	f007 fa91 	bl	801751e <RegionGetPhyParam>
 800fffc:	0003      	movs	r3, r0
 800fffe:	001a      	movs	r2, r3
 8010000:	2064      	movs	r0, #100	; 0x64
 8010002:	183b      	adds	r3, r7, r0
 8010004:	601a      	str	r2, [r3, #0]

            // Get downlink frame counter value
            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, MacCtx.NvmCtx->Version, phyParam.Value, &fCntID, &downLinkCounter );
 8010006:	1dbb      	adds	r3, r7, #6
 8010008:	781d      	ldrb	r5, [r3, #0]
 801000a:	4b45      	ldr	r3, [pc, #276]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 801000c:	4a46      	ldr	r2, [pc, #280]	; (8010128 <ProcessRadioRxDone+0x700>)
 801000e:	5899      	ldr	r1, [r3, r2]
 8010010:	183b      	adds	r3, r7, r0
 8010012:	681b      	ldr	r3, [r3, #0]
 8010014:	b29b      	uxth	r3, r3
 8010016:	2280      	movs	r2, #128	; 0x80
 8010018:	18bc      	adds	r4, r7, r2
 801001a:	22e8      	movs	r2, #232	; 0xe8
 801001c:	0052      	lsls	r2, r2, #1
 801001e:	588e      	ldr	r6, [r1, r2]
 8010020:	2134      	movs	r1, #52	; 0x34
 8010022:	1879      	adds	r1, r7, r1
 8010024:	2082      	movs	r0, #130	; 0x82
 8010026:	183a      	adds	r2, r7, r0
 8010028:	7810      	ldrb	r0, [r2, #0]
 801002a:	2208      	movs	r2, #8
 801002c:	18ba      	adds	r2, r7, r2
 801002e:	9202      	str	r2, [sp, #8]
 8010030:	1dfa      	adds	r2, r7, #7
 8010032:	9201      	str	r2, [sp, #4]
 8010034:	9300      	str	r3, [sp, #0]
 8010036:	0033      	movs	r3, r6
 8010038:	000a      	movs	r2, r1
 801003a:	0029      	movs	r1, r5
 801003c:	f000 feda 	bl	8010df4 <GetFCntDown>
 8010040:	0003      	movs	r3, r0
 8010042:	7023      	strb	r3, [r4, #0]
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8010044:	2280      	movs	r2, #128	; 0x80
 8010046:	18bb      	adds	r3, r7, r2
 8010048:	781b      	ldrb	r3, [r3, #0]
 801004a:	2b00      	cmp	r3, #0
 801004c:	d040      	beq.n	80100d0 <ProcessRadioRxDone+0x6a8>
            {
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )
 801004e:	18bb      	adds	r3, r7, r2
 8010050:	781b      	ldrb	r3, [r3, #0]
 8010052:	2b07      	cmp	r3, #7
 8010054:	d126      	bne.n	80100a4 <ProcessRadioRxDone+0x67c>
                {
                    // Catch the case of repeated downlink frame counter
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;
 8010056:	4b32      	ldr	r3, [pc, #200]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 8010058:	4a34      	ldr	r2, [pc, #208]	; (801012c <ProcessRadioRxDone+0x704>)
 801005a:	2108      	movs	r1, #8
 801005c:	5499      	strb	r1, [r3, r2]
                    if( ( MacCtx.NvmCtx->Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( MacCtx.NvmCtx->LastRxMic == macMsgData.MIC ) )
 801005e:	4b30      	ldr	r3, [pc, #192]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 8010060:	4a31      	ldr	r2, [pc, #196]	; (8010128 <ProcessRadioRxDone+0x700>)
 8010062:	589a      	ldr	r2, [r3, r2]
 8010064:	23e9      	movs	r3, #233	; 0xe9
 8010066:	005b      	lsls	r3, r3, #1
 8010068:	5cd3      	ldrb	r3, [r2, r3]
 801006a:	2b00      	cmp	r3, #0
 801006c:	d128      	bne.n	80100c0 <ProcessRadioRxDone+0x698>
 801006e:	2374      	movs	r3, #116	; 0x74
 8010070:	18fb      	adds	r3, r7, r3
 8010072:	781b      	ldrb	r3, [r3, #0]
 8010074:	221f      	movs	r2, #31
 8010076:	4393      	bics	r3, r2
 8010078:	b2db      	uxtb	r3, r3
 801007a:	2ba0      	cmp	r3, #160	; 0xa0
 801007c:	d120      	bne.n	80100c0 <ProcessRadioRxDone+0x698>
 801007e:	4b28      	ldr	r3, [pc, #160]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 8010080:	4a29      	ldr	r2, [pc, #164]	; (8010128 <ProcessRadioRxDone+0x700>)
 8010082:	589a      	ldr	r2, [r3, r2]
 8010084:	23ec      	movs	r3, #236	; 0xec
 8010086:	005b      	lsls	r3, r3, #1
 8010088:	58d2      	ldr	r2, [r2, r3]
 801008a:	2134      	movs	r1, #52	; 0x34
 801008c:	187b      	adds	r3, r7, r1
 801008e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010090:	429a      	cmp	r2, r3
 8010092:	d115      	bne.n	80100c0 <ProcessRadioRxDone+0x698>
                    {
                        MacCtx.NvmCtx->SrvAckRequested = true;
 8010094:	4b22      	ldr	r3, [pc, #136]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 8010096:	4a24      	ldr	r2, [pc, #144]	; (8010128 <ProcessRadioRxDone+0x700>)
 8010098:	589a      	ldr	r2, [r3, r2]
 801009a:	23e0      	movs	r3, #224	; 0xe0
 801009c:	005b      	lsls	r3, r3, #1
 801009e:	2101      	movs	r1, #1
 80100a0:	54d1      	strb	r1, [r2, r3]
 80100a2:	e00d      	b.n	80100c0 <ProcessRadioRxDone+0x698>
                    }
                }
                else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT )
 80100a4:	2380      	movs	r3, #128	; 0x80
 80100a6:	18fb      	adds	r3, r7, r3
 80100a8:	781b      	ldrb	r3, [r3, #0]
 80100aa:	2b08      	cmp	r3, #8
 80100ac:	d104      	bne.n	80100b8 <ProcessRadioRxDone+0x690>
                {
                    // Lost too many frames
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;
 80100ae:	4b1c      	ldr	r3, [pc, #112]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 80100b0:	4a1e      	ldr	r2, [pc, #120]	; (801012c <ProcessRadioRxDone+0x704>)
 80100b2:	210a      	movs	r1, #10
 80100b4:	5499      	strb	r1, [r3, r2]
 80100b6:	e003      	b.n	80100c0 <ProcessRadioRxDone+0x698>
                }
                else
                {
                    // Other errors
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80100b8:	4b19      	ldr	r3, [pc, #100]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 80100ba:	4a1c      	ldr	r2, [pc, #112]	; (801012c <ProcessRadioRxDone+0x704>)
 80100bc:	2101      	movs	r1, #1
 80100be:	5499      	strb	r1, [r3, r2]
                }
                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 80100c0:	68b9      	ldr	r1, [r7, #8]
 80100c2:	4a17      	ldr	r2, [pc, #92]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 80100c4:	2386      	movs	r3, #134	; 0x86
 80100c6:	00db      	lsls	r3, r3, #3
 80100c8:	50d1      	str	r1, [r2, r3]
                PrepareRxDoneAbort( );
 80100ca:	f7ff fc81 	bl	800f9d0 <PrepareRxDoneAbort>
                return;
 80100ce:	e1bf      	b.n	8010450 <ProcessRadioRxDone+0xa28>
            }

            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );
 80100d0:	1dfb      	adds	r3, r7, #7
 80100d2:	781a      	ldrb	r2, [r3, #0]
 80100d4:	68bd      	ldr	r5, [r7, #8]
 80100d6:	2680      	movs	r6, #128	; 0x80
 80100d8:	19bc      	adds	r4, r7, r6
 80100da:	2384      	movs	r3, #132	; 0x84
 80100dc:	18fb      	adds	r3, r7, r3
 80100de:	6819      	ldr	r1, [r3, #0]
 80100e0:	2382      	movs	r3, #130	; 0x82
 80100e2:	18fb      	adds	r3, r7, r3
 80100e4:	7818      	ldrb	r0, [r3, #0]
 80100e6:	2334      	movs	r3, #52	; 0x34
 80100e8:	18fb      	adds	r3, r7, r3
 80100ea:	9300      	str	r3, [sp, #0]
 80100ec:	002b      	movs	r3, r5
 80100ee:	f006 fd0b 	bl	8016b08 <LoRaMacCryptoUnsecureMessage>
 80100f2:	0003      	movs	r3, r0
 80100f4:	7023      	strb	r3, [r4, #0]
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 80100f6:	19bb      	adds	r3, r7, r6
 80100f8:	781b      	ldrb	r3, [r3, #0]
 80100fa:	2b00      	cmp	r3, #0
 80100fc:	d01e      	beq.n	801013c <ProcessRadioRxDone+0x714>
            {
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS )
 80100fe:	19bb      	adds	r3, r7, r6
 8010100:	781b      	ldrb	r3, [r3, #0]
 8010102:	2b02      	cmp	r3, #2
 8010104:	d104      	bne.n	8010110 <ProcessRadioRxDone+0x6e8>
                {
                    // We are not the destination of this frame.
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;
 8010106:	4b06      	ldr	r3, [pc, #24]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 8010108:	4a08      	ldr	r2, [pc, #32]	; (801012c <ProcessRadioRxDone+0x704>)
 801010a:	210b      	movs	r1, #11
 801010c:	5499      	strb	r1, [r3, r2]
 801010e:	e003      	b.n	8010118 <ProcessRadioRxDone+0x6f0>
                }
                else
                {
                    // MIC calculation fail
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;
 8010110:	4b03      	ldr	r3, [pc, #12]	; (8010120 <ProcessRadioRxDone+0x6f8>)
 8010112:	4a06      	ldr	r2, [pc, #24]	; (801012c <ProcessRadioRxDone+0x704>)
 8010114:	210c      	movs	r1, #12
 8010116:	5499      	strb	r1, [r3, r2]
                }
                PrepareRxDoneAbort( );
 8010118:	f7ff fc5a 	bl	800f9d0 <PrepareRxDoneAbort>
                return;
 801011c:	e198      	b.n	8010450 <ProcessRadioRxDone+0xa28>
 801011e:	46c0      	nop			; (mov r8, r8)
 8010120:	200008ec 	.word	0x200008ec
 8010124:	0000041c 	.word	0x0000041c
 8010128:	00000484 	.word	0x00000484
 801012c:	0000041d 	.word	0x0000041d
 8010130:	20000b24 	.word	0x20000b24
 8010134:	00000434 	.word	0x00000434
 8010138:	0000042d 	.word	0x0000042d
            }

            // Frame is valid
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 801013c:	4bc6      	ldr	r3, [pc, #792]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801013e:	4ac7      	ldr	r2, [pc, #796]	; (801045c <ProcessRadioRxDone+0xa34>)
 8010140:	2100      	movs	r1, #0
 8010142:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsIndication.Multicast = multicast;
 8010144:	4bc4      	ldr	r3, [pc, #784]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010146:	2283      	movs	r2, #131	; 0x83
 8010148:	18ba      	adds	r2, r7, r2
 801014a:	49c5      	ldr	r1, [pc, #788]	; (8010460 <ProcessRadioRxDone+0xa38>)
 801014c:	7812      	ldrb	r2, [r2, #0]
 801014e:	545a      	strb	r2, [r3, r1]
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 8010150:	2034      	movs	r0, #52	; 0x34
 8010152:	183b      	adds	r3, r7, r0
 8010154:	7b1b      	ldrb	r3, [r3, #12]
 8010156:	06db      	lsls	r3, r3, #27
 8010158:	0fdb      	lsrs	r3, r3, #31
 801015a:	b2db      	uxtb	r3, r3
 801015c:	0019      	movs	r1, r3
 801015e:	4bbe      	ldr	r3, [pc, #760]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010160:	4ac0      	ldr	r2, [pc, #768]	; (8010464 <ProcessRadioRxDone+0xa3c>)
 8010162:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsIndication.Buffer = NULL;
 8010164:	4bbc      	ldr	r3, [pc, #752]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010166:	4ac0      	ldr	r2, [pc, #768]	; (8010468 <ProcessRadioRxDone+0xa40>)
 8010168:	2100      	movs	r1, #0
 801016a:	5099      	str	r1, [r3, r2]
            MacCtx.McpsIndication.BufferSize = 0;
 801016c:	4aba      	ldr	r2, [pc, #744]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801016e:	2385      	movs	r3, #133	; 0x85
 8010170:	00db      	lsls	r3, r3, #3
 8010172:	2100      	movs	r1, #0
 8010174:	54d1      	strb	r1, [r2, r3]
            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 8010176:	68b9      	ldr	r1, [r7, #8]
 8010178:	4ab7      	ldr	r2, [pc, #732]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801017a:	2386      	movs	r3, #134	; 0x86
 801017c:	00db      	lsls	r3, r3, #3
 801017e:	50d1      	str	r1, [r2, r3]
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 8010180:	183b      	adds	r3, r7, r0
 8010182:	7b1b      	ldrb	r3, [r3, #12]
 8010184:	069b      	lsls	r3, r3, #26
 8010186:	0fdb      	lsrs	r3, r3, #31
 8010188:	b2db      	uxtb	r3, r3
 801018a:	1e5a      	subs	r2, r3, #1
 801018c:	4193      	sbcs	r3, r2
 801018e:	b2d9      	uxtb	r1, r3
 8010190:	4bb1      	ldr	r3, [pc, #708]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010192:	4ab6      	ldr	r2, [pc, #728]	; (801046c <ProcessRadioRxDone+0xa44>)
 8010194:	5499      	strb	r1, [r3, r2]

            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 8010196:	4bb0      	ldr	r3, [pc, #704]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010198:	4ab5      	ldr	r2, [pc, #724]	; (8010470 <ProcessRadioRxDone+0xa48>)
 801019a:	2100      	movs	r1, #0
 801019c:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 801019e:	183b      	adds	r3, r7, r0
 80101a0:	7b1b      	ldrb	r3, [r3, #12]
 80101a2:	069b      	lsls	r3, r3, #26
 80101a4:	0fdb      	lsrs	r3, r3, #31
 80101a6:	b2db      	uxtb	r3, r3
 80101a8:	1e5a      	subs	r2, r3, #1
 80101aa:	4193      	sbcs	r3, r2
 80101ac:	b2d9      	uxtb	r1, r3
 80101ae:	4aaa      	ldr	r2, [pc, #680]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80101b0:	2388      	movs	r3, #136	; 0x88
 80101b2:	00db      	lsls	r3, r3, #3
 80101b4:	54d1      	strb	r1, [r2, r3]

            // Reset ADR ACK Counter only, when RX1 or RX2 slot
            if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||
 80101b6:	4ba8      	ldr	r3, [pc, #672]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80101b8:	4aae      	ldr	r2, [pc, #696]	; (8010474 <ProcessRadioRxDone+0xa4c>)
 80101ba:	5c9b      	ldrb	r3, [r3, r2]
 80101bc:	2b00      	cmp	r3, #0
 80101be:	d004      	beq.n	80101ca <ProcessRadioRxDone+0x7a2>
                ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )
 80101c0:	4ba5      	ldr	r3, [pc, #660]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80101c2:	4aac      	ldr	r2, [pc, #688]	; (8010474 <ProcessRadioRxDone+0xa4c>)
 80101c4:	5c9b      	ldrb	r3, [r3, r2]
            if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||
 80101c6:	2b01      	cmp	r3, #1
 80101c8:	d105      	bne.n	80101d6 <ProcessRadioRxDone+0x7ae>
            {
                MacCtx.NvmCtx->AdrAckCounter = 0;
 80101ca:	4ba3      	ldr	r3, [pc, #652]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80101cc:	4aaa      	ldr	r2, [pc, #680]	; (8010478 <ProcessRadioRxDone+0xa50>)
 80101ce:	589b      	ldr	r3, [r3, r2]
 80101d0:	22f4      	movs	r2, #244	; 0xf4
 80101d2:	2100      	movs	r1, #0
 80101d4:	5099      	str	r1, [r3, r2]
            }

            // MCPS Indication and ack requested handling
            if( multicast == 1 )
 80101d6:	2383      	movs	r3, #131	; 0x83
 80101d8:	18fb      	adds	r3, r7, r3
 80101da:	781b      	ldrb	r3, [r3, #0]
 80101dc:	2b01      	cmp	r3, #1
 80101de:	d104      	bne.n	80101ea <ProcessRadioRxDone+0x7c2>
            {
                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;
 80101e0:	4b9d      	ldr	r3, [pc, #628]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80101e2:	4aa6      	ldr	r2, [pc, #664]	; (801047c <ProcessRadioRxDone+0xa54>)
 80101e4:	2102      	movs	r1, #2
 80101e6:	5499      	strb	r1, [r3, r2]
 80101e8:	e02f      	b.n	801024a <ProcessRadioRxDone+0x822>
            }
            else
            {
                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )
 80101ea:	2374      	movs	r3, #116	; 0x74
 80101ec:	18fb      	adds	r3, r7, r3
 80101ee:	781b      	ldrb	r3, [r3, #0]
 80101f0:	221f      	movs	r2, #31
 80101f2:	4393      	bics	r3, r2
 80101f4:	b2db      	uxtb	r3, r3
 80101f6:	2ba0      	cmp	r3, #160	; 0xa0
 80101f8:	d11c      	bne.n	8010234 <ProcessRadioRxDone+0x80c>
                {
                    MacCtx.NvmCtx->SrvAckRequested = true;
 80101fa:	4b97      	ldr	r3, [pc, #604]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80101fc:	4a9e      	ldr	r2, [pc, #632]	; (8010478 <ProcessRadioRxDone+0xa50>)
 80101fe:	589a      	ldr	r2, [r3, r2]
 8010200:	23e0      	movs	r3, #224	; 0xe0
 8010202:	005b      	lsls	r3, r3, #1
 8010204:	2101      	movs	r1, #1
 8010206:	54d1      	strb	r1, [r2, r3]
                    if( MacCtx.NvmCtx->Version.Fields.Minor == 0 )
 8010208:	4b93      	ldr	r3, [pc, #588]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801020a:	4a9b      	ldr	r2, [pc, #620]	; (8010478 <ProcessRadioRxDone+0xa50>)
 801020c:	589a      	ldr	r2, [r3, r2]
 801020e:	23e9      	movs	r3, #233	; 0xe9
 8010210:	005b      	lsls	r3, r3, #1
 8010212:	5cd3      	ldrb	r3, [r2, r3]
 8010214:	2b00      	cmp	r3, #0
 8010216:	d108      	bne.n	801022a <ProcessRadioRxDone+0x802>
                    {
                        MacCtx.NvmCtx->LastRxMic = macMsgData.MIC;
 8010218:	4b8f      	ldr	r3, [pc, #572]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801021a:	4a97      	ldr	r2, [pc, #604]	; (8010478 <ProcessRadioRxDone+0xa50>)
 801021c:	589a      	ldr	r2, [r3, r2]
 801021e:	2334      	movs	r3, #52	; 0x34
 8010220:	18fb      	adds	r3, r7, r3
 8010222:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8010224:	23ec      	movs	r3, #236	; 0xec
 8010226:	005b      	lsls	r3, r3, #1
 8010228:	50d1      	str	r1, [r2, r3]
                    }
                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 801022a:	4b8b      	ldr	r3, [pc, #556]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801022c:	4a93      	ldr	r2, [pc, #588]	; (801047c <ProcessRadioRxDone+0xa54>)
 801022e:	2101      	movs	r1, #1
 8010230:	5499      	strb	r1, [r3, r2]
 8010232:	e00a      	b.n	801024a <ProcessRadioRxDone+0x822>
                }
                else
                {
                    MacCtx.NvmCtx->SrvAckRequested = false;
 8010234:	4b88      	ldr	r3, [pc, #544]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010236:	4a90      	ldr	r2, [pc, #576]	; (8010478 <ProcessRadioRxDone+0xa50>)
 8010238:	589a      	ldr	r2, [r3, r2]
 801023a:	23e0      	movs	r3, #224	; 0xe0
 801023c:	005b      	lsls	r3, r3, #1
 801023e:	2100      	movs	r1, #0
 8010240:	54d1      	strb	r1, [r2, r3]
                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 8010242:	4b85      	ldr	r3, [pc, #532]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010244:	4a8d      	ldr	r2, [pc, #564]	; (801047c <ProcessRadioRxDone+0xa54>)
 8010246:	2100      	movs	r1, #0
 8010248:	5499      	strb	r1, [r3, r2]
                }
            }

            RemoveMacCommands( MacCtx.McpsIndication.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );
 801024a:	4b83      	ldr	r3, [pc, #524]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801024c:	4a89      	ldr	r2, [pc, #548]	; (8010474 <ProcessRadioRxDone+0xa4c>)
 801024e:	5c98      	ldrb	r0, [r3, r2]
 8010250:	4b81      	ldr	r3, [pc, #516]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010252:	4a8b      	ldr	r2, [pc, #556]	; (8010480 <ProcessRadioRxDone+0xa58>)
 8010254:	5c9a      	ldrb	r2, [r3, r2]
 8010256:	2334      	movs	r3, #52	; 0x34
 8010258:	18fb      	adds	r3, r7, r3
 801025a:	7b1b      	ldrb	r3, [r3, #12]
 801025c:	1c19      	adds	r1, r3, #0
 801025e:	f002 f943 	bl	80124e8 <RemoveMacCommands>

            switch( fType )
 8010262:	1dbb      	adds	r3, r7, #6
 8010264:	781b      	ldrb	r3, [r3, #0]
 8010266:	2b03      	cmp	r3, #3
 8010268:	d100      	bne.n	801026c <ProcessRadioRxDone+0x844>
 801026a:	e073      	b.n	8010354 <ProcessRadioRxDone+0x92c>
 801026c:	dd00      	ble.n	8010270 <ProcessRadioRxDone+0x848>
 801026e:	e089      	b.n	8010384 <ProcessRadioRxDone+0x95c>
 8010270:	2b02      	cmp	r3, #2
 8010272:	d055      	beq.n	8010320 <ProcessRadioRxDone+0x8f8>
 8010274:	dd00      	ble.n	8010278 <ProcessRadioRxDone+0x850>
 8010276:	e085      	b.n	8010384 <ProcessRadioRxDone+0x95c>
 8010278:	2b00      	cmp	r3, #0
 801027a:	d002      	beq.n	8010282 <ProcessRadioRxDone+0x85a>
 801027c:	2b01      	cmp	r3, #1
 801027e:	d030      	beq.n	80102e2 <ProcessRadioRxDone+0x8ba>
 8010280:	e080      	b.n	8010384 <ProcessRadioRxDone+0x95c>
                    * |    > 0   |   X  |  > 0  |       X      |
                    * +----------+------+-------+--------------+
                    */

                    // Decode MAC commands in FOpts field
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );
 8010282:	2034      	movs	r0, #52	; 0x34
 8010284:	183b      	adds	r3, r7, r0
 8010286:	7b1b      	ldrb	r3, [r3, #12]
 8010288:	071b      	lsls	r3, r3, #28
 801028a:	0f1b      	lsrs	r3, r3, #28
 801028c:	b2db      	uxtb	r3, r3
 801028e:	001c      	movs	r4, r3
 8010290:	4b71      	ldr	r3, [pc, #452]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010292:	4a78      	ldr	r2, [pc, #480]	; (8010474 <ProcessRadioRxDone+0xa4c>)
 8010294:	5c9b      	ldrb	r3, [r3, r2]
 8010296:	2277      	movs	r2, #119	; 0x77
 8010298:	18ba      	adds	r2, r7, r2
 801029a:	2100      	movs	r1, #0
 801029c:	5651      	ldrsb	r1, [r2, r1]
 801029e:	0005      	movs	r5, r0
 80102a0:	183a      	adds	r2, r7, r0
 80102a2:	3210      	adds	r2, #16
 80102a4:	0010      	movs	r0, r2
 80102a6:	9300      	str	r3, [sp, #0]
 80102a8:	000b      	movs	r3, r1
 80102aa:	0022      	movs	r2, r4
 80102ac:	2100      	movs	r1, #0
 80102ae:	f000 ffd5 	bl	801125c <ProcessMacCommands>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 80102b2:	0028      	movs	r0, r5
 80102b4:	183b      	adds	r3, r7, r0
 80102b6:	2220      	movs	r2, #32
 80102b8:	5c99      	ldrb	r1, [r3, r2]
 80102ba:	4b67      	ldr	r3, [pc, #412]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80102bc:	4a71      	ldr	r2, [pc, #452]	; (8010484 <ProcessRadioRxDone+0xa5c>)
 80102be:	5499      	strb	r1, [r3, r2]
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 80102c0:	183b      	adds	r3, r7, r0
 80102c2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80102c4:	4b64      	ldr	r3, [pc, #400]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80102c6:	4968      	ldr	r1, [pc, #416]	; (8010468 <ProcessRadioRxDone+0xa40>)
 80102c8:	505a      	str	r2, [r3, r1]
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 80102ca:	183b      	adds	r3, r7, r0
 80102cc:	2228      	movs	r2, #40	; 0x28
 80102ce:	5c99      	ldrb	r1, [r3, r2]
 80102d0:	4a61      	ldr	r2, [pc, #388]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80102d2:	2385      	movs	r3, #133	; 0x85
 80102d4:	00db      	lsls	r3, r3, #3
 80102d6:	54d1      	strb	r1, [r2, r3]
                    MacCtx.McpsIndication.RxData = true;
 80102d8:	4b5f      	ldr	r3, [pc, #380]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80102da:	4a6b      	ldr	r2, [pc, #428]	; (8010488 <ProcessRadioRxDone+0xa60>)
 80102dc:	2101      	movs	r1, #1
 80102de:	5499      	strb	r1, [r3, r2]
                    break;
 80102e0:	e057      	b.n	8010392 <ProcessRadioRxDone+0x96a>
                    * |    > 0   |   X  |   -   |       -      |
                    * +----------+------+-------+--------------+
                    */

                    // Decode MAC commands in FOpts field
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );
 80102e2:	2034      	movs	r0, #52	; 0x34
 80102e4:	183b      	adds	r3, r7, r0
 80102e6:	7b1b      	ldrb	r3, [r3, #12]
 80102e8:	071b      	lsls	r3, r3, #28
 80102ea:	0f1b      	lsrs	r3, r3, #28
 80102ec:	b2db      	uxtb	r3, r3
 80102ee:	001c      	movs	r4, r3
 80102f0:	4b59      	ldr	r3, [pc, #356]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80102f2:	4a60      	ldr	r2, [pc, #384]	; (8010474 <ProcessRadioRxDone+0xa4c>)
 80102f4:	5c9b      	ldrb	r3, [r3, r2]
 80102f6:	2277      	movs	r2, #119	; 0x77
 80102f8:	18ba      	adds	r2, r7, r2
 80102fa:	2100      	movs	r1, #0
 80102fc:	5651      	ldrsb	r1, [r2, r1]
 80102fe:	0005      	movs	r5, r0
 8010300:	183a      	adds	r2, r7, r0
 8010302:	3210      	adds	r2, #16
 8010304:	0010      	movs	r0, r2
 8010306:	9300      	str	r3, [sp, #0]
 8010308:	000b      	movs	r3, r1
 801030a:	0022      	movs	r2, r4
 801030c:	2100      	movs	r1, #0
 801030e:	f000 ffa5 	bl	801125c <ProcessMacCommands>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 8010312:	197b      	adds	r3, r7, r5
 8010314:	2220      	movs	r2, #32
 8010316:	5c99      	ldrb	r1, [r3, r2]
 8010318:	4b4f      	ldr	r3, [pc, #316]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801031a:	4a5a      	ldr	r2, [pc, #360]	; (8010484 <ProcessRadioRxDone+0xa5c>)
 801031c:	5499      	strb	r1, [r3, r2]
                    break;
 801031e:	e038      	b.n	8010392 <ProcessRadioRxDone+0x96a>
                    * |    = 0   |   -  |  = 0  | MAC commands |
                    * +----------+------+-------+--------------+
                    */

                    // Decode MAC commands in FRMPayload
                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.McpsIndication.RxSlot );
 8010320:	2434      	movs	r4, #52	; 0x34
 8010322:	193b      	adds	r3, r7, r4
 8010324:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8010326:	193b      	adds	r3, r7, r4
 8010328:	2228      	movs	r2, #40	; 0x28
 801032a:	5c99      	ldrb	r1, [r3, r2]
 801032c:	4b4a      	ldr	r3, [pc, #296]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801032e:	4a51      	ldr	r2, [pc, #324]	; (8010474 <ProcessRadioRxDone+0xa4c>)
 8010330:	5c9b      	ldrb	r3, [r3, r2]
 8010332:	2277      	movs	r2, #119	; 0x77
 8010334:	18ba      	adds	r2, r7, r2
 8010336:	7812      	ldrb	r2, [r2, #0]
 8010338:	b252      	sxtb	r2, r2
 801033a:	9300      	str	r3, [sp, #0]
 801033c:	0013      	movs	r3, r2
 801033e:	000a      	movs	r2, r1
 8010340:	2100      	movs	r1, #0
 8010342:	f000 ff8b 	bl	801125c <ProcessMacCommands>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 8010346:	193b      	adds	r3, r7, r4
 8010348:	2220      	movs	r2, #32
 801034a:	5c99      	ldrb	r1, [r3, r2]
 801034c:	4b42      	ldr	r3, [pc, #264]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801034e:	4a4d      	ldr	r2, [pc, #308]	; (8010484 <ProcessRadioRxDone+0xa5c>)
 8010350:	5499      	strb	r1, [r3, r2]
                    break;
 8010352:	e01e      	b.n	8010392 <ProcessRadioRxDone+0x96a>
                    * |    = 0   |   -  |  > 0  |       X      |
                    * +----------+------+-------+--------------+
                    */

                    // No MAC commands just application payload
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 8010354:	2034      	movs	r0, #52	; 0x34
 8010356:	183b      	adds	r3, r7, r0
 8010358:	2220      	movs	r2, #32
 801035a:	5c99      	ldrb	r1, [r3, r2]
 801035c:	4b3e      	ldr	r3, [pc, #248]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801035e:	4a49      	ldr	r2, [pc, #292]	; (8010484 <ProcessRadioRxDone+0xa5c>)
 8010360:	5499      	strb	r1, [r3, r2]
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 8010362:	183b      	adds	r3, r7, r0
 8010364:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8010366:	4b3c      	ldr	r3, [pc, #240]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010368:	493f      	ldr	r1, [pc, #252]	; (8010468 <ProcessRadioRxDone+0xa40>)
 801036a:	505a      	str	r2, [r3, r1]
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 801036c:	183b      	adds	r3, r7, r0
 801036e:	2228      	movs	r2, #40	; 0x28
 8010370:	5c99      	ldrb	r1, [r3, r2]
 8010372:	4a39      	ldr	r2, [pc, #228]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010374:	2385      	movs	r3, #133	; 0x85
 8010376:	00db      	lsls	r3, r3, #3
 8010378:	54d1      	strb	r1, [r2, r3]
                    MacCtx.McpsIndication.RxData = true;
 801037a:	4b37      	ldr	r3, [pc, #220]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801037c:	4a42      	ldr	r2, [pc, #264]	; (8010488 <ProcessRadioRxDone+0xa60>)
 801037e:	2101      	movs	r1, #1
 8010380:	5499      	strb	r1, [r3, r2]
                    break;
 8010382:	e006      	b.n	8010392 <ProcessRadioRxDone+0x96a>
                }
                default:
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8010384:	4b34      	ldr	r3, [pc, #208]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010386:	4a35      	ldr	r2, [pc, #212]	; (801045c <ProcessRadioRxDone+0xa34>)
 8010388:	2101      	movs	r1, #1
 801038a:	5499      	strb	r1, [r3, r2]
                    PrepareRxDoneAbort( );
 801038c:	f7ff fb20 	bl	800f9d0 <PrepareRxDoneAbort>
                    break;
 8010390:	46c0      	nop			; (mov r8, r8)
            }

            // Provide always an indication, skip the callback to the user application,
            // in case of a confirmed downlink retransmission.
            MacCtx.MacFlags.Bits.McpsInd = 1;
 8010392:	4b31      	ldr	r3, [pc, #196]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010394:	4a3d      	ldr	r2, [pc, #244]	; (801048c <ProcessRadioRxDone+0xa64>)
 8010396:	5c99      	ldrb	r1, [r3, r2]
 8010398:	2002      	movs	r0, #2
 801039a:	4301      	orrs	r1, r0
 801039c:	5499      	strb	r1, [r3, r2]

            break;
 801039e:	e036      	b.n	801040e <ProcessRadioRxDone+0x9e6>
        case FRAME_TYPE_PROPRIETARY:
            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );
 80103a0:	2476      	movs	r4, #118	; 0x76
 80103a2:	193b      	adds	r3, r7, r4
 80103a4:	781b      	ldrb	r3, [r3, #0]
 80103a6:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80103a8:	18d1      	adds	r1, r2, r3
 80103aa:	193b      	adds	r3, r7, r4
 80103ac:	781b      	ldrb	r3, [r3, #0]
 80103ae:	b29b      	uxth	r3, r3
 80103b0:	257a      	movs	r5, #122	; 0x7a
 80103b2:	197a      	adds	r2, r7, r5
 80103b4:	8812      	ldrh	r2, [r2, #0]
 80103b6:	1ad3      	subs	r3, r2, r3
 80103b8:	b29a      	uxth	r2, r3
 80103ba:	4b35      	ldr	r3, [pc, #212]	; (8010490 <ProcessRadioRxDone+0xa68>)
 80103bc:	0018      	movs	r0, r3
 80103be:	f00b f8c3 	bl	801b548 <memcpy1>

            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;
 80103c2:	4b25      	ldr	r3, [pc, #148]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80103c4:	4a2d      	ldr	r2, [pc, #180]	; (801047c <ProcessRadioRxDone+0xa54>)
 80103c6:	2103      	movs	r1, #3
 80103c8:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 80103ca:	4b23      	ldr	r3, [pc, #140]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80103cc:	4a23      	ldr	r2, [pc, #140]	; (801045c <ProcessRadioRxDone+0xa34>)
 80103ce:	2100      	movs	r1, #0
 80103d0:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;
 80103d2:	4b21      	ldr	r3, [pc, #132]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80103d4:	4924      	ldr	r1, [pc, #144]	; (8010468 <ProcessRadioRxDone+0xa40>)
 80103d6:	4a2e      	ldr	r2, [pc, #184]	; (8010490 <ProcessRadioRxDone+0xa68>)
 80103d8:	505a      	str	r2, [r3, r1]
            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;
 80103da:	197b      	adds	r3, r7, r5
 80103dc:	881b      	ldrh	r3, [r3, #0]
 80103de:	b2da      	uxtb	r2, r3
 80103e0:	193b      	adds	r3, r7, r4
 80103e2:	781b      	ldrb	r3, [r3, #0]
 80103e4:	1ad3      	subs	r3, r2, r3
 80103e6:	b2d9      	uxtb	r1, r3
 80103e8:	4a1b      	ldr	r2, [pc, #108]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80103ea:	2385      	movs	r3, #133	; 0x85
 80103ec:	00db      	lsls	r3, r3, #3
 80103ee:	54d1      	strb	r1, [r2, r3]

            MacCtx.MacFlags.Bits.McpsInd = 1;
 80103f0:	4b19      	ldr	r3, [pc, #100]	; (8010458 <ProcessRadioRxDone+0xa30>)
 80103f2:	4a26      	ldr	r2, [pc, #152]	; (801048c <ProcessRadioRxDone+0xa64>)
 80103f4:	5c99      	ldrb	r1, [r3, r2]
 80103f6:	2002      	movs	r0, #2
 80103f8:	4301      	orrs	r1, r0
 80103fa:	5499      	strb	r1, [r3, r2]
            break;
 80103fc:	e007      	b.n	801040e <ProcessRadioRxDone+0x9e6>
        default:
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80103fe:	4b16      	ldr	r3, [pc, #88]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010400:	4a16      	ldr	r2, [pc, #88]	; (801045c <ProcessRadioRxDone+0xa34>)
 8010402:	2101      	movs	r1, #1
 8010404:	5499      	strb	r1, [r3, r2]
            PrepareRxDoneAbort( );
 8010406:	f7ff fae3 	bl	800f9d0 <PrepareRxDoneAbort>
            break;
 801040a:	e000      	b.n	801040e <ProcessRadioRxDone+0x9e6>
            break;
 801040c:	46c0      	nop			; (mov r8, r8)
    }

    // Verify if we need to disable the AckTimeoutTimer
    if( MacCtx.NodeAckRequested == true )
 801040e:	4b12      	ldr	r3, [pc, #72]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010410:	4a20      	ldr	r2, [pc, #128]	; (8010494 <ProcessRadioRxDone+0xa6c>)
 8010412:	5c9b      	ldrb	r3, [r3, r2]
 8010414:	2b00      	cmp	r3, #0
 8010416:	d009      	beq.n	801042c <ProcessRadioRxDone+0xa04>
    {
        if( MacCtx.McpsConfirm.AckReceived == true )
 8010418:	4a0f      	ldr	r2, [pc, #60]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801041a:	2388      	movs	r3, #136	; 0x88
 801041c:	00db      	lsls	r3, r3, #3
 801041e:	5cd3      	ldrb	r3, [r2, r3]
 8010420:	2b00      	cmp	r3, #0
 8010422:	d00d      	beq.n	8010440 <ProcessRadioRxDone+0xa18>
        {
            OnAckTimeoutTimerEvent( NULL );
 8010424:	2000      	movs	r0, #0
 8010426:	f000 fca3 	bl	8010d70 <OnAckTimeoutTimerEvent>
 801042a:	e009      	b.n	8010440 <ProcessRadioRxDone+0xa18>
        }
    }
    else
    {
        if( MacCtx.NvmCtx->DeviceClass == CLASS_C )
 801042c:	4b0a      	ldr	r3, [pc, #40]	; (8010458 <ProcessRadioRxDone+0xa30>)
 801042e:	4a12      	ldr	r2, [pc, #72]	; (8010478 <ProcessRadioRxDone+0xa50>)
 8010430:	589b      	ldr	r3, [r3, r2]
 8010432:	22f0      	movs	r2, #240	; 0xf0
 8010434:	5c9b      	ldrb	r3, [r3, r2]
 8010436:	2b02      	cmp	r3, #2
 8010438:	d102      	bne.n	8010440 <ProcessRadioRxDone+0xa18>
        {
            OnAckTimeoutTimerEvent( NULL );
 801043a:	2000      	movs	r0, #0
 801043c:	f000 fc98 	bl	8010d70 <OnAckTimeoutTimerEvent>
        }
    }
    MacCtx.MacFlags.Bits.MacDone = 1;
 8010440:	4b05      	ldr	r3, [pc, #20]	; (8010458 <ProcessRadioRxDone+0xa30>)
 8010442:	4a12      	ldr	r2, [pc, #72]	; (801048c <ProcessRadioRxDone+0xa64>)
 8010444:	5c99      	ldrb	r1, [r3, r2]
 8010446:	2020      	movs	r0, #32
 8010448:	4301      	orrs	r1, r0
 801044a:	5499      	strb	r1, [r3, r2]

    UpdateRxSlotIdleState( );
 801044c:	f7ff f9f8 	bl	800f840 <UpdateRxSlotIdleState>
}
 8010450:	46bd      	mov	sp, r7
 8010452:	b023      	add	sp, #140	; 0x8c
 8010454:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010456:	46c0      	nop			; (mov r8, r8)
 8010458:	200008ec 	.word	0x200008ec
 801045c:	0000041d 	.word	0x0000041d
 8010460:	0000041e 	.word	0x0000041e
 8010464:	00000421 	.word	0x00000421
 8010468:	00000424 	.word	0x00000424
 801046c:	0000042e 	.word	0x0000042e
 8010470:	0000043d 	.word	0x0000043d
 8010474:	0000042d 	.word	0x0000042d
 8010478:	00000484 	.word	0x00000484
 801047c:	0000041c 	.word	0x0000041c
 8010480:	0000043c 	.word	0x0000043c
 8010484:	0000041f 	.word	0x0000041f
 8010488:	00000429 	.word	0x00000429
 801048c:	00000481 	.word	0x00000481
 8010490:	20000b24 	.word	0x20000b24
 8010494:	00000414 	.word	0x00000414

08010498 <ProcessRadioTxTimeout>:

static void ProcessRadioTxTimeout( void )
{
 8010498:	b580      	push	{r7, lr}
 801049a:	af00      	add	r7, sp, #0
    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )
 801049c:	4b12      	ldr	r3, [pc, #72]	; (80104e8 <ProcessRadioTxTimeout+0x50>)
 801049e:	4a13      	ldr	r2, [pc, #76]	; (80104ec <ProcessRadioTxTimeout+0x54>)
 80104a0:	589b      	ldr	r3, [r3, r2]
 80104a2:	22f0      	movs	r2, #240	; 0xf0
 80104a4:	5c9b      	ldrb	r3, [r3, r2]
 80104a6:	2b02      	cmp	r3, #2
 80104a8:	d002      	beq.n	80104b0 <ProcessRadioTxTimeout+0x18>
    {
        Radio.Sleep( );
 80104aa:	4b11      	ldr	r3, [pc, #68]	; (80104f0 <ProcessRadioTxTimeout+0x58>)
 80104ac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80104ae:	4798      	blx	r3
    }
    UpdateRxSlotIdleState( );
 80104b0:	f7ff f9c6 	bl	800f840 <UpdateRxSlotIdleState>

    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;
 80104b4:	4b0c      	ldr	r3, [pc, #48]	; (80104e8 <ProcessRadioTxTimeout+0x50>)
 80104b6:	4a0f      	ldr	r2, [pc, #60]	; (80104f4 <ProcessRadioTxTimeout+0x5c>)
 80104b8:	2102      	movs	r1, #2
 80104ba:	5499      	strb	r1, [r3, r2]
    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );
 80104bc:	2002      	movs	r0, #2
 80104be:	f005 fa47 	bl	8015950 <LoRaMacConfirmQueueSetStatusCmn>
    if( MacCtx.NodeAckRequested == true )
 80104c2:	4b09      	ldr	r3, [pc, #36]	; (80104e8 <ProcessRadioTxTimeout+0x50>)
 80104c4:	4a0c      	ldr	r2, [pc, #48]	; (80104f8 <ProcessRadioTxTimeout+0x60>)
 80104c6:	5c9b      	ldrb	r3, [r3, r2]
 80104c8:	2b00      	cmp	r3, #0
 80104ca:	d003      	beq.n	80104d4 <ProcessRadioTxTimeout+0x3c>
    {
        MacCtx.AckTimeoutRetry = true;
 80104cc:	4b06      	ldr	r3, [pc, #24]	; (80104e8 <ProcessRadioTxTimeout+0x50>)
 80104ce:	4a0b      	ldr	r2, [pc, #44]	; (80104fc <ProcessRadioTxTimeout+0x64>)
 80104d0:	2101      	movs	r1, #1
 80104d2:	5499      	strb	r1, [r3, r2]
    }
    MacCtx.MacFlags.Bits.MacDone = 1;
 80104d4:	4b04      	ldr	r3, [pc, #16]	; (80104e8 <ProcessRadioTxTimeout+0x50>)
 80104d6:	4a0a      	ldr	r2, [pc, #40]	; (8010500 <ProcessRadioTxTimeout+0x68>)
 80104d8:	5c99      	ldrb	r1, [r3, r2]
 80104da:	2020      	movs	r0, #32
 80104dc:	4301      	orrs	r1, r0
 80104de:	5499      	strb	r1, [r3, r2]
}
 80104e0:	46c0      	nop			; (mov r8, r8)
 80104e2:	46bd      	mov	sp, r7
 80104e4:	bd80      	pop	{r7, pc}
 80104e6:	46c0      	nop			; (mov r8, r8)
 80104e8:	200008ec 	.word	0x200008ec
 80104ec:	00000484 	.word	0x00000484
 80104f0:	0801ebd0 	.word	0x0801ebd0
 80104f4:	0000043d 	.word	0x0000043d
 80104f8:	00000414 	.word	0x00000414
 80104fc:	00000413 	.word	0x00000413
 8010500:	00000481 	.word	0x00000481

08010504 <HandleRadioRxErrorTimeout>:

static void HandleRadioRxErrorTimeout( LoRaMacEventInfoStatus_t rx1EventInfoStatus, LoRaMacEventInfoStatus_t rx2EventInfoStatus )
{
 8010504:	b580      	push	{r7, lr}
 8010506:	b084      	sub	sp, #16
 8010508:	af00      	add	r7, sp, #0
 801050a:	0002      	movs	r2, r0
 801050c:	1dfb      	adds	r3, r7, #7
 801050e:	701a      	strb	r2, [r3, #0]
 8010510:	1dbb      	adds	r3, r7, #6
 8010512:	1c0a      	adds	r2, r1, #0
 8010514:	701a      	strb	r2, [r3, #0]
    bool classBRx = false;
 8010516:	230f      	movs	r3, #15
 8010518:	18fb      	adds	r3, r7, r3
 801051a:	2200      	movs	r2, #0
 801051c:	701a      	strb	r2, [r3, #0]

    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )
 801051e:	4b3d      	ldr	r3, [pc, #244]	; (8010614 <HandleRadioRxErrorTimeout+0x110>)
 8010520:	4a3d      	ldr	r2, [pc, #244]	; (8010618 <HandleRadioRxErrorTimeout+0x114>)
 8010522:	589b      	ldr	r3, [r3, r2]
 8010524:	22f0      	movs	r2, #240	; 0xf0
 8010526:	5c9b      	ldrb	r3, [r3, r2]
 8010528:	2b02      	cmp	r3, #2
 801052a:	d002      	beq.n	8010532 <HandleRadioRxErrorTimeout+0x2e>
    {
        Radio.Sleep( );
 801052c:	4b3b      	ldr	r3, [pc, #236]	; (801061c <HandleRadioRxErrorTimeout+0x118>)
 801052e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8010530:	4798      	blx	r3
    }

    if( LoRaMacClassBIsBeaconExpected( ) == true )
 8010532:	f004 fd83 	bl	801503c <LoRaMacClassBIsBeaconExpected>
 8010536:	1e03      	subs	r3, r0, #0
 8010538:	d009      	beq.n	801054e <HandleRadioRxErrorTimeout+0x4a>
    {
        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );
 801053a:	2002      	movs	r0, #2
 801053c:	f004 fd36 	bl	8014fac <LoRaMacClassBSetBeaconState>
        LoRaMacClassBBeaconTimerEvent( NULL );
 8010540:	2000      	movs	r0, #0
 8010542:	f004 fd57 	bl	8014ff4 <LoRaMacClassBBeaconTimerEvent>
        classBRx = true;
 8010546:	230f      	movs	r3, #15
 8010548:	18fb      	adds	r3, r7, r3
 801054a:	2201      	movs	r2, #1
 801054c:	701a      	strb	r2, [r3, #0]
    }
    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )
 801054e:	4b31      	ldr	r3, [pc, #196]	; (8010614 <HandleRadioRxErrorTimeout+0x110>)
 8010550:	4a31      	ldr	r2, [pc, #196]	; (8010618 <HandleRadioRxErrorTimeout+0x114>)
 8010552:	589b      	ldr	r3, [r3, r2]
 8010554:	22f0      	movs	r2, #240	; 0xf0
 8010556:	5c9b      	ldrb	r3, [r3, r2]
 8010558:	2b01      	cmp	r3, #1
 801055a:	d11b      	bne.n	8010594 <HandleRadioRxErrorTimeout+0x90>
    {
        if( LoRaMacClassBIsPingExpected( ) == true )
 801055c:	f004 fd74 	bl	8015048 <LoRaMacClassBIsPingExpected>
 8010560:	1e03      	subs	r3, r0, #0
 8010562:	d009      	beq.n	8010578 <HandleRadioRxErrorTimeout+0x74>
        {
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 8010564:	2000      	movs	r0, #0
 8010566:	f004 fd2b 	bl	8014fc0 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 801056a:	2000      	movs	r0, #0
 801056c:	f004 fd4a 	bl	8015004 <LoRaMacClassBPingSlotTimerEvent>
            classBRx = true;
 8010570:	230f      	movs	r3, #15
 8010572:	18fb      	adds	r3, r7, r3
 8010574:	2201      	movs	r2, #1
 8010576:	701a      	strb	r2, [r3, #0]
        }
        if( LoRaMacClassBIsMulticastExpected( ) == true )
 8010578:	f004 fd6c 	bl	8015054 <LoRaMacClassBIsMulticastExpected>
 801057c:	1e03      	subs	r3, r0, #0
 801057e:	d009      	beq.n	8010594 <HandleRadioRxErrorTimeout+0x90>
        {
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 8010580:	2000      	movs	r0, #0
 8010582:	f004 fd27 	bl	8014fd4 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 8010586:	2000      	movs	r0, #0
 8010588:	f004 fd44 	bl	8015014 <LoRaMacClassBMulticastSlotTimerEvent>
            classBRx = true;
 801058c:	230f      	movs	r3, #15
 801058e:	18fb      	adds	r3, r7, r3
 8010590:	2201      	movs	r2, #1
 8010592:	701a      	strb	r2, [r3, #0]
        }
    }

    if( classBRx == false )
 8010594:	230f      	movs	r3, #15
 8010596:	18fb      	adds	r3, r7, r3
 8010598:	781b      	ldrb	r3, [r3, #0]
 801059a:	2201      	movs	r2, #1
 801059c:	4053      	eors	r3, r2
 801059e:	b2db      	uxtb	r3, r3
 80105a0:	2b00      	cmp	r3, #0
 80105a2:	d031      	beq.n	8010608 <HandleRadioRxErrorTimeout+0x104>
    {
        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 80105a4:	4a1b      	ldr	r2, [pc, #108]	; (8010614 <HandleRadioRxErrorTimeout+0x110>)
 80105a6:	2390      	movs	r3, #144	; 0x90
 80105a8:	00db      	lsls	r3, r3, #3
 80105aa:	5cd3      	ldrb	r3, [r2, r3]
 80105ac:	2b00      	cmp	r3, #0
 80105ae:	d10f      	bne.n	80105d0 <HandleRadioRxErrorTimeout+0xcc>
        {
            if( MacCtx.NodeAckRequested == true )
 80105b0:	4b18      	ldr	r3, [pc, #96]	; (8010614 <HandleRadioRxErrorTimeout+0x110>)
 80105b2:	4a1b      	ldr	r2, [pc, #108]	; (8010620 <HandleRadioRxErrorTimeout+0x11c>)
 80105b4:	5c9b      	ldrb	r3, [r3, r2]
 80105b6:	2b00      	cmp	r3, #0
 80105b8:	d004      	beq.n	80105c4 <HandleRadioRxErrorTimeout+0xc0>
            {
                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;
 80105ba:	4b16      	ldr	r3, [pc, #88]	; (8010614 <HandleRadioRxErrorTimeout+0x110>)
 80105bc:	1dfa      	adds	r2, r7, #7
 80105be:	4919      	ldr	r1, [pc, #100]	; (8010624 <HandleRadioRxErrorTimeout+0x120>)
 80105c0:	7812      	ldrb	r2, [r2, #0]
 80105c2:	545a      	strb	r2, [r3, r1]
            }
            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );
 80105c4:	1dfb      	adds	r3, r7, #7
 80105c6:	781b      	ldrb	r3, [r3, #0]
 80105c8:	0018      	movs	r0, r3
 80105ca:	f005 f9c1 	bl	8015950 <LoRaMacConfirmQueueSetStatusCmn>
 80105ce:	e01b      	b.n	8010608 <HandleRadioRxErrorTimeout+0x104>
        }
        else
        {
            if( MacCtx.NodeAckRequested == true )
 80105d0:	4b10      	ldr	r3, [pc, #64]	; (8010614 <HandleRadioRxErrorTimeout+0x110>)
 80105d2:	4a13      	ldr	r2, [pc, #76]	; (8010620 <HandleRadioRxErrorTimeout+0x11c>)
 80105d4:	5c9b      	ldrb	r3, [r3, r2]
 80105d6:	2b00      	cmp	r3, #0
 80105d8:	d004      	beq.n	80105e4 <HandleRadioRxErrorTimeout+0xe0>
            {
                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;
 80105da:	4b0e      	ldr	r3, [pc, #56]	; (8010614 <HandleRadioRxErrorTimeout+0x110>)
 80105dc:	1dba      	adds	r2, r7, #6
 80105de:	4911      	ldr	r1, [pc, #68]	; (8010624 <HandleRadioRxErrorTimeout+0x120>)
 80105e0:	7812      	ldrb	r2, [r2, #0]
 80105e2:	545a      	strb	r2, [r3, r1]
            }
            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );
 80105e4:	1dbb      	adds	r3, r7, #6
 80105e6:	781b      	ldrb	r3, [r3, #0]
 80105e8:	0018      	movs	r0, r3
 80105ea:	f005 f9b1 	bl	8015950 <LoRaMacConfirmQueueSetStatusCmn>

            if( MacCtx.NvmCtx->DeviceClass != CLASS_C )
 80105ee:	4b09      	ldr	r3, [pc, #36]	; (8010614 <HandleRadioRxErrorTimeout+0x110>)
 80105f0:	4a09      	ldr	r2, [pc, #36]	; (8010618 <HandleRadioRxErrorTimeout+0x114>)
 80105f2:	589b      	ldr	r3, [r3, r2]
 80105f4:	22f0      	movs	r2, #240	; 0xf0
 80105f6:	5c9b      	ldrb	r3, [r3, r2]
 80105f8:	2b02      	cmp	r3, #2
 80105fa:	d005      	beq.n	8010608 <HandleRadioRxErrorTimeout+0x104>
            {
                MacCtx.MacFlags.Bits.MacDone = 1;
 80105fc:	4b05      	ldr	r3, [pc, #20]	; (8010614 <HandleRadioRxErrorTimeout+0x110>)
 80105fe:	4a0a      	ldr	r2, [pc, #40]	; (8010628 <HandleRadioRxErrorTimeout+0x124>)
 8010600:	5c99      	ldrb	r1, [r3, r2]
 8010602:	2020      	movs	r0, #32
 8010604:	4301      	orrs	r1, r0
 8010606:	5499      	strb	r1, [r3, r2]
            }
        }
    }

    UpdateRxSlotIdleState( );
 8010608:	f7ff f91a 	bl	800f840 <UpdateRxSlotIdleState>
}
 801060c:	46c0      	nop			; (mov r8, r8)
 801060e:	46bd      	mov	sp, r7
 8010610:	b004      	add	sp, #16
 8010612:	bd80      	pop	{r7, pc}
 8010614:	200008ec 	.word	0x200008ec
 8010618:	00000484 	.word	0x00000484
 801061c:	0801ebd0 	.word	0x0801ebd0
 8010620:	00000414 	.word	0x00000414
 8010624:	0000043d 	.word	0x0000043d
 8010628:	00000481 	.word	0x00000481

0801062c <ProcessRadioRxError>:

static void ProcessRadioRxError( void )
{
 801062c:	b580      	push	{r7, lr}
 801062e:	af00      	add	r7, sp, #0
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );
 8010630:	2106      	movs	r1, #6
 8010632:	2005      	movs	r0, #5
 8010634:	f7ff ff66 	bl	8010504 <HandleRadioRxErrorTimeout>
}
 8010638:	46c0      	nop			; (mov r8, r8)
 801063a:	46bd      	mov	sp, r7
 801063c:	bd80      	pop	{r7, pc}

0801063e <ProcessRadioRxTimeout>:

static void ProcessRadioRxTimeout( void )
{
 801063e:	b580      	push	{r7, lr}
 8010640:	af00      	add	r7, sp, #0
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );
 8010642:	2104      	movs	r1, #4
 8010644:	2003      	movs	r0, #3
 8010646:	f7ff ff5d 	bl	8010504 <HandleRadioRxErrorTimeout>
}
 801064a:	46c0      	nop			; (mov r8, r8)
 801064c:	46bd      	mov	sp, r7
 801064e:	bd80      	pop	{r7, pc}

08010650 <LoRaMacHandleIrqEvents>:

static void LoRaMacHandleIrqEvents( void )
{
 8010650:	b580      	push	{r7, lr}
 8010652:	b084      	sub	sp, #16
 8010654:	af00      	add	r7, sp, #0
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8010656:	f3ef 8310 	mrs	r3, PRIMASK
 801065a:	607b      	str	r3, [r7, #4]
  return(result);
 801065c:	687b      	ldr	r3, [r7, #4]
    LoRaMacRadioEvents_t events;

    CRITICAL_SECTION_BEGIN( );
 801065e:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("cpsid i" : : : "memory");
 8010660:	b672      	cpsid	i
}
 8010662:	46c0      	nop			; (mov r8, r8)
    events = LoRaMacRadioEvents;
 8010664:	4b1f      	ldr	r3, [pc, #124]	; (80106e4 <LoRaMacHandleIrqEvents+0x94>)
 8010666:	681b      	ldr	r3, [r3, #0]
 8010668:	603b      	str	r3, [r7, #0]
    LoRaMacRadioEvents.Value = 0;
 801066a:	4b1e      	ldr	r3, [pc, #120]	; (80106e4 <LoRaMacHandleIrqEvents+0x94>)
 801066c:	2200      	movs	r2, #0
 801066e:	601a      	str	r2, [r3, #0]
 8010670:	68fb      	ldr	r3, [r7, #12]
 8010672:	60bb      	str	r3, [r7, #8]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8010674:	68bb      	ldr	r3, [r7, #8]
 8010676:	f383 8810 	msr	PRIMASK, r3
}
 801067a:	46c0      	nop			; (mov r8, r8)
    CRITICAL_SECTION_END( );

    if( events.Value != 0 )
 801067c:	683b      	ldr	r3, [r7, #0]
 801067e:	2b00      	cmp	r3, #0
 8010680:	d02c      	beq.n	80106dc <LoRaMacHandleIrqEvents+0x8c>
    {
        if( events.Events.TxDone == 1 )
 8010682:	003b      	movs	r3, r7
 8010684:	781b      	ldrb	r3, [r3, #0]
 8010686:	2210      	movs	r2, #16
 8010688:	4013      	ands	r3, r2
 801068a:	b2db      	uxtb	r3, r3
 801068c:	2b00      	cmp	r3, #0
 801068e:	d001      	beq.n	8010694 <LoRaMacHandleIrqEvents+0x44>
        {
            ProcessRadioTxDone( );
 8010690:	f7ff f8f2 	bl	800f878 <ProcessRadioTxDone>
        }
        if( events.Events.RxDone == 1 )
 8010694:	003b      	movs	r3, r7
 8010696:	781b      	ldrb	r3, [r3, #0]
 8010698:	2208      	movs	r2, #8
 801069a:	4013      	ands	r3, r2
 801069c:	b2db      	uxtb	r3, r3
 801069e:	2b00      	cmp	r3, #0
 80106a0:	d001      	beq.n	80106a6 <LoRaMacHandleIrqEvents+0x56>
        {
            ProcessRadioRxDone( );
 80106a2:	f7ff f9c1 	bl	800fa28 <ProcessRadioRxDone>
        }
        if( events.Events.TxTimeout == 1 )
 80106a6:	003b      	movs	r3, r7
 80106a8:	781b      	ldrb	r3, [r3, #0]
 80106aa:	2204      	movs	r2, #4
 80106ac:	4013      	ands	r3, r2
 80106ae:	b2db      	uxtb	r3, r3
 80106b0:	2b00      	cmp	r3, #0
 80106b2:	d001      	beq.n	80106b8 <LoRaMacHandleIrqEvents+0x68>
        {
            ProcessRadioTxTimeout( );
 80106b4:	f7ff fef0 	bl	8010498 <ProcessRadioTxTimeout>
        }
        if( events.Events.RxError == 1 )
 80106b8:	003b      	movs	r3, r7
 80106ba:	781b      	ldrb	r3, [r3, #0]
 80106bc:	2202      	movs	r2, #2
 80106be:	4013      	ands	r3, r2
 80106c0:	b2db      	uxtb	r3, r3
 80106c2:	2b00      	cmp	r3, #0
 80106c4:	d001      	beq.n	80106ca <LoRaMacHandleIrqEvents+0x7a>
        {
            ProcessRadioRxError( );
 80106c6:	f7ff ffb1 	bl	801062c <ProcessRadioRxError>
        }
        if( events.Events.RxTimeout == 1 )
 80106ca:	003b      	movs	r3, r7
 80106cc:	781b      	ldrb	r3, [r3, #0]
 80106ce:	2201      	movs	r2, #1
 80106d0:	4013      	ands	r3, r2
 80106d2:	b2db      	uxtb	r3, r3
 80106d4:	2b00      	cmp	r3, #0
 80106d6:	d001      	beq.n	80106dc <LoRaMacHandleIrqEvents+0x8c>
        {
            ProcessRadioRxTimeout( );
 80106d8:	f7ff ffb1 	bl	801063e <ProcessRadioRxTimeout>
        }
    }
}
 80106dc:	46c0      	nop			; (mov r8, r8)
 80106de:	46bd      	mov	sp, r7
 80106e0:	b004      	add	sp, #16
 80106e2:	bd80      	pop	{r7, pc}
 80106e4:	20000f50 	.word	0x20000f50

080106e8 <LoRaMacIsBusy>:

bool LoRaMacIsBusy( void )
{
 80106e8:	b580      	push	{r7, lr}
 80106ea:	af00      	add	r7, sp, #0
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 80106ec:	4a08      	ldr	r2, [pc, #32]	; (8010710 <LoRaMacIsBusy+0x28>)
 80106ee:	23d0      	movs	r3, #208	; 0xd0
 80106f0:	009b      	lsls	r3, r3, #2
 80106f2:	58d3      	ldr	r3, [r2, r3]
 80106f4:	2b00      	cmp	r3, #0
 80106f6:	d106      	bne.n	8010706 <LoRaMacIsBusy+0x1e>
        ( MacCtx.AllowRequests == LORAMAC_REQUEST_HANDLING_ON ) )
 80106f8:	4b05      	ldr	r3, [pc, #20]	; (8010710 <LoRaMacIsBusy+0x28>)
 80106fa:	4a06      	ldr	r2, [pc, #24]	; (8010714 <LoRaMacIsBusy+0x2c>)
 80106fc:	5c9b      	ldrb	r3, [r3, r2]
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 80106fe:	2b01      	cmp	r3, #1
 8010700:	d101      	bne.n	8010706 <LoRaMacIsBusy+0x1e>
    {
        return false;
 8010702:	2300      	movs	r3, #0
 8010704:	e000      	b.n	8010708 <LoRaMacIsBusy+0x20>
    }
    return true;
 8010706:	2301      	movs	r3, #1
}
 8010708:	0018      	movs	r0, r3
 801070a:	46bd      	mov	sp, r7
 801070c:	bd80      	pop	{r7, pc}
 801070e:	46c0      	nop			; (mov r8, r8)
 8010710:	200008ec 	.word	0x200008ec
 8010714:	00000482 	.word	0x00000482

08010718 <LoRaMacEnableRequests>:


static void LoRaMacEnableRequests( LoRaMacRequestHandling_t requestState )
{
 8010718:	b580      	push	{r7, lr}
 801071a:	b082      	sub	sp, #8
 801071c:	af00      	add	r7, sp, #0
 801071e:	0002      	movs	r2, r0
 8010720:	1dfb      	adds	r3, r7, #7
 8010722:	701a      	strb	r2, [r3, #0]
    MacCtx.AllowRequests = requestState;
 8010724:	4b04      	ldr	r3, [pc, #16]	; (8010738 <LoRaMacEnableRequests+0x20>)
 8010726:	1dfa      	adds	r2, r7, #7
 8010728:	4904      	ldr	r1, [pc, #16]	; (801073c <LoRaMacEnableRequests+0x24>)
 801072a:	7812      	ldrb	r2, [r2, #0]
 801072c:	545a      	strb	r2, [r3, r1]
}
 801072e:	46c0      	nop			; (mov r8, r8)
 8010730:	46bd      	mov	sp, r7
 8010732:	b002      	add	sp, #8
 8010734:	bd80      	pop	{r7, pc}
 8010736:	46c0      	nop			; (mov r8, r8)
 8010738:	200008ec 	.word	0x200008ec
 801073c:	00000482 	.word	0x00000482

08010740 <LoRaMacHandleRequestEvents>:

static void LoRaMacHandleRequestEvents( void )
{
 8010740:	b580      	push	{r7, lr}
 8010742:	b082      	sub	sp, #8
 8010744:	af00      	add	r7, sp, #0
    // Handle events
    LoRaMacFlags_t reqEvents = MacCtx.MacFlags;
 8010746:	1d3b      	adds	r3, r7, #4
 8010748:	4a2c      	ldr	r2, [pc, #176]	; (80107fc <LoRaMacHandleRequestEvents+0xbc>)
 801074a:	492d      	ldr	r1, [pc, #180]	; (8010800 <LoRaMacHandleRequestEvents+0xc0>)
 801074c:	5c52      	ldrb	r2, [r2, r1]
 801074e:	701a      	strb	r2, [r3, #0]

    if( MacCtx.MacState == LORAMAC_IDLE )
 8010750:	4a2a      	ldr	r2, [pc, #168]	; (80107fc <LoRaMacHandleRequestEvents+0xbc>)
 8010752:	23d0      	movs	r3, #208	; 0xd0
 8010754:	009b      	lsls	r3, r3, #2
 8010756:	58d3      	ldr	r3, [r2, r3]
 8010758:	2b00      	cmp	r3, #0
 801075a:	d14a      	bne.n	80107f2 <LoRaMacHandleRequestEvents+0xb2>
    {
        // Update event bits
        if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 801075c:	4b27      	ldr	r3, [pc, #156]	; (80107fc <LoRaMacHandleRequestEvents+0xbc>)
 801075e:	4a28      	ldr	r2, [pc, #160]	; (8010800 <LoRaMacHandleRequestEvents+0xc0>)
 8010760:	5c9b      	ldrb	r3, [r3, r2]
 8010762:	2201      	movs	r2, #1
 8010764:	4013      	ands	r3, r2
 8010766:	b2db      	uxtb	r3, r3
 8010768:	2b00      	cmp	r3, #0
 801076a:	d005      	beq.n	8010778 <LoRaMacHandleRequestEvents+0x38>
        {
            MacCtx.MacFlags.Bits.McpsReq = 0;
 801076c:	4b23      	ldr	r3, [pc, #140]	; (80107fc <LoRaMacHandleRequestEvents+0xbc>)
 801076e:	4a24      	ldr	r2, [pc, #144]	; (8010800 <LoRaMacHandleRequestEvents+0xc0>)
 8010770:	5c99      	ldrb	r1, [r3, r2]
 8010772:	2001      	movs	r0, #1
 8010774:	4381      	bics	r1, r0
 8010776:	5499      	strb	r1, [r3, r2]
        }

        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 8010778:	4b20      	ldr	r3, [pc, #128]	; (80107fc <LoRaMacHandleRequestEvents+0xbc>)
 801077a:	4a21      	ldr	r2, [pc, #132]	; (8010800 <LoRaMacHandleRequestEvents+0xc0>)
 801077c:	5c9b      	ldrb	r3, [r3, r2]
 801077e:	2204      	movs	r2, #4
 8010780:	4013      	ands	r3, r2
 8010782:	b2db      	uxtb	r3, r3
 8010784:	2b00      	cmp	r3, #0
 8010786:	d005      	beq.n	8010794 <LoRaMacHandleRequestEvents+0x54>
        {
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 8010788:	4b1c      	ldr	r3, [pc, #112]	; (80107fc <LoRaMacHandleRequestEvents+0xbc>)
 801078a:	4a1d      	ldr	r2, [pc, #116]	; (8010800 <LoRaMacHandleRequestEvents+0xc0>)
 801078c:	5c99      	ldrb	r1, [r3, r2]
 801078e:	2004      	movs	r0, #4
 8010790:	4381      	bics	r1, r0
 8010792:	5499      	strb	r1, [r3, r2]
        }

        // Allow requests again
        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );
 8010794:	2001      	movs	r0, #1
 8010796:	f7ff ffbf 	bl	8010718 <LoRaMacEnableRequests>

        // Handle callbacks
        if( reqEvents.Bits.McpsReq == 1 )
 801079a:	1d3b      	adds	r3, r7, #4
 801079c:	781b      	ldrb	r3, [r3, #0]
 801079e:	2201      	movs	r2, #1
 80107a0:	4013      	ands	r3, r2
 80107a2:	b2db      	uxtb	r3, r3
 80107a4:	2b00      	cmp	r3, #0
 80107a6:	d007      	beq.n	80107b8 <LoRaMacHandleRequestEvents+0x78>
        {
            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );
 80107a8:	4a14      	ldr	r2, [pc, #80]	; (80107fc <LoRaMacHandleRequestEvents+0xbc>)
 80107aa:	23d1      	movs	r3, #209	; 0xd1
 80107ac:	009b      	lsls	r3, r3, #2
 80107ae:	58d3      	ldr	r3, [r2, r3]
 80107b0:	681b      	ldr	r3, [r3, #0]
 80107b2:	4a14      	ldr	r2, [pc, #80]	; (8010804 <LoRaMacHandleRequestEvents+0xc4>)
 80107b4:	0010      	movs	r0, r2
 80107b6:	4798      	blx	r3
        }

        if( reqEvents.Bits.MlmeReq == 1 )
 80107b8:	1d3b      	adds	r3, r7, #4
 80107ba:	781b      	ldrb	r3, [r3, #0]
 80107bc:	2204      	movs	r2, #4
 80107be:	4013      	ands	r3, r2
 80107c0:	b2db      	uxtb	r3, r3
 80107c2:	2b00      	cmp	r3, #0
 80107c4:	d00d      	beq.n	80107e2 <LoRaMacHandleRequestEvents+0xa2>
        {
            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );
 80107c6:	4b10      	ldr	r3, [pc, #64]	; (8010808 <LoRaMacHandleRequestEvents+0xc8>)
 80107c8:	0018      	movs	r0, r3
 80107ca:	f005 f90d 	bl	80159e8 <LoRaMacConfirmQueueHandleCb>
            if( LoRaMacConfirmQueueGetCnt( ) > 0 )
 80107ce:	f005 f96d 	bl	8015aac <LoRaMacConfirmQueueGetCnt>
 80107d2:	1e03      	subs	r3, r0, #0
 80107d4:	d005      	beq.n	80107e2 <LoRaMacHandleRequestEvents+0xa2>
            {
                MacCtx.MacFlags.Bits.MlmeReq = 1;
 80107d6:	4b09      	ldr	r3, [pc, #36]	; (80107fc <LoRaMacHandleRequestEvents+0xbc>)
 80107d8:	4a09      	ldr	r2, [pc, #36]	; (8010800 <LoRaMacHandleRequestEvents+0xc0>)
 80107da:	5c99      	ldrb	r1, [r3, r2]
 80107dc:	2004      	movs	r0, #4
 80107de:	4301      	orrs	r1, r0
 80107e0:	5499      	strb	r1, [r3, r2]
            }
        }

        // Start beaconing again
        LoRaMacClassBResumeBeaconing( );
 80107e2:	f004 fc52 	bl	801508a <LoRaMacClassBResumeBeaconing>

        // Procedure done. Reset variables.
        MacCtx.MacFlags.Bits.MacDone = 0;
 80107e6:	4b05      	ldr	r3, [pc, #20]	; (80107fc <LoRaMacHandleRequestEvents+0xbc>)
 80107e8:	4a05      	ldr	r2, [pc, #20]	; (8010800 <LoRaMacHandleRequestEvents+0xc0>)
 80107ea:	5c99      	ldrb	r1, [r3, r2]
 80107ec:	2020      	movs	r0, #32
 80107ee:	4381      	bics	r1, r0
 80107f0:	5499      	strb	r1, [r3, r2]
    }
}
 80107f2:	46c0      	nop			; (mov r8, r8)
 80107f4:	46bd      	mov	sp, r7
 80107f6:	b002      	add	sp, #8
 80107f8:	bd80      	pop	{r7, pc}
 80107fa:	46c0      	nop			; (mov r8, r8)
 80107fc:	200008ec 	.word	0x200008ec
 8010800:	00000481 	.word	0x00000481
 8010804:	20000d28 	.word	0x20000d28
 8010808:	20000d3c 	.word	0x20000d3c

0801080c <LoRaMacHandleScheduleUplinkEvent>:

static void LoRaMacHandleScheduleUplinkEvent( void )
{
 801080c:	b580      	push	{r7, lr}
 801080e:	b082      	sub	sp, #8
 8010810:	af00      	add	r7, sp, #0
    // Handle events
    if( MacCtx.MacState == LORAMAC_IDLE )
 8010812:	4a0b      	ldr	r2, [pc, #44]	; (8010840 <LoRaMacHandleScheduleUplinkEvent+0x34>)
 8010814:	23d0      	movs	r3, #208	; 0xd0
 8010816:	009b      	lsls	r3, r3, #2
 8010818:	58d3      	ldr	r3, [r2, r3]
 801081a:	2b00      	cmp	r3, #0
 801081c:	d10c      	bne.n	8010838 <LoRaMacHandleScheduleUplinkEvent+0x2c>
    {
        // Verify if sticky MAC commands are pending or not
        bool isStickyMacCommandPending = false;
 801081e:	1dfb      	adds	r3, r7, #7
 8010820:	2200      	movs	r2, #0
 8010822:	701a      	strb	r2, [r3, #0]
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 8010824:	1dfb      	adds	r3, r7, #7
 8010826:	0018      	movs	r0, r3
 8010828:	f004 ff38 	bl	801569c <LoRaMacCommandsStickyCmdsPending>
        if( isStickyMacCommandPending == true )
 801082c:	1dfb      	adds	r3, r7, #7
 801082e:	781b      	ldrb	r3, [r3, #0]
 8010830:	2b00      	cmp	r3, #0
 8010832:	d001      	beq.n	8010838 <LoRaMacHandleScheduleUplinkEvent+0x2c>
        {// Setup MLME indication
            SetMlmeScheduleUplinkIndication( );
 8010834:	f000 fd02 	bl	801123c <SetMlmeScheduleUplinkIndication>
        }
    }
}
 8010838:	46c0      	nop			; (mov r8, r8)
 801083a:	46bd      	mov	sp, r7
 801083c:	b002      	add	sp, #8
 801083e:	bd80      	pop	{r7, pc}
 8010840:	200008ec 	.word	0x200008ec

08010844 <LoRaMacHandleIndicationEvents>:

static void LoRaMacHandleIndicationEvents( void )
{
 8010844:	b580      	push	{r7, lr}
 8010846:	b088      	sub	sp, #32
 8010848:	af00      	add	r7, sp, #0
    // Handle MLME indication
    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )
 801084a:	4b26      	ldr	r3, [pc, #152]	; (80108e4 <LoRaMacHandleIndicationEvents+0xa0>)
 801084c:	4a26      	ldr	r2, [pc, #152]	; (80108e8 <LoRaMacHandleIndicationEvents+0xa4>)
 801084e:	5c9b      	ldrb	r3, [r3, r2]
 8010850:	2208      	movs	r2, #8
 8010852:	4013      	ands	r3, r2
 8010854:	b2db      	uxtb	r3, r3
 8010856:	2b00      	cmp	r3, #0
 8010858:	d00d      	beq.n	8010876 <LoRaMacHandleIndicationEvents+0x32>
    {
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 801085a:	4b22      	ldr	r3, [pc, #136]	; (80108e4 <LoRaMacHandleIndicationEvents+0xa0>)
 801085c:	4a22      	ldr	r2, [pc, #136]	; (80108e8 <LoRaMacHandleIndicationEvents+0xa4>)
 801085e:	5c99      	ldrb	r1, [r3, r2]
 8010860:	2008      	movs	r0, #8
 8010862:	4381      	bics	r1, r0
 8010864:	5499      	strb	r1, [r3, r2]
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication );
 8010866:	4a1f      	ldr	r2, [pc, #124]	; (80108e4 <LoRaMacHandleIndicationEvents+0xa0>)
 8010868:	23d1      	movs	r3, #209	; 0xd1
 801086a:	009b      	lsls	r3, r3, #2
 801086c:	58d3      	ldr	r3, [r2, r3]
 801086e:	68db      	ldr	r3, [r3, #12]
 8010870:	4a1e      	ldr	r2, [pc, #120]	; (80108ec <LoRaMacHandleIndicationEvents+0xa8>)
 8010872:	0010      	movs	r0, r2
 8010874:	4798      	blx	r3
    }

    if( MacCtx.MacFlags.Bits.MlmeSchedUplinkInd == 1 )
 8010876:	4b1b      	ldr	r3, [pc, #108]	; (80108e4 <LoRaMacHandleIndicationEvents+0xa0>)
 8010878:	4a1b      	ldr	r2, [pc, #108]	; (80108e8 <LoRaMacHandleIndicationEvents+0xa4>)
 801087a:	5c9b      	ldrb	r3, [r3, r2]
 801087c:	2210      	movs	r2, #16
 801087e:	4013      	ands	r3, r2
 8010880:	b2db      	uxtb	r3, r3
 8010882:	2b00      	cmp	r3, #0
 8010884:	d013      	beq.n	80108ae <LoRaMacHandleIndicationEvents+0x6a>
    {
        MlmeIndication_t schduleUplinkIndication;
        schduleUplinkIndication.MlmeIndication = MLME_SCHEDULE_UPLINK;
 8010886:	1d3b      	adds	r3, r7, #4
 8010888:	2206      	movs	r2, #6
 801088a:	701a      	strb	r2, [r3, #0]
        schduleUplinkIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 801088c:	1d3b      	adds	r3, r7, #4
 801088e:	2200      	movs	r2, #0
 8010890:	705a      	strb	r2, [r3, #1]

        MacCtx.MacPrimitives->MacMlmeIndication( &schduleUplinkIndication );
 8010892:	4a14      	ldr	r2, [pc, #80]	; (80108e4 <LoRaMacHandleIndicationEvents+0xa0>)
 8010894:	23d1      	movs	r3, #209	; 0xd1
 8010896:	009b      	lsls	r3, r3, #2
 8010898:	58d3      	ldr	r3, [r2, r3]
 801089a:	68db      	ldr	r3, [r3, #12]
 801089c:	1d3a      	adds	r2, r7, #4
 801089e:	0010      	movs	r0, r2
 80108a0:	4798      	blx	r3
        MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 0;
 80108a2:	4b10      	ldr	r3, [pc, #64]	; (80108e4 <LoRaMacHandleIndicationEvents+0xa0>)
 80108a4:	4a10      	ldr	r2, [pc, #64]	; (80108e8 <LoRaMacHandleIndicationEvents+0xa4>)
 80108a6:	5c99      	ldrb	r1, [r3, r2]
 80108a8:	2010      	movs	r0, #16
 80108aa:	4381      	bics	r1, r0
 80108ac:	5499      	strb	r1, [r3, r2]
    }

    // Handle MCPS indication
    if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 80108ae:	4b0d      	ldr	r3, [pc, #52]	; (80108e4 <LoRaMacHandleIndicationEvents+0xa0>)
 80108b0:	4a0d      	ldr	r2, [pc, #52]	; (80108e8 <LoRaMacHandleIndicationEvents+0xa4>)
 80108b2:	5c9b      	ldrb	r3, [r3, r2]
 80108b4:	2202      	movs	r2, #2
 80108b6:	4013      	ands	r3, r2
 80108b8:	b2db      	uxtb	r3, r3
 80108ba:	2b00      	cmp	r3, #0
 80108bc:	d00d      	beq.n	80108da <LoRaMacHandleIndicationEvents+0x96>
    {
        MacCtx.MacFlags.Bits.McpsInd = 0;
 80108be:	4b09      	ldr	r3, [pc, #36]	; (80108e4 <LoRaMacHandleIndicationEvents+0xa0>)
 80108c0:	4a09      	ldr	r2, [pc, #36]	; (80108e8 <LoRaMacHandleIndicationEvents+0xa4>)
 80108c2:	5c99      	ldrb	r1, [r3, r2]
 80108c4:	2002      	movs	r0, #2
 80108c6:	4381      	bics	r1, r0
 80108c8:	5499      	strb	r1, [r3, r2]
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication );
 80108ca:	4a06      	ldr	r2, [pc, #24]	; (80108e4 <LoRaMacHandleIndicationEvents+0xa0>)
 80108cc:	23d1      	movs	r3, #209	; 0xd1
 80108ce:	009b      	lsls	r3, r3, #2
 80108d0:	58d3      	ldr	r3, [r2, r3]
 80108d2:	685b      	ldr	r3, [r3, #4]
 80108d4:	4a06      	ldr	r2, [pc, #24]	; (80108f0 <LoRaMacHandleIndicationEvents+0xac>)
 80108d6:	0010      	movs	r0, r2
 80108d8:	4798      	blx	r3
    }
}
 80108da:	46c0      	nop			; (mov r8, r8)
 80108dc:	46bd      	mov	sp, r7
 80108de:	b008      	add	sp, #32
 80108e0:	bd80      	pop	{r7, pc}
 80108e2:	46c0      	nop			; (mov r8, r8)
 80108e4:	200008ec 	.word	0x200008ec
 80108e8:	00000481 	.word	0x00000481
 80108ec:	20000d50 	.word	0x20000d50
 80108f0:	20000d08 	.word	0x20000d08

080108f4 <LoRaMacHandleMcpsRequest>:

static void LoRaMacHandleMcpsRequest( void )
{
 80108f4:	b590      	push	{r4, r7, lr}
 80108f6:	b083      	sub	sp, #12
 80108f8:	af00      	add	r7, sp, #0
    // Handle MCPS uplinks
    if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 80108fa:	4b39      	ldr	r3, [pc, #228]	; (80109e0 <LoRaMacHandleMcpsRequest+0xec>)
 80108fc:	4a39      	ldr	r2, [pc, #228]	; (80109e4 <LoRaMacHandleMcpsRequest+0xf0>)
 80108fe:	5c9b      	ldrb	r3, [r3, r2]
 8010900:	2201      	movs	r2, #1
 8010902:	4013      	ands	r3, r2
 8010904:	b2db      	uxtb	r3, r3
 8010906:	2b00      	cmp	r3, #0
 8010908:	d066      	beq.n	80109d8 <LoRaMacHandleMcpsRequest+0xe4>
    {
        bool stopRetransmission = false;
 801090a:	1dfb      	adds	r3, r7, #7
 801090c:	2200      	movs	r2, #0
 801090e:	701a      	strb	r2, [r3, #0]
        bool waitForRetransmission = false;
 8010910:	1dbb      	adds	r3, r7, #6
 8010912:	2200      	movs	r2, #0
 8010914:	701a      	strb	r2, [r3, #0]

        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||
 8010916:	4b32      	ldr	r3, [pc, #200]	; (80109e0 <LoRaMacHandleMcpsRequest+0xec>)
 8010918:	4a33      	ldr	r2, [pc, #204]	; (80109e8 <LoRaMacHandleMcpsRequest+0xf4>)
 801091a:	5c9b      	ldrb	r3, [r3, r2]
 801091c:	2b00      	cmp	r3, #0
 801091e:	d004      	beq.n	801092a <LoRaMacHandleMcpsRequest+0x36>
            ( MacCtx.McpsConfirm.McpsRequest == MCPS_PROPRIETARY ) )
 8010920:	4b2f      	ldr	r3, [pc, #188]	; (80109e0 <LoRaMacHandleMcpsRequest+0xec>)
 8010922:	4a31      	ldr	r2, [pc, #196]	; (80109e8 <LoRaMacHandleMcpsRequest+0xf4>)
 8010924:	5c9b      	ldrb	r3, [r3, r2]
        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||
 8010926:	2b03      	cmp	r3, #3
 8010928:	d105      	bne.n	8010936 <LoRaMacHandleMcpsRequest+0x42>
        {
            stopRetransmission = CheckRetransUnconfirmedUplink( );
 801092a:	1dfc      	adds	r4, r7, #7
 801092c:	f002 fb18 	bl	8012f60 <CheckRetransUnconfirmedUplink>
 8010930:	0003      	movs	r3, r0
 8010932:	7023      	strb	r3, [r4, #0]
 8010934:	e026      	b.n	8010984 <LoRaMacHandleMcpsRequest+0x90>
        }
        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )
 8010936:	4b2a      	ldr	r3, [pc, #168]	; (80109e0 <LoRaMacHandleMcpsRequest+0xec>)
 8010938:	4a2b      	ldr	r2, [pc, #172]	; (80109e8 <LoRaMacHandleMcpsRequest+0xf4>)
 801093a:	5c9b      	ldrb	r3, [r3, r2]
 801093c:	2b01      	cmp	r3, #1
 801093e:	d121      	bne.n	8010984 <LoRaMacHandleMcpsRequest+0x90>
        {
            if( MacCtx.AckTimeoutRetry == true )
 8010940:	4b27      	ldr	r3, [pc, #156]	; (80109e0 <LoRaMacHandleMcpsRequest+0xec>)
 8010942:	4a2a      	ldr	r2, [pc, #168]	; (80109ec <LoRaMacHandleMcpsRequest+0xf8>)
 8010944:	5c9b      	ldrb	r3, [r3, r2]
 8010946:	2b00      	cmp	r3, #0
 8010948:	d019      	beq.n	801097e <LoRaMacHandleMcpsRequest+0x8a>
            {
                stopRetransmission = CheckRetransConfirmedUplink( );
 801094a:	1dfc      	adds	r4, r7, #7
 801094c:	f002 fb3c 	bl	8012fc8 <CheckRetransConfirmedUplink>
 8010950:	0003      	movs	r3, r0
 8010952:	7023      	strb	r3, [r4, #0]

                if( MacCtx.NvmCtx->Version.Fields.Minor == 0 )
 8010954:	4b22      	ldr	r3, [pc, #136]	; (80109e0 <LoRaMacHandleMcpsRequest+0xec>)
 8010956:	4a26      	ldr	r2, [pc, #152]	; (80109f0 <LoRaMacHandleMcpsRequest+0xfc>)
 8010958:	589a      	ldr	r2, [r3, r2]
 801095a:	23e9      	movs	r3, #233	; 0xe9
 801095c:	005b      	lsls	r3, r3, #1
 801095e:	5cd3      	ldrb	r3, [r2, r3]
 8010960:	2b00      	cmp	r3, #0
 8010962:	d10f      	bne.n	8010984 <LoRaMacHandleMcpsRequest+0x90>
                {
                    if( stopRetransmission == false )
 8010964:	1dfb      	adds	r3, r7, #7
 8010966:	781b      	ldrb	r3, [r3, #0]
 8010968:	2201      	movs	r2, #1
 801096a:	4053      	eors	r3, r2
 801096c:	b2db      	uxtb	r3, r3
 801096e:	2b00      	cmp	r3, #0
 8010970:	d002      	beq.n	8010978 <LoRaMacHandleMcpsRequest+0x84>
                    {
                        AckTimeoutRetriesProcess( );
 8010972:	f002 fb9d 	bl	80130b0 <AckTimeoutRetriesProcess>
 8010976:	e005      	b.n	8010984 <LoRaMacHandleMcpsRequest+0x90>
                    }
                    else
                    {
                        AckTimeoutRetriesFinalize( );
 8010978:	f002 fbe8 	bl	801314c <AckTimeoutRetriesFinalize>
 801097c:	e002      	b.n	8010984 <LoRaMacHandleMcpsRequest+0x90>
                    }
                }
            }
            else
            {
                waitForRetransmission = true;
 801097e:	1dbb      	adds	r3, r7, #6
 8010980:	2201      	movs	r2, #1
 8010982:	701a      	strb	r2, [r3, #0]
            }
        }

        if( stopRetransmission == true )
 8010984:	1dfb      	adds	r3, r7, #7
 8010986:	781b      	ldrb	r3, [r3, #0]
 8010988:	2b00      	cmp	r3, #0
 801098a:	d011      	beq.n	80109b0 <LoRaMacHandleMcpsRequest+0xbc>
        {// Stop retransmission
            TimerStop( &MacCtx.TxDelayedTimer );
 801098c:	4b19      	ldr	r3, [pc, #100]	; (80109f4 <LoRaMacHandleMcpsRequest+0x100>)
 801098e:	0018      	movs	r0, r3
 8010990:	f00a fb54 	bl	801b03c <TimerStop>
            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 8010994:	4a12      	ldr	r2, [pc, #72]	; (80109e0 <LoRaMacHandleMcpsRequest+0xec>)
 8010996:	23d0      	movs	r3, #208	; 0xd0
 8010998:	009b      	lsls	r3, r3, #2
 801099a:	58d3      	ldr	r3, [r2, r3]
 801099c:	2220      	movs	r2, #32
 801099e:	4393      	bics	r3, r2
 80109a0:	0019      	movs	r1, r3
 80109a2:	4a0f      	ldr	r2, [pc, #60]	; (80109e0 <LoRaMacHandleMcpsRequest+0xec>)
 80109a4:	23d0      	movs	r3, #208	; 0xd0
 80109a6:	009b      	lsls	r3, r3, #2
 80109a8:	50d1      	str	r1, [r2, r3]
            StopRetransmission( );
 80109aa:	f002 fb35 	bl	8013018 <StopRetransmission>
            MacCtx.AckTimeoutRetry = false;
            // Sends the same frame again
            OnTxDelayedTimerEvent( NULL );
        }
    }
}
 80109ae:	e013      	b.n	80109d8 <LoRaMacHandleMcpsRequest+0xe4>
        else if( waitForRetransmission == false )
 80109b0:	1dbb      	adds	r3, r7, #6
 80109b2:	781b      	ldrb	r3, [r3, #0]
 80109b4:	2201      	movs	r2, #1
 80109b6:	4053      	eors	r3, r2
 80109b8:	b2db      	uxtb	r3, r3
 80109ba:	2b00      	cmp	r3, #0
 80109bc:	d00c      	beq.n	80109d8 <LoRaMacHandleMcpsRequest+0xe4>
            MacCtx.MacFlags.Bits.MacDone = 0;
 80109be:	4b08      	ldr	r3, [pc, #32]	; (80109e0 <LoRaMacHandleMcpsRequest+0xec>)
 80109c0:	4a08      	ldr	r2, [pc, #32]	; (80109e4 <LoRaMacHandleMcpsRequest+0xf0>)
 80109c2:	5c99      	ldrb	r1, [r3, r2]
 80109c4:	2020      	movs	r0, #32
 80109c6:	4381      	bics	r1, r0
 80109c8:	5499      	strb	r1, [r3, r2]
            MacCtx.AckTimeoutRetry = false;
 80109ca:	4b05      	ldr	r3, [pc, #20]	; (80109e0 <LoRaMacHandleMcpsRequest+0xec>)
 80109cc:	4a07      	ldr	r2, [pc, #28]	; (80109ec <LoRaMacHandleMcpsRequest+0xf8>)
 80109ce:	2100      	movs	r1, #0
 80109d0:	5499      	strb	r1, [r3, r2]
            OnTxDelayedTimerEvent( NULL );
 80109d2:	2000      	movs	r0, #0
 80109d4:	f000 f8e8 	bl	8010ba8 <OnTxDelayedTimerEvent>
}
 80109d8:	46c0      	nop			; (mov r8, r8)
 80109da:	46bd      	mov	sp, r7
 80109dc:	b003      	add	sp, #12
 80109de:	bd90      	pop	{r4, r7, pc}
 80109e0:	200008ec 	.word	0x200008ec
 80109e4:	00000481 	.word	0x00000481
 80109e8:	0000043c 	.word	0x0000043c
 80109ec:	00000413 	.word	0x00000413
 80109f0:	00000484 	.word	0x00000484
 80109f4:	20000c54 	.word	0x20000c54

080109f8 <LoRaMacHandleMlmeRequest>:

static void LoRaMacHandleMlmeRequest( void )
{
 80109f8:	b580      	push	{r7, lr}
 80109fa:	af00      	add	r7, sp, #0
    // Handle join request
    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 80109fc:	4b1d      	ldr	r3, [pc, #116]	; (8010a74 <LoRaMacHandleMlmeRequest+0x7c>)
 80109fe:	4a1e      	ldr	r2, [pc, #120]	; (8010a78 <LoRaMacHandleMlmeRequest+0x80>)
 8010a00:	5c9b      	ldrb	r3, [r3, r2]
 8010a02:	2204      	movs	r2, #4
 8010a04:	4013      	ands	r3, r2
 8010a06:	b2db      	uxtb	r3, r3
 8010a08:	2b00      	cmp	r3, #0
 8010a0a:	d02f      	beq.n	8010a6c <LoRaMacHandleMlmeRequest+0x74>
    {
        if( ( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true ) )
 8010a0c:	2000      	movs	r0, #0
 8010a0e:	f004 ffd1 	bl	80159b4 <LoRaMacConfirmQueueIsCmdActive>
 8010a12:	1e03      	subs	r3, r0, #0
 8010a14:	d015      	beq.n	8010a42 <LoRaMacHandleMlmeRequest+0x4a>
        {
            if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )
 8010a16:	2000      	movs	r0, #0
 8010a18:	f004 ff74 	bl	8015904 <LoRaMacConfirmQueueGetStatus>
 8010a1c:	1e03      	subs	r3, r0, #0
 8010a1e:	d104      	bne.n	8010a2a <LoRaMacHandleMlmeRequest+0x32>
            {// Node joined successfully
                MacCtx.ChannelsNbTransCounter = 0;
 8010a20:	4a14      	ldr	r2, [pc, #80]	; (8010a74 <LoRaMacHandleMlmeRequest+0x7c>)
 8010a22:	2382      	movs	r3, #130	; 0x82
 8010a24:	00db      	lsls	r3, r3, #3
 8010a26:	2100      	movs	r1, #0
 8010a28:	54d1      	strb	r1, [r2, r3]
            }
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8010a2a:	4a12      	ldr	r2, [pc, #72]	; (8010a74 <LoRaMacHandleMlmeRequest+0x7c>)
 8010a2c:	23d0      	movs	r3, #208	; 0xd0
 8010a2e:	009b      	lsls	r3, r3, #2
 8010a30:	58d3      	ldr	r3, [r2, r3]
 8010a32:	2202      	movs	r2, #2
 8010a34:	4393      	bics	r3, r2
 8010a36:	0019      	movs	r1, r3
 8010a38:	4a0e      	ldr	r2, [pc, #56]	; (8010a74 <LoRaMacHandleMlmeRequest+0x7c>)
 8010a3a:	23d0      	movs	r3, #208	; 0xd0
 8010a3c:	009b      	lsls	r3, r3, #2
 8010a3e:	50d1      	str	r1, [r2, r3]
                 ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW_1 ) == true ) )
        {
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
        }
    }
}
 8010a40:	e014      	b.n	8010a6c <LoRaMacHandleMlmeRequest+0x74>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 8010a42:	2004      	movs	r0, #4
 8010a44:	f004 ffb6 	bl	80159b4 <LoRaMacConfirmQueueIsCmdActive>
 8010a48:	1e03      	subs	r3, r0, #0
 8010a4a:	d104      	bne.n	8010a56 <LoRaMacHandleMlmeRequest+0x5e>
                 ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW_1 ) == true ) )
 8010a4c:	2005      	movs	r0, #5
 8010a4e:	f004 ffb1 	bl	80159b4 <LoRaMacConfirmQueueIsCmdActive>
 8010a52:	1e03      	subs	r3, r0, #0
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 8010a54:	d00a      	beq.n	8010a6c <LoRaMacHandleMlmeRequest+0x74>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8010a56:	4a07      	ldr	r2, [pc, #28]	; (8010a74 <LoRaMacHandleMlmeRequest+0x7c>)
 8010a58:	23d0      	movs	r3, #208	; 0xd0
 8010a5a:	009b      	lsls	r3, r3, #2
 8010a5c:	58d3      	ldr	r3, [r2, r3]
 8010a5e:	2202      	movs	r2, #2
 8010a60:	4393      	bics	r3, r2
 8010a62:	0019      	movs	r1, r3
 8010a64:	4a03      	ldr	r2, [pc, #12]	; (8010a74 <LoRaMacHandleMlmeRequest+0x7c>)
 8010a66:	23d0      	movs	r3, #208	; 0xd0
 8010a68:	009b      	lsls	r3, r3, #2
 8010a6a:	50d1      	str	r1, [r2, r3]
}
 8010a6c:	46c0      	nop			; (mov r8, r8)
 8010a6e:	46bd      	mov	sp, r7
 8010a70:	bd80      	pop	{r7, pc}
 8010a72:	46c0      	nop			; (mov r8, r8)
 8010a74:	200008ec 	.word	0x200008ec
 8010a78:	00000481 	.word	0x00000481

08010a7c <LoRaMacCheckForBeaconAcquisition>:

static uint8_t LoRaMacCheckForBeaconAcquisition( void )
{
 8010a7c:	b580      	push	{r7, lr}
 8010a7e:	af00      	add	r7, sp, #0
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 8010a80:	200b      	movs	r0, #11
 8010a82:	f004 ff97 	bl	80159b4 <LoRaMacConfirmQueueIsCmdActive>
 8010a86:	1e03      	subs	r3, r0, #0
 8010a88:	d01c      	beq.n	8010ac4 <LoRaMacCheckForBeaconAcquisition+0x48>
        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )
 8010a8a:	4b10      	ldr	r3, [pc, #64]	; (8010acc <LoRaMacCheckForBeaconAcquisition+0x50>)
 8010a8c:	4a10      	ldr	r2, [pc, #64]	; (8010ad0 <LoRaMacCheckForBeaconAcquisition+0x54>)
 8010a8e:	5c9b      	ldrb	r3, [r3, r2]
 8010a90:	2201      	movs	r2, #1
 8010a92:	4013      	ands	r3, r2
 8010a94:	b2db      	uxtb	r3, r3
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 8010a96:	2b00      	cmp	r3, #0
 8010a98:	d114      	bne.n	8010ac4 <LoRaMacCheckForBeaconAcquisition+0x48>
    {
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 8010a9a:	4b0c      	ldr	r3, [pc, #48]	; (8010acc <LoRaMacCheckForBeaconAcquisition+0x50>)
 8010a9c:	4a0c      	ldr	r2, [pc, #48]	; (8010ad0 <LoRaMacCheckForBeaconAcquisition+0x54>)
 8010a9e:	5c9b      	ldrb	r3, [r3, r2]
 8010aa0:	2204      	movs	r2, #4
 8010aa2:	4013      	ands	r3, r2
 8010aa4:	b2db      	uxtb	r3, r3
 8010aa6:	2b00      	cmp	r3, #0
 8010aa8:	d00c      	beq.n	8010ac4 <LoRaMacCheckForBeaconAcquisition+0x48>
        {
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8010aaa:	4a08      	ldr	r2, [pc, #32]	; (8010acc <LoRaMacCheckForBeaconAcquisition+0x50>)
 8010aac:	23d0      	movs	r3, #208	; 0xd0
 8010aae:	009b      	lsls	r3, r3, #2
 8010ab0:	58d3      	ldr	r3, [r2, r3]
 8010ab2:	2202      	movs	r2, #2
 8010ab4:	4393      	bics	r3, r2
 8010ab6:	0019      	movs	r1, r3
 8010ab8:	4a04      	ldr	r2, [pc, #16]	; (8010acc <LoRaMacCheckForBeaconAcquisition+0x50>)
 8010aba:	23d0      	movs	r3, #208	; 0xd0
 8010abc:	009b      	lsls	r3, r3, #2
 8010abe:	50d1      	str	r1, [r2, r3]
            return 0x01;
 8010ac0:	2301      	movs	r3, #1
 8010ac2:	e000      	b.n	8010ac6 <LoRaMacCheckForBeaconAcquisition+0x4a>
        }
    }
    return 0x00;
 8010ac4:	2300      	movs	r3, #0
}
 8010ac6:	0018      	movs	r0, r3
 8010ac8:	46bd      	mov	sp, r7
 8010aca:	bd80      	pop	{r7, pc}
 8010acc:	200008ec 	.word	0x200008ec
 8010ad0:	00000481 	.word	0x00000481

08010ad4 <LoRaMacCheckForRxAbort>:

static void LoRaMacCheckForRxAbort( void )
{
 8010ad4:	b580      	push	{r7, lr}
 8010ad6:	af00      	add	r7, sp, #0
    // A error occurs during receiving
    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )
 8010ad8:	4a0f      	ldr	r2, [pc, #60]	; (8010b18 <LoRaMacCheckForRxAbort+0x44>)
 8010ada:	23d0      	movs	r3, #208	; 0xd0
 8010adc:	009b      	lsls	r3, r3, #2
 8010ade:	58d3      	ldr	r3, [r2, r3]
 8010ae0:	2280      	movs	r2, #128	; 0x80
 8010ae2:	4013      	ands	r3, r2
 8010ae4:	d015      	beq.n	8010b12 <LoRaMacCheckForRxAbort+0x3e>
    {
        MacCtx.MacState &= ~LORAMAC_RX_ABORT;
 8010ae6:	4a0c      	ldr	r2, [pc, #48]	; (8010b18 <LoRaMacCheckForRxAbort+0x44>)
 8010ae8:	23d0      	movs	r3, #208	; 0xd0
 8010aea:	009b      	lsls	r3, r3, #2
 8010aec:	58d3      	ldr	r3, [r2, r3]
 8010aee:	2280      	movs	r2, #128	; 0x80
 8010af0:	4393      	bics	r3, r2
 8010af2:	0019      	movs	r1, r3
 8010af4:	4a08      	ldr	r2, [pc, #32]	; (8010b18 <LoRaMacCheckForRxAbort+0x44>)
 8010af6:	23d0      	movs	r3, #208	; 0xd0
 8010af8:	009b      	lsls	r3, r3, #2
 8010afa:	50d1      	str	r1, [r2, r3]
        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8010afc:	4a06      	ldr	r2, [pc, #24]	; (8010b18 <LoRaMacCheckForRxAbort+0x44>)
 8010afe:	23d0      	movs	r3, #208	; 0xd0
 8010b00:	009b      	lsls	r3, r3, #2
 8010b02:	58d3      	ldr	r3, [r2, r3]
 8010b04:	2202      	movs	r2, #2
 8010b06:	4393      	bics	r3, r2
 8010b08:	0019      	movs	r1, r3
 8010b0a:	4a03      	ldr	r2, [pc, #12]	; (8010b18 <LoRaMacCheckForRxAbort+0x44>)
 8010b0c:	23d0      	movs	r3, #208	; 0xd0
 8010b0e:	009b      	lsls	r3, r3, #2
 8010b10:	50d1      	str	r1, [r2, r3]
    }
}
 8010b12:	46c0      	nop			; (mov r8, r8)
 8010b14:	46bd      	mov	sp, r7
 8010b16:	bd80      	pop	{r7, pc}
 8010b18:	200008ec 	.word	0x200008ec

08010b1c <LoRaMacProcess>:


void LoRaMacProcess( void )
{
 8010b1c:	b580      	push	{r7, lr}
 8010b1e:	b082      	sub	sp, #8
 8010b20:	af00      	add	r7, sp, #0
    uint8_t noTx = false;
 8010b22:	1dfb      	adds	r3, r7, #7
 8010b24:	2200      	movs	r2, #0
 8010b26:	701a      	strb	r2, [r3, #0]

    LoRaMacHandleIrqEvents( );
 8010b28:	f7ff fd92 	bl	8010650 <LoRaMacHandleIrqEvents>
    LoRaMacClassBProcess( );
 8010b2c:	f004 fb0a 	bl	8015144 <LoRaMacClassBProcess>

    // MAC proceeded a state and is ready to check
    if( MacCtx.MacFlags.Bits.MacDone == 1 )
 8010b30:	4b1b      	ldr	r3, [pc, #108]	; (8010ba0 <LoRaMacProcess+0x84>)
 8010b32:	4a1c      	ldr	r2, [pc, #112]	; (8010ba4 <LoRaMacProcess+0x88>)
 8010b34:	5c9b      	ldrb	r3, [r3, r2]
 8010b36:	2220      	movs	r2, #32
 8010b38:	4013      	ands	r3, r2
 8010b3a:	b2db      	uxtb	r3, r3
 8010b3c:	2b00      	cmp	r3, #0
 8010b3e:	d020      	beq.n	8010b82 <LoRaMacProcess+0x66>
    {
        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_OFF );
 8010b40:	2000      	movs	r0, #0
 8010b42:	f7ff fde9 	bl	8010718 <LoRaMacEnableRequests>
        LoRaMacCheckForRxAbort( );
 8010b46:	f7ff ffc5 	bl	8010ad4 <LoRaMacCheckForRxAbort>

        // An error occurs during transmitting
        if( IsRequestPending( ) > 0 )
 8010b4a:	f002 fb95 	bl	8013278 <IsRequestPending>
 8010b4e:	1e03      	subs	r3, r0, #0
 8010b50:	d008      	beq.n	8010b64 <LoRaMacProcess+0x48>
        {
            noTx |= LoRaMacCheckForBeaconAcquisition( );
 8010b52:	f7ff ff93 	bl	8010a7c <LoRaMacCheckForBeaconAcquisition>
 8010b56:	0003      	movs	r3, r0
 8010b58:	0019      	movs	r1, r3
 8010b5a:	1dfb      	adds	r3, r7, #7
 8010b5c:	1dfa      	adds	r2, r7, #7
 8010b5e:	7812      	ldrb	r2, [r2, #0]
 8010b60:	430a      	orrs	r2, r1
 8010b62:	701a      	strb	r2, [r3, #0]
        }

        if( noTx == 0x00 )
 8010b64:	1dfb      	adds	r3, r7, #7
 8010b66:	781b      	ldrb	r3, [r3, #0]
 8010b68:	2b00      	cmp	r3, #0
 8010b6a:	d103      	bne.n	8010b74 <LoRaMacProcess+0x58>
        {
            LoRaMacHandleMlmeRequest( );
 8010b6c:	f7ff ff44 	bl	80109f8 <LoRaMacHandleMlmeRequest>
            LoRaMacHandleMcpsRequest( );
 8010b70:	f7ff fec0 	bl	80108f4 <LoRaMacHandleMcpsRequest>
        }
        LoRaMacHandleRequestEvents( );
 8010b74:	f7ff fde4 	bl	8010740 <LoRaMacHandleRequestEvents>
        LoRaMacHandleScheduleUplinkEvent( );
 8010b78:	f7ff fe48 	bl	801080c <LoRaMacHandleScheduleUplinkEvent>
        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );
 8010b7c:	2001      	movs	r0, #1
 8010b7e:	f7ff fdcb 	bl	8010718 <LoRaMacEnableRequests>
    }
    LoRaMacHandleIndicationEvents( );
 8010b82:	f7ff fe5f 	bl	8010844 <LoRaMacHandleIndicationEvents>
    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )
 8010b86:	4a06      	ldr	r2, [pc, #24]	; (8010ba0 <LoRaMacProcess+0x84>)
 8010b88:	2390      	movs	r3, #144	; 0x90
 8010b8a:	00db      	lsls	r3, r3, #3
 8010b8c:	5cd3      	ldrb	r3, [r2, r3]
 8010b8e:	2b02      	cmp	r3, #2
 8010b90:	d101      	bne.n	8010b96 <LoRaMacProcess+0x7a>
    {
        OpenContinuousRxCWindow( );
 8010b92:	f001 fe01 	bl	8012798 <OpenContinuousRxCWindow>
    }
}
 8010b96:	46c0      	nop			; (mov r8, r8)
 8010b98:	46bd      	mov	sp, r7
 8010b9a:	b002      	add	sp, #8
 8010b9c:	bd80      	pop	{r7, pc}
 8010b9e:	46c0      	nop			; (mov r8, r8)
 8010ba0:	200008ec 	.word	0x200008ec
 8010ba4:	00000481 	.word	0x00000481

08010ba8 <OnTxDelayedTimerEvent>:

static void OnTxDelayedTimerEvent( void* context )
{
 8010ba8:	b580      	push	{r7, lr}
 8010baa:	b082      	sub	sp, #8
 8010bac:	af00      	add	r7, sp, #0
 8010bae:	6078      	str	r0, [r7, #4]
    TimerStop( &MacCtx.TxDelayedTimer );
 8010bb0:	4b19      	ldr	r3, [pc, #100]	; (8010c18 <OnTxDelayedTimerEvent+0x70>)
 8010bb2:	0018      	movs	r0, r3
 8010bb4:	f00a fa42 	bl	801b03c <TimerStop>
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 8010bb8:	4a18      	ldr	r2, [pc, #96]	; (8010c1c <OnTxDelayedTimerEvent+0x74>)
 8010bba:	23d0      	movs	r3, #208	; 0xd0
 8010bbc:	009b      	lsls	r3, r3, #2
 8010bbe:	58d3      	ldr	r3, [r2, r3]
 8010bc0:	2220      	movs	r2, #32
 8010bc2:	4393      	bics	r3, r2
 8010bc4:	0019      	movs	r1, r3
 8010bc6:	4a15      	ldr	r2, [pc, #84]	; (8010c1c <OnTxDelayedTimerEvent+0x74>)
 8010bc8:	23d0      	movs	r3, #208	; 0xd0
 8010bca:	009b      	lsls	r3, r3, #2
 8010bcc:	50d1      	str	r1, [r2, r3]

    // Schedule frame, allow delayed frame transmissions
    switch( ScheduleTx( true ) )
 8010bce:	2001      	movs	r0, #1
 8010bd0:	f001 fa42 	bl	8012058 <ScheduleTx>
 8010bd4:	1e03      	subs	r3, r0, #0
 8010bd6:	d01a      	beq.n	8010c0e <OnTxDelayedTimerEvent+0x66>
 8010bd8:	2b0b      	cmp	r3, #11
 8010bda:	d018      	beq.n	8010c0e <OnTxDelayedTimerEvent+0x66>
            break;
        }
        default:
        {
            // Stop retransmission attempt
            MacCtx.McpsConfirm.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;
 8010bdc:	4b0f      	ldr	r3, [pc, #60]	; (8010c1c <OnTxDelayedTimerEvent+0x74>)
 8010bde:	4a10      	ldr	r2, [pc, #64]	; (8010c20 <OnTxDelayedTimerEvent+0x78>)
 8010be0:	589b      	ldr	r3, [r3, r2]
 8010be2:	22f9      	movs	r2, #249	; 0xf9
 8010be4:	569b      	ldrsb	r3, [r3, r2]
 8010be6:	b2d9      	uxtb	r1, r3
 8010be8:	4b0c      	ldr	r3, [pc, #48]	; (8010c1c <OnTxDelayedTimerEvent+0x74>)
 8010bea:	4a0e      	ldr	r2, [pc, #56]	; (8010c24 <OnTxDelayedTimerEvent+0x7c>)
 8010bec:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 8010bee:	4b0b      	ldr	r3, [pc, #44]	; (8010c1c <OnTxDelayedTimerEvent+0x74>)
 8010bf0:	4a0d      	ldr	r2, [pc, #52]	; (8010c28 <OnTxDelayedTimerEvent+0x80>)
 8010bf2:	5c99      	ldrb	r1, [r3, r2]
 8010bf4:	4b09      	ldr	r3, [pc, #36]	; (8010c1c <OnTxDelayedTimerEvent+0x74>)
 8010bf6:	4a0d      	ldr	r2, [pc, #52]	; (8010c2c <OnTxDelayedTimerEvent+0x84>)
 8010bf8:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 8010bfa:	4b08      	ldr	r3, [pc, #32]	; (8010c1c <OnTxDelayedTimerEvent+0x74>)
 8010bfc:	4a0c      	ldr	r2, [pc, #48]	; (8010c30 <OnTxDelayedTimerEvent+0x88>)
 8010bfe:	2109      	movs	r1, #9
 8010c00:	5499      	strb	r1, [r3, r2]
            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );
 8010c02:	2009      	movs	r0, #9
 8010c04:	f004 fea4 	bl	8015950 <LoRaMacConfirmQueueSetStatusCmn>
            StopRetransmission( );
 8010c08:	f002 fa06 	bl	8013018 <StopRetransmission>
            break;
 8010c0c:	e000      	b.n	8010c10 <OnTxDelayedTimerEvent+0x68>
            break;
 8010c0e:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 8010c10:	46c0      	nop			; (mov r8, r8)
 8010c12:	46bd      	mov	sp, r7
 8010c14:	b002      	add	sp, #8
 8010c16:	bd80      	pop	{r7, pc}
 8010c18:	20000c54 	.word	0x20000c54
 8010c1c:	200008ec 	.word	0x200008ec
 8010c20:	00000484 	.word	0x00000484
 8010c24:	0000043e 	.word	0x0000043e
 8010c28:	00000412 	.word	0x00000412
 8010c2c:	00000441 	.word	0x00000441
 8010c30:	0000043d 	.word	0x0000043d

08010c34 <OnRxWindow1TimerEvent>:

static void OnRxWindow1TimerEvent( void* context )
{
 8010c34:	b580      	push	{r7, lr}
 8010c36:	b082      	sub	sp, #8
 8010c38:	af00      	add	r7, sp, #0
 8010c3a:	6078      	str	r0, [r7, #4]
    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;
 8010c3c:	4b1a      	ldr	r3, [pc, #104]	; (8010ca8 <OnRxWindow1TimerEvent+0x74>)
 8010c3e:	4a1b      	ldr	r2, [pc, #108]	; (8010cac <OnRxWindow1TimerEvent+0x78>)
 8010c40:	5c99      	ldrb	r1, [r3, r2]
 8010c42:	4a19      	ldr	r2, [pc, #100]	; (8010ca8 <OnRxWindow1TimerEvent+0x74>)
 8010c44:	23ee      	movs	r3, #238	; 0xee
 8010c46:	009b      	lsls	r3, r3, #2
 8010c48:	54d1      	strb	r1, [r2, r3]
    MacCtx.RxWindow1Config.DrOffset = MacCtx.NvmCtx->MacParams.Rx1DrOffset;
 8010c4a:	4b17      	ldr	r3, [pc, #92]	; (8010ca8 <OnRxWindow1TimerEvent+0x74>)
 8010c4c:	4a18      	ldr	r2, [pc, #96]	; (8010cb0 <OnRxWindow1TimerEvent+0x7c>)
 8010c4e:	589a      	ldr	r2, [r3, r2]
 8010c50:	231a      	movs	r3, #26
 8010c52:	33ff      	adds	r3, #255	; 0xff
 8010c54:	5cd3      	ldrb	r3, [r2, r3]
 8010c56:	b259      	sxtb	r1, r3
 8010c58:	4b13      	ldr	r3, [pc, #76]	; (8010ca8 <OnRxWindow1TimerEvent+0x74>)
 8010c5a:	4a16      	ldr	r2, [pc, #88]	; (8010cb4 <OnRxWindow1TimerEvent+0x80>)
 8010c5c:	5499      	strb	r1, [r3, r2]
    MacCtx.RxWindow1Config.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;
 8010c5e:	4b12      	ldr	r3, [pc, #72]	; (8010ca8 <OnRxWindow1TimerEvent+0x74>)
 8010c60:	4a13      	ldr	r2, [pc, #76]	; (8010cb0 <OnRxWindow1TimerEvent+0x7c>)
 8010c62:	589a      	ldr	r2, [r3, r2]
 8010c64:	232e      	movs	r3, #46	; 0x2e
 8010c66:	33ff      	adds	r3, #255	; 0xff
 8010c68:	5cd1      	ldrb	r1, [r2, r3]
 8010c6a:	4a0f      	ldr	r2, [pc, #60]	; (8010ca8 <OnRxWindow1TimerEvent+0x74>)
 8010c6c:	23f2      	movs	r3, #242	; 0xf2
 8010c6e:	009b      	lsls	r3, r3, #2
 8010c70:	54d1      	strb	r1, [r2, r3]
    MacCtx.RxWindow1Config.RepeaterSupport = MacCtx.NvmCtx->RepeaterSupport;
 8010c72:	4b0d      	ldr	r3, [pc, #52]	; (8010ca8 <OnRxWindow1TimerEvent+0x74>)
 8010c74:	4a0e      	ldr	r2, [pc, #56]	; (8010cb0 <OnRxWindow1TimerEvent+0x7c>)
 8010c76:	589a      	ldr	r2, [r3, r2]
 8010c78:	2340      	movs	r3, #64	; 0x40
 8010c7a:	33ff      	adds	r3, #255	; 0xff
 8010c7c:	5cd1      	ldrb	r1, [r2, r3]
 8010c7e:	4b0a      	ldr	r3, [pc, #40]	; (8010ca8 <OnRxWindow1TimerEvent+0x74>)
 8010c80:	4a0d      	ldr	r2, [pc, #52]	; (8010cb8 <OnRxWindow1TimerEvent+0x84>)
 8010c82:	5499      	strb	r1, [r3, r2]
    MacCtx.RxWindow1Config.RxContinuous = false;
 8010c84:	4b08      	ldr	r3, [pc, #32]	; (8010ca8 <OnRxWindow1TimerEvent+0x74>)
 8010c86:	4a0d      	ldr	r2, [pc, #52]	; (8010cbc <OnRxWindow1TimerEvent+0x88>)
 8010c88:	2100      	movs	r1, #0
 8010c8a:	5499      	strb	r1, [r3, r2]
    MacCtx.RxWindow1Config.RxSlot = RX_SLOT_WIN_1;
 8010c8c:	4b06      	ldr	r3, [pc, #24]	; (8010ca8 <OnRxWindow1TimerEvent+0x74>)
 8010c8e:	4a0c      	ldr	r2, [pc, #48]	; (8010cc0 <OnRxWindow1TimerEvent+0x8c>)
 8010c90:	2100      	movs	r1, #0
 8010c92:	5499      	strb	r1, [r3, r2]

    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );
 8010c94:	4a0b      	ldr	r2, [pc, #44]	; (8010cc4 <OnRxWindow1TimerEvent+0x90>)
 8010c96:	4b0c      	ldr	r3, [pc, #48]	; (8010cc8 <OnRxWindow1TimerEvent+0x94>)
 8010c98:	0011      	movs	r1, r2
 8010c9a:	0018      	movs	r0, r3
 8010c9c:	f001 fd48 	bl	8012730 <RxWindowSetup>
}
 8010ca0:	46c0      	nop			; (mov r8, r8)
 8010ca2:	46bd      	mov	sp, r7
 8010ca4:	b002      	add	sp, #8
 8010ca6:	bd80      	pop	{r7, pc}
 8010ca8:	200008ec 	.word	0x200008ec
 8010cac:	00000415 	.word	0x00000415
 8010cb0:	00000484 	.word	0x00000484
 8010cb4:	000003bb 	.word	0x000003bb
 8010cb8:	000003c9 	.word	0x000003c9
 8010cbc:	000003ca 	.word	0x000003ca
 8010cc0:	000003cb 	.word	0x000003cb
 8010cc4:	20000ca4 	.word	0x20000ca4
 8010cc8:	20000c6c 	.word	0x20000c6c

08010ccc <OnRxWindow2TimerEvent>:

static void OnRxWindow2TimerEvent( void* context )
{
 8010ccc:	b580      	push	{r7, lr}
 8010cce:	b082      	sub	sp, #8
 8010cd0:	af00      	add	r7, sp, #0
 8010cd2:	6078      	str	r0, [r7, #4]
    // Check if we are processing Rx1 window.
    // If yes, we don't setup the Rx2 window.
    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 8010cd4:	4a1e      	ldr	r2, [pc, #120]	; (8010d50 <OnRxWindow2TimerEvent+0x84>)
 8010cd6:	2390      	movs	r3, #144	; 0x90
 8010cd8:	00db      	lsls	r3, r3, #3
 8010cda:	5cd3      	ldrb	r3, [r2, r3]
 8010cdc:	2b00      	cmp	r3, #0
 8010cde:	d032      	beq.n	8010d46 <OnRxWindow2TimerEvent+0x7a>
    {
        return;
    }
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 8010ce0:	4b1b      	ldr	r3, [pc, #108]	; (8010d50 <OnRxWindow2TimerEvent+0x84>)
 8010ce2:	4a1c      	ldr	r2, [pc, #112]	; (8010d54 <OnRxWindow2TimerEvent+0x88>)
 8010ce4:	5c99      	ldrb	r1, [r3, r2]
 8010ce6:	4a1a      	ldr	r2, [pc, #104]	; (8010d50 <OnRxWindow2TimerEvent+0x84>)
 8010ce8:	23f3      	movs	r3, #243	; 0xf3
 8010cea:	009b      	lsls	r3, r3, #2
 8010cec:	54d1      	strb	r1, [r2, r3]
    MacCtx.RxWindow2Config.Frequency = MacCtx.NvmCtx->MacParams.Rx2Channel.Frequency;
 8010cee:	4b18      	ldr	r3, [pc, #96]	; (8010d50 <OnRxWindow2TimerEvent+0x84>)
 8010cf0:	4a19      	ldr	r2, [pc, #100]	; (8010d58 <OnRxWindow2TimerEvent+0x8c>)
 8010cf2:	589a      	ldr	r2, [r3, r2]
 8010cf4:	238e      	movs	r3, #142	; 0x8e
 8010cf6:	005b      	lsls	r3, r3, #1
 8010cf8:	58d1      	ldr	r1, [r2, r3]
 8010cfa:	4a15      	ldr	r2, [pc, #84]	; (8010d50 <OnRxWindow2TimerEvent+0x84>)
 8010cfc:	23f4      	movs	r3, #244	; 0xf4
 8010cfe:	009b      	lsls	r3, r3, #2
 8010d00:	50d1      	str	r1, [r2, r3]
    MacCtx.RxWindow2Config.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;
 8010d02:	4b13      	ldr	r3, [pc, #76]	; (8010d50 <OnRxWindow2TimerEvent+0x84>)
 8010d04:	4a14      	ldr	r2, [pc, #80]	; (8010d58 <OnRxWindow2TimerEvent+0x8c>)
 8010d06:	589a      	ldr	r2, [r3, r2]
 8010d08:	232e      	movs	r3, #46	; 0x2e
 8010d0a:	33ff      	adds	r3, #255	; 0xff
 8010d0c:	5cd1      	ldrb	r1, [r2, r3]
 8010d0e:	4a10      	ldr	r2, [pc, #64]	; (8010d50 <OnRxWindow2TimerEvent+0x84>)
 8010d10:	23f7      	movs	r3, #247	; 0xf7
 8010d12:	009b      	lsls	r3, r3, #2
 8010d14:	54d1      	strb	r1, [r2, r3]
    MacCtx.RxWindow2Config.RepeaterSupport = MacCtx.NvmCtx->RepeaterSupport;
 8010d16:	4b0e      	ldr	r3, [pc, #56]	; (8010d50 <OnRxWindow2TimerEvent+0x84>)
 8010d18:	4a0f      	ldr	r2, [pc, #60]	; (8010d58 <OnRxWindow2TimerEvent+0x8c>)
 8010d1a:	589a      	ldr	r2, [r3, r2]
 8010d1c:	2340      	movs	r3, #64	; 0x40
 8010d1e:	33ff      	adds	r3, #255	; 0xff
 8010d20:	5cd1      	ldrb	r1, [r2, r3]
 8010d22:	4b0b      	ldr	r3, [pc, #44]	; (8010d50 <OnRxWindow2TimerEvent+0x84>)
 8010d24:	4a0d      	ldr	r2, [pc, #52]	; (8010d5c <OnRxWindow2TimerEvent+0x90>)
 8010d26:	5499      	strb	r1, [r3, r2]
    MacCtx.RxWindow2Config.RxContinuous = false;
 8010d28:	4b09      	ldr	r3, [pc, #36]	; (8010d50 <OnRxWindow2TimerEvent+0x84>)
 8010d2a:	4a0d      	ldr	r2, [pc, #52]	; (8010d60 <OnRxWindow2TimerEvent+0x94>)
 8010d2c:	2100      	movs	r1, #0
 8010d2e:	5499      	strb	r1, [r3, r2]
    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;
 8010d30:	4b07      	ldr	r3, [pc, #28]	; (8010d50 <OnRxWindow2TimerEvent+0x84>)
 8010d32:	4a0c      	ldr	r2, [pc, #48]	; (8010d64 <OnRxWindow2TimerEvent+0x98>)
 8010d34:	2101      	movs	r1, #1
 8010d36:	5499      	strb	r1, [r3, r2]

    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );
 8010d38:	4a0b      	ldr	r2, [pc, #44]	; (8010d68 <OnRxWindow2TimerEvent+0x9c>)
 8010d3a:	4b0c      	ldr	r3, [pc, #48]	; (8010d6c <OnRxWindow2TimerEvent+0xa0>)
 8010d3c:	0011      	movs	r1, r2
 8010d3e:	0018      	movs	r0, r3
 8010d40:	f001 fcf6 	bl	8012730 <RxWindowSetup>
 8010d44:	e000      	b.n	8010d48 <OnRxWindow2TimerEvent+0x7c>
        return;
 8010d46:	46c0      	nop			; (mov r8, r8)
}
 8010d48:	46bd      	mov	sp, r7
 8010d4a:	b002      	add	sp, #8
 8010d4c:	bd80      	pop	{r7, pc}
 8010d4e:	46c0      	nop			; (mov r8, r8)
 8010d50:	200008ec 	.word	0x200008ec
 8010d54:	00000415 	.word	0x00000415
 8010d58:	00000484 	.word	0x00000484
 8010d5c:	000003dd 	.word	0x000003dd
 8010d60:	000003de 	.word	0x000003de
 8010d64:	000003df 	.word	0x000003df
 8010d68:	20000cb8 	.word	0x20000cb8
 8010d6c:	20000c84 	.word	0x20000c84

08010d70 <OnAckTimeoutTimerEvent>:

static void OnAckTimeoutTimerEvent( void* context )
{
 8010d70:	b580      	push	{r7, lr}
 8010d72:	b082      	sub	sp, #8
 8010d74:	af00      	add	r7, sp, #0
 8010d76:	6078      	str	r0, [r7, #4]
    TimerStop( &MacCtx.AckTimeoutTimer );
 8010d78:	4b18      	ldr	r3, [pc, #96]	; (8010ddc <OnAckTimeoutTimerEvent+0x6c>)
 8010d7a:	0018      	movs	r0, r3
 8010d7c:	f00a f95e 	bl	801b03c <TimerStop>

    if( MacCtx.NodeAckRequested == true )
 8010d80:	4b17      	ldr	r3, [pc, #92]	; (8010de0 <OnAckTimeoutTimerEvent+0x70>)
 8010d82:	4a18      	ldr	r2, [pc, #96]	; (8010de4 <OnAckTimeoutTimerEvent+0x74>)
 8010d84:	5c9b      	ldrb	r3, [r3, r2]
 8010d86:	2b00      	cmp	r3, #0
 8010d88:	d003      	beq.n	8010d92 <OnAckTimeoutTimerEvent+0x22>
    {
        MacCtx.AckTimeoutRetry = true;
 8010d8a:	4b15      	ldr	r3, [pc, #84]	; (8010de0 <OnAckTimeoutTimerEvent+0x70>)
 8010d8c:	4a16      	ldr	r2, [pc, #88]	; (8010de8 <OnAckTimeoutTimerEvent+0x78>)
 8010d8e:	2101      	movs	r1, #1
 8010d90:	5499      	strb	r1, [r3, r2]
    }
    if( MacCtx.NvmCtx->DeviceClass == CLASS_C )
 8010d92:	4b13      	ldr	r3, [pc, #76]	; (8010de0 <OnAckTimeoutTimerEvent+0x70>)
 8010d94:	4a15      	ldr	r2, [pc, #84]	; (8010dec <OnAckTimeoutTimerEvent+0x7c>)
 8010d96:	589b      	ldr	r3, [r3, r2]
 8010d98:	22f0      	movs	r2, #240	; 0xf0
 8010d9a:	5c9b      	ldrb	r3, [r3, r2]
 8010d9c:	2b02      	cmp	r3, #2
 8010d9e:	d105      	bne.n	8010dac <OnAckTimeoutTimerEvent+0x3c>
    {
        MacCtx.MacFlags.Bits.MacDone = 1;
 8010da0:	4b0f      	ldr	r3, [pc, #60]	; (8010de0 <OnAckTimeoutTimerEvent+0x70>)
 8010da2:	4a13      	ldr	r2, [pc, #76]	; (8010df0 <OnAckTimeoutTimerEvent+0x80>)
 8010da4:	5c99      	ldrb	r1, [r3, r2]
 8010da6:	2020      	movs	r0, #32
 8010da8:	4301      	orrs	r1, r0
 8010daa:	5499      	strb	r1, [r3, r2]
    }
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8010dac:	4a0c      	ldr	r2, [pc, #48]	; (8010de0 <OnAckTimeoutTimerEvent+0x70>)
 8010dae:	23d2      	movs	r3, #210	; 0xd2
 8010db0:	009b      	lsls	r3, r3, #2
 8010db2:	58d3      	ldr	r3, [r2, r3]
 8010db4:	2b00      	cmp	r3, #0
 8010db6:	d00c      	beq.n	8010dd2 <OnAckTimeoutTimerEvent+0x62>
 8010db8:	4a09      	ldr	r2, [pc, #36]	; (8010de0 <OnAckTimeoutTimerEvent+0x70>)
 8010dba:	23d2      	movs	r3, #210	; 0xd2
 8010dbc:	009b      	lsls	r3, r3, #2
 8010dbe:	58d3      	ldr	r3, [r2, r3]
 8010dc0:	68db      	ldr	r3, [r3, #12]
 8010dc2:	2b00      	cmp	r3, #0
 8010dc4:	d005      	beq.n	8010dd2 <OnAckTimeoutTimerEvent+0x62>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 8010dc6:	4a06      	ldr	r2, [pc, #24]	; (8010de0 <OnAckTimeoutTimerEvent+0x70>)
 8010dc8:	23d2      	movs	r3, #210	; 0xd2
 8010dca:	009b      	lsls	r3, r3, #2
 8010dcc:	58d3      	ldr	r3, [r2, r3]
 8010dce:	68db      	ldr	r3, [r3, #12]
 8010dd0:	4798      	blx	r3
    }
}
 8010dd2:	46c0      	nop			; (mov r8, r8)
 8010dd4:	46bd      	mov	sp, r7
 8010dd6:	b002      	add	sp, #8
 8010dd8:	bd80      	pop	{r7, pc}
 8010dda:	46c0      	nop			; (mov r8, r8)
 8010ddc:	20000ce4 	.word	0x20000ce4
 8010de0:	200008ec 	.word	0x200008ec
 8010de4:	00000414 	.word	0x00000414
 8010de8:	00000413 	.word	0x00000413
 8010dec:	00000484 	.word	0x00000484
 8010df0:	00000481 	.word	0x00000481

08010df4 <GetFCntDown>:

static LoRaMacCryptoStatus_t GetFCntDown( AddressIdentifier_t addrID, FType_t fType, LoRaMacMessageData_t* macMsg, Version_t lrWanVersion,
                                          uint16_t maxFCntGap, FCntIdentifier_t* fCntID, uint32_t* currentDown )
{
 8010df4:	b590      	push	{r4, r7, lr}
 8010df6:	b085      	sub	sp, #20
 8010df8:	af00      	add	r7, sp, #0
 8010dfa:	60ba      	str	r2, [r7, #8]
 8010dfc:	607b      	str	r3, [r7, #4]
 8010dfe:	230f      	movs	r3, #15
 8010e00:	18fb      	adds	r3, r7, r3
 8010e02:	1c02      	adds	r2, r0, #0
 8010e04:	701a      	strb	r2, [r3, #0]
 8010e06:	230e      	movs	r3, #14
 8010e08:	18fb      	adds	r3, r7, r3
 8010e0a:	1c0a      	adds	r2, r1, #0
 8010e0c:	701a      	strb	r2, [r3, #0]
    if( ( macMsg == NULL ) || ( fCntID == NULL ) ||
 8010e0e:	68bb      	ldr	r3, [r7, #8]
 8010e10:	2b00      	cmp	r3, #0
 8010e12:	d005      	beq.n	8010e20 <GetFCntDown+0x2c>
 8010e14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e16:	2b00      	cmp	r3, #0
 8010e18:	d002      	beq.n	8010e20 <GetFCntDown+0x2c>
 8010e1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010e1c:	2b00      	cmp	r3, #0
 8010e1e:	d101      	bne.n	8010e24 <GetFCntDown+0x30>
        ( currentDown == NULL ) )
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 8010e20:	230a      	movs	r3, #10
 8010e22:	e042      	b.n	8010eaa <GetFCntDown+0xb6>
    }

    // Determine the frame counter identifier and choose counter from FCntList
    switch( addrID )
 8010e24:	230f      	movs	r3, #15
 8010e26:	18fb      	adds	r3, r7, r3
 8010e28:	781b      	ldrb	r3, [r3, #0]
 8010e2a:	2b04      	cmp	r3, #4
 8010e2c:	d82d      	bhi.n	8010e8a <GetFCntDown+0x96>
 8010e2e:	009a      	lsls	r2, r3, #2
 8010e30:	4b20      	ldr	r3, [pc, #128]	; (8010eb4 <GetFCntDown+0xc0>)
 8010e32:	18d3      	adds	r3, r2, r3
 8010e34:	681b      	ldr	r3, [r3, #0]
 8010e36:	469f      	mov	pc, r3
    {
        case UNICAST_DEV_ADDR:
            if( lrWanVersion.Fields.Minor == 1 )
 8010e38:	1d3b      	adds	r3, r7, #4
 8010e3a:	789b      	ldrb	r3, [r3, #2]
 8010e3c:	2b01      	cmp	r3, #1
 8010e3e:	d110      	bne.n	8010e62 <GetFCntDown+0x6e>
            {
                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )
 8010e40:	220e      	movs	r2, #14
 8010e42:	18bb      	adds	r3, r7, r2
 8010e44:	781b      	ldrb	r3, [r3, #0]
 8010e46:	2b00      	cmp	r3, #0
 8010e48:	d003      	beq.n	8010e52 <GetFCntDown+0x5e>
 8010e4a:	18bb      	adds	r3, r7, r2
 8010e4c:	781b      	ldrb	r3, [r3, #0]
 8010e4e:	2b03      	cmp	r3, #3
 8010e50:	d103      	bne.n	8010e5a <GetFCntDown+0x66>
                {
                    *fCntID = A_FCNT_DOWN;
 8010e52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e54:	2202      	movs	r2, #2
 8010e56:	701a      	strb	r2, [r3, #0]
            }
            else
            { // For LoRaWAN 1.0.X
                *fCntID = FCNT_DOWN;
            }
            break;
 8010e58:	e019      	b.n	8010e8e <GetFCntDown+0x9a>
                    *fCntID = N_FCNT_DOWN;
 8010e5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e5c:	2201      	movs	r2, #1
 8010e5e:	701a      	strb	r2, [r3, #0]
            break;
 8010e60:	e015      	b.n	8010e8e <GetFCntDown+0x9a>
                *fCntID = FCNT_DOWN;
 8010e62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e64:	2203      	movs	r2, #3
 8010e66:	701a      	strb	r2, [r3, #0]
            break;
 8010e68:	e011      	b.n	8010e8e <GetFCntDown+0x9a>
        case MULTICAST_0_ADDR:
            *fCntID = MC_FCNT_DOWN_0;
 8010e6a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e6c:	2204      	movs	r2, #4
 8010e6e:	701a      	strb	r2, [r3, #0]
            break;
 8010e70:	e00d      	b.n	8010e8e <GetFCntDown+0x9a>
        case MULTICAST_1_ADDR:
            *fCntID = MC_FCNT_DOWN_1;
 8010e72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e74:	2205      	movs	r2, #5
 8010e76:	701a      	strb	r2, [r3, #0]
            break;
 8010e78:	e009      	b.n	8010e8e <GetFCntDown+0x9a>
        case MULTICAST_2_ADDR:
            *fCntID = MC_FCNT_DOWN_2;
 8010e7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e7c:	2206      	movs	r2, #6
 8010e7e:	701a      	strb	r2, [r3, #0]
            break;
 8010e80:	e005      	b.n	8010e8e <GetFCntDown+0x9a>
        case MULTICAST_3_ADDR:
            *fCntID = MC_FCNT_DOWN_3;
 8010e82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e84:	2207      	movs	r2, #7
 8010e86:	701a      	strb	r2, [r3, #0]
            break;
 8010e88:	e001      	b.n	8010e8e <GetFCntDown+0x9a>
        default:
            return LORAMAC_CRYPTO_FAIL_FCNT_ID;
 8010e8a:	2305      	movs	r3, #5
 8010e8c:	e00d      	b.n	8010eaa <GetFCntDown+0xb6>
    }

    return LoRaMacCryptoGetFCntDown( *fCntID, maxFCntGap, macMsg->FHDR.FCnt, currentDown );
 8010e8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e90:	7818      	ldrb	r0, [r3, #0]
 8010e92:	68bb      	ldr	r3, [r7, #8]
 8010e94:	89db      	ldrh	r3, [r3, #14]
 8010e96:	001c      	movs	r4, r3
 8010e98:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8010e9a:	2320      	movs	r3, #32
 8010e9c:	18fb      	adds	r3, r7, r3
 8010e9e:	8819      	ldrh	r1, [r3, #0]
 8010ea0:	0013      	movs	r3, r2
 8010ea2:	0022      	movs	r2, r4
 8010ea4:	f005 fa80 	bl	80163a8 <LoRaMacCryptoGetFCntDown>
 8010ea8:	0003      	movs	r3, r0
}
 8010eaa:	0018      	movs	r0, r3
 8010eac:	46bd      	mov	sp, r7
 8010eae:	b005      	add	sp, #20
 8010eb0:	bd90      	pop	{r4, r7, pc}
 8010eb2:	46c0      	nop			; (mov r8, r8)
 8010eb4:	0801f1cc 	.word	0x0801f1cc

08010eb8 <SwitchClass>:

static LoRaMacStatus_t SwitchClass( DeviceClass_t deviceClass )
{
 8010eb8:	b5b0      	push	{r4, r5, r7, lr}
 8010eba:	b086      	sub	sp, #24
 8010ebc:	af02      	add	r7, sp, #8
 8010ebe:	0002      	movs	r2, r0
 8010ec0:	1dfb      	adds	r3, r7, #7
 8010ec2:	701a      	strb	r2, [r3, #0]
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 8010ec4:	230f      	movs	r3, #15
 8010ec6:	18fb      	adds	r3, r7, r3
 8010ec8:	2203      	movs	r2, #3
 8010eca:	701a      	strb	r2, [r3, #0]

    switch( MacCtx.NvmCtx->DeviceClass )
 8010ecc:	4b96      	ldr	r3, [pc, #600]	; (8011128 <SwitchClass+0x270>)
 8010ece:	4a97      	ldr	r2, [pc, #604]	; (801112c <SwitchClass+0x274>)
 8010ed0:	589b      	ldr	r3, [r3, r2]
 8010ed2:	22f0      	movs	r2, #240	; 0xf0
 8010ed4:	5c9b      	ldrb	r3, [r3, r2]
 8010ed6:	2b02      	cmp	r3, #2
 8010ed8:	d100      	bne.n	8010edc <SwitchClass+0x24>
 8010eda:	e106      	b.n	80110ea <SwitchClass+0x232>
 8010edc:	dd00      	ble.n	8010ee0 <SwitchClass+0x28>
 8010ede:	e11c      	b.n	801111a <SwitchClass+0x262>
 8010ee0:	2b00      	cmp	r3, #0
 8010ee2:	d003      	beq.n	8010eec <SwitchClass+0x34>
 8010ee4:	2b01      	cmp	r3, #1
 8010ee6:	d100      	bne.n	8010eea <SwitchClass+0x32>
 8010ee8:	e0ea      	b.n	80110c0 <SwitchClass+0x208>
 8010eea:	e116      	b.n	801111a <SwitchClass+0x262>
    {
        case CLASS_A:
        {
            if( deviceClass == CLASS_A )
 8010eec:	1dfb      	adds	r3, r7, #7
 8010eee:	781b      	ldrb	r3, [r3, #0]
 8010ef0:	2b00      	cmp	r3, #0
 8010ef2:	d10d      	bne.n	8010f10 <SwitchClass+0x58>
            {
                // Revert back RxC parameters
                MacCtx.NvmCtx->MacParams.RxCChannel = MacCtx.NvmCtx->MacParams.Rx2Channel;
 8010ef4:	4b8c      	ldr	r3, [pc, #560]	; (8011128 <SwitchClass+0x270>)
 8010ef6:	4a8d      	ldr	r2, [pc, #564]	; (801112c <SwitchClass+0x274>)
 8010ef8:	5899      	ldr	r1, [r3, r2]
 8010efa:	4b8b      	ldr	r3, [pc, #556]	; (8011128 <SwitchClass+0x270>)
 8010efc:	4a8b      	ldr	r2, [pc, #556]	; (801112c <SwitchClass+0x274>)
 8010efe:	5898      	ldr	r0, [r3, r2]
 8010f00:	2392      	movs	r3, #146	; 0x92
 8010f02:	005b      	lsls	r3, r3, #1
 8010f04:	228e      	movs	r2, #142	; 0x8e
 8010f06:	0052      	lsls	r2, r2, #1
 8010f08:	18c3      	adds	r3, r0, r3
 8010f0a:	188a      	adds	r2, r1, r2
 8010f0c:	ca03      	ldmia	r2!, {r0, r1}
 8010f0e:	c303      	stmia	r3!, {r0, r1}
            }
            if( deviceClass == CLASS_B )
 8010f10:	1dfb      	adds	r3, r7, #7
 8010f12:	781b      	ldrb	r3, [r3, #0]
 8010f14:	2b01      	cmp	r3, #1
 8010f16:	d113      	bne.n	8010f40 <SwitchClass+0x88>
            {
                status = LoRaMacClassBSwitchClass( deviceClass );
 8010f18:	250f      	movs	r5, #15
 8010f1a:	197c      	adds	r4, r7, r5
 8010f1c:	1dfb      	adds	r3, r7, #7
 8010f1e:	781b      	ldrb	r3, [r3, #0]
 8010f20:	0018      	movs	r0, r3
 8010f22:	f004 f8b7 	bl	8015094 <LoRaMacClassBSwitchClass>
 8010f26:	0003      	movs	r3, r0
 8010f28:	7023      	strb	r3, [r4, #0]
                if( status == LORAMAC_STATUS_OK )
 8010f2a:	197b      	adds	r3, r7, r5
 8010f2c:	781b      	ldrb	r3, [r3, #0]
 8010f2e:	2b00      	cmp	r3, #0
 8010f30:	d106      	bne.n	8010f40 <SwitchClass+0x88>
                {
                    MacCtx.NvmCtx->DeviceClass = deviceClass;
 8010f32:	4b7d      	ldr	r3, [pc, #500]	; (8011128 <SwitchClass+0x270>)
 8010f34:	4a7d      	ldr	r2, [pc, #500]	; (801112c <SwitchClass+0x274>)
 8010f36:	589b      	ldr	r3, [r3, r2]
 8010f38:	1dfa      	adds	r2, r7, #7
 8010f3a:	21f0      	movs	r1, #240	; 0xf0
 8010f3c:	7812      	ldrb	r2, [r2, #0]
 8010f3e:	545a      	strb	r2, [r3, r1]
                }
            }

            if( deviceClass == CLASS_C )
 8010f40:	1dfb      	adds	r3, r7, #7
 8010f42:	781b      	ldrb	r3, [r3, #0]
 8010f44:	2b02      	cmp	r3, #2
 8010f46:	d000      	beq.n	8010f4a <SwitchClass+0x92>
 8010f48:	e0e2      	b.n	8011110 <SwitchClass+0x258>
            {
                MacCtx.NvmCtx->DeviceClass = deviceClass;
 8010f4a:	4b77      	ldr	r3, [pc, #476]	; (8011128 <SwitchClass+0x270>)
 8010f4c:	4a77      	ldr	r2, [pc, #476]	; (801112c <SwitchClass+0x274>)
 8010f4e:	589b      	ldr	r3, [r3, r2]
 8010f50:	1dfa      	adds	r2, r7, #7
 8010f52:	21f0      	movs	r1, #240	; 0xf0
 8010f54:	7812      	ldrb	r2, [r2, #0]
 8010f56:	545a      	strb	r2, [r3, r1]

                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 8010f58:	4873      	ldr	r0, [pc, #460]	; (8011128 <SwitchClass+0x270>)
 8010f5a:	23f8      	movs	r3, #248	; 0xf8
 8010f5c:	009b      	lsls	r3, r3, #2
 8010f5e:	4972      	ldr	r1, [pc, #456]	; (8011128 <SwitchClass+0x270>)
 8010f60:	22f3      	movs	r2, #243	; 0xf3
 8010f62:	0092      	lsls	r2, r2, #2
 8010f64:	18c3      	adds	r3, r0, r3
 8010f66:	188a      	adds	r2, r1, r2
 8010f68:	ca13      	ldmia	r2!, {r0, r1, r4}
 8010f6a:	c313      	stmia	r3!, {r0, r1, r4}
 8010f6c:	ca03      	ldmia	r2!, {r0, r1}
 8010f6e:	c303      	stmia	r3!, {r0, r1}
                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 8010f70:	4b6d      	ldr	r3, [pc, #436]	; (8011128 <SwitchClass+0x270>)
 8010f72:	4a6f      	ldr	r2, [pc, #444]	; (8011130 <SwitchClass+0x278>)
 8010f74:	2102      	movs	r1, #2
 8010f76:	5499      	strb	r1, [r3, r2]

                for( int8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 8010f78:	230e      	movs	r3, #14
 8010f7a:	18fb      	adds	r3, r7, r3
 8010f7c:	2200      	movs	r2, #0
 8010f7e:	701a      	strb	r2, [r3, #0]
 8010f80:	e06f      	b.n	8011062 <SwitchClass+0x1aa>
                {
                    if( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.IsEnabled == true )
 8010f82:	4b69      	ldr	r3, [pc, #420]	; (8011128 <SwitchClass+0x270>)
 8010f84:	4a69      	ldr	r2, [pc, #420]	; (801112c <SwitchClass+0x274>)
 8010f86:	5899      	ldr	r1, [r3, r2]
 8010f88:	240e      	movs	r4, #14
 8010f8a:	193b      	adds	r3, r7, r4
 8010f8c:	2200      	movs	r2, #0
 8010f8e:	569a      	ldrsb	r2, [r3, r2]
 8010f90:	2051      	movs	r0, #81	; 0x51
 8010f92:	0013      	movs	r3, r2
 8010f94:	009b      	lsls	r3, r3, #2
 8010f96:	189b      	adds	r3, r3, r2
 8010f98:	00db      	lsls	r3, r3, #3
 8010f9a:	18cb      	adds	r3, r1, r3
 8010f9c:	181b      	adds	r3, r3, r0
 8010f9e:	781b      	ldrb	r3, [r3, #0]
 8010fa0:	2b00      	cmp	r3, #0
 8010fa2:	d055      	beq.n	8011050 <SwitchClass+0x198>
                    // TODO: Check multicast channel device class.
                    {
                        MacCtx.NvmCtx->MacParams.RxCChannel.Frequency = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.RxParams.ClassC.Frequency;
 8010fa4:	4b60      	ldr	r3, [pc, #384]	; (8011128 <SwitchClass+0x270>)
 8010fa6:	4a61      	ldr	r2, [pc, #388]	; (801112c <SwitchClass+0x274>)
 8010fa8:	5898      	ldr	r0, [r3, r2]
 8010faa:	193b      	adds	r3, r7, r4
 8010fac:	2200      	movs	r2, #0
 8010fae:	569a      	ldrsb	r2, [r3, r2]
 8010fb0:	4b5d      	ldr	r3, [pc, #372]	; (8011128 <SwitchClass+0x270>)
 8010fb2:	495e      	ldr	r1, [pc, #376]	; (801112c <SwitchClass+0x274>)
 8010fb4:	5859      	ldr	r1, [r3, r1]
 8010fb6:	0013      	movs	r3, r2
 8010fb8:	009b      	lsls	r3, r3, #2
 8010fba:	189b      	adds	r3, r3, r2
 8010fbc:	00db      	lsls	r3, r3, #3
 8010fbe:	18c3      	adds	r3, r0, r3
 8010fc0:	3364      	adds	r3, #100	; 0x64
 8010fc2:	681a      	ldr	r2, [r3, #0]
 8010fc4:	2392      	movs	r3, #146	; 0x92
 8010fc6:	005b      	lsls	r3, r3, #1
 8010fc8:	50ca      	str	r2, [r1, r3]
                        MacCtx.NvmCtx->MacParams.RxCChannel.Datarate = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 8010fca:	4b57      	ldr	r3, [pc, #348]	; (8011128 <SwitchClass+0x270>)
 8010fcc:	4a57      	ldr	r2, [pc, #348]	; (801112c <SwitchClass+0x274>)
 8010fce:	5899      	ldr	r1, [r3, r2]
 8010fd0:	193b      	adds	r3, r7, r4
 8010fd2:	2200      	movs	r2, #0
 8010fd4:	569a      	ldrsb	r2, [r3, r2]
 8010fd6:	2068      	movs	r0, #104	; 0x68
 8010fd8:	0013      	movs	r3, r2
 8010fda:	009b      	lsls	r3, r3, #2
 8010fdc:	189b      	adds	r3, r3, r2
 8010fde:	00db      	lsls	r3, r3, #3
 8010fe0:	18cb      	adds	r3, r1, r3
 8010fe2:	181b      	adds	r3, r3, r0
 8010fe4:	2100      	movs	r1, #0
 8010fe6:	5659      	ldrsb	r1, [r3, r1]
 8010fe8:	4b4f      	ldr	r3, [pc, #316]	; (8011128 <SwitchClass+0x270>)
 8010fea:	4a50      	ldr	r2, [pc, #320]	; (801112c <SwitchClass+0x274>)
 8010fec:	589a      	ldr	r2, [r3, r2]
 8010fee:	b2c9      	uxtb	r1, r1
 8010ff0:	2394      	movs	r3, #148	; 0x94
 8010ff2:	005b      	lsls	r3, r3, #1
 8010ff4:	54d1      	strb	r1, [r2, r3]

                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 8010ff6:	4b4c      	ldr	r3, [pc, #304]	; (8011128 <SwitchClass+0x270>)
 8010ff8:	4a4e      	ldr	r2, [pc, #312]	; (8011134 <SwitchClass+0x27c>)
 8010ffa:	5c99      	ldrb	r1, [r3, r2]
 8010ffc:	4a4a      	ldr	r2, [pc, #296]	; (8011128 <SwitchClass+0x270>)
 8010ffe:	23f8      	movs	r3, #248	; 0xf8
 8011000:	009b      	lsls	r3, r3, #2
 8011002:	54d1      	strb	r1, [r2, r3]
                        MacCtx.RxWindowCConfig.Frequency = MacCtx.NvmCtx->MacParams.RxCChannel.Frequency;
 8011004:	4b48      	ldr	r3, [pc, #288]	; (8011128 <SwitchClass+0x270>)
 8011006:	4a49      	ldr	r2, [pc, #292]	; (801112c <SwitchClass+0x274>)
 8011008:	589a      	ldr	r2, [r3, r2]
 801100a:	2392      	movs	r3, #146	; 0x92
 801100c:	005b      	lsls	r3, r3, #1
 801100e:	58d1      	ldr	r1, [r2, r3]
 8011010:	4a45      	ldr	r2, [pc, #276]	; (8011128 <SwitchClass+0x270>)
 8011012:	23f9      	movs	r3, #249	; 0xf9
 8011014:	009b      	lsls	r3, r3, #2
 8011016:	50d1      	str	r1, [r2, r3]
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;
 8011018:	4b43      	ldr	r3, [pc, #268]	; (8011128 <SwitchClass+0x270>)
 801101a:	4a44      	ldr	r2, [pc, #272]	; (801112c <SwitchClass+0x274>)
 801101c:	589a      	ldr	r2, [r3, r2]
 801101e:	232e      	movs	r3, #46	; 0x2e
 8011020:	33ff      	adds	r3, #255	; 0xff
 8011022:	5cd1      	ldrb	r1, [r2, r3]
 8011024:	4a40      	ldr	r2, [pc, #256]	; (8011128 <SwitchClass+0x270>)
 8011026:	23fc      	movs	r3, #252	; 0xfc
 8011028:	009b      	lsls	r3, r3, #2
 801102a:	54d1      	strb	r1, [r2, r3]
                        MacCtx.RxWindowCConfig.RepeaterSupport = MacCtx.NvmCtx->RepeaterSupport;
 801102c:	4b3e      	ldr	r3, [pc, #248]	; (8011128 <SwitchClass+0x270>)
 801102e:	4a3f      	ldr	r2, [pc, #252]	; (801112c <SwitchClass+0x274>)
 8011030:	589a      	ldr	r2, [r3, r2]
 8011032:	2340      	movs	r3, #64	; 0x40
 8011034:	33ff      	adds	r3, #255	; 0xff
 8011036:	5cd1      	ldrb	r1, [r2, r3]
 8011038:	4b3b      	ldr	r3, [pc, #236]	; (8011128 <SwitchClass+0x270>)
 801103a:	4a3f      	ldr	r2, [pc, #252]	; (8011138 <SwitchClass+0x280>)
 801103c:	5499      	strb	r1, [r3, r2]
                        MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 801103e:	4b3a      	ldr	r3, [pc, #232]	; (8011128 <SwitchClass+0x270>)
 8011040:	4a3b      	ldr	r2, [pc, #236]	; (8011130 <SwitchClass+0x278>)
 8011042:	2103      	movs	r1, #3
 8011044:	5499      	strb	r1, [r3, r2]
                        MacCtx.RxWindowCConfig.RxContinuous = true;
 8011046:	4b38      	ldr	r3, [pc, #224]	; (8011128 <SwitchClass+0x270>)
 8011048:	4a3c      	ldr	r2, [pc, #240]	; (801113c <SwitchClass+0x284>)
 801104a:	2101      	movs	r1, #1
 801104c:	5499      	strb	r1, [r3, r2]
                        break;
 801104e:	e00e      	b.n	801106e <SwitchClass+0x1b6>
                for( int8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 8011050:	210e      	movs	r1, #14
 8011052:	187b      	adds	r3, r7, r1
 8011054:	781b      	ldrb	r3, [r3, #0]
 8011056:	b25b      	sxtb	r3, r3
 8011058:	b2db      	uxtb	r3, r3
 801105a:	3301      	adds	r3, #1
 801105c:	b2da      	uxtb	r2, r3
 801105e:	187b      	adds	r3, r7, r1
 8011060:	701a      	strb	r2, [r3, #0]
 8011062:	230e      	movs	r3, #14
 8011064:	18fb      	adds	r3, r7, r3
 8011066:	781b      	ldrb	r3, [r3, #0]
 8011068:	b25b      	sxtb	r3, r3
 801106a:	2b03      	cmp	r3, #3
 801106c:	dd89      	ble.n	8010f82 <SwitchClass+0xca>
                    }
                }

                // Set the NodeAckRequested indicator to default
                MacCtx.NodeAckRequested = false;
 801106e:	4b2e      	ldr	r3, [pc, #184]	; (8011128 <SwitchClass+0x270>)
 8011070:	4a33      	ldr	r2, [pc, #204]	; (8011140 <SwitchClass+0x288>)
 8011072:	2100      	movs	r1, #0
 8011074:	5499      	strb	r1, [r3, r2]
                // Set the radio into sleep mode in case we are still in RX mode
                Radio.Sleep( );
 8011076:	4b33      	ldr	r3, [pc, #204]	; (8011144 <SwitchClass+0x28c>)
 8011078:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801107a:	4798      	blx	r3
                // Compute Rx2 windows parameters in case the RX2 datarate has changed
                RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 801107c:	4b2a      	ldr	r3, [pc, #168]	; (8011128 <SwitchClass+0x270>)
 801107e:	4a2b      	ldr	r2, [pc, #172]	; (801112c <SwitchClass+0x274>)
 8011080:	589b      	ldr	r3, [r3, r2]
 8011082:	7818      	ldrb	r0, [r3, #0]
                                                 MacCtx.NvmCtx->MacParams.RxCChannel.Datarate,
 8011084:	4b28      	ldr	r3, [pc, #160]	; (8011128 <SwitchClass+0x270>)
 8011086:	4a29      	ldr	r2, [pc, #164]	; (801112c <SwitchClass+0x274>)
 8011088:	589a      	ldr	r2, [r3, r2]
 801108a:	2394      	movs	r3, #148	; 0x94
 801108c:	005b      	lsls	r3, r3, #1
 801108e:	5cd3      	ldrb	r3, [r2, r3]
                RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 8011090:	b259      	sxtb	r1, r3
                                                 MacCtx.NvmCtx->MacParams.MinRxSymbols,
 8011092:	4b25      	ldr	r3, [pc, #148]	; (8011128 <SwitchClass+0x270>)
 8011094:	4a25      	ldr	r2, [pc, #148]	; (801112c <SwitchClass+0x274>)
 8011096:	589a      	ldr	r2, [r3, r2]
                RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 8011098:	2380      	movs	r3, #128	; 0x80
 801109a:	005b      	lsls	r3, r3, #1
 801109c:	5cd2      	ldrb	r2, [r2, r3]
                                                 MacCtx.NvmCtx->MacParams.SystemMaxRxError,
 801109e:	4b22      	ldr	r3, [pc, #136]	; (8011128 <SwitchClass+0x270>)
 80110a0:	4c22      	ldr	r4, [pc, #136]	; (801112c <SwitchClass+0x274>)
 80110a2:	591b      	ldr	r3, [r3, r4]
                RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 80110a4:	24fc      	movs	r4, #252	; 0xfc
 80110a6:	591c      	ldr	r4, [r3, r4]
 80110a8:	4b27      	ldr	r3, [pc, #156]	; (8011148 <SwitchClass+0x290>)
 80110aa:	9300      	str	r3, [sp, #0]
 80110ac:	0023      	movs	r3, r4
 80110ae:	f006 fae5 	bl	801767c <RegionComputeRxWindowParameters>
                                                 &MacCtx.RxWindowCConfig );
                OpenContinuousRxCWindow( );
 80110b2:	f001 fb71 	bl	8012798 <OpenContinuousRxCWindow>

                status = LORAMAC_STATUS_OK;
 80110b6:	230f      	movs	r3, #15
 80110b8:	18fb      	adds	r3, r7, r3
 80110ba:	2200      	movs	r2, #0
 80110bc:	701a      	strb	r2, [r3, #0]
            }
            break;
 80110be:	e027      	b.n	8011110 <SwitchClass+0x258>
        }
        case CLASS_B:
        {
            status = LoRaMacClassBSwitchClass( deviceClass );
 80110c0:	250f      	movs	r5, #15
 80110c2:	197c      	adds	r4, r7, r5
 80110c4:	1dfb      	adds	r3, r7, #7
 80110c6:	781b      	ldrb	r3, [r3, #0]
 80110c8:	0018      	movs	r0, r3
 80110ca:	f003 ffe3 	bl	8015094 <LoRaMacClassBSwitchClass>
 80110ce:	0003      	movs	r3, r0
 80110d0:	7023      	strb	r3, [r4, #0]
            if( status == LORAMAC_STATUS_OK )
 80110d2:	197b      	adds	r3, r7, r5
 80110d4:	781b      	ldrb	r3, [r3, #0]
 80110d6:	2b00      	cmp	r3, #0
 80110d8:	d11c      	bne.n	8011114 <SwitchClass+0x25c>
            {
                MacCtx.NvmCtx->DeviceClass = deviceClass;
 80110da:	4b13      	ldr	r3, [pc, #76]	; (8011128 <SwitchClass+0x270>)
 80110dc:	4a13      	ldr	r2, [pc, #76]	; (801112c <SwitchClass+0x274>)
 80110de:	589b      	ldr	r3, [r3, r2]
 80110e0:	1dfa      	adds	r2, r7, #7
 80110e2:	21f0      	movs	r1, #240	; 0xf0
 80110e4:	7812      	ldrb	r2, [r2, #0]
 80110e6:	545a      	strb	r2, [r3, r1]
            }
            break;
 80110e8:	e014      	b.n	8011114 <SwitchClass+0x25c>
        }
        case CLASS_C:
        {
            if( deviceClass == CLASS_A )
 80110ea:	1dfb      	adds	r3, r7, #7
 80110ec:	781b      	ldrb	r3, [r3, #0]
 80110ee:	2b00      	cmp	r3, #0
 80110f0:	d112      	bne.n	8011118 <SwitchClass+0x260>
            {
                MacCtx.NvmCtx->DeviceClass = deviceClass;
 80110f2:	4b0d      	ldr	r3, [pc, #52]	; (8011128 <SwitchClass+0x270>)
 80110f4:	4a0d      	ldr	r2, [pc, #52]	; (801112c <SwitchClass+0x274>)
 80110f6:	589b      	ldr	r3, [r3, r2]
 80110f8:	1dfa      	adds	r2, r7, #7
 80110fa:	21f0      	movs	r1, #240	; 0xf0
 80110fc:	7812      	ldrb	r2, [r2, #0]
 80110fe:	545a      	strb	r2, [r3, r1]

                // Set the radio into sleep to setup a defined state
                Radio.Sleep( );
 8011100:	4b10      	ldr	r3, [pc, #64]	; (8011144 <SwitchClass+0x28c>)
 8011102:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011104:	4798      	blx	r3

                status = LORAMAC_STATUS_OK;
 8011106:	230f      	movs	r3, #15
 8011108:	18fb      	adds	r3, r7, r3
 801110a:	2200      	movs	r2, #0
 801110c:	701a      	strb	r2, [r3, #0]
            }
            break;
 801110e:	e003      	b.n	8011118 <SwitchClass+0x260>
            break;
 8011110:	46c0      	nop			; (mov r8, r8)
 8011112:	e002      	b.n	801111a <SwitchClass+0x262>
            break;
 8011114:	46c0      	nop			; (mov r8, r8)
 8011116:	e000      	b.n	801111a <SwitchClass+0x262>
            break;
 8011118:	46c0      	nop			; (mov r8, r8)
        }
    }

    return status;
 801111a:	230f      	movs	r3, #15
 801111c:	18fb      	adds	r3, r7, r3
 801111e:	781b      	ldrb	r3, [r3, #0]
}
 8011120:	0018      	movs	r0, r3
 8011122:	46bd      	mov	sp, r7
 8011124:	b004      	add	sp, #16
 8011126:	bdb0      	pop	{r4, r5, r7, pc}
 8011128:	200008ec 	.word	0x200008ec
 801112c:	00000484 	.word	0x00000484
 8011130:	000003f3 	.word	0x000003f3
 8011134:	00000415 	.word	0x00000415
 8011138:	000003f1 	.word	0x000003f1
 801113c:	000003f2 	.word	0x000003f2
 8011140:	00000414 	.word	0x00000414
 8011144:	0801ebd0 	.word	0x0801ebd0
 8011148:	20000ccc 	.word	0x20000ccc

0801114c <GetMaxAppPayloadWithoutFOptsLength>:

static uint8_t GetMaxAppPayloadWithoutFOptsLength( int8_t datarate )
{
 801114c:	b580      	push	{r7, lr}
 801114e:	b084      	sub	sp, #16
 8011150:	af00      	add	r7, sp, #0
 8011152:	0002      	movs	r2, r0
 8011154:	1dfb      	adds	r3, r7, #7
 8011156:	701a      	strb	r2, [r3, #0]
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    // Setup PHY request
    getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;
 8011158:	4b18      	ldr	r3, [pc, #96]	; (80111bc <GetMaxAppPayloadWithoutFOptsLength+0x70>)
 801115a:	4a19      	ldr	r2, [pc, #100]	; (80111c0 <GetMaxAppPayloadWithoutFOptsLength+0x74>)
 801115c:	589a      	ldr	r2, [r3, r2]
 801115e:	2396      	movs	r3, #150	; 0x96
 8011160:	005b      	lsls	r3, r3, #1
 8011162:	5cd2      	ldrb	r2, [r2, r3]
 8011164:	210c      	movs	r1, #12
 8011166:	187b      	adds	r3, r7, r1
 8011168:	709a      	strb	r2, [r3, #2]
    getPhy.Datarate = datarate;
 801116a:	187b      	adds	r3, r7, r1
 801116c:	1dfa      	adds	r2, r7, #7
 801116e:	7812      	ldrb	r2, [r2, #0]
 8011170:	705a      	strb	r2, [r3, #1]
    getPhy.Attribute = PHY_MAX_PAYLOAD;
 8011172:	187b      	adds	r3, r7, r1
 8011174:	220d      	movs	r2, #13
 8011176:	701a      	strb	r2, [r3, #0]

    // Get the maximum payload length
    if( MacCtx.NvmCtx->RepeaterSupport == true )
 8011178:	4b10      	ldr	r3, [pc, #64]	; (80111bc <GetMaxAppPayloadWithoutFOptsLength+0x70>)
 801117a:	4a11      	ldr	r2, [pc, #68]	; (80111c0 <GetMaxAppPayloadWithoutFOptsLength+0x74>)
 801117c:	589a      	ldr	r2, [r3, r2]
 801117e:	2340      	movs	r3, #64	; 0x40
 8011180:	33ff      	adds	r3, #255	; 0xff
 8011182:	5cd3      	ldrb	r3, [r2, r3]
 8011184:	2b00      	cmp	r3, #0
 8011186:	d002      	beq.n	801118e <GetMaxAppPayloadWithoutFOptsLength+0x42>
    {
        getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 8011188:	187b      	adds	r3, r7, r1
 801118a:	220e      	movs	r2, #14
 801118c:	701a      	strb	r2, [r3, #0]
    }
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 801118e:	4b0b      	ldr	r3, [pc, #44]	; (80111bc <GetMaxAppPayloadWithoutFOptsLength+0x70>)
 8011190:	4a0b      	ldr	r2, [pc, #44]	; (80111c0 <GetMaxAppPayloadWithoutFOptsLength+0x74>)
 8011192:	589b      	ldr	r3, [r3, r2]
 8011194:	781b      	ldrb	r3, [r3, #0]
 8011196:	220c      	movs	r2, #12
 8011198:	18ba      	adds	r2, r7, r2
 801119a:	0011      	movs	r1, r2
 801119c:	0018      	movs	r0, r3
 801119e:	f006 f9be 	bl	801751e <RegionGetPhyParam>
 80111a2:	0003      	movs	r3, r0
 80111a4:	001a      	movs	r2, r3
 80111a6:	2108      	movs	r1, #8
 80111a8:	187b      	adds	r3, r7, r1
 80111aa:	601a      	str	r2, [r3, #0]

    return phyParam.Value;
 80111ac:	187b      	adds	r3, r7, r1
 80111ae:	681b      	ldr	r3, [r3, #0]
 80111b0:	b2db      	uxtb	r3, r3
}
 80111b2:	0018      	movs	r0, r3
 80111b4:	46bd      	mov	sp, r7
 80111b6:	b004      	add	sp, #16
 80111b8:	bd80      	pop	{r7, pc}
 80111ba:	46c0      	nop			; (mov r8, r8)
 80111bc:	200008ec 	.word	0x200008ec
 80111c0:	00000484 	.word	0x00000484

080111c4 <ValidatePayloadLength>:

static bool ValidatePayloadLength( uint8_t lenN, int8_t datarate, uint8_t fOptsLen )
{
 80111c4:	b5b0      	push	{r4, r5, r7, lr}
 80111c6:	b084      	sub	sp, #16
 80111c8:	af00      	add	r7, sp, #0
 80111ca:	0004      	movs	r4, r0
 80111cc:	0008      	movs	r0, r1
 80111ce:	0011      	movs	r1, r2
 80111d0:	1dfb      	adds	r3, r7, #7
 80111d2:	1c22      	adds	r2, r4, #0
 80111d4:	701a      	strb	r2, [r3, #0]
 80111d6:	1dbb      	adds	r3, r7, #6
 80111d8:	1c02      	adds	r2, r0, #0
 80111da:	701a      	strb	r2, [r3, #0]
 80111dc:	1d7b      	adds	r3, r7, #5
 80111de:	1c0a      	adds	r2, r1, #0
 80111e0:	701a      	strb	r2, [r3, #0]
    uint16_t maxN = 0;
 80111e2:	250e      	movs	r5, #14
 80111e4:	197b      	adds	r3, r7, r5
 80111e6:	2200      	movs	r2, #0
 80111e8:	801a      	strh	r2, [r3, #0]
    uint16_t payloadSize = 0;
 80111ea:	240c      	movs	r4, #12
 80111ec:	193b      	adds	r3, r7, r4
 80111ee:	2200      	movs	r2, #0
 80111f0:	801a      	strh	r2, [r3, #0]

    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 80111f2:	1dbb      	adds	r3, r7, #6
 80111f4:	781b      	ldrb	r3, [r3, #0]
 80111f6:	b25b      	sxtb	r3, r3
 80111f8:	0018      	movs	r0, r3
 80111fa:	f7ff ffa7 	bl	801114c <GetMaxAppPayloadWithoutFOptsLength>
 80111fe:	0003      	movs	r3, r0
 8011200:	001a      	movs	r2, r3
 8011202:	0028      	movs	r0, r5
 8011204:	183b      	adds	r3, r7, r0
 8011206:	801a      	strh	r2, [r3, #0]

    // Calculate the resulting payload size
    payloadSize = ( lenN + fOptsLen );
 8011208:	1dfb      	adds	r3, r7, #7
 801120a:	781b      	ldrb	r3, [r3, #0]
 801120c:	b299      	uxth	r1, r3
 801120e:	1d7b      	adds	r3, r7, #5
 8011210:	781b      	ldrb	r3, [r3, #0]
 8011212:	b29a      	uxth	r2, r3
 8011214:	193b      	adds	r3, r7, r4
 8011216:	188a      	adds	r2, r1, r2
 8011218:	801a      	strh	r2, [r3, #0]

    // Validation of the application payload size
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
 801121a:	193a      	adds	r2, r7, r4
 801121c:	183b      	adds	r3, r7, r0
 801121e:	8812      	ldrh	r2, [r2, #0]
 8011220:	881b      	ldrh	r3, [r3, #0]
 8011222:	429a      	cmp	r2, r3
 8011224:	d805      	bhi.n	8011232 <ValidatePayloadLength+0x6e>
 8011226:	193b      	adds	r3, r7, r4
 8011228:	881b      	ldrh	r3, [r3, #0]
 801122a:	2bff      	cmp	r3, #255	; 0xff
 801122c:	d801      	bhi.n	8011232 <ValidatePayloadLength+0x6e>
    {
        return true;
 801122e:	2301      	movs	r3, #1
 8011230:	e000      	b.n	8011234 <ValidatePayloadLength+0x70>
    }
    return false;
 8011232:	2300      	movs	r3, #0
}
 8011234:	0018      	movs	r0, r3
 8011236:	46bd      	mov	sp, r7
 8011238:	b004      	add	sp, #16
 801123a:	bdb0      	pop	{r4, r5, r7, pc}

0801123c <SetMlmeScheduleUplinkIndication>:

static void SetMlmeScheduleUplinkIndication( void )
{
 801123c:	b580      	push	{r7, lr}
 801123e:	af00      	add	r7, sp, #0
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8011240:	4b04      	ldr	r3, [pc, #16]	; (8011254 <SetMlmeScheduleUplinkIndication+0x18>)
 8011242:	4a05      	ldr	r2, [pc, #20]	; (8011258 <SetMlmeScheduleUplinkIndication+0x1c>)
 8011244:	5c99      	ldrb	r1, [r3, r2]
 8011246:	2010      	movs	r0, #16
 8011248:	4301      	orrs	r1, r0
 801124a:	5499      	strb	r1, [r3, r2]
}
 801124c:	46c0      	nop			; (mov r8, r8)
 801124e:	46bd      	mov	sp, r7
 8011250:	bd80      	pop	{r7, pc}
 8011252:	46c0      	nop			; (mov r8, r8)
 8011254:	200008ec 	.word	0x200008ec
 8011258:	00000481 	.word	0x00000481

0801125c <ProcessMacCommands>:

static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
{
 801125c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801125e:	b0a5      	sub	sp, #148	; 0x94
 8011260:	af02      	add	r7, sp, #8
 8011262:	6078      	str	r0, [r7, #4]
 8011264:	000c      	movs	r4, r1
 8011266:	0010      	movs	r0, r2
 8011268:	0019      	movs	r1, r3
 801126a:	1cfb      	adds	r3, r7, #3
 801126c:	1c22      	adds	r2, r4, #0
 801126e:	701a      	strb	r2, [r3, #0]
 8011270:	1cbb      	adds	r3, r7, #2
 8011272:	1c02      	adds	r2, r0, #0
 8011274:	701a      	strb	r2, [r3, #0]
 8011276:	1c7b      	adds	r3, r7, #1
 8011278:	1c0a      	adds	r2, r1, #0
 801127a:	701a      	strb	r2, [r3, #0]
    uint8_t status = 0;
 801127c:	236b      	movs	r3, #107	; 0x6b
 801127e:	18fb      	adds	r3, r7, r3
 8011280:	2200      	movs	r2, #0
 8011282:	701a      	strb	r2, [r3, #0]
    bool adrBlockFound = false;
 8011284:	2387      	movs	r3, #135	; 0x87
 8011286:	18fb      	adds	r3, r7, r3
 8011288:	2200      	movs	r2, #0
 801128a:	701a      	strb	r2, [r3, #0]
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 801128c:	2368      	movs	r3, #104	; 0x68
 801128e:	18fb      	adds	r3, r7, r3
 8011290:	2200      	movs	r2, #0
 8011292:	801a      	strh	r2, [r3, #0]

    while( macIndex < commandsSize )
 8011294:	f000 fd33 	bl	8011cfe <ProcessMacCommands+0xaa2>
    {
        // Decode Frame MAC commands
        switch( payload[macIndex++] )
 8011298:	1cfb      	adds	r3, r7, #3
 801129a:	781b      	ldrb	r3, [r3, #0]
 801129c:	1cfa      	adds	r2, r7, #3
 801129e:	1c59      	adds	r1, r3, #1
 80112a0:	7011      	strb	r1, [r2, #0]
 80112a2:	001a      	movs	r2, r3
 80112a4:	687b      	ldr	r3, [r7, #4]
 80112a6:	189b      	adds	r3, r3, r2
 80112a8:	781b      	ldrb	r3, [r3, #0]
 80112aa:	2b13      	cmp	r3, #19
 80112ac:	d901      	bls.n	80112b2 <ProcessMacCommands+0x56>
 80112ae:	f000 fd2f 	bl	8011d10 <ProcessMacCommands+0xab4>
 80112b2:	009a      	lsls	r2, r3, #2
 80112b4:	4bf2      	ldr	r3, [pc, #968]	; (8011680 <ProcessMacCommands+0x424>)
 80112b6:	18d3      	adds	r3, r2, r3
 80112b8:	681b      	ldr	r3, [r3, #0]
 80112ba:	469f      	mov	pc, r3
        {
            case SRV_MAC_LINK_CHECK_ANS:
            {
                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )
 80112bc:	2003      	movs	r0, #3
 80112be:	f004 fb79 	bl	80159b4 <LoRaMacConfirmQueueIsCmdActive>
 80112c2:	1e03      	subs	r3, r0, #0
 80112c4:	d101      	bne.n	80112ca <ProcessMacCommands+0x6e>
 80112c6:	f000 fd1a 	bl	8011cfe <ProcessMacCommands+0xaa2>
                {
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );
 80112ca:	2103      	movs	r1, #3
 80112cc:	2000      	movs	r0, #0
 80112ce:	f004 faed 	bl	80158ac <LoRaMacConfirmQueueSetStatus>
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 80112d2:	1cfb      	adds	r3, r7, #3
 80112d4:	781b      	ldrb	r3, [r3, #0]
 80112d6:	1cfa      	adds	r2, r7, #3
 80112d8:	1c59      	adds	r1, r3, #1
 80112da:	7011      	strb	r1, [r2, #0]
 80112dc:	001a      	movs	r2, r3
 80112de:	687b      	ldr	r3, [r7, #4]
 80112e0:	189b      	adds	r3, r3, r2
 80112e2:	7819      	ldrb	r1, [r3, #0]
 80112e4:	4ae7      	ldr	r2, [pc, #924]	; (8011684 <ProcessMacCommands+0x428>)
 80112e6:	238b      	movs	r3, #139	; 0x8b
 80112e8:	00db      	lsls	r3, r3, #3
 80112ea:	54d1      	strb	r1, [r2, r3]
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 80112ec:	1cfb      	adds	r3, r7, #3
 80112ee:	781b      	ldrb	r3, [r3, #0]
 80112f0:	1cfa      	adds	r2, r7, #3
 80112f2:	1c59      	adds	r1, r3, #1
 80112f4:	7011      	strb	r1, [r2, #0]
 80112f6:	001a      	movs	r2, r3
 80112f8:	687b      	ldr	r3, [r7, #4]
 80112fa:	189b      	adds	r3, r3, r2
 80112fc:	7819      	ldrb	r1, [r3, #0]
 80112fe:	4be1      	ldr	r3, [pc, #900]	; (8011684 <ProcessMacCommands+0x428>)
 8011300:	4ae1      	ldr	r2, [pc, #900]	; (8011688 <ProcessMacCommands+0x42c>)
 8011302:	5499      	strb	r1, [r3, r2]
                }
                break;
 8011304:	f000 fcfb 	bl	8011cfe <ProcessMacCommands+0xaa2>
            }
            case SRV_MAC_LINK_ADR_REQ:
            {
                LinkAdrReqParams_t linkAdrReq;
                int8_t linkAdrDatarate = DR_0;
 8011308:	2657      	movs	r6, #87	; 0x57
 801130a:	19bb      	adds	r3, r7, r6
 801130c:	2200      	movs	r2, #0
 801130e:	701a      	strb	r2, [r3, #0]
                int8_t linkAdrTxPower = TX_POWER_0;
 8011310:	2456      	movs	r4, #86	; 0x56
 8011312:	193b      	adds	r3, r7, r4
 8011314:	2200      	movs	r2, #0
 8011316:	701a      	strb	r2, [r3, #0]
                uint8_t linkAdrNbRep = 0;
 8011318:	2555      	movs	r5, #85	; 0x55
 801131a:	197b      	adds	r3, r7, r5
 801131c:	2200      	movs	r2, #0
 801131e:	701a      	strb	r2, [r3, #0]
                uint8_t linkAdrNbBytesParsed = 0;
 8011320:	2354      	movs	r3, #84	; 0x54
 8011322:	18fb      	adds	r3, r7, r3
 8011324:	2200      	movs	r2, #0
 8011326:	701a      	strb	r2, [r3, #0]

                if( adrBlockFound == false )
 8011328:	2187      	movs	r1, #135	; 0x87
 801132a:	187b      	adds	r3, r7, r1
 801132c:	781b      	ldrb	r3, [r3, #0]
 801132e:	2201      	movs	r2, #1
 8011330:	4053      	eors	r3, r2
 8011332:	b2db      	uxtb	r3, r3
 8011334:	2b00      	cmp	r3, #0
 8011336:	d100      	bne.n	801133a <ProcessMacCommands+0xde>
 8011338:	e0a0      	b.n	801147c <ProcessMacCommands+0x220>
                {
                    adrBlockFound = true;
 801133a:	187b      	adds	r3, r7, r1
 801133c:	2201      	movs	r2, #1
 801133e:	701a      	strb	r2, [r3, #0]

                    // Fill parameter structure
                    linkAdrReq.Payload = &payload[macIndex - 1];
 8011340:	1cfb      	adds	r3, r7, #3
 8011342:	781b      	ldrb	r3, [r3, #0]
 8011344:	3b01      	subs	r3, #1
 8011346:	687a      	ldr	r2, [r7, #4]
 8011348:	18d2      	adds	r2, r2, r3
 801134a:	2158      	movs	r1, #88	; 0x58
 801134c:	187b      	adds	r3, r7, r1
 801134e:	605a      	str	r2, [r3, #4]
                    linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );
 8011350:	1cba      	adds	r2, r7, #2
 8011352:	1cfb      	adds	r3, r7, #3
 8011354:	7812      	ldrb	r2, [r2, #0]
 8011356:	781b      	ldrb	r3, [r3, #0]
 8011358:	1ad3      	subs	r3, r2, r3
 801135a:	b2db      	uxtb	r3, r3
 801135c:	3301      	adds	r3, #1
 801135e:	b2da      	uxtb	r2, r3
 8011360:	187b      	adds	r3, r7, r1
 8011362:	721a      	strb	r2, [r3, #8]
                    linkAdrReq.AdrEnabled = MacCtx.NvmCtx->AdrCtrlOn;
 8011364:	4bc7      	ldr	r3, [pc, #796]	; (8011684 <ProcessMacCommands+0x428>)
 8011366:	4ac9      	ldr	r2, [pc, #804]	; (801168c <ProcessMacCommands+0x430>)
 8011368:	589b      	ldr	r3, [r3, r2]
 801136a:	22f2      	movs	r2, #242	; 0xf2
 801136c:	5c9a      	ldrb	r2, [r3, r2]
 801136e:	187b      	adds	r3, r7, r1
 8011370:	729a      	strb	r2, [r3, #10]
                    linkAdrReq.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;
 8011372:	4bc4      	ldr	r3, [pc, #784]	; (8011684 <ProcessMacCommands+0x428>)
 8011374:	4ac5      	ldr	r2, [pc, #788]	; (801168c <ProcessMacCommands+0x430>)
 8011376:	589a      	ldr	r2, [r3, r2]
 8011378:	2396      	movs	r3, #150	; 0x96
 801137a:	005b      	lsls	r3, r3, #1
 801137c:	5cd2      	ldrb	r2, [r2, r3]
 801137e:	000d      	movs	r5, r1
 8011380:	197b      	adds	r3, r7, r5
 8011382:	725a      	strb	r2, [r3, #9]
                    linkAdrReq.CurrentDatarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;
 8011384:	4bbf      	ldr	r3, [pc, #764]	; (8011684 <ProcessMacCommands+0x428>)
 8011386:	4ac1      	ldr	r2, [pc, #772]	; (801168c <ProcessMacCommands+0x430>)
 8011388:	589b      	ldr	r3, [r3, r2]
 801138a:	22f9      	movs	r2, #249	; 0xf9
 801138c:	569a      	ldrsb	r2, [r3, r2]
 801138e:	197b      	adds	r3, r7, r5
 8011390:	72da      	strb	r2, [r3, #11]
                    linkAdrReq.CurrentTxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;
 8011392:	4bbc      	ldr	r3, [pc, #752]	; (8011684 <ProcessMacCommands+0x428>)
 8011394:	4abd      	ldr	r2, [pc, #756]	; (801168c <ProcessMacCommands+0x430>)
 8011396:	589b      	ldr	r3, [r3, r2]
 8011398:	22f8      	movs	r2, #248	; 0xf8
 801139a:	569a      	ldrsb	r2, [r3, r2]
 801139c:	197b      	adds	r3, r7, r5
 801139e:	731a      	strb	r2, [r3, #12]
                    linkAdrReq.CurrentNbRep = MacCtx.NvmCtx->MacParams.ChannelsNbTrans;
 80113a0:	4bb8      	ldr	r3, [pc, #736]	; (8011684 <ProcessMacCommands+0x428>)
 80113a2:	4aba      	ldr	r2, [pc, #744]	; (801168c <ProcessMacCommands+0x430>)
 80113a4:	589a      	ldr	r2, [r3, r2]
 80113a6:	238c      	movs	r3, #140	; 0x8c
 80113a8:	005b      	lsls	r3, r3, #1
 80113aa:	5cd2      	ldrb	r2, [r2, r3]
 80113ac:	197b      	adds	r3, r7, r5
 80113ae:	735a      	strb	r2, [r3, #13]
                    linkAdrReq.Version = MacCtx.NvmCtx->Version;
 80113b0:	4bb4      	ldr	r3, [pc, #720]	; (8011684 <ProcessMacCommands+0x428>)
 80113b2:	4ab6      	ldr	r2, [pc, #728]	; (801168c <ProcessMacCommands+0x430>)
 80113b4:	5899      	ldr	r1, [r3, r2]
 80113b6:	197b      	adds	r3, r7, r5
 80113b8:	22e8      	movs	r2, #232	; 0xe8
 80113ba:	0052      	lsls	r2, r2, #1
 80113bc:	588a      	ldr	r2, [r1, r2]
 80113be:	601a      	str	r2, [r3, #0]

                    // Process the ADR requests
                    status = RegionLinkAdrReq( MacCtx.NvmCtx->Region, &linkAdrReq, &linkAdrDatarate,
 80113c0:	4bb0      	ldr	r3, [pc, #704]	; (8011684 <ProcessMacCommands+0x428>)
 80113c2:	4ab2      	ldr	r2, [pc, #712]	; (801168c <ProcessMacCommands+0x430>)
 80113c4:	589b      	ldr	r3, [r3, r2]
 80113c6:	7818      	ldrb	r0, [r3, #0]
 80113c8:	193c      	adds	r4, r7, r4
 80113ca:	19ba      	adds	r2, r7, r6
 80113cc:	1979      	adds	r1, r7, r5
 80113ce:	2354      	movs	r3, #84	; 0x54
 80113d0:	18fb      	adds	r3, r7, r3
 80113d2:	9301      	str	r3, [sp, #4]
 80113d4:	2555      	movs	r5, #85	; 0x55
 80113d6:	197b      	adds	r3, r7, r5
 80113d8:	9300      	str	r3, [sp, #0]
 80113da:	0023      	movs	r3, r4
 80113dc:	f006 f9a7 	bl	801772e <RegionLinkAdrReq>
 80113e0:	0003      	movs	r3, r0
 80113e2:	001a      	movs	r2, r3
 80113e4:	216b      	movs	r1, #107	; 0x6b
 80113e6:	187b      	adds	r3, r7, r1
 80113e8:	701a      	strb	r2, [r3, #0]
                                               &linkAdrTxPower, &linkAdrNbRep, &linkAdrNbBytesParsed );

                    if( ( status & 0x07 ) == 0x07 )
 80113ea:	187b      	adds	r3, r7, r1
 80113ec:	781b      	ldrb	r3, [r3, #0]
 80113ee:	001a      	movs	r2, r3
 80113f0:	2307      	movs	r3, #7
 80113f2:	4013      	ands	r3, r2
 80113f4:	2b07      	cmp	r3, #7
 80113f6:	d118      	bne.n	801142a <ProcessMacCommands+0x1ce>
                    {
                        MacCtx.NvmCtx->MacParams.ChannelsDatarate = linkAdrDatarate;
 80113f8:	4ba2      	ldr	r3, [pc, #648]	; (8011684 <ProcessMacCommands+0x428>)
 80113fa:	4aa4      	ldr	r2, [pc, #656]	; (801168c <ProcessMacCommands+0x430>)
 80113fc:	589b      	ldr	r3, [r3, r2]
 80113fe:	19ba      	adds	r2, r7, r6
 8011400:	2100      	movs	r1, #0
 8011402:	5651      	ldrsb	r1, [r2, r1]
 8011404:	22f9      	movs	r2, #249	; 0xf9
 8011406:	5499      	strb	r1, [r3, r2]
                        MacCtx.NvmCtx->MacParams.ChannelsTxPower = linkAdrTxPower;
 8011408:	4b9e      	ldr	r3, [pc, #632]	; (8011684 <ProcessMacCommands+0x428>)
 801140a:	4aa0      	ldr	r2, [pc, #640]	; (801168c <ProcessMacCommands+0x430>)
 801140c:	589b      	ldr	r3, [r3, r2]
 801140e:	2456      	movs	r4, #86	; 0x56
 8011410:	193a      	adds	r2, r7, r4
 8011412:	2100      	movs	r1, #0
 8011414:	5651      	ldrsb	r1, [r2, r1]
 8011416:	22f8      	movs	r2, #248	; 0xf8
 8011418:	5499      	strb	r1, [r3, r2]
                        MacCtx.NvmCtx->MacParams.ChannelsNbTrans = linkAdrNbRep;
 801141a:	4b9a      	ldr	r3, [pc, #616]	; (8011684 <ProcessMacCommands+0x428>)
 801141c:	4a9b      	ldr	r2, [pc, #620]	; (801168c <ProcessMacCommands+0x430>)
 801141e:	589a      	ldr	r2, [r3, r2]
 8011420:	197b      	adds	r3, r7, r5
 8011422:	7819      	ldrb	r1, [r3, #0]
 8011424:	238c      	movs	r3, #140	; 0x8c
 8011426:	005b      	lsls	r3, r3, #1
 8011428:	54d1      	strb	r1, [r2, r3]
                    }

                    // Add the answers to the buffer
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 801142a:	2386      	movs	r3, #134	; 0x86
 801142c:	18fb      	adds	r3, r7, r3
 801142e:	2200      	movs	r2, #0
 8011430:	701a      	strb	r2, [r3, #0]
 8011432:	e00c      	b.n	801144e <ProcessMacCommands+0x1f2>
                    {
                        LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );
 8011434:	236b      	movs	r3, #107	; 0x6b
 8011436:	18fb      	adds	r3, r7, r3
 8011438:	2201      	movs	r2, #1
 801143a:	0019      	movs	r1, r3
 801143c:	2003      	movs	r0, #3
 801143e:	f003 fff3 	bl	8015428 <LoRaMacCommandsAddCmd>
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 8011442:	2186      	movs	r1, #134	; 0x86
 8011444:	187b      	adds	r3, r7, r1
 8011446:	781a      	ldrb	r2, [r3, #0]
 8011448:	187b      	adds	r3, r7, r1
 801144a:	3201      	adds	r2, #1
 801144c:	701a      	strb	r2, [r3, #0]
 801144e:	2454      	movs	r4, #84	; 0x54
 8011450:	193b      	adds	r3, r7, r4
 8011452:	781b      	ldrb	r3, [r3, #0]
 8011454:	2105      	movs	r1, #5
 8011456:	0018      	movs	r0, r3
 8011458:	f7ee fe60 	bl	800011c <__udivsi3>
 801145c:	0003      	movs	r3, r0
 801145e:	b2db      	uxtb	r3, r3
 8011460:	2286      	movs	r2, #134	; 0x86
 8011462:	18ba      	adds	r2, r7, r2
 8011464:	7812      	ldrb	r2, [r2, #0]
 8011466:	429a      	cmp	r2, r3
 8011468:	d3e4      	bcc.n	8011434 <ProcessMacCommands+0x1d8>
                    }
                    // Update MAC index
                    macIndex += linkAdrNbBytesParsed - 1;
 801146a:	193b      	adds	r3, r7, r4
 801146c:	781a      	ldrb	r2, [r3, #0]
 801146e:	1cfb      	adds	r3, r7, #3
 8011470:	781b      	ldrb	r3, [r3, #0]
 8011472:	18d3      	adds	r3, r2, r3
 8011474:	b2da      	uxtb	r2, r3
 8011476:	1cfb      	adds	r3, r7, #3
 8011478:	3a01      	subs	r2, #1
 801147a:	701a      	strb	r2, [r3, #0]
                }
                break;
 801147c:	46c0      	nop			; (mov r8, r8)
 801147e:	f000 fc3e 	bl	8011cfe <ProcessMacCommands+0xaa2>
            }
            case SRV_MAC_DUTY_CYCLE_REQ:
            {
                MacCtx.NvmCtx->MaxDCycle = payload[macIndex++] & 0x0F;
 8011482:	1cfb      	adds	r3, r7, #3
 8011484:	781b      	ldrb	r3, [r3, #0]
 8011486:	1cfa      	adds	r2, r7, #3
 8011488:	1c59      	adds	r1, r3, #1
 801148a:	7011      	strb	r1, [r2, #0]
 801148c:	001a      	movs	r2, r3
 801148e:	687b      	ldr	r3, [r7, #4]
 8011490:	189b      	adds	r3, r3, r2
 8011492:	781b      	ldrb	r3, [r3, #0]
 8011494:	4a7b      	ldr	r2, [pc, #492]	; (8011684 <ProcessMacCommands+0x428>)
 8011496:	497d      	ldr	r1, [pc, #500]	; (801168c <ProcessMacCommands+0x430>)
 8011498:	5852      	ldr	r2, [r2, r1]
 801149a:	210f      	movs	r1, #15
 801149c:	400b      	ands	r3, r1
 801149e:	b2d9      	uxtb	r1, r3
 80114a0:	239e      	movs	r3, #158	; 0x9e
 80114a2:	005b      	lsls	r3, r3, #1
 80114a4:	54d1      	strb	r1, [r2, r3]
                MacCtx.NvmCtx->AggregatedDCycle = 1 << MacCtx.NvmCtx->MaxDCycle;
 80114a6:	4b77      	ldr	r3, [pc, #476]	; (8011684 <ProcessMacCommands+0x428>)
 80114a8:	4a78      	ldr	r2, [pc, #480]	; (801168c <ProcessMacCommands+0x430>)
 80114aa:	589a      	ldr	r2, [r3, r2]
 80114ac:	239e      	movs	r3, #158	; 0x9e
 80114ae:	005b      	lsls	r3, r3, #1
 80114b0:	5cd3      	ldrb	r3, [r2, r3]
 80114b2:	001a      	movs	r2, r3
 80114b4:	2301      	movs	r3, #1
 80114b6:	4093      	lsls	r3, r2
 80114b8:	0019      	movs	r1, r3
 80114ba:	4b72      	ldr	r3, [pc, #456]	; (8011684 <ProcessMacCommands+0x428>)
 80114bc:	4a73      	ldr	r2, [pc, #460]	; (801168c <ProcessMacCommands+0x430>)
 80114be:	589a      	ldr	r2, [r3, r2]
 80114c0:	b289      	uxth	r1, r1
 80114c2:	23e1      	movs	r3, #225	; 0xe1
 80114c4:	005b      	lsls	r3, r3, #1
 80114c6:	52d1      	strh	r1, [r2, r3]
                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );
 80114c8:	2368      	movs	r3, #104	; 0x68
 80114ca:	18fb      	adds	r3, r7, r3
 80114cc:	2200      	movs	r2, #0
 80114ce:	0019      	movs	r1, r3
 80114d0:	2004      	movs	r0, #4
 80114d2:	f003 ffa9 	bl	8015428 <LoRaMacCommandsAddCmd>
                break;
 80114d6:	f000 fc12 	bl	8011cfe <ProcessMacCommands+0xaa2>
            }
            case SRV_MAC_RX_PARAM_SETUP_REQ:
            {
                RxParamSetupReqParams_t rxParamSetupReq;
                status = 0x07;
 80114da:	256b      	movs	r5, #107	; 0x6b
 80114dc:	197b      	adds	r3, r7, r5
 80114de:	2207      	movs	r2, #7
 80114e0:	701a      	strb	r2, [r3, #0]

                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 80114e2:	1cfb      	adds	r3, r7, #3
 80114e4:	781b      	ldrb	r3, [r3, #0]
 80114e6:	687a      	ldr	r2, [r7, #4]
 80114e8:	18d3      	adds	r3, r2, r3
 80114ea:	781b      	ldrb	r3, [r3, #0]
 80114ec:	091b      	lsrs	r3, r3, #4
 80114ee:	b2db      	uxtb	r3, r3
 80114f0:	b25b      	sxtb	r3, r3
 80114f2:	2207      	movs	r2, #7
 80114f4:	4013      	ands	r3, r2
 80114f6:	b25a      	sxtb	r2, r3
 80114f8:	204c      	movs	r0, #76	; 0x4c
 80114fa:	183b      	adds	r3, r7, r0
 80114fc:	705a      	strb	r2, [r3, #1]
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 80114fe:	1cfb      	adds	r3, r7, #3
 8011500:	781b      	ldrb	r3, [r3, #0]
 8011502:	687a      	ldr	r2, [r7, #4]
 8011504:	18d3      	adds	r3, r2, r3
 8011506:	781b      	ldrb	r3, [r3, #0]
 8011508:	b25b      	sxtb	r3, r3
 801150a:	220f      	movs	r2, #15
 801150c:	4013      	ands	r3, r2
 801150e:	b25a      	sxtb	r2, r3
 8011510:	183b      	adds	r3, r7, r0
 8011512:	701a      	strb	r2, [r3, #0]
                macIndex++;
 8011514:	1cfb      	adds	r3, r7, #3
 8011516:	781a      	ldrb	r2, [r3, #0]
 8011518:	1cfb      	adds	r3, r7, #3
 801151a:	3201      	adds	r2, #1
 801151c:	701a      	strb	r2, [r3, #0]

                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 801151e:	1cfb      	adds	r3, r7, #3
 8011520:	781b      	ldrb	r3, [r3, #0]
 8011522:	1cfa      	adds	r2, r7, #3
 8011524:	1c59      	adds	r1, r3, #1
 8011526:	7011      	strb	r1, [r2, #0]
 8011528:	001a      	movs	r2, r3
 801152a:	687b      	ldr	r3, [r7, #4]
 801152c:	189b      	adds	r3, r3, r2
 801152e:	781b      	ldrb	r3, [r3, #0]
 8011530:	001a      	movs	r2, r3
 8011532:	183b      	adds	r3, r7, r0
 8011534:	605a      	str	r2, [r3, #4]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8011536:	1cfb      	adds	r3, r7, #3
 8011538:	781b      	ldrb	r3, [r3, #0]
 801153a:	1cfa      	adds	r2, r7, #3
 801153c:	1c59      	adds	r1, r3, #1
 801153e:	7011      	strb	r1, [r2, #0]
 8011540:	001a      	movs	r2, r3
 8011542:	687b      	ldr	r3, [r7, #4]
 8011544:	189b      	adds	r3, r3, r2
 8011546:	781b      	ldrb	r3, [r3, #0]
 8011548:	021a      	lsls	r2, r3, #8
 801154a:	183b      	adds	r3, r7, r0
 801154c:	685b      	ldr	r3, [r3, #4]
 801154e:	431a      	orrs	r2, r3
 8011550:	183b      	adds	r3, r7, r0
 8011552:	605a      	str	r2, [r3, #4]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8011554:	1cfb      	adds	r3, r7, #3
 8011556:	781b      	ldrb	r3, [r3, #0]
 8011558:	1cfa      	adds	r2, r7, #3
 801155a:	1c59      	adds	r1, r3, #1
 801155c:	7011      	strb	r1, [r2, #0]
 801155e:	001a      	movs	r2, r3
 8011560:	687b      	ldr	r3, [r7, #4]
 8011562:	189b      	adds	r3, r3, r2
 8011564:	781b      	ldrb	r3, [r3, #0]
 8011566:	041a      	lsls	r2, r3, #16
 8011568:	183b      	adds	r3, r7, r0
 801156a:	685b      	ldr	r3, [r3, #4]
 801156c:	431a      	orrs	r2, r3
 801156e:	0004      	movs	r4, r0
 8011570:	193b      	adds	r3, r7, r4
 8011572:	605a      	str	r2, [r3, #4]
                rxParamSetupReq.Frequency *= 100;
 8011574:	193b      	adds	r3, r7, r4
 8011576:	685b      	ldr	r3, [r3, #4]
 8011578:	2264      	movs	r2, #100	; 0x64
 801157a:	435a      	muls	r2, r3
 801157c:	193b      	adds	r3, r7, r4
 801157e:	605a      	str	r2, [r3, #4]

                // Perform request on region
                status = RegionRxParamSetupReq( MacCtx.NvmCtx->Region, &rxParamSetupReq );
 8011580:	4b40      	ldr	r3, [pc, #256]	; (8011684 <ProcessMacCommands+0x428>)
 8011582:	4a42      	ldr	r2, [pc, #264]	; (801168c <ProcessMacCommands+0x430>)
 8011584:	589b      	ldr	r3, [r3, r2]
 8011586:	781b      	ldrb	r3, [r3, #0]
 8011588:	193a      	adds	r2, r7, r4
 801158a:	0011      	movs	r1, r2
 801158c:	0018      	movs	r0, r3
 801158e:	f006 f8ec 	bl	801776a <RegionRxParamSetupReq>
 8011592:	0003      	movs	r3, r0
 8011594:	001a      	movs	r2, r3
 8011596:	197b      	adds	r3, r7, r5
 8011598:	701a      	strb	r2, [r3, #0]

                if( ( status & 0x07 ) == 0x07 )
 801159a:	197b      	adds	r3, r7, r5
 801159c:	781b      	ldrb	r3, [r3, #0]
 801159e:	001a      	movs	r2, r3
 80115a0:	2307      	movs	r3, #7
 80115a2:	4013      	ands	r3, r2
 80115a4:	2b07      	cmp	r3, #7
 80115a6:	d12d      	bne.n	8011604 <ProcessMacCommands+0x3a8>
                {
                    MacCtx.NvmCtx->MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;
 80115a8:	193b      	adds	r3, r7, r4
 80115aa:	2100      	movs	r1, #0
 80115ac:	5659      	ldrsb	r1, [r3, r1]
 80115ae:	4b35      	ldr	r3, [pc, #212]	; (8011684 <ProcessMacCommands+0x428>)
 80115b0:	4a36      	ldr	r2, [pc, #216]	; (801168c <ProcessMacCommands+0x430>)
 80115b2:	589a      	ldr	r2, [r3, r2]
 80115b4:	b2c9      	uxtb	r1, r1
 80115b6:	2390      	movs	r3, #144	; 0x90
 80115b8:	005b      	lsls	r3, r3, #1
 80115ba:	54d1      	strb	r1, [r2, r3]
                    MacCtx.NvmCtx->MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;
 80115bc:	193b      	adds	r3, r7, r4
 80115be:	2100      	movs	r1, #0
 80115c0:	5659      	ldrsb	r1, [r3, r1]
 80115c2:	4b30      	ldr	r3, [pc, #192]	; (8011684 <ProcessMacCommands+0x428>)
 80115c4:	4a31      	ldr	r2, [pc, #196]	; (801168c <ProcessMacCommands+0x430>)
 80115c6:	589a      	ldr	r2, [r3, r2]
 80115c8:	b2c9      	uxtb	r1, r1
 80115ca:	2394      	movs	r3, #148	; 0x94
 80115cc:	005b      	lsls	r3, r3, #1
 80115ce:	54d1      	strb	r1, [r2, r3]
                    MacCtx.NvmCtx->MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;
 80115d0:	4b2c      	ldr	r3, [pc, #176]	; (8011684 <ProcessMacCommands+0x428>)
 80115d2:	4a2e      	ldr	r2, [pc, #184]	; (801168c <ProcessMacCommands+0x430>)
 80115d4:	589a      	ldr	r2, [r3, r2]
 80115d6:	193b      	adds	r3, r7, r4
 80115d8:	6859      	ldr	r1, [r3, #4]
 80115da:	238e      	movs	r3, #142	; 0x8e
 80115dc:	005b      	lsls	r3, r3, #1
 80115de:	50d1      	str	r1, [r2, r3]
                    MacCtx.NvmCtx->MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;
 80115e0:	4b28      	ldr	r3, [pc, #160]	; (8011684 <ProcessMacCommands+0x428>)
 80115e2:	4a2a      	ldr	r2, [pc, #168]	; (801168c <ProcessMacCommands+0x430>)
 80115e4:	589a      	ldr	r2, [r3, r2]
 80115e6:	193b      	adds	r3, r7, r4
 80115e8:	6859      	ldr	r1, [r3, #4]
 80115ea:	2392      	movs	r3, #146	; 0x92
 80115ec:	005b      	lsls	r3, r3, #1
 80115ee:	50d1      	str	r1, [r2, r3]
                    MacCtx.NvmCtx->MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;
 80115f0:	193b      	adds	r3, r7, r4
 80115f2:	2101      	movs	r1, #1
 80115f4:	5659      	ldrsb	r1, [r3, r1]
 80115f6:	4b23      	ldr	r3, [pc, #140]	; (8011684 <ProcessMacCommands+0x428>)
 80115f8:	4a24      	ldr	r2, [pc, #144]	; (801168c <ProcessMacCommands+0x430>)
 80115fa:	589a      	ldr	r2, [r3, r2]
 80115fc:	b2c9      	uxtb	r1, r1
 80115fe:	231a      	movs	r3, #26
 8011600:	33ff      	adds	r3, #255	; 0xff
 8011602:	54d1      	strb	r1, [r2, r3]
                }
                macCmdPayload[0] = status;
 8011604:	236b      	movs	r3, #107	; 0x6b
 8011606:	18fb      	adds	r3, r7, r3
 8011608:	781a      	ldrb	r2, [r3, #0]
 801160a:	2168      	movs	r1, #104	; 0x68
 801160c:	187b      	adds	r3, r7, r1
 801160e:	701a      	strb	r2, [r3, #0]
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );
 8011610:	187b      	adds	r3, r7, r1
 8011612:	2201      	movs	r2, #1
 8011614:	0019      	movs	r1, r3
 8011616:	2005      	movs	r0, #5
 8011618:	f003 ff06 	bl	8015428 <LoRaMacCommandsAddCmd>
                // Setup indication to inform the application
                SetMlmeScheduleUplinkIndication( );
 801161c:	f7ff fe0e 	bl	801123c <SetMlmeScheduleUplinkIndication>
                break;
 8011620:	46c0      	nop			; (mov r8, r8)
 8011622:	e36c      	b.n	8011cfe <ProcessMacCommands+0xaa2>
            }
            case SRV_MAC_DEV_STATUS_REQ:
            {
                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;
 8011624:	2185      	movs	r1, #133	; 0x85
 8011626:	187b      	adds	r3, r7, r1
 8011628:	22ff      	movs	r2, #255	; 0xff
 801162a:	701a      	strb	r2, [r3, #0]
                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )
 801162c:	4a15      	ldr	r2, [pc, #84]	; (8011684 <ProcessMacCommands+0x428>)
 801162e:	23d2      	movs	r3, #210	; 0xd2
 8011630:	009b      	lsls	r3, r3, #2
 8011632:	58d3      	ldr	r3, [r2, r3]
 8011634:	2b00      	cmp	r3, #0
 8011636:	d00f      	beq.n	8011658 <ProcessMacCommands+0x3fc>
 8011638:	4a12      	ldr	r2, [pc, #72]	; (8011684 <ProcessMacCommands+0x428>)
 801163a:	23d2      	movs	r3, #210	; 0xd2
 801163c:	009b      	lsls	r3, r3, #2
 801163e:	58d3      	ldr	r3, [r2, r3]
 8011640:	681b      	ldr	r3, [r3, #0]
 8011642:	2b00      	cmp	r3, #0
 8011644:	d008      	beq.n	8011658 <ProcessMacCommands+0x3fc>
                {
                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );
 8011646:	4a0f      	ldr	r2, [pc, #60]	; (8011684 <ProcessMacCommands+0x428>)
 8011648:	23d2      	movs	r3, #210	; 0xd2
 801164a:	009b      	lsls	r3, r3, #2
 801164c:	58d3      	ldr	r3, [r2, r3]
 801164e:	681b      	ldr	r3, [r3, #0]
 8011650:	187c      	adds	r4, r7, r1
 8011652:	4798      	blx	r3
 8011654:	0003      	movs	r3, r0
 8011656:	7023      	strb	r3, [r4, #0]
                }
                macCmdPayload[0] = batteryLevel;
 8011658:	2168      	movs	r1, #104	; 0x68
 801165a:	187b      	adds	r3, r7, r1
 801165c:	2285      	movs	r2, #133	; 0x85
 801165e:	18ba      	adds	r2, r7, r2
 8011660:	7812      	ldrb	r2, [r2, #0]
 8011662:	701a      	strb	r2, [r3, #0]
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 8011664:	1c7b      	adds	r3, r7, #1
 8011666:	781b      	ldrb	r3, [r3, #0]
 8011668:	223f      	movs	r2, #63	; 0x3f
 801166a:	4013      	ands	r3, r2
 801166c:	b2da      	uxtb	r2, r3
 801166e:	187b      	adds	r3, r7, r1
 8011670:	705a      	strb	r2, [r3, #1]
                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );
 8011672:	187b      	adds	r3, r7, r1
 8011674:	2202      	movs	r2, #2
 8011676:	0019      	movs	r1, r3
 8011678:	2006      	movs	r0, #6
 801167a:	f003 fed5 	bl	8015428 <LoRaMacCommandsAddCmd>
                break;
 801167e:	e33e      	b.n	8011cfe <ProcessMacCommands+0xaa2>
 8011680:	0801f1e0 	.word	0x0801f1e0
 8011684:	200008ec 	.word	0x200008ec
 8011688:	00000459 	.word	0x00000459
 801168c:	00000484 	.word	0x00000484
            }
            case SRV_MAC_NEW_CHANNEL_REQ:
            {
                NewChannelReqParams_t newChannelReq;
                ChannelParams_t chParam;
                status = 0x03;
 8011690:	246b      	movs	r4, #107	; 0x6b
 8011692:	193b      	adds	r3, r7, r4
 8011694:	2203      	movs	r2, #3
 8011696:	701a      	strb	r2, [r3, #0]

                newChannelReq.ChannelId = payload[macIndex++];
 8011698:	1cfb      	adds	r3, r7, #3
 801169a:	781b      	ldrb	r3, [r3, #0]
 801169c:	1cfa      	adds	r2, r7, #3
 801169e:	1c59      	adds	r1, r3, #1
 80116a0:	7011      	strb	r1, [r2, #0]
 80116a2:	001a      	movs	r2, r3
 80116a4:	687b      	ldr	r3, [r7, #4]
 80116a6:	189b      	adds	r3, r3, r2
 80116a8:	781b      	ldrb	r3, [r3, #0]
 80116aa:	b25a      	sxtb	r2, r3
 80116ac:	2544      	movs	r5, #68	; 0x44
 80116ae:	197b      	adds	r3, r7, r5
 80116b0:	711a      	strb	r2, [r3, #4]
                newChannelReq.NewChannel = &chParam;
 80116b2:	197b      	adds	r3, r7, r5
 80116b4:	2038      	movs	r0, #56	; 0x38
 80116b6:	183a      	adds	r2, r7, r0
 80116b8:	601a      	str	r2, [r3, #0]

                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 80116ba:	1cfb      	adds	r3, r7, #3
 80116bc:	781b      	ldrb	r3, [r3, #0]
 80116be:	1cfa      	adds	r2, r7, #3
 80116c0:	1c59      	adds	r1, r3, #1
 80116c2:	7011      	strb	r1, [r2, #0]
 80116c4:	001a      	movs	r2, r3
 80116c6:	687b      	ldr	r3, [r7, #4]
 80116c8:	189b      	adds	r3, r3, r2
 80116ca:	781b      	ldrb	r3, [r3, #0]
 80116cc:	001a      	movs	r2, r3
 80116ce:	183b      	adds	r3, r7, r0
 80116d0:	601a      	str	r2, [r3, #0]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 80116d2:	1cfb      	adds	r3, r7, #3
 80116d4:	781b      	ldrb	r3, [r3, #0]
 80116d6:	1cfa      	adds	r2, r7, #3
 80116d8:	1c59      	adds	r1, r3, #1
 80116da:	7011      	strb	r1, [r2, #0]
 80116dc:	001a      	movs	r2, r3
 80116de:	687b      	ldr	r3, [r7, #4]
 80116e0:	189b      	adds	r3, r3, r2
 80116e2:	781b      	ldrb	r3, [r3, #0]
 80116e4:	021a      	lsls	r2, r3, #8
 80116e6:	183b      	adds	r3, r7, r0
 80116e8:	681b      	ldr	r3, [r3, #0]
 80116ea:	431a      	orrs	r2, r3
 80116ec:	183b      	adds	r3, r7, r0
 80116ee:	601a      	str	r2, [r3, #0]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 80116f0:	1cfb      	adds	r3, r7, #3
 80116f2:	781b      	ldrb	r3, [r3, #0]
 80116f4:	1cfa      	adds	r2, r7, #3
 80116f6:	1c59      	adds	r1, r3, #1
 80116f8:	7011      	strb	r1, [r2, #0]
 80116fa:	001a      	movs	r2, r3
 80116fc:	687b      	ldr	r3, [r7, #4]
 80116fe:	189b      	adds	r3, r3, r2
 8011700:	781b      	ldrb	r3, [r3, #0]
 8011702:	041a      	lsls	r2, r3, #16
 8011704:	183b      	adds	r3, r7, r0
 8011706:	681b      	ldr	r3, [r3, #0]
 8011708:	431a      	orrs	r2, r3
 801170a:	183b      	adds	r3, r7, r0
 801170c:	601a      	str	r2, [r3, #0]
                chParam.Frequency *= 100;
 801170e:	183b      	adds	r3, r7, r0
 8011710:	681b      	ldr	r3, [r3, #0]
 8011712:	2264      	movs	r2, #100	; 0x64
 8011714:	435a      	muls	r2, r3
 8011716:	183b      	adds	r3, r7, r0
 8011718:	601a      	str	r2, [r3, #0]
                chParam.Rx1Frequency = 0;
 801171a:	183b      	adds	r3, r7, r0
 801171c:	2200      	movs	r2, #0
 801171e:	605a      	str	r2, [r3, #4]
                chParam.DrRange.Value = payload[macIndex++];
 8011720:	1cfb      	adds	r3, r7, #3
 8011722:	781b      	ldrb	r3, [r3, #0]
 8011724:	1cfa      	adds	r2, r7, #3
 8011726:	1c59      	adds	r1, r3, #1
 8011728:	7011      	strb	r1, [r2, #0]
 801172a:	001a      	movs	r2, r3
 801172c:	687b      	ldr	r3, [r7, #4]
 801172e:	189b      	adds	r3, r3, r2
 8011730:	781b      	ldrb	r3, [r3, #0]
 8011732:	b25a      	sxtb	r2, r3
 8011734:	183b      	adds	r3, r7, r0
 8011736:	721a      	strb	r2, [r3, #8]

                status = RegionNewChannelReq( MacCtx.NvmCtx->Region, &newChannelReq );
 8011738:	4ba3      	ldr	r3, [pc, #652]	; (80119c8 <ProcessMacCommands+0x76c>)
 801173a:	4aa4      	ldr	r2, [pc, #656]	; (80119cc <ProcessMacCommands+0x770>)
 801173c:	589b      	ldr	r3, [r3, r2]
 801173e:	781b      	ldrb	r3, [r3, #0]
 8011740:	197a      	adds	r2, r7, r5
 8011742:	0011      	movs	r1, r2
 8011744:	0018      	movs	r0, r3
 8011746:	f006 f826 	bl	8017796 <RegionNewChannelReq>
 801174a:	0003      	movs	r3, r0
 801174c:	001a      	movs	r2, r3
 801174e:	193b      	adds	r3, r7, r4
 8011750:	701a      	strb	r2, [r3, #0]

                macCmdPayload[0] = status;
 8011752:	193b      	adds	r3, r7, r4
 8011754:	781a      	ldrb	r2, [r3, #0]
 8011756:	2168      	movs	r1, #104	; 0x68
 8011758:	187b      	adds	r3, r7, r1
 801175a:	701a      	strb	r2, [r3, #0]
                LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );
 801175c:	187b      	adds	r3, r7, r1
 801175e:	2201      	movs	r2, #1
 8011760:	0019      	movs	r1, r3
 8011762:	2007      	movs	r0, #7
 8011764:	f003 fe60 	bl	8015428 <LoRaMacCommandsAddCmd>
                break;
 8011768:	46c0      	nop			; (mov r8, r8)
 801176a:	e2c8      	b.n	8011cfe <ProcessMacCommands+0xaa2>
            }
            case SRV_MAC_RX_TIMING_SETUP_REQ:
            {
                uint8_t delay = payload[macIndex++] & 0x0F;
 801176c:	1cfb      	adds	r3, r7, #3
 801176e:	781b      	ldrb	r3, [r3, #0]
 8011770:	1cfa      	adds	r2, r7, #3
 8011772:	1c59      	adds	r1, r3, #1
 8011774:	7011      	strb	r1, [r2, #0]
 8011776:	001a      	movs	r2, r3
 8011778:	687b      	ldr	r3, [r7, #4]
 801177a:	189b      	adds	r3, r3, r2
 801177c:	781a      	ldrb	r2, [r3, #0]
 801177e:	2084      	movs	r0, #132	; 0x84
 8011780:	183b      	adds	r3, r7, r0
 8011782:	210f      	movs	r1, #15
 8011784:	400a      	ands	r2, r1
 8011786:	701a      	strb	r2, [r3, #0]

                if( delay == 0 )
 8011788:	183b      	adds	r3, r7, r0
 801178a:	781b      	ldrb	r3, [r3, #0]
 801178c:	2b00      	cmp	r3, #0
 801178e:	d104      	bne.n	801179a <ProcessMacCommands+0x53e>
                {
                    delay++;
 8011790:	183b      	adds	r3, r7, r0
 8011792:	781a      	ldrb	r2, [r3, #0]
 8011794:	183b      	adds	r3, r7, r0
 8011796:	3201      	adds	r2, #1
 8011798:	701a      	strb	r2, [r3, #0]
                }
                MacCtx.NvmCtx->MacParams.ReceiveDelay1 = delay * 1000;
 801179a:	2384      	movs	r3, #132	; 0x84
 801179c:	18fb      	adds	r3, r7, r3
 801179e:	781a      	ldrb	r2, [r3, #0]
 80117a0:	0013      	movs	r3, r2
 80117a2:	015b      	lsls	r3, r3, #5
 80117a4:	1a9b      	subs	r3, r3, r2
 80117a6:	009b      	lsls	r3, r3, #2
 80117a8:	189b      	adds	r3, r3, r2
 80117aa:	00db      	lsls	r3, r3, #3
 80117ac:	0019      	movs	r1, r3
 80117ae:	4b86      	ldr	r3, [pc, #536]	; (80119c8 <ProcessMacCommands+0x76c>)
 80117b0:	4a86      	ldr	r2, [pc, #536]	; (80119cc <ProcessMacCommands+0x770>)
 80117b2:	589a      	ldr	r2, [r3, r2]
 80117b4:	2384      	movs	r3, #132	; 0x84
 80117b6:	005b      	lsls	r3, r3, #1
 80117b8:	50d1      	str	r1, [r2, r3]
                MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + 1000;
 80117ba:	4b83      	ldr	r3, [pc, #524]	; (80119c8 <ProcessMacCommands+0x76c>)
 80117bc:	4a83      	ldr	r2, [pc, #524]	; (80119cc <ProcessMacCommands+0x770>)
 80117be:	589a      	ldr	r2, [r3, r2]
 80117c0:	2384      	movs	r3, #132	; 0x84
 80117c2:	005b      	lsls	r3, r3, #1
 80117c4:	58d3      	ldr	r3, [r2, r3]
 80117c6:	4a80      	ldr	r2, [pc, #512]	; (80119c8 <ProcessMacCommands+0x76c>)
 80117c8:	4980      	ldr	r1, [pc, #512]	; (80119cc <ProcessMacCommands+0x770>)
 80117ca:	5852      	ldr	r2, [r2, r1]
 80117cc:	21fa      	movs	r1, #250	; 0xfa
 80117ce:	0089      	lsls	r1, r1, #2
 80117d0:	1859      	adds	r1, r3, r1
 80117d2:	2386      	movs	r3, #134	; 0x86
 80117d4:	005b      	lsls	r3, r3, #1
 80117d6:	50d1      	str	r1, [r2, r3]
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 80117d8:	2368      	movs	r3, #104	; 0x68
 80117da:	18fb      	adds	r3, r7, r3
 80117dc:	2200      	movs	r2, #0
 80117de:	0019      	movs	r1, r3
 80117e0:	2008      	movs	r0, #8
 80117e2:	f003 fe21 	bl	8015428 <LoRaMacCommandsAddCmd>
                // Setup indication to inform the application
                SetMlmeScheduleUplinkIndication( );
 80117e6:	f7ff fd29 	bl	801123c <SetMlmeScheduleUplinkIndication>
                break;
 80117ea:	e288      	b.n	8011cfe <ProcessMacCommands+0xaa2>
            case SRV_MAC_TX_PARAM_SETUP_REQ:
            {
                TxParamSetupReqParams_t txParamSetupReq;
                GetPhyParams_t getPhy;
                PhyParam_t phyParam;
                uint8_t eirpDwellTime = payload[macIndex++];
 80117ec:	1cfb      	adds	r3, r7, #3
 80117ee:	781b      	ldrb	r3, [r3, #0]
 80117f0:	1cfa      	adds	r2, r7, #3
 80117f2:	1c59      	adds	r1, r3, #1
 80117f4:	7011      	strb	r1, [r2, #0]
 80117f6:	001a      	movs	r2, r3
 80117f8:	687b      	ldr	r3, [r7, #4]
 80117fa:	189a      	adds	r2, r3, r2
 80117fc:	2076      	movs	r0, #118	; 0x76
 80117fe:	183b      	adds	r3, r7, r0
 8011800:	7812      	ldrb	r2, [r2, #0]
 8011802:	701a      	strb	r2, [r3, #0]

                txParamSetupReq.UplinkDwellTime = 0;
 8011804:	2134      	movs	r1, #52	; 0x34
 8011806:	187b      	adds	r3, r7, r1
 8011808:	2200      	movs	r2, #0
 801180a:	701a      	strb	r2, [r3, #0]
                txParamSetupReq.DownlinkDwellTime = 0;
 801180c:	187b      	adds	r3, r7, r1
 801180e:	2200      	movs	r2, #0
 8011810:	705a      	strb	r2, [r3, #1]

                if( ( eirpDwellTime & 0x20 ) == 0x20 )
 8011812:	183b      	adds	r3, r7, r0
 8011814:	781b      	ldrb	r3, [r3, #0]
 8011816:	2220      	movs	r2, #32
 8011818:	4013      	ands	r3, r2
 801181a:	d002      	beq.n	8011822 <ProcessMacCommands+0x5c6>
                {
                    txParamSetupReq.DownlinkDwellTime = 1;
 801181c:	187b      	adds	r3, r7, r1
 801181e:	2201      	movs	r2, #1
 8011820:	705a      	strb	r2, [r3, #1]
                }
                if( ( eirpDwellTime & 0x10 ) == 0x10 )
 8011822:	2376      	movs	r3, #118	; 0x76
 8011824:	18fb      	adds	r3, r7, r3
 8011826:	781b      	ldrb	r3, [r3, #0]
 8011828:	2210      	movs	r2, #16
 801182a:	4013      	ands	r3, r2
 801182c:	d003      	beq.n	8011836 <ProcessMacCommands+0x5da>
                {
                    txParamSetupReq.UplinkDwellTime = 1;
 801182e:	2334      	movs	r3, #52	; 0x34
 8011830:	18fb      	adds	r3, r7, r3
 8011832:	2201      	movs	r2, #1
 8011834:	701a      	strb	r2, [r3, #0]
                }
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 8011836:	2376      	movs	r3, #118	; 0x76
 8011838:	18fb      	adds	r3, r7, r3
 801183a:	781b      	ldrb	r3, [r3, #0]
 801183c:	220f      	movs	r2, #15
 801183e:	4013      	ands	r3, r2
 8011840:	b2da      	uxtb	r2, r3
 8011842:	2434      	movs	r4, #52	; 0x34
 8011844:	193b      	adds	r3, r7, r4
 8011846:	709a      	strb	r2, [r3, #2]

                // Check the status for correctness
                if( RegionTxParamSetupReq( MacCtx.NvmCtx->Region, &txParamSetupReq ) != -1 )
 8011848:	4b5f      	ldr	r3, [pc, #380]	; (80119c8 <ProcessMacCommands+0x76c>)
 801184a:	4a60      	ldr	r2, [pc, #384]	; (80119cc <ProcessMacCommands+0x770>)
 801184c:	589b      	ldr	r3, [r3, r2]
 801184e:	781b      	ldrb	r3, [r3, #0]
 8011850:	193a      	adds	r2, r7, r4
 8011852:	0011      	movs	r1, r2
 8011854:	0018      	movs	r0, r3
 8011856:	f005 ffb4 	bl	80177c2 <RegionTxParamSetupReq>
 801185a:	0003      	movs	r3, r0
 801185c:	3301      	adds	r3, #1
 801185e:	d054      	beq.n	801190a <ProcessMacCommands+0x6ae>
                {
                    // Accept command
                    MacCtx.NvmCtx->MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8011860:	4b59      	ldr	r3, [pc, #356]	; (80119c8 <ProcessMacCommands+0x76c>)
 8011862:	4a5a      	ldr	r2, [pc, #360]	; (80119cc <ProcessMacCommands+0x770>)
 8011864:	589a      	ldr	r2, [r3, r2]
 8011866:	193b      	adds	r3, r7, r4
 8011868:	7819      	ldrb	r1, [r3, #0]
 801186a:	2396      	movs	r3, #150	; 0x96
 801186c:	005b      	lsls	r3, r3, #1
 801186e:	54d1      	strb	r1, [r2, r3]
                    MacCtx.NvmCtx->MacParams.DownlinkDwellTime = txParamSetupReq.DownlinkDwellTime;
 8011870:	4b55      	ldr	r3, [pc, #340]	; (80119c8 <ProcessMacCommands+0x76c>)
 8011872:	4a56      	ldr	r2, [pc, #344]	; (80119cc <ProcessMacCommands+0x770>)
 8011874:	589a      	ldr	r2, [r3, r2]
 8011876:	193b      	adds	r3, r7, r4
 8011878:	7859      	ldrb	r1, [r3, #1]
 801187a:	232e      	movs	r3, #46	; 0x2e
 801187c:	33ff      	adds	r3, #255	; 0xff
 801187e:	54d1      	strb	r1, [r2, r3]
                    MacCtx.NvmCtx->MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8011880:	193b      	adds	r3, r7, r4
 8011882:	789b      	ldrb	r3, [r3, #2]
 8011884:	001a      	movs	r2, r3
 8011886:	4b52      	ldr	r3, [pc, #328]	; (80119d0 <ProcessMacCommands+0x774>)
 8011888:	5c9a      	ldrb	r2, [r3, r2]
 801188a:	4b4f      	ldr	r3, [pc, #316]	; (80119c8 <ProcessMacCommands+0x76c>)
 801188c:	494f      	ldr	r1, [pc, #316]	; (80119cc <ProcessMacCommands+0x770>)
 801188e:	585c      	ldr	r4, [r3, r1]
 8011890:	0010      	movs	r0, r2
 8011892:	f7ef fe01 	bl	8001498 <__aeabi_ui2f>
 8011896:	1c02      	adds	r2, r0, #0
 8011898:	2398      	movs	r3, #152	; 0x98
 801189a:	005b      	lsls	r3, r3, #1
 801189c:	50e2      	str	r2, [r4, r3]
                    // Update the datarate in case of the new configuration limits it
                    getPhy.Attribute = PHY_MIN_TX_DR;
 801189e:	2130      	movs	r1, #48	; 0x30
 80118a0:	187b      	adds	r3, r7, r1
 80118a2:	2202      	movs	r2, #2
 80118a4:	701a      	strb	r2, [r3, #0]
                    getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;
 80118a6:	4b48      	ldr	r3, [pc, #288]	; (80119c8 <ProcessMacCommands+0x76c>)
 80118a8:	4a48      	ldr	r2, [pc, #288]	; (80119cc <ProcessMacCommands+0x770>)
 80118aa:	589a      	ldr	r2, [r3, r2]
 80118ac:	2396      	movs	r3, #150	; 0x96
 80118ae:	005b      	lsls	r3, r3, #1
 80118b0:	5cd2      	ldrb	r2, [r2, r3]
 80118b2:	187b      	adds	r3, r7, r1
 80118b4:	709a      	strb	r2, [r3, #2]
                    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 80118b6:	4b44      	ldr	r3, [pc, #272]	; (80119c8 <ProcessMacCommands+0x76c>)
 80118b8:	4a44      	ldr	r2, [pc, #272]	; (80119cc <ProcessMacCommands+0x770>)
 80118ba:	589b      	ldr	r3, [r3, r2]
 80118bc:	781b      	ldrb	r3, [r3, #0]
 80118be:	187a      	adds	r2, r7, r1
 80118c0:	0011      	movs	r1, r2
 80118c2:	0018      	movs	r0, r3
 80118c4:	f005 fe2b 	bl	801751e <RegionGetPhyParam>
 80118c8:	0003      	movs	r3, r0
 80118ca:	001a      	movs	r2, r3
 80118cc:	212c      	movs	r1, #44	; 0x2c
 80118ce:	187b      	adds	r3, r7, r1
 80118d0:	601a      	str	r2, [r3, #0]
                    MacCtx.NvmCtx->MacParams.ChannelsDatarate = MAX( MacCtx.NvmCtx->MacParams.ChannelsDatarate, ( int8_t )phyParam.Value );
 80118d2:	187b      	adds	r3, r7, r1
 80118d4:	681b      	ldr	r3, [r3, #0]
 80118d6:	b259      	sxtb	r1, r3
 80118d8:	4b3b      	ldr	r3, [pc, #236]	; (80119c8 <ProcessMacCommands+0x76c>)
 80118da:	4a3c      	ldr	r2, [pc, #240]	; (80119cc <ProcessMacCommands+0x770>)
 80118dc:	589b      	ldr	r3, [r3, r2]
 80118de:	22f9      	movs	r2, #249	; 0xf9
 80118e0:	5698      	ldrsb	r0, [r3, r2]
 80118e2:	4b39      	ldr	r3, [pc, #228]	; (80119c8 <ProcessMacCommands+0x76c>)
 80118e4:	4a39      	ldr	r2, [pc, #228]	; (80119cc <ProcessMacCommands+0x770>)
 80118e6:	589b      	ldr	r3, [r3, r2]
 80118e8:	1c04      	adds	r4, r0, #0
 80118ea:	1c08      	adds	r0, r1, #0
 80118ec:	b241      	sxtb	r1, r0
 80118ee:	b262      	sxtb	r2, r4
 80118f0:	4291      	cmp	r1, r2
 80118f2:	da00      	bge.n	80118f6 <ProcessMacCommands+0x69a>
 80118f4:	1c20      	adds	r0, r4, #0
 80118f6:	b241      	sxtb	r1, r0
 80118f8:	22f9      	movs	r2, #249	; 0xf9
 80118fa:	5499      	strb	r1, [r3, r2]

                    // Add command response
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 80118fc:	2368      	movs	r3, #104	; 0x68
 80118fe:	18fb      	adds	r3, r7, r3
 8011900:	2200      	movs	r2, #0
 8011902:	0019      	movs	r1, r3
 8011904:	2009      	movs	r0, #9
 8011906:	f003 fd8f 	bl	8015428 <LoRaMacCommandsAddCmd>
                }
                break;
 801190a:	46c0      	nop			; (mov r8, r8)
 801190c:	e1f7      	b.n	8011cfe <ProcessMacCommands+0xaa2>
            }
            case SRV_MAC_DL_CHANNEL_REQ:
            {
                DlChannelReqParams_t dlChannelReq;
                status = 0x03;
 801190e:	246b      	movs	r4, #107	; 0x6b
 8011910:	193b      	adds	r3, r7, r4
 8011912:	2203      	movs	r2, #3
 8011914:	701a      	strb	r2, [r3, #0]

                dlChannelReq.ChannelId = payload[macIndex++];
 8011916:	1cfb      	adds	r3, r7, #3
 8011918:	781b      	ldrb	r3, [r3, #0]
 801191a:	1cfa      	adds	r2, r7, #3
 801191c:	1c59      	adds	r1, r3, #1
 801191e:	7011      	strb	r1, [r2, #0]
 8011920:	001a      	movs	r2, r3
 8011922:	687b      	ldr	r3, [r7, #4]
 8011924:	189b      	adds	r3, r3, r2
 8011926:	781a      	ldrb	r2, [r3, #0]
 8011928:	2024      	movs	r0, #36	; 0x24
 801192a:	183b      	adds	r3, r7, r0
 801192c:	701a      	strb	r2, [r3, #0]
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 801192e:	1cfb      	adds	r3, r7, #3
 8011930:	781b      	ldrb	r3, [r3, #0]
 8011932:	1cfa      	adds	r2, r7, #3
 8011934:	1c59      	adds	r1, r3, #1
 8011936:	7011      	strb	r1, [r2, #0]
 8011938:	001a      	movs	r2, r3
 801193a:	687b      	ldr	r3, [r7, #4]
 801193c:	189b      	adds	r3, r3, r2
 801193e:	781b      	ldrb	r3, [r3, #0]
 8011940:	001a      	movs	r2, r3
 8011942:	183b      	adds	r3, r7, r0
 8011944:	605a      	str	r2, [r3, #4]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8011946:	1cfb      	adds	r3, r7, #3
 8011948:	781b      	ldrb	r3, [r3, #0]
 801194a:	1cfa      	adds	r2, r7, #3
 801194c:	1c59      	adds	r1, r3, #1
 801194e:	7011      	strb	r1, [r2, #0]
 8011950:	001a      	movs	r2, r3
 8011952:	687b      	ldr	r3, [r7, #4]
 8011954:	189b      	adds	r3, r3, r2
 8011956:	781b      	ldrb	r3, [r3, #0]
 8011958:	021a      	lsls	r2, r3, #8
 801195a:	183b      	adds	r3, r7, r0
 801195c:	685b      	ldr	r3, [r3, #4]
 801195e:	431a      	orrs	r2, r3
 8011960:	183b      	adds	r3, r7, r0
 8011962:	605a      	str	r2, [r3, #4]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8011964:	1cfb      	adds	r3, r7, #3
 8011966:	781b      	ldrb	r3, [r3, #0]
 8011968:	1cfa      	adds	r2, r7, #3
 801196a:	1c59      	adds	r1, r3, #1
 801196c:	7011      	strb	r1, [r2, #0]
 801196e:	001a      	movs	r2, r3
 8011970:	687b      	ldr	r3, [r7, #4]
 8011972:	189b      	adds	r3, r3, r2
 8011974:	781b      	ldrb	r3, [r3, #0]
 8011976:	041a      	lsls	r2, r3, #16
 8011978:	183b      	adds	r3, r7, r0
 801197a:	685b      	ldr	r3, [r3, #4]
 801197c:	431a      	orrs	r2, r3
 801197e:	0001      	movs	r1, r0
 8011980:	187b      	adds	r3, r7, r1
 8011982:	605a      	str	r2, [r3, #4]
                dlChannelReq.Rx1Frequency *= 100;
 8011984:	187b      	adds	r3, r7, r1
 8011986:	685b      	ldr	r3, [r3, #4]
 8011988:	2264      	movs	r2, #100	; 0x64
 801198a:	435a      	muls	r2, r3
 801198c:	187b      	adds	r3, r7, r1
 801198e:	605a      	str	r2, [r3, #4]

                status = RegionDlChannelReq( MacCtx.NvmCtx->Region, &dlChannelReq );
 8011990:	4b0d      	ldr	r3, [pc, #52]	; (80119c8 <ProcessMacCommands+0x76c>)
 8011992:	4a0e      	ldr	r2, [pc, #56]	; (80119cc <ProcessMacCommands+0x770>)
 8011994:	589b      	ldr	r3, [r3, r2]
 8011996:	781b      	ldrb	r3, [r3, #0]
 8011998:	187a      	adds	r2, r7, r1
 801199a:	0011      	movs	r1, r2
 801199c:	0018      	movs	r0, r3
 801199e:	f005 ff26 	bl	80177ee <RegionDlChannelReq>
 80119a2:	0003      	movs	r3, r0
 80119a4:	001a      	movs	r2, r3
 80119a6:	193b      	adds	r3, r7, r4
 80119a8:	701a      	strb	r2, [r3, #0]
                macCmdPayload[0] = status;
 80119aa:	193b      	adds	r3, r7, r4
 80119ac:	781a      	ldrb	r2, [r3, #0]
 80119ae:	2168      	movs	r1, #104	; 0x68
 80119b0:	187b      	adds	r3, r7, r1
 80119b2:	701a      	strb	r2, [r3, #0]
                LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 80119b4:	187b      	adds	r3, r7, r1
 80119b6:	2201      	movs	r2, #1
 80119b8:	0019      	movs	r1, r3
 80119ba:	200a      	movs	r0, #10
 80119bc:	f003 fd34 	bl	8015428 <LoRaMacCommandsAddCmd>
                // Setup indication to inform the application
                SetMlmeScheduleUplinkIndication( );
 80119c0:	f7ff fc3c 	bl	801123c <SetMlmeScheduleUplinkIndication>
                break;
 80119c4:	46c0      	nop			; (mov r8, r8)
 80119c6:	e19a      	b.n	8011cfe <ProcessMacCommands+0xaa2>
 80119c8:	200008ec 	.word	0x200008ec
 80119cc:	00000484 	.word	0x00000484
 80119d0:	0801f170 	.word	0x0801f170
            }
            case SRV_MAC_DEVICE_TIME_ANS:
            {
                SysTime_t gpsEpochTime = { 0 };
 80119d4:	241c      	movs	r4, #28
 80119d6:	193b      	adds	r3, r7, r4
 80119d8:	0018      	movs	r0, r3
 80119da:	2308      	movs	r3, #8
 80119dc:	001a      	movs	r2, r3
 80119de:	2100      	movs	r1, #0
 80119e0:	f00b fdb8 	bl	801d554 <memset>
                SysTime_t sysTime = { 0 };
 80119e4:	2514      	movs	r5, #20
 80119e6:	197b      	adds	r3, r7, r5
 80119e8:	0018      	movs	r0, r3
 80119ea:	2308      	movs	r3, #8
 80119ec:	001a      	movs	r2, r3
 80119ee:	2100      	movs	r1, #0
 80119f0:	f00b fdb0 	bl	801d554 <memset>
                SysTime_t sysTimeCurrent = { 0 };
 80119f4:	260c      	movs	r6, #12
 80119f6:	19bb      	adds	r3, r7, r6
 80119f8:	0018      	movs	r0, r3
 80119fa:	2308      	movs	r3, #8
 80119fc:	001a      	movs	r2, r3
 80119fe:	2100      	movs	r1, #0
 8011a00:	f00b fda8 	bl	801d554 <memset>

                gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 8011a04:	1cfb      	adds	r3, r7, #3
 8011a06:	781b      	ldrb	r3, [r3, #0]
 8011a08:	1cfa      	adds	r2, r7, #3
 8011a0a:	1c59      	adds	r1, r3, #1
 8011a0c:	7011      	strb	r1, [r2, #0]
 8011a0e:	001a      	movs	r2, r3
 8011a10:	687b      	ldr	r3, [r7, #4]
 8011a12:	189b      	adds	r3, r3, r2
 8011a14:	781b      	ldrb	r3, [r3, #0]
 8011a16:	001a      	movs	r2, r3
 8011a18:	193b      	adds	r3, r7, r4
 8011a1a:	601a      	str	r2, [r3, #0]
                gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8011a1c:	1cfb      	adds	r3, r7, #3
 8011a1e:	781b      	ldrb	r3, [r3, #0]
 8011a20:	1cfa      	adds	r2, r7, #3
 8011a22:	1c59      	adds	r1, r3, #1
 8011a24:	7011      	strb	r1, [r2, #0]
 8011a26:	001a      	movs	r2, r3
 8011a28:	687b      	ldr	r3, [r7, #4]
 8011a2a:	189b      	adds	r3, r3, r2
 8011a2c:	781b      	ldrb	r3, [r3, #0]
 8011a2e:	021a      	lsls	r2, r3, #8
 8011a30:	193b      	adds	r3, r7, r4
 8011a32:	681b      	ldr	r3, [r3, #0]
 8011a34:	431a      	orrs	r2, r3
 8011a36:	0020      	movs	r0, r4
 8011a38:	193b      	adds	r3, r7, r4
 8011a3a:	601a      	str	r2, [r3, #0]
                gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8011a3c:	1cfb      	adds	r3, r7, #3
 8011a3e:	781b      	ldrb	r3, [r3, #0]
 8011a40:	1cfa      	adds	r2, r7, #3
 8011a42:	1c59      	adds	r1, r3, #1
 8011a44:	7011      	strb	r1, [r2, #0]
 8011a46:	001a      	movs	r2, r3
 8011a48:	687b      	ldr	r3, [r7, #4]
 8011a4a:	189b      	adds	r3, r3, r2
 8011a4c:	781b      	ldrb	r3, [r3, #0]
 8011a4e:	041a      	lsls	r2, r3, #16
 8011a50:	183b      	adds	r3, r7, r0
 8011a52:	681b      	ldr	r3, [r3, #0]
 8011a54:	431a      	orrs	r2, r3
 8011a56:	183b      	adds	r3, r7, r0
 8011a58:	601a      	str	r2, [r3, #0]
                gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8011a5a:	1cfb      	adds	r3, r7, #3
 8011a5c:	781b      	ldrb	r3, [r3, #0]
 8011a5e:	1cfa      	adds	r2, r7, #3
 8011a60:	1c59      	adds	r1, r3, #1
 8011a62:	7011      	strb	r1, [r2, #0]
 8011a64:	001a      	movs	r2, r3
 8011a66:	687b      	ldr	r3, [r7, #4]
 8011a68:	189b      	adds	r3, r3, r2
 8011a6a:	781b      	ldrb	r3, [r3, #0]
 8011a6c:	061a      	lsls	r2, r3, #24
 8011a6e:	183b      	adds	r3, r7, r0
 8011a70:	681b      	ldr	r3, [r3, #0]
 8011a72:	431a      	orrs	r2, r3
 8011a74:	183b      	adds	r3, r7, r0
 8011a76:	601a      	str	r2, [r3, #0]
                gpsEpochTime.SubSeconds = payload[macIndex++];
 8011a78:	1cfb      	adds	r3, r7, #3
 8011a7a:	781b      	ldrb	r3, [r3, #0]
 8011a7c:	1cfa      	adds	r2, r7, #3
 8011a7e:	1c59      	adds	r1, r3, #1
 8011a80:	7011      	strb	r1, [r2, #0]
 8011a82:	001a      	movs	r2, r3
 8011a84:	687b      	ldr	r3, [r7, #4]
 8011a86:	189b      	adds	r3, r3, r2
 8011a88:	781b      	ldrb	r3, [r3, #0]
 8011a8a:	b21a      	sxth	r2, r3
 8011a8c:	183b      	adds	r3, r7, r0
 8011a8e:	809a      	strh	r2, [r3, #4]

                // Convert the fractional second received in ms
                // round( pow( 0.5, 8.0 ) * 1000 ) = 3.90625
                gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8011a90:	0001      	movs	r1, r0
 8011a92:	183b      	adds	r3, r7, r0
 8011a94:	2204      	movs	r2, #4
 8011a96:	5e9b      	ldrsh	r3, [r3, r2]
 8011a98:	001a      	movs	r2, r3
 8011a9a:	0013      	movs	r3, r2
 8011a9c:	015b      	lsls	r3, r3, #5
 8011a9e:	1a9b      	subs	r3, r3, r2
 8011aa0:	009b      	lsls	r3, r3, #2
 8011aa2:	189b      	adds	r3, r3, r2
 8011aa4:	00db      	lsls	r3, r3, #3
 8011aa6:	121b      	asrs	r3, r3, #8
 8011aa8:	b21a      	sxth	r2, r3
 8011aaa:	187b      	adds	r3, r7, r1
 8011aac:	809a      	strh	r2, [r3, #4]

                // Copy received GPS Epoch time into system time
                sysTime = gpsEpochTime;
 8011aae:	197b      	adds	r3, r7, r5
 8011ab0:	187a      	adds	r2, r7, r1
 8011ab2:	ca03      	ldmia	r2!, {r0, r1}
 8011ab4:	c303      	stmia	r3!, {r0, r1}
                // Add Unix to Gps epcoh offset. The system time is based on Unix time.
                sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;
 8011ab6:	197b      	adds	r3, r7, r5
 8011ab8:	681b      	ldr	r3, [r3, #0]
 8011aba:	4a97      	ldr	r2, [pc, #604]	; (8011d18 <ProcessMacCommands+0xabc>)
 8011abc:	189a      	adds	r2, r3, r2
 8011abe:	002c      	movs	r4, r5
 8011ac0:	197b      	adds	r3, r7, r5
 8011ac2:	601a      	str	r2, [r3, #0]

                // Compensate time difference between Tx Done time and now
                sysTimeCurrent = SysTimeGet( );
 8011ac4:	19bb      	adds	r3, r7, r6
 8011ac6:	0018      	movs	r0, r3
 8011ac8:	f009 f96b 	bl	801ada2 <SysTimeGet>
                sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );
 8011acc:	236c      	movs	r3, #108	; 0x6c
 8011ace:	18fd      	adds	r5, r7, r3
 8011ad0:	4892      	ldr	r0, [pc, #584]	; (8011d1c <ProcessMacCommands+0xac0>)
 8011ad2:	23ce      	movs	r3, #206	; 0xce
 8011ad4:	0099      	lsls	r1, r3, #2
 8011ad6:	0026      	movs	r6, r4
 8011ad8:	193a      	adds	r2, r7, r4
 8011ada:	2404      	movs	r4, #4
 8011adc:	1843      	adds	r3, r0, r1
 8011ade:	191c      	adds	r4, r3, r4
 8011ae0:	466b      	mov	r3, sp
 8011ae2:	6824      	ldr	r4, [r4, #0]
 8011ae4:	601c      	str	r4, [r3, #0]
 8011ae6:	5843      	ldr	r3, [r0, r1]
 8011ae8:	6811      	ldr	r1, [r2, #0]
 8011aea:	6852      	ldr	r2, [r2, #4]
 8011aec:	0028      	movs	r0, r5
 8011aee:	f009 f8d5 	bl	801ac9c <SysTimeSub>
 8011af2:	0035      	movs	r5, r6
 8011af4:	197c      	adds	r4, r7, r5
 8011af6:	236c      	movs	r3, #108	; 0x6c
 8011af8:	18fb      	adds	r3, r7, r3
 8011afa:	260c      	movs	r6, #12
 8011afc:	19ba      	adds	r2, r7, r6
 8011afe:	4669      	mov	r1, sp
 8011b00:	6858      	ldr	r0, [r3, #4]
 8011b02:	6008      	str	r0, [r1, #0]
 8011b04:	681b      	ldr	r3, [r3, #0]
 8011b06:	6811      	ldr	r1, [r2, #0]
 8011b08:	6852      	ldr	r2, [r2, #4]
 8011b0a:	0020      	movs	r0, r4
 8011b0c:	f009 f870 	bl	801abf0 <SysTimeAdd>

                // Apply the new system time.
                SysTimeSet( sysTime );
 8011b10:	197b      	adds	r3, r7, r5
 8011b12:	6818      	ldr	r0, [r3, #0]
 8011b14:	6859      	ldr	r1, [r3, #4]
 8011b16:	f009 f914 	bl	801ad42 <SysTimeSet>
                LoRaMacClassBDeviceTimeAns( );
 8011b1a:	f003 faf7 	bl	801510c <LoRaMacClassBDeviceTimeAns>
                MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 8011b1e:	4a7f      	ldr	r2, [pc, #508]	; (8011d1c <ProcessMacCommands+0xac0>)
 8011b20:	2387      	movs	r3, #135	; 0x87
 8011b22:	00db      	lsls	r3, r3, #3
 8011b24:	2101      	movs	r1, #1
 8011b26:	54d1      	strb	r1, [r2, r3]
                break;
 8011b28:	46c0      	nop			; (mov r8, r8)
 8011b2a:	e0e8      	b.n	8011cfe <ProcessMacCommands+0xaa2>
            }
            case SRV_MAC_PING_SLOT_INFO_ANS:
            {
                // According to the specification, it is not allowed to process this answer in
                // a ping or multicast slot
                if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 8011b2c:	4a7b      	ldr	r2, [pc, #492]	; (8011d1c <ProcessMacCommands+0xac0>)
 8011b2e:	2390      	movs	r3, #144	; 0x90
 8011b30:	00db      	lsls	r3, r3, #3
 8011b32:	5cd3      	ldrb	r3, [r2, r3]
 8011b34:	2b04      	cmp	r3, #4
 8011b36:	d100      	bne.n	8011b3a <ProcessMacCommands+0x8de>
 8011b38:	e0e1      	b.n	8011cfe <ProcessMacCommands+0xaa2>
 8011b3a:	4a78      	ldr	r2, [pc, #480]	; (8011d1c <ProcessMacCommands+0xac0>)
 8011b3c:	2390      	movs	r3, #144	; 0x90
 8011b3e:	00db      	lsls	r3, r3, #3
 8011b40:	5cd3      	ldrb	r3, [r2, r3]
 8011b42:	2b05      	cmp	r3, #5
 8011b44:	d100      	bne.n	8011b48 <ProcessMacCommands+0x8ec>
 8011b46:	e0da      	b.n	8011cfe <ProcessMacCommands+0xaa2>
                {
                    LoRaMacClassBPingSlotInfoAns( );
 8011b48:	f003 fac1 	bl	80150ce <LoRaMacClassBPingSlotInfoAns>
                }
                break;
 8011b4c:	e0d7      	b.n	8011cfe <ProcessMacCommands+0xaa2>
            }
            case SRV_MAC_PING_SLOT_CHANNEL_REQ:
            {
                uint8_t status = 0x03;
 8011b4e:	207c      	movs	r0, #124	; 0x7c
 8011b50:	183b      	adds	r3, r7, r0
 8011b52:	2203      	movs	r2, #3
 8011b54:	701a      	strb	r2, [r3, #0]
                uint32_t frequency = 0;
 8011b56:	2300      	movs	r3, #0
 8011b58:	67bb      	str	r3, [r7, #120]	; 0x78
                uint8_t datarate;

                frequency = ( uint32_t )payload[macIndex++];
 8011b5a:	1cfb      	adds	r3, r7, #3
 8011b5c:	781b      	ldrb	r3, [r3, #0]
 8011b5e:	1cfa      	adds	r2, r7, #3
 8011b60:	1c59      	adds	r1, r3, #1
 8011b62:	7011      	strb	r1, [r2, #0]
 8011b64:	001a      	movs	r2, r3
 8011b66:	687b      	ldr	r3, [r7, #4]
 8011b68:	189b      	adds	r3, r3, r2
 8011b6a:	781b      	ldrb	r3, [r3, #0]
 8011b6c:	67bb      	str	r3, [r7, #120]	; 0x78
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8011b6e:	1cfb      	adds	r3, r7, #3
 8011b70:	781b      	ldrb	r3, [r3, #0]
 8011b72:	1cfa      	adds	r2, r7, #3
 8011b74:	1c59      	adds	r1, r3, #1
 8011b76:	7011      	strb	r1, [r2, #0]
 8011b78:	001a      	movs	r2, r3
 8011b7a:	687b      	ldr	r3, [r7, #4]
 8011b7c:	189b      	adds	r3, r3, r2
 8011b7e:	781b      	ldrb	r3, [r3, #0]
 8011b80:	021b      	lsls	r3, r3, #8
 8011b82:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8011b84:	4313      	orrs	r3, r2
 8011b86:	67bb      	str	r3, [r7, #120]	; 0x78
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8011b88:	1cfb      	adds	r3, r7, #3
 8011b8a:	781b      	ldrb	r3, [r3, #0]
 8011b8c:	1cfa      	adds	r2, r7, #3
 8011b8e:	1c59      	adds	r1, r3, #1
 8011b90:	7011      	strb	r1, [r2, #0]
 8011b92:	001a      	movs	r2, r3
 8011b94:	687b      	ldr	r3, [r7, #4]
 8011b96:	189b      	adds	r3, r3, r2
 8011b98:	781b      	ldrb	r3, [r3, #0]
 8011b9a:	041b      	lsls	r3, r3, #16
 8011b9c:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8011b9e:	4313      	orrs	r3, r2
 8011ba0:	67bb      	str	r3, [r7, #120]	; 0x78
                frequency *= 100;
 8011ba2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8011ba4:	2264      	movs	r2, #100	; 0x64
 8011ba6:	4353      	muls	r3, r2
 8011ba8:	67bb      	str	r3, [r7, #120]	; 0x78
                datarate = payload[macIndex++] & 0x0F;
 8011baa:	1cfb      	adds	r3, r7, #3
 8011bac:	781b      	ldrb	r3, [r3, #0]
 8011bae:	1cfa      	adds	r2, r7, #3
 8011bb0:	1c59      	adds	r1, r3, #1
 8011bb2:	7011      	strb	r1, [r2, #0]
 8011bb4:	001a      	movs	r2, r3
 8011bb6:	687b      	ldr	r3, [r7, #4]
 8011bb8:	189b      	adds	r3, r3, r2
 8011bba:	781a      	ldrb	r2, [r3, #0]
 8011bbc:	2677      	movs	r6, #119	; 0x77
 8011bbe:	19bb      	adds	r3, r7, r6
 8011bc0:	210f      	movs	r1, #15
 8011bc2:	400a      	ands	r2, r1
 8011bc4:	701a      	strb	r2, [r3, #0]

                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );
 8011bc6:	0005      	movs	r5, r0
 8011bc8:	183c      	adds	r4, r7, r0
 8011bca:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8011bcc:	19bb      	adds	r3, r7, r6
 8011bce:	781b      	ldrb	r3, [r3, #0]
 8011bd0:	0011      	movs	r1, r2
 8011bd2:	0018      	movs	r0, r3
 8011bd4:	f003 fa80 	bl	80150d8 <LoRaMacClassBPingSlotChannelReq>
 8011bd8:	0003      	movs	r3, r0
 8011bda:	7023      	strb	r3, [r4, #0]
                macCmdPayload[0] = status;
 8011bdc:	2168      	movs	r1, #104	; 0x68
 8011bde:	187b      	adds	r3, r7, r1
 8011be0:	197a      	adds	r2, r7, r5
 8011be2:	7812      	ldrb	r2, [r2, #0]
 8011be4:	701a      	strb	r2, [r3, #0]
                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_FREQ_ANS, macCmdPayload, 1 );
 8011be6:	187b      	adds	r3, r7, r1
 8011be8:	2201      	movs	r2, #1
 8011bea:	0019      	movs	r1, r3
 8011bec:	2011      	movs	r0, #17
 8011bee:	f003 fc1b 	bl	8015428 <LoRaMacCommandsAddCmd>
                break;
 8011bf2:	e084      	b.n	8011cfe <ProcessMacCommands+0xaa2>
            }
            case SRV_MAC_BEACON_TIMING_ANS:
            {
                uint16_t beaconTimingDelay = 0;
 8011bf4:	207e      	movs	r0, #126	; 0x7e
 8011bf6:	183b      	adds	r3, r7, r0
 8011bf8:	2200      	movs	r2, #0
 8011bfa:	801a      	strh	r2, [r3, #0]
                uint8_t beaconTimingChannel = 0;
 8011bfc:	247d      	movs	r4, #125	; 0x7d
 8011bfe:	193b      	adds	r3, r7, r4
 8011c00:	2200      	movs	r2, #0
 8011c02:	701a      	strb	r2, [r3, #0]

                beaconTimingDelay = ( uint16_t )payload[macIndex++];
 8011c04:	1cfb      	adds	r3, r7, #3
 8011c06:	781b      	ldrb	r3, [r3, #0]
 8011c08:	1cfa      	adds	r2, r7, #3
 8011c0a:	1c59      	adds	r1, r3, #1
 8011c0c:	7011      	strb	r1, [r2, #0]
 8011c0e:	001a      	movs	r2, r3
 8011c10:	687b      	ldr	r3, [r7, #4]
 8011c12:	189b      	adds	r3, r3, r2
 8011c14:	781a      	ldrb	r2, [r3, #0]
 8011c16:	183b      	adds	r3, r7, r0
 8011c18:	801a      	strh	r2, [r3, #0]
                beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8011c1a:	1cfb      	adds	r3, r7, #3
 8011c1c:	781b      	ldrb	r3, [r3, #0]
 8011c1e:	1cfa      	adds	r2, r7, #3
 8011c20:	1c59      	adds	r1, r3, #1
 8011c22:	7011      	strb	r1, [r2, #0]
 8011c24:	001a      	movs	r2, r3
 8011c26:	687b      	ldr	r3, [r7, #4]
 8011c28:	189b      	adds	r3, r3, r2
 8011c2a:	781b      	ldrb	r3, [r3, #0]
 8011c2c:	021b      	lsls	r3, r3, #8
 8011c2e:	b21a      	sxth	r2, r3
 8011c30:	183b      	adds	r3, r7, r0
 8011c32:	2100      	movs	r1, #0
 8011c34:	5e5b      	ldrsh	r3, [r3, r1]
 8011c36:	4313      	orrs	r3, r2
 8011c38:	b21a      	sxth	r2, r3
 8011c3a:	183b      	adds	r3, r7, r0
 8011c3c:	801a      	strh	r2, [r3, #0]
                beaconTimingChannel = payload[macIndex++];
 8011c3e:	1cfb      	adds	r3, r7, #3
 8011c40:	781b      	ldrb	r3, [r3, #0]
 8011c42:	1cfa      	adds	r2, r7, #3
 8011c44:	1c59      	adds	r1, r3, #1
 8011c46:	7011      	strb	r1, [r2, #0]
 8011c48:	001a      	movs	r2, r3
 8011c4a:	687b      	ldr	r3, [r7, #4]
 8011c4c:	189a      	adds	r2, r3, r2
 8011c4e:	193b      	adds	r3, r7, r4
 8011c50:	7812      	ldrb	r2, [r2, #0]
 8011c52:	701a      	strb	r2, [r3, #0]

                LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8011c54:	4b32      	ldr	r3, [pc, #200]	; (8011d20 <ProcessMacCommands+0xac4>)
 8011c56:	681a      	ldr	r2, [r3, #0]
 8011c58:	193b      	adds	r3, r7, r4
 8011c5a:	7819      	ldrb	r1, [r3, #0]
 8011c5c:	183b      	adds	r3, r7, r0
 8011c5e:	881b      	ldrh	r3, [r3, #0]
 8011c60:	0018      	movs	r0, r3
 8011c62:	f003 fa45 	bl	80150f0 <LoRaMacClassBBeaconTimingAns>
                break;
 8011c66:	e04a      	b.n	8011cfe <ProcessMacCommands+0xaa2>
            }
            case SRV_MAC_BEACON_FREQ_REQ:
                {
                    uint32_t frequency = 0;
 8011c68:	2300      	movs	r3, #0
 8011c6a:	2080      	movs	r0, #128	; 0x80
 8011c6c:	183a      	adds	r2, r7, r0
 8011c6e:	6013      	str	r3, [r2, #0]

                    frequency = ( uint32_t )payload[macIndex++];
 8011c70:	1cfb      	adds	r3, r7, #3
 8011c72:	781b      	ldrb	r3, [r3, #0]
 8011c74:	1cfa      	adds	r2, r7, #3
 8011c76:	1c59      	adds	r1, r3, #1
 8011c78:	7011      	strb	r1, [r2, #0]
 8011c7a:	001a      	movs	r2, r3
 8011c7c:	687b      	ldr	r3, [r7, #4]
 8011c7e:	189b      	adds	r3, r3, r2
 8011c80:	781b      	ldrb	r3, [r3, #0]
 8011c82:	183a      	adds	r2, r7, r0
 8011c84:	6013      	str	r3, [r2, #0]
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 8011c86:	1cfb      	adds	r3, r7, #3
 8011c88:	781b      	ldrb	r3, [r3, #0]
 8011c8a:	1cfa      	adds	r2, r7, #3
 8011c8c:	1c59      	adds	r1, r3, #1
 8011c8e:	7011      	strb	r1, [r2, #0]
 8011c90:	001a      	movs	r2, r3
 8011c92:	687b      	ldr	r3, [r7, #4]
 8011c94:	189b      	adds	r3, r3, r2
 8011c96:	781b      	ldrb	r3, [r3, #0]
 8011c98:	021b      	lsls	r3, r3, #8
 8011c9a:	183a      	adds	r2, r7, r0
 8011c9c:	6812      	ldr	r2, [r2, #0]
 8011c9e:	4313      	orrs	r3, r2
 8011ca0:	183a      	adds	r2, r7, r0
 8011ca2:	6013      	str	r3, [r2, #0]
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8011ca4:	1cfb      	adds	r3, r7, #3
 8011ca6:	781b      	ldrb	r3, [r3, #0]
 8011ca8:	1cfa      	adds	r2, r7, #3
 8011caa:	1c59      	adds	r1, r3, #1
 8011cac:	7011      	strb	r1, [r2, #0]
 8011cae:	001a      	movs	r2, r3
 8011cb0:	687b      	ldr	r3, [r7, #4]
 8011cb2:	189b      	adds	r3, r3, r2
 8011cb4:	781b      	ldrb	r3, [r3, #0]
 8011cb6:	041b      	lsls	r3, r3, #16
 8011cb8:	183a      	adds	r2, r7, r0
 8011cba:	6812      	ldr	r2, [r2, #0]
 8011cbc:	4313      	orrs	r3, r2
 8011cbe:	183a      	adds	r2, r7, r0
 8011cc0:	6013      	str	r3, [r2, #0]
                    frequency *= 100;
 8011cc2:	183b      	adds	r3, r7, r0
 8011cc4:	681b      	ldr	r3, [r3, #0]
 8011cc6:	2264      	movs	r2, #100	; 0x64
 8011cc8:	4353      	muls	r3, r2
 8011cca:	183a      	adds	r2, r7, r0
 8011ccc:	6013      	str	r3, [r2, #0]

                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 8011cce:	183b      	adds	r3, r7, r0
 8011cd0:	681b      	ldr	r3, [r3, #0]
 8011cd2:	0018      	movs	r0, r3
 8011cd4:	f003 fa1f 	bl	8015116 <LoRaMacClassBBeaconFreqReq>
 8011cd8:	1e03      	subs	r3, r0, #0
 8011cda:	d004      	beq.n	8011ce6 <ProcessMacCommands+0xa8a>
                    {
                        macCmdPayload[0] = 1;
 8011cdc:	2368      	movs	r3, #104	; 0x68
 8011cde:	18fb      	adds	r3, r7, r3
 8011ce0:	2201      	movs	r2, #1
 8011ce2:	701a      	strb	r2, [r3, #0]
 8011ce4:	e003      	b.n	8011cee <ProcessMacCommands+0xa92>
                    }
                    else
                    {
                        macCmdPayload[0] = 0;
 8011ce6:	2368      	movs	r3, #104	; 0x68
 8011ce8:	18fb      	adds	r3, r7, r3
 8011cea:	2200      	movs	r2, #0
 8011cec:	701a      	strb	r2, [r3, #0]
                    }
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 8011cee:	2368      	movs	r3, #104	; 0x68
 8011cf0:	18fb      	adds	r3, r7, r3
 8011cf2:	2201      	movs	r2, #1
 8011cf4:	0019      	movs	r1, r3
 8011cf6:	2013      	movs	r0, #19
 8011cf8:	f003 fb96 	bl	8015428 <LoRaMacCommandsAddCmd>
                }
                break;
 8011cfc:	46c0      	nop			; (mov r8, r8)
    while( macIndex < commandsSize )
 8011cfe:	1cfa      	adds	r2, r7, #3
 8011d00:	1cbb      	adds	r3, r7, #2
 8011d02:	7812      	ldrb	r2, [r2, #0]
 8011d04:	781b      	ldrb	r3, [r3, #0]
 8011d06:	429a      	cmp	r2, r3
 8011d08:	d201      	bcs.n	8011d0e <ProcessMacCommands+0xab2>
 8011d0a:	f7ff fac5 	bl	8011298 <ProcessMacCommands+0x3c>
 8011d0e:	e000      	b.n	8011d12 <ProcessMacCommands+0xab6>
            default:
                // Unknown command. ABORT MAC commands processing
                return;
 8011d10:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 8011d12:	46bd      	mov	sp, r7
 8011d14:	b023      	add	sp, #140	; 0x8c
 8011d16:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011d18:	12d53d80 	.word	0x12d53d80
 8011d1c:	200008ec 	.word	0x200008ec
 8011d20:	200017e4 	.word	0x200017e4

08011d24 <Send>:

LoRaMacStatus_t Send( LoRaMacHeader_t* macHdr, uint8_t fPort, void* fBuffer, uint16_t fBufferSize )
{
 8011d24:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011d26:	b08f      	sub	sp, #60	; 0x3c
 8011d28:	af02      	add	r7, sp, #8
 8011d2a:	60f8      	str	r0, [r7, #12]
 8011d2c:	0008      	movs	r0, r1
 8011d2e:	607a      	str	r2, [r7, #4]
 8011d30:	0019      	movs	r1, r3
 8011d32:	230b      	movs	r3, #11
 8011d34:	18fb      	adds	r3, r7, r3
 8011d36:	1c02      	adds	r2, r0, #0
 8011d38:	701a      	strb	r2, [r3, #0]
 8011d3a:	2308      	movs	r3, #8
 8011d3c:	18fb      	adds	r3, r7, r3
 8011d3e:	1c0a      	adds	r2, r1, #0
 8011d40:	801a      	strh	r2, [r3, #0]
    LoRaMacFrameCtrl_t fCtrl;
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 8011d42:	232f      	movs	r3, #47	; 0x2f
 8011d44:	18fb      	adds	r3, r7, r3
 8011d46:	2203      	movs	r2, #3
 8011d48:	701a      	strb	r2, [r3, #0]
    int8_t datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;
 8011d4a:	4b8e      	ldr	r3, [pc, #568]	; (8011f84 <Send+0x260>)
 8011d4c:	4a8e      	ldr	r2, [pc, #568]	; (8011f88 <Send+0x264>)
 8011d4e:	589a      	ldr	r2, [r3, r2]
 8011d50:	232e      	movs	r3, #46	; 0x2e
 8011d52:	18fb      	adds	r3, r7, r3
 8011d54:	21f9      	movs	r1, #249	; 0xf9
 8011d56:	5c52      	ldrb	r2, [r2, r1]
 8011d58:	701a      	strb	r2, [r3, #0]
    int8_t txPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;
 8011d5a:	4b8a      	ldr	r3, [pc, #552]	; (8011f84 <Send+0x260>)
 8011d5c:	4a8a      	ldr	r2, [pc, #552]	; (8011f88 <Send+0x264>)
 8011d5e:	589a      	ldr	r2, [r3, r2]
 8011d60:	232d      	movs	r3, #45	; 0x2d
 8011d62:	18fb      	adds	r3, r7, r3
 8011d64:	21f8      	movs	r1, #248	; 0xf8
 8011d66:	5c52      	ldrb	r2, [r2, r1]
 8011d68:	701a      	strb	r2, [r3, #0]
    uint32_t adrAckCounter = MacCtx.NvmCtx->AdrAckCounter;
 8011d6a:	4b86      	ldr	r3, [pc, #536]	; (8011f84 <Send+0x260>)
 8011d6c:	4a86      	ldr	r2, [pc, #536]	; (8011f88 <Send+0x264>)
 8011d6e:	589b      	ldr	r3, [r3, r2]
 8011d70:	22f4      	movs	r2, #244	; 0xf4
 8011d72:	589b      	ldr	r3, [r3, r2]
 8011d74:	62bb      	str	r3, [r7, #40]	; 0x28
    CalcNextAdrParams_t adrNext;

    // Check if we are joined
    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )
 8011d76:	4b83      	ldr	r3, [pc, #524]	; (8011f84 <Send+0x260>)
 8011d78:	4a83      	ldr	r2, [pc, #524]	; (8011f88 <Send+0x264>)
 8011d7a:	589a      	ldr	r2, [r3, r2]
 8011d7c:	23ea      	movs	r3, #234	; 0xea
 8011d7e:	005b      	lsls	r3, r3, #1
 8011d80:	5cd3      	ldrb	r3, [r2, r3]
 8011d82:	2b00      	cmp	r3, #0
 8011d84:	d101      	bne.n	8011d8a <Send+0x66>
    {
        return LORAMAC_STATUS_NO_NETWORK_JOINED;
 8011d86:	2307      	movs	r3, #7
 8011d88:	e0f7      	b.n	8011f7a <Send+0x256>
    }
    if( MacCtx.NvmCtx->MaxDCycle == 0 )
 8011d8a:	4b7e      	ldr	r3, [pc, #504]	; (8011f84 <Send+0x260>)
 8011d8c:	4a7e      	ldr	r2, [pc, #504]	; (8011f88 <Send+0x264>)
 8011d8e:	589a      	ldr	r2, [r3, r2]
 8011d90:	239e      	movs	r3, #158	; 0x9e
 8011d92:	005b      	lsls	r3, r3, #1
 8011d94:	5cd3      	ldrb	r3, [r2, r3]
 8011d96:	2b00      	cmp	r3, #0
 8011d98:	d106      	bne.n	8011da8 <Send+0x84>
    {
        MacCtx.NvmCtx->AggregatedTimeOff = 0;
 8011d9a:	4b7a      	ldr	r3, [pc, #488]	; (8011f84 <Send+0x260>)
 8011d9c:	4a7a      	ldr	r2, [pc, #488]	; (8011f88 <Send+0x264>)
 8011d9e:	589a      	ldr	r2, [r3, r2]
 8011da0:	23e4      	movs	r3, #228	; 0xe4
 8011da2:	005b      	lsls	r3, r3, #1
 8011da4:	2100      	movs	r1, #0
 8011da6:	50d1      	str	r1, [r2, r3]
    }

    fCtrl.Value = 0;
 8011da8:	242c      	movs	r4, #44	; 0x2c
 8011daa:	193b      	adds	r3, r7, r4
 8011dac:	2200      	movs	r2, #0
 8011dae:	701a      	strb	r2, [r3, #0]
    fCtrl.Bits.FOptsLen      = 0;
 8011db0:	193b      	adds	r3, r7, r4
 8011db2:	781a      	ldrb	r2, [r3, #0]
 8011db4:	210f      	movs	r1, #15
 8011db6:	438a      	bics	r2, r1
 8011db8:	701a      	strb	r2, [r3, #0]
    fCtrl.Bits.Adr           = MacCtx.NvmCtx->AdrCtrlOn;
 8011dba:	4b72      	ldr	r3, [pc, #456]	; (8011f84 <Send+0x260>)
 8011dbc:	4a72      	ldr	r2, [pc, #456]	; (8011f88 <Send+0x264>)
 8011dbe:	589b      	ldr	r3, [r3, r2]
 8011dc0:	22f2      	movs	r2, #242	; 0xf2
 8011dc2:	5c9a      	ldrb	r2, [r3, r2]
 8011dc4:	193b      	adds	r3, r7, r4
 8011dc6:	01d0      	lsls	r0, r2, #7
 8011dc8:	781a      	ldrb	r2, [r3, #0]
 8011dca:	217f      	movs	r1, #127	; 0x7f
 8011dcc:	400a      	ands	r2, r1
 8011dce:	1c11      	adds	r1, r2, #0
 8011dd0:	1c02      	adds	r2, r0, #0
 8011dd2:	430a      	orrs	r2, r1
 8011dd4:	701a      	strb	r2, [r3, #0]

    // Check class b
    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )
 8011dd6:	4b6b      	ldr	r3, [pc, #428]	; (8011f84 <Send+0x260>)
 8011dd8:	4a6b      	ldr	r2, [pc, #428]	; (8011f88 <Send+0x264>)
 8011dda:	589b      	ldr	r3, [r3, r2]
 8011ddc:	22f0      	movs	r2, #240	; 0xf0
 8011dde:	5c9b      	ldrb	r3, [r3, r2]
 8011de0:	2b01      	cmp	r3, #1
 8011de2:	d105      	bne.n	8011df0 <Send+0xcc>
    {
        fCtrl.Bits.FPending      = 1;
 8011de4:	193b      	adds	r3, r7, r4
 8011de6:	781a      	ldrb	r2, [r3, #0]
 8011de8:	2110      	movs	r1, #16
 8011dea:	430a      	orrs	r2, r1
 8011dec:	701a      	strb	r2, [r3, #0]
 8011dee:	e005      	b.n	8011dfc <Send+0xd8>
    }
    else
    {
        fCtrl.Bits.FPending      = 0;
 8011df0:	232c      	movs	r3, #44	; 0x2c
 8011df2:	18fb      	adds	r3, r7, r3
 8011df4:	781a      	ldrb	r2, [r3, #0]
 8011df6:	2110      	movs	r1, #16
 8011df8:	438a      	bics	r2, r1
 8011dfa:	701a      	strb	r2, [r3, #0]
    }

    // Check server ack
    if( MacCtx.NvmCtx->SrvAckRequested == true )
 8011dfc:	4b61      	ldr	r3, [pc, #388]	; (8011f84 <Send+0x260>)
 8011dfe:	4a62      	ldr	r2, [pc, #392]	; (8011f88 <Send+0x264>)
 8011e00:	589a      	ldr	r2, [r3, r2]
 8011e02:	23e0      	movs	r3, #224	; 0xe0
 8011e04:	005b      	lsls	r3, r3, #1
 8011e06:	5cd3      	ldrb	r3, [r2, r3]
 8011e08:	2b00      	cmp	r3, #0
 8011e0a:	d005      	beq.n	8011e18 <Send+0xf4>
    {
        fCtrl.Bits.Ack = 1;
 8011e0c:	232c      	movs	r3, #44	; 0x2c
 8011e0e:	18fb      	adds	r3, r7, r3
 8011e10:	781a      	ldrb	r2, [r3, #0]
 8011e12:	2120      	movs	r1, #32
 8011e14:	430a      	orrs	r2, r1
 8011e16:	701a      	strb	r2, [r3, #0]
    }

    // ADR next request
    adrNext.Version = MacCtx.NvmCtx->Version;
 8011e18:	4b5a      	ldr	r3, [pc, #360]	; (8011f84 <Send+0x260>)
 8011e1a:	4a5b      	ldr	r2, [pc, #364]	; (8011f88 <Send+0x264>)
 8011e1c:	5899      	ldr	r1, [r3, r2]
 8011e1e:	2014      	movs	r0, #20
 8011e20:	183b      	adds	r3, r7, r0
 8011e22:	22e8      	movs	r2, #232	; 0xe8
 8011e24:	0052      	lsls	r2, r2, #1
 8011e26:	588a      	ldr	r2, [r1, r2]
 8011e28:	601a      	str	r2, [r3, #0]
    adrNext.UpdateChanMask = true;
 8011e2a:	0001      	movs	r1, r0
 8011e2c:	187b      	adds	r3, r7, r1
 8011e2e:	2201      	movs	r2, #1
 8011e30:	711a      	strb	r2, [r3, #4]
    adrNext.AdrEnabled = fCtrl.Bits.Adr;
 8011e32:	242c      	movs	r4, #44	; 0x2c
 8011e34:	193b      	adds	r3, r7, r4
 8011e36:	781b      	ldrb	r3, [r3, #0]
 8011e38:	061b      	lsls	r3, r3, #24
 8011e3a:	0fdb      	lsrs	r3, r3, #31
 8011e3c:	b2db      	uxtb	r3, r3
 8011e3e:	1e5a      	subs	r2, r3, #1
 8011e40:	4193      	sbcs	r3, r2
 8011e42:	b2da      	uxtb	r2, r3
 8011e44:	187b      	adds	r3, r7, r1
 8011e46:	715a      	strb	r2, [r3, #5]
    adrNext.AdrAckCounter = MacCtx.NvmCtx->AdrAckCounter;
 8011e48:	4b4e      	ldr	r3, [pc, #312]	; (8011f84 <Send+0x260>)
 8011e4a:	4a4f      	ldr	r2, [pc, #316]	; (8011f88 <Send+0x264>)
 8011e4c:	589b      	ldr	r3, [r3, r2]
 8011e4e:	22f4      	movs	r2, #244	; 0xf4
 8011e50:	589a      	ldr	r2, [r3, r2]
 8011e52:	0008      	movs	r0, r1
 8011e54:	183b      	adds	r3, r7, r0
 8011e56:	609a      	str	r2, [r3, #8]
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 8011e58:	4a4a      	ldr	r2, [pc, #296]	; (8011f84 <Send+0x260>)
 8011e5a:	23fd      	movs	r3, #253	; 0xfd
 8011e5c:	009b      	lsls	r3, r3, #2
 8011e5e:	5ad2      	ldrh	r2, [r2, r3]
 8011e60:	183b      	adds	r3, r7, r0
 8011e62:	819a      	strh	r2, [r3, #12]
    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;
 8011e64:	4b47      	ldr	r3, [pc, #284]	; (8011f84 <Send+0x260>)
 8011e66:	4a49      	ldr	r2, [pc, #292]	; (8011f8c <Send+0x268>)
 8011e68:	5a9a      	ldrh	r2, [r3, r2]
 8011e6a:	183b      	adds	r3, r7, r0
 8011e6c:	81da      	strh	r2, [r3, #14]
    adrNext.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;
 8011e6e:	4b45      	ldr	r3, [pc, #276]	; (8011f84 <Send+0x260>)
 8011e70:	4a45      	ldr	r2, [pc, #276]	; (8011f88 <Send+0x264>)
 8011e72:	589b      	ldr	r3, [r3, r2]
 8011e74:	22f9      	movs	r2, #249	; 0xf9
 8011e76:	569a      	ldrsb	r2, [r3, r2]
 8011e78:	183b      	adds	r3, r7, r0
 8011e7a:	741a      	strb	r2, [r3, #16]
    adrNext.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;
 8011e7c:	4b41      	ldr	r3, [pc, #260]	; (8011f84 <Send+0x260>)
 8011e7e:	4a42      	ldr	r2, [pc, #264]	; (8011f88 <Send+0x264>)
 8011e80:	589b      	ldr	r3, [r3, r2]
 8011e82:	22f8      	movs	r2, #248	; 0xf8
 8011e84:	569a      	ldrsb	r2, [r3, r2]
 8011e86:	183b      	adds	r3, r7, r0
 8011e88:	745a      	strb	r2, [r3, #17]
    adrNext.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;
 8011e8a:	4b3e      	ldr	r3, [pc, #248]	; (8011f84 <Send+0x260>)
 8011e8c:	4a3e      	ldr	r2, [pc, #248]	; (8011f88 <Send+0x264>)
 8011e8e:	589a      	ldr	r2, [r3, r2]
 8011e90:	2396      	movs	r3, #150	; 0x96
 8011e92:	005b      	lsls	r3, r3, #1
 8011e94:	5cd2      	ldrb	r2, [r2, r3]
 8011e96:	183b      	adds	r3, r7, r0
 8011e98:	749a      	strb	r2, [r3, #18]
    adrNext.Region = MacCtx.NvmCtx->Region;
 8011e9a:	4b3a      	ldr	r3, [pc, #232]	; (8011f84 <Send+0x260>)
 8011e9c:	4a3a      	ldr	r2, [pc, #232]	; (8011f88 <Send+0x264>)
 8011e9e:	589b      	ldr	r3, [r3, r2]
 8011ea0:	781a      	ldrb	r2, [r3, #0]
 8011ea2:	183b      	adds	r3, r7, r0
 8011ea4:	74da      	strb	r2, [r3, #19]

    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &MacCtx.NvmCtx->MacParams.ChannelsDatarate,
 8011ea6:	4b37      	ldr	r3, [pc, #220]	; (8011f84 <Send+0x260>)
 8011ea8:	4a37      	ldr	r2, [pc, #220]	; (8011f88 <Send+0x264>)
 8011eaa:	589b      	ldr	r3, [r3, r2]
 8011eac:	33f9      	adds	r3, #249	; 0xf9
 8011eae:	0019      	movs	r1, r3
                                               &MacCtx.NvmCtx->MacParams.ChannelsTxPower, &adrAckCounter );
 8011eb0:	4b34      	ldr	r3, [pc, #208]	; (8011f84 <Send+0x260>)
 8011eb2:	4a35      	ldr	r2, [pc, #212]	; (8011f88 <Send+0x264>)
 8011eb4:	589b      	ldr	r3, [r3, r2]
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &MacCtx.NvmCtx->MacParams.ChannelsDatarate,
 8011eb6:	33f8      	adds	r3, #248	; 0xf8
 8011eb8:	001a      	movs	r2, r3
 8011eba:	2328      	movs	r3, #40	; 0x28
 8011ebc:	18fb      	adds	r3, r7, r3
 8011ebe:	1838      	adds	r0, r7, r0
 8011ec0:	f003 f83d 	bl	8014f3e <LoRaMacAdrCalcNext>
 8011ec4:	0003      	movs	r3, r0
 8011ec6:	0019      	movs	r1, r3
 8011ec8:	0026      	movs	r6, r4
 8011eca:	193b      	adds	r3, r7, r4
 8011ecc:	2201      	movs	r2, #1
 8011ece:	400a      	ands	r2, r1
 8011ed0:	0190      	lsls	r0, r2, #6
 8011ed2:	781a      	ldrb	r2, [r3, #0]
 8011ed4:	2140      	movs	r1, #64	; 0x40
 8011ed6:	438a      	bics	r2, r1
 8011ed8:	1c11      	adds	r1, r2, #0
 8011eda:	1c02      	adds	r2, r0, #0
 8011edc:	430a      	orrs	r2, r1
 8011ede:	701a      	strb	r2, [r3, #0]

    // Prepare the frame
    status = PrepareFrame( macHdr, &fCtrl, fPort, fBuffer, fBufferSize );
 8011ee0:	222f      	movs	r2, #47	; 0x2f
 8011ee2:	18bc      	adds	r4, r7, r2
 8011ee4:	687d      	ldr	r5, [r7, #4]
 8011ee6:	230b      	movs	r3, #11
 8011ee8:	18fb      	adds	r3, r7, r3
 8011eea:	781a      	ldrb	r2, [r3, #0]
 8011eec:	19b9      	adds	r1, r7, r6
 8011eee:	68f8      	ldr	r0, [r7, #12]
 8011ef0:	2308      	movs	r3, #8
 8011ef2:	18fb      	adds	r3, r7, r3
 8011ef4:	881b      	ldrh	r3, [r3, #0]
 8011ef6:	9300      	str	r3, [sp, #0]
 8011ef8:	002b      	movs	r3, r5
 8011efa:	f000 fc7f 	bl	80127fc <PrepareFrame>
 8011efe:	0003      	movs	r3, r0
 8011f00:	7023      	strb	r3, [r4, #0]

    // Validate status
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 8011f02:	222f      	movs	r2, #47	; 0x2f
 8011f04:	18bb      	adds	r3, r7, r2
 8011f06:	781b      	ldrb	r3, [r3, #0]
 8011f08:	2b00      	cmp	r3, #0
 8011f0a:	d003      	beq.n	8011f14 <Send+0x1f0>
 8011f0c:	18bb      	adds	r3, r7, r2
 8011f0e:	781b      	ldrb	r3, [r3, #0]
 8011f10:	2b0a      	cmp	r3, #10
 8011f12:	d106      	bne.n	8011f22 <Send+0x1fe>
    {
        // Schedule frame, do not allow delayed transmissions
        status = ScheduleTx( false );
 8011f14:	232f      	movs	r3, #47	; 0x2f
 8011f16:	18fc      	adds	r4, r7, r3
 8011f18:	2000      	movs	r0, #0
 8011f1a:	f000 f89d 	bl	8012058 <ScheduleTx>
 8011f1e:	0003      	movs	r3, r0
 8011f20:	7023      	strb	r3, [r4, #0]
    }

    // Post processing
    if( status != LORAMAC_STATUS_OK )
 8011f22:	232f      	movs	r3, #47	; 0x2f
 8011f24:	18fb      	adds	r3, r7, r3
 8011f26:	781b      	ldrb	r3, [r3, #0]
 8011f28:	2b00      	cmp	r3, #0
 8011f2a:	d010      	beq.n	8011f4e <Send+0x22a>
    {
        // Bad case - restore
        // Store local variables
        MacCtx.NvmCtx->MacParams.ChannelsDatarate = datarate;
 8011f2c:	4b15      	ldr	r3, [pc, #84]	; (8011f84 <Send+0x260>)
 8011f2e:	4a16      	ldr	r2, [pc, #88]	; (8011f88 <Send+0x264>)
 8011f30:	589b      	ldr	r3, [r3, r2]
 8011f32:	222e      	movs	r2, #46	; 0x2e
 8011f34:	18ba      	adds	r2, r7, r2
 8011f36:	21f9      	movs	r1, #249	; 0xf9
 8011f38:	7812      	ldrb	r2, [r2, #0]
 8011f3a:	545a      	strb	r2, [r3, r1]
        MacCtx.NvmCtx->MacParams.ChannelsTxPower = txPower;
 8011f3c:	4b11      	ldr	r3, [pc, #68]	; (8011f84 <Send+0x260>)
 8011f3e:	4a12      	ldr	r2, [pc, #72]	; (8011f88 <Send+0x264>)
 8011f40:	589b      	ldr	r3, [r3, r2]
 8011f42:	222d      	movs	r2, #45	; 0x2d
 8011f44:	18ba      	adds	r2, r7, r2
 8011f46:	21f8      	movs	r1, #248	; 0xf8
 8011f48:	7812      	ldrb	r2, [r2, #0]
 8011f4a:	545a      	strb	r2, [r3, r1]
 8011f4c:	e012      	b.n	8011f74 <Send+0x250>
    }
    else
    {
        // Good case
        MacCtx.NvmCtx->SrvAckRequested = false;
 8011f4e:	4b0d      	ldr	r3, [pc, #52]	; (8011f84 <Send+0x260>)
 8011f50:	4a0d      	ldr	r2, [pc, #52]	; (8011f88 <Send+0x264>)
 8011f52:	589a      	ldr	r2, [r3, r2]
 8011f54:	23e0      	movs	r3, #224	; 0xe0
 8011f56:	005b      	lsls	r3, r3, #1
 8011f58:	2100      	movs	r1, #0
 8011f5a:	54d1      	strb	r1, [r2, r3]
        MacCtx.NvmCtx->AdrAckCounter = adrAckCounter;
 8011f5c:	4b09      	ldr	r3, [pc, #36]	; (8011f84 <Send+0x260>)
 8011f5e:	4a0a      	ldr	r2, [pc, #40]	; (8011f88 <Send+0x264>)
 8011f60:	589b      	ldr	r3, [r3, r2]
 8011f62:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011f64:	21f4      	movs	r1, #244	; 0xf4
 8011f66:	505a      	str	r2, [r3, r1]
        // Remove all none sticky MAC commands
        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )
 8011f68:	f003 fae8 	bl	801553c <LoRaMacCommandsRemoveNoneStickyCmds>
 8011f6c:	1e03      	subs	r3, r0, #0
 8011f6e:	d001      	beq.n	8011f74 <Send+0x250>
        {
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8011f70:	2313      	movs	r3, #19
 8011f72:	e002      	b.n	8011f7a <Send+0x256>
        }
    }
    return status;
 8011f74:	232f      	movs	r3, #47	; 0x2f
 8011f76:	18fb      	adds	r3, r7, r3
 8011f78:	781b      	ldrb	r3, [r3, #0]
}
 8011f7a:	0018      	movs	r0, r3
 8011f7c:	46bd      	mov	sp, r7
 8011f7e:	b00d      	add	sp, #52	; 0x34
 8011f80:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011f82:	46c0      	nop			; (mov r8, r8)
 8011f84:	200008ec 	.word	0x200008ec
 8011f88:	00000484 	.word	0x00000484
 8011f8c:	000003f6 	.word	0x000003f6

08011f90 <SendReJoinReq>:

LoRaMacStatus_t SendReJoinReq( JoinReqIdentifier_t joinReqType )
{
 8011f90:	b5b0      	push	{r4, r5, r7, lr}
 8011f92:	b084      	sub	sp, #16
 8011f94:	af00      	add	r7, sp, #0
 8011f96:	0002      	movs	r2, r0
 8011f98:	1dfb      	adds	r3, r7, #7
 8011f9a:	701a      	strb	r2, [r3, #0]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 8011f9c:	230e      	movs	r3, #14
 8011f9e:	18fb      	adds	r3, r7, r3
 8011fa0:	2200      	movs	r2, #0
 8011fa2:	701a      	strb	r2, [r3, #0]
    LoRaMacHeader_t macHdr;
    macHdr.Value = 0;
 8011fa4:	240c      	movs	r4, #12
 8011fa6:	193b      	adds	r3, r7, r4
 8011fa8:	2200      	movs	r2, #0
 8011faa:	701a      	strb	r2, [r3, #0]
    bool allowDelayedTx = true;
 8011fac:	250f      	movs	r5, #15
 8011fae:	197b      	adds	r3, r7, r5
 8011fb0:	2201      	movs	r2, #1
 8011fb2:	701a      	strb	r2, [r3, #0]

    // Setup join/rejoin message
    switch( joinReqType )
 8011fb4:	1dfb      	adds	r3, r7, #7
 8011fb6:	781b      	ldrb	r3, [r3, #0]
 8011fb8:	2bff      	cmp	r3, #255	; 0xff
 8011fba:	d130      	bne.n	801201e <SendReJoinReq+0x8e>
    {
        case JOIN_REQ:
        {
            SwitchClass( CLASS_A );
 8011fbc:	2000      	movs	r0, #0
 8011fbe:	f7fe ff7b 	bl	8010eb8 <SwitchClass>

            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;
 8011fc2:	4a21      	ldr	r2, [pc, #132]	; (8012048 <SendReJoinReq+0xb8>)
 8011fc4:	2382      	movs	r3, #130	; 0x82
 8011fc6:	005b      	lsls	r3, r3, #1
 8011fc8:	2100      	movs	r1, #0
 8011fca:	54d1      	strb	r1, [r2, r3]
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 8011fcc:	4a1e      	ldr	r2, [pc, #120]	; (8012048 <SendReJoinReq+0xb8>)
 8011fce:	2384      	movs	r3, #132	; 0x84
 8011fd0:	005b      	lsls	r3, r3, #1
 8011fd2:	491e      	ldr	r1, [pc, #120]	; (801204c <SendReJoinReq+0xbc>)
 8011fd4:	50d1      	str	r1, [r2, r3]
            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 8011fd6:	4a1c      	ldr	r2, [pc, #112]	; (8012048 <SendReJoinReq+0xb8>)
 8011fd8:	2386      	movs	r3, #134	; 0x86
 8011fda:	005b      	lsls	r3, r3, #1
 8011fdc:	21ff      	movs	r1, #255	; 0xff
 8011fde:	54d1      	strb	r1, [r2, r3]

            macHdr.Bits.MType = FRAME_TYPE_JOIN_REQ;
 8011fe0:	193b      	adds	r3, r7, r4
 8011fe2:	781a      	ldrb	r2, [r3, #0]
 8011fe4:	211f      	movs	r1, #31
 8011fe6:	400a      	ands	r2, r1
 8011fe8:	701a      	strb	r2, [r3, #0]
            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;
 8011fea:	193b      	adds	r3, r7, r4
 8011fec:	7819      	ldrb	r1, [r3, #0]
 8011fee:	4a16      	ldr	r2, [pc, #88]	; (8012048 <SendReJoinReq+0xb8>)
 8011ff0:	230e      	movs	r3, #14
 8011ff2:	33ff      	adds	r3, #255	; 0xff
 8011ff4:	54d1      	strb	r1, [r2, r3]

            memcpy1( MacCtx.TxMsg.Message.JoinReq.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );
 8011ff6:	f7fd fad7 	bl	800f5a8 <SecureElementGetJoinEui>
 8011ffa:	0001      	movs	r1, r0
 8011ffc:	4b14      	ldr	r3, [pc, #80]	; (8012050 <SendReJoinReq+0xc0>)
 8011ffe:	2208      	movs	r2, #8
 8012000:	0018      	movs	r0, r3
 8012002:	f009 faa1 	bl	801b548 <memcpy1>
            memcpy1( MacCtx.TxMsg.Message.JoinReq.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );
 8012006:	f7fd faab 	bl	800f560 <SecureElementGetDevEui>
 801200a:	0001      	movs	r1, r0
 801200c:	4b11      	ldr	r3, [pc, #68]	; (8012054 <SendReJoinReq+0xc4>)
 801200e:	2208      	movs	r2, #8
 8012010:	0018      	movs	r0, r3
 8012012:	f009 fa99 	bl	801b548 <memcpy1>

            allowDelayedTx = false;
 8012016:	197b      	adds	r3, r7, r5
 8012018:	2200      	movs	r2, #0
 801201a:	701a      	strb	r2, [r3, #0]

            break;
 801201c:	e004      	b.n	8012028 <SendReJoinReq+0x98>
        }
        default:
            status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 801201e:	230e      	movs	r3, #14
 8012020:	18fb      	adds	r3, r7, r3
 8012022:	2202      	movs	r2, #2
 8012024:	701a      	strb	r2, [r3, #0]
            break;
 8012026:	46c0      	nop			; (mov r8, r8)
    }

    // Schedule frame
    status = ScheduleTx( allowDelayedTx );
 8012028:	250e      	movs	r5, #14
 801202a:	197c      	adds	r4, r7, r5
 801202c:	230f      	movs	r3, #15
 801202e:	18fb      	adds	r3, r7, r3
 8012030:	781b      	ldrb	r3, [r3, #0]
 8012032:	0018      	movs	r0, r3
 8012034:	f000 f810 	bl	8012058 <ScheduleTx>
 8012038:	0003      	movs	r3, r0
 801203a:	7023      	strb	r3, [r4, #0]
    return status;
 801203c:	197b      	adds	r3, r7, r5
 801203e:	781b      	ldrb	r3, [r3, #0]
}
 8012040:	0018      	movs	r0, r3
 8012042:	46bd      	mov	sp, r7
 8012044:	b004      	add	sp, #16
 8012046:	bdb0      	pop	{r4, r5, r7, pc}
 8012048:	200008ec 	.word	0x200008ec
 801204c:	200008ee 	.word	0x200008ee
 8012050:	200009fa 	.word	0x200009fa
 8012054:	20000a02 	.word	0x20000a02

08012058 <ScheduleTx>:

static LoRaMacStatus_t ScheduleTx( bool allowDelayedTx )
{
 8012058:	b5f0      	push	{r4, r5, r6, r7, lr}
 801205a:	b08b      	sub	sp, #44	; 0x2c
 801205c:	af02      	add	r7, sp, #8
 801205e:	0002      	movs	r2, r0
 8012060:	1dfb      	adds	r3, r7, #7
 8012062:	701a      	strb	r2, [r3, #0]
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 8012064:	231f      	movs	r3, #31
 8012066:	18fb      	adds	r3, r7, r3
 8012068:	2203      	movs	r2, #3
 801206a:	701a      	strb	r2, [r3, #0]
    TimerTime_t dutyCycleTimeOff = 0;
 801206c:	2300      	movs	r3, #0
 801206e:	61bb      	str	r3, [r7, #24]
    NextChanParams_t nextChan;
    size_t macCmdsSize = 0;
 8012070:	2300      	movs	r3, #0
 8012072:	60bb      	str	r3, [r7, #8]

    // Update back-off
    CalculateBackOff( MacCtx.NvmCtx->LastTxChannel );
 8012074:	4ba5      	ldr	r3, [pc, #660]	; (801230c <ScheduleTx+0x2b4>)
 8012076:	4aa6      	ldr	r2, [pc, #664]	; (8012310 <ScheduleTx+0x2b8>)
 8012078:	589a      	ldr	r2, [r3, r2]
 801207a:	239f      	movs	r3, #159	; 0x9f
 801207c:	005b      	lsls	r3, r3, #1
 801207e:	5cd3      	ldrb	r3, [r2, r3]
 8012080:	0018      	movs	r0, r3
 8012082:	f000 f9c1 	bl	8012408 <CalculateBackOff>

    nextChan.AggrTimeOff = MacCtx.NvmCtx->AggregatedTimeOff;
 8012086:	4ba1      	ldr	r3, [pc, #644]	; (801230c <ScheduleTx+0x2b4>)
 8012088:	4aa1      	ldr	r2, [pc, #644]	; (8012310 <ScheduleTx+0x2b8>)
 801208a:	589a      	ldr	r2, [r3, r2]
 801208c:	23e4      	movs	r3, #228	; 0xe4
 801208e:	005b      	lsls	r3, r3, #1
 8012090:	58d2      	ldr	r2, [r2, r3]
 8012092:	210c      	movs	r1, #12
 8012094:	187b      	adds	r3, r7, r1
 8012096:	601a      	str	r2, [r3, #0]
    nextChan.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;
 8012098:	4b9c      	ldr	r3, [pc, #624]	; (801230c <ScheduleTx+0x2b4>)
 801209a:	4a9d      	ldr	r2, [pc, #628]	; (8012310 <ScheduleTx+0x2b8>)
 801209c:	589b      	ldr	r3, [r3, r2]
 801209e:	22f9      	movs	r2, #249	; 0xf9
 80120a0:	569a      	ldrsb	r2, [r3, r2]
 80120a2:	187b      	adds	r3, r7, r1
 80120a4:	721a      	strb	r2, [r3, #8]
    nextChan.DutyCycleEnabled = MacCtx.NvmCtx->DutyCycleOn;
 80120a6:	4b99      	ldr	r3, [pc, #612]	; (801230c <ScheduleTx+0x2b4>)
 80120a8:	4a99      	ldr	r2, [pc, #612]	; (8012310 <ScheduleTx+0x2b8>)
 80120aa:	589a      	ldr	r2, [r3, r2]
 80120ac:	233e      	movs	r3, #62	; 0x3e
 80120ae:	33ff      	adds	r3, #255	; 0xff
 80120b0:	5cd2      	ldrb	r2, [r2, r3]
 80120b2:	187b      	adds	r3, r7, r1
 80120b4:	729a      	strb	r2, [r3, #10]
    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )
 80120b6:	4b95      	ldr	r3, [pc, #596]	; (801230c <ScheduleTx+0x2b4>)
 80120b8:	4a95      	ldr	r2, [pc, #596]	; (8012310 <ScheduleTx+0x2b8>)
 80120ba:	589a      	ldr	r2, [r3, r2]
 80120bc:	23ea      	movs	r3, #234	; 0xea
 80120be:	005b      	lsls	r3, r3, #1
 80120c0:	5cd3      	ldrb	r3, [r2, r3]
 80120c2:	2b00      	cmp	r3, #0
 80120c4:	d103      	bne.n	80120ce <ScheduleTx+0x76>
    {
        nextChan.Joined = false;
 80120c6:	187b      	adds	r3, r7, r1
 80120c8:	2200      	movs	r2, #0
 80120ca:	725a      	strb	r2, [r3, #9]
 80120cc:	e003      	b.n	80120d6 <ScheduleTx+0x7e>
    }
    else
    {
        nextChan.Joined = true;
 80120ce:	230c      	movs	r3, #12
 80120d0:	18fb      	adds	r3, r7, r3
 80120d2:	2201      	movs	r2, #1
 80120d4:	725a      	strb	r2, [r3, #9]
    }
    nextChan.LastAggrTx = MacCtx.NvmCtx->LastTxDoneTime;
 80120d6:	4b8d      	ldr	r3, [pc, #564]	; (801230c <ScheduleTx+0x2b4>)
 80120d8:	4a8d      	ldr	r2, [pc, #564]	; (8012310 <ScheduleTx+0x2b8>)
 80120da:	589a      	ldr	r2, [r3, r2]
 80120dc:	23e2      	movs	r3, #226	; 0xe2
 80120de:	005b      	lsls	r3, r3, #1
 80120e0:	58d2      	ldr	r2, [r2, r3]
 80120e2:	210c      	movs	r1, #12
 80120e4:	187b      	adds	r3, r7, r1
 80120e6:	605a      	str	r2, [r3, #4]

    // Select channel
    status = RegionNextChannel( MacCtx.NvmCtx->Region, &nextChan, &MacCtx.Channel, &dutyCycleTimeOff, &MacCtx.NvmCtx->AggregatedTimeOff );
 80120e8:	4b88      	ldr	r3, [pc, #544]	; (801230c <ScheduleTx+0x2b4>)
 80120ea:	4a89      	ldr	r2, [pc, #548]	; (8012310 <ScheduleTx+0x2b8>)
 80120ec:	589b      	ldr	r3, [r3, r2]
 80120ee:	7818      	ldrb	r0, [r3, #0]
 80120f0:	4b86      	ldr	r3, [pc, #536]	; (801230c <ScheduleTx+0x2b4>)
 80120f2:	4a87      	ldr	r2, [pc, #540]	; (8012310 <ScheduleTx+0x2b8>)
 80120f4:	589b      	ldr	r3, [r3, r2]
 80120f6:	33c9      	adds	r3, #201	; 0xc9
 80120f8:	33ff      	adds	r3, #255	; 0xff
 80120fa:	261f      	movs	r6, #31
 80120fc:	19bc      	adds	r4, r7, r6
 80120fe:	2218      	movs	r2, #24
 8012100:	18bd      	adds	r5, r7, r2
 8012102:	4a84      	ldr	r2, [pc, #528]	; (8012314 <ScheduleTx+0x2bc>)
 8012104:	1879      	adds	r1, r7, r1
 8012106:	9300      	str	r3, [sp, #0]
 8012108:	002b      	movs	r3, r5
 801210a:	f005 fbbe 	bl	801788a <RegionNextChannel>
 801210e:	0003      	movs	r3, r0
 8012110:	7023      	strb	r3, [r4, #0]

    if( status != LORAMAC_STATUS_OK )
 8012112:	19bb      	adds	r3, r7, r6
 8012114:	781b      	ldrb	r3, [r3, #0]
 8012116:	2b00      	cmp	r3, #0
 8012118:	d025      	beq.n	8012166 <ScheduleTx+0x10e>
    {
        if( ( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED ) &&
 801211a:	19bb      	adds	r3, r7, r6
 801211c:	781b      	ldrb	r3, [r3, #0]
 801211e:	2b0b      	cmp	r3, #11
 8012120:	d11d      	bne.n	801215e <ScheduleTx+0x106>
 8012122:	1dfb      	adds	r3, r7, #7
 8012124:	781b      	ldrb	r3, [r3, #0]
 8012126:	2b00      	cmp	r3, #0
 8012128:	d019      	beq.n	801215e <ScheduleTx+0x106>
            ( allowDelayedTx == true ) )
        {
            // Allow delayed transmissions. We have to allow it in case
            // the MAC must retransmit a frame with the frame repetitions
            if( dutyCycleTimeOff != 0 )
 801212a:	69bb      	ldr	r3, [r7, #24]
 801212c:	2b00      	cmp	r3, #0
 801212e:	d014      	beq.n	801215a <ScheduleTx+0x102>
            {// Send later - prepare timer
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 8012130:	4a76      	ldr	r2, [pc, #472]	; (801230c <ScheduleTx+0x2b4>)
 8012132:	23d0      	movs	r3, #208	; 0xd0
 8012134:	009b      	lsls	r3, r3, #2
 8012136:	58d3      	ldr	r3, [r2, r3]
 8012138:	2220      	movs	r2, #32
 801213a:	431a      	orrs	r2, r3
 801213c:	0011      	movs	r1, r2
 801213e:	4a73      	ldr	r2, [pc, #460]	; (801230c <ScheduleTx+0x2b4>)
 8012140:	23d0      	movs	r3, #208	; 0xd0
 8012142:	009b      	lsls	r3, r3, #2
 8012144:	50d1      	str	r1, [r2, r3]
                TimerSetValue( &MacCtx.TxDelayedTimer, dutyCycleTimeOff );
 8012146:	69ba      	ldr	r2, [r7, #24]
 8012148:	4b73      	ldr	r3, [pc, #460]	; (8012318 <ScheduleTx+0x2c0>)
 801214a:	0011      	movs	r1, r2
 801214c:	0018      	movs	r0, r3
 801214e:	f008 fff3 	bl	801b138 <TimerSetValue>
                TimerStart( &MacCtx.TxDelayedTimer );
 8012152:	4b71      	ldr	r3, [pc, #452]	; (8012318 <ScheduleTx+0x2c0>)
 8012154:	0018      	movs	r0, r3
 8012156:	f008 fe95 	bl	801ae84 <TimerStart>
            }
            return LORAMAC_STATUS_OK;
 801215a:	2300      	movs	r3, #0
 801215c:	e0d1      	b.n	8012302 <ScheduleTx+0x2aa>
        }
        else
        {// State where the MAC cannot send a frame
            return status;
 801215e:	231f      	movs	r3, #31
 8012160:	18fb      	adds	r3, r7, r3
 8012162:	781b      	ldrb	r3, [r3, #0]
 8012164:	e0cd      	b.n	8012302 <ScheduleTx+0x2aa>
        }
    }

    // Compute Rx1 windows parameters
    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 8012166:	4b69      	ldr	r3, [pc, #420]	; (801230c <ScheduleTx+0x2b4>)
 8012168:	4a69      	ldr	r2, [pc, #420]	; (8012310 <ScheduleTx+0x2b8>)
 801216a:	589b      	ldr	r3, [r3, r2]
 801216c:	781c      	ldrb	r4, [r3, #0]
                                     RegionApplyDrOffset( MacCtx.NvmCtx->Region, MacCtx.NvmCtx->MacParams.DownlinkDwellTime, MacCtx.NvmCtx->MacParams.ChannelsDatarate, MacCtx.NvmCtx->MacParams.Rx1DrOffset ),
 801216e:	4b67      	ldr	r3, [pc, #412]	; (801230c <ScheduleTx+0x2b4>)
 8012170:	4a67      	ldr	r2, [pc, #412]	; (8012310 <ScheduleTx+0x2b8>)
 8012172:	589b      	ldr	r3, [r3, r2]
 8012174:	7818      	ldrb	r0, [r3, #0]
 8012176:	4b65      	ldr	r3, [pc, #404]	; (801230c <ScheduleTx+0x2b4>)
 8012178:	4a65      	ldr	r2, [pc, #404]	; (8012310 <ScheduleTx+0x2b8>)
 801217a:	589a      	ldr	r2, [r3, r2]
 801217c:	232e      	movs	r3, #46	; 0x2e
 801217e:	33ff      	adds	r3, #255	; 0xff
 8012180:	5cd1      	ldrb	r1, [r2, r3]
 8012182:	4b62      	ldr	r3, [pc, #392]	; (801230c <ScheduleTx+0x2b4>)
 8012184:	4a62      	ldr	r2, [pc, #392]	; (8012310 <ScheduleTx+0x2b8>)
 8012186:	589b      	ldr	r3, [r3, r2]
 8012188:	22f9      	movs	r2, #249	; 0xf9
 801218a:	569d      	ldrsb	r5, [r3, r2]
 801218c:	4b5f      	ldr	r3, [pc, #380]	; (801230c <ScheduleTx+0x2b4>)
 801218e:	4a60      	ldr	r2, [pc, #384]	; (8012310 <ScheduleTx+0x2b8>)
 8012190:	589a      	ldr	r2, [r3, r2]
 8012192:	231a      	movs	r3, #26
 8012194:	33ff      	adds	r3, #255	; 0xff
 8012196:	5cd3      	ldrb	r3, [r2, r3]
 8012198:	b25b      	sxtb	r3, r3
 801219a:	002a      	movs	r2, r5
 801219c:	f005 fba5 	bl	80178ea <RegionApplyDrOffset>
 80121a0:	0003      	movs	r3, r0
    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 80121a2:	b259      	sxtb	r1, r3
                                     MacCtx.NvmCtx->MacParams.MinRxSymbols,
 80121a4:	4b59      	ldr	r3, [pc, #356]	; (801230c <ScheduleTx+0x2b4>)
 80121a6:	4a5a      	ldr	r2, [pc, #360]	; (8012310 <ScheduleTx+0x2b8>)
 80121a8:	589a      	ldr	r2, [r3, r2]
    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 80121aa:	2380      	movs	r3, #128	; 0x80
 80121ac:	005b      	lsls	r3, r3, #1
 80121ae:	5cd2      	ldrb	r2, [r2, r3]
                                     MacCtx.NvmCtx->MacParams.SystemMaxRxError,
 80121b0:	4b56      	ldr	r3, [pc, #344]	; (801230c <ScheduleTx+0x2b4>)
 80121b2:	4857      	ldr	r0, [pc, #348]	; (8012310 <ScheduleTx+0x2b8>)
 80121b4:	581b      	ldr	r3, [r3, r0]
    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 80121b6:	20fc      	movs	r0, #252	; 0xfc
 80121b8:	5818      	ldr	r0, [r3, r0]
 80121ba:	4b58      	ldr	r3, [pc, #352]	; (801231c <ScheduleTx+0x2c4>)
 80121bc:	9300      	str	r3, [sp, #0]
 80121be:	0003      	movs	r3, r0
 80121c0:	0020      	movs	r0, r4
 80121c2:	f005 fa5b 	bl	801767c <RegionComputeRxWindowParameters>
                                     &MacCtx.RxWindow1Config );
    // Compute Rx2 windows parameters
    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 80121c6:	4b51      	ldr	r3, [pc, #324]	; (801230c <ScheduleTx+0x2b4>)
 80121c8:	4a51      	ldr	r2, [pc, #324]	; (8012310 <ScheduleTx+0x2b8>)
 80121ca:	589b      	ldr	r3, [r3, r2]
 80121cc:	7818      	ldrb	r0, [r3, #0]
                                     MacCtx.NvmCtx->MacParams.Rx2Channel.Datarate,
 80121ce:	4b4f      	ldr	r3, [pc, #316]	; (801230c <ScheduleTx+0x2b4>)
 80121d0:	4a4f      	ldr	r2, [pc, #316]	; (8012310 <ScheduleTx+0x2b8>)
 80121d2:	589a      	ldr	r2, [r3, r2]
 80121d4:	2390      	movs	r3, #144	; 0x90
 80121d6:	005b      	lsls	r3, r3, #1
 80121d8:	5cd3      	ldrb	r3, [r2, r3]
    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 80121da:	b259      	sxtb	r1, r3
                                     MacCtx.NvmCtx->MacParams.MinRxSymbols,
 80121dc:	4b4b      	ldr	r3, [pc, #300]	; (801230c <ScheduleTx+0x2b4>)
 80121de:	4a4c      	ldr	r2, [pc, #304]	; (8012310 <ScheduleTx+0x2b8>)
 80121e0:	589a      	ldr	r2, [r3, r2]
    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 80121e2:	2380      	movs	r3, #128	; 0x80
 80121e4:	005b      	lsls	r3, r3, #1
 80121e6:	5cd2      	ldrb	r2, [r2, r3]
                                     MacCtx.NvmCtx->MacParams.SystemMaxRxError,
 80121e8:	4b48      	ldr	r3, [pc, #288]	; (801230c <ScheduleTx+0x2b4>)
 80121ea:	4c49      	ldr	r4, [pc, #292]	; (8012310 <ScheduleTx+0x2b8>)
 80121ec:	591b      	ldr	r3, [r3, r4]
    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 80121ee:	24fc      	movs	r4, #252	; 0xfc
 80121f0:	591c      	ldr	r4, [r3, r4]
 80121f2:	4b4b      	ldr	r3, [pc, #300]	; (8012320 <ScheduleTx+0x2c8>)
 80121f4:	9300      	str	r3, [sp, #0]
 80121f6:	0023      	movs	r3, r4
 80121f8:	f005 fa40 	bl	801767c <RegionComputeRxWindowParameters>
                                     &MacCtx.RxWindow2Config );

    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )
 80121fc:	4b43      	ldr	r3, [pc, #268]	; (801230c <ScheduleTx+0x2b4>)
 80121fe:	4a44      	ldr	r2, [pc, #272]	; (8012310 <ScheduleTx+0x2b8>)
 8012200:	589a      	ldr	r2, [r3, r2]
 8012202:	23ea      	movs	r3, #234	; 0xea
 8012204:	005b      	lsls	r3, r3, #1
 8012206:	5cd3      	ldrb	r3, [r2, r3]
 8012208:	2b00      	cmp	r3, #0
 801220a:	d11e      	bne.n	801224a <ScheduleTx+0x1f2>
    {
        MacCtx.RxWindow1Delay = MacCtx.NvmCtx->MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 801220c:	4b3f      	ldr	r3, [pc, #252]	; (801230c <ScheduleTx+0x2b4>)
 801220e:	4a40      	ldr	r2, [pc, #256]	; (8012310 <ScheduleTx+0x2b8>)
 8012210:	589a      	ldr	r2, [r3, r2]
 8012212:	2388      	movs	r3, #136	; 0x88
 8012214:	005b      	lsls	r3, r3, #1
 8012216:	58d3      	ldr	r3, [r2, r3]
 8012218:	493c      	ldr	r1, [pc, #240]	; (801230c <ScheduleTx+0x2b4>)
 801221a:	22f1      	movs	r2, #241	; 0xf1
 801221c:	0092      	lsls	r2, r2, #2
 801221e:	588a      	ldr	r2, [r1, r2]
 8012220:	1899      	adds	r1, r3, r2
 8012222:	4a3a      	ldr	r2, [pc, #232]	; (801230c <ScheduleTx+0x2b4>)
 8012224:	23ec      	movs	r3, #236	; 0xec
 8012226:	009b      	lsls	r3, r3, #2
 8012228:	50d1      	str	r1, [r2, r3]
        MacCtx.RxWindow2Delay = MacCtx.NvmCtx->MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 801222a:	4b38      	ldr	r3, [pc, #224]	; (801230c <ScheduleTx+0x2b4>)
 801222c:	4a38      	ldr	r2, [pc, #224]	; (8012310 <ScheduleTx+0x2b8>)
 801222e:	589a      	ldr	r2, [r3, r2]
 8012230:	238a      	movs	r3, #138	; 0x8a
 8012232:	005b      	lsls	r3, r3, #1
 8012234:	58d3      	ldr	r3, [r2, r3]
 8012236:	4935      	ldr	r1, [pc, #212]	; (801230c <ScheduleTx+0x2b4>)
 8012238:	22f6      	movs	r2, #246	; 0xf6
 801223a:	0092      	lsls	r2, r2, #2
 801223c:	588a      	ldr	r2, [r1, r2]
 801223e:	1899      	adds	r1, r3, r2
 8012240:	4a32      	ldr	r2, [pc, #200]	; (801230c <ScheduleTx+0x2b4>)
 8012242:	23ed      	movs	r3, #237	; 0xed
 8012244:	009b      	lsls	r3, r3, #2
 8012246:	50d1      	str	r1, [r2, r3]
 8012248:	e03c      	b.n	80122c4 <ScheduleTx+0x26c>
    }
    else
    {
        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 801224a:	2308      	movs	r3, #8
 801224c:	18fb      	adds	r3, r7, r3
 801224e:	0018      	movs	r0, r3
 8012250:	f003 f9c0 	bl	80155d4 <LoRaMacCommandsGetSizeSerializedCmds>
 8012254:	1e03      	subs	r3, r0, #0
 8012256:	d001      	beq.n	801225c <ScheduleTx+0x204>
        {
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8012258:	2313      	movs	r3, #19
 801225a:	e052      	b.n	8012302 <ScheduleTx+0x2aa>
        }

        if( ValidatePayloadLength( MacCtx.AppDataSize, MacCtx.NvmCtx->MacParams.ChannelsDatarate, macCmdsSize ) == false )
 801225c:	4b2b      	ldr	r3, [pc, #172]	; (801230c <ScheduleTx+0x2b4>)
 801225e:	4a31      	ldr	r2, [pc, #196]	; (8012324 <ScheduleTx+0x2cc>)
 8012260:	5c98      	ldrb	r0, [r3, r2]
 8012262:	4b2a      	ldr	r3, [pc, #168]	; (801230c <ScheduleTx+0x2b4>)
 8012264:	4a2a      	ldr	r2, [pc, #168]	; (8012310 <ScheduleTx+0x2b8>)
 8012266:	589b      	ldr	r3, [r3, r2]
 8012268:	22f9      	movs	r2, #249	; 0xf9
 801226a:	569b      	ldrsb	r3, [r3, r2]
 801226c:	68ba      	ldr	r2, [r7, #8]
 801226e:	b2d2      	uxtb	r2, r2
 8012270:	0019      	movs	r1, r3
 8012272:	f7fe ffa7 	bl	80111c4 <ValidatePayloadLength>
 8012276:	0003      	movs	r3, r0
 8012278:	001a      	movs	r2, r3
 801227a:	2301      	movs	r3, #1
 801227c:	4053      	eors	r3, r2
 801227e:	b2db      	uxtb	r3, r3
 8012280:	2b00      	cmp	r3, #0
 8012282:	d001      	beq.n	8012288 <ScheduleTx+0x230>
        {
            return LORAMAC_STATUS_LENGTH_ERROR;
 8012284:	2308      	movs	r3, #8
 8012286:	e03c      	b.n	8012302 <ScheduleTx+0x2aa>
        }
        MacCtx.RxWindow1Delay = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8012288:	4b20      	ldr	r3, [pc, #128]	; (801230c <ScheduleTx+0x2b4>)
 801228a:	4a21      	ldr	r2, [pc, #132]	; (8012310 <ScheduleTx+0x2b8>)
 801228c:	589a      	ldr	r2, [r3, r2]
 801228e:	2384      	movs	r3, #132	; 0x84
 8012290:	005b      	lsls	r3, r3, #1
 8012292:	58d3      	ldr	r3, [r2, r3]
 8012294:	491d      	ldr	r1, [pc, #116]	; (801230c <ScheduleTx+0x2b4>)
 8012296:	22f1      	movs	r2, #241	; 0xf1
 8012298:	0092      	lsls	r2, r2, #2
 801229a:	588a      	ldr	r2, [r1, r2]
 801229c:	1899      	adds	r1, r3, r2
 801229e:	4a1b      	ldr	r2, [pc, #108]	; (801230c <ScheduleTx+0x2b4>)
 80122a0:	23ec      	movs	r3, #236	; 0xec
 80122a2:	009b      	lsls	r3, r3, #2
 80122a4:	50d1      	str	r1, [r2, r3]
        MacCtx.RxWindow2Delay = MacCtx.NvmCtx->MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 80122a6:	4b19      	ldr	r3, [pc, #100]	; (801230c <ScheduleTx+0x2b4>)
 80122a8:	4a19      	ldr	r2, [pc, #100]	; (8012310 <ScheduleTx+0x2b8>)
 80122aa:	589a      	ldr	r2, [r3, r2]
 80122ac:	2386      	movs	r3, #134	; 0x86
 80122ae:	005b      	lsls	r3, r3, #1
 80122b0:	58d3      	ldr	r3, [r2, r3]
 80122b2:	4916      	ldr	r1, [pc, #88]	; (801230c <ScheduleTx+0x2b4>)
 80122b4:	22f6      	movs	r2, #246	; 0xf6
 80122b6:	0092      	lsls	r2, r2, #2
 80122b8:	588a      	ldr	r2, [r1, r2]
 80122ba:	1899      	adds	r1, r3, r2
 80122bc:	4a13      	ldr	r2, [pc, #76]	; (801230c <ScheduleTx+0x2b4>)
 80122be:	23ed      	movs	r3, #237	; 0xed
 80122c0:	009b      	lsls	r3, r3, #2
 80122c2:	50d1      	str	r1, [r2, r3]
    }

    // Secure frame
    LoRaMacStatus_t retval = SecureFrame( MacCtx.NvmCtx->MacParams.ChannelsDatarate, MacCtx.Channel );
 80122c4:	4b11      	ldr	r3, [pc, #68]	; (801230c <ScheduleTx+0x2b4>)
 80122c6:	4a12      	ldr	r2, [pc, #72]	; (8012310 <ScheduleTx+0x2b8>)
 80122c8:	589b      	ldr	r3, [r3, r2]
 80122ca:	22f9      	movs	r2, #249	; 0xf9
 80122cc:	569b      	ldrsb	r3, [r3, r2]
 80122ce:	b2da      	uxtb	r2, r3
 80122d0:	4b0e      	ldr	r3, [pc, #56]	; (801230c <ScheduleTx+0x2b4>)
 80122d2:	4915      	ldr	r1, [pc, #84]	; (8012328 <ScheduleTx+0x2d0>)
 80122d4:	5c5b      	ldrb	r3, [r3, r1]
 80122d6:	251e      	movs	r5, #30
 80122d8:	197c      	adds	r4, r7, r5
 80122da:	0019      	movs	r1, r3
 80122dc:	0010      	movs	r0, r2
 80122de:	f000 f825 	bl	801232c <SecureFrame>
 80122e2:	0003      	movs	r3, r0
 80122e4:	7023      	strb	r3, [r4, #0]
    if( retval != LORAMAC_STATUS_OK )
 80122e6:	197b      	adds	r3, r7, r5
 80122e8:	781b      	ldrb	r3, [r3, #0]
 80122ea:	2b00      	cmp	r3, #0
 80122ec:	d002      	beq.n	80122f4 <ScheduleTx+0x29c>
    {
        return retval;
 80122ee:	197b      	adds	r3, r7, r5
 80122f0:	781b      	ldrb	r3, [r3, #0]
 80122f2:	e006      	b.n	8012302 <ScheduleTx+0x2aa>
    }

    // Try to send now
    return SendFrameOnChannel( MacCtx.Channel );
 80122f4:	4b05      	ldr	r3, [pc, #20]	; (801230c <ScheduleTx+0x2b4>)
 80122f6:	4a0c      	ldr	r2, [pc, #48]	; (8012328 <ScheduleTx+0x2d0>)
 80122f8:	5c9b      	ldrb	r3, [r3, r2]
 80122fa:	0018      	movs	r0, r3
 80122fc:	f000 fbd0 	bl	8012aa0 <SendFrameOnChannel>
 8012300:	0003      	movs	r3, r0
}
 8012302:	0018      	movs	r0, r3
 8012304:	46bd      	mov	sp, r7
 8012306:	b009      	add	sp, #36	; 0x24
 8012308:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801230a:	46c0      	nop			; (mov r8, r8)
 801230c:	200008ec 	.word	0x200008ec
 8012310:	00000484 	.word	0x00000484
 8012314:	20000d01 	.word	0x20000d01
 8012318:	20000c54 	.word	0x20000c54
 801231c:	20000ca4 	.word	0x20000ca4
 8012320:	20000cb8 	.word	0x20000cb8
 8012324:	00000237 	.word	0x00000237
 8012328:	00000415 	.word	0x00000415

0801232c <SecureFrame>:

static LoRaMacStatus_t SecureFrame( uint8_t txDr, uint8_t txCh )
{
 801232c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801232e:	b085      	sub	sp, #20
 8012330:	af00      	add	r7, sp, #0
 8012332:	0002      	movs	r2, r0
 8012334:	1dfb      	adds	r3, r7, #7
 8012336:	701a      	strb	r2, [r3, #0]
 8012338:	1dbb      	adds	r3, r7, #6
 801233a:	1c0a      	adds	r2, r1, #0
 801233c:	701a      	strb	r2, [r3, #0]
    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;
 801233e:	230f      	movs	r3, #15
 8012340:	18fb      	adds	r3, r7, r3
 8012342:	2213      	movs	r2, #19
 8012344:	701a      	strb	r2, [r3, #0]
    uint32_t fCntUp = 0;
 8012346:	2300      	movs	r3, #0
 8012348:	60bb      	str	r3, [r7, #8]

    switch( MacCtx.TxMsg.Type )
 801234a:	4a2c      	ldr	r2, [pc, #176]	; (80123fc <SecureFrame+0xd0>)
 801234c:	2382      	movs	r3, #130	; 0x82
 801234e:	005b      	lsls	r3, r3, #1
 8012350:	5cd3      	ldrb	r3, [r2, r3]
 8012352:	2b00      	cmp	r3, #0
 8012354:	d002      	beq.n	801235c <SecureFrame+0x30>
 8012356:	2b04      	cmp	r3, #4
 8012358:	d016      	beq.n	8012388 <SecureFrame+0x5c>
 801235a:	e047      	b.n	80123ec <SecureFrame+0xc0>
    {
        case LORAMAC_MSG_TYPE_JOIN_REQUEST:
            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 801235c:	250f      	movs	r5, #15
 801235e:	197c      	adds	r4, r7, r5
 8012360:	4b27      	ldr	r3, [pc, #156]	; (8012400 <SecureFrame+0xd4>)
 8012362:	0018      	movs	r0, r3
 8012364:	f004 f90e 	bl	8016584 <LoRaMacCryptoPrepareJoinRequest>
 8012368:	0003      	movs	r3, r0
 801236a:	7023      	strb	r3, [r4, #0]
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 801236c:	197b      	adds	r3, r7, r5
 801236e:	781b      	ldrb	r3, [r3, #0]
 8012370:	2b00      	cmp	r3, #0
 8012372:	d001      	beq.n	8012378 <SecureFrame+0x4c>
            {
                return LORAMAC_STATUS_CRYPTO_ERROR;
 8012374:	2311      	movs	r3, #17
 8012376:	e03c      	b.n	80123f2 <SecureFrame+0xc6>
            }
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.JoinReq.BufSize;
 8012378:	4a20      	ldr	r2, [pc, #128]	; (80123fc <SecureFrame+0xd0>)
 801237a:	2386      	movs	r3, #134	; 0x86
 801237c:	005b      	lsls	r3, r3, #1
 801237e:	5cd3      	ldrb	r3, [r2, r3]
 8012380:	b29a      	uxth	r2, r3
 8012382:	4b1e      	ldr	r3, [pc, #120]	; (80123fc <SecureFrame+0xd0>)
 8012384:	801a      	strh	r2, [r3, #0]
            break;
 8012386:	e033      	b.n	80123f0 <SecureFrame+0xc4>
        case LORAMAC_MSG_TYPE_DATA:

            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 8012388:	2308      	movs	r3, #8
 801238a:	18fb      	adds	r3, r7, r3
 801238c:	0018      	movs	r0, r3
 801238e:	f003 fff5 	bl	801637c <LoRaMacCryptoGetFCntUp>
 8012392:	1e03      	subs	r3, r0, #0
 8012394:	d001      	beq.n	801239a <SecureFrame+0x6e>
            {
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 8012396:	2312      	movs	r3, #18
 8012398:	e02b      	b.n	80123f2 <SecureFrame+0xc6>
            }

            if( ( MacCtx.ChannelsNbTransCounter >= 1 ) || ( MacCtx.AckTimeoutRetriesCounter > 1 ) )
 801239a:	4a18      	ldr	r2, [pc, #96]	; (80123fc <SecureFrame+0xd0>)
 801239c:	2382      	movs	r3, #130	; 0x82
 801239e:	00db      	lsls	r3, r3, #3
 80123a0:	5cd3      	ldrb	r3, [r2, r3]
 80123a2:	2b00      	cmp	r3, #0
 80123a4:	d104      	bne.n	80123b0 <SecureFrame+0x84>
 80123a6:	4b15      	ldr	r3, [pc, #84]	; (80123fc <SecureFrame+0xd0>)
 80123a8:	4a16      	ldr	r2, [pc, #88]	; (8012404 <SecureFrame+0xd8>)
 80123aa:	5c9b      	ldrb	r3, [r3, r2]
 80123ac:	2b01      	cmp	r3, #1
 80123ae:	d902      	bls.n	80123b6 <SecureFrame+0x8a>
            {
                fCntUp -= 1;
 80123b0:	68bb      	ldr	r3, [r7, #8]
 80123b2:	3b01      	subs	r3, #1
 80123b4:	60bb      	str	r3, [r7, #8]
            }

            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );
 80123b6:	68b8      	ldr	r0, [r7, #8]
 80123b8:	260f      	movs	r6, #15
 80123ba:	19bc      	adds	r4, r7, r6
 80123bc:	4d10      	ldr	r5, [pc, #64]	; (8012400 <SecureFrame+0xd4>)
 80123be:	1dbb      	adds	r3, r7, #6
 80123c0:	781a      	ldrb	r2, [r3, #0]
 80123c2:	1dfb      	adds	r3, r7, #7
 80123c4:	7819      	ldrb	r1, [r3, #0]
 80123c6:	002b      	movs	r3, r5
 80123c8:	f004 fb10 	bl	80169ec <LoRaMacCryptoSecureMessage>
 80123cc:	0003      	movs	r3, r0
 80123ce:	7023      	strb	r3, [r4, #0]
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 80123d0:	19bb      	adds	r3, r7, r6
 80123d2:	781b      	ldrb	r3, [r3, #0]
 80123d4:	2b00      	cmp	r3, #0
 80123d6:	d001      	beq.n	80123dc <SecureFrame+0xb0>
            {
                return LORAMAC_STATUS_CRYPTO_ERROR;
 80123d8:	2311      	movs	r3, #17
 80123da:	e00a      	b.n	80123f2 <SecureFrame+0xc6>
            }
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 80123dc:	4a07      	ldr	r2, [pc, #28]	; (80123fc <SecureFrame+0xd0>)
 80123de:	2386      	movs	r3, #134	; 0x86
 80123e0:	005b      	lsls	r3, r3, #1
 80123e2:	5cd3      	ldrb	r3, [r2, r3]
 80123e4:	b29a      	uxth	r2, r3
 80123e6:	4b05      	ldr	r3, [pc, #20]	; (80123fc <SecureFrame+0xd0>)
 80123e8:	801a      	strh	r2, [r3, #0]
            break;
 80123ea:	e001      	b.n	80123f0 <SecureFrame+0xc4>
        case LORAMAC_MSG_TYPE_JOIN_ACCEPT:
        case LORAMAC_MSG_TYPE_UNDEF:
        default:
            return LORAMAC_STATUS_PARAMETER_INVALID;
 80123ec:	2303      	movs	r3, #3
 80123ee:	e000      	b.n	80123f2 <SecureFrame+0xc6>
    }
    return LORAMAC_STATUS_OK;
 80123f0:	2300      	movs	r3, #0
}
 80123f2:	0018      	movs	r0, r3
 80123f4:	46bd      	mov	sp, r7
 80123f6:	b005      	add	sp, #20
 80123f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80123fa:	46c0      	nop			; (mov r8, r8)
 80123fc:	200008ec 	.word	0x200008ec
 8012400:	200009f4 	.word	0x200009f4
 8012404:	00000412 	.word	0x00000412

08012408 <CalculateBackOff>:

static void CalculateBackOff( uint8_t channel )
{
 8012408:	b590      	push	{r4, r7, lr}
 801240a:	b087      	sub	sp, #28
 801240c:	af00      	add	r7, sp, #0
 801240e:	0002      	movs	r2, r0
 8012410:	1dfb      	adds	r3, r7, #7
 8012412:	701a      	strb	r2, [r3, #0]
    CalcBackOffParams_t calcBackOff;

    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )
 8012414:	4b31      	ldr	r3, [pc, #196]	; (80124dc <CalculateBackOff+0xd4>)
 8012416:	4a32      	ldr	r2, [pc, #200]	; (80124e0 <CalculateBackOff+0xd8>)
 8012418:	589a      	ldr	r2, [r3, r2]
 801241a:	23ea      	movs	r3, #234	; 0xea
 801241c:	005b      	lsls	r3, r3, #1
 801241e:	5cd3      	ldrb	r3, [r2, r3]
 8012420:	2b00      	cmp	r3, #0
 8012422:	d104      	bne.n	801242e <CalculateBackOff+0x26>
    {
        calcBackOff.Joined = false;
 8012424:	230c      	movs	r3, #12
 8012426:	18fb      	adds	r3, r7, r3
 8012428:	2200      	movs	r2, #0
 801242a:	701a      	strb	r2, [r3, #0]
 801242c:	e003      	b.n	8012436 <CalculateBackOff+0x2e>
    }
    else
    {
        calcBackOff.Joined = true;
 801242e:	230c      	movs	r3, #12
 8012430:	18fb      	adds	r3, r7, r3
 8012432:	2201      	movs	r2, #1
 8012434:	701a      	strb	r2, [r3, #0]
    }
    calcBackOff.DutyCycleEnabled = MacCtx.NvmCtx->DutyCycleOn;
 8012436:	4b29      	ldr	r3, [pc, #164]	; (80124dc <CalculateBackOff+0xd4>)
 8012438:	4a29      	ldr	r2, [pc, #164]	; (80124e0 <CalculateBackOff+0xd8>)
 801243a:	589a      	ldr	r2, [r3, r2]
 801243c:	233e      	movs	r3, #62	; 0x3e
 801243e:	33ff      	adds	r3, #255	; 0xff
 8012440:	5cd2      	ldrb	r2, [r2, r3]
 8012442:	240c      	movs	r4, #12
 8012444:	193b      	adds	r3, r7, r4
 8012446:	709a      	strb	r2, [r3, #2]
    calcBackOff.Channel = channel;
 8012448:	193b      	adds	r3, r7, r4
 801244a:	1dfa      	adds	r2, r7, #7
 801244c:	7812      	ldrb	r2, [r2, #0]
 801244e:	70da      	strb	r2, [r3, #3]
    calcBackOff.ElapsedTime = TimerGetElapsedTime( MacCtx.NvmCtx->InitializationTime );
 8012450:	4b22      	ldr	r3, [pc, #136]	; (80124dc <CalculateBackOff+0xd4>)
 8012452:	4a23      	ldr	r2, [pc, #140]	; (80124e0 <CalculateBackOff+0xd8>)
 8012454:	589a      	ldr	r2, [r3, r2]
 8012456:	23e6      	movs	r3, #230	; 0xe6
 8012458:	005b      	lsls	r3, r3, #1
 801245a:	58d3      	ldr	r3, [r2, r3]
 801245c:	0018      	movs	r0, r3
 801245e:	f008 fea0 	bl	801b1a2 <TimerGetElapsedTime>
 8012462:	0002      	movs	r2, r0
 8012464:	193b      	adds	r3, r7, r4
 8012466:	605a      	str	r2, [r3, #4]
    calcBackOff.TxTimeOnAir = MacCtx.TxTimeOnAir;
 8012468:	4a1c      	ldr	r2, [pc, #112]	; (80124dc <CalculateBackOff+0xd4>)
 801246a:	2383      	movs	r3, #131	; 0x83
 801246c:	00db      	lsls	r3, r3, #3
 801246e:	58d2      	ldr	r2, [r2, r3]
 8012470:	193b      	adds	r3, r7, r4
 8012472:	609a      	str	r2, [r3, #8]
    calcBackOff.LastTxIsJoinRequest = false;
 8012474:	193b      	adds	r3, r7, r4
 8012476:	2200      	movs	r2, #0
 8012478:	705a      	strb	r2, [r3, #1]
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) && ( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true ) )
 801247a:	4b18      	ldr	r3, [pc, #96]	; (80124dc <CalculateBackOff+0xd4>)
 801247c:	4a19      	ldr	r2, [pc, #100]	; (80124e4 <CalculateBackOff+0xdc>)
 801247e:	5c9b      	ldrb	r3, [r3, r2]
 8012480:	2204      	movs	r2, #4
 8012482:	4013      	ands	r3, r2
 8012484:	b2db      	uxtb	r3, r3
 8012486:	2b00      	cmp	r3, #0
 8012488:	d007      	beq.n	801249a <CalculateBackOff+0x92>
 801248a:	2000      	movs	r0, #0
 801248c:	f003 fa92 	bl	80159b4 <LoRaMacConfirmQueueIsCmdActive>
 8012490:	1e03      	subs	r3, r0, #0
 8012492:	d002      	beq.n	801249a <CalculateBackOff+0x92>
    {
        calcBackOff.LastTxIsJoinRequest = true;
 8012494:	193b      	adds	r3, r7, r4
 8012496:	2201      	movs	r2, #1
 8012498:	705a      	strb	r2, [r3, #1]
    }

    // Update regional back-off
    RegionCalcBackOff( MacCtx.NvmCtx->Region, &calcBackOff );
 801249a:	4b10      	ldr	r3, [pc, #64]	; (80124dc <CalculateBackOff+0xd4>)
 801249c:	4a10      	ldr	r2, [pc, #64]	; (80124e0 <CalculateBackOff+0xd8>)
 801249e:	589b      	ldr	r3, [r3, r2]
 80124a0:	781b      	ldrb	r3, [r3, #0]
 80124a2:	220c      	movs	r2, #12
 80124a4:	18ba      	adds	r2, r7, r2
 80124a6:	0011      	movs	r1, r2
 80124a8:	0018      	movs	r0, r3
 80124aa:	f005 f9d9 	bl	8017860 <RegionCalcBackOff>

    // Update aggregated time-off. This must be an assignment and no incremental
    // update as we do only calculate the time-off based on the last transmission
    MacCtx.NvmCtx->AggregatedTimeOff = ( MacCtx.TxTimeOnAir * MacCtx.NvmCtx->AggregatedDCycle - MacCtx.TxTimeOnAir );
 80124ae:	4b0b      	ldr	r3, [pc, #44]	; (80124dc <CalculateBackOff+0xd4>)
 80124b0:	4a0b      	ldr	r2, [pc, #44]	; (80124e0 <CalculateBackOff+0xd8>)
 80124b2:	589a      	ldr	r2, [r3, r2]
 80124b4:	23e1      	movs	r3, #225	; 0xe1
 80124b6:	005b      	lsls	r3, r3, #1
 80124b8:	5ad3      	ldrh	r3, [r2, r3]
 80124ba:	3b01      	subs	r3, #1
 80124bc:	4907      	ldr	r1, [pc, #28]	; (80124dc <CalculateBackOff+0xd4>)
 80124be:	2283      	movs	r2, #131	; 0x83
 80124c0:	00d2      	lsls	r2, r2, #3
 80124c2:	5889      	ldr	r1, [r1, r2]
 80124c4:	4a05      	ldr	r2, [pc, #20]	; (80124dc <CalculateBackOff+0xd4>)
 80124c6:	4806      	ldr	r0, [pc, #24]	; (80124e0 <CalculateBackOff+0xd8>)
 80124c8:	5812      	ldr	r2, [r2, r0]
 80124ca:	4359      	muls	r1, r3
 80124cc:	23e4      	movs	r3, #228	; 0xe4
 80124ce:	005b      	lsls	r3, r3, #1
 80124d0:	50d1      	str	r1, [r2, r3]
}
 80124d2:	46c0      	nop			; (mov r8, r8)
 80124d4:	46bd      	mov	sp, r7
 80124d6:	b007      	add	sp, #28
 80124d8:	bd90      	pop	{r4, r7, pc}
 80124da:	46c0      	nop			; (mov r8, r8)
 80124dc:	200008ec 	.word	0x200008ec
 80124e0:	00000484 	.word	0x00000484
 80124e4:	00000481 	.word	0x00000481

080124e8 <RemoveMacCommands>:

static void RemoveMacCommands( LoRaMacRxSlot_t rxSlot, LoRaMacFrameCtrl_t fCtrl, Mcps_t request )
{
 80124e8:	b580      	push	{r7, lr}
 80124ea:	b082      	sub	sp, #8
 80124ec:	af00      	add	r7, sp, #0
 80124ee:	1d3b      	adds	r3, r7, #4
 80124f0:	7019      	strb	r1, [r3, #0]
 80124f2:	0011      	movs	r1, r2
 80124f4:	1dfb      	adds	r3, r7, #7
 80124f6:	1c02      	adds	r2, r0, #0
 80124f8:	701a      	strb	r2, [r3, #0]
 80124fa:	1dbb      	adds	r3, r7, #6
 80124fc:	1c0a      	adds	r2, r1, #0
 80124fe:	701a      	strb	r2, [r3, #0]
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 8012500:	1dfb      	adds	r3, r7, #7
 8012502:	781b      	ldrb	r3, [r3, #0]
 8012504:	2b00      	cmp	r3, #0
 8012506:	d003      	beq.n	8012510 <RemoveMacCommands+0x28>
 8012508:	1dfb      	adds	r3, r7, #7
 801250a:	781b      	ldrb	r3, [r3, #0]
 801250c:	2b01      	cmp	r3, #1
 801250e:	d10f      	bne.n	8012530 <RemoveMacCommands+0x48>
    {
        // Remove all sticky MAC commands answers since we can assume
        // that they have been received by the server.
        if( request == MCPS_CONFIRMED )
 8012510:	1dbb      	adds	r3, r7, #6
 8012512:	781b      	ldrb	r3, [r3, #0]
 8012514:	2b01      	cmp	r3, #1
 8012516:	d109      	bne.n	801252c <RemoveMacCommands+0x44>
        {
            if( fCtrl.Bits.Ack == 1 )
 8012518:	1d3b      	adds	r3, r7, #4
 801251a:	781b      	ldrb	r3, [r3, #0]
 801251c:	2220      	movs	r2, #32
 801251e:	4013      	ands	r3, r2
 8012520:	b2db      	uxtb	r3, r3
 8012522:	2b00      	cmp	r3, #0
 8012524:	d004      	beq.n	8012530 <RemoveMacCommands+0x48>
            {  // For confirmed uplinks only if we have received an ACK.
                LoRaMacCommandsRemoveStickyAnsCmds( );
 8012526:	f003 f831 	bl	801558c <LoRaMacCommandsRemoveStickyAnsCmds>
        else
        {
            LoRaMacCommandsRemoveStickyAnsCmds( );
        }
    }
}
 801252a:	e001      	b.n	8012530 <RemoveMacCommands+0x48>
            LoRaMacCommandsRemoveStickyAnsCmds( );
 801252c:	f003 f82e 	bl	801558c <LoRaMacCommandsRemoveStickyAnsCmds>
}
 8012530:	46c0      	nop			; (mov r8, r8)
 8012532:	46bd      	mov	sp, r7
 8012534:	b002      	add	sp, #8
 8012536:	bd80      	pop	{r7, pc}

08012538 <ResetMacParameters>:


static void ResetMacParameters( void )
{
 8012538:	b580      	push	{r7, lr}
 801253a:	b082      	sub	sp, #8
 801253c:	af00      	add	r7, sp, #0
    MacCtx.NvmCtx->NetworkActivation = ACTIVATION_TYPE_NONE;
 801253e:	4b72      	ldr	r3, [pc, #456]	; (8012708 <ResetMacParameters+0x1d0>)
 8012540:	4a72      	ldr	r2, [pc, #456]	; (801270c <ResetMacParameters+0x1d4>)
 8012542:	589a      	ldr	r2, [r3, r2]
 8012544:	23ea      	movs	r3, #234	; 0xea
 8012546:	005b      	lsls	r3, r3, #1
 8012548:	2100      	movs	r1, #0
 801254a:	54d1      	strb	r1, [r2, r3]

    // ADR counter
    MacCtx.NvmCtx->AdrAckCounter = 0;
 801254c:	4b6e      	ldr	r3, [pc, #440]	; (8012708 <ResetMacParameters+0x1d0>)
 801254e:	4a6f      	ldr	r2, [pc, #444]	; (801270c <ResetMacParameters+0x1d4>)
 8012550:	589b      	ldr	r3, [r3, r2]
 8012552:	22f4      	movs	r2, #244	; 0xf4
 8012554:	2100      	movs	r1, #0
 8012556:	5099      	str	r1, [r3, r2]

    MacCtx.ChannelsNbTransCounter = 0;
 8012558:	4a6b      	ldr	r2, [pc, #428]	; (8012708 <ResetMacParameters+0x1d0>)
 801255a:	2382      	movs	r3, #130	; 0x82
 801255c:	00db      	lsls	r3, r3, #3
 801255e:	2100      	movs	r1, #0
 8012560:	54d1      	strb	r1, [r2, r3]
    MacCtx.AckTimeoutRetries = 1;
 8012562:	4b69      	ldr	r3, [pc, #420]	; (8012708 <ResetMacParameters+0x1d0>)
 8012564:	4a6a      	ldr	r2, [pc, #424]	; (8012710 <ResetMacParameters+0x1d8>)
 8012566:	2101      	movs	r1, #1
 8012568:	5499      	strb	r1, [r3, r2]
    MacCtx.AckTimeoutRetriesCounter = 1;
 801256a:	4b67      	ldr	r3, [pc, #412]	; (8012708 <ResetMacParameters+0x1d0>)
 801256c:	4a69      	ldr	r2, [pc, #420]	; (8012714 <ResetMacParameters+0x1dc>)
 801256e:	2101      	movs	r1, #1
 8012570:	5499      	strb	r1, [r3, r2]
    MacCtx.AckTimeoutRetry = false;
 8012572:	4b65      	ldr	r3, [pc, #404]	; (8012708 <ResetMacParameters+0x1d0>)
 8012574:	4a68      	ldr	r2, [pc, #416]	; (8012718 <ResetMacParameters+0x1e0>)
 8012576:	2100      	movs	r1, #0
 8012578:	5499      	strb	r1, [r3, r2]

    MacCtx.NvmCtx->MaxDCycle = 0;
 801257a:	4b63      	ldr	r3, [pc, #396]	; (8012708 <ResetMacParameters+0x1d0>)
 801257c:	4a63      	ldr	r2, [pc, #396]	; (801270c <ResetMacParameters+0x1d4>)
 801257e:	589a      	ldr	r2, [r3, r2]
 8012580:	239e      	movs	r3, #158	; 0x9e
 8012582:	005b      	lsls	r3, r3, #1
 8012584:	2100      	movs	r1, #0
 8012586:	54d1      	strb	r1, [r2, r3]
    MacCtx.NvmCtx->AggregatedDCycle = 1;
 8012588:	4b5f      	ldr	r3, [pc, #380]	; (8012708 <ResetMacParameters+0x1d0>)
 801258a:	4a60      	ldr	r2, [pc, #384]	; (801270c <ResetMacParameters+0x1d4>)
 801258c:	589a      	ldr	r2, [r3, r2]
 801258e:	23e1      	movs	r3, #225	; 0xe1
 8012590:	005b      	lsls	r3, r3, #1
 8012592:	2101      	movs	r1, #1
 8012594:	52d1      	strh	r1, [r2, r3]

    MacCtx.NvmCtx->MacParams.ChannelsTxPower = MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower;
 8012596:	4b5c      	ldr	r3, [pc, #368]	; (8012708 <ResetMacParameters+0x1d0>)
 8012598:	4a5c      	ldr	r2, [pc, #368]	; (801270c <ResetMacParameters+0x1d4>)
 801259a:	589a      	ldr	r2, [r3, r2]
 801259c:	4b5a      	ldr	r3, [pc, #360]	; (8012708 <ResetMacParameters+0x1d0>)
 801259e:	495b      	ldr	r1, [pc, #364]	; (801270c <ResetMacParameters+0x1d4>)
 80125a0:	585b      	ldr	r3, [r3, r1]
 80125a2:	2104      	movs	r1, #4
 80125a4:	5651      	ldrsb	r1, [r2, r1]
 80125a6:	22f8      	movs	r2, #248	; 0xf8
 80125a8:	5499      	strb	r1, [r3, r2]
    MacCtx.NvmCtx->MacParams.ChannelsDatarate = MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate;
 80125aa:	4b57      	ldr	r3, [pc, #348]	; (8012708 <ResetMacParameters+0x1d0>)
 80125ac:	4a57      	ldr	r2, [pc, #348]	; (801270c <ResetMacParameters+0x1d4>)
 80125ae:	589a      	ldr	r2, [r3, r2]
 80125b0:	4b55      	ldr	r3, [pc, #340]	; (8012708 <ResetMacParameters+0x1d0>)
 80125b2:	4956      	ldr	r1, [pc, #344]	; (801270c <ResetMacParameters+0x1d4>)
 80125b4:	585b      	ldr	r3, [r3, r1]
 80125b6:	2105      	movs	r1, #5
 80125b8:	5651      	ldrsb	r1, [r2, r1]
 80125ba:	22f9      	movs	r2, #249	; 0xf9
 80125bc:	5499      	strb	r1, [r3, r2]
    MacCtx.NvmCtx->MacParams.Rx1DrOffset = MacCtx.NvmCtx->MacParamsDefaults.Rx1DrOffset;
 80125be:	4b52      	ldr	r3, [pc, #328]	; (8012708 <ResetMacParameters+0x1d0>)
 80125c0:	4a52      	ldr	r2, [pc, #328]	; (801270c <ResetMacParameters+0x1d4>)
 80125c2:	589b      	ldr	r3, [r3, r2]
 80125c4:	4a50      	ldr	r2, [pc, #320]	; (8012708 <ResetMacParameters+0x1d0>)
 80125c6:	4951      	ldr	r1, [pc, #324]	; (801270c <ResetMacParameters+0x1d4>)
 80125c8:	5852      	ldr	r2, [r2, r1]
 80125ca:	2125      	movs	r1, #37	; 0x25
 80125cc:	5c59      	ldrb	r1, [r3, r1]
 80125ce:	231a      	movs	r3, #26
 80125d0:	33ff      	adds	r3, #255	; 0xff
 80125d2:	54d1      	strb	r1, [r2, r3]
    MacCtx.NvmCtx->MacParams.Rx2Channel = MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel;
 80125d4:	4b4c      	ldr	r3, [pc, #304]	; (8012708 <ResetMacParameters+0x1d0>)
 80125d6:	4a4d      	ldr	r2, [pc, #308]	; (801270c <ResetMacParameters+0x1d4>)
 80125d8:	589a      	ldr	r2, [r3, r2]
 80125da:	4b4b      	ldr	r3, [pc, #300]	; (8012708 <ResetMacParameters+0x1d0>)
 80125dc:	494b      	ldr	r1, [pc, #300]	; (801270c <ResetMacParameters+0x1d4>)
 80125de:	5859      	ldr	r1, [r3, r1]
 80125e0:	238e      	movs	r3, #142	; 0x8e
 80125e2:	005b      	lsls	r3, r3, #1
 80125e4:	18cb      	adds	r3, r1, r3
 80125e6:	3228      	adds	r2, #40	; 0x28
 80125e8:	ca03      	ldmia	r2!, {r0, r1}
 80125ea:	c303      	stmia	r3!, {r0, r1}
    MacCtx.NvmCtx->MacParams.RxCChannel = MacCtx.NvmCtx->MacParamsDefaults.RxCChannel;
 80125ec:	4b46      	ldr	r3, [pc, #280]	; (8012708 <ResetMacParameters+0x1d0>)
 80125ee:	4a47      	ldr	r2, [pc, #284]	; (801270c <ResetMacParameters+0x1d4>)
 80125f0:	589a      	ldr	r2, [r3, r2]
 80125f2:	4b45      	ldr	r3, [pc, #276]	; (8012708 <ResetMacParameters+0x1d0>)
 80125f4:	4945      	ldr	r1, [pc, #276]	; (801270c <ResetMacParameters+0x1d4>)
 80125f6:	5859      	ldr	r1, [r3, r1]
 80125f8:	2392      	movs	r3, #146	; 0x92
 80125fa:	005b      	lsls	r3, r3, #1
 80125fc:	18cb      	adds	r3, r1, r3
 80125fe:	3230      	adds	r2, #48	; 0x30
 8012600:	ca03      	ldmia	r2!, {r0, r1}
 8012602:	c303      	stmia	r3!, {r0, r1}
    MacCtx.NvmCtx->MacParams.UplinkDwellTime = MacCtx.NvmCtx->MacParamsDefaults.UplinkDwellTime;
 8012604:	4b40      	ldr	r3, [pc, #256]	; (8012708 <ResetMacParameters+0x1d0>)
 8012606:	4a41      	ldr	r2, [pc, #260]	; (801270c <ResetMacParameters+0x1d4>)
 8012608:	589b      	ldr	r3, [r3, r2]
 801260a:	4a3f      	ldr	r2, [pc, #252]	; (8012708 <ResetMacParameters+0x1d0>)
 801260c:	493f      	ldr	r1, [pc, #252]	; (801270c <ResetMacParameters+0x1d4>)
 801260e:	5852      	ldr	r2, [r2, r1]
 8012610:	2138      	movs	r1, #56	; 0x38
 8012612:	5c59      	ldrb	r1, [r3, r1]
 8012614:	2396      	movs	r3, #150	; 0x96
 8012616:	005b      	lsls	r3, r3, #1
 8012618:	54d1      	strb	r1, [r2, r3]
    MacCtx.NvmCtx->MacParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParamsDefaults.DownlinkDwellTime;
 801261a:	4b3b      	ldr	r3, [pc, #236]	; (8012708 <ResetMacParameters+0x1d0>)
 801261c:	4a3b      	ldr	r2, [pc, #236]	; (801270c <ResetMacParameters+0x1d4>)
 801261e:	589b      	ldr	r3, [r3, r2]
 8012620:	4a39      	ldr	r2, [pc, #228]	; (8012708 <ResetMacParameters+0x1d0>)
 8012622:	493a      	ldr	r1, [pc, #232]	; (801270c <ResetMacParameters+0x1d4>)
 8012624:	5852      	ldr	r2, [r2, r1]
 8012626:	2139      	movs	r1, #57	; 0x39
 8012628:	5c59      	ldrb	r1, [r3, r1]
 801262a:	232e      	movs	r3, #46	; 0x2e
 801262c:	33ff      	adds	r3, #255	; 0xff
 801262e:	54d1      	strb	r1, [r2, r3]
    MacCtx.NvmCtx->MacParams.MaxEirp = MacCtx.NvmCtx->MacParamsDefaults.MaxEirp;
 8012630:	4b35      	ldr	r3, [pc, #212]	; (8012708 <ResetMacParameters+0x1d0>)
 8012632:	4a36      	ldr	r2, [pc, #216]	; (801270c <ResetMacParameters+0x1d4>)
 8012634:	589b      	ldr	r3, [r3, r2]
 8012636:	4a34      	ldr	r2, [pc, #208]	; (8012708 <ResetMacParameters+0x1d0>)
 8012638:	4934      	ldr	r1, [pc, #208]	; (801270c <ResetMacParameters+0x1d4>)
 801263a:	5852      	ldr	r2, [r2, r1]
 801263c:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 801263e:	2398      	movs	r3, #152	; 0x98
 8012640:	005b      	lsls	r3, r3, #1
 8012642:	50d1      	str	r1, [r2, r3]
    MacCtx.NvmCtx->MacParams.AntennaGain = MacCtx.NvmCtx->MacParamsDefaults.AntennaGain;
 8012644:	4b30      	ldr	r3, [pc, #192]	; (8012708 <ResetMacParameters+0x1d0>)
 8012646:	4a31      	ldr	r2, [pc, #196]	; (801270c <ResetMacParameters+0x1d4>)
 8012648:	589b      	ldr	r3, [r3, r2]
 801264a:	4a2f      	ldr	r2, [pc, #188]	; (8012708 <ResetMacParameters+0x1d0>)
 801264c:	492f      	ldr	r1, [pc, #188]	; (801270c <ResetMacParameters+0x1d4>)
 801264e:	5852      	ldr	r2, [r2, r1]
 8012650:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8012652:	239a      	movs	r3, #154	; 0x9a
 8012654:	005b      	lsls	r3, r3, #1
 8012656:	50d1      	str	r1, [r2, r3]

    MacCtx.NodeAckRequested = false;
 8012658:	4b2b      	ldr	r3, [pc, #172]	; (8012708 <ResetMacParameters+0x1d0>)
 801265a:	4a30      	ldr	r2, [pc, #192]	; (801271c <ResetMacParameters+0x1e4>)
 801265c:	2100      	movs	r1, #0
 801265e:	5499      	strb	r1, [r3, r2]
    MacCtx.NvmCtx->SrvAckRequested = false;
 8012660:	4b29      	ldr	r3, [pc, #164]	; (8012708 <ResetMacParameters+0x1d0>)
 8012662:	4a2a      	ldr	r2, [pc, #168]	; (801270c <ResetMacParameters+0x1d4>)
 8012664:	589a      	ldr	r2, [r3, r2]
 8012666:	23e0      	movs	r3, #224	; 0xe0
 8012668:	005b      	lsls	r3, r3, #1
 801266a:	2100      	movs	r1, #0
 801266c:	54d1      	strb	r1, [r2, r3]

    // Reset to application defaults
    InitDefaultsParams_t params;
    params.Type = INIT_TYPE_RESTORE_DEFAULT_CHANNELS;
 801266e:	003b      	movs	r3, r7
 8012670:	2201      	movs	r2, #1
 8012672:	711a      	strb	r2, [r3, #4]
    params.NvmCtx = NULL;
 8012674:	003b      	movs	r3, r7
 8012676:	2200      	movs	r2, #0
 8012678:	601a      	str	r2, [r3, #0]
    RegionInitDefaults( MacCtx.NvmCtx->Region, &params );
 801267a:	4b23      	ldr	r3, [pc, #140]	; (8012708 <ResetMacParameters+0x1d0>)
 801267c:	4a23      	ldr	r2, [pc, #140]	; (801270c <ResetMacParameters+0x1d4>)
 801267e:	589b      	ldr	r3, [r3, r2]
 8012680:	781b      	ldrb	r3, [r3, #0]
 8012682:	003a      	movs	r2, r7
 8012684:	0011      	movs	r1, r2
 8012686:	0018      	movs	r0, r3
 8012688:	f004 ff85 	bl	8017596 <RegionInitDefaults>

    // Initialize channel index.
    MacCtx.Channel = 0;
 801268c:	4b1e      	ldr	r3, [pc, #120]	; (8012708 <ResetMacParameters+0x1d0>)
 801268e:	4a24      	ldr	r2, [pc, #144]	; (8012720 <ResetMacParameters+0x1e8>)
 8012690:	2100      	movs	r1, #0
 8012692:	5499      	strb	r1, [r3, r2]
    MacCtx.NvmCtx->LastTxChannel = MacCtx.Channel;
 8012694:	4b1c      	ldr	r3, [pc, #112]	; (8012708 <ResetMacParameters+0x1d0>)
 8012696:	4a1d      	ldr	r2, [pc, #116]	; (801270c <ResetMacParameters+0x1d4>)
 8012698:	589a      	ldr	r2, [r3, r2]
 801269a:	4b1b      	ldr	r3, [pc, #108]	; (8012708 <ResetMacParameters+0x1d0>)
 801269c:	4920      	ldr	r1, [pc, #128]	; (8012720 <ResetMacParameters+0x1e8>)
 801269e:	5c59      	ldrb	r1, [r3, r1]
 80126a0:	239f      	movs	r3, #159	; 0x9f
 80126a2:	005b      	lsls	r3, r3, #1
 80126a4:	54d1      	strb	r1, [r2, r3]

    // Initialize Rx2 config parameters.
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 80126a6:	4b18      	ldr	r3, [pc, #96]	; (8012708 <ResetMacParameters+0x1d0>)
 80126a8:	4a1d      	ldr	r2, [pc, #116]	; (8012720 <ResetMacParameters+0x1e8>)
 80126aa:	5c99      	ldrb	r1, [r3, r2]
 80126ac:	4a16      	ldr	r2, [pc, #88]	; (8012708 <ResetMacParameters+0x1d0>)
 80126ae:	23f3      	movs	r3, #243	; 0xf3
 80126b0:	009b      	lsls	r3, r3, #2
 80126b2:	54d1      	strb	r1, [r2, r3]
    MacCtx.RxWindow2Config.Frequency = MacCtx.NvmCtx->MacParams.Rx2Channel.Frequency;
 80126b4:	4b14      	ldr	r3, [pc, #80]	; (8012708 <ResetMacParameters+0x1d0>)
 80126b6:	4a15      	ldr	r2, [pc, #84]	; (801270c <ResetMacParameters+0x1d4>)
 80126b8:	589a      	ldr	r2, [r3, r2]
 80126ba:	238e      	movs	r3, #142	; 0x8e
 80126bc:	005b      	lsls	r3, r3, #1
 80126be:	58d1      	ldr	r1, [r2, r3]
 80126c0:	4a11      	ldr	r2, [pc, #68]	; (8012708 <ResetMacParameters+0x1d0>)
 80126c2:	23f4      	movs	r3, #244	; 0xf4
 80126c4:	009b      	lsls	r3, r3, #2
 80126c6:	50d1      	str	r1, [r2, r3]
    MacCtx.RxWindow2Config.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;
 80126c8:	4b0f      	ldr	r3, [pc, #60]	; (8012708 <ResetMacParameters+0x1d0>)
 80126ca:	4a10      	ldr	r2, [pc, #64]	; (801270c <ResetMacParameters+0x1d4>)
 80126cc:	589a      	ldr	r2, [r3, r2]
 80126ce:	232e      	movs	r3, #46	; 0x2e
 80126d0:	33ff      	adds	r3, #255	; 0xff
 80126d2:	5cd1      	ldrb	r1, [r2, r3]
 80126d4:	4a0c      	ldr	r2, [pc, #48]	; (8012708 <ResetMacParameters+0x1d0>)
 80126d6:	23f7      	movs	r3, #247	; 0xf7
 80126d8:	009b      	lsls	r3, r3, #2
 80126da:	54d1      	strb	r1, [r2, r3]
    MacCtx.RxWindow2Config.RepeaterSupport = MacCtx.NvmCtx->RepeaterSupport;
 80126dc:	4b0a      	ldr	r3, [pc, #40]	; (8012708 <ResetMacParameters+0x1d0>)
 80126de:	4a0b      	ldr	r2, [pc, #44]	; (801270c <ResetMacParameters+0x1d4>)
 80126e0:	589a      	ldr	r2, [r3, r2]
 80126e2:	2340      	movs	r3, #64	; 0x40
 80126e4:	33ff      	adds	r3, #255	; 0xff
 80126e6:	5cd1      	ldrb	r1, [r2, r3]
 80126e8:	4b07      	ldr	r3, [pc, #28]	; (8012708 <ResetMacParameters+0x1d0>)
 80126ea:	4a0e      	ldr	r2, [pc, #56]	; (8012724 <ResetMacParameters+0x1ec>)
 80126ec:	5499      	strb	r1, [r3, r2]
    MacCtx.RxWindow2Config.RxContinuous = false;
 80126ee:	4b06      	ldr	r3, [pc, #24]	; (8012708 <ResetMacParameters+0x1d0>)
 80126f0:	4a0d      	ldr	r2, [pc, #52]	; (8012728 <ResetMacParameters+0x1f0>)
 80126f2:	2100      	movs	r1, #0
 80126f4:	5499      	strb	r1, [r3, r2]
    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;
 80126f6:	4b04      	ldr	r3, [pc, #16]	; (8012708 <ResetMacParameters+0x1d0>)
 80126f8:	4a0c      	ldr	r2, [pc, #48]	; (801272c <ResetMacParameters+0x1f4>)
 80126fa:	2101      	movs	r1, #1
 80126fc:	5499      	strb	r1, [r3, r2]
}
 80126fe:	46c0      	nop			; (mov r8, r8)
 8012700:	46bd      	mov	sp, r7
 8012702:	b002      	add	sp, #8
 8012704:	bd80      	pop	{r7, pc}
 8012706:	46c0      	nop			; (mov r8, r8)
 8012708:	200008ec 	.word	0x200008ec
 801270c:	00000484 	.word	0x00000484
 8012710:	00000411 	.word	0x00000411
 8012714:	00000412 	.word	0x00000412
 8012718:	00000413 	.word	0x00000413
 801271c:	00000414 	.word	0x00000414
 8012720:	00000415 	.word	0x00000415
 8012724:	000003dd 	.word	0x000003dd
 8012728:	000003de 	.word	0x000003de
 801272c:	000003df 	.word	0x000003df

08012730 <RxWindowSetup>:
 *
 * \param [IN] rxTimer  Window timer to be topped.
 * \param [IN] rxConfig Window parameters to be setup
 */
static void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )
{
 8012730:	b580      	push	{r7, lr}
 8012732:	b082      	sub	sp, #8
 8012734:	af00      	add	r7, sp, #0
 8012736:	6078      	str	r0, [r7, #4]
 8012738:	6039      	str	r1, [r7, #0]
    TimerStop( rxTimer );
 801273a:	687b      	ldr	r3, [r7, #4]
 801273c:	0018      	movs	r0, r3
 801273e:	f008 fc7d 	bl	801b03c <TimerStop>

    // Ensure the radio is Idle
    Radio.Standby( );
 8012742:	4b11      	ldr	r3, [pc, #68]	; (8012788 <RxWindowSetup+0x58>)
 8012744:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012746:	4798      	blx	r3

    if( RegionRxConfig( MacCtx.NvmCtx->Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 8012748:	4b10      	ldr	r3, [pc, #64]	; (801278c <RxWindowSetup+0x5c>)
 801274a:	4a11      	ldr	r2, [pc, #68]	; (8012790 <RxWindowSetup+0x60>)
 801274c:	589b      	ldr	r3, [r3, r2]
 801274e:	781b      	ldrb	r3, [r3, #0]
 8012750:	4a10      	ldr	r2, [pc, #64]	; (8012794 <RxWindowSetup+0x64>)
 8012752:	6839      	ldr	r1, [r7, #0]
 8012754:	0018      	movs	r0, r3
 8012756:	f004 ffb5 	bl	80176c4 <RegionRxConfig>
 801275a:	1e03      	subs	r3, r0, #0
 801275c:	d00f      	beq.n	801277e <RxWindowSetup+0x4e>
    {
        Radio.Rx( MacCtx.NvmCtx->MacParams.MaxRxWindow );
 801275e:	4b0a      	ldr	r3, [pc, #40]	; (8012788 <RxWindowSetup+0x58>)
 8012760:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012762:	4a0a      	ldr	r2, [pc, #40]	; (801278c <RxWindowSetup+0x5c>)
 8012764:	490a      	ldr	r1, [pc, #40]	; (8012790 <RxWindowSetup+0x60>)
 8012766:	5851      	ldr	r1, [r2, r1]
 8012768:	2282      	movs	r2, #130	; 0x82
 801276a:	0052      	lsls	r2, r2, #1
 801276c:	588a      	ldr	r2, [r1, r2]
 801276e:	0010      	movs	r0, r2
 8012770:	4798      	blx	r3
        MacCtx.RxSlot = rxConfig->RxSlot;
 8012772:	683b      	ldr	r3, [r7, #0]
 8012774:	7cd9      	ldrb	r1, [r3, #19]
 8012776:	4a05      	ldr	r2, [pc, #20]	; (801278c <RxWindowSetup+0x5c>)
 8012778:	2390      	movs	r3, #144	; 0x90
 801277a:	00db      	lsls	r3, r3, #3
 801277c:	54d1      	strb	r1, [r2, r3]
    }
}
 801277e:	46c0      	nop			; (mov r8, r8)
 8012780:	46bd      	mov	sp, r7
 8012782:	b002      	add	sp, #8
 8012784:	bd80      	pop	{r7, pc}
 8012786:	46c0      	nop			; (mov r8, r8)
 8012788:	0801ebd0 	.word	0x0801ebd0
 801278c:	200008ec 	.word	0x200008ec
 8012790:	00000484 	.word	0x00000484
 8012794:	20000d0c 	.word	0x20000d0c

08012798 <OpenContinuousRxCWindow>:

static void OpenContinuousRxCWindow( void )
{
 8012798:	b580      	push	{r7, lr}
 801279a:	af00      	add	r7, sp, #0
    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 801279c:	4b10      	ldr	r3, [pc, #64]	; (80127e0 <OpenContinuousRxCWindow+0x48>)
 801279e:	4a11      	ldr	r2, [pc, #68]	; (80127e4 <OpenContinuousRxCWindow+0x4c>)
 80127a0:	2102      	movs	r1, #2
 80127a2:	5499      	strb	r1, [r3, r2]
    // Setup continuous listening
    MacCtx.RxWindowCConfig.RxContinuous = true;
 80127a4:	4b0e      	ldr	r3, [pc, #56]	; (80127e0 <OpenContinuousRxCWindow+0x48>)
 80127a6:	4a10      	ldr	r2, [pc, #64]	; (80127e8 <OpenContinuousRxCWindow+0x50>)
 80127a8:	2101      	movs	r1, #1
 80127aa:	5499      	strb	r1, [r3, r2]

    // At this point the Radio should be idle.
    // Thus, there is no need to set the radio in standby mode.
    if( RegionRxConfig( MacCtx.NvmCtx->Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 80127ac:	4b0c      	ldr	r3, [pc, #48]	; (80127e0 <OpenContinuousRxCWindow+0x48>)
 80127ae:	4a0f      	ldr	r2, [pc, #60]	; (80127ec <OpenContinuousRxCWindow+0x54>)
 80127b0:	589b      	ldr	r3, [r3, r2]
 80127b2:	781b      	ldrb	r3, [r3, #0]
 80127b4:	4a0e      	ldr	r2, [pc, #56]	; (80127f0 <OpenContinuousRxCWindow+0x58>)
 80127b6:	490f      	ldr	r1, [pc, #60]	; (80127f4 <OpenContinuousRxCWindow+0x5c>)
 80127b8:	0018      	movs	r0, r3
 80127ba:	f004 ff83 	bl	80176c4 <RegionRxConfig>
 80127be:	1e03      	subs	r3, r0, #0
 80127c0:	d00a      	beq.n	80127d8 <OpenContinuousRxCWindow+0x40>
    {
        Radio.Rx( 0 ); // Continuous mode
 80127c2:	4b0d      	ldr	r3, [pc, #52]	; (80127f8 <OpenContinuousRxCWindow+0x60>)
 80127c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80127c6:	2000      	movs	r0, #0
 80127c8:	4798      	blx	r3
        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;
 80127ca:	4b05      	ldr	r3, [pc, #20]	; (80127e0 <OpenContinuousRxCWindow+0x48>)
 80127cc:	4a05      	ldr	r2, [pc, #20]	; (80127e4 <OpenContinuousRxCWindow+0x4c>)
 80127ce:	5c99      	ldrb	r1, [r3, r2]
 80127d0:	4a03      	ldr	r2, [pc, #12]	; (80127e0 <OpenContinuousRxCWindow+0x48>)
 80127d2:	2390      	movs	r3, #144	; 0x90
 80127d4:	00db      	lsls	r3, r3, #3
 80127d6:	54d1      	strb	r1, [r2, r3]
    }
}
 80127d8:	46c0      	nop			; (mov r8, r8)
 80127da:	46bd      	mov	sp, r7
 80127dc:	bd80      	pop	{r7, pc}
 80127de:	46c0      	nop			; (mov r8, r8)
 80127e0:	200008ec 	.word	0x200008ec
 80127e4:	000003f3 	.word	0x000003f3
 80127e8:	000003f2 	.word	0x000003f2
 80127ec:	00000484 	.word	0x00000484
 80127f0:	20000d0c 	.word	0x20000d0c
 80127f4:	20000ccc 	.word	0x20000ccc
 80127f8:	0801ebd0 	.word	0x0801ebd0

080127fc <PrepareFrame>:

LoRaMacStatus_t PrepareFrame( LoRaMacHeader_t* macHdr, LoRaMacFrameCtrl_t* fCtrl, uint8_t fPort, void* fBuffer, uint16_t fBufferSize )
{
 80127fc:	b590      	push	{r4, r7, lr}
 80127fe:	b089      	sub	sp, #36	; 0x24
 8012800:	af00      	add	r7, sp, #0
 8012802:	60f8      	str	r0, [r7, #12]
 8012804:	60b9      	str	r1, [r7, #8]
 8012806:	603b      	str	r3, [r7, #0]
 8012808:	1dfb      	adds	r3, r7, #7
 801280a:	701a      	strb	r2, [r3, #0]
    MacCtx.PktBufferLen = 0;
 801280c:	4b9b      	ldr	r3, [pc, #620]	; (8012a7c <PrepareFrame+0x280>)
 801280e:	2200      	movs	r2, #0
 8012810:	801a      	strh	r2, [r3, #0]
    MacCtx.NodeAckRequested = false;
 8012812:	4b9a      	ldr	r3, [pc, #616]	; (8012a7c <PrepareFrame+0x280>)
 8012814:	4a9a      	ldr	r2, [pc, #616]	; (8012a80 <PrepareFrame+0x284>)
 8012816:	2100      	movs	r1, #0
 8012818:	5499      	strb	r1, [r3, r2]
    uint32_t fCntUp = 0;
 801281a:	2300      	movs	r3, #0
 801281c:	61bb      	str	r3, [r7, #24]
    size_t macCmdsSize = 0;
 801281e:	2300      	movs	r3, #0
 8012820:	617b      	str	r3, [r7, #20]
    uint8_t availableSize = 0;
 8012822:	231f      	movs	r3, #31
 8012824:	18fb      	adds	r3, r7, r3
 8012826:	2200      	movs	r2, #0
 8012828:	701a      	strb	r2, [r3, #0]

    if( fBuffer == NULL )
 801282a:	683b      	ldr	r3, [r7, #0]
 801282c:	2b00      	cmp	r3, #0
 801282e:	d103      	bne.n	8012838 <PrepareFrame+0x3c>
    {
        fBufferSize = 0;
 8012830:	2330      	movs	r3, #48	; 0x30
 8012832:	18fb      	adds	r3, r7, r3
 8012834:	2200      	movs	r2, #0
 8012836:	801a      	strh	r2, [r3, #0]
    }

    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 8012838:	2430      	movs	r4, #48	; 0x30
 801283a:	193b      	adds	r3, r7, r4
 801283c:	881a      	ldrh	r2, [r3, #0]
 801283e:	6839      	ldr	r1, [r7, #0]
 8012840:	4b90      	ldr	r3, [pc, #576]	; (8012a84 <PrepareFrame+0x288>)
 8012842:	0018      	movs	r0, r3
 8012844:	f008 fe80 	bl	801b548 <memcpy1>
    MacCtx.AppDataSize = fBufferSize;
 8012848:	193b      	adds	r3, r7, r4
 801284a:	881b      	ldrh	r3, [r3, #0]
 801284c:	b2d9      	uxtb	r1, r3
 801284e:	4b8b      	ldr	r3, [pc, #556]	; (8012a7c <PrepareFrame+0x280>)
 8012850:	4a8d      	ldr	r2, [pc, #564]	; (8012a88 <PrepareFrame+0x28c>)
 8012852:	5499      	strb	r1, [r3, r2]
    MacCtx.PktBuffer[0] = macHdr->Value;
 8012854:	68fb      	ldr	r3, [r7, #12]
 8012856:	781a      	ldrb	r2, [r3, #0]
 8012858:	4b88      	ldr	r3, [pc, #544]	; (8012a7c <PrepareFrame+0x280>)
 801285a:	709a      	strb	r2, [r3, #2]

    switch( macHdr->Bits.MType )
 801285c:	68fb      	ldr	r3, [r7, #12]
 801285e:	781b      	ldrb	r3, [r3, #0]
 8012860:	061b      	lsls	r3, r3, #24
 8012862:	0f5b      	lsrs	r3, r3, #29
 8012864:	b2db      	uxtb	r3, r3
 8012866:	2b07      	cmp	r3, #7
 8012868:	d100      	bne.n	801286c <PrepareFrame+0x70>
 801286a:	e0e3      	b.n	8012a34 <PrepareFrame+0x238>
 801286c:	dd00      	ble.n	8012870 <PrepareFrame+0x74>
 801286e:	e0fb      	b.n	8012a68 <PrepareFrame+0x26c>
 8012870:	2b02      	cmp	r3, #2
 8012872:	d006      	beq.n	8012882 <PrepareFrame+0x86>
 8012874:	2b04      	cmp	r3, #4
 8012876:	d000      	beq.n	801287a <PrepareFrame+0x7e>
 8012878:	e0f6      	b.n	8012a68 <PrepareFrame+0x26c>
    {
        case FRAME_TYPE_DATA_CONFIRMED_UP:
            MacCtx.NodeAckRequested = true;
 801287a:	4b80      	ldr	r3, [pc, #512]	; (8012a7c <PrepareFrame+0x280>)
 801287c:	4a80      	ldr	r2, [pc, #512]	; (8012a80 <PrepareFrame+0x284>)
 801287e:	2101      	movs	r1, #1
 8012880:	5499      	strb	r1, [r3, r2]
            // Intentional fall through
        case FRAME_TYPE_DATA_UNCONFIRMED_UP:
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 8012882:	4a7e      	ldr	r2, [pc, #504]	; (8012a7c <PrepareFrame+0x280>)
 8012884:	2382      	movs	r3, #130	; 0x82
 8012886:	005b      	lsls	r3, r3, #1
 8012888:	2104      	movs	r1, #4
 801288a:	54d1      	strb	r1, [r2, r3]
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 801288c:	4a7b      	ldr	r2, [pc, #492]	; (8012a7c <PrepareFrame+0x280>)
 801288e:	2384      	movs	r3, #132	; 0x84
 8012890:	005b      	lsls	r3, r3, #1
 8012892:	497e      	ldr	r1, [pc, #504]	; (8012a8c <PrepareFrame+0x290>)
 8012894:	50d1      	str	r1, [r2, r3]
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 8012896:	4a79      	ldr	r2, [pc, #484]	; (8012a7c <PrepareFrame+0x280>)
 8012898:	2386      	movs	r3, #134	; 0x86
 801289a:	005b      	lsls	r3, r3, #1
 801289c:	21ff      	movs	r1, #255	; 0xff
 801289e:	54d1      	strb	r1, [r2, r3]
            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;
 80128a0:	68fb      	ldr	r3, [r7, #12]
 80128a2:	7819      	ldrb	r1, [r3, #0]
 80128a4:	4a75      	ldr	r2, [pc, #468]	; (8012a7c <PrepareFrame+0x280>)
 80128a6:	230e      	movs	r3, #14
 80128a8:	33ff      	adds	r3, #255	; 0xff
 80128aa:	54d1      	strb	r1, [r2, r3]
            MacCtx.TxMsg.Message.Data.FPort = fPort;
 80128ac:	4a73      	ldr	r2, [pc, #460]	; (8012a7c <PrepareFrame+0x280>)
 80128ae:	1df9      	adds	r1, r7, #7
 80128b0:	2394      	movs	r3, #148	; 0x94
 80128b2:	005b      	lsls	r3, r3, #1
 80128b4:	7809      	ldrb	r1, [r1, #0]
 80128b6:	54d1      	strb	r1, [r2, r3]
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = MacCtx.NvmCtx->DevAddr;
 80128b8:	4b70      	ldr	r3, [pc, #448]	; (8012a7c <PrepareFrame+0x280>)
 80128ba:	4a75      	ldr	r2, [pc, #468]	; (8012a90 <PrepareFrame+0x294>)
 80128bc:	589b      	ldr	r3, [r3, r2]
 80128be:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 80128c0:	4a6e      	ldr	r2, [pc, #440]	; (8012a7c <PrepareFrame+0x280>)
 80128c2:	2388      	movs	r3, #136	; 0x88
 80128c4:	005b      	lsls	r3, r3, #1
 80128c6:	50d1      	str	r1, [r2, r3]
            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 80128c8:	68bb      	ldr	r3, [r7, #8]
 80128ca:	7819      	ldrb	r1, [r3, #0]
 80128cc:	4a6b      	ldr	r2, [pc, #428]	; (8012a7c <PrepareFrame+0x280>)
 80128ce:	238a      	movs	r3, #138	; 0x8a
 80128d0:	005b      	lsls	r3, r3, #1
 80128d2:	54d1      	strb	r1, [r2, r3]
            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;
 80128d4:	4b69      	ldr	r3, [pc, #420]	; (8012a7c <PrepareFrame+0x280>)
 80128d6:	4a6c      	ldr	r2, [pc, #432]	; (8012a88 <PrepareFrame+0x28c>)
 80128d8:	5c99      	ldrb	r1, [r3, r2]
 80128da:	4a68      	ldr	r2, [pc, #416]	; (8012a7c <PrepareFrame+0x280>)
 80128dc:	2398      	movs	r3, #152	; 0x98
 80128de:	005b      	lsls	r3, r3, #1
 80128e0:	54d1      	strb	r1, [r2, r3]
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 80128e2:	4a66      	ldr	r2, [pc, #408]	; (8012a7c <PrepareFrame+0x280>)
 80128e4:	2396      	movs	r3, #150	; 0x96
 80128e6:	005b      	lsls	r3, r3, #1
 80128e8:	4966      	ldr	r1, [pc, #408]	; (8012a84 <PrepareFrame+0x288>)
 80128ea:	50d1      	str	r1, [r2, r3]

            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 80128ec:	2318      	movs	r3, #24
 80128ee:	18fb      	adds	r3, r7, r3
 80128f0:	0018      	movs	r0, r3
 80128f2:	f003 fd43 	bl	801637c <LoRaMacCryptoGetFCntUp>
 80128f6:	1e03      	subs	r3, r0, #0
 80128f8:	d001      	beq.n	80128fe <PrepareFrame+0x102>
            {
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 80128fa:	2312      	movs	r3, #18
 80128fc:	e0ba      	b.n	8012a74 <PrepareFrame+0x278>
            }
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 80128fe:	69bb      	ldr	r3, [r7, #24]
 8012900:	b299      	uxth	r1, r3
 8012902:	4a5e      	ldr	r2, [pc, #376]	; (8012a7c <PrepareFrame+0x280>)
 8012904:	238b      	movs	r3, #139	; 0x8b
 8012906:	005b      	lsls	r3, r3, #1
 8012908:	52d1      	strh	r1, [r2, r3]

            // Reset confirm parameters
            MacCtx.McpsConfirm.NbRetries = 0;
 801290a:	4b5c      	ldr	r3, [pc, #368]	; (8012a7c <PrepareFrame+0x280>)
 801290c:	4a61      	ldr	r2, [pc, #388]	; (8012a94 <PrepareFrame+0x298>)
 801290e:	2100      	movs	r1, #0
 8012910:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsConfirm.AckReceived = false;
 8012912:	4a5a      	ldr	r2, [pc, #360]	; (8012a7c <PrepareFrame+0x280>)
 8012914:	2388      	movs	r3, #136	; 0x88
 8012916:	00db      	lsls	r3, r3, #3
 8012918:	2100      	movs	r1, #0
 801291a:	54d1      	strb	r1, [r2, r3]
            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;
 801291c:	69b9      	ldr	r1, [r7, #24]
 801291e:	4a57      	ldr	r2, [pc, #348]	; (8012a7c <PrepareFrame+0x280>)
 8012920:	2389      	movs	r3, #137	; 0x89
 8012922:	00db      	lsls	r3, r3, #3
 8012924:	50d1      	str	r1, [r2, r3]

            // Handle the MAC commands if there are any available
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8012926:	2314      	movs	r3, #20
 8012928:	18fb      	adds	r3, r7, r3
 801292a:	0018      	movs	r0, r3
 801292c:	f002 fe52 	bl	80155d4 <LoRaMacCommandsGetSizeSerializedCmds>
 8012930:	1e03      	subs	r3, r0, #0
 8012932:	d001      	beq.n	8012938 <PrepareFrame+0x13c>
            {
                return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8012934:	2313      	movs	r3, #19
 8012936:	e09d      	b.n	8012a74 <PrepareFrame+0x278>
            }

            if( macCmdsSize > 0 )
 8012938:	697b      	ldr	r3, [r7, #20]
 801293a:	2b00      	cmp	r3, #0
 801293c:	d100      	bne.n	8012940 <PrepareFrame+0x144>
 801293e:	e095      	b.n	8012a6c <PrepareFrame+0x270>
            {
                availableSize = GetMaxAppPayloadWithoutFOptsLength( MacCtx.NvmCtx->MacParams.ChannelsDatarate );
 8012940:	4b4e      	ldr	r3, [pc, #312]	; (8012a7c <PrepareFrame+0x280>)
 8012942:	4a53      	ldr	r2, [pc, #332]	; (8012a90 <PrepareFrame+0x294>)
 8012944:	589b      	ldr	r3, [r3, r2]
 8012946:	22f9      	movs	r2, #249	; 0xf9
 8012948:	569b      	ldrsb	r3, [r3, r2]
 801294a:	221f      	movs	r2, #31
 801294c:	18bc      	adds	r4, r7, r2
 801294e:	0018      	movs	r0, r3
 8012950:	f7fe fbfc 	bl	801114c <GetMaxAppPayloadWithoutFOptsLength>
 8012954:	0003      	movs	r3, r0
 8012956:	7023      	strb	r3, [r4, #0]

                // There is application payload available and the MAC commands fit into FOpts field.
                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 8012958:	4b48      	ldr	r3, [pc, #288]	; (8012a7c <PrepareFrame+0x280>)
 801295a:	4a4b      	ldr	r2, [pc, #300]	; (8012a88 <PrepareFrame+0x28c>)
 801295c:	5c9b      	ldrb	r3, [r3, r2]
 801295e:	2b00      	cmp	r3, #0
 8012960:	d024      	beq.n	80129ac <PrepareFrame+0x1b0>
 8012962:	697b      	ldr	r3, [r7, #20]
 8012964:	2b0f      	cmp	r3, #15
 8012966:	d821      	bhi.n	80129ac <PrepareFrame+0x1b0>
                {
                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )
 8012968:	4a4b      	ldr	r2, [pc, #300]	; (8012a98 <PrepareFrame+0x29c>)
 801296a:	2314      	movs	r3, #20
 801296c:	18fb      	adds	r3, r7, r3
 801296e:	0019      	movs	r1, r3
 8012970:	200f      	movs	r0, #15
 8012972:	f002 fe45 	bl	8015600 <LoRaMacCommandsSerializeCmds>
 8012976:	1e03      	subs	r3, r0, #0
 8012978:	d001      	beq.n	801297e <PrepareFrame+0x182>
                    {
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 801297a:	2313      	movs	r3, #19
 801297c:	e07a      	b.n	8012a74 <PrepareFrame+0x278>
                    }
                    fCtrl->Bits.FOptsLen = macCmdsSize;
 801297e:	697b      	ldr	r3, [r7, #20]
 8012980:	1c1a      	adds	r2, r3, #0
 8012982:	230f      	movs	r3, #15
 8012984:	4013      	ands	r3, r2
 8012986:	b2da      	uxtb	r2, r3
 8012988:	68bb      	ldr	r3, [r7, #8]
 801298a:	210f      	movs	r1, #15
 801298c:	400a      	ands	r2, r1
 801298e:	0010      	movs	r0, r2
 8012990:	781a      	ldrb	r2, [r3, #0]
 8012992:	210f      	movs	r1, #15
 8012994:	438a      	bics	r2, r1
 8012996:	1c11      	adds	r1, r2, #0
 8012998:	1c02      	adds	r2, r0, #0
 801299a:	430a      	orrs	r2, r1
 801299c:	701a      	strb	r2, [r3, #0]
                    // Update FCtrl field with new value of FOptionsLength
                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 801299e:	68bb      	ldr	r3, [r7, #8]
 80129a0:	7819      	ldrb	r1, [r3, #0]
 80129a2:	4a36      	ldr	r2, [pc, #216]	; (8012a7c <PrepareFrame+0x280>)
 80129a4:	238a      	movs	r3, #138	; 0x8a
 80129a6:	005b      	lsls	r3, r3, #1
 80129a8:	54d1      	strb	r1, [r2, r3]
                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.NvmCtx->MacCommandsBuffer;
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
                }
            }

            break;
 80129aa:	e05f      	b.n	8012a6c <PrepareFrame+0x270>
                else if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize > LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 80129ac:	4b33      	ldr	r3, [pc, #204]	; (8012a7c <PrepareFrame+0x280>)
 80129ae:	4a36      	ldr	r2, [pc, #216]	; (8012a88 <PrepareFrame+0x28c>)
 80129b0:	5c9b      	ldrb	r3, [r3, r2]
 80129b2:	2b00      	cmp	r3, #0
 80129b4:	d016      	beq.n	80129e4 <PrepareFrame+0x1e8>
 80129b6:	697b      	ldr	r3, [r7, #20]
 80129b8:	2b0f      	cmp	r3, #15
 80129ba:	d913      	bls.n	80129e4 <PrepareFrame+0x1e8>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.NvmCtx->MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 80129bc:	231f      	movs	r3, #31
 80129be:	18fb      	adds	r3, r7, r3
 80129c0:	7818      	ldrb	r0, [r3, #0]
 80129c2:	4b2e      	ldr	r3, [pc, #184]	; (8012a7c <PrepareFrame+0x280>)
 80129c4:	4a32      	ldr	r2, [pc, #200]	; (8012a90 <PrepareFrame+0x294>)
 80129c6:	589b      	ldr	r3, [r3, r2]
 80129c8:	3341      	adds	r3, #65	; 0x41
 80129ca:	33ff      	adds	r3, #255	; 0xff
 80129cc:	001a      	movs	r2, r3
 80129ce:	2314      	movs	r3, #20
 80129d0:	18fb      	adds	r3, r7, r3
 80129d2:	0019      	movs	r1, r3
 80129d4:	f002 fe14 	bl	8015600 <LoRaMacCommandsSerializeCmds>
 80129d8:	1e03      	subs	r3, r0, #0
 80129da:	d001      	beq.n	80129e0 <PrepareFrame+0x1e4>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80129dc:	2313      	movs	r3, #19
 80129de:	e049      	b.n	8012a74 <PrepareFrame+0x278>
                    return LORAMAC_STATUS_SKIPPED_APP_DATA;
 80129e0:	230a      	movs	r3, #10
 80129e2:	e047      	b.n	8012a74 <PrepareFrame+0x278>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.NvmCtx->MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 80129e4:	231f      	movs	r3, #31
 80129e6:	18fb      	adds	r3, r7, r3
 80129e8:	7818      	ldrb	r0, [r3, #0]
 80129ea:	4b24      	ldr	r3, [pc, #144]	; (8012a7c <PrepareFrame+0x280>)
 80129ec:	4a28      	ldr	r2, [pc, #160]	; (8012a90 <PrepareFrame+0x294>)
 80129ee:	589b      	ldr	r3, [r3, r2]
 80129f0:	3341      	adds	r3, #65	; 0x41
 80129f2:	33ff      	adds	r3, #255	; 0xff
 80129f4:	001a      	movs	r2, r3
 80129f6:	2314      	movs	r3, #20
 80129f8:	18fb      	adds	r3, r7, r3
 80129fa:	0019      	movs	r1, r3
 80129fc:	f002 fe00 	bl	8015600 <LoRaMacCommandsSerializeCmds>
 8012a00:	1e03      	subs	r3, r0, #0
 8012a02:	d001      	beq.n	8012a08 <PrepareFrame+0x20c>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8012a04:	2313      	movs	r3, #19
 8012a06:	e035      	b.n	8012a74 <PrepareFrame+0x278>
                    MacCtx.TxMsg.Message.Data.FPort = 0;
 8012a08:	4a1c      	ldr	r2, [pc, #112]	; (8012a7c <PrepareFrame+0x280>)
 8012a0a:	2394      	movs	r3, #148	; 0x94
 8012a0c:	005b      	lsls	r3, r3, #1
 8012a0e:	2100      	movs	r1, #0
 8012a10:	54d1      	strb	r1, [r2, r3]
                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.NvmCtx->MacCommandsBuffer;
 8012a12:	4b1a      	ldr	r3, [pc, #104]	; (8012a7c <PrepareFrame+0x280>)
 8012a14:	4a1e      	ldr	r2, [pc, #120]	; (8012a90 <PrepareFrame+0x294>)
 8012a16:	589b      	ldr	r3, [r3, r2]
 8012a18:	3341      	adds	r3, #65	; 0x41
 8012a1a:	33ff      	adds	r3, #255	; 0xff
 8012a1c:	0019      	movs	r1, r3
 8012a1e:	4a17      	ldr	r2, [pc, #92]	; (8012a7c <PrepareFrame+0x280>)
 8012a20:	2396      	movs	r3, #150	; 0x96
 8012a22:	005b      	lsls	r3, r3, #1
 8012a24:	50d1      	str	r1, [r2, r3]
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 8012a26:	697b      	ldr	r3, [r7, #20]
 8012a28:	b2d9      	uxtb	r1, r3
 8012a2a:	4a14      	ldr	r2, [pc, #80]	; (8012a7c <PrepareFrame+0x280>)
 8012a2c:	2398      	movs	r3, #152	; 0x98
 8012a2e:	005b      	lsls	r3, r3, #1
 8012a30:	54d1      	strb	r1, [r2, r3]
            break;
 8012a32:	e01b      	b.n	8012a6c <PrepareFrame+0x270>
        case FRAME_TYPE_PROPRIETARY:
            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )
 8012a34:	683b      	ldr	r3, [r7, #0]
 8012a36:	2b00      	cmp	r3, #0
 8012a38:	d01a      	beq.n	8012a70 <PrepareFrame+0x274>
 8012a3a:	4b10      	ldr	r3, [pc, #64]	; (8012a7c <PrepareFrame+0x280>)
 8012a3c:	4a12      	ldr	r2, [pc, #72]	; (8012a88 <PrepareFrame+0x28c>)
 8012a3e:	5c9b      	ldrb	r3, [r3, r2]
 8012a40:	2b00      	cmp	r3, #0
 8012a42:	d015      	beq.n	8012a70 <PrepareFrame+0x274>
            {
                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );
 8012a44:	4815      	ldr	r0, [pc, #84]	; (8012a9c <PrepareFrame+0x2a0>)
 8012a46:	4b0d      	ldr	r3, [pc, #52]	; (8012a7c <PrepareFrame+0x280>)
 8012a48:	4a0f      	ldr	r2, [pc, #60]	; (8012a88 <PrepareFrame+0x28c>)
 8012a4a:	5c9b      	ldrb	r3, [r3, r2]
 8012a4c:	b29a      	uxth	r2, r3
 8012a4e:	683b      	ldr	r3, [r7, #0]
 8012a50:	0019      	movs	r1, r3
 8012a52:	f008 fd79 	bl	801b548 <memcpy1>
                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;
 8012a56:	4b09      	ldr	r3, [pc, #36]	; (8012a7c <PrepareFrame+0x280>)
 8012a58:	4a0b      	ldr	r2, [pc, #44]	; (8012a88 <PrepareFrame+0x28c>)
 8012a5a:	5c9b      	ldrb	r3, [r3, r2]
 8012a5c:	b29b      	uxth	r3, r3
 8012a5e:	3301      	adds	r3, #1
 8012a60:	b29a      	uxth	r2, r3
 8012a62:	4b06      	ldr	r3, [pc, #24]	; (8012a7c <PrepareFrame+0x280>)
 8012a64:	801a      	strh	r2, [r3, #0]
            }
            break;
 8012a66:	e003      	b.n	8012a70 <PrepareFrame+0x274>
        default:
            return LORAMAC_STATUS_SERVICE_UNKNOWN;
 8012a68:	2302      	movs	r3, #2
 8012a6a:	e003      	b.n	8012a74 <PrepareFrame+0x278>
            break;
 8012a6c:	46c0      	nop			; (mov r8, r8)
 8012a6e:	e000      	b.n	8012a72 <PrepareFrame+0x276>
            break;
 8012a70:	46c0      	nop			; (mov r8, r8)
    }

    return LORAMAC_STATUS_OK;
 8012a72:	2300      	movs	r3, #0
}
 8012a74:	0018      	movs	r0, r3
 8012a76:	46bd      	mov	sp, r7
 8012a78:	b009      	add	sp, #36	; 0x24
 8012a7a:	bd90      	pop	{r4, r7, pc}
 8012a7c:	200008ec 	.word	0x200008ec
 8012a80:	00000414 	.word	0x00000414
 8012a84:	20000a24 	.word	0x20000a24
 8012a88:	00000237 	.word	0x00000237
 8012a8c:	200008ee 	.word	0x200008ee
 8012a90:	00000484 	.word	0x00000484
 8012a94:	00000441 	.word	0x00000441
 8012a98:	20000a04 	.word	0x20000a04
 8012a9c:	200008ef 	.word	0x200008ef

08012aa0 <SendFrameOnChannel>:

LoRaMacStatus_t SendFrameOnChannel( uint8_t channel )
{
 8012aa0:	b590      	push	{r4, r7, lr}
 8012aa2:	b089      	sub	sp, #36	; 0x24
 8012aa4:	af00      	add	r7, sp, #0
 8012aa6:	0002      	movs	r2, r0
 8012aa8:	1dfb      	adds	r3, r7, #7
 8012aaa:	701a      	strb	r2, [r3, #0]
    TxConfigParams_t txConfig;
    int8_t txPower = 0;
 8012aac:	230b      	movs	r3, #11
 8012aae:	18fb      	adds	r3, r7, r3
 8012ab0:	2200      	movs	r2, #0
 8012ab2:	701a      	strb	r2, [r3, #0]

    txConfig.Channel = channel;
 8012ab4:	210c      	movs	r1, #12
 8012ab6:	187b      	adds	r3, r7, r1
 8012ab8:	1dfa      	adds	r2, r7, #7
 8012aba:	7812      	ldrb	r2, [r2, #0]
 8012abc:	701a      	strb	r2, [r3, #0]
    txConfig.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;
 8012abe:	4b56      	ldr	r3, [pc, #344]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012ac0:	4a56      	ldr	r2, [pc, #344]	; (8012c1c <SendFrameOnChannel+0x17c>)
 8012ac2:	589b      	ldr	r3, [r3, r2]
 8012ac4:	22f9      	movs	r2, #249	; 0xf9
 8012ac6:	569a      	ldrsb	r2, [r3, r2]
 8012ac8:	187b      	adds	r3, r7, r1
 8012aca:	705a      	strb	r2, [r3, #1]
    txConfig.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;
 8012acc:	4b52      	ldr	r3, [pc, #328]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012ace:	4a53      	ldr	r2, [pc, #332]	; (8012c1c <SendFrameOnChannel+0x17c>)
 8012ad0:	589b      	ldr	r3, [r3, r2]
 8012ad2:	22f8      	movs	r2, #248	; 0xf8
 8012ad4:	569a      	ldrsb	r2, [r3, r2]
 8012ad6:	187b      	adds	r3, r7, r1
 8012ad8:	709a      	strb	r2, [r3, #2]
    txConfig.MaxEirp = MacCtx.NvmCtx->MacParams.MaxEirp;
 8012ada:	4b4f      	ldr	r3, [pc, #316]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012adc:	4a4f      	ldr	r2, [pc, #316]	; (8012c1c <SendFrameOnChannel+0x17c>)
 8012ade:	589a      	ldr	r2, [r3, r2]
 8012ae0:	2398      	movs	r3, #152	; 0x98
 8012ae2:	005b      	lsls	r3, r3, #1
 8012ae4:	58d2      	ldr	r2, [r2, r3]
 8012ae6:	187b      	adds	r3, r7, r1
 8012ae8:	605a      	str	r2, [r3, #4]
    txConfig.AntennaGain = MacCtx.NvmCtx->MacParams.AntennaGain;
 8012aea:	4b4b      	ldr	r3, [pc, #300]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012aec:	4a4b      	ldr	r2, [pc, #300]	; (8012c1c <SendFrameOnChannel+0x17c>)
 8012aee:	589a      	ldr	r2, [r3, r2]
 8012af0:	239a      	movs	r3, #154	; 0x9a
 8012af2:	005b      	lsls	r3, r3, #1
 8012af4:	58d2      	ldr	r2, [r2, r3]
 8012af6:	187b      	adds	r3, r7, r1
 8012af8:	609a      	str	r2, [r3, #8]
    txConfig.PktLen = MacCtx.PktBufferLen;
 8012afa:	4b47      	ldr	r3, [pc, #284]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012afc:	881a      	ldrh	r2, [r3, #0]
 8012afe:	187b      	adds	r3, r7, r1
 8012b00:	819a      	strh	r2, [r3, #12]


    if( LoRaMacClassBIsBeaconExpected( ) == true )
 8012b02:	f002 fa9b 	bl	801503c <LoRaMacClassBIsBeaconExpected>
 8012b06:	1e03      	subs	r3, r0, #0
 8012b08:	d001      	beq.n	8012b0e <SendFrameOnChannel+0x6e>
    {
        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;
 8012b0a:	230e      	movs	r3, #14
 8012b0c:	e07f      	b.n	8012c0e <SendFrameOnChannel+0x16e>
    }

    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )
 8012b0e:	4b42      	ldr	r3, [pc, #264]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012b10:	4a42      	ldr	r2, [pc, #264]	; (8012c1c <SendFrameOnChannel+0x17c>)
 8012b12:	589b      	ldr	r3, [r3, r2]
 8012b14:	22f0      	movs	r2, #240	; 0xf0
 8012b16:	5c9b      	ldrb	r3, [r3, r2]
 8012b18:	2b01      	cmp	r3, #1
 8012b1a:	d10d      	bne.n	8012b38 <SendFrameOnChannel+0x98>
    {
        if( LoRaMacClassBIsPingExpected( ) == true )
 8012b1c:	f002 fa94 	bl	8015048 <LoRaMacClassBIsPingExpected>
 8012b20:	1e03      	subs	r3, r0, #0
 8012b22:	d001      	beq.n	8012b28 <SendFrameOnChannel+0x88>
        {
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 8012b24:	230f      	movs	r3, #15
 8012b26:	e072      	b.n	8012c0e <SendFrameOnChannel+0x16e>
        }
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 8012b28:	f002 fa94 	bl	8015054 <LoRaMacClassBIsMulticastExpected>
 8012b2c:	1e03      	subs	r3, r0, #0
 8012b2e:	d001      	beq.n	8012b34 <SendFrameOnChannel+0x94>
        {
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 8012b30:	230f      	movs	r3, #15
 8012b32:	e06c      	b.n	8012c0e <SendFrameOnChannel+0x16e>
        }
        else
        {
            LoRaMacClassBStopRxSlots( );
 8012b34:	f002 fb01 	bl	801513a <LoRaMacClassBStopRxSlots>
        }
    }
    RegionTxConfig( MacCtx.NvmCtx->Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 8012b38:	4b37      	ldr	r3, [pc, #220]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012b3a:	4a38      	ldr	r2, [pc, #224]	; (8012c1c <SendFrameOnChannel+0x17c>)
 8012b3c:	589b      	ldr	r3, [r3, r2]
 8012b3e:	7818      	ldrb	r0, [r3, #0]
 8012b40:	4b37      	ldr	r3, [pc, #220]	; (8012c20 <SendFrameOnChannel+0x180>)
 8012b42:	240b      	movs	r4, #11
 8012b44:	193a      	adds	r2, r7, r4
 8012b46:	210c      	movs	r1, #12
 8012b48:	1879      	adds	r1, r7, r1
 8012b4a:	f004 fdd5 	bl	80176f8 <RegionTxConfig>

    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8012b4e:	4b32      	ldr	r3, [pc, #200]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012b50:	4a34      	ldr	r2, [pc, #208]	; (8012c24 <SendFrameOnChannel+0x184>)
 8012b52:	2101      	movs	r1, #1
 8012b54:	5499      	strb	r1, [r3, r2]
    MacCtx.McpsConfirm.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;
 8012b56:	4b30      	ldr	r3, [pc, #192]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012b58:	4a30      	ldr	r2, [pc, #192]	; (8012c1c <SendFrameOnChannel+0x17c>)
 8012b5a:	589b      	ldr	r3, [r3, r2]
 8012b5c:	22f9      	movs	r2, #249	; 0xf9
 8012b5e:	569b      	ldrsb	r3, [r3, r2]
 8012b60:	b2d9      	uxtb	r1, r3
 8012b62:	4b2d      	ldr	r3, [pc, #180]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012b64:	4a30      	ldr	r2, [pc, #192]	; (8012c28 <SendFrameOnChannel+0x188>)
 8012b66:	5499      	strb	r1, [r3, r2]
    MacCtx.McpsConfirm.TxPower = txPower;
 8012b68:	193b      	adds	r3, r7, r4
 8012b6a:	2100      	movs	r1, #0
 8012b6c:	5659      	ldrsb	r1, [r3, r1]
 8012b6e:	4b2a      	ldr	r3, [pc, #168]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012b70:	4a2e      	ldr	r2, [pc, #184]	; (8012c2c <SendFrameOnChannel+0x18c>)
 8012b72:	5499      	strb	r1, [r3, r2]
    MacCtx.McpsConfirm.Channel = channel;
 8012b74:	1dfb      	adds	r3, r7, #7
 8012b76:	781a      	ldrb	r2, [r3, #0]
 8012b78:	4b27      	ldr	r3, [pc, #156]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012b7a:	492d      	ldr	r1, [pc, #180]	; (8012c30 <SendFrameOnChannel+0x190>)
 8012b7c:	505a      	str	r2, [r3, r1]

    // Store the time on air
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 8012b7e:	4a26      	ldr	r2, [pc, #152]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012b80:	2383      	movs	r3, #131	; 0x83
 8012b82:	00db      	lsls	r3, r3, #3
 8012b84:	58d2      	ldr	r2, [r2, r3]
 8012b86:	4b24      	ldr	r3, [pc, #144]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012b88:	492a      	ldr	r1, [pc, #168]	; (8012c34 <SendFrameOnChannel+0x194>)
 8012b8a:	505a      	str	r2, [r3, r1]
    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 8012b8c:	4a22      	ldr	r2, [pc, #136]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012b8e:	2383      	movs	r3, #131	; 0x83
 8012b90:	00db      	lsls	r3, r3, #3
 8012b92:	58d2      	ldr	r2, [r2, r3]
 8012b94:	4b20      	ldr	r3, [pc, #128]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012b96:	4928      	ldr	r1, [pc, #160]	; (8012c38 <SendFrameOnChannel+0x198>)
 8012b98:	505a      	str	r2, [r3, r1]

    if( LoRaMacClassBIsBeaconModeActive( ) == true )
 8012b9a:	f002 fa61 	bl	8015060 <LoRaMacClassBIsBeaconModeActive>
 8012b9e:	1e03      	subs	r3, r0, #0
 8012ba0:	d00d      	beq.n	8012bbe <SendFrameOnChannel+0x11e>
    {
        // Currently, the Time-On-Air can only be computed when the radio is configured with
        // the TX configuration
        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );
 8012ba2:	4a1d      	ldr	r2, [pc, #116]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012ba4:	2383      	movs	r3, #131	; 0x83
 8012ba6:	00db      	lsls	r3, r3, #3
 8012ba8:	58d3      	ldr	r3, [r2, r3]
 8012baa:	0018      	movs	r0, r3
 8012bac:	f002 fabc 	bl	8015128 <LoRaMacClassBIsUplinkCollision>
 8012bb0:	0003      	movs	r3, r0
 8012bb2:	61fb      	str	r3, [r7, #28]

        if( collisionTime > 0 )
 8012bb4:	69fb      	ldr	r3, [r7, #28]
 8012bb6:	2b00      	cmp	r3, #0
 8012bb8:	d001      	beq.n	8012bbe <SendFrameOnChannel+0x11e>
        {
            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;
 8012bba:	2310      	movs	r3, #16
 8012bbc:	e027      	b.n	8012c0e <SendFrameOnChannel+0x16e>
        }
    }

    LoRaMacClassBHaltBeaconing( );
 8012bbe:	f002 fa5f 	bl	8015080 <LoRaMacClassBHaltBeaconing>

    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 8012bc2:	4a15      	ldr	r2, [pc, #84]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012bc4:	23d0      	movs	r3, #208	; 0xd0
 8012bc6:	009b      	lsls	r3, r3, #2
 8012bc8:	58d3      	ldr	r3, [r2, r3]
 8012bca:	2202      	movs	r2, #2
 8012bcc:	431a      	orrs	r2, r3
 8012bce:	0011      	movs	r1, r2
 8012bd0:	4a11      	ldr	r2, [pc, #68]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012bd2:	23d0      	movs	r3, #208	; 0xd0
 8012bd4:	009b      	lsls	r3, r3, #2
 8012bd6:	50d1      	str	r1, [r2, r3]
    if( MacCtx.NodeAckRequested == false )
 8012bd8:	4b0f      	ldr	r3, [pc, #60]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012bda:	4a18      	ldr	r2, [pc, #96]	; (8012c3c <SendFrameOnChannel+0x19c>)
 8012bdc:	5c9b      	ldrb	r3, [r3, r2]
 8012bde:	2201      	movs	r2, #1
 8012be0:	4053      	eors	r3, r2
 8012be2:	b2db      	uxtb	r3, r3
 8012be4:	2b00      	cmp	r3, #0
 8012be6:	d009      	beq.n	8012bfc <SendFrameOnChannel+0x15c>
    {
        MacCtx.ChannelsNbTransCounter++;
 8012be8:	4a0b      	ldr	r2, [pc, #44]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012bea:	2382      	movs	r3, #130	; 0x82
 8012bec:	00db      	lsls	r3, r3, #3
 8012bee:	5cd3      	ldrb	r3, [r2, r3]
 8012bf0:	3301      	adds	r3, #1
 8012bf2:	b2d9      	uxtb	r1, r3
 8012bf4:	4a08      	ldr	r2, [pc, #32]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012bf6:	2382      	movs	r3, #130	; 0x82
 8012bf8:	00db      	lsls	r3, r3, #3
 8012bfa:	54d1      	strb	r1, [r2, r3]
    }

    // Send now
    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );
 8012bfc:	4b10      	ldr	r3, [pc, #64]	; (8012c40 <SendFrameOnChannel+0x1a0>)
 8012bfe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012c00:	4a05      	ldr	r2, [pc, #20]	; (8012c18 <SendFrameOnChannel+0x178>)
 8012c02:	8812      	ldrh	r2, [r2, #0]
 8012c04:	b2d1      	uxtb	r1, r2
 8012c06:	4a0f      	ldr	r2, [pc, #60]	; (8012c44 <SendFrameOnChannel+0x1a4>)
 8012c08:	0010      	movs	r0, r2
 8012c0a:	4798      	blx	r3

    return LORAMAC_STATUS_OK;
 8012c0c:	2300      	movs	r3, #0
}
 8012c0e:	0018      	movs	r0, r3
 8012c10:	46bd      	mov	sp, r7
 8012c12:	b009      	add	sp, #36	; 0x24
 8012c14:	bd90      	pop	{r4, r7, pc}
 8012c16:	46c0      	nop			; (mov r8, r8)
 8012c18:	200008ec 	.word	0x200008ec
 8012c1c:	00000484 	.word	0x00000484
 8012c20:	20000d04 	.word	0x20000d04
 8012c24:	0000043d 	.word	0x0000043d
 8012c28:	0000043e 	.word	0x0000043e
 8012c2c:	0000043f 	.word	0x0000043f
 8012c30:	0000044c 	.word	0x0000044c
 8012c34:	00000444 	.word	0x00000444
 8012c38:	00000454 	.word	0x00000454
 8012c3c:	00000414 	.word	0x00000414
 8012c40:	0801ebd0 	.word	0x0801ebd0
 8012c44:	200008ee 	.word	0x200008ee

08012c48 <SetTxContinuousWave>:

LoRaMacStatus_t SetTxContinuousWave( uint16_t timeout )
{
 8012c48:	b580      	push	{r7, lr}
 8012c4a:	b086      	sub	sp, #24
 8012c4c:	af00      	add	r7, sp, #0
 8012c4e:	0002      	movs	r2, r0
 8012c50:	1dbb      	adds	r3, r7, #6
 8012c52:	801a      	strh	r2, [r3, #0]
    ContinuousWaveParams_t continuousWave;

    continuousWave.Channel = MacCtx.Channel;
 8012c54:	4b20      	ldr	r3, [pc, #128]	; (8012cd8 <SetTxContinuousWave+0x90>)
 8012c56:	4a21      	ldr	r2, [pc, #132]	; (8012cdc <SetTxContinuousWave+0x94>)
 8012c58:	5c9a      	ldrb	r2, [r3, r2]
 8012c5a:	2108      	movs	r1, #8
 8012c5c:	187b      	adds	r3, r7, r1
 8012c5e:	701a      	strb	r2, [r3, #0]
    continuousWave.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;
 8012c60:	4b1d      	ldr	r3, [pc, #116]	; (8012cd8 <SetTxContinuousWave+0x90>)
 8012c62:	4a1f      	ldr	r2, [pc, #124]	; (8012ce0 <SetTxContinuousWave+0x98>)
 8012c64:	589b      	ldr	r3, [r3, r2]
 8012c66:	22f9      	movs	r2, #249	; 0xf9
 8012c68:	569a      	ldrsb	r2, [r3, r2]
 8012c6a:	187b      	adds	r3, r7, r1
 8012c6c:	705a      	strb	r2, [r3, #1]
    continuousWave.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;
 8012c6e:	4b1a      	ldr	r3, [pc, #104]	; (8012cd8 <SetTxContinuousWave+0x90>)
 8012c70:	4a1b      	ldr	r2, [pc, #108]	; (8012ce0 <SetTxContinuousWave+0x98>)
 8012c72:	589b      	ldr	r3, [r3, r2]
 8012c74:	22f8      	movs	r2, #248	; 0xf8
 8012c76:	569a      	ldrsb	r2, [r3, r2]
 8012c78:	187b      	adds	r3, r7, r1
 8012c7a:	709a      	strb	r2, [r3, #2]
    continuousWave.MaxEirp = MacCtx.NvmCtx->MacParams.MaxEirp;
 8012c7c:	4b16      	ldr	r3, [pc, #88]	; (8012cd8 <SetTxContinuousWave+0x90>)
 8012c7e:	4a18      	ldr	r2, [pc, #96]	; (8012ce0 <SetTxContinuousWave+0x98>)
 8012c80:	589a      	ldr	r2, [r3, r2]
 8012c82:	2398      	movs	r3, #152	; 0x98
 8012c84:	005b      	lsls	r3, r3, #1
 8012c86:	58d2      	ldr	r2, [r2, r3]
 8012c88:	187b      	adds	r3, r7, r1
 8012c8a:	605a      	str	r2, [r3, #4]
    continuousWave.AntennaGain = MacCtx.NvmCtx->MacParams.AntennaGain;
 8012c8c:	4b12      	ldr	r3, [pc, #72]	; (8012cd8 <SetTxContinuousWave+0x90>)
 8012c8e:	4a14      	ldr	r2, [pc, #80]	; (8012ce0 <SetTxContinuousWave+0x98>)
 8012c90:	589a      	ldr	r2, [r3, r2]
 8012c92:	239a      	movs	r3, #154	; 0x9a
 8012c94:	005b      	lsls	r3, r3, #1
 8012c96:	58d2      	ldr	r2, [r2, r3]
 8012c98:	187b      	adds	r3, r7, r1
 8012c9a:	609a      	str	r2, [r3, #8]
    continuousWave.Timeout = timeout;
 8012c9c:	187b      	adds	r3, r7, r1
 8012c9e:	1dba      	adds	r2, r7, #6
 8012ca0:	8812      	ldrh	r2, [r2, #0]
 8012ca2:	819a      	strh	r2, [r3, #12]

    RegionSetContinuousWave( MacCtx.NvmCtx->Region, &continuousWave );
 8012ca4:	4b0c      	ldr	r3, [pc, #48]	; (8012cd8 <SetTxContinuousWave+0x90>)
 8012ca6:	4a0e      	ldr	r2, [pc, #56]	; (8012ce0 <SetTxContinuousWave+0x98>)
 8012ca8:	589b      	ldr	r3, [r3, r2]
 8012caa:	781b      	ldrb	r3, [r3, #0]
 8012cac:	187a      	adds	r2, r7, r1
 8012cae:	0011      	movs	r1, r2
 8012cb0:	0018      	movs	r0, r3
 8012cb2:	f004 fe05 	bl	80178c0 <RegionSetContinuousWave>

    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 8012cb6:	4a08      	ldr	r2, [pc, #32]	; (8012cd8 <SetTxContinuousWave+0x90>)
 8012cb8:	23d0      	movs	r3, #208	; 0xd0
 8012cba:	009b      	lsls	r3, r3, #2
 8012cbc:	58d3      	ldr	r3, [r2, r3]
 8012cbe:	2202      	movs	r2, #2
 8012cc0:	431a      	orrs	r2, r3
 8012cc2:	0011      	movs	r1, r2
 8012cc4:	4a04      	ldr	r2, [pc, #16]	; (8012cd8 <SetTxContinuousWave+0x90>)
 8012cc6:	23d0      	movs	r3, #208	; 0xd0
 8012cc8:	009b      	lsls	r3, r3, #2
 8012cca:	50d1      	str	r1, [r2, r3]

    return LORAMAC_STATUS_OK;
 8012ccc:	2300      	movs	r3, #0
}
 8012cce:	0018      	movs	r0, r3
 8012cd0:	46bd      	mov	sp, r7
 8012cd2:	b006      	add	sp, #24
 8012cd4:	bd80      	pop	{r7, pc}
 8012cd6:	46c0      	nop			; (mov r8, r8)
 8012cd8:	200008ec 	.word	0x200008ec
 8012cdc:	00000415 	.word	0x00000415
 8012ce0:	00000484 	.word	0x00000484

08012ce4 <SetTxContinuousWave1>:

LoRaMacStatus_t SetTxContinuousWave1( uint16_t timeout, uint32_t frequency, uint8_t power )
{
 8012ce4:	b580      	push	{r7, lr}
 8012ce6:	b082      	sub	sp, #8
 8012ce8:	af00      	add	r7, sp, #0
 8012cea:	6039      	str	r1, [r7, #0]
 8012cec:	0011      	movs	r1, r2
 8012cee:	1dbb      	adds	r3, r7, #6
 8012cf0:	1c02      	adds	r2, r0, #0
 8012cf2:	801a      	strh	r2, [r3, #0]
 8012cf4:	1d7b      	adds	r3, r7, #5
 8012cf6:	1c0a      	adds	r2, r1, #0
 8012cf8:	701a      	strb	r2, [r3, #0]
    Radio.SetTxContinuousWave( frequency, power, timeout );
 8012cfa:	4b0c      	ldr	r3, [pc, #48]	; (8012d2c <SetTxContinuousWave1+0x48>)
 8012cfc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012cfe:	1d7a      	adds	r2, r7, #5
 8012d00:	2100      	movs	r1, #0
 8012d02:	5651      	ldrsb	r1, [r2, r1]
 8012d04:	1dba      	adds	r2, r7, #6
 8012d06:	8812      	ldrh	r2, [r2, #0]
 8012d08:	6838      	ldr	r0, [r7, #0]
 8012d0a:	4798      	blx	r3

    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 8012d0c:	4a08      	ldr	r2, [pc, #32]	; (8012d30 <SetTxContinuousWave1+0x4c>)
 8012d0e:	23d0      	movs	r3, #208	; 0xd0
 8012d10:	009b      	lsls	r3, r3, #2
 8012d12:	58d3      	ldr	r3, [r2, r3]
 8012d14:	2202      	movs	r2, #2
 8012d16:	431a      	orrs	r2, r3
 8012d18:	0011      	movs	r1, r2
 8012d1a:	4a05      	ldr	r2, [pc, #20]	; (8012d30 <SetTxContinuousWave1+0x4c>)
 8012d1c:	23d0      	movs	r3, #208	; 0xd0
 8012d1e:	009b      	lsls	r3, r3, #2
 8012d20:	50d1      	str	r1, [r2, r3]

    return LORAMAC_STATUS_OK;
 8012d22:	2300      	movs	r3, #0
}
 8012d24:	0018      	movs	r0, r3
 8012d26:	46bd      	mov	sp, r7
 8012d28:	b002      	add	sp, #8
 8012d2a:	bd80      	pop	{r7, pc}
 8012d2c:	0801ebd0 	.word	0x0801ebd0
 8012d30:	200008ec 	.word	0x200008ec

08012d34 <GetCtxs>:

LoRaMacCtxs_t* GetCtxs( void )
{
 8012d34:	b580      	push	{r7, lr}
 8012d36:	b082      	sub	sp, #8
 8012d38:	af00      	add	r7, sp, #0
    Contexts.MacNvmCtx = &NvmMacCtx;
 8012d3a:	4b20      	ldr	r3, [pc, #128]	; (8012dbc <GetCtxs+0x88>)
 8012d3c:	4a20      	ldr	r2, [pc, #128]	; (8012dc0 <GetCtxs+0x8c>)
 8012d3e:	601a      	str	r2, [r3, #0]
    Contexts.MacNvmCtxSize = sizeof( NvmMacCtx );
 8012d40:	4b1e      	ldr	r3, [pc, #120]	; (8012dbc <GetCtxs+0x88>)
 8012d42:	22ee      	movs	r2, #238	; 0xee
 8012d44:	0052      	lsls	r2, r2, #1
 8012d46:	605a      	str	r2, [r3, #4]
    Contexts.CryptoNvmCtx = LoRaMacCryptoGetNvmCtx( &Contexts.CryptoNvmCtxSize );
 8012d48:	4b1e      	ldr	r3, [pc, #120]	; (8012dc4 <GetCtxs+0x90>)
 8012d4a:	0018      	movs	r0, r3
 8012d4c:	f003 fb08 	bl	8016360 <LoRaMacCryptoGetNvmCtx>
 8012d50:	0002      	movs	r2, r0
 8012d52:	4b1a      	ldr	r3, [pc, #104]	; (8012dbc <GetCtxs+0x88>)
 8012d54:	611a      	str	r2, [r3, #16]
    GetNvmCtxParams_t params ={ 0 };
 8012d56:	2300      	movs	r3, #0
 8012d58:	607b      	str	r3, [r7, #4]
    Contexts.RegionNvmCtx = RegionGetNvmCtx( MacCtx.NvmCtx->Region, &params );
 8012d5a:	4b1b      	ldr	r3, [pc, #108]	; (8012dc8 <GetCtxs+0x94>)
 8012d5c:	4a1b      	ldr	r2, [pc, #108]	; (8012dcc <GetCtxs+0x98>)
 8012d5e:	589b      	ldr	r3, [r3, r2]
 8012d60:	781b      	ldrb	r3, [r3, #0]
 8012d62:	1d3a      	adds	r2, r7, #4
 8012d64:	0011      	movs	r1, r2
 8012d66:	0018      	movs	r0, r3
 8012d68:	f004 fc2a 	bl	80175c0 <RegionGetNvmCtx>
 8012d6c:	0002      	movs	r2, r0
 8012d6e:	4b13      	ldr	r3, [pc, #76]	; (8012dbc <GetCtxs+0x88>)
 8012d70:	609a      	str	r2, [r3, #8]
    Contexts.RegionNvmCtxSize = params.nvmCtxSize;
 8012d72:	687a      	ldr	r2, [r7, #4]
 8012d74:	4b11      	ldr	r3, [pc, #68]	; (8012dbc <GetCtxs+0x88>)
 8012d76:	60da      	str	r2, [r3, #12]
    Contexts.SecureElementNvmCtx = SecureElementGetNvmCtx( &Contexts.SecureElementNvmCtxSize );
 8012d78:	4b15      	ldr	r3, [pc, #84]	; (8012dd0 <GetCtxs+0x9c>)
 8012d7a:	0018      	movs	r0, r3
 8012d7c:	f7fc f9fa 	bl	800f174 <SecureElementGetNvmCtx>
 8012d80:	0002      	movs	r2, r0
 8012d82:	4b0e      	ldr	r3, [pc, #56]	; (8012dbc <GetCtxs+0x88>)
 8012d84:	619a      	str	r2, [r3, #24]
    Contexts.CommandsNvmCtx = LoRaMacCommandsGetNvmCtx( &Contexts.CommandsNvmCtxSize );
 8012d86:	4b13      	ldr	r3, [pc, #76]	; (8012dd4 <GetCtxs+0xa0>)
 8012d88:	0018      	movs	r0, r3
 8012d8a:	f002 fb3f 	bl	801540c <LoRaMacCommandsGetNvmCtx>
 8012d8e:	0002      	movs	r2, r0
 8012d90:	4b0a      	ldr	r3, [pc, #40]	; (8012dbc <GetCtxs+0x88>)
 8012d92:	621a      	str	r2, [r3, #32]
    Contexts.ClassBNvmCtx = LoRaMacClassBGetNvmCtx( &Contexts.ClassBNvmCtxSize );
 8012d94:	4b10      	ldr	r3, [pc, #64]	; (8012dd8 <GetCtxs+0xa4>)
 8012d96:	0018      	movs	r0, r3
 8012d98:	f002 f8fc 	bl	8014f94 <LoRaMacClassBGetNvmCtx>
 8012d9c:	0002      	movs	r2, r0
 8012d9e:	4b07      	ldr	r3, [pc, #28]	; (8012dbc <GetCtxs+0x88>)
 8012da0:	629a      	str	r2, [r3, #40]	; 0x28
    Contexts.ConfirmQueueNvmCtx = LoRaMacConfirmQueueGetNvmCtx( &Contexts.ConfirmQueueNvmCtxSize );
 8012da2:	4b0e      	ldr	r3, [pc, #56]	; (8012ddc <GetCtxs+0xa8>)
 8012da4:	0018      	movs	r0, r3
 8012da6:	f002 fd21 	bl	80157ec <LoRaMacConfirmQueueGetNvmCtx>
 8012daa:	0002      	movs	r2, r0
 8012dac:	4b03      	ldr	r3, [pc, #12]	; (8012dbc <GetCtxs+0x88>)
 8012dae:	631a      	str	r2, [r3, #48]	; 0x30
    return &Contexts;
 8012db0:	4b02      	ldr	r3, [pc, #8]	; (8012dbc <GetCtxs+0x88>)
}
 8012db2:	0018      	movs	r0, r3
 8012db4:	46bd      	mov	sp, r7
 8012db6:	b002      	add	sp, #8
 8012db8:	bd80      	pop	{r7, pc}
 8012dba:	46c0      	nop			; (mov r8, r8)
 8012dbc:	200017f4 	.word	0x200017f4
 8012dc0:	20000d74 	.word	0x20000d74
 8012dc4:	20001808 	.word	0x20001808
 8012dc8:	200008ec 	.word	0x200008ec
 8012dcc:	00000484 	.word	0x00000484
 8012dd0:	20001810 	.word	0x20001810
 8012dd4:	20001818 	.word	0x20001818
 8012dd8:	20001820 	.word	0x20001820
 8012ddc:	20001828 	.word	0x20001828

08012de0 <RestoreCtxs>:

LoRaMacStatus_t RestoreCtxs( LoRaMacCtxs_t* contexts )
{
 8012de0:	b580      	push	{r7, lr}
 8012de2:	b084      	sub	sp, #16
 8012de4:	af00      	add	r7, sp, #0
 8012de6:	6078      	str	r0, [r7, #4]
    if( contexts == NULL )
 8012de8:	687b      	ldr	r3, [r7, #4]
 8012dea:	2b00      	cmp	r3, #0
 8012dec:	d101      	bne.n	8012df2 <RestoreCtxs+0x12>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8012dee:	2303      	movs	r3, #3
 8012df0:	e05d      	b.n	8012eae <RestoreCtxs+0xce>
    }
    if( MacCtx.MacState != LORAMAC_STOPPED )
 8012df2:	4a31      	ldr	r2, [pc, #196]	; (8012eb8 <RestoreCtxs+0xd8>)
 8012df4:	23d0      	movs	r3, #208	; 0xd0
 8012df6:	009b      	lsls	r3, r3, #2
 8012df8:	58d3      	ldr	r3, [r2, r3]
 8012dfa:	2b01      	cmp	r3, #1
 8012dfc:	d001      	beq.n	8012e02 <RestoreCtxs+0x22>
    {
        return LORAMAC_STATUS_BUSY;
 8012dfe:	2301      	movs	r3, #1
 8012e00:	e055      	b.n	8012eae <RestoreCtxs+0xce>
    }

    if( contexts->MacNvmCtx != NULL )
 8012e02:	687b      	ldr	r3, [r7, #4]
 8012e04:	681b      	ldr	r3, [r3, #0]
 8012e06:	2b00      	cmp	r3, #0
 8012e08:	d008      	beq.n	8012e1c <RestoreCtxs+0x3c>
    {
        memcpy1( ( uint8_t* ) &NvmMacCtx, ( uint8_t* ) contexts->MacNvmCtx, contexts->MacNvmCtxSize );
 8012e0a:	687b      	ldr	r3, [r7, #4]
 8012e0c:	6819      	ldr	r1, [r3, #0]
 8012e0e:	687b      	ldr	r3, [r7, #4]
 8012e10:	685b      	ldr	r3, [r3, #4]
 8012e12:	b29a      	uxth	r2, r3
 8012e14:	4b29      	ldr	r3, [pc, #164]	; (8012ebc <RestoreCtxs+0xdc>)
 8012e16:	0018      	movs	r0, r3
 8012e18:	f008 fb96 	bl	801b548 <memcpy1>
    }

    InitDefaultsParams_t params;
    params.Type = INIT_TYPE_RESTORE_CTX;
 8012e1c:	2108      	movs	r1, #8
 8012e1e:	187b      	adds	r3, r7, r1
 8012e20:	2202      	movs	r2, #2
 8012e22:	711a      	strb	r2, [r3, #4]
    params.NvmCtx = contexts->RegionNvmCtx;
 8012e24:	687b      	ldr	r3, [r7, #4]
 8012e26:	689a      	ldr	r2, [r3, #8]
 8012e28:	187b      	adds	r3, r7, r1
 8012e2a:	601a      	str	r2, [r3, #0]
    RegionInitDefaults( MacCtx.NvmCtx->Region, &params );
 8012e2c:	4b22      	ldr	r3, [pc, #136]	; (8012eb8 <RestoreCtxs+0xd8>)
 8012e2e:	4a24      	ldr	r2, [pc, #144]	; (8012ec0 <RestoreCtxs+0xe0>)
 8012e30:	589b      	ldr	r3, [r3, r2]
 8012e32:	781b      	ldrb	r3, [r3, #0]
 8012e34:	187a      	adds	r2, r7, r1
 8012e36:	0011      	movs	r1, r2
 8012e38:	0018      	movs	r0, r3
 8012e3a:	f004 fbac 	bl	8017596 <RegionInitDefaults>

    if( SecureElementRestoreNvmCtx( contexts->SecureElementNvmCtx ) != SECURE_ELEMENT_SUCCESS )
 8012e3e:	687b      	ldr	r3, [r7, #4]
 8012e40:	699b      	ldr	r3, [r3, #24]
 8012e42:	0018      	movs	r0, r3
 8012e44:	f7fc f97e 	bl	800f144 <SecureElementRestoreNvmCtx>
 8012e48:	1e03      	subs	r3, r0, #0
 8012e4a:	d001      	beq.n	8012e50 <RestoreCtxs+0x70>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
 8012e4c:	2311      	movs	r3, #17
 8012e4e:	e02e      	b.n	8012eae <RestoreCtxs+0xce>
    }

    if( LoRaMacCryptoRestoreNvmCtx( contexts->CryptoNvmCtx ) != LORAMAC_CRYPTO_SUCCESS )
 8012e50:	687b      	ldr	r3, [r7, #4]
 8012e52:	691b      	ldr	r3, [r3, #16]
 8012e54:	0018      	movs	r0, r3
 8012e56:	f003 fa6d 	bl	8016334 <LoRaMacCryptoRestoreNvmCtx>
 8012e5a:	1e03      	subs	r3, r0, #0
 8012e5c:	d001      	beq.n	8012e62 <RestoreCtxs+0x82>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
 8012e5e:	2311      	movs	r3, #17
 8012e60:	e025      	b.n	8012eae <RestoreCtxs+0xce>
    }

    if( LoRaMacCommandsRestoreNvmCtx( contexts->CommandsNvmCtx ) != LORAMAC_COMMANDS_SUCCESS )
 8012e62:	687b      	ldr	r3, [r7, #4]
 8012e64:	6a1b      	ldr	r3, [r3, #32]
 8012e66:	0018      	movs	r0, r3
 8012e68:	f002 faba 	bl	80153e0 <LoRaMacCommandsRestoreNvmCtx>
 8012e6c:	1e03      	subs	r3, r0, #0
 8012e6e:	d001      	beq.n	8012e74 <RestoreCtxs+0x94>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8012e70:	2313      	movs	r3, #19
 8012e72:	e01c      	b.n	8012eae <RestoreCtxs+0xce>
    }

    if( LoRaMacClassBRestoreNvmCtx( contexts->ClassBNvmCtx ) != true )
 8012e74:	687b      	ldr	r3, [r7, #4]
 8012e76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012e78:	0018      	movs	r0, r3
 8012e7a:	f002 f882 	bl	8014f82 <LoRaMacClassBRestoreNvmCtx>
 8012e7e:	0003      	movs	r3, r0
 8012e80:	001a      	movs	r2, r3
 8012e82:	2301      	movs	r3, #1
 8012e84:	4053      	eors	r3, r2
 8012e86:	b2db      	uxtb	r3, r3
 8012e88:	2b00      	cmp	r3, #0
 8012e8a:	d001      	beq.n	8012e90 <RestoreCtxs+0xb0>
    {
        return LORAMAC_STATUS_CLASS_B_ERROR;
 8012e8c:	2314      	movs	r3, #20
 8012e8e:	e00e      	b.n	8012eae <RestoreCtxs+0xce>
    }

    if( LoRaMacConfirmQueueRestoreNvmCtx( contexts->ConfirmQueueNvmCtx ) != true )
 8012e90:	687b      	ldr	r3, [r7, #4]
 8012e92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012e94:	0018      	movs	r0, r3
 8012e96:	f002 fc93 	bl	80157c0 <LoRaMacConfirmQueueRestoreNvmCtx>
 8012e9a:	0003      	movs	r3, r0
 8012e9c:	001a      	movs	r2, r3
 8012e9e:	2301      	movs	r3, #1
 8012ea0:	4053      	eors	r3, r2
 8012ea2:	b2db      	uxtb	r3, r3
 8012ea4:	2b00      	cmp	r3, #0
 8012ea6:	d001      	beq.n	8012eac <RestoreCtxs+0xcc>
    {
        return LORAMAC_STATUS_CONFIRM_QUEUE_ERROR;
 8012ea8:	2315      	movs	r3, #21
 8012eaa:	e000      	b.n	8012eae <RestoreCtxs+0xce>
    }

    return LORAMAC_STATUS_OK;
 8012eac:	2300      	movs	r3, #0
}
 8012eae:	0018      	movs	r0, r3
 8012eb0:	46bd      	mov	sp, r7
 8012eb2:	b004      	add	sp, #16
 8012eb4:	bd80      	pop	{r7, pc}
 8012eb6:	46c0      	nop			; (mov r8, r8)
 8012eb8:	200008ec 	.word	0x200008ec
 8012ebc:	20000d74 	.word	0x20000d74
 8012ec0:	00000484 	.word	0x00000484

08012ec4 <DetermineFrameType>:

LoRaMacStatus_t DetermineFrameType( LoRaMacMessageData_t* macMsg, FType_t* fType )
{
 8012ec4:	b580      	push	{r7, lr}
 8012ec6:	b082      	sub	sp, #8
 8012ec8:	af00      	add	r7, sp, #0
 8012eca:	6078      	str	r0, [r7, #4]
 8012ecc:	6039      	str	r1, [r7, #0]
    if( ( macMsg == NULL ) || ( fType == NULL ) )
 8012ece:	687b      	ldr	r3, [r7, #4]
 8012ed0:	2b00      	cmp	r3, #0
 8012ed2:	d002      	beq.n	8012eda <DetermineFrameType+0x16>
 8012ed4:	683b      	ldr	r3, [r7, #0]
 8012ed6:	2b00      	cmp	r3, #0
 8012ed8:	d101      	bne.n	8012ede <DetermineFrameType+0x1a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8012eda:	2303      	movs	r3, #3
 8012edc:	e03b      	b.n	8012f56 <DetermineFrameType+0x92>
     * +-------+  +----------+------+-------+--------------+
     * |   D   |  |    = 0   |   -  |  > 0  |       X      |
     * +-------+  +----------+------+-------+--------------+
     */

    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 8012ede:	687b      	ldr	r3, [r7, #4]
 8012ee0:	7b1b      	ldrb	r3, [r3, #12]
 8012ee2:	220f      	movs	r2, #15
 8012ee4:	4013      	ands	r3, r2
 8012ee6:	b2db      	uxtb	r3, r3
 8012ee8:	2b00      	cmp	r3, #0
 8012eea:	d008      	beq.n	8012efe <DetermineFrameType+0x3a>
 8012eec:	687b      	ldr	r3, [r7, #4]
 8012eee:	2220      	movs	r2, #32
 8012ef0:	5c9b      	ldrb	r3, [r3, r2]
 8012ef2:	2b00      	cmp	r3, #0
 8012ef4:	d003      	beq.n	8012efe <DetermineFrameType+0x3a>
    {
        *fType = FRAME_TYPE_A;
 8012ef6:	683b      	ldr	r3, [r7, #0]
 8012ef8:	2200      	movs	r2, #0
 8012efa:	701a      	strb	r2, [r3, #0]
 8012efc:	e02a      	b.n	8012f54 <DetermineFrameType+0x90>
    }
    else if( macMsg->FRMPayloadSize == 0 )
 8012efe:	687b      	ldr	r3, [r7, #4]
 8012f00:	2228      	movs	r2, #40	; 0x28
 8012f02:	5c9b      	ldrb	r3, [r3, r2]
 8012f04:	2b00      	cmp	r3, #0
 8012f06:	d103      	bne.n	8012f10 <DetermineFrameType+0x4c>
    {
        *fType = FRAME_TYPE_B;
 8012f08:	683b      	ldr	r3, [r7, #0]
 8012f0a:	2201      	movs	r2, #1
 8012f0c:	701a      	strb	r2, [r3, #0]
 8012f0e:	e021      	b.n	8012f54 <DetermineFrameType+0x90>
    }
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )
 8012f10:	687b      	ldr	r3, [r7, #4]
 8012f12:	7b1b      	ldrb	r3, [r3, #12]
 8012f14:	220f      	movs	r2, #15
 8012f16:	4013      	ands	r3, r2
 8012f18:	b2db      	uxtb	r3, r3
 8012f1a:	2b00      	cmp	r3, #0
 8012f1c:	d108      	bne.n	8012f30 <DetermineFrameType+0x6c>
 8012f1e:	687b      	ldr	r3, [r7, #4]
 8012f20:	2220      	movs	r2, #32
 8012f22:	5c9b      	ldrb	r3, [r3, r2]
 8012f24:	2b00      	cmp	r3, #0
 8012f26:	d103      	bne.n	8012f30 <DetermineFrameType+0x6c>
    {
        *fType = FRAME_TYPE_C;
 8012f28:	683b      	ldr	r3, [r7, #0]
 8012f2a:	2202      	movs	r2, #2
 8012f2c:	701a      	strb	r2, [r3, #0]
 8012f2e:	e011      	b.n	8012f54 <DetermineFrameType+0x90>
    }
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort > 0 ) )
 8012f30:	687b      	ldr	r3, [r7, #4]
 8012f32:	7b1b      	ldrb	r3, [r3, #12]
 8012f34:	220f      	movs	r2, #15
 8012f36:	4013      	ands	r3, r2
 8012f38:	b2db      	uxtb	r3, r3
 8012f3a:	2b00      	cmp	r3, #0
 8012f3c:	d108      	bne.n	8012f50 <DetermineFrameType+0x8c>
 8012f3e:	687b      	ldr	r3, [r7, #4]
 8012f40:	2220      	movs	r2, #32
 8012f42:	5c9b      	ldrb	r3, [r3, r2]
 8012f44:	2b00      	cmp	r3, #0
 8012f46:	d003      	beq.n	8012f50 <DetermineFrameType+0x8c>
    {
        *fType = FRAME_TYPE_D;
 8012f48:	683b      	ldr	r3, [r7, #0]
 8012f4a:	2203      	movs	r2, #3
 8012f4c:	701a      	strb	r2, [r3, #0]
 8012f4e:	e001      	b.n	8012f54 <DetermineFrameType+0x90>
    }
    else
    {
        // Should never happen.
        return LORAMAC_STATUS_ERROR;
 8012f50:	2317      	movs	r3, #23
 8012f52:	e000      	b.n	8012f56 <DetermineFrameType+0x92>
    }

    return LORAMAC_STATUS_OK;
 8012f54:	2300      	movs	r3, #0
}
 8012f56:	0018      	movs	r0, r3
 8012f58:	46bd      	mov	sp, r7
 8012f5a:	b002      	add	sp, #8
 8012f5c:	bd80      	pop	{r7, pc}
	...

08012f60 <CheckRetransUnconfirmedUplink>:

static bool CheckRetransUnconfirmedUplink( void )
{
 8012f60:	b580      	push	{r7, lr}
 8012f62:	af00      	add	r7, sp, #0
    // Unconfirmed uplink, when all retransmissions are done.
    if( MacCtx.ChannelsNbTransCounter >=
 8012f64:	4a14      	ldr	r2, [pc, #80]	; (8012fb8 <CheckRetransUnconfirmedUplink+0x58>)
 8012f66:	2382      	movs	r3, #130	; 0x82
 8012f68:	00db      	lsls	r3, r3, #3
 8012f6a:	5cd2      	ldrb	r2, [r2, r3]
        MacCtx.NvmCtx->MacParams.ChannelsNbTrans )
 8012f6c:	4b12      	ldr	r3, [pc, #72]	; (8012fb8 <CheckRetransUnconfirmedUplink+0x58>)
 8012f6e:	4913      	ldr	r1, [pc, #76]	; (8012fbc <CheckRetransUnconfirmedUplink+0x5c>)
 8012f70:	5859      	ldr	r1, [r3, r1]
 8012f72:	238c      	movs	r3, #140	; 0x8c
 8012f74:	005b      	lsls	r3, r3, #1
 8012f76:	5ccb      	ldrb	r3, [r1, r3]
    if( MacCtx.ChannelsNbTransCounter >=
 8012f78:	429a      	cmp	r2, r3
 8012f7a:	d301      	bcc.n	8012f80 <CheckRetransUnconfirmedUplink+0x20>
    {
        return true;
 8012f7c:	2301      	movs	r3, #1
 8012f7e:	e018      	b.n	8012fb2 <CheckRetransUnconfirmedUplink+0x52>
    }
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 8012f80:	4b0d      	ldr	r3, [pc, #52]	; (8012fb8 <CheckRetransUnconfirmedUplink+0x58>)
 8012f82:	4a0f      	ldr	r2, [pc, #60]	; (8012fc0 <CheckRetransUnconfirmedUplink+0x60>)
 8012f84:	5c9b      	ldrb	r3, [r3, r2]
 8012f86:	2202      	movs	r2, #2
 8012f88:	4013      	ands	r3, r2
 8012f8a:	b2db      	uxtb	r3, r3
 8012f8c:	2b00      	cmp	r3, #0
 8012f8e:	d00f      	beq.n	8012fb0 <CheckRetransUnconfirmedUplink+0x50>
    {
        // For Class A stop in each case
        if( MacCtx.NvmCtx->DeviceClass == CLASS_A )
 8012f90:	4b09      	ldr	r3, [pc, #36]	; (8012fb8 <CheckRetransUnconfirmedUplink+0x58>)
 8012f92:	4a0a      	ldr	r2, [pc, #40]	; (8012fbc <CheckRetransUnconfirmedUplink+0x5c>)
 8012f94:	589b      	ldr	r3, [r3, r2]
 8012f96:	22f0      	movs	r2, #240	; 0xf0
 8012f98:	5c9b      	ldrb	r3, [r3, r2]
 8012f9a:	2b00      	cmp	r3, #0
 8012f9c:	d101      	bne.n	8012fa2 <CheckRetransUnconfirmedUplink+0x42>
        {
            return true;
 8012f9e:	2301      	movs	r3, #1
 8012fa0:	e007      	b.n	8012fb2 <CheckRetransUnconfirmedUplink+0x52>
        }
        else
        {// For Class B & C stop only if the frame was received in RX1 window
            if( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 )
 8012fa2:	4b05      	ldr	r3, [pc, #20]	; (8012fb8 <CheckRetransUnconfirmedUplink+0x58>)
 8012fa4:	4a07      	ldr	r2, [pc, #28]	; (8012fc4 <CheckRetransUnconfirmedUplink+0x64>)
 8012fa6:	5c9b      	ldrb	r3, [r3, r2]
 8012fa8:	2b00      	cmp	r3, #0
 8012faa:	d101      	bne.n	8012fb0 <CheckRetransUnconfirmedUplink+0x50>
            {
                return true;
 8012fac:	2301      	movs	r3, #1
 8012fae:	e000      	b.n	8012fb2 <CheckRetransUnconfirmedUplink+0x52>
            }
        }
    }
    return false;
 8012fb0:	2300      	movs	r3, #0
}
 8012fb2:	0018      	movs	r0, r3
 8012fb4:	46bd      	mov	sp, r7
 8012fb6:	bd80      	pop	{r7, pc}
 8012fb8:	200008ec 	.word	0x200008ec
 8012fbc:	00000484 	.word	0x00000484
 8012fc0:	00000481 	.word	0x00000481
 8012fc4:	0000042d 	.word	0x0000042d

08012fc8 <CheckRetransConfirmedUplink>:

static bool CheckRetransConfirmedUplink( void )
{
 8012fc8:	b580      	push	{r7, lr}
 8012fca:	af00      	add	r7, sp, #0
    // Confirmed uplink, when all retransmissions ( tries to get a ack ) are done.
    if( MacCtx.AckTimeoutRetriesCounter >=
 8012fcc:	4b0e      	ldr	r3, [pc, #56]	; (8013008 <CheckRetransConfirmedUplink+0x40>)
 8012fce:	4a0f      	ldr	r2, [pc, #60]	; (801300c <CheckRetransConfirmedUplink+0x44>)
 8012fd0:	5c9a      	ldrb	r2, [r3, r2]
        MacCtx.AckTimeoutRetries )
 8012fd2:	4b0d      	ldr	r3, [pc, #52]	; (8013008 <CheckRetransConfirmedUplink+0x40>)
 8012fd4:	490e      	ldr	r1, [pc, #56]	; (8013010 <CheckRetransConfirmedUplink+0x48>)
 8012fd6:	5c5b      	ldrb	r3, [r3, r1]
    if( MacCtx.AckTimeoutRetriesCounter >=
 8012fd8:	429a      	cmp	r2, r3
 8012fda:	d301      	bcc.n	8012fe0 <CheckRetransConfirmedUplink+0x18>
    {
        return true;
 8012fdc:	2301      	movs	r3, #1
 8012fde:	e010      	b.n	8013002 <CheckRetransConfirmedUplink+0x3a>
    }
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 8012fe0:	4b09      	ldr	r3, [pc, #36]	; (8013008 <CheckRetransConfirmedUplink+0x40>)
 8012fe2:	4a0c      	ldr	r2, [pc, #48]	; (8013014 <CheckRetransConfirmedUplink+0x4c>)
 8012fe4:	5c9b      	ldrb	r3, [r3, r2]
 8012fe6:	2202      	movs	r2, #2
 8012fe8:	4013      	ands	r3, r2
 8012fea:	b2db      	uxtb	r3, r3
 8012fec:	2b00      	cmp	r3, #0
 8012fee:	d007      	beq.n	8013000 <CheckRetransConfirmedUplink+0x38>
    {
        if( MacCtx.McpsConfirm.AckReceived == true )
 8012ff0:	4a05      	ldr	r2, [pc, #20]	; (8013008 <CheckRetransConfirmedUplink+0x40>)
 8012ff2:	2388      	movs	r3, #136	; 0x88
 8012ff4:	00db      	lsls	r3, r3, #3
 8012ff6:	5cd3      	ldrb	r3, [r2, r3]
 8012ff8:	2b00      	cmp	r3, #0
 8012ffa:	d001      	beq.n	8013000 <CheckRetransConfirmedUplink+0x38>
        {
            return true;
 8012ffc:	2301      	movs	r3, #1
 8012ffe:	e000      	b.n	8013002 <CheckRetransConfirmedUplink+0x3a>
        }
    }
    return false;
 8013000:	2300      	movs	r3, #0
}
 8013002:	0018      	movs	r0, r3
 8013004:	46bd      	mov	sp, r7
 8013006:	bd80      	pop	{r7, pc}
 8013008:	200008ec 	.word	0x200008ec
 801300c:	00000412 	.word	0x00000412
 8013010:	00000411 	.word	0x00000411
 8013014:	00000481 	.word	0x00000481

08013018 <StopRetransmission>:

static bool StopRetransmission( void )
{
 8013018:	b580      	push	{r7, lr}
 801301a:	af00      	add	r7, sp, #0
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 801301c:	4b1e      	ldr	r3, [pc, #120]	; (8013098 <StopRetransmission+0x80>)
 801301e:	4a1f      	ldr	r2, [pc, #124]	; (801309c <StopRetransmission+0x84>)
 8013020:	5c9b      	ldrb	r3, [r3, r2]
 8013022:	2202      	movs	r2, #2
 8013024:	4013      	ands	r3, r2
 8013026:	b2db      	uxtb	r3, r3
 8013028:	2b00      	cmp	r3, #0
 801302a:	d009      	beq.n	8013040 <StopRetransmission+0x28>
        ( ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_1 ) &&
 801302c:	4b1a      	ldr	r3, [pc, #104]	; (8013098 <StopRetransmission+0x80>)
 801302e:	4a1c      	ldr	r2, [pc, #112]	; (80130a0 <StopRetransmission+0x88>)
 8013030:	5c9b      	ldrb	r3, [r3, r2]
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 8013032:	2b00      	cmp	r3, #0
 8013034:	d013      	beq.n	801305e <StopRetransmission+0x46>
          ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_2 ) ) )
 8013036:	4b18      	ldr	r3, [pc, #96]	; (8013098 <StopRetransmission+0x80>)
 8013038:	4a19      	ldr	r2, [pc, #100]	; (80130a0 <StopRetransmission+0x88>)
 801303a:	5c9b      	ldrb	r3, [r3, r2]
        ( ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_1 ) &&
 801303c:	2b01      	cmp	r3, #1
 801303e:	d00e      	beq.n	801305e <StopRetransmission+0x46>
    {   // Maximum repetitions without downlink. Increase ADR Ack counter.
        // Only process the case when the MAC did not receive a downlink.
        if( MacCtx.NvmCtx->AdrCtrlOn == true )
 8013040:	4b15      	ldr	r3, [pc, #84]	; (8013098 <StopRetransmission+0x80>)
 8013042:	4a18      	ldr	r2, [pc, #96]	; (80130a4 <StopRetransmission+0x8c>)
 8013044:	589b      	ldr	r3, [r3, r2]
 8013046:	22f2      	movs	r2, #242	; 0xf2
 8013048:	5c9b      	ldrb	r3, [r3, r2]
 801304a:	2b00      	cmp	r3, #0
 801304c:	d007      	beq.n	801305e <StopRetransmission+0x46>
        {
            MacCtx.NvmCtx->AdrAckCounter++;
 801304e:	4b12      	ldr	r3, [pc, #72]	; (8013098 <StopRetransmission+0x80>)
 8013050:	4a14      	ldr	r2, [pc, #80]	; (80130a4 <StopRetransmission+0x8c>)
 8013052:	589b      	ldr	r3, [r3, r2]
 8013054:	22f4      	movs	r2, #244	; 0xf4
 8013056:	589a      	ldr	r2, [r3, r2]
 8013058:	3201      	adds	r2, #1
 801305a:	21f4      	movs	r1, #244	; 0xf4
 801305c:	505a      	str	r2, [r3, r1]
        }
    }

    MacCtx.ChannelsNbTransCounter = 0;
 801305e:	4a0e      	ldr	r2, [pc, #56]	; (8013098 <StopRetransmission+0x80>)
 8013060:	2382      	movs	r3, #130	; 0x82
 8013062:	00db      	lsls	r3, r3, #3
 8013064:	2100      	movs	r1, #0
 8013066:	54d1      	strb	r1, [r2, r3]
    MacCtx.NodeAckRequested = false;
 8013068:	4b0b      	ldr	r3, [pc, #44]	; (8013098 <StopRetransmission+0x80>)
 801306a:	4a0f      	ldr	r2, [pc, #60]	; (80130a8 <StopRetransmission+0x90>)
 801306c:	2100      	movs	r1, #0
 801306e:	5499      	strb	r1, [r3, r2]
    MacCtx.AckTimeoutRetry = false;
 8013070:	4b09      	ldr	r3, [pc, #36]	; (8013098 <StopRetransmission+0x80>)
 8013072:	4a0e      	ldr	r2, [pc, #56]	; (80130ac <StopRetransmission+0x94>)
 8013074:	2100      	movs	r1, #0
 8013076:	5499      	strb	r1, [r3, r2]
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8013078:	4a07      	ldr	r2, [pc, #28]	; (8013098 <StopRetransmission+0x80>)
 801307a:	23d0      	movs	r3, #208	; 0xd0
 801307c:	009b      	lsls	r3, r3, #2
 801307e:	58d3      	ldr	r3, [r2, r3]
 8013080:	2202      	movs	r2, #2
 8013082:	4393      	bics	r3, r2
 8013084:	0019      	movs	r1, r3
 8013086:	4a04      	ldr	r2, [pc, #16]	; (8013098 <StopRetransmission+0x80>)
 8013088:	23d0      	movs	r3, #208	; 0xd0
 801308a:	009b      	lsls	r3, r3, #2
 801308c:	50d1      	str	r1, [r2, r3]

    return true;
 801308e:	2301      	movs	r3, #1
}
 8013090:	0018      	movs	r0, r3
 8013092:	46bd      	mov	sp, r7
 8013094:	bd80      	pop	{r7, pc}
 8013096:	46c0      	nop			; (mov r8, r8)
 8013098:	200008ec 	.word	0x200008ec
 801309c:	00000481 	.word	0x00000481
 80130a0:	0000042d 	.word	0x0000042d
 80130a4:	00000484 	.word	0x00000484
 80130a8:	00000414 	.word	0x00000414
 80130ac:	00000413 	.word	0x00000413

080130b0 <AckTimeoutRetriesProcess>:

static void AckTimeoutRetriesProcess( void )
{
 80130b0:	b580      	push	{r7, lr}
 80130b2:	b082      	sub	sp, #8
 80130b4:	af00      	add	r7, sp, #0
    if( MacCtx.AckTimeoutRetriesCounter < MacCtx.AckTimeoutRetries )
 80130b6:	4b21      	ldr	r3, [pc, #132]	; (801313c <AckTimeoutRetriesProcess+0x8c>)
 80130b8:	4a21      	ldr	r2, [pc, #132]	; (8013140 <AckTimeoutRetriesProcess+0x90>)
 80130ba:	5c9a      	ldrb	r2, [r3, r2]
 80130bc:	4b1f      	ldr	r3, [pc, #124]	; (801313c <AckTimeoutRetriesProcess+0x8c>)
 80130be:	4921      	ldr	r1, [pc, #132]	; (8013144 <AckTimeoutRetriesProcess+0x94>)
 80130c0:	5c5b      	ldrb	r3, [r3, r1]
 80130c2:	429a      	cmp	r2, r3
 80130c4:	d236      	bcs.n	8013134 <AckTimeoutRetriesProcess+0x84>
    {
        MacCtx.AckTimeoutRetriesCounter++;
 80130c6:	4b1d      	ldr	r3, [pc, #116]	; (801313c <AckTimeoutRetriesProcess+0x8c>)
 80130c8:	4a1d      	ldr	r2, [pc, #116]	; (8013140 <AckTimeoutRetriesProcess+0x90>)
 80130ca:	5c9b      	ldrb	r3, [r3, r2]
 80130cc:	3301      	adds	r3, #1
 80130ce:	b2d9      	uxtb	r1, r3
 80130d0:	4b1a      	ldr	r3, [pc, #104]	; (801313c <AckTimeoutRetriesProcess+0x8c>)
 80130d2:	4a1b      	ldr	r2, [pc, #108]	; (8013140 <AckTimeoutRetriesProcess+0x90>)
 80130d4:	5499      	strb	r1, [r3, r2]
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 80130d6:	4b19      	ldr	r3, [pc, #100]	; (801313c <AckTimeoutRetriesProcess+0x8c>)
 80130d8:	4a19      	ldr	r2, [pc, #100]	; (8013140 <AckTimeoutRetriesProcess+0x90>)
 80130da:	5c9b      	ldrb	r3, [r3, r2]
 80130dc:	2201      	movs	r2, #1
 80130de:	4013      	ands	r3, r2
 80130e0:	b2db      	uxtb	r3, r3
 80130e2:	2b00      	cmp	r3, #0
 80130e4:	d026      	beq.n	8013134 <AckTimeoutRetriesProcess+0x84>
        {
            GetPhyParams_t getPhy;
            PhyParam_t phyParam;

            getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 80130e6:	1d3b      	adds	r3, r7, #4
 80130e8:	2222      	movs	r2, #34	; 0x22
 80130ea:	701a      	strb	r2, [r3, #0]
            getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;
 80130ec:	4b13      	ldr	r3, [pc, #76]	; (801313c <AckTimeoutRetriesProcess+0x8c>)
 80130ee:	4a16      	ldr	r2, [pc, #88]	; (8013148 <AckTimeoutRetriesProcess+0x98>)
 80130f0:	589a      	ldr	r2, [r3, r2]
 80130f2:	2396      	movs	r3, #150	; 0x96
 80130f4:	005b      	lsls	r3, r3, #1
 80130f6:	5cd2      	ldrb	r2, [r2, r3]
 80130f8:	1d3b      	adds	r3, r7, #4
 80130fa:	709a      	strb	r2, [r3, #2]
            getPhy.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;
 80130fc:	4b0f      	ldr	r3, [pc, #60]	; (801313c <AckTimeoutRetriesProcess+0x8c>)
 80130fe:	4a12      	ldr	r2, [pc, #72]	; (8013148 <AckTimeoutRetriesProcess+0x98>)
 8013100:	589b      	ldr	r3, [r3, r2]
 8013102:	22f9      	movs	r2, #249	; 0xf9
 8013104:	569a      	ldrsb	r2, [r3, r2]
 8013106:	1d3b      	adds	r3, r7, #4
 8013108:	705a      	strb	r2, [r3, #1]
            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 801310a:	4b0c      	ldr	r3, [pc, #48]	; (801313c <AckTimeoutRetriesProcess+0x8c>)
 801310c:	4a0e      	ldr	r2, [pc, #56]	; (8013148 <AckTimeoutRetriesProcess+0x98>)
 801310e:	589b      	ldr	r3, [r3, r2]
 8013110:	781b      	ldrb	r3, [r3, #0]
 8013112:	1d3a      	adds	r2, r7, #4
 8013114:	0011      	movs	r1, r2
 8013116:	0018      	movs	r0, r3
 8013118:	f004 fa01 	bl	801751e <RegionGetPhyParam>
 801311c:	0003      	movs	r3, r0
 801311e:	001a      	movs	r2, r3
 8013120:	003b      	movs	r3, r7
 8013122:	601a      	str	r2, [r3, #0]
            MacCtx.NvmCtx->MacParams.ChannelsDatarate = phyParam.Value;
 8013124:	003b      	movs	r3, r7
 8013126:	6819      	ldr	r1, [r3, #0]
 8013128:	4b04      	ldr	r3, [pc, #16]	; (801313c <AckTimeoutRetriesProcess+0x8c>)
 801312a:	4a07      	ldr	r2, [pc, #28]	; (8013148 <AckTimeoutRetriesProcess+0x98>)
 801312c:	589b      	ldr	r3, [r3, r2]
 801312e:	b249      	sxtb	r1, r1
 8013130:	22f9      	movs	r2, #249	; 0xf9
 8013132:	5499      	strb	r1, [r3, r2]
        }
    }
}
 8013134:	46c0      	nop			; (mov r8, r8)
 8013136:	46bd      	mov	sp, r7
 8013138:	b002      	add	sp, #8
 801313a:	bd80      	pop	{r7, pc}
 801313c:	200008ec 	.word	0x200008ec
 8013140:	00000412 	.word	0x00000412
 8013144:	00000411 	.word	0x00000411
 8013148:	00000484 	.word	0x00000484

0801314c <AckTimeoutRetriesFinalize>:

static void AckTimeoutRetriesFinalize( void )
{
 801314c:	b580      	push	{r7, lr}
 801314e:	b082      	sub	sp, #8
 8013150:	af00      	add	r7, sp, #0
    if( MacCtx.McpsConfirm.AckReceived == false )
 8013152:	4a16      	ldr	r2, [pc, #88]	; (80131ac <AckTimeoutRetriesFinalize+0x60>)
 8013154:	2388      	movs	r3, #136	; 0x88
 8013156:	00db      	lsls	r3, r3, #3
 8013158:	5cd3      	ldrb	r3, [r2, r3]
 801315a:	2201      	movs	r2, #1
 801315c:	4053      	eors	r3, r2
 801315e:	b2db      	uxtb	r3, r3
 8013160:	2b00      	cmp	r3, #0
 8013162:	d018      	beq.n	8013196 <AckTimeoutRetriesFinalize+0x4a>
    {
        InitDefaultsParams_t params;
        params.Type = INIT_TYPE_RESTORE_DEFAULT_CHANNELS;
 8013164:	003b      	movs	r3, r7
 8013166:	2201      	movs	r2, #1
 8013168:	711a      	strb	r2, [r3, #4]
        params.NvmCtx = Contexts.RegionNvmCtx;
 801316a:	4b11      	ldr	r3, [pc, #68]	; (80131b0 <AckTimeoutRetriesFinalize+0x64>)
 801316c:	689a      	ldr	r2, [r3, #8]
 801316e:	003b      	movs	r3, r7
 8013170:	601a      	str	r2, [r3, #0]
        RegionInitDefaults( MacCtx.NvmCtx->Region, &params );
 8013172:	4b0e      	ldr	r3, [pc, #56]	; (80131ac <AckTimeoutRetriesFinalize+0x60>)
 8013174:	4a0f      	ldr	r2, [pc, #60]	; (80131b4 <AckTimeoutRetriesFinalize+0x68>)
 8013176:	589b      	ldr	r3, [r3, r2]
 8013178:	781b      	ldrb	r3, [r3, #0]
 801317a:	003a      	movs	r2, r7
 801317c:	0011      	movs	r1, r2
 801317e:	0018      	movs	r0, r3
 8013180:	f004 fa09 	bl	8017596 <RegionInitDefaults>

        MacCtx.NodeAckRequested = false;
 8013184:	4b09      	ldr	r3, [pc, #36]	; (80131ac <AckTimeoutRetriesFinalize+0x60>)
 8013186:	4a0c      	ldr	r2, [pc, #48]	; (80131b8 <AckTimeoutRetriesFinalize+0x6c>)
 8013188:	2100      	movs	r1, #0
 801318a:	5499      	strb	r1, [r3, r2]
        MacCtx.McpsConfirm.AckReceived = false;
 801318c:	4a07      	ldr	r2, [pc, #28]	; (80131ac <AckTimeoutRetriesFinalize+0x60>)
 801318e:	2388      	movs	r3, #136	; 0x88
 8013190:	00db      	lsls	r3, r3, #3
 8013192:	2100      	movs	r1, #0
 8013194:	54d1      	strb	r1, [r2, r3]
    }
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 8013196:	4b05      	ldr	r3, [pc, #20]	; (80131ac <AckTimeoutRetriesFinalize+0x60>)
 8013198:	4a08      	ldr	r2, [pc, #32]	; (80131bc <AckTimeoutRetriesFinalize+0x70>)
 801319a:	5c99      	ldrb	r1, [r3, r2]
 801319c:	4b03      	ldr	r3, [pc, #12]	; (80131ac <AckTimeoutRetriesFinalize+0x60>)
 801319e:	4a08      	ldr	r2, [pc, #32]	; (80131c0 <AckTimeoutRetriesFinalize+0x74>)
 80131a0:	5499      	strb	r1, [r3, r2]
}
 80131a2:	46c0      	nop			; (mov r8, r8)
 80131a4:	46bd      	mov	sp, r7
 80131a6:	b002      	add	sp, #8
 80131a8:	bd80      	pop	{r7, pc}
 80131aa:	46c0      	nop			; (mov r8, r8)
 80131ac:	200008ec 	.word	0x200008ec
 80131b0:	200017f4 	.word	0x200017f4
 80131b4:	00000484 	.word	0x00000484
 80131b8:	00000414 	.word	0x00000414
 80131bc:	00000412 	.word	0x00000412
 80131c0:	00000441 	.word	0x00000441

080131c4 <CallNvmCtxCallback>:

static void CallNvmCtxCallback( LoRaMacNvmCtxModule_t module )
{
 80131c4:	b580      	push	{r7, lr}
 80131c6:	b082      	sub	sp, #8
 80131c8:	af00      	add	r7, sp, #0
 80131ca:	0002      	movs	r2, r0
 80131cc:	1dfb      	adds	r3, r7, #7
 80131ce:	701a      	strb	r2, [r3, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->NvmContextChange != NULL ) )
 80131d0:	4a0c      	ldr	r2, [pc, #48]	; (8013204 <CallNvmCtxCallback+0x40>)
 80131d2:	23d2      	movs	r3, #210	; 0xd2
 80131d4:	009b      	lsls	r3, r3, #2
 80131d6:	58d3      	ldr	r3, [r2, r3]
 80131d8:	2b00      	cmp	r3, #0
 80131da:	d00f      	beq.n	80131fc <CallNvmCtxCallback+0x38>
 80131dc:	4a09      	ldr	r2, [pc, #36]	; (8013204 <CallNvmCtxCallback+0x40>)
 80131de:	23d2      	movs	r3, #210	; 0xd2
 80131e0:	009b      	lsls	r3, r3, #2
 80131e2:	58d3      	ldr	r3, [r2, r3]
 80131e4:	689b      	ldr	r3, [r3, #8]
 80131e6:	2b00      	cmp	r3, #0
 80131e8:	d008      	beq.n	80131fc <CallNvmCtxCallback+0x38>
    {
        MacCtx.MacCallbacks->NvmContextChange( module );
 80131ea:	4a06      	ldr	r2, [pc, #24]	; (8013204 <CallNvmCtxCallback+0x40>)
 80131ec:	23d2      	movs	r3, #210	; 0xd2
 80131ee:	009b      	lsls	r3, r3, #2
 80131f0:	58d3      	ldr	r3, [r2, r3]
 80131f2:	689b      	ldr	r3, [r3, #8]
 80131f4:	1dfa      	adds	r2, r7, #7
 80131f6:	7812      	ldrb	r2, [r2, #0]
 80131f8:	0010      	movs	r0, r2
 80131fa:	4798      	blx	r3
    }
}
 80131fc:	46c0      	nop			; (mov r8, r8)
 80131fe:	46bd      	mov	sp, r7
 8013200:	b002      	add	sp, #8
 8013202:	bd80      	pop	{r7, pc}
 8013204:	200008ec 	.word	0x200008ec

08013208 <EventMacNvmCtxChanged>:

static void EventMacNvmCtxChanged( void )
{
 8013208:	b580      	push	{r7, lr}
 801320a:	af00      	add	r7, sp, #0
    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_MAC );
 801320c:	2000      	movs	r0, #0
 801320e:	f7ff ffd9 	bl	80131c4 <CallNvmCtxCallback>
}
 8013212:	46c0      	nop			; (mov r8, r8)
 8013214:	46bd      	mov	sp, r7
 8013216:	bd80      	pop	{r7, pc}

08013218 <EventRegionNvmCtxChanged>:

static void EventRegionNvmCtxChanged( void )
{
 8013218:	b580      	push	{r7, lr}
 801321a:	af00      	add	r7, sp, #0
    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_REGION );
 801321c:	2001      	movs	r0, #1
 801321e:	f7ff ffd1 	bl	80131c4 <CallNvmCtxCallback>
}
 8013222:	46c0      	nop			; (mov r8, r8)
 8013224:	46bd      	mov	sp, r7
 8013226:	bd80      	pop	{r7, pc}

08013228 <EventCryptoNvmCtxChanged>:

static void EventCryptoNvmCtxChanged( void )
{
 8013228:	b580      	push	{r7, lr}
 801322a:	af00      	add	r7, sp, #0
    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_CRYPTO );
 801322c:	2002      	movs	r0, #2
 801322e:	f7ff ffc9 	bl	80131c4 <CallNvmCtxCallback>
}
 8013232:	46c0      	nop			; (mov r8, r8)
 8013234:	46bd      	mov	sp, r7
 8013236:	bd80      	pop	{r7, pc}

08013238 <EventSecureElementNvmCtxChanged>:

static void EventSecureElementNvmCtxChanged( void )
{
 8013238:	b580      	push	{r7, lr}
 801323a:	af00      	add	r7, sp, #0
    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_SECURE_ELEMENT );
 801323c:	2003      	movs	r0, #3
 801323e:	f7ff ffc1 	bl	80131c4 <CallNvmCtxCallback>
}
 8013242:	46c0      	nop			; (mov r8, r8)
 8013244:	46bd      	mov	sp, r7
 8013246:	bd80      	pop	{r7, pc}

08013248 <EventCommandsNvmCtxChanged>:

static void EventCommandsNvmCtxChanged( void )
{
 8013248:	b580      	push	{r7, lr}
 801324a:	af00      	add	r7, sp, #0
    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_COMMANDS );
 801324c:	2004      	movs	r0, #4
 801324e:	f7ff ffb9 	bl	80131c4 <CallNvmCtxCallback>
}
 8013252:	46c0      	nop			; (mov r8, r8)
 8013254:	46bd      	mov	sp, r7
 8013256:	bd80      	pop	{r7, pc}

08013258 <EventClassBNvmCtxChanged>:

static void EventClassBNvmCtxChanged( void )
{
 8013258:	b580      	push	{r7, lr}
 801325a:	af00      	add	r7, sp, #0
    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_CLASS_B );
 801325c:	2005      	movs	r0, #5
 801325e:	f7ff ffb1 	bl	80131c4 <CallNvmCtxCallback>
}
 8013262:	46c0      	nop			; (mov r8, r8)
 8013264:	46bd      	mov	sp, r7
 8013266:	bd80      	pop	{r7, pc}

08013268 <EventConfirmQueueNvmCtxChanged>:

static void EventConfirmQueueNvmCtxChanged( void )
{
 8013268:	b580      	push	{r7, lr}
 801326a:	af00      	add	r7, sp, #0
    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_CONFIRM_QUEUE );
 801326c:	2006      	movs	r0, #6
 801326e:	f7ff ffa9 	bl	80131c4 <CallNvmCtxCallback>
}
 8013272:	46c0      	nop			; (mov r8, r8)
 8013274:	46bd      	mov	sp, r7
 8013276:	bd80      	pop	{r7, pc}

08013278 <IsRequestPending>:

static uint8_t IsRequestPending( void )
{
 8013278:	b580      	push	{r7, lr}
 801327a:	af00      	add	r7, sp, #0
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||
 801327c:	4b0a      	ldr	r3, [pc, #40]	; (80132a8 <IsRequestPending+0x30>)
 801327e:	4a0b      	ldr	r2, [pc, #44]	; (80132ac <IsRequestPending+0x34>)
 8013280:	5c9b      	ldrb	r3, [r3, r2]
 8013282:	2204      	movs	r2, #4
 8013284:	4013      	ands	r3, r2
 8013286:	b2db      	uxtb	r3, r3
 8013288:	2b00      	cmp	r3, #0
 801328a:	d107      	bne.n	801329c <IsRequestPending+0x24>
        ( MacCtx.MacFlags.Bits.McpsReq == 1 ) )
 801328c:	4b06      	ldr	r3, [pc, #24]	; (80132a8 <IsRequestPending+0x30>)
 801328e:	4a07      	ldr	r2, [pc, #28]	; (80132ac <IsRequestPending+0x34>)
 8013290:	5c9b      	ldrb	r3, [r3, r2]
 8013292:	2201      	movs	r2, #1
 8013294:	4013      	ands	r3, r2
 8013296:	b2db      	uxtb	r3, r3
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||
 8013298:	2b00      	cmp	r3, #0
 801329a:	d001      	beq.n	80132a0 <IsRequestPending+0x28>
    {
        return 1;
 801329c:	2301      	movs	r3, #1
 801329e:	e000      	b.n	80132a2 <IsRequestPending+0x2a>
    }
    return 0;
 80132a0:	2300      	movs	r3, #0
}
 80132a2:	0018      	movs	r0, r3
 80132a4:	46bd      	mov	sp, r7
 80132a6:	bd80      	pop	{r7, pc}
 80132a8:	200008ec 	.word	0x200008ec
 80132ac:	00000481 	.word	0x00000481

080132b0 <LoRaMacInitialization>:


LoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )
{
 80132b0:	b5b0      	push	{r4, r5, r7, lr}
 80132b2:	b094      	sub	sp, #80	; 0x50
 80132b4:	af00      	add	r7, sp, #0
 80132b6:	60f8      	str	r0, [r7, #12]
 80132b8:	60b9      	str	r1, [r7, #8]
 80132ba:	1dfb      	adds	r3, r7, #7
 80132bc:	701a      	strb	r2, [r3, #0]
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    LoRaMacClassBCallback_t classBCallbacks;
    LoRaMacClassBParams_t classBParams;

    if( ( primitives == NULL ) ||
 80132be:	68fb      	ldr	r3, [r7, #12]
 80132c0:	2b00      	cmp	r3, #0
 80132c2:	d002      	beq.n	80132ca <LoRaMacInitialization+0x1a>
 80132c4:	68bb      	ldr	r3, [r7, #8]
 80132c6:	2b00      	cmp	r3, #0
 80132c8:	d101      	bne.n	80132ce <LoRaMacInitialization+0x1e>
        ( callbacks == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 80132ca:	2303      	movs	r3, #3
 80132cc:	e35f      	b.n	801398e <LoRaMacInitialization+0x6de>
    }

    if( ( primitives->MacMcpsConfirm == NULL ) ||
 80132ce:	68fb      	ldr	r3, [r7, #12]
 80132d0:	681b      	ldr	r3, [r3, #0]
 80132d2:	2b00      	cmp	r3, #0
 80132d4:	d00b      	beq.n	80132ee <LoRaMacInitialization+0x3e>
        ( primitives->MacMcpsIndication == NULL ) ||
 80132d6:	68fb      	ldr	r3, [r7, #12]
 80132d8:	685b      	ldr	r3, [r3, #4]
    if( ( primitives->MacMcpsConfirm == NULL ) ||
 80132da:	2b00      	cmp	r3, #0
 80132dc:	d007      	beq.n	80132ee <LoRaMacInitialization+0x3e>
        ( primitives->MacMlmeConfirm == NULL ) ||
 80132de:	68fb      	ldr	r3, [r7, #12]
 80132e0:	689b      	ldr	r3, [r3, #8]
        ( primitives->MacMcpsIndication == NULL ) ||
 80132e2:	2b00      	cmp	r3, #0
 80132e4:	d003      	beq.n	80132ee <LoRaMacInitialization+0x3e>
        ( primitives->MacMlmeIndication == NULL ) )
 80132e6:	68fb      	ldr	r3, [r7, #12]
 80132e8:	68db      	ldr	r3, [r3, #12]
        ( primitives->MacMlmeConfirm == NULL ) ||
 80132ea:	2b00      	cmp	r3, #0
 80132ec:	d101      	bne.n	80132f2 <LoRaMacInitialization+0x42>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 80132ee:	2303      	movs	r3, #3
 80132f0:	e34d      	b.n	801398e <LoRaMacInitialization+0x6de>
    }
    // Verify if the region is supported
    if( RegionIsActive( region ) == false )
 80132f2:	1dfb      	adds	r3, r7, #7
 80132f4:	781b      	ldrb	r3, [r3, #0]
 80132f6:	0018      	movs	r0, r3
 80132f8:	f004 f900 	bl	80174fc <RegionIsActive>
 80132fc:	0003      	movs	r3, r0
 80132fe:	001a      	movs	r2, r3
 8013300:	2301      	movs	r3, #1
 8013302:	4053      	eors	r3, r2
 8013304:	b2db      	uxtb	r3, r3
 8013306:	2b00      	cmp	r3, #0
 8013308:	d001      	beq.n	801330e <LoRaMacInitialization+0x5e>
    {
        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
 801330a:	2309      	movs	r3, #9
 801330c:	e33f      	b.n	801398e <LoRaMacInitialization+0x6de>
    }

    // Confirm queue reset
    LoRaMacConfirmQueueInit( primitives, EventConfirmQueueNvmCtxChanged );
 801330e:	4afd      	ldr	r2, [pc, #1012]	; (8013704 <LoRaMacInitialization+0x454>)
 8013310:	68fb      	ldr	r3, [r7, #12]
 8013312:	0011      	movs	r1, r2
 8013314:	0018      	movs	r0, r3
 8013316:	f002 fa23 	bl	8015760 <LoRaMacConfirmQueueInit>

    // Initialize the module context with zeros
    memset1( ( uint8_t* ) &NvmMacCtx, 0x00, sizeof( LoRaMacNvmCtx_t ) );
 801331a:	23ee      	movs	r3, #238	; 0xee
 801331c:	005a      	lsls	r2, r3, #1
 801331e:	4bfa      	ldr	r3, [pc, #1000]	; (8013708 <LoRaMacInitialization+0x458>)
 8013320:	2100      	movs	r1, #0
 8013322:	0018      	movs	r0, r3
 8013324:	f008 f94e 	bl	801b5c4 <memset1>
    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );
 8013328:	2391      	movs	r3, #145	; 0x91
 801332a:	00da      	lsls	r2, r3, #3
 801332c:	4bf7      	ldr	r3, [pc, #988]	; (801370c <LoRaMacInitialization+0x45c>)
 801332e:	2100      	movs	r1, #0
 8013330:	0018      	movs	r0, r3
 8013332:	f008 f947 	bl	801b5c4 <memset1>
    MacCtx.NvmCtx = &NvmMacCtx;
 8013336:	4bf5      	ldr	r3, [pc, #980]	; (801370c <LoRaMacInitialization+0x45c>)
 8013338:	49f5      	ldr	r1, [pc, #980]	; (8013710 <LoRaMacInitialization+0x460>)
 801333a:	4af3      	ldr	r2, [pc, #972]	; (8013708 <LoRaMacInitialization+0x458>)
 801333c:	505a      	str	r2, [r3, r1]

    // Set non zero variables to its default value
    MacCtx.AckTimeoutRetriesCounter = 1;
 801333e:	4bf3      	ldr	r3, [pc, #972]	; (801370c <LoRaMacInitialization+0x45c>)
 8013340:	4af4      	ldr	r2, [pc, #976]	; (8013714 <LoRaMacInitialization+0x464>)
 8013342:	2101      	movs	r1, #1
 8013344:	5499      	strb	r1, [r3, r2]
    MacCtx.AckTimeoutRetries = 1;
 8013346:	4bf1      	ldr	r3, [pc, #964]	; (801370c <LoRaMacInitialization+0x45c>)
 8013348:	4af3      	ldr	r2, [pc, #972]	; (8013718 <LoRaMacInitialization+0x468>)
 801334a:	2101      	movs	r1, #1
 801334c:	5499      	strb	r1, [r3, r2]
    MacCtx.NvmCtx->Region = region;
 801334e:	4bef      	ldr	r3, [pc, #956]	; (801370c <LoRaMacInitialization+0x45c>)
 8013350:	4aef      	ldr	r2, [pc, #956]	; (8013710 <LoRaMacInitialization+0x460>)
 8013352:	589b      	ldr	r3, [r3, r2]
 8013354:	1dfa      	adds	r2, r7, #7
 8013356:	7812      	ldrb	r2, [r2, #0]
 8013358:	701a      	strb	r2, [r3, #0]
    MacCtx.NvmCtx->DeviceClass = CLASS_A;
 801335a:	4bec      	ldr	r3, [pc, #944]	; (801370c <LoRaMacInitialization+0x45c>)
 801335c:	4aec      	ldr	r2, [pc, #944]	; (8013710 <LoRaMacInitialization+0x460>)
 801335e:	589b      	ldr	r3, [r3, r2]
 8013360:	22f0      	movs	r2, #240	; 0xf0
 8013362:	2100      	movs	r1, #0
 8013364:	5499      	strb	r1, [r3, r2]
    MacCtx.NvmCtx->RepeaterSupport = false;
 8013366:	4be9      	ldr	r3, [pc, #932]	; (801370c <LoRaMacInitialization+0x45c>)
 8013368:	4ae9      	ldr	r2, [pc, #932]	; (8013710 <LoRaMacInitialization+0x460>)
 801336a:	589a      	ldr	r2, [r3, r2]
 801336c:	2340      	movs	r3, #64	; 0x40
 801336e:	33ff      	adds	r3, #255	; 0xff
 8013370:	2100      	movs	r1, #0
 8013372:	54d1      	strb	r1, [r2, r3]

    Version_t lrWanVersion;
    lrWanVersion.Fields.Major    = 1;
 8013374:	211c      	movs	r1, #28
 8013376:	187b      	adds	r3, r7, r1
 8013378:	2201      	movs	r2, #1
 801337a:	70da      	strb	r2, [r3, #3]
    lrWanVersion.Fields.Minor    = 0;
 801337c:	187b      	adds	r3, r7, r1
 801337e:	2200      	movs	r2, #0
 8013380:	709a      	strb	r2, [r3, #2]
    lrWanVersion.Fields.Revision = 3;
 8013382:	187b      	adds	r3, r7, r1
 8013384:	2203      	movs	r2, #3
 8013386:	705a      	strb	r2, [r3, #1]
    lrWanVersion.Fields.Rfu      = 0;
 8013388:	187b      	adds	r3, r7, r1
 801338a:	2200      	movs	r2, #0
 801338c:	701a      	strb	r2, [r3, #0]
    MacCtx.NvmCtx->Version = lrWanVersion;
 801338e:	4bdf      	ldr	r3, [pc, #892]	; (801370c <LoRaMacInitialization+0x45c>)
 8013390:	4adf      	ldr	r2, [pc, #892]	; (8013710 <LoRaMacInitialization+0x460>)
 8013392:	589a      	ldr	r2, [r3, r2]
 8013394:	23e8      	movs	r3, #232	; 0xe8
 8013396:	005b      	lsls	r3, r3, #1
 8013398:	69f9      	ldr	r1, [r7, #28]
 801339a:	50d1      	str	r1, [r2, r3]

    // Reset to defaults
    getPhy.Attribute = PHY_DUTY_CYCLE;
 801339c:	254c      	movs	r5, #76	; 0x4c
 801339e:	197b      	adds	r3, r7, r5
 80133a0:	220f      	movs	r2, #15
 80133a2:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 80133a4:	4bd9      	ldr	r3, [pc, #868]	; (801370c <LoRaMacInitialization+0x45c>)
 80133a6:	4ada      	ldr	r2, [pc, #872]	; (8013710 <LoRaMacInitialization+0x460>)
 80133a8:	589b      	ldr	r3, [r3, r2]
 80133aa:	781b      	ldrb	r3, [r3, #0]
 80133ac:	197a      	adds	r2, r7, r5
 80133ae:	0011      	movs	r1, r2
 80133b0:	0018      	movs	r0, r3
 80133b2:	f004 f8b4 	bl	801751e <RegionGetPhyParam>
 80133b6:	0003      	movs	r3, r0
 80133b8:	001a      	movs	r2, r3
 80133ba:	2448      	movs	r4, #72	; 0x48
 80133bc:	193b      	adds	r3, r7, r4
 80133be:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->DutyCycleOn = ( bool ) phyParam.Value;
 80133c0:	193b      	adds	r3, r7, r4
 80133c2:	681b      	ldr	r3, [r3, #0]
 80133c4:	4ad1      	ldr	r2, [pc, #836]	; (801370c <LoRaMacInitialization+0x45c>)
 80133c6:	49d2      	ldr	r1, [pc, #840]	; (8013710 <LoRaMacInitialization+0x460>)
 80133c8:	5852      	ldr	r2, [r2, r1]
 80133ca:	1e59      	subs	r1, r3, #1
 80133cc:	418b      	sbcs	r3, r1
 80133ce:	b2d9      	uxtb	r1, r3
 80133d0:	233e      	movs	r3, #62	; 0x3e
 80133d2:	33ff      	adds	r3, #255	; 0xff
 80133d4:	54d1      	strb	r1, [r2, r3]

    getPhy.Attribute = PHY_DEF_TX_POWER;
 80133d6:	197b      	adds	r3, r7, r5
 80133d8:	220a      	movs	r2, #10
 80133da:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 80133dc:	4bcb      	ldr	r3, [pc, #812]	; (801370c <LoRaMacInitialization+0x45c>)
 80133de:	4acc      	ldr	r2, [pc, #816]	; (8013710 <LoRaMacInitialization+0x460>)
 80133e0:	589b      	ldr	r3, [r3, r2]
 80133e2:	781b      	ldrb	r3, [r3, #0]
 80133e4:	197a      	adds	r2, r7, r5
 80133e6:	0011      	movs	r1, r2
 80133e8:	0018      	movs	r0, r3
 80133ea:	f004 f898 	bl	801751e <RegionGetPhyParam>
 80133ee:	0003      	movs	r3, r0
 80133f0:	001a      	movs	r2, r3
 80133f2:	193b      	adds	r3, r7, r4
 80133f4:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower = phyParam.Value;
 80133f6:	193b      	adds	r3, r7, r4
 80133f8:	6819      	ldr	r1, [r3, #0]
 80133fa:	4bc4      	ldr	r3, [pc, #784]	; (801370c <LoRaMacInitialization+0x45c>)
 80133fc:	4ac4      	ldr	r2, [pc, #784]	; (8013710 <LoRaMacInitialization+0x460>)
 80133fe:	589b      	ldr	r3, [r3, r2]
 8013400:	b24a      	sxtb	r2, r1
 8013402:	711a      	strb	r2, [r3, #4]

    getPhy.Attribute = PHY_DEF_TX_DR;
 8013404:	197b      	adds	r3, r7, r5
 8013406:	2206      	movs	r2, #6
 8013408:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 801340a:	4bc0      	ldr	r3, [pc, #768]	; (801370c <LoRaMacInitialization+0x45c>)
 801340c:	4ac0      	ldr	r2, [pc, #768]	; (8013710 <LoRaMacInitialization+0x460>)
 801340e:	589b      	ldr	r3, [r3, r2]
 8013410:	781b      	ldrb	r3, [r3, #0]
 8013412:	197a      	adds	r2, r7, r5
 8013414:	0011      	movs	r1, r2
 8013416:	0018      	movs	r0, r3
 8013418:	f004 f881 	bl	801751e <RegionGetPhyParam>
 801341c:	0003      	movs	r3, r0
 801341e:	001a      	movs	r2, r3
 8013420:	193b      	adds	r3, r7, r4
 8013422:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate = phyParam.Value;
 8013424:	193b      	adds	r3, r7, r4
 8013426:	6819      	ldr	r1, [r3, #0]
 8013428:	4bb8      	ldr	r3, [pc, #736]	; (801370c <LoRaMacInitialization+0x45c>)
 801342a:	4ab9      	ldr	r2, [pc, #740]	; (8013710 <LoRaMacInitialization+0x460>)
 801342c:	589b      	ldr	r3, [r3, r2]
 801342e:	b24a      	sxtb	r2, r1
 8013430:	715a      	strb	r2, [r3, #5]

    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 8013432:	197b      	adds	r3, r7, r5
 8013434:	2210      	movs	r2, #16
 8013436:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 8013438:	4bb4      	ldr	r3, [pc, #720]	; (801370c <LoRaMacInitialization+0x45c>)
 801343a:	4ab5      	ldr	r2, [pc, #724]	; (8013710 <LoRaMacInitialization+0x460>)
 801343c:	589b      	ldr	r3, [r3, r2]
 801343e:	781b      	ldrb	r3, [r3, #0]
 8013440:	197a      	adds	r2, r7, r5
 8013442:	0011      	movs	r1, r2
 8013444:	0018      	movs	r0, r3
 8013446:	f004 f86a 	bl	801751e <RegionGetPhyParam>
 801344a:	0003      	movs	r3, r0
 801344c:	001a      	movs	r2, r3
 801344e:	193b      	adds	r3, r7, r4
 8013450:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.MaxRxWindow = phyParam.Value;
 8013452:	4bae      	ldr	r3, [pc, #696]	; (801370c <LoRaMacInitialization+0x45c>)
 8013454:	4aae      	ldr	r2, [pc, #696]	; (8013710 <LoRaMacInitialization+0x460>)
 8013456:	589b      	ldr	r3, [r3, r2]
 8013458:	193a      	adds	r2, r7, r4
 801345a:	6812      	ldr	r2, [r2, #0]
 801345c:	611a      	str	r2, [r3, #16]

    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 801345e:	197b      	adds	r3, r7, r5
 8013460:	2211      	movs	r2, #17
 8013462:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 8013464:	4ba9      	ldr	r3, [pc, #676]	; (801370c <LoRaMacInitialization+0x45c>)
 8013466:	4aaa      	ldr	r2, [pc, #680]	; (8013710 <LoRaMacInitialization+0x460>)
 8013468:	589b      	ldr	r3, [r3, r2]
 801346a:	781b      	ldrb	r3, [r3, #0]
 801346c:	197a      	adds	r2, r7, r5
 801346e:	0011      	movs	r1, r2
 8013470:	0018      	movs	r0, r3
 8013472:	f004 f854 	bl	801751e <RegionGetPhyParam>
 8013476:	0003      	movs	r3, r0
 8013478:	001a      	movs	r2, r3
 801347a:	193b      	adds	r3, r7, r4
 801347c:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay1 = phyParam.Value;
 801347e:	4ba3      	ldr	r3, [pc, #652]	; (801370c <LoRaMacInitialization+0x45c>)
 8013480:	4aa3      	ldr	r2, [pc, #652]	; (8013710 <LoRaMacInitialization+0x460>)
 8013482:	589b      	ldr	r3, [r3, r2]
 8013484:	193a      	adds	r2, r7, r4
 8013486:	6812      	ldr	r2, [r2, #0]
 8013488:	615a      	str	r2, [r3, #20]

    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 801348a:	197b      	adds	r3, r7, r5
 801348c:	2212      	movs	r2, #18
 801348e:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 8013490:	4b9e      	ldr	r3, [pc, #632]	; (801370c <LoRaMacInitialization+0x45c>)
 8013492:	4a9f      	ldr	r2, [pc, #636]	; (8013710 <LoRaMacInitialization+0x460>)
 8013494:	589b      	ldr	r3, [r3, r2]
 8013496:	781b      	ldrb	r3, [r3, #0]
 8013498:	197a      	adds	r2, r7, r5
 801349a:	0011      	movs	r1, r2
 801349c:	0018      	movs	r0, r3
 801349e:	f004 f83e 	bl	801751e <RegionGetPhyParam>
 80134a2:	0003      	movs	r3, r0
 80134a4:	001a      	movs	r2, r3
 80134a6:	193b      	adds	r3, r7, r4
 80134a8:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay2 = phyParam.Value;
 80134aa:	4b98      	ldr	r3, [pc, #608]	; (801370c <LoRaMacInitialization+0x45c>)
 80134ac:	4a98      	ldr	r2, [pc, #608]	; (8013710 <LoRaMacInitialization+0x460>)
 80134ae:	589b      	ldr	r3, [r3, r2]
 80134b0:	193a      	adds	r2, r7, r4
 80134b2:	6812      	ldr	r2, [r2, #0]
 80134b4:	619a      	str	r2, [r3, #24]

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 80134b6:	197b      	adds	r3, r7, r5
 80134b8:	2213      	movs	r2, #19
 80134ba:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 80134bc:	4b93      	ldr	r3, [pc, #588]	; (801370c <LoRaMacInitialization+0x45c>)
 80134be:	4a94      	ldr	r2, [pc, #592]	; (8013710 <LoRaMacInitialization+0x460>)
 80134c0:	589b      	ldr	r3, [r3, r2]
 80134c2:	781b      	ldrb	r3, [r3, #0]
 80134c4:	197a      	adds	r2, r7, r5
 80134c6:	0011      	movs	r1, r2
 80134c8:	0018      	movs	r0, r3
 80134ca:	f004 f828 	bl	801751e <RegionGetPhyParam>
 80134ce:	0003      	movs	r3, r0
 80134d0:	001a      	movs	r2, r3
 80134d2:	193b      	adds	r3, r7, r4
 80134d4:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;
 80134d6:	4b8d      	ldr	r3, [pc, #564]	; (801370c <LoRaMacInitialization+0x45c>)
 80134d8:	4a8d      	ldr	r2, [pc, #564]	; (8013710 <LoRaMacInitialization+0x460>)
 80134da:	589b      	ldr	r3, [r3, r2]
 80134dc:	193a      	adds	r2, r7, r4
 80134de:	6812      	ldr	r2, [r2, #0]
 80134e0:	61da      	str	r2, [r3, #28]

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 80134e2:	197b      	adds	r3, r7, r5
 80134e4:	2214      	movs	r2, #20
 80134e6:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 80134e8:	4b88      	ldr	r3, [pc, #544]	; (801370c <LoRaMacInitialization+0x45c>)
 80134ea:	4a89      	ldr	r2, [pc, #548]	; (8013710 <LoRaMacInitialization+0x460>)
 80134ec:	589b      	ldr	r3, [r3, r2]
 80134ee:	781b      	ldrb	r3, [r3, #0]
 80134f0:	197a      	adds	r2, r7, r5
 80134f2:	0011      	movs	r1, r2
 80134f4:	0018      	movs	r0, r3
 80134f6:	f004 f812 	bl	801751e <RegionGetPhyParam>
 80134fa:	0003      	movs	r3, r0
 80134fc:	001a      	movs	r2, r3
 80134fe:	193b      	adds	r3, r7, r4
 8013500:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;
 8013502:	4b82      	ldr	r3, [pc, #520]	; (801370c <LoRaMacInitialization+0x45c>)
 8013504:	4a82      	ldr	r2, [pc, #520]	; (8013710 <LoRaMacInitialization+0x460>)
 8013506:	589b      	ldr	r3, [r3, r2]
 8013508:	193a      	adds	r2, r7, r4
 801350a:	6812      	ldr	r2, [r2, #0]
 801350c:	621a      	str	r2, [r3, #32]

    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 801350e:	197b      	adds	r3, r7, r5
 8013510:	2217      	movs	r2, #23
 8013512:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 8013514:	4b7d      	ldr	r3, [pc, #500]	; (801370c <LoRaMacInitialization+0x45c>)
 8013516:	4a7e      	ldr	r2, [pc, #504]	; (8013710 <LoRaMacInitialization+0x460>)
 8013518:	589b      	ldr	r3, [r3, r2]
 801351a:	781b      	ldrb	r3, [r3, #0]
 801351c:	197a      	adds	r2, r7, r5
 801351e:	0011      	movs	r1, r2
 8013520:	0018      	movs	r0, r3
 8013522:	f003 fffc 	bl	801751e <RegionGetPhyParam>
 8013526:	0003      	movs	r3, r0
 8013528:	001a      	movs	r2, r3
 801352a:	193b      	adds	r3, r7, r4
 801352c:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.Rx1DrOffset = phyParam.Value;
 801352e:	193b      	adds	r3, r7, r4
 8013530:	6819      	ldr	r1, [r3, #0]
 8013532:	4b76      	ldr	r3, [pc, #472]	; (801370c <LoRaMacInitialization+0x45c>)
 8013534:	4a76      	ldr	r2, [pc, #472]	; (8013710 <LoRaMacInitialization+0x460>)
 8013536:	589b      	ldr	r3, [r3, r2]
 8013538:	b2c9      	uxtb	r1, r1
 801353a:	2225      	movs	r2, #37	; 0x25
 801353c:	5499      	strb	r1, [r3, r2]

    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 801353e:	197b      	adds	r3, r7, r5
 8013540:	2218      	movs	r2, #24
 8013542:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 8013544:	4b71      	ldr	r3, [pc, #452]	; (801370c <LoRaMacInitialization+0x45c>)
 8013546:	4a72      	ldr	r2, [pc, #456]	; (8013710 <LoRaMacInitialization+0x460>)
 8013548:	589b      	ldr	r3, [r3, r2]
 801354a:	781b      	ldrb	r3, [r3, #0]
 801354c:	197a      	adds	r2, r7, r5
 801354e:	0011      	movs	r1, r2
 8013550:	0018      	movs	r0, r3
 8013552:	f003 ffe4 	bl	801751e <RegionGetPhyParam>
 8013556:	0003      	movs	r3, r0
 8013558:	001a      	movs	r2, r3
 801355a:	193b      	adds	r3, r7, r4
 801355c:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
 801355e:	4b6b      	ldr	r3, [pc, #428]	; (801370c <LoRaMacInitialization+0x45c>)
 8013560:	4a6b      	ldr	r2, [pc, #428]	; (8013710 <LoRaMacInitialization+0x460>)
 8013562:	589b      	ldr	r3, [r3, r2]
 8013564:	193a      	adds	r2, r7, r4
 8013566:	6812      	ldr	r2, [r2, #0]
 8013568:	629a      	str	r2, [r3, #40]	; 0x28
    MacCtx.NvmCtx->MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;
 801356a:	4b68      	ldr	r3, [pc, #416]	; (801370c <LoRaMacInitialization+0x45c>)
 801356c:	4a68      	ldr	r2, [pc, #416]	; (8013710 <LoRaMacInitialization+0x460>)
 801356e:	589b      	ldr	r3, [r3, r2]
 8013570:	193a      	adds	r2, r7, r4
 8013572:	6812      	ldr	r2, [r2, #0]
 8013574:	631a      	str	r2, [r3, #48]	; 0x30

    getPhy.Attribute = PHY_DEF_RX2_DR;
 8013576:	197b      	adds	r3, r7, r5
 8013578:	2219      	movs	r2, #25
 801357a:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 801357c:	4b63      	ldr	r3, [pc, #396]	; (801370c <LoRaMacInitialization+0x45c>)
 801357e:	4a64      	ldr	r2, [pc, #400]	; (8013710 <LoRaMacInitialization+0x460>)
 8013580:	589b      	ldr	r3, [r3, r2]
 8013582:	781b      	ldrb	r3, [r3, #0]
 8013584:	197a      	adds	r2, r7, r5
 8013586:	0011      	movs	r1, r2
 8013588:	0018      	movs	r0, r3
 801358a:	f003 ffc8 	bl	801751e <RegionGetPhyParam>
 801358e:	0003      	movs	r3, r0
 8013590:	001a      	movs	r2, r3
 8013592:	193b      	adds	r3, r7, r4
 8013594:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 8013596:	193b      	adds	r3, r7, r4
 8013598:	6819      	ldr	r1, [r3, #0]
 801359a:	4b5c      	ldr	r3, [pc, #368]	; (801370c <LoRaMacInitialization+0x45c>)
 801359c:	4a5c      	ldr	r2, [pc, #368]	; (8013710 <LoRaMacInitialization+0x460>)
 801359e:	589b      	ldr	r3, [r3, r2]
 80135a0:	b2c9      	uxtb	r1, r1
 80135a2:	222c      	movs	r2, #44	; 0x2c
 80135a4:	5499      	strb	r1, [r3, r2]
    MacCtx.NvmCtx->MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;
 80135a6:	193b      	adds	r3, r7, r4
 80135a8:	6819      	ldr	r1, [r3, #0]
 80135aa:	4b58      	ldr	r3, [pc, #352]	; (801370c <LoRaMacInitialization+0x45c>)
 80135ac:	4a58      	ldr	r2, [pc, #352]	; (8013710 <LoRaMacInitialization+0x460>)
 80135ae:	589b      	ldr	r3, [r3, r2]
 80135b0:	b2c9      	uxtb	r1, r1
 80135b2:	2234      	movs	r2, #52	; 0x34
 80135b4:	5499      	strb	r1, [r3, r2]

    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 80135b6:	197b      	adds	r3, r7, r5
 80135b8:	221e      	movs	r2, #30
 80135ba:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 80135bc:	4b53      	ldr	r3, [pc, #332]	; (801370c <LoRaMacInitialization+0x45c>)
 80135be:	4a54      	ldr	r2, [pc, #336]	; (8013710 <LoRaMacInitialization+0x460>)
 80135c0:	589b      	ldr	r3, [r3, r2]
 80135c2:	781b      	ldrb	r3, [r3, #0]
 80135c4:	197a      	adds	r2, r7, r5
 80135c6:	0011      	movs	r1, r2
 80135c8:	0018      	movs	r0, r3
 80135ca:	f003 ffa8 	bl	801751e <RegionGetPhyParam>
 80135ce:	0003      	movs	r3, r0
 80135d0:	001a      	movs	r2, r3
 80135d2:	193b      	adds	r3, r7, r4
 80135d4:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.UplinkDwellTime = phyParam.Value;
 80135d6:	193b      	adds	r3, r7, r4
 80135d8:	6819      	ldr	r1, [r3, #0]
 80135da:	4b4c      	ldr	r3, [pc, #304]	; (801370c <LoRaMacInitialization+0x45c>)
 80135dc:	4a4c      	ldr	r2, [pc, #304]	; (8013710 <LoRaMacInitialization+0x460>)
 80135de:	589b      	ldr	r3, [r3, r2]
 80135e0:	b2c9      	uxtb	r1, r1
 80135e2:	2238      	movs	r2, #56	; 0x38
 80135e4:	5499      	strb	r1, [r3, r2]

    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 80135e6:	197b      	adds	r3, r7, r5
 80135e8:	221f      	movs	r2, #31
 80135ea:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 80135ec:	4b47      	ldr	r3, [pc, #284]	; (801370c <LoRaMacInitialization+0x45c>)
 80135ee:	4a48      	ldr	r2, [pc, #288]	; (8013710 <LoRaMacInitialization+0x460>)
 80135f0:	589b      	ldr	r3, [r3, r2]
 80135f2:	781b      	ldrb	r3, [r3, #0]
 80135f4:	197a      	adds	r2, r7, r5
 80135f6:	0011      	movs	r1, r2
 80135f8:	0018      	movs	r0, r3
 80135fa:	f003 ff90 	bl	801751e <RegionGetPhyParam>
 80135fe:	0003      	movs	r3, r0
 8013600:	001a      	movs	r2, r3
 8013602:	193b      	adds	r3, r7, r4
 8013604:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.DownlinkDwellTime = phyParam.Value;
 8013606:	193b      	adds	r3, r7, r4
 8013608:	6819      	ldr	r1, [r3, #0]
 801360a:	4b40      	ldr	r3, [pc, #256]	; (801370c <LoRaMacInitialization+0x45c>)
 801360c:	4a40      	ldr	r2, [pc, #256]	; (8013710 <LoRaMacInitialization+0x460>)
 801360e:	589b      	ldr	r3, [r3, r2]
 8013610:	b2c9      	uxtb	r1, r1
 8013612:	2239      	movs	r2, #57	; 0x39
 8013614:	5499      	strb	r1, [r3, r2]

    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 8013616:	197b      	adds	r3, r7, r5
 8013618:	2220      	movs	r2, #32
 801361a:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 801361c:	4b3b      	ldr	r3, [pc, #236]	; (801370c <LoRaMacInitialization+0x45c>)
 801361e:	4a3c      	ldr	r2, [pc, #240]	; (8013710 <LoRaMacInitialization+0x460>)
 8013620:	589b      	ldr	r3, [r3, r2]
 8013622:	781b      	ldrb	r3, [r3, #0]
 8013624:	197a      	adds	r2, r7, r5
 8013626:	0011      	movs	r1, r2
 8013628:	0018      	movs	r0, r3
 801362a:	f003 ff78 	bl	801751e <RegionGetPhyParam>
 801362e:	0003      	movs	r3, r0
 8013630:	001a      	movs	r2, r3
 8013632:	193b      	adds	r3, r7, r4
 8013634:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.MaxEirp = phyParam.fValue;
 8013636:	4b35      	ldr	r3, [pc, #212]	; (801370c <LoRaMacInitialization+0x45c>)
 8013638:	4a35      	ldr	r2, [pc, #212]	; (8013710 <LoRaMacInitialization+0x460>)
 801363a:	589b      	ldr	r3, [r3, r2]
 801363c:	193a      	adds	r2, r7, r4
 801363e:	6812      	ldr	r2, [r2, #0]
 8013640:	63da      	str	r2, [r3, #60]	; 0x3c

    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 8013642:	197b      	adds	r3, r7, r5
 8013644:	2221      	movs	r2, #33	; 0x21
 8013646:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 8013648:	4b30      	ldr	r3, [pc, #192]	; (801370c <LoRaMacInitialization+0x45c>)
 801364a:	4a31      	ldr	r2, [pc, #196]	; (8013710 <LoRaMacInitialization+0x460>)
 801364c:	589b      	ldr	r3, [r3, r2]
 801364e:	781b      	ldrb	r3, [r3, #0]
 8013650:	197a      	adds	r2, r7, r5
 8013652:	0011      	movs	r1, r2
 8013654:	0018      	movs	r0, r3
 8013656:	f003 ff62 	bl	801751e <RegionGetPhyParam>
 801365a:	0003      	movs	r3, r0
 801365c:	001a      	movs	r2, r3
 801365e:	193b      	adds	r3, r7, r4
 8013660:	601a      	str	r2, [r3, #0]
    MacCtx.NvmCtx->MacParamsDefaults.AntennaGain = phyParam.fValue;
 8013662:	4b2a      	ldr	r3, [pc, #168]	; (801370c <LoRaMacInitialization+0x45c>)
 8013664:	4a2a      	ldr	r2, [pc, #168]	; (8013710 <LoRaMacInitialization+0x460>)
 8013666:	589b      	ldr	r3, [r3, r2]
 8013668:	193a      	adds	r2, r7, r4
 801366a:	6812      	ldr	r2, [r2, #0]
 801366c:	641a      	str	r2, [r3, #64]	; 0x40

    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 801366e:	197b      	adds	r3, r7, r5
 8013670:	220b      	movs	r2, #11
 8013672:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 8013674:	4b25      	ldr	r3, [pc, #148]	; (801370c <LoRaMacInitialization+0x45c>)
 8013676:	4a26      	ldr	r2, [pc, #152]	; (8013710 <LoRaMacInitialization+0x460>)
 8013678:	589b      	ldr	r3, [r3, r2]
 801367a:	781b      	ldrb	r3, [r3, #0]
 801367c:	197a      	adds	r2, r7, r5
 801367e:	0011      	movs	r1, r2
 8013680:	0018      	movs	r0, r3
 8013682:	f003 ff4c 	bl	801751e <RegionGetPhyParam>
 8013686:	0003      	movs	r3, r0
 8013688:	001a      	movs	r2, r3
 801368a:	193b      	adds	r3, r7, r4
 801368c:	601a      	str	r2, [r3, #0]
    MacCtx.AdrAckLimit = phyParam.Value;
 801368e:	193b      	adds	r3, r7, r4
 8013690:	681b      	ldr	r3, [r3, #0]
 8013692:	b299      	uxth	r1, r3
 8013694:	4a1d      	ldr	r2, [pc, #116]	; (801370c <LoRaMacInitialization+0x45c>)
 8013696:	23fd      	movs	r3, #253	; 0xfd
 8013698:	009b      	lsls	r3, r3, #2
 801369a:	52d1      	strh	r1, [r2, r3]

    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 801369c:	197b      	adds	r3, r7, r5
 801369e:	220c      	movs	r2, #12
 80136a0:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 80136a2:	4b1a      	ldr	r3, [pc, #104]	; (801370c <LoRaMacInitialization+0x45c>)
 80136a4:	4a1a      	ldr	r2, [pc, #104]	; (8013710 <LoRaMacInitialization+0x460>)
 80136a6:	589b      	ldr	r3, [r3, r2]
 80136a8:	781b      	ldrb	r3, [r3, #0]
 80136aa:	197a      	adds	r2, r7, r5
 80136ac:	0011      	movs	r1, r2
 80136ae:	0018      	movs	r0, r3
 80136b0:	f003 ff35 	bl	801751e <RegionGetPhyParam>
 80136b4:	0003      	movs	r3, r0
 80136b6:	001a      	movs	r2, r3
 80136b8:	193b      	adds	r3, r7, r4
 80136ba:	601a      	str	r2, [r3, #0]
    MacCtx.AdrAckDelay = phyParam.Value;
 80136bc:	193b      	adds	r3, r7, r4
 80136be:	681b      	ldr	r3, [r3, #0]
 80136c0:	b299      	uxth	r1, r3
 80136c2:	4b12      	ldr	r3, [pc, #72]	; (801370c <LoRaMacInitialization+0x45c>)
 80136c4:	4a15      	ldr	r2, [pc, #84]	; (801371c <LoRaMacInitialization+0x46c>)
 80136c6:	5299      	strh	r1, [r3, r2]

    // Init parameters which are not set in function ResetMacParameters
    MacCtx.NvmCtx->MacParamsDefaults.ChannelsNbTrans = 1;
 80136c8:	4b10      	ldr	r3, [pc, #64]	; (801370c <LoRaMacInitialization+0x45c>)
 80136ca:	4a11      	ldr	r2, [pc, #68]	; (8013710 <LoRaMacInitialization+0x460>)
 80136cc:	589b      	ldr	r3, [r3, r2]
 80136ce:	2224      	movs	r2, #36	; 0x24
 80136d0:	2101      	movs	r1, #1
 80136d2:	5499      	strb	r1, [r3, r2]
    MacCtx.NvmCtx->MacParamsDefaults.SystemMaxRxError = 20;
 80136d4:	4b0d      	ldr	r3, [pc, #52]	; (801370c <LoRaMacInitialization+0x45c>)
 80136d6:	4a0e      	ldr	r2, [pc, #56]	; (8013710 <LoRaMacInitialization+0x460>)
 80136d8:	589b      	ldr	r3, [r3, r2]
 80136da:	2214      	movs	r2, #20
 80136dc:	609a      	str	r2, [r3, #8]
    MacCtx.NvmCtx->MacParamsDefaults.MinRxSymbols = 6;
 80136de:	4b0b      	ldr	r3, [pc, #44]	; (801370c <LoRaMacInitialization+0x45c>)
 80136e0:	4a0b      	ldr	r2, [pc, #44]	; (8013710 <LoRaMacInitialization+0x460>)
 80136e2:	589b      	ldr	r3, [r3, r2]
 80136e4:	2206      	movs	r2, #6
 80136e6:	731a      	strb	r2, [r3, #12]

    MacCtx.NvmCtx->MacParams.SystemMaxRxError = MacCtx.NvmCtx->MacParamsDefaults.SystemMaxRxError;
 80136e8:	4b08      	ldr	r3, [pc, #32]	; (801370c <LoRaMacInitialization+0x45c>)
 80136ea:	4a09      	ldr	r2, [pc, #36]	; (8013710 <LoRaMacInitialization+0x460>)
 80136ec:	589b      	ldr	r3, [r3, r2]
 80136ee:	4a07      	ldr	r2, [pc, #28]	; (801370c <LoRaMacInitialization+0x45c>)
 80136f0:	4907      	ldr	r1, [pc, #28]	; (8013710 <LoRaMacInitialization+0x460>)
 80136f2:	5852      	ldr	r2, [r2, r1]
 80136f4:	689b      	ldr	r3, [r3, #8]
 80136f6:	21fc      	movs	r1, #252	; 0xfc
 80136f8:	5053      	str	r3, [r2, r1]
    MacCtx.NvmCtx->MacParams.MinRxSymbols = MacCtx.NvmCtx->MacParamsDefaults.MinRxSymbols;
 80136fa:	4b04      	ldr	r3, [pc, #16]	; (801370c <LoRaMacInitialization+0x45c>)
 80136fc:	4a04      	ldr	r2, [pc, #16]	; (8013710 <LoRaMacInitialization+0x460>)
 80136fe:	589b      	ldr	r3, [r3, r2]
 8013700:	4a02      	ldr	r2, [pc, #8]	; (801370c <LoRaMacInitialization+0x45c>)
 8013702:	e00d      	b.n	8013720 <LoRaMacInitialization+0x470>
 8013704:	08013269 	.word	0x08013269
 8013708:	20000d74 	.word	0x20000d74
 801370c:	200008ec 	.word	0x200008ec
 8013710:	00000484 	.word	0x00000484
 8013714:	00000412 	.word	0x00000412
 8013718:	00000411 	.word	0x00000411
 801371c:	000003f6 	.word	0x000003f6
 8013720:	499d      	ldr	r1, [pc, #628]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013722:	5852      	ldr	r2, [r2, r1]
 8013724:	7b19      	ldrb	r1, [r3, #12]
 8013726:	2380      	movs	r3, #128	; 0x80
 8013728:	005b      	lsls	r3, r3, #1
 801372a:	54d1      	strb	r1, [r2, r3]
    MacCtx.NvmCtx->MacParams.MaxRxWindow = MacCtx.NvmCtx->MacParamsDefaults.MaxRxWindow;
 801372c:	4b9b      	ldr	r3, [pc, #620]	; (801399c <LoRaMacInitialization+0x6ec>)
 801372e:	4a9a      	ldr	r2, [pc, #616]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013730:	589b      	ldr	r3, [r3, r2]
 8013732:	4a9a      	ldr	r2, [pc, #616]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013734:	4998      	ldr	r1, [pc, #608]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013736:	5852      	ldr	r2, [r2, r1]
 8013738:	6919      	ldr	r1, [r3, #16]
 801373a:	2382      	movs	r3, #130	; 0x82
 801373c:	005b      	lsls	r3, r3, #1
 801373e:	50d1      	str	r1, [r2, r3]
    MacCtx.NvmCtx->MacParams.ReceiveDelay1 = MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay1;
 8013740:	4b96      	ldr	r3, [pc, #600]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013742:	4a95      	ldr	r2, [pc, #596]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013744:	589b      	ldr	r3, [r3, r2]
 8013746:	4a95      	ldr	r2, [pc, #596]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013748:	4993      	ldr	r1, [pc, #588]	; (8013998 <LoRaMacInitialization+0x6e8>)
 801374a:	5852      	ldr	r2, [r2, r1]
 801374c:	6959      	ldr	r1, [r3, #20]
 801374e:	2384      	movs	r3, #132	; 0x84
 8013750:	005b      	lsls	r3, r3, #1
 8013752:	50d1      	str	r1, [r2, r3]
    MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay2;
 8013754:	4b91      	ldr	r3, [pc, #580]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013756:	4a90      	ldr	r2, [pc, #576]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013758:	589b      	ldr	r3, [r3, r2]
 801375a:	4a90      	ldr	r2, [pc, #576]	; (801399c <LoRaMacInitialization+0x6ec>)
 801375c:	498e      	ldr	r1, [pc, #568]	; (8013998 <LoRaMacInitialization+0x6e8>)
 801375e:	5852      	ldr	r2, [r2, r1]
 8013760:	6999      	ldr	r1, [r3, #24]
 8013762:	2386      	movs	r3, #134	; 0x86
 8013764:	005b      	lsls	r3, r3, #1
 8013766:	50d1      	str	r1, [r2, r3]
    MacCtx.NvmCtx->MacParams.JoinAcceptDelay1 = MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay1;
 8013768:	4b8c      	ldr	r3, [pc, #560]	; (801399c <LoRaMacInitialization+0x6ec>)
 801376a:	4a8b      	ldr	r2, [pc, #556]	; (8013998 <LoRaMacInitialization+0x6e8>)
 801376c:	589b      	ldr	r3, [r3, r2]
 801376e:	4a8b      	ldr	r2, [pc, #556]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013770:	4989      	ldr	r1, [pc, #548]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013772:	5852      	ldr	r2, [r2, r1]
 8013774:	69d9      	ldr	r1, [r3, #28]
 8013776:	2388      	movs	r3, #136	; 0x88
 8013778:	005b      	lsls	r3, r3, #1
 801377a:	50d1      	str	r1, [r2, r3]
    MacCtx.NvmCtx->MacParams.JoinAcceptDelay2 = MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay2;
 801377c:	4b87      	ldr	r3, [pc, #540]	; (801399c <LoRaMacInitialization+0x6ec>)
 801377e:	4a86      	ldr	r2, [pc, #536]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013780:	589b      	ldr	r3, [r3, r2]
 8013782:	4a86      	ldr	r2, [pc, #536]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013784:	4984      	ldr	r1, [pc, #528]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013786:	5852      	ldr	r2, [r2, r1]
 8013788:	6a19      	ldr	r1, [r3, #32]
 801378a:	238a      	movs	r3, #138	; 0x8a
 801378c:	005b      	lsls	r3, r3, #1
 801378e:	50d1      	str	r1, [r2, r3]
    MacCtx.NvmCtx->MacParams.ChannelsNbTrans = MacCtx.NvmCtx->MacParamsDefaults.ChannelsNbTrans;
 8013790:	4b82      	ldr	r3, [pc, #520]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013792:	4a81      	ldr	r2, [pc, #516]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013794:	589b      	ldr	r3, [r3, r2]
 8013796:	4a81      	ldr	r2, [pc, #516]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013798:	497f      	ldr	r1, [pc, #508]	; (8013998 <LoRaMacInitialization+0x6e8>)
 801379a:	5852      	ldr	r2, [r2, r1]
 801379c:	2124      	movs	r1, #36	; 0x24
 801379e:	5c59      	ldrb	r1, [r3, r1]
 80137a0:	238c      	movs	r3, #140	; 0x8c
 80137a2:	005b      	lsls	r3, r3, #1
 80137a4:	54d1      	strb	r1, [r2, r3]

    ResetMacParameters( );
 80137a6:	f7fe fec7 	bl	8012538 <ResetMacParameters>

    MacCtx.NvmCtx->PublicNetwork = true;
 80137aa:	4b7c      	ldr	r3, [pc, #496]	; (801399c <LoRaMacInitialization+0x6ec>)
 80137ac:	4a7a      	ldr	r2, [pc, #488]	; (8013998 <LoRaMacInitialization+0x6e8>)
 80137ae:	589b      	ldr	r3, [r3, r2]
 80137b0:	22f1      	movs	r2, #241	; 0xf1
 80137b2:	2101      	movs	r1, #1
 80137b4:	5499      	strb	r1, [r3, r2]

    MacCtx.MacPrimitives = primitives;
 80137b6:	4a79      	ldr	r2, [pc, #484]	; (801399c <LoRaMacInitialization+0x6ec>)
 80137b8:	23d1      	movs	r3, #209	; 0xd1
 80137ba:	009b      	lsls	r3, r3, #2
 80137bc:	68f9      	ldr	r1, [r7, #12]
 80137be:	50d1      	str	r1, [r2, r3]
    MacCtx.MacCallbacks = callbacks;
 80137c0:	4a76      	ldr	r2, [pc, #472]	; (801399c <LoRaMacInitialization+0x6ec>)
 80137c2:	23d2      	movs	r3, #210	; 0xd2
 80137c4:	009b      	lsls	r3, r3, #2
 80137c6:	68b9      	ldr	r1, [r7, #8]
 80137c8:	50d1      	str	r1, [r2, r3]
    MacCtx.MacFlags.Value = 0;
 80137ca:	4b74      	ldr	r3, [pc, #464]	; (801399c <LoRaMacInitialization+0x6ec>)
 80137cc:	4a74      	ldr	r2, [pc, #464]	; (80139a0 <LoRaMacInitialization+0x6f0>)
 80137ce:	2100      	movs	r1, #0
 80137d0:	5499      	strb	r1, [r3, r2]
    MacCtx.MacState = LORAMAC_STOPPED;
 80137d2:	4a72      	ldr	r2, [pc, #456]	; (801399c <LoRaMacInitialization+0x6ec>)
 80137d4:	23d0      	movs	r3, #208	; 0xd0
 80137d6:	009b      	lsls	r3, r3, #2
 80137d8:	2101      	movs	r1, #1
 80137da:	50d1      	str	r1, [r2, r3]

    // Reset duty cycle times
    MacCtx.NvmCtx->LastTxDoneTime = 0;
 80137dc:	4b6f      	ldr	r3, [pc, #444]	; (801399c <LoRaMacInitialization+0x6ec>)
 80137de:	4a6e      	ldr	r2, [pc, #440]	; (8013998 <LoRaMacInitialization+0x6e8>)
 80137e0:	589a      	ldr	r2, [r3, r2]
 80137e2:	23e2      	movs	r3, #226	; 0xe2
 80137e4:	005b      	lsls	r3, r3, #1
 80137e6:	2100      	movs	r1, #0
 80137e8:	50d1      	str	r1, [r2, r3]
    MacCtx.NvmCtx->AggregatedTimeOff = 0;
 80137ea:	4b6c      	ldr	r3, [pc, #432]	; (801399c <LoRaMacInitialization+0x6ec>)
 80137ec:	4a6a      	ldr	r2, [pc, #424]	; (8013998 <LoRaMacInitialization+0x6e8>)
 80137ee:	589a      	ldr	r2, [r3, r2]
 80137f0:	23e4      	movs	r3, #228	; 0xe4
 80137f2:	005b      	lsls	r3, r3, #1
 80137f4:	2100      	movs	r1, #0
 80137f6:	50d1      	str	r1, [r2, r3]

    // Initialize timers
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 80137f8:	4a6a      	ldr	r2, [pc, #424]	; (80139a4 <LoRaMacInitialization+0x6f4>)
 80137fa:	4b6b      	ldr	r3, [pc, #428]	; (80139a8 <LoRaMacInitialization+0x6f8>)
 80137fc:	0011      	movs	r1, r2
 80137fe:	0018      	movs	r0, r3
 8013800:	f007 fb22 	bl	801ae48 <TimerInit>
    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );
 8013804:	4a69      	ldr	r2, [pc, #420]	; (80139ac <LoRaMacInitialization+0x6fc>)
 8013806:	4b6a      	ldr	r3, [pc, #424]	; (80139b0 <LoRaMacInitialization+0x700>)
 8013808:	0011      	movs	r1, r2
 801380a:	0018      	movs	r0, r3
 801380c:	f007 fb1c 	bl	801ae48 <TimerInit>
    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );
 8013810:	4a68      	ldr	r2, [pc, #416]	; (80139b4 <LoRaMacInitialization+0x704>)
 8013812:	4b69      	ldr	r3, [pc, #420]	; (80139b8 <LoRaMacInitialization+0x708>)
 8013814:	0011      	movs	r1, r2
 8013816:	0018      	movs	r0, r3
 8013818:	f007 fb16 	bl	801ae48 <TimerInit>
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 801381c:	4a67      	ldr	r2, [pc, #412]	; (80139bc <LoRaMacInitialization+0x70c>)
 801381e:	4b68      	ldr	r3, [pc, #416]	; (80139c0 <LoRaMacInitialization+0x710>)
 8013820:	0011      	movs	r1, r2
 8013822:	0018      	movs	r0, r3
 8013824:	f007 fb10 	bl	801ae48 <TimerInit>

    // Store the current initialization time
    MacCtx.NvmCtx->InitializationTime = TimerGetCurrentTime( );
 8013828:	4b5c      	ldr	r3, [pc, #368]	; (801399c <LoRaMacInitialization+0x6ec>)
 801382a:	4a5b      	ldr	r2, [pc, #364]	; (8013998 <LoRaMacInitialization+0x6e8>)
 801382c:	589c      	ldr	r4, [r3, r2]
 801382e:	f007 fca8 	bl	801b182 <TimerGetCurrentTime>
 8013832:	0002      	movs	r2, r0
 8013834:	23e6      	movs	r3, #230	; 0xe6
 8013836:	005b      	lsls	r3, r3, #1
 8013838:	50e2      	str	r2, [r4, r3]

    // Initialize Radio driver
    MacCtx.RadioEvents.TxDone = OnRadioTxDone;
 801383a:	4a58      	ldr	r2, [pc, #352]	; (801399c <LoRaMacInitialization+0x6ec>)
 801383c:	23d3      	movs	r3, #211	; 0xd3
 801383e:	009b      	lsls	r3, r3, #2
 8013840:	4960      	ldr	r1, [pc, #384]	; (80139c4 <LoRaMacInitialization+0x714>)
 8013842:	50d1      	str	r1, [r2, r3]
    MacCtx.RadioEvents.RxDone = OnRadioRxDone;
 8013844:	4a55      	ldr	r2, [pc, #340]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013846:	23d5      	movs	r3, #213	; 0xd5
 8013848:	009b      	lsls	r3, r3, #2
 801384a:	495f      	ldr	r1, [pc, #380]	; (80139c8 <LoRaMacInitialization+0x718>)
 801384c:	50d1      	str	r1, [r2, r3]
    MacCtx.RadioEvents.RxError = OnRadioRxError;
 801384e:	4a53      	ldr	r2, [pc, #332]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013850:	23d7      	movs	r3, #215	; 0xd7
 8013852:	009b      	lsls	r3, r3, #2
 8013854:	495d      	ldr	r1, [pc, #372]	; (80139cc <LoRaMacInitialization+0x71c>)
 8013856:	50d1      	str	r1, [r2, r3]
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
 8013858:	4a50      	ldr	r2, [pc, #320]	; (801399c <LoRaMacInitialization+0x6ec>)
 801385a:	23d4      	movs	r3, #212	; 0xd4
 801385c:	009b      	lsls	r3, r3, #2
 801385e:	495c      	ldr	r1, [pc, #368]	; (80139d0 <LoRaMacInitialization+0x720>)
 8013860:	50d1      	str	r1, [r2, r3]
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
 8013862:	4a4e      	ldr	r2, [pc, #312]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013864:	23d6      	movs	r3, #214	; 0xd6
 8013866:	009b      	lsls	r3, r3, #2
 8013868:	495a      	ldr	r1, [pc, #360]	; (80139d4 <LoRaMacInitialization+0x724>)
 801386a:	50d1      	str	r1, [r2, r3]
    Radio.Init( &MacCtx.RadioEvents );
 801386c:	4b5a      	ldr	r3, [pc, #360]	; (80139d8 <LoRaMacInitialization+0x728>)
 801386e:	689b      	ldr	r3, [r3, #8]
 8013870:	4a5a      	ldr	r2, [pc, #360]	; (80139dc <LoRaMacInitialization+0x72c>)
 8013872:	0010      	movs	r0, r2
 8013874:	4798      	blx	r3

    InitDefaultsParams_t params;
    params.Type = INIT_TYPE_INIT;
 8013876:	2114      	movs	r1, #20
 8013878:	187b      	adds	r3, r7, r1
 801387a:	2200      	movs	r2, #0
 801387c:	711a      	strb	r2, [r3, #4]
    params.NvmCtx = NULL;
 801387e:	187b      	adds	r3, r7, r1
 8013880:	2200      	movs	r2, #0
 8013882:	601a      	str	r2, [r3, #0]
    RegionInitDefaults( MacCtx.NvmCtx->Region, &params );
 8013884:	4b45      	ldr	r3, [pc, #276]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013886:	4a44      	ldr	r2, [pc, #272]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013888:	589b      	ldr	r3, [r3, r2]
 801388a:	781b      	ldrb	r3, [r3, #0]
 801388c:	187a      	adds	r2, r7, r1
 801388e:	0011      	movs	r1, r2
 8013890:	0018      	movs	r0, r3
 8013892:	f003 fe80 	bl	8017596 <RegionInitDefaults>

    // Initialize the Secure Element driver
    if( SecureElementInit( EventSecureElementNvmCtxChanged ) != SECURE_ELEMENT_SUCCESS )
 8013896:	4b52      	ldr	r3, [pc, #328]	; (80139e0 <LoRaMacInitialization+0x730>)
 8013898:	0018      	movs	r0, r3
 801389a:	f7fb fa91 	bl	800edc0 <SecureElementInit>
 801389e:	1e03      	subs	r3, r0, #0
 80138a0:	d001      	beq.n	80138a6 <LoRaMacInitialization+0x5f6>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
 80138a2:	2311      	movs	r3, #17
 80138a4:	e073      	b.n	801398e <LoRaMacInitialization+0x6de>
    }

    // Initialize Crypto module
    if( LoRaMacCryptoInit( EventCryptoNvmCtxChanged ) != LORAMAC_CRYPTO_SUCCESS )
 80138a6:	4b4f      	ldr	r3, [pc, #316]	; (80139e4 <LoRaMacInitialization+0x734>)
 80138a8:	0018      	movs	r0, r3
 80138aa:	f002 fcfd 	bl	80162a8 <LoRaMacCryptoInit>
 80138ae:	1e03      	subs	r3, r0, #0
 80138b0:	d001      	beq.n	80138b6 <LoRaMacInitialization+0x606>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
 80138b2:	2311      	movs	r3, #17
 80138b4:	e06b      	b.n	801398e <LoRaMacInitialization+0x6de>
    }

    // Initialize MAC commands module
    if( LoRaMacCommandsInit( EventCommandsNvmCtxChanged ) != LORAMAC_COMMANDS_SUCCESS )
 80138b6:	4b4c      	ldr	r3, [pc, #304]	; (80139e8 <LoRaMacInitialization+0x738>)
 80138b8:	0018      	movs	r0, r3
 80138ba:	f001 fd77 	bl	80153ac <LoRaMacCommandsInit>
 80138be:	1e03      	subs	r3, r0, #0
 80138c0:	d001      	beq.n	80138c6 <LoRaMacInitialization+0x616>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80138c2:	2313      	movs	r3, #19
 80138c4:	e063      	b.n	801398e <LoRaMacInitialization+0x6de>
    }

    // Set multicast downlink counter reference
    if( LoRaMacCryptoSetMulticastReference( MacCtx.NvmCtx->MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )
 80138c6:	4b35      	ldr	r3, [pc, #212]	; (801399c <LoRaMacInitialization+0x6ec>)
 80138c8:	4a33      	ldr	r2, [pc, #204]	; (8013998 <LoRaMacInitialization+0x6e8>)
 80138ca:	589b      	ldr	r3, [r3, r2]
 80138cc:	3350      	adds	r3, #80	; 0x50
 80138ce:	0018      	movs	r0, r3
 80138d0:	f002 fe00 	bl	80164d4 <LoRaMacCryptoSetMulticastReference>
 80138d4:	1e03      	subs	r3, r0, #0
 80138d6:	d001      	beq.n	80138dc <LoRaMacInitialization+0x62c>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
 80138d8:	2311      	movs	r3, #17
 80138da:	e058      	b.n	801398e <LoRaMacInitialization+0x6de>
    }

    // Random seed initialization
    srand1( Radio.Random( ) );
 80138dc:	4b3e      	ldr	r3, [pc, #248]	; (80139d8 <LoRaMacInitialization+0x728>)
 80138de:	69db      	ldr	r3, [r3, #28]
 80138e0:	4798      	blx	r3
 80138e2:	0003      	movs	r3, r0
 80138e4:	0018      	movs	r0, r3
 80138e6:	f007 fe0b 	bl	801b500 <srand1>

    Radio.SetPublicNetwork( MacCtx.NvmCtx->PublicNetwork );
 80138ea:	4b3b      	ldr	r3, [pc, #236]	; (80139d8 <LoRaMacInitialization+0x728>)
 80138ec:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80138ee:	4a2b      	ldr	r2, [pc, #172]	; (801399c <LoRaMacInitialization+0x6ec>)
 80138f0:	4929      	ldr	r1, [pc, #164]	; (8013998 <LoRaMacInitialization+0x6e8>)
 80138f2:	5852      	ldr	r2, [r2, r1]
 80138f4:	21f1      	movs	r1, #241	; 0xf1
 80138f6:	5c52      	ldrb	r2, [r2, r1]
 80138f8:	0010      	movs	r0, r2
 80138fa:	4798      	blx	r3
    Radio.Sleep( );
 80138fc:	4b36      	ldr	r3, [pc, #216]	; (80139d8 <LoRaMacInitialization+0x728>)
 80138fe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8013900:	4798      	blx	r3

    // Initialize class b
    // Apply callback
    classBCallbacks.GetTemperatureLevel = NULL;
 8013902:	2140      	movs	r1, #64	; 0x40
 8013904:	187b      	adds	r3, r7, r1
 8013906:	2200      	movs	r2, #0
 8013908:	601a      	str	r2, [r3, #0]
    classBCallbacks.MacProcessNotify = NULL;
 801390a:	187b      	adds	r3, r7, r1
 801390c:	2200      	movs	r2, #0
 801390e:	605a      	str	r2, [r3, #4]
    if( callbacks != NULL )
 8013910:	68bb      	ldr	r3, [r7, #8]
 8013912:	2b00      	cmp	r3, #0
 8013914:	d007      	beq.n	8013926 <LoRaMacInitialization+0x676>
    {
        classBCallbacks.GetTemperatureLevel = callbacks->GetTemperatureLevel;
 8013916:	68bb      	ldr	r3, [r7, #8]
 8013918:	685a      	ldr	r2, [r3, #4]
 801391a:	187b      	adds	r3, r7, r1
 801391c:	601a      	str	r2, [r3, #0]
        classBCallbacks.MacProcessNotify = callbacks->MacProcessNotify;
 801391e:	68bb      	ldr	r3, [r7, #8]
 8013920:	68da      	ldr	r2, [r3, #12]
 8013922:	187b      	adds	r3, r7, r1
 8013924:	605a      	str	r2, [r3, #4]
    }

    // Must all be static. Don't use local references.
    classBParams.MlmeIndication = &MacCtx.MlmeIndication;
 8013926:	2120      	movs	r1, #32
 8013928:	187b      	adds	r3, r7, r1
 801392a:	4a30      	ldr	r2, [pc, #192]	; (80139ec <LoRaMacInitialization+0x73c>)
 801392c:	601a      	str	r2, [r3, #0]
    classBParams.McpsIndication = &MacCtx.McpsIndication;
 801392e:	187b      	adds	r3, r7, r1
 8013930:	4a2f      	ldr	r2, [pc, #188]	; (80139f0 <LoRaMacInitialization+0x740>)
 8013932:	605a      	str	r2, [r3, #4]
    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;
 8013934:	187b      	adds	r3, r7, r1
 8013936:	4a2f      	ldr	r2, [pc, #188]	; (80139f4 <LoRaMacInitialization+0x744>)
 8013938:	609a      	str	r2, [r3, #8]
    classBParams.LoRaMacFlags = &MacCtx.MacFlags;
 801393a:	187b      	adds	r3, r7, r1
 801393c:	4a2e      	ldr	r2, [pc, #184]	; (80139f8 <LoRaMacInitialization+0x748>)
 801393e:	60da      	str	r2, [r3, #12]
    classBParams.LoRaMacDevAddr = &MacCtx.NvmCtx->DevAddr;
 8013940:	4b16      	ldr	r3, [pc, #88]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013942:	4a15      	ldr	r2, [pc, #84]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013944:	589b      	ldr	r3, [r3, r2]
 8013946:	334c      	adds	r3, #76	; 0x4c
 8013948:	001a      	movs	r2, r3
 801394a:	187b      	adds	r3, r7, r1
 801394c:	611a      	str	r2, [r3, #16]
    classBParams.LoRaMacRegion = &MacCtx.NvmCtx->Region;
 801394e:	4b13      	ldr	r3, [pc, #76]	; (801399c <LoRaMacInitialization+0x6ec>)
 8013950:	4a11      	ldr	r2, [pc, #68]	; (8013998 <LoRaMacInitialization+0x6e8>)
 8013952:	589b      	ldr	r3, [r3, r2]
 8013954:	001a      	movs	r2, r3
 8013956:	187b      	adds	r3, r7, r1
 8013958:	615a      	str	r2, [r3, #20]
    classBParams.LoRaMacParams = &MacCtx.NvmCtx->MacParams;
 801395a:	4b10      	ldr	r3, [pc, #64]	; (801399c <LoRaMacInitialization+0x6ec>)
 801395c:	4a0e      	ldr	r2, [pc, #56]	; (8013998 <LoRaMacInitialization+0x6e8>)
 801395e:	589b      	ldr	r3, [r3, r2]
 8013960:	33f8      	adds	r3, #248	; 0xf8
 8013962:	001a      	movs	r2, r3
 8013964:	187b      	adds	r3, r7, r1
 8013966:	619a      	str	r2, [r3, #24]
    classBParams.MulticastChannels = &MacCtx.NvmCtx->MulticastChannelList[0];
 8013968:	4b0c      	ldr	r3, [pc, #48]	; (801399c <LoRaMacInitialization+0x6ec>)
 801396a:	4a0b      	ldr	r2, [pc, #44]	; (8013998 <LoRaMacInitialization+0x6e8>)
 801396c:	589b      	ldr	r3, [r3, r2]
 801396e:	3350      	adds	r3, #80	; 0x50
 8013970:	001a      	movs	r2, r3
 8013972:	0008      	movs	r0, r1
 8013974:	187b      	adds	r3, r7, r1
 8013976:	61da      	str	r2, [r3, #28]

    LoRaMacClassBInit( &classBParams, &classBCallbacks, &EventClassBNvmCtxChanged );
 8013978:	4a20      	ldr	r2, [pc, #128]	; (80139fc <LoRaMacInitialization+0x74c>)
 801397a:	2340      	movs	r3, #64	; 0x40
 801397c:	18f9      	adds	r1, r7, r3
 801397e:	183b      	adds	r3, r7, r0
 8013980:	0018      	movs	r0, r3
 8013982:	f001 faf4 	bl	8014f6e <LoRaMacClassBInit>

    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );
 8013986:	2001      	movs	r0, #1
 8013988:	f7fc fec6 	bl	8010718 <LoRaMacEnableRequests>

    return LORAMAC_STATUS_OK;
 801398c:	2300      	movs	r3, #0
}
 801398e:	0018      	movs	r0, r3
 8013990:	46bd      	mov	sp, r7
 8013992:	b014      	add	sp, #80	; 0x50
 8013994:	bdb0      	pop	{r4, r5, r7, pc}
 8013996:	46c0      	nop			; (mov r8, r8)
 8013998:	00000484 	.word	0x00000484
 801399c:	200008ec 	.word	0x200008ec
 80139a0:	00000481 	.word	0x00000481
 80139a4:	08010ba9 	.word	0x08010ba9
 80139a8:	20000c54 	.word	0x20000c54
 80139ac:	08010c35 	.word	0x08010c35
 80139b0:	20000c6c 	.word	0x20000c6c
 80139b4:	08010ccd 	.word	0x08010ccd
 80139b8:	20000c84 	.word	0x20000c84
 80139bc:	08010d71 	.word	0x08010d71
 80139c0:	20000ce4 	.word	0x20000ce4
 80139c4:	0800f5b9 	.word	0x0800f5b9
 80139c8:	0800f655 	.word	0x0800f655
 80139cc:	0800f789 	.word	0x0800f789
 80139d0:	0800f715 	.word	0x0800f715
 80139d4:	0800f7cd 	.word	0x0800f7cd
 80139d8:	0801ebd0 	.word	0x0801ebd0
 80139dc:	20000c38 	.word	0x20000c38
 80139e0:	08013239 	.word	0x08013239
 80139e4:	08013229 	.word	0x08013229
 80139e8:	08013249 	.word	0x08013249
 80139ec:	20000d50 	.word	0x20000d50
 80139f0:	20000d08 	.word	0x20000d08
 80139f4:	20000d3c 	.word	0x20000d3c
 80139f8:	20000d6d 	.word	0x20000d6d
 80139fc:	08013259 	.word	0x08013259

08013a00 <LoRaMacStart>:

LoRaMacStatus_t LoRaMacStart( void )
{
 8013a00:	b580      	push	{r7, lr}
 8013a02:	af00      	add	r7, sp, #0
    MacCtx.MacState = LORAMAC_IDLE;
 8013a04:	4a04      	ldr	r2, [pc, #16]	; (8013a18 <LoRaMacStart+0x18>)
 8013a06:	23d0      	movs	r3, #208	; 0xd0
 8013a08:	009b      	lsls	r3, r3, #2
 8013a0a:	2100      	movs	r1, #0
 8013a0c:	50d1      	str	r1, [r2, r3]
    return LORAMAC_STATUS_OK;
 8013a0e:	2300      	movs	r3, #0
}
 8013a10:	0018      	movs	r0, r3
 8013a12:	46bd      	mov	sp, r7
 8013a14:	bd80      	pop	{r7, pc}
 8013a16:	46c0      	nop			; (mov r8, r8)
 8013a18:	200008ec 	.word	0x200008ec

08013a1c <LoRaMacQueryTxPossible>:
    }
    return LORAMAC_STATUS_BUSY;
}

LoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )
{
 8013a1c:	b590      	push	{r4, r7, lr}
 8013a1e:	b08b      	sub	sp, #44	; 0x2c
 8013a20:	af00      	add	r7, sp, #0
 8013a22:	0002      	movs	r2, r0
 8013a24:	6039      	str	r1, [r7, #0]
 8013a26:	1dfb      	adds	r3, r7, #7
 8013a28:	701a      	strb	r2, [r3, #0]
    CalcNextAdrParams_t adrNext;
    uint32_t adrAckCounter = MacCtx.NvmCtx->AdrAckCounter;
 8013a2a:	4b50      	ldr	r3, [pc, #320]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013a2c:	4a50      	ldr	r2, [pc, #320]	; (8013b70 <LoRaMacQueryTxPossible+0x154>)
 8013a2e:	589b      	ldr	r3, [r3, r2]
 8013a30:	22f4      	movs	r2, #244	; 0xf4
 8013a32:	589b      	ldr	r3, [r3, r2]
 8013a34:	613b      	str	r3, [r7, #16]
    int8_t datarate = MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate;
 8013a36:	4b4d      	ldr	r3, [pc, #308]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013a38:	4a4d      	ldr	r2, [pc, #308]	; (8013b70 <LoRaMacQueryTxPossible+0x154>)
 8013a3a:	589b      	ldr	r3, [r3, r2]
 8013a3c:	2205      	movs	r2, #5
 8013a3e:	569a      	ldrsb	r2, [r3, r2]
 8013a40:	230f      	movs	r3, #15
 8013a42:	18fb      	adds	r3, r7, r3
 8013a44:	701a      	strb	r2, [r3, #0]
    int8_t txPower = MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower;
 8013a46:	4b49      	ldr	r3, [pc, #292]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013a48:	4a49      	ldr	r2, [pc, #292]	; (8013b70 <LoRaMacQueryTxPossible+0x154>)
 8013a4a:	589b      	ldr	r3, [r3, r2]
 8013a4c:	2204      	movs	r2, #4
 8013a4e:	569a      	ldrsb	r2, [r3, r2]
 8013a50:	230e      	movs	r3, #14
 8013a52:	18fb      	adds	r3, r7, r3
 8013a54:	701a      	strb	r2, [r3, #0]
    size_t macCmdsSize = 0;
 8013a56:	2300      	movs	r3, #0
 8013a58:	60bb      	str	r3, [r7, #8]

    if( txInfo == NULL )
 8013a5a:	683b      	ldr	r3, [r7, #0]
 8013a5c:	2b00      	cmp	r3, #0
 8013a5e:	d101      	bne.n	8013a64 <LoRaMacQueryTxPossible+0x48>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8013a60:	2303      	movs	r3, #3
 8013a62:	e07e      	b.n	8013b62 <LoRaMacQueryTxPossible+0x146>
    }

    // Setup ADR request
    adrNext.Version = MacCtx.NvmCtx->Version;
 8013a64:	4b41      	ldr	r3, [pc, #260]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013a66:	4a42      	ldr	r2, [pc, #264]	; (8013b70 <LoRaMacQueryTxPossible+0x154>)
 8013a68:	5899      	ldr	r1, [r3, r2]
 8013a6a:	2014      	movs	r0, #20
 8013a6c:	183b      	adds	r3, r7, r0
 8013a6e:	22e8      	movs	r2, #232	; 0xe8
 8013a70:	0052      	lsls	r2, r2, #1
 8013a72:	588a      	ldr	r2, [r1, r2]
 8013a74:	601a      	str	r2, [r3, #0]
    adrNext.UpdateChanMask = false;
 8013a76:	183b      	adds	r3, r7, r0
 8013a78:	2200      	movs	r2, #0
 8013a7a:	711a      	strb	r2, [r3, #4]
    adrNext.AdrEnabled = MacCtx.NvmCtx->AdrCtrlOn;
 8013a7c:	4b3b      	ldr	r3, [pc, #236]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013a7e:	4a3c      	ldr	r2, [pc, #240]	; (8013b70 <LoRaMacQueryTxPossible+0x154>)
 8013a80:	589b      	ldr	r3, [r3, r2]
 8013a82:	22f2      	movs	r2, #242	; 0xf2
 8013a84:	5c9a      	ldrb	r2, [r3, r2]
 8013a86:	183b      	adds	r3, r7, r0
 8013a88:	715a      	strb	r2, [r3, #5]
    adrNext.AdrAckCounter = MacCtx.NvmCtx->AdrAckCounter;
 8013a8a:	4b38      	ldr	r3, [pc, #224]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013a8c:	4a38      	ldr	r2, [pc, #224]	; (8013b70 <LoRaMacQueryTxPossible+0x154>)
 8013a8e:	589b      	ldr	r3, [r3, r2]
 8013a90:	22f4      	movs	r2, #244	; 0xf4
 8013a92:	589a      	ldr	r2, [r3, r2]
 8013a94:	183b      	adds	r3, r7, r0
 8013a96:	609a      	str	r2, [r3, #8]
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 8013a98:	4a34      	ldr	r2, [pc, #208]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013a9a:	23fd      	movs	r3, #253	; 0xfd
 8013a9c:	009b      	lsls	r3, r3, #2
 8013a9e:	5ad2      	ldrh	r2, [r2, r3]
 8013aa0:	183b      	adds	r3, r7, r0
 8013aa2:	819a      	strh	r2, [r3, #12]
    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;
 8013aa4:	4b31      	ldr	r3, [pc, #196]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013aa6:	4a33      	ldr	r2, [pc, #204]	; (8013b74 <LoRaMacQueryTxPossible+0x158>)
 8013aa8:	5a9a      	ldrh	r2, [r3, r2]
 8013aaa:	183b      	adds	r3, r7, r0
 8013aac:	81da      	strh	r2, [r3, #14]
    adrNext.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;
 8013aae:	4b2f      	ldr	r3, [pc, #188]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013ab0:	4a2f      	ldr	r2, [pc, #188]	; (8013b70 <LoRaMacQueryTxPossible+0x154>)
 8013ab2:	589b      	ldr	r3, [r3, r2]
 8013ab4:	22f9      	movs	r2, #249	; 0xf9
 8013ab6:	569a      	ldrsb	r2, [r3, r2]
 8013ab8:	183b      	adds	r3, r7, r0
 8013aba:	741a      	strb	r2, [r3, #16]
    adrNext.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;
 8013abc:	4b2b      	ldr	r3, [pc, #172]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013abe:	4a2c      	ldr	r2, [pc, #176]	; (8013b70 <LoRaMacQueryTxPossible+0x154>)
 8013ac0:	589b      	ldr	r3, [r3, r2]
 8013ac2:	22f8      	movs	r2, #248	; 0xf8
 8013ac4:	569a      	ldrsb	r2, [r3, r2]
 8013ac6:	183b      	adds	r3, r7, r0
 8013ac8:	745a      	strb	r2, [r3, #17]
    adrNext.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;
 8013aca:	4b28      	ldr	r3, [pc, #160]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013acc:	4a28      	ldr	r2, [pc, #160]	; (8013b70 <LoRaMacQueryTxPossible+0x154>)
 8013ace:	589a      	ldr	r2, [r3, r2]
 8013ad0:	2396      	movs	r3, #150	; 0x96
 8013ad2:	005b      	lsls	r3, r3, #1
 8013ad4:	5cd2      	ldrb	r2, [r2, r3]
 8013ad6:	183b      	adds	r3, r7, r0
 8013ad8:	749a      	strb	r2, [r3, #18]
    adrNext.Region = MacCtx.NvmCtx->Region;
 8013ada:	4b24      	ldr	r3, [pc, #144]	; (8013b6c <LoRaMacQueryTxPossible+0x150>)
 8013adc:	4a24      	ldr	r2, [pc, #144]	; (8013b70 <LoRaMacQueryTxPossible+0x154>)
 8013ade:	589b      	ldr	r3, [r3, r2]
 8013ae0:	781a      	ldrb	r2, [r3, #0]
 8013ae2:	183b      	adds	r3, r7, r0
 8013ae4:	74da      	strb	r2, [r3, #19]

    // We call the function for information purposes only. We don't want to
    // apply the datarate, the tx power and the ADR ack counter.
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );
 8013ae6:	2310      	movs	r3, #16
 8013ae8:	18fb      	adds	r3, r7, r3
 8013aea:	220e      	movs	r2, #14
 8013aec:	18ba      	adds	r2, r7, r2
 8013aee:	240f      	movs	r4, #15
 8013af0:	1939      	adds	r1, r7, r4
 8013af2:	1838      	adds	r0, r7, r0
 8013af4:	f001 fa23 	bl	8014f3e <LoRaMacAdrCalcNext>

    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8013af8:	193b      	adds	r3, r7, r4
 8013afa:	781b      	ldrb	r3, [r3, #0]
 8013afc:	b25b      	sxtb	r3, r3
 8013afe:	0018      	movs	r0, r3
 8013b00:	f7fd fb24 	bl	801114c <GetMaxAppPayloadWithoutFOptsLength>
 8013b04:	0003      	movs	r3, r0
 8013b06:	001a      	movs	r2, r3
 8013b08:	683b      	ldr	r3, [r7, #0]
 8013b0a:	705a      	strb	r2, [r3, #1]

    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8013b0c:	2308      	movs	r3, #8
 8013b0e:	18fb      	adds	r3, r7, r3
 8013b10:	0018      	movs	r0, r3
 8013b12:	f001 fd5f 	bl	80155d4 <LoRaMacCommandsGetSizeSerializedCmds>
 8013b16:	1e03      	subs	r3, r0, #0
 8013b18:	d001      	beq.n	8013b1e <LoRaMacQueryTxPossible+0x102>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8013b1a:	2313      	movs	r3, #19
 8013b1c:	e021      	b.n	8013b62 <LoRaMacQueryTxPossible+0x146>
    }

    // Verify if the MAC commands fit into the FOpts and into the maximum payload.
    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )
 8013b1e:	68bb      	ldr	r3, [r7, #8]
 8013b20:	2b0f      	cmp	r3, #15
 8013b22:	d81a      	bhi.n	8013b5a <LoRaMacQueryTxPossible+0x13e>
 8013b24:	683b      	ldr	r3, [r7, #0]
 8013b26:	785b      	ldrb	r3, [r3, #1]
 8013b28:	001a      	movs	r2, r3
 8013b2a:	68bb      	ldr	r3, [r7, #8]
 8013b2c:	429a      	cmp	r2, r3
 8013b2e:	d314      	bcc.n	8013b5a <LoRaMacQueryTxPossible+0x13e>
    {
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 8013b30:	683b      	ldr	r3, [r7, #0]
 8013b32:	785a      	ldrb	r2, [r3, #1]
 8013b34:	68bb      	ldr	r3, [r7, #8]
 8013b36:	b2db      	uxtb	r3, r3
 8013b38:	1ad3      	subs	r3, r2, r3
 8013b3a:	b2da      	uxtb	r2, r3
 8013b3c:	683b      	ldr	r3, [r7, #0]
 8013b3e:	701a      	strb	r2, [r3, #0]

        // Verify if the application data together with MAC command fit into the maximum payload.
        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )
 8013b40:	683b      	ldr	r3, [r7, #0]
 8013b42:	785b      	ldrb	r3, [r3, #1]
 8013b44:	0019      	movs	r1, r3
 8013b46:	1dfb      	adds	r3, r7, #7
 8013b48:	781a      	ldrb	r2, [r3, #0]
 8013b4a:	68bb      	ldr	r3, [r7, #8]
 8013b4c:	18d3      	adds	r3, r2, r3
 8013b4e:	4299      	cmp	r1, r3
 8013b50:	d301      	bcc.n	8013b56 <LoRaMacQueryTxPossible+0x13a>
        {
            return LORAMAC_STATUS_OK;
 8013b52:	2300      	movs	r3, #0
 8013b54:	e005      	b.n	8013b62 <LoRaMacQueryTxPossible+0x146>
        }
        else
        {
           return LORAMAC_STATUS_LENGTH_ERROR;
 8013b56:	2308      	movs	r3, #8
 8013b58:	e003      	b.n	8013b62 <LoRaMacQueryTxPossible+0x146>
        }
    }
    else
    {
        txInfo->MaxPossibleApplicationDataSize = 0;
 8013b5a:	683b      	ldr	r3, [r7, #0]
 8013b5c:	2200      	movs	r2, #0
 8013b5e:	701a      	strb	r2, [r3, #0]
        return LORAMAC_STATUS_LENGTH_ERROR;
 8013b60:	2308      	movs	r3, #8
    }
}
 8013b62:	0018      	movs	r0, r3
 8013b64:	46bd      	mov	sp, r7
 8013b66:	b00b      	add	sp, #44	; 0x2c
 8013b68:	bd90      	pop	{r4, r7, pc}
 8013b6a:	46c0      	nop			; (mov r8, r8)
 8013b6c:	200008ec 	.word	0x200008ec
 8013b70:	00000484 	.word	0x00000484
 8013b74:	000003f6 	.word	0x000003f6

08013b78 <LoRaMacMibGetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )
{
 8013b78:	b590      	push	{r4, r7, lr}
 8013b7a:	b087      	sub	sp, #28
 8013b7c:	af00      	add	r7, sp, #0
 8013b7e:	6078      	str	r0, [r7, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 8013b80:	2317      	movs	r3, #23
 8013b82:	18fb      	adds	r3, r7, r3
 8013b84:	2200      	movs	r2, #0
 8013b86:	701a      	strb	r2, [r3, #0]
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( mibGet == NULL )
 8013b88:	687b      	ldr	r3, [r7, #4]
 8013b8a:	2b00      	cmp	r3, #0
 8013b8c:	d101      	bne.n	8013b92 <LoRaMacMibGetRequestConfirm+0x1a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8013b8e:	2303      	movs	r3, #3
 8013b90:	e143      	b.n	8013e1a <LoRaMacMibGetRequestConfirm+0x2a2>
    }

    switch( mibGet->Type )
 8013b92:	687b      	ldr	r3, [r7, #4]
 8013b94:	781b      	ldrb	r3, [r3, #0]
 8013b96:	2b34      	cmp	r3, #52	; 0x34
 8013b98:	d900      	bls.n	8013b9c <LoRaMacMibGetRequestConfirm+0x24>
 8013b9a:	e132      	b.n	8013e02 <LoRaMacMibGetRequestConfirm+0x28a>
 8013b9c:	009a      	lsls	r2, r3, #2
 8013b9e:	4ba1      	ldr	r3, [pc, #644]	; (8013e24 <LoRaMacMibGetRequestConfirm+0x2ac>)
 8013ba0:	18d3      	adds	r3, r2, r3
 8013ba2:	681b      	ldr	r3, [r3, #0]
 8013ba4:	469f      	mov	pc, r3
    {
        case MIB_DEVICE_CLASS:
        {
            mibGet->Param.Class = MacCtx.NvmCtx->DeviceClass;
 8013ba6:	4ba0      	ldr	r3, [pc, #640]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013ba8:	4aa0      	ldr	r2, [pc, #640]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013baa:	589b      	ldr	r3, [r3, r2]
 8013bac:	22f0      	movs	r2, #240	; 0xf0
 8013bae:	5c9a      	ldrb	r2, [r3, r2]
 8013bb0:	687b      	ldr	r3, [r7, #4]
 8013bb2:	711a      	strb	r2, [r3, #4]
            break;
 8013bb4:	e12e      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_NETWORK_ACTIVATION:
        {
            mibGet->Param.NetworkActivation = MacCtx.NvmCtx->NetworkActivation;
 8013bb6:	4b9c      	ldr	r3, [pc, #624]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013bb8:	4a9c      	ldr	r2, [pc, #624]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013bba:	589a      	ldr	r2, [r3, r2]
 8013bbc:	23ea      	movs	r3, #234	; 0xea
 8013bbe:	005b      	lsls	r3, r3, #1
 8013bc0:	5cd2      	ldrb	r2, [r2, r3]
 8013bc2:	687b      	ldr	r3, [r7, #4]
 8013bc4:	711a      	strb	r2, [r3, #4]
            break;
 8013bc6:	e125      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_DEV_EUI:
        {
            mibGet->Param.DevEui = SecureElementGetDevEui( );
 8013bc8:	f7fb fcca 	bl	800f560 <SecureElementGetDevEui>
 8013bcc:	0002      	movs	r2, r0
 8013bce:	687b      	ldr	r3, [r7, #4]
 8013bd0:	605a      	str	r2, [r3, #4]
            break;
 8013bd2:	e11f      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_JOIN_EUI:
        {
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 8013bd4:	f7fb fce8 	bl	800f5a8 <SecureElementGetJoinEui>
 8013bd8:	0002      	movs	r2, r0
 8013bda:	687b      	ldr	r3, [r7, #4]
 8013bdc:	605a      	str	r2, [r3, #4]
            break;
 8013bde:	e119      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_ADR:
        {
            mibGet->Param.AdrEnable = MacCtx.NvmCtx->AdrCtrlOn;
 8013be0:	4b91      	ldr	r3, [pc, #580]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013be2:	4a92      	ldr	r2, [pc, #584]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013be4:	589b      	ldr	r3, [r3, r2]
 8013be6:	22f2      	movs	r2, #242	; 0xf2
 8013be8:	5c9a      	ldrb	r2, [r3, r2]
 8013bea:	687b      	ldr	r3, [r7, #4]
 8013bec:	711a      	strb	r2, [r3, #4]
            break;
 8013bee:	e111      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_NET_ID:
        {
            mibGet->Param.NetID = MacCtx.NvmCtx->NetID;
 8013bf0:	4b8d      	ldr	r3, [pc, #564]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013bf2:	4a8e      	ldr	r2, [pc, #568]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013bf4:	589b      	ldr	r3, [r3, r2]
 8013bf6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8013bf8:	687b      	ldr	r3, [r7, #4]
 8013bfa:	605a      	str	r2, [r3, #4]
            break;
 8013bfc:	e10a      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_DEV_ADDR:
        {
            mibGet->Param.DevAddr = MacCtx.NvmCtx->DevAddr;
 8013bfe:	4b8a      	ldr	r3, [pc, #552]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013c00:	4a8a      	ldr	r2, [pc, #552]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013c02:	589b      	ldr	r3, [r3, r2]
 8013c04:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8013c06:	687b      	ldr	r3, [r7, #4]
 8013c08:	605a      	str	r2, [r3, #4]
            break;
 8013c0a:	e103      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_PUBLIC_NETWORK:
        {
            mibGet->Param.EnablePublicNetwork = MacCtx.NvmCtx->PublicNetwork;
 8013c0c:	4b86      	ldr	r3, [pc, #536]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013c0e:	4a87      	ldr	r2, [pc, #540]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013c10:	589b      	ldr	r3, [r3, r2]
 8013c12:	22f1      	movs	r2, #241	; 0xf1
 8013c14:	5c9a      	ldrb	r2, [r3, r2]
 8013c16:	687b      	ldr	r3, [r7, #4]
 8013c18:	711a      	strb	r2, [r3, #4]
            break;
 8013c1a:	e0fb      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_REPEATER_SUPPORT:
        {
            mibGet->Param.EnableRepeaterSupport = MacCtx.NvmCtx->RepeaterSupport;
 8013c1c:	4b82      	ldr	r3, [pc, #520]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013c1e:	4a83      	ldr	r2, [pc, #524]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013c20:	589a      	ldr	r2, [r3, r2]
 8013c22:	2340      	movs	r3, #64	; 0x40
 8013c24:	33ff      	adds	r3, #255	; 0xff
 8013c26:	5cd2      	ldrb	r2, [r2, r3]
 8013c28:	687b      	ldr	r3, [r7, #4]
 8013c2a:	711a      	strb	r2, [r3, #4]
            break;
 8013c2c:	e0f2      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_CHANNELS:
        {
            getPhy.Attribute = PHY_CHANNELS;
 8013c2e:	2110      	movs	r1, #16
 8013c30:	187b      	adds	r3, r7, r1
 8013c32:	221d      	movs	r2, #29
 8013c34:	701a      	strb	r2, [r3, #0]
            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 8013c36:	4b7c      	ldr	r3, [pc, #496]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013c38:	4a7c      	ldr	r2, [pc, #496]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013c3a:	589b      	ldr	r3, [r3, r2]
 8013c3c:	781b      	ldrb	r3, [r3, #0]
 8013c3e:	187a      	adds	r2, r7, r1
 8013c40:	0011      	movs	r1, r2
 8013c42:	0018      	movs	r0, r3
 8013c44:	f003 fc6b 	bl	801751e <RegionGetPhyParam>
 8013c48:	0003      	movs	r3, r0
 8013c4a:	001a      	movs	r2, r3
 8013c4c:	210c      	movs	r1, #12
 8013c4e:	187b      	adds	r3, r7, r1
 8013c50:	601a      	str	r2, [r3, #0]

            mibGet->Param.ChannelList = phyParam.Channels;
 8013c52:	187b      	adds	r3, r7, r1
 8013c54:	681a      	ldr	r2, [r3, #0]
 8013c56:	687b      	ldr	r3, [r7, #4]
 8013c58:	605a      	str	r2, [r3, #4]
            break;
 8013c5a:	e0db      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_RX2_CHANNEL:
        {
            mibGet->Param.Rx2Channel = MacCtx.NvmCtx->MacParams.Rx2Channel;
 8013c5c:	4b72      	ldr	r3, [pc, #456]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013c5e:	4a73      	ldr	r2, [pc, #460]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013c60:	5899      	ldr	r1, [r3, r2]
 8013c62:	687b      	ldr	r3, [r7, #4]
 8013c64:	228e      	movs	r2, #142	; 0x8e
 8013c66:	0052      	lsls	r2, r2, #1
 8013c68:	3304      	adds	r3, #4
 8013c6a:	188a      	adds	r2, r1, r2
 8013c6c:	ca03      	ldmia	r2!, {r0, r1}
 8013c6e:	c303      	stmia	r3!, {r0, r1}
            break;
 8013c70:	e0d0      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_RX2_DEFAULT_CHANNEL:
        {
            mibGet->Param.Rx2Channel = MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel;
 8013c72:	4b6d      	ldr	r3, [pc, #436]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013c74:	4a6d      	ldr	r2, [pc, #436]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013c76:	589a      	ldr	r2, [r3, r2]
 8013c78:	687b      	ldr	r3, [r7, #4]
 8013c7a:	3304      	adds	r3, #4
 8013c7c:	3228      	adds	r2, #40	; 0x28
 8013c7e:	ca03      	ldmia	r2!, {r0, r1}
 8013c80:	c303      	stmia	r3!, {r0, r1}
            break;
 8013c82:	e0c7      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_RXC_CHANNEL:
        {
            mibGet->Param.RxCChannel = MacCtx.NvmCtx->MacParams.RxCChannel;
 8013c84:	4b68      	ldr	r3, [pc, #416]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013c86:	4a69      	ldr	r2, [pc, #420]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013c88:	5899      	ldr	r1, [r3, r2]
 8013c8a:	687b      	ldr	r3, [r7, #4]
 8013c8c:	2292      	movs	r2, #146	; 0x92
 8013c8e:	0052      	lsls	r2, r2, #1
 8013c90:	3304      	adds	r3, #4
 8013c92:	188a      	adds	r2, r1, r2
 8013c94:	ca03      	ldmia	r2!, {r0, r1}
 8013c96:	c303      	stmia	r3!, {r0, r1}
            break;
 8013c98:	e0bc      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_RXC_DEFAULT_CHANNEL:
        {
            mibGet->Param.RxCChannel = MacCtx.NvmCtx->MacParamsDefaults.RxCChannel;
 8013c9a:	4b63      	ldr	r3, [pc, #396]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013c9c:	4a63      	ldr	r2, [pc, #396]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013c9e:	589a      	ldr	r2, [r3, r2]
 8013ca0:	687b      	ldr	r3, [r7, #4]
 8013ca2:	3304      	adds	r3, #4
 8013ca4:	3230      	adds	r2, #48	; 0x30
 8013ca6:	ca03      	ldmia	r2!, {r0, r1}
 8013ca8:	c303      	stmia	r3!, {r0, r1}
            break;
 8013caa:	e0b3      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_CHANNELS_DEFAULT_MASK:
        {
            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;
 8013cac:	2110      	movs	r1, #16
 8013cae:	187b      	adds	r3, r7, r1
 8013cb0:	221b      	movs	r2, #27
 8013cb2:	701a      	strb	r2, [r3, #0]
            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 8013cb4:	4b5c      	ldr	r3, [pc, #368]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013cb6:	4a5d      	ldr	r2, [pc, #372]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013cb8:	589b      	ldr	r3, [r3, r2]
 8013cba:	781b      	ldrb	r3, [r3, #0]
 8013cbc:	187a      	adds	r2, r7, r1
 8013cbe:	0011      	movs	r1, r2
 8013cc0:	0018      	movs	r0, r3
 8013cc2:	f003 fc2c 	bl	801751e <RegionGetPhyParam>
 8013cc6:	0003      	movs	r3, r0
 8013cc8:	001a      	movs	r2, r3
 8013cca:	210c      	movs	r1, #12
 8013ccc:	187b      	adds	r3, r7, r1
 8013cce:	601a      	str	r2, [r3, #0]

            mibGet->Param.ChannelsDefaultMask = phyParam.ChannelsMask;
 8013cd0:	187b      	adds	r3, r7, r1
 8013cd2:	681a      	ldr	r2, [r3, #0]
 8013cd4:	687b      	ldr	r3, [r7, #4]
 8013cd6:	605a      	str	r2, [r3, #4]
            break;
 8013cd8:	e09c      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_CHANNELS_MASK:
        {
            getPhy.Attribute = PHY_CHANNELS_MASK;
 8013cda:	2110      	movs	r1, #16
 8013cdc:	187b      	adds	r3, r7, r1
 8013cde:	221a      	movs	r2, #26
 8013ce0:	701a      	strb	r2, [r3, #0]
            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 8013ce2:	4b51      	ldr	r3, [pc, #324]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013ce4:	4a51      	ldr	r2, [pc, #324]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013ce6:	589b      	ldr	r3, [r3, r2]
 8013ce8:	781b      	ldrb	r3, [r3, #0]
 8013cea:	187a      	adds	r2, r7, r1
 8013cec:	0011      	movs	r1, r2
 8013cee:	0018      	movs	r0, r3
 8013cf0:	f003 fc15 	bl	801751e <RegionGetPhyParam>
 8013cf4:	0003      	movs	r3, r0
 8013cf6:	001a      	movs	r2, r3
 8013cf8:	210c      	movs	r1, #12
 8013cfa:	187b      	adds	r3, r7, r1
 8013cfc:	601a      	str	r2, [r3, #0]

            mibGet->Param.ChannelsMask = phyParam.ChannelsMask;
 8013cfe:	187b      	adds	r3, r7, r1
 8013d00:	681a      	ldr	r2, [r3, #0]
 8013d02:	687b      	ldr	r3, [r7, #4]
 8013d04:	605a      	str	r2, [r3, #4]
            break;
 8013d06:	e085      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_CHANNELS_NB_TRANS:
        {
            mibGet->Param.ChannelsNbTrans = MacCtx.NvmCtx->MacParams.ChannelsNbTrans;
 8013d08:	4b47      	ldr	r3, [pc, #284]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013d0a:	4a48      	ldr	r2, [pc, #288]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013d0c:	589a      	ldr	r2, [r3, r2]
 8013d0e:	238c      	movs	r3, #140	; 0x8c
 8013d10:	005b      	lsls	r3, r3, #1
 8013d12:	5cd2      	ldrb	r2, [r2, r3]
 8013d14:	687b      	ldr	r3, [r7, #4]
 8013d16:	711a      	strb	r2, [r3, #4]
            break;
 8013d18:	e07c      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_MAX_RX_WINDOW_DURATION:
        {
            mibGet->Param.MaxRxWindow = MacCtx.NvmCtx->MacParams.MaxRxWindow;
 8013d1a:	4b43      	ldr	r3, [pc, #268]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013d1c:	4a43      	ldr	r2, [pc, #268]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013d1e:	589a      	ldr	r2, [r3, r2]
 8013d20:	2382      	movs	r3, #130	; 0x82
 8013d22:	005b      	lsls	r3, r3, #1
 8013d24:	58d2      	ldr	r2, [r2, r3]
 8013d26:	687b      	ldr	r3, [r7, #4]
 8013d28:	605a      	str	r2, [r3, #4]
            break;
 8013d2a:	e073      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_RECEIVE_DELAY_1:
        {
            mibGet->Param.ReceiveDelay1 = MacCtx.NvmCtx->MacParams.ReceiveDelay1;
 8013d2c:	4b3e      	ldr	r3, [pc, #248]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013d2e:	4a3f      	ldr	r2, [pc, #252]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013d30:	589a      	ldr	r2, [r3, r2]
 8013d32:	2384      	movs	r3, #132	; 0x84
 8013d34:	005b      	lsls	r3, r3, #1
 8013d36:	58d2      	ldr	r2, [r2, r3]
 8013d38:	687b      	ldr	r3, [r7, #4]
 8013d3a:	605a      	str	r2, [r3, #4]
            break;
 8013d3c:	e06a      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_RECEIVE_DELAY_2:
        {
            mibGet->Param.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay2;
 8013d3e:	4b3a      	ldr	r3, [pc, #232]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013d40:	4a3a      	ldr	r2, [pc, #232]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013d42:	589a      	ldr	r2, [r3, r2]
 8013d44:	2386      	movs	r3, #134	; 0x86
 8013d46:	005b      	lsls	r3, r3, #1
 8013d48:	58d2      	ldr	r2, [r2, r3]
 8013d4a:	687b      	ldr	r3, [r7, #4]
 8013d4c:	605a      	str	r2, [r3, #4]
            break;
 8013d4e:	e061      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_JOIN_ACCEPT_DELAY_1:
        {
            mibGet->Param.JoinAcceptDelay1 = MacCtx.NvmCtx->MacParams.JoinAcceptDelay1;
 8013d50:	4b35      	ldr	r3, [pc, #212]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013d52:	4a36      	ldr	r2, [pc, #216]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013d54:	589a      	ldr	r2, [r3, r2]
 8013d56:	2388      	movs	r3, #136	; 0x88
 8013d58:	005b      	lsls	r3, r3, #1
 8013d5a:	58d2      	ldr	r2, [r2, r3]
 8013d5c:	687b      	ldr	r3, [r7, #4]
 8013d5e:	605a      	str	r2, [r3, #4]
            break;
 8013d60:	e058      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_JOIN_ACCEPT_DELAY_2:
        {
            mibGet->Param.JoinAcceptDelay2 = MacCtx.NvmCtx->MacParams.JoinAcceptDelay2;
 8013d62:	4b31      	ldr	r3, [pc, #196]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013d64:	4a31      	ldr	r2, [pc, #196]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013d66:	589a      	ldr	r2, [r3, r2]
 8013d68:	238a      	movs	r3, #138	; 0x8a
 8013d6a:	005b      	lsls	r3, r3, #1
 8013d6c:	58d2      	ldr	r2, [r2, r3]
 8013d6e:	687b      	ldr	r3, [r7, #4]
 8013d70:	605a      	str	r2, [r3, #4]
            break;
 8013d72:	e04f      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_CHANNELS_DEFAULT_DATARATE:
        {
            mibGet->Param.ChannelsDefaultDatarate = MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate;
 8013d74:	4b2c      	ldr	r3, [pc, #176]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013d76:	4a2d      	ldr	r2, [pc, #180]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013d78:	589b      	ldr	r3, [r3, r2]
 8013d7a:	2205      	movs	r2, #5
 8013d7c:	569a      	ldrsb	r2, [r3, r2]
 8013d7e:	687b      	ldr	r3, [r7, #4]
 8013d80:	711a      	strb	r2, [r3, #4]
            break;
 8013d82:	e047      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_CHANNELS_DATARATE:
        {
            mibGet->Param.ChannelsDatarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;
 8013d84:	4b28      	ldr	r3, [pc, #160]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013d86:	4a29      	ldr	r2, [pc, #164]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013d88:	589b      	ldr	r3, [r3, r2]
 8013d8a:	22f9      	movs	r2, #249	; 0xf9
 8013d8c:	569a      	ldrsb	r2, [r3, r2]
 8013d8e:	687b      	ldr	r3, [r7, #4]
 8013d90:	711a      	strb	r2, [r3, #4]
            break;
 8013d92:	e03f      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_CHANNELS_DEFAULT_TX_POWER:
        {
            mibGet->Param.ChannelsDefaultTxPower = MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower;
 8013d94:	4b24      	ldr	r3, [pc, #144]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013d96:	4a25      	ldr	r2, [pc, #148]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013d98:	589b      	ldr	r3, [r3, r2]
 8013d9a:	2204      	movs	r2, #4
 8013d9c:	569a      	ldrsb	r2, [r3, r2]
 8013d9e:	687b      	ldr	r3, [r7, #4]
 8013da0:	711a      	strb	r2, [r3, #4]
            break;
 8013da2:	e037      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_CHANNELS_TX_POWER:
        {
            mibGet->Param.ChannelsTxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;
 8013da4:	4b20      	ldr	r3, [pc, #128]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013da6:	4a21      	ldr	r2, [pc, #132]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013da8:	589b      	ldr	r3, [r3, r2]
 8013daa:	22f8      	movs	r2, #248	; 0xf8
 8013dac:	569a      	ldrsb	r2, [r3, r2]
 8013dae:	687b      	ldr	r3, [r7, #4]
 8013db0:	711a      	strb	r2, [r3, #4]
            break;
 8013db2:	e02f      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_SYSTEM_MAX_RX_ERROR:
        {
            mibGet->Param.SystemMaxRxError = MacCtx.NvmCtx->MacParams.SystemMaxRxError;
 8013db4:	4b1c      	ldr	r3, [pc, #112]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013db6:	4a1d      	ldr	r2, [pc, #116]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013db8:	589b      	ldr	r3, [r3, r2]
 8013dba:	22fc      	movs	r2, #252	; 0xfc
 8013dbc:	589a      	ldr	r2, [r3, r2]
 8013dbe:	687b      	ldr	r3, [r7, #4]
 8013dc0:	605a      	str	r2, [r3, #4]
            break;
 8013dc2:	e027      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_MIN_RX_SYMBOLS:
        {
            mibGet->Param.MinRxSymbols = MacCtx.NvmCtx->MacParams.MinRxSymbols;
 8013dc4:	4b18      	ldr	r3, [pc, #96]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013dc6:	4a19      	ldr	r2, [pc, #100]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013dc8:	589a      	ldr	r2, [r3, r2]
 8013dca:	2380      	movs	r3, #128	; 0x80
 8013dcc:	005b      	lsls	r3, r3, #1
 8013dce:	5cd2      	ldrb	r2, [r2, r3]
 8013dd0:	687b      	ldr	r3, [r7, #4]
 8013dd2:	711a      	strb	r2, [r3, #4]
            break;
 8013dd4:	e01e      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_ANTENNA_GAIN:
        {
            mibGet->Param.AntennaGain = MacCtx.NvmCtx->MacParams.AntennaGain;
 8013dd6:	4b14      	ldr	r3, [pc, #80]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013dd8:	4a14      	ldr	r2, [pc, #80]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013dda:	589a      	ldr	r2, [r3, r2]
 8013ddc:	239a      	movs	r3, #154	; 0x9a
 8013dde:	005b      	lsls	r3, r3, #1
 8013de0:	58d2      	ldr	r2, [r2, r3]
 8013de2:	687b      	ldr	r3, [r7, #4]
 8013de4:	605a      	str	r2, [r3, #4]
            break;
 8013de6:	e015      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_NVM_CTXS:
        {
            mibGet->Param.Contexts = GetCtxs( );
 8013de8:	f7fe ffa4 	bl	8012d34 <GetCtxs>
 8013dec:	0002      	movs	r2, r0
 8013dee:	687b      	ldr	r3, [r7, #4]
 8013df0:	605a      	str	r2, [r3, #4]
            break;
 8013df2:	e00f      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        case MIB_DEFAULT_ANTENNA_GAIN:
        {
            mibGet->Param.DefaultAntennaGain = MacCtx.NvmCtx->MacParamsDefaults.AntennaGain;
 8013df4:	4b0c      	ldr	r3, [pc, #48]	; (8013e28 <LoRaMacMibGetRequestConfirm+0x2b0>)
 8013df6:	4a0d      	ldr	r2, [pc, #52]	; (8013e2c <LoRaMacMibGetRequestConfirm+0x2b4>)
 8013df8:	589b      	ldr	r3, [r3, r2]
 8013dfa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8013dfc:	687b      	ldr	r3, [r7, #4]
 8013dfe:	605a      	str	r2, [r3, #4]
            break;
 8013e00:	e008      	b.n	8013e14 <LoRaMacMibGetRequestConfirm+0x29c>
        }
        default:
        {
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
 8013e02:	2317      	movs	r3, #23
 8013e04:	18fc      	adds	r4, r7, r3
 8013e06:	687b      	ldr	r3, [r7, #4]
 8013e08:	0018      	movs	r0, r3
 8013e0a:	f001 f94e 	bl	80150aa <LoRaMacClassBMibGetRequestConfirm>
 8013e0e:	0003      	movs	r3, r0
 8013e10:	7023      	strb	r3, [r4, #0]
            break;
 8013e12:	46c0      	nop			; (mov r8, r8)
        }
    }
    return status;
 8013e14:	2317      	movs	r3, #23
 8013e16:	18fb      	adds	r3, r7, r3
 8013e18:	781b      	ldrb	r3, [r3, #0]
}
 8013e1a:	0018      	movs	r0, r3
 8013e1c:	46bd      	mov	sp, r7
 8013e1e:	b007      	add	sp, #28
 8013e20:	bd90      	pop	{r4, r7, pc}
 8013e22:	46c0      	nop			; (mov r8, r8)
 8013e24:	0801f230 	.word	0x0801f230
 8013e28:	200008ec 	.word	0x200008ec
 8013e2c:	00000484 	.word	0x00000484

08013e30 <LoRaMacMibSetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )
{
 8013e30:	b590      	push	{r4, r7, lr}
 8013e32:	b089      	sub	sp, #36	; 0x24
 8013e34:	af02      	add	r7, sp, #8
 8013e36:	6078      	str	r0, [r7, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 8013e38:	2317      	movs	r3, #23
 8013e3a:	18fb      	adds	r3, r7, r3
 8013e3c:	2200      	movs	r2, #0
 8013e3e:	701a      	strb	r2, [r3, #0]
    ChanMaskSetParams_t chanMaskSet;
    VerifyParams_t verify;

    if( mibSet == NULL )
 8013e40:	687b      	ldr	r3, [r7, #4]
 8013e42:	2b00      	cmp	r3, #0
 8013e44:	d102      	bne.n	8013e4c <LoRaMacMibSetRequestConfirm+0x1c>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8013e46:	2303      	movs	r3, #3
 8013e48:	f000 fcde 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
    }
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8013e4c:	4adb      	ldr	r2, [pc, #876]	; (80141bc <LoRaMacMibSetRequestConfirm+0x38c>)
 8013e4e:	23d0      	movs	r3, #208	; 0xd0
 8013e50:	009b      	lsls	r3, r3, #2
 8013e52:	58d3      	ldr	r3, [r2, r3]
 8013e54:	2202      	movs	r2, #2
 8013e56:	4013      	ands	r3, r2
 8013e58:	d002      	beq.n	8013e60 <LoRaMacMibSetRequestConfirm+0x30>
    {
        return LORAMAC_STATUS_BUSY;
 8013e5a:	2301      	movs	r3, #1
 8013e5c:	f000 fcd4 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
    }

    switch( mibSet->Type )
 8013e60:	687b      	ldr	r3, [r7, #4]
 8013e62:	781b      	ldrb	r3, [r3, #0]
 8013e64:	2b35      	cmp	r3, #53	; 0x35
 8013e66:	d901      	bls.n	8013e6c <LoRaMacMibSetRequestConfirm+0x3c>
 8013e68:	f000 fc87 	bl	801477a <LoRaMacMibSetRequestConfirm+0x94a>
 8013e6c:	009a      	lsls	r2, r3, #2
 8013e6e:	4bd4      	ldr	r3, [pc, #848]	; (80141c0 <LoRaMacMibSetRequestConfirm+0x390>)
 8013e70:	18d3      	adds	r3, r2, r3
 8013e72:	681b      	ldr	r3, [r3, #0]
 8013e74:	469f      	mov	pc, r3
    {
        case MIB_DEVICE_CLASS:
        {
            status = SwitchClass( mibSet->Param.Class );
 8013e76:	687b      	ldr	r3, [r7, #4]
 8013e78:	791b      	ldrb	r3, [r3, #4]
 8013e7a:	2217      	movs	r2, #23
 8013e7c:	18bc      	adds	r4, r7, r2
 8013e7e:	0018      	movs	r0, r3
 8013e80:	f7fd f81a 	bl	8010eb8 <SwitchClass>
 8013e84:	0003      	movs	r3, r0
 8013e86:	7023      	strb	r3, [r4, #0]
            break;
 8013e88:	f000 fcb7 	bl	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_NETWORK_ACTIVATION:
        {
            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )
 8013e8c:	687b      	ldr	r3, [r7, #4]
 8013e8e:	791b      	ldrb	r3, [r3, #4]
 8013e90:	2b02      	cmp	r3, #2
 8013e92:	d009      	beq.n	8013ea8 <LoRaMacMibSetRequestConfirm+0x78>
            {
                MacCtx.NvmCtx->NetworkActivation = mibSet->Param.NetworkActivation;
 8013e94:	4bc9      	ldr	r3, [pc, #804]	; (80141bc <LoRaMacMibSetRequestConfirm+0x38c>)
 8013e96:	4acb      	ldr	r2, [pc, #812]	; (80141c4 <LoRaMacMibSetRequestConfirm+0x394>)
 8013e98:	589a      	ldr	r2, [r3, r2]
 8013e9a:	687b      	ldr	r3, [r7, #4]
 8013e9c:	7919      	ldrb	r1, [r3, #4]
 8013e9e:	23ea      	movs	r3, #234	; 0xea
 8013ea0:	005b      	lsls	r3, r3, #1
 8013ea2:	54d1      	strb	r1, [r2, r3]
            }
            else
            {   // Do not allow to set ACTIVATION_TYPE_OTAA since the MAC will set it automatically after a successful join process.
                status = LORAMAC_STATUS_PARAMETER_INVALID;
            }
            break;
 8013ea4:	f000 fca9 	bl	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8013ea8:	2317      	movs	r3, #23
 8013eaa:	18fb      	adds	r3, r7, r3
 8013eac:	2203      	movs	r2, #3
 8013eae:	701a      	strb	r2, [r3, #0]
            break;
 8013eb0:	f000 fca3 	bl	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_DEV_EUI:
        {
            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )
 8013eb4:	687b      	ldr	r3, [r7, #4]
 8013eb6:	685b      	ldr	r3, [r3, #4]
 8013eb8:	0018      	movs	r0, r3
 8013eba:	f7fb fb35 	bl	800f528 <SecureElementSetDevEui>
 8013ebe:	1e03      	subs	r3, r0, #0
 8013ec0:	d101      	bne.n	8013ec6 <LoRaMacMibSetRequestConfirm+0x96>
 8013ec2:	f000 fc63 	bl	801478c <LoRaMacMibSetRequestConfirm+0x95c>
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8013ec6:	2317      	movs	r3, #23
 8013ec8:	18fb      	adds	r3, r7, r3
 8013eca:	2203      	movs	r2, #3
 8013ecc:	701a      	strb	r2, [r3, #0]
            }
            break;
 8013ece:	f000 fc5d 	bl	801478c <LoRaMacMibSetRequestConfirm+0x95c>
        }
        case MIB_JOIN_EUI:
        {
            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )
 8013ed2:	687b      	ldr	r3, [r7, #4]
 8013ed4:	685b      	ldr	r3, [r3, #4]
 8013ed6:	0018      	movs	r0, r3
 8013ed8:	f7fb fb4a 	bl	800f570 <SecureElementSetJoinEui>
 8013edc:	1e03      	subs	r3, r0, #0
 8013ede:	d101      	bne.n	8013ee4 <LoRaMacMibSetRequestConfirm+0xb4>
 8013ee0:	f000 fc56 	bl	8014790 <LoRaMacMibSetRequestConfirm+0x960>
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8013ee4:	2317      	movs	r3, #23
 8013ee6:	18fb      	adds	r3, r7, r3
 8013ee8:	2203      	movs	r2, #3
 8013eea:	701a      	strb	r2, [r3, #0]
            }
            break;
 8013eec:	f000 fc50 	bl	8014790 <LoRaMacMibSetRequestConfirm+0x960>
        }
        case MIB_ADR:
        {
            MacCtx.NvmCtx->AdrCtrlOn = mibSet->Param.AdrEnable;
 8013ef0:	4bb2      	ldr	r3, [pc, #712]	; (80141bc <LoRaMacMibSetRequestConfirm+0x38c>)
 8013ef2:	4ab4      	ldr	r2, [pc, #720]	; (80141c4 <LoRaMacMibSetRequestConfirm+0x394>)
 8013ef4:	589b      	ldr	r3, [r3, r2]
 8013ef6:	687a      	ldr	r2, [r7, #4]
 8013ef8:	7911      	ldrb	r1, [r2, #4]
 8013efa:	22f2      	movs	r2, #242	; 0xf2
 8013efc:	5499      	strb	r1, [r3, r2]
            break;
 8013efe:	f000 fc7c 	bl	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_NET_ID:
        {
            MacCtx.NvmCtx->NetID = mibSet->Param.NetID;
 8013f02:	4bae      	ldr	r3, [pc, #696]	; (80141bc <LoRaMacMibSetRequestConfirm+0x38c>)
 8013f04:	4aaf      	ldr	r2, [pc, #700]	; (80141c4 <LoRaMacMibSetRequestConfirm+0x394>)
 8013f06:	589b      	ldr	r3, [r3, r2]
 8013f08:	687a      	ldr	r2, [r7, #4]
 8013f0a:	6852      	ldr	r2, [r2, #4]
 8013f0c:	649a      	str	r2, [r3, #72]	; 0x48
            break;
 8013f0e:	f000 fc74 	bl	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_DEV_ADDR:
        {
            MacCtx.NvmCtx->DevAddr = mibSet->Param.DevAddr;
 8013f12:	4baa      	ldr	r3, [pc, #680]	; (80141bc <LoRaMacMibSetRequestConfirm+0x38c>)
 8013f14:	4aab      	ldr	r2, [pc, #684]	; (80141c4 <LoRaMacMibSetRequestConfirm+0x394>)
 8013f16:	589b      	ldr	r3, [r3, r2]
 8013f18:	687a      	ldr	r2, [r7, #4]
 8013f1a:	6852      	ldr	r2, [r2, #4]
 8013f1c:	64da      	str	r2, [r3, #76]	; 0x4c
            break;
 8013f1e:	f000 fc6c 	bl	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_GEN_APP_KEY:
        {
            if( mibSet->Param.GenAppKey != NULL )
 8013f22:	687b      	ldr	r3, [r7, #4]
 8013f24:	685b      	ldr	r3, [r3, #4]
 8013f26:	2b00      	cmp	r3, #0
 8013f28:	d00c      	beq.n	8013f44 <LoRaMacMibSetRequestConfirm+0x114>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( GEN_APP_KEY, mibSet->Param.GenAppKey ) )
 8013f2a:	687b      	ldr	r3, [r7, #4]
 8013f2c:	685b      	ldr	r3, [r3, #4]
 8013f2e:	0019      	movs	r1, r3
 8013f30:	2001      	movs	r0, #1
 8013f32:	f002 faf7 	bl	8016524 <LoRaMacCryptoSetKey>
 8013f36:	1e03      	subs	r3, r0, #0
 8013f38:	d101      	bne.n	8013f3e <LoRaMacMibSetRequestConfirm+0x10e>
 8013f3a:	f000 fc2b 	bl	8014794 <LoRaMacMibSetRequestConfirm+0x964>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8013f3e:	2311      	movs	r3, #17
 8013f40:	f000 fc62 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8013f44:	2317      	movs	r3, #23
 8013f46:	18fb      	adds	r3, r7, r3
 8013f48:	2203      	movs	r2, #3
 8013f4a:	701a      	strb	r2, [r3, #0]
            }
            break;
 8013f4c:	f000 fc22 	bl	8014794 <LoRaMacMibSetRequestConfirm+0x964>
        }
        case MIB_APP_KEY:
        {
            if( mibSet->Param.AppKey != NULL )
 8013f50:	687b      	ldr	r3, [r7, #4]
 8013f52:	685b      	ldr	r3, [r3, #4]
 8013f54:	2b00      	cmp	r3, #0
 8013f56:	d00c      	beq.n	8013f72 <LoRaMacMibSetRequestConfirm+0x142>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )
 8013f58:	687b      	ldr	r3, [r7, #4]
 8013f5a:	685b      	ldr	r3, [r3, #4]
 8013f5c:	0019      	movs	r1, r3
 8013f5e:	2000      	movs	r0, #0
 8013f60:	f002 fae0 	bl	8016524 <LoRaMacCryptoSetKey>
 8013f64:	1e03      	subs	r3, r0, #0
 8013f66:	d101      	bne.n	8013f6c <LoRaMacMibSetRequestConfirm+0x13c>
 8013f68:	f000 fc16 	bl	8014798 <LoRaMacMibSetRequestConfirm+0x968>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8013f6c:	2311      	movs	r3, #17
 8013f6e:	f000 fc4b 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8013f72:	2317      	movs	r3, #23
 8013f74:	18fb      	adds	r3, r7, r3
 8013f76:	2203      	movs	r2, #3
 8013f78:	701a      	strb	r2, [r3, #0]
            }
            break;
 8013f7a:	f000 fc0d 	bl	8014798 <LoRaMacMibSetRequestConfirm+0x968>
        }
        case MIB_NWK_KEY:
        {
            if( mibSet->Param.NwkKey != NULL )
 8013f7e:	687b      	ldr	r3, [r7, #4]
 8013f80:	685b      	ldr	r3, [r3, #4]
 8013f82:	2b00      	cmp	r3, #0
 8013f84:	d00c      	beq.n	8013fa0 <LoRaMacMibSetRequestConfirm+0x170>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )
 8013f86:	687b      	ldr	r3, [r7, #4]
 8013f88:	685b      	ldr	r3, [r3, #4]
 8013f8a:	0019      	movs	r1, r3
 8013f8c:	2002      	movs	r0, #2
 8013f8e:	f002 fac9 	bl	8016524 <LoRaMacCryptoSetKey>
 8013f92:	1e03      	subs	r3, r0, #0
 8013f94:	d101      	bne.n	8013f9a <LoRaMacMibSetRequestConfirm+0x16a>
 8013f96:	f000 fc01 	bl	801479c <LoRaMacMibSetRequestConfirm+0x96c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8013f9a:	2311      	movs	r3, #17
 8013f9c:	f000 fc34 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8013fa0:	2317      	movs	r3, #23
 8013fa2:	18fb      	adds	r3, r7, r3
 8013fa4:	2203      	movs	r2, #3
 8013fa6:	701a      	strb	r2, [r3, #0]
            }
            break;
 8013fa8:	f000 fbf8 	bl	801479c <LoRaMacMibSetRequestConfirm+0x96c>
        }
        case MIB_J_S_INT_KEY:
        {
            if( mibSet->Param.JSIntKey != NULL )
 8013fac:	687b      	ldr	r3, [r7, #4]
 8013fae:	685b      	ldr	r3, [r3, #4]
 8013fb0:	2b00      	cmp	r3, #0
 8013fb2:	d00c      	beq.n	8013fce <LoRaMacMibSetRequestConfirm+0x19e>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( J_S_INT_KEY, mibSet->Param.JSIntKey ) )
 8013fb4:	687b      	ldr	r3, [r7, #4]
 8013fb6:	685b      	ldr	r3, [r3, #4]
 8013fb8:	0019      	movs	r1, r3
 8013fba:	2003      	movs	r0, #3
 8013fbc:	f002 fab2 	bl	8016524 <LoRaMacCryptoSetKey>
 8013fc0:	1e03      	subs	r3, r0, #0
 8013fc2:	d101      	bne.n	8013fc8 <LoRaMacMibSetRequestConfirm+0x198>
 8013fc4:	f000 fbec 	bl	80147a0 <LoRaMacMibSetRequestConfirm+0x970>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8013fc8:	2311      	movs	r3, #17
 8013fca:	f000 fc1d 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8013fce:	2317      	movs	r3, #23
 8013fd0:	18fb      	adds	r3, r7, r3
 8013fd2:	2203      	movs	r2, #3
 8013fd4:	701a      	strb	r2, [r3, #0]
            }
            break;
 8013fd6:	f000 fbe3 	bl	80147a0 <LoRaMacMibSetRequestConfirm+0x970>
        }
        case MIB_J_S_ENC_KEY:
        {
            if( mibSet->Param.JSEncKey != NULL )
 8013fda:	687b      	ldr	r3, [r7, #4]
 8013fdc:	685b      	ldr	r3, [r3, #4]
 8013fde:	2b00      	cmp	r3, #0
 8013fe0:	d00c      	beq.n	8013ffc <LoRaMacMibSetRequestConfirm+0x1cc>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( J_S_ENC_KEY, mibSet->Param.JSEncKey ) )
 8013fe2:	687b      	ldr	r3, [r7, #4]
 8013fe4:	685b      	ldr	r3, [r3, #4]
 8013fe6:	0019      	movs	r1, r3
 8013fe8:	2004      	movs	r0, #4
 8013fea:	f002 fa9b 	bl	8016524 <LoRaMacCryptoSetKey>
 8013fee:	1e03      	subs	r3, r0, #0
 8013ff0:	d101      	bne.n	8013ff6 <LoRaMacMibSetRequestConfirm+0x1c6>
 8013ff2:	f000 fbd7 	bl	80147a4 <LoRaMacMibSetRequestConfirm+0x974>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8013ff6:	2311      	movs	r3, #17
 8013ff8:	f000 fc06 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8013ffc:	2317      	movs	r3, #23
 8013ffe:	18fb      	adds	r3, r7, r3
 8014000:	2203      	movs	r2, #3
 8014002:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014004:	f000 fbce 	bl	80147a4 <LoRaMacMibSetRequestConfirm+0x974>
        }
        case MIB_F_NWK_S_INT_KEY:
        {
            if( mibSet->Param.FNwkSIntKey != NULL )
 8014008:	687b      	ldr	r3, [r7, #4]
 801400a:	685b      	ldr	r3, [r3, #4]
 801400c:	2b00      	cmp	r3, #0
 801400e:	d00c      	beq.n	801402a <LoRaMacMibSetRequestConfirm+0x1fa>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( F_NWK_S_INT_KEY, mibSet->Param.FNwkSIntKey ) )
 8014010:	687b      	ldr	r3, [r7, #4]
 8014012:	685b      	ldr	r3, [r3, #4]
 8014014:	0019      	movs	r1, r3
 8014016:	2005      	movs	r0, #5
 8014018:	f002 fa84 	bl	8016524 <LoRaMacCryptoSetKey>
 801401c:	1e03      	subs	r3, r0, #0
 801401e:	d101      	bne.n	8014024 <LoRaMacMibSetRequestConfirm+0x1f4>
 8014020:	f000 fbc2 	bl	80147a8 <LoRaMacMibSetRequestConfirm+0x978>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8014024:	2311      	movs	r3, #17
 8014026:	f000 fbef 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 801402a:	2317      	movs	r3, #23
 801402c:	18fb      	adds	r3, r7, r3
 801402e:	2203      	movs	r2, #3
 8014030:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014032:	f000 fbb9 	bl	80147a8 <LoRaMacMibSetRequestConfirm+0x978>
        }
        case MIB_S_NWK_S_INT_KEY:
        {
            if( mibSet->Param.SNwkSIntKey != NULL )
 8014036:	687b      	ldr	r3, [r7, #4]
 8014038:	685b      	ldr	r3, [r3, #4]
 801403a:	2b00      	cmp	r3, #0
 801403c:	d00c      	beq.n	8014058 <LoRaMacMibSetRequestConfirm+0x228>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( S_NWK_S_INT_KEY, mibSet->Param.SNwkSIntKey ) )
 801403e:	687b      	ldr	r3, [r7, #4]
 8014040:	685b      	ldr	r3, [r3, #4]
 8014042:	0019      	movs	r1, r3
 8014044:	2006      	movs	r0, #6
 8014046:	f002 fa6d 	bl	8016524 <LoRaMacCryptoSetKey>
 801404a:	1e03      	subs	r3, r0, #0
 801404c:	d101      	bne.n	8014052 <LoRaMacMibSetRequestConfirm+0x222>
 801404e:	f000 fbad 	bl	80147ac <LoRaMacMibSetRequestConfirm+0x97c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8014052:	2311      	movs	r3, #17
 8014054:	f000 fbd8 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014058:	2317      	movs	r3, #23
 801405a:	18fb      	adds	r3, r7, r3
 801405c:	2203      	movs	r2, #3
 801405e:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014060:	f000 fba4 	bl	80147ac <LoRaMacMibSetRequestConfirm+0x97c>
        }
        case MIB_NWK_S_ENC_KEY:
        {
            if( mibSet->Param.NwkSEncKey != NULL )
 8014064:	687b      	ldr	r3, [r7, #4]
 8014066:	685b      	ldr	r3, [r3, #4]
 8014068:	2b00      	cmp	r3, #0
 801406a:	d00c      	beq.n	8014086 <LoRaMacMibSetRequestConfirm+0x256>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_ENC_KEY, mibSet->Param.NwkSEncKey ) )
 801406c:	687b      	ldr	r3, [r7, #4]
 801406e:	685b      	ldr	r3, [r3, #4]
 8014070:	0019      	movs	r1, r3
 8014072:	2007      	movs	r0, #7
 8014074:	f002 fa56 	bl	8016524 <LoRaMacCryptoSetKey>
 8014078:	1e03      	subs	r3, r0, #0
 801407a:	d101      	bne.n	8014080 <LoRaMacMibSetRequestConfirm+0x250>
 801407c:	f000 fb98 	bl	80147b0 <LoRaMacMibSetRequestConfirm+0x980>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8014080:	2311      	movs	r3, #17
 8014082:	f000 fbc1 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014086:	2317      	movs	r3, #23
 8014088:	18fb      	adds	r3, r7, r3
 801408a:	2203      	movs	r2, #3
 801408c:	701a      	strb	r2, [r3, #0]
            }
            break;
 801408e:	f000 fb8f 	bl	80147b0 <LoRaMacMibSetRequestConfirm+0x980>
        }
        case MIB_APP_S_KEY:
        {
            if( mibSet->Param.AppSKey != NULL )
 8014092:	687b      	ldr	r3, [r7, #4]
 8014094:	685b      	ldr	r3, [r3, #4]
 8014096:	2b00      	cmp	r3, #0
 8014098:	d00c      	beq.n	80140b4 <LoRaMacMibSetRequestConfirm+0x284>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )
 801409a:	687b      	ldr	r3, [r7, #4]
 801409c:	685b      	ldr	r3, [r3, #4]
 801409e:	0019      	movs	r1, r3
 80140a0:	2008      	movs	r0, #8
 80140a2:	f002 fa3f 	bl	8016524 <LoRaMacCryptoSetKey>
 80140a6:	1e03      	subs	r3, r0, #0
 80140a8:	d101      	bne.n	80140ae <LoRaMacMibSetRequestConfirm+0x27e>
 80140aa:	f000 fb83 	bl	80147b4 <LoRaMacMibSetRequestConfirm+0x984>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 80140ae:	2311      	movs	r3, #17
 80140b0:	f000 fbaa 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 80140b4:	2317      	movs	r3, #23
 80140b6:	18fb      	adds	r3, r7, r3
 80140b8:	2203      	movs	r2, #3
 80140ba:	701a      	strb	r2, [r3, #0]
            }
            break;
 80140bc:	f000 fb7a 	bl	80147b4 <LoRaMacMibSetRequestConfirm+0x984>
        }
        case MIB_MC_KE_KEY:
        {
            if( mibSet->Param.McKEKey != NULL )
 80140c0:	687b      	ldr	r3, [r7, #4]
 80140c2:	685b      	ldr	r3, [r3, #4]
 80140c4:	2b00      	cmp	r3, #0
 80140c6:	d00c      	beq.n	80140e2 <LoRaMacMibSetRequestConfirm+0x2b2>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )
 80140c8:	687b      	ldr	r3, [r7, #4]
 80140ca:	685b      	ldr	r3, [r3, #4]
 80140cc:	0019      	movs	r1, r3
 80140ce:	207f      	movs	r0, #127	; 0x7f
 80140d0:	f002 fa28 	bl	8016524 <LoRaMacCryptoSetKey>
 80140d4:	1e03      	subs	r3, r0, #0
 80140d6:	d101      	bne.n	80140dc <LoRaMacMibSetRequestConfirm+0x2ac>
 80140d8:	f000 fb6e 	bl	80147b8 <LoRaMacMibSetRequestConfirm+0x988>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 80140dc:	2311      	movs	r3, #17
 80140de:	f000 fb93 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 80140e2:	2317      	movs	r3, #23
 80140e4:	18fb      	adds	r3, r7, r3
 80140e6:	2203      	movs	r2, #3
 80140e8:	701a      	strb	r2, [r3, #0]
            }
            break;
 80140ea:	f000 fb65 	bl	80147b8 <LoRaMacMibSetRequestConfirm+0x988>
        }
        case MIB_MC_KEY_0:
        {
            if( mibSet->Param.McKey0 != NULL )
 80140ee:	687b      	ldr	r3, [r7, #4]
 80140f0:	685b      	ldr	r3, [r3, #4]
 80140f2:	2b00      	cmp	r3, #0
 80140f4:	d00b      	beq.n	801410e <LoRaMacMibSetRequestConfirm+0x2de>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )
 80140f6:	687b      	ldr	r3, [r7, #4]
 80140f8:	685b      	ldr	r3, [r3, #4]
 80140fa:	0019      	movs	r1, r3
 80140fc:	2080      	movs	r0, #128	; 0x80
 80140fe:	f002 fa11 	bl	8016524 <LoRaMacCryptoSetKey>
 8014102:	1e03      	subs	r3, r0, #0
 8014104:	d100      	bne.n	8014108 <LoRaMacMibSetRequestConfirm+0x2d8>
 8014106:	e359      	b.n	80147bc <LoRaMacMibSetRequestConfirm+0x98c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8014108:	2311      	movs	r3, #17
 801410a:	f000 fb7d 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 801410e:	2317      	movs	r3, #23
 8014110:	18fb      	adds	r3, r7, r3
 8014112:	2203      	movs	r2, #3
 8014114:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014116:	e351      	b.n	80147bc <LoRaMacMibSetRequestConfirm+0x98c>
        }
        case MIB_MC_APP_S_KEY_0:
        {
            if( mibSet->Param.McAppSKey0 != NULL )
 8014118:	687b      	ldr	r3, [r7, #4]
 801411a:	685b      	ldr	r3, [r3, #4]
 801411c:	2b00      	cmp	r3, #0
 801411e:	d00b      	beq.n	8014138 <LoRaMacMibSetRequestConfirm+0x308>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )
 8014120:	687b      	ldr	r3, [r7, #4]
 8014122:	685b      	ldr	r3, [r3, #4]
 8014124:	0019      	movs	r1, r3
 8014126:	2081      	movs	r0, #129	; 0x81
 8014128:	f002 f9fc 	bl	8016524 <LoRaMacCryptoSetKey>
 801412c:	1e03      	subs	r3, r0, #0
 801412e:	d100      	bne.n	8014132 <LoRaMacMibSetRequestConfirm+0x302>
 8014130:	e346      	b.n	80147c0 <LoRaMacMibSetRequestConfirm+0x990>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8014132:	2311      	movs	r3, #17
 8014134:	f000 fb68 	bl	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014138:	2317      	movs	r3, #23
 801413a:	18fb      	adds	r3, r7, r3
 801413c:	2203      	movs	r2, #3
 801413e:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014140:	e33e      	b.n	80147c0 <LoRaMacMibSetRequestConfirm+0x990>
        }
        case MIB_MC_NWK_S_KEY_0:
        {
            if( mibSet->Param.McNwkSKey0 != NULL )
 8014142:	687b      	ldr	r3, [r7, #4]
 8014144:	685b      	ldr	r3, [r3, #4]
 8014146:	2b00      	cmp	r3, #0
 8014148:	d00a      	beq.n	8014160 <LoRaMacMibSetRequestConfirm+0x330>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )
 801414a:	687b      	ldr	r3, [r7, #4]
 801414c:	685b      	ldr	r3, [r3, #4]
 801414e:	0019      	movs	r1, r3
 8014150:	2082      	movs	r0, #130	; 0x82
 8014152:	f002 f9e7 	bl	8016524 <LoRaMacCryptoSetKey>
 8014156:	1e03      	subs	r3, r0, #0
 8014158:	d100      	bne.n	801415c <LoRaMacMibSetRequestConfirm+0x32c>
 801415a:	e333      	b.n	80147c4 <LoRaMacMibSetRequestConfirm+0x994>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 801415c:	2311      	movs	r3, #17
 801415e:	e353      	b.n	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014160:	2317      	movs	r3, #23
 8014162:	18fb      	adds	r3, r7, r3
 8014164:	2203      	movs	r2, #3
 8014166:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014168:	e32c      	b.n	80147c4 <LoRaMacMibSetRequestConfirm+0x994>
        }
        case MIB_MC_KEY_1:
        {
            if( mibSet->Param.McKey1 != NULL )
 801416a:	687b      	ldr	r3, [r7, #4]
 801416c:	685b      	ldr	r3, [r3, #4]
 801416e:	2b00      	cmp	r3, #0
 8014170:	d00a      	beq.n	8014188 <LoRaMacMibSetRequestConfirm+0x358>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_1, mibSet->Param.McKey1 ) )
 8014172:	687b      	ldr	r3, [r7, #4]
 8014174:	685b      	ldr	r3, [r3, #4]
 8014176:	0019      	movs	r1, r3
 8014178:	2083      	movs	r0, #131	; 0x83
 801417a:	f002 f9d3 	bl	8016524 <LoRaMacCryptoSetKey>
 801417e:	1e03      	subs	r3, r0, #0
 8014180:	d100      	bne.n	8014184 <LoRaMacMibSetRequestConfirm+0x354>
 8014182:	e321      	b.n	80147c8 <LoRaMacMibSetRequestConfirm+0x998>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8014184:	2311      	movs	r3, #17
 8014186:	e33f      	b.n	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014188:	2317      	movs	r3, #23
 801418a:	18fb      	adds	r3, r7, r3
 801418c:	2203      	movs	r2, #3
 801418e:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014190:	e31a      	b.n	80147c8 <LoRaMacMibSetRequestConfirm+0x998>
        }
        case MIB_MC_APP_S_KEY_1:
        {
            if( mibSet->Param.McAppSKey1 != NULL )
 8014192:	687b      	ldr	r3, [r7, #4]
 8014194:	685b      	ldr	r3, [r3, #4]
 8014196:	2b00      	cmp	r3, #0
 8014198:	d00a      	beq.n	80141b0 <LoRaMacMibSetRequestConfirm+0x380>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_1, mibSet->Param.McAppSKey1 ) )
 801419a:	687b      	ldr	r3, [r7, #4]
 801419c:	685b      	ldr	r3, [r3, #4]
 801419e:	0019      	movs	r1, r3
 80141a0:	2084      	movs	r0, #132	; 0x84
 80141a2:	f002 f9bf 	bl	8016524 <LoRaMacCryptoSetKey>
 80141a6:	1e03      	subs	r3, r0, #0
 80141a8:	d100      	bne.n	80141ac <LoRaMacMibSetRequestConfirm+0x37c>
 80141aa:	e30f      	b.n	80147cc <LoRaMacMibSetRequestConfirm+0x99c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 80141ac:	2311      	movs	r3, #17
 80141ae:	e32b      	b.n	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 80141b0:	2317      	movs	r3, #23
 80141b2:	18fb      	adds	r3, r7, r3
 80141b4:	2203      	movs	r2, #3
 80141b6:	701a      	strb	r2, [r3, #0]
            }
            break;
 80141b8:	e308      	b.n	80147cc <LoRaMacMibSetRequestConfirm+0x99c>
 80141ba:	46c0      	nop			; (mov r8, r8)
 80141bc:	200008ec 	.word	0x200008ec
 80141c0:	0801f304 	.word	0x0801f304
 80141c4:	00000484 	.word	0x00000484
        }
        case MIB_MC_NWK_S_KEY_1:
        {
            if( mibSet->Param.McNwkSKey1 != NULL )
 80141c8:	687b      	ldr	r3, [r7, #4]
 80141ca:	685b      	ldr	r3, [r3, #4]
 80141cc:	2b00      	cmp	r3, #0
 80141ce:	d00a      	beq.n	80141e6 <LoRaMacMibSetRequestConfirm+0x3b6>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_1, mibSet->Param.McNwkSKey1 ) )
 80141d0:	687b      	ldr	r3, [r7, #4]
 80141d2:	685b      	ldr	r3, [r3, #4]
 80141d4:	0019      	movs	r1, r3
 80141d6:	2085      	movs	r0, #133	; 0x85
 80141d8:	f002 f9a4 	bl	8016524 <LoRaMacCryptoSetKey>
 80141dc:	1e03      	subs	r3, r0, #0
 80141de:	d100      	bne.n	80141e2 <LoRaMacMibSetRequestConfirm+0x3b2>
 80141e0:	e2f6      	b.n	80147d0 <LoRaMacMibSetRequestConfirm+0x9a0>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 80141e2:	2311      	movs	r3, #17
 80141e4:	e310      	b.n	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 80141e6:	2317      	movs	r3, #23
 80141e8:	18fb      	adds	r3, r7, r3
 80141ea:	2203      	movs	r2, #3
 80141ec:	701a      	strb	r2, [r3, #0]
            }
            break;
 80141ee:	e2ef      	b.n	80147d0 <LoRaMacMibSetRequestConfirm+0x9a0>
        }
        case MIB_MC_KEY_2:
        {
            if( mibSet->Param.McKey2 != NULL )
 80141f0:	687b      	ldr	r3, [r7, #4]
 80141f2:	685b      	ldr	r3, [r3, #4]
 80141f4:	2b00      	cmp	r3, #0
 80141f6:	d00a      	beq.n	801420e <LoRaMacMibSetRequestConfirm+0x3de>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_2, mibSet->Param.McKey2 ) )
 80141f8:	687b      	ldr	r3, [r7, #4]
 80141fa:	685b      	ldr	r3, [r3, #4]
 80141fc:	0019      	movs	r1, r3
 80141fe:	2086      	movs	r0, #134	; 0x86
 8014200:	f002 f990 	bl	8016524 <LoRaMacCryptoSetKey>
 8014204:	1e03      	subs	r3, r0, #0
 8014206:	d100      	bne.n	801420a <LoRaMacMibSetRequestConfirm+0x3da>
 8014208:	e2e4      	b.n	80147d4 <LoRaMacMibSetRequestConfirm+0x9a4>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 801420a:	2311      	movs	r3, #17
 801420c:	e2fc      	b.n	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 801420e:	2317      	movs	r3, #23
 8014210:	18fb      	adds	r3, r7, r3
 8014212:	2203      	movs	r2, #3
 8014214:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014216:	e2dd      	b.n	80147d4 <LoRaMacMibSetRequestConfirm+0x9a4>
        }
        case MIB_MC_APP_S_KEY_2:
        {
            if( mibSet->Param.McAppSKey2 != NULL )
 8014218:	687b      	ldr	r3, [r7, #4]
 801421a:	685b      	ldr	r3, [r3, #4]
 801421c:	2b00      	cmp	r3, #0
 801421e:	d00a      	beq.n	8014236 <LoRaMacMibSetRequestConfirm+0x406>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_2, mibSet->Param.McAppSKey2 ) )
 8014220:	687b      	ldr	r3, [r7, #4]
 8014222:	685b      	ldr	r3, [r3, #4]
 8014224:	0019      	movs	r1, r3
 8014226:	2087      	movs	r0, #135	; 0x87
 8014228:	f002 f97c 	bl	8016524 <LoRaMacCryptoSetKey>
 801422c:	1e03      	subs	r3, r0, #0
 801422e:	d100      	bne.n	8014232 <LoRaMacMibSetRequestConfirm+0x402>
 8014230:	e2d2      	b.n	80147d8 <LoRaMacMibSetRequestConfirm+0x9a8>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8014232:	2311      	movs	r3, #17
 8014234:	e2e8      	b.n	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014236:	2317      	movs	r3, #23
 8014238:	18fb      	adds	r3, r7, r3
 801423a:	2203      	movs	r2, #3
 801423c:	701a      	strb	r2, [r3, #0]
            }
            break;
 801423e:	e2cb      	b.n	80147d8 <LoRaMacMibSetRequestConfirm+0x9a8>
        }
        case MIB_MC_NWK_S_KEY_2:
        {
            if( mibSet->Param.McNwkSKey2 != NULL )
 8014240:	687b      	ldr	r3, [r7, #4]
 8014242:	685b      	ldr	r3, [r3, #4]
 8014244:	2b00      	cmp	r3, #0
 8014246:	d00a      	beq.n	801425e <LoRaMacMibSetRequestConfirm+0x42e>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_2, mibSet->Param.McNwkSKey2 ) )
 8014248:	687b      	ldr	r3, [r7, #4]
 801424a:	685b      	ldr	r3, [r3, #4]
 801424c:	0019      	movs	r1, r3
 801424e:	2088      	movs	r0, #136	; 0x88
 8014250:	f002 f968 	bl	8016524 <LoRaMacCryptoSetKey>
 8014254:	1e03      	subs	r3, r0, #0
 8014256:	d100      	bne.n	801425a <LoRaMacMibSetRequestConfirm+0x42a>
 8014258:	e2c0      	b.n	80147dc <LoRaMacMibSetRequestConfirm+0x9ac>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 801425a:	2311      	movs	r3, #17
 801425c:	e2d4      	b.n	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 801425e:	2317      	movs	r3, #23
 8014260:	18fb      	adds	r3, r7, r3
 8014262:	2203      	movs	r2, #3
 8014264:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014266:	e2b9      	b.n	80147dc <LoRaMacMibSetRequestConfirm+0x9ac>
        }
        case MIB_MC_KEY_3:
        {
            if( mibSet->Param.McKey3 != NULL )
 8014268:	687b      	ldr	r3, [r7, #4]
 801426a:	685b      	ldr	r3, [r3, #4]
 801426c:	2b00      	cmp	r3, #0
 801426e:	d00a      	beq.n	8014286 <LoRaMacMibSetRequestConfirm+0x456>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_3, mibSet->Param.McKey3 ) )
 8014270:	687b      	ldr	r3, [r7, #4]
 8014272:	685b      	ldr	r3, [r3, #4]
 8014274:	0019      	movs	r1, r3
 8014276:	2089      	movs	r0, #137	; 0x89
 8014278:	f002 f954 	bl	8016524 <LoRaMacCryptoSetKey>
 801427c:	1e03      	subs	r3, r0, #0
 801427e:	d100      	bne.n	8014282 <LoRaMacMibSetRequestConfirm+0x452>
 8014280:	e2ae      	b.n	80147e0 <LoRaMacMibSetRequestConfirm+0x9b0>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8014282:	2311      	movs	r3, #17
 8014284:	e2c0      	b.n	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014286:	2317      	movs	r3, #23
 8014288:	18fb      	adds	r3, r7, r3
 801428a:	2203      	movs	r2, #3
 801428c:	701a      	strb	r2, [r3, #0]
            }
            break;
 801428e:	e2a7      	b.n	80147e0 <LoRaMacMibSetRequestConfirm+0x9b0>
        }
        case MIB_MC_APP_S_KEY_3:
        {
            if( mibSet->Param.McAppSKey3 != NULL )
 8014290:	687b      	ldr	r3, [r7, #4]
 8014292:	685b      	ldr	r3, [r3, #4]
 8014294:	2b00      	cmp	r3, #0
 8014296:	d00a      	beq.n	80142ae <LoRaMacMibSetRequestConfirm+0x47e>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_3, mibSet->Param.McAppSKey3 ) )
 8014298:	687b      	ldr	r3, [r7, #4]
 801429a:	685b      	ldr	r3, [r3, #4]
 801429c:	0019      	movs	r1, r3
 801429e:	208a      	movs	r0, #138	; 0x8a
 80142a0:	f002 f940 	bl	8016524 <LoRaMacCryptoSetKey>
 80142a4:	1e03      	subs	r3, r0, #0
 80142a6:	d100      	bne.n	80142aa <LoRaMacMibSetRequestConfirm+0x47a>
 80142a8:	e29c      	b.n	80147e4 <LoRaMacMibSetRequestConfirm+0x9b4>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 80142aa:	2311      	movs	r3, #17
 80142ac:	e2ac      	b.n	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 80142ae:	2317      	movs	r3, #23
 80142b0:	18fb      	adds	r3, r7, r3
 80142b2:	2203      	movs	r2, #3
 80142b4:	701a      	strb	r2, [r3, #0]
            }
            break;
 80142b6:	e295      	b.n	80147e4 <LoRaMacMibSetRequestConfirm+0x9b4>
        }
        case MIB_MC_NWK_S_KEY_3:
        {
            if( mibSet->Param.McNwkSKey3 != NULL )
 80142b8:	687b      	ldr	r3, [r7, #4]
 80142ba:	685b      	ldr	r3, [r3, #4]
 80142bc:	2b00      	cmp	r3, #0
 80142be:	d00a      	beq.n	80142d6 <LoRaMacMibSetRequestConfirm+0x4a6>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_3, mibSet->Param.McNwkSKey3 ) )
 80142c0:	687b      	ldr	r3, [r7, #4]
 80142c2:	685b      	ldr	r3, [r3, #4]
 80142c4:	0019      	movs	r1, r3
 80142c6:	208b      	movs	r0, #139	; 0x8b
 80142c8:	f002 f92c 	bl	8016524 <LoRaMacCryptoSetKey>
 80142cc:	1e03      	subs	r3, r0, #0
 80142ce:	d100      	bne.n	80142d2 <LoRaMacMibSetRequestConfirm+0x4a2>
 80142d0:	e28a      	b.n	80147e8 <LoRaMacMibSetRequestConfirm+0x9b8>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 80142d2:	2311      	movs	r3, #17
 80142d4:	e298      	b.n	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 80142d6:	2317      	movs	r3, #23
 80142d8:	18fb      	adds	r3, r7, r3
 80142da:	2203      	movs	r2, #3
 80142dc:	701a      	strb	r2, [r3, #0]
            }
            break;
 80142de:	e283      	b.n	80147e8 <LoRaMacMibSetRequestConfirm+0x9b8>
        }
        case MIB_PUBLIC_NETWORK:
        {
            MacCtx.NvmCtx->PublicNetwork = mibSet->Param.EnablePublicNetwork;
 80142e0:	4bd7      	ldr	r3, [pc, #860]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 80142e2:	4ad8      	ldr	r2, [pc, #864]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 80142e4:	589b      	ldr	r3, [r3, r2]
 80142e6:	687a      	ldr	r2, [r7, #4]
 80142e8:	7911      	ldrb	r1, [r2, #4]
 80142ea:	22f1      	movs	r2, #241	; 0xf1
 80142ec:	5499      	strb	r1, [r3, r2]
            Radio.SetPublicNetwork( MacCtx.NvmCtx->PublicNetwork );
 80142ee:	4bd6      	ldr	r3, [pc, #856]	; (8014648 <LoRaMacMibSetRequestConfirm+0x818>)
 80142f0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80142f2:	4ad3      	ldr	r2, [pc, #844]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 80142f4:	49d3      	ldr	r1, [pc, #844]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 80142f6:	5852      	ldr	r2, [r2, r1]
 80142f8:	21f1      	movs	r1, #241	; 0xf1
 80142fa:	5c52      	ldrb	r2, [r2, r1]
 80142fc:	0010      	movs	r0, r2
 80142fe:	4798      	blx	r3
            break;
 8014300:	e27b      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_REPEATER_SUPPORT:
        {
            MacCtx.NvmCtx->RepeaterSupport = mibSet->Param.EnableRepeaterSupport;
 8014302:	4bcf      	ldr	r3, [pc, #828]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014304:	4acf      	ldr	r2, [pc, #828]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014306:	589a      	ldr	r2, [r3, r2]
 8014308:	687b      	ldr	r3, [r7, #4]
 801430a:	7919      	ldrb	r1, [r3, #4]
 801430c:	2340      	movs	r3, #64	; 0x40
 801430e:	33ff      	adds	r3, #255	; 0xff
 8014310:	54d1      	strb	r1, [r2, r3]
            break;
 8014312:	e272      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_RX2_CHANNEL:
        {
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 8014314:	687b      	ldr	r3, [r7, #4]
 8014316:	7a1b      	ldrb	r3, [r3, #8]
 8014318:	b25a      	sxtb	r2, r3
 801431a:	2108      	movs	r1, #8
 801431c:	187b      	adds	r3, r7, r1
 801431e:	701a      	strb	r2, [r3, #0]
            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;
 8014320:	4bc7      	ldr	r3, [pc, #796]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014322:	4ac8      	ldr	r2, [pc, #800]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014324:	589a      	ldr	r2, [r3, r2]
 8014326:	232e      	movs	r3, #46	; 0x2e
 8014328:	33ff      	adds	r3, #255	; 0xff
 801432a:	5cd2      	ldrb	r2, [r2, r3]
 801432c:	187b      	adds	r3, r7, r1
 801432e:	705a      	strb	r2, [r3, #1]

            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )
 8014330:	4bc3      	ldr	r3, [pc, #780]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014332:	4ac4      	ldr	r2, [pc, #784]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014334:	589b      	ldr	r3, [r3, r2]
 8014336:	781b      	ldrb	r3, [r3, #0]
 8014338:	1879      	adds	r1, r7, r1
 801433a:	2207      	movs	r2, #7
 801433c:	0018      	movs	r0, r3
 801433e:	f003 f955 	bl	80175ec <RegionVerify>
 8014342:	1e03      	subs	r3, r0, #0
 8014344:	d00a      	beq.n	801435c <LoRaMacMibSetRequestConfirm+0x52c>
            {
                MacCtx.NvmCtx->MacParams.Rx2Channel = mibSet->Param.Rx2Channel;
 8014346:	4bbe      	ldr	r3, [pc, #760]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014348:	4abe      	ldr	r2, [pc, #760]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 801434a:	5899      	ldr	r1, [r3, r2]
 801434c:	238e      	movs	r3, #142	; 0x8e
 801434e:	005b      	lsls	r3, r3, #1
 8014350:	687a      	ldr	r2, [r7, #4]
 8014352:	18cb      	adds	r3, r1, r3
 8014354:	3204      	adds	r2, #4
 8014356:	ca03      	ldmia	r2!, {r0, r1}
 8014358:	c303      	stmia	r3!, {r0, r1}
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
            }
            break;
 801435a:	e24e      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 801435c:	2317      	movs	r3, #23
 801435e:	18fb      	adds	r3, r7, r3
 8014360:	2203      	movs	r2, #3
 8014362:	701a      	strb	r2, [r3, #0]
            break;
 8014364:	e249      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_RX2_DEFAULT_CHANNEL:
        {
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 8014366:	687b      	ldr	r3, [r7, #4]
 8014368:	7a1b      	ldrb	r3, [r3, #8]
 801436a:	b25a      	sxtb	r2, r3
 801436c:	2108      	movs	r1, #8
 801436e:	187b      	adds	r3, r7, r1
 8014370:	701a      	strb	r2, [r3, #0]
            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;
 8014372:	4bb3      	ldr	r3, [pc, #716]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014374:	4ab3      	ldr	r2, [pc, #716]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014376:	589a      	ldr	r2, [r3, r2]
 8014378:	232e      	movs	r3, #46	; 0x2e
 801437a:	33ff      	adds	r3, #255	; 0xff
 801437c:	5cd2      	ldrb	r2, [r2, r3]
 801437e:	187b      	adds	r3, r7, r1
 8014380:	705a      	strb	r2, [r3, #1]

            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )
 8014382:	4baf      	ldr	r3, [pc, #700]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014384:	4aaf      	ldr	r2, [pc, #700]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014386:	589b      	ldr	r3, [r3, r2]
 8014388:	781b      	ldrb	r3, [r3, #0]
 801438a:	1879      	adds	r1, r7, r1
 801438c:	2207      	movs	r2, #7
 801438e:	0018      	movs	r0, r3
 8014390:	f003 f92c 	bl	80175ec <RegionVerify>
 8014394:	1e03      	subs	r3, r0, #0
 8014396:	d008      	beq.n	80143aa <LoRaMacMibSetRequestConfirm+0x57a>
            {
                MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 8014398:	4ba9      	ldr	r3, [pc, #676]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 801439a:	4aaa      	ldr	r2, [pc, #680]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 801439c:	589b      	ldr	r3, [r3, r2]
 801439e:	687a      	ldr	r2, [r7, #4]
 80143a0:	3328      	adds	r3, #40	; 0x28
 80143a2:	3204      	adds	r2, #4
 80143a4:	ca03      	ldmia	r2!, {r0, r1}
 80143a6:	c303      	stmia	r3!, {r0, r1}
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
            }
            break;
 80143a8:	e227      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 80143aa:	2317      	movs	r3, #23
 80143ac:	18fb      	adds	r3, r7, r3
 80143ae:	2203      	movs	r2, #3
 80143b0:	701a      	strb	r2, [r3, #0]
            break;
 80143b2:	e222      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_RXC_CHANNEL:
        {
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 80143b4:	687b      	ldr	r3, [r7, #4]
 80143b6:	7a1b      	ldrb	r3, [r3, #8]
 80143b8:	b25a      	sxtb	r2, r3
 80143ba:	2108      	movs	r1, #8
 80143bc:	187b      	adds	r3, r7, r1
 80143be:	701a      	strb	r2, [r3, #0]
            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;
 80143c0:	4b9f      	ldr	r3, [pc, #636]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 80143c2:	4aa0      	ldr	r2, [pc, #640]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 80143c4:	589a      	ldr	r2, [r3, r2]
 80143c6:	232e      	movs	r3, #46	; 0x2e
 80143c8:	33ff      	adds	r3, #255	; 0xff
 80143ca:	5cd2      	ldrb	r2, [r2, r3]
 80143cc:	187b      	adds	r3, r7, r1
 80143ce:	705a      	strb	r2, [r3, #1]

            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )
 80143d0:	4b9b      	ldr	r3, [pc, #620]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 80143d2:	4a9c      	ldr	r2, [pc, #624]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 80143d4:	589b      	ldr	r3, [r3, r2]
 80143d6:	781b      	ldrb	r3, [r3, #0]
 80143d8:	1879      	adds	r1, r7, r1
 80143da:	2207      	movs	r2, #7
 80143dc:	0018      	movs	r0, r3
 80143de:	f003 f905 	bl	80175ec <RegionVerify>
 80143e2:	1e03      	subs	r3, r0, #0
 80143e4:	d03b      	beq.n	801445e <LoRaMacMibSetRequestConfirm+0x62e>
            {
                MacCtx.NvmCtx->MacParams.RxCChannel = mibSet->Param.RxCChannel;
 80143e6:	4b96      	ldr	r3, [pc, #600]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 80143e8:	4a96      	ldr	r2, [pc, #600]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 80143ea:	5899      	ldr	r1, [r3, r2]
 80143ec:	2392      	movs	r3, #146	; 0x92
 80143ee:	005b      	lsls	r3, r3, #1
 80143f0:	687a      	ldr	r2, [r7, #4]
 80143f2:	18cb      	adds	r3, r1, r3
 80143f4:	3204      	adds	r2, #4
 80143f6:	ca03      	ldmia	r2!, {r0, r1}
 80143f8:	c303      	stmia	r3!, {r0, r1}

                if( ( MacCtx.NvmCtx->DeviceClass == CLASS_C ) && ( MacCtx.NvmCtx->NetworkActivation != ACTIVATION_TYPE_NONE ) )
 80143fa:	4b91      	ldr	r3, [pc, #580]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 80143fc:	4a91      	ldr	r2, [pc, #580]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 80143fe:	589b      	ldr	r3, [r3, r2]
 8014400:	22f0      	movs	r2, #240	; 0xf0
 8014402:	5c9b      	ldrb	r3, [r3, r2]
 8014404:	2b02      	cmp	r3, #2
 8014406:	d000      	beq.n	801440a <LoRaMacMibSetRequestConfirm+0x5da>
 8014408:	e1f0      	b.n	80147ec <LoRaMacMibSetRequestConfirm+0x9bc>
 801440a:	4b8d      	ldr	r3, [pc, #564]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 801440c:	4a8d      	ldr	r2, [pc, #564]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 801440e:	589a      	ldr	r2, [r3, r2]
 8014410:	23ea      	movs	r3, #234	; 0xea
 8014412:	005b      	lsls	r3, r3, #1
 8014414:	5cd3      	ldrb	r3, [r2, r3]
 8014416:	2b00      	cmp	r3, #0
 8014418:	d100      	bne.n	801441c <LoRaMacMibSetRequestConfirm+0x5ec>
 801441a:	e1e7      	b.n	80147ec <LoRaMacMibSetRequestConfirm+0x9bc>
                {
                    // We can only compute the RX window parameters directly, if we are already
                    // in class c mode and joined. We cannot setup an RX window in case of any other
                    // class type.
                    // Set the radio into sleep mode in case we are still in RX mode
                    Radio.Sleep( );
 801441c:	4b8a      	ldr	r3, [pc, #552]	; (8014648 <LoRaMacMibSetRequestConfirm+0x818>)
 801441e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014420:	4798      	blx	r3
                    // Compute RxC windows parameters
                    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 8014422:	4b87      	ldr	r3, [pc, #540]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014424:	4a87      	ldr	r2, [pc, #540]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014426:	589b      	ldr	r3, [r3, r2]
 8014428:	7818      	ldrb	r0, [r3, #0]
                                                     MacCtx.NvmCtx->MacParams.RxCChannel.Datarate,
 801442a:	4b85      	ldr	r3, [pc, #532]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 801442c:	4a85      	ldr	r2, [pc, #532]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 801442e:	589a      	ldr	r2, [r3, r2]
 8014430:	2394      	movs	r3, #148	; 0x94
 8014432:	005b      	lsls	r3, r3, #1
 8014434:	5cd3      	ldrb	r3, [r2, r3]
                    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 8014436:	b259      	sxtb	r1, r3
                                                     MacCtx.NvmCtx->MacParams.MinRxSymbols,
 8014438:	4b81      	ldr	r3, [pc, #516]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 801443a:	4a82      	ldr	r2, [pc, #520]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 801443c:	589a      	ldr	r2, [r3, r2]
                    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 801443e:	2380      	movs	r3, #128	; 0x80
 8014440:	005b      	lsls	r3, r3, #1
 8014442:	5cd2      	ldrb	r2, [r2, r3]
                                                     MacCtx.NvmCtx->MacParams.SystemMaxRxError,
 8014444:	4b7e      	ldr	r3, [pc, #504]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014446:	4c7f      	ldr	r4, [pc, #508]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014448:	591b      	ldr	r3, [r3, r4]
                    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,
 801444a:	24fc      	movs	r4, #252	; 0xfc
 801444c:	591c      	ldr	r4, [r3, r4]
 801444e:	4b7f      	ldr	r3, [pc, #508]	; (801464c <LoRaMacMibSetRequestConfirm+0x81c>)
 8014450:	9300      	str	r3, [sp, #0]
 8014452:	0023      	movs	r3, r4
 8014454:	f003 f912 	bl	801767c <RegionComputeRxWindowParameters>
                                                     &MacCtx.RxWindowCConfig );
                    OpenContinuousRxCWindow( );
 8014458:	f7fe f99e 	bl	8012798 <OpenContinuousRxCWindow>
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
            }
            break;
 801445c:	e1c6      	b.n	80147ec <LoRaMacMibSetRequestConfirm+0x9bc>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 801445e:	2317      	movs	r3, #23
 8014460:	18fb      	adds	r3, r7, r3
 8014462:	2203      	movs	r2, #3
 8014464:	701a      	strb	r2, [r3, #0]
            break;
 8014466:	e1c1      	b.n	80147ec <LoRaMacMibSetRequestConfirm+0x9bc>
        }
        case MIB_RXC_DEFAULT_CHANNEL:
        {
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 8014468:	687b      	ldr	r3, [r7, #4]
 801446a:	7a1b      	ldrb	r3, [r3, #8]
 801446c:	b25a      	sxtb	r2, r3
 801446e:	2108      	movs	r1, #8
 8014470:	187b      	adds	r3, r7, r1
 8014472:	701a      	strb	r2, [r3, #0]
            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;
 8014474:	4b72      	ldr	r3, [pc, #456]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014476:	4a73      	ldr	r2, [pc, #460]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014478:	589a      	ldr	r2, [r3, r2]
 801447a:	232e      	movs	r3, #46	; 0x2e
 801447c:	33ff      	adds	r3, #255	; 0xff
 801447e:	5cd2      	ldrb	r2, [r2, r3]
 8014480:	187b      	adds	r3, r7, r1
 8014482:	705a      	strb	r2, [r3, #1]

            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )
 8014484:	4b6e      	ldr	r3, [pc, #440]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014486:	4a6f      	ldr	r2, [pc, #444]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014488:	589b      	ldr	r3, [r3, r2]
 801448a:	781b      	ldrb	r3, [r3, #0]
 801448c:	1879      	adds	r1, r7, r1
 801448e:	2207      	movs	r2, #7
 8014490:	0018      	movs	r0, r3
 8014492:	f003 f8ab 	bl	80175ec <RegionVerify>
 8014496:	1e03      	subs	r3, r0, #0
 8014498:	d008      	beq.n	80144ac <LoRaMacMibSetRequestConfirm+0x67c>
            {
                MacCtx.NvmCtx->MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;
 801449a:	4b69      	ldr	r3, [pc, #420]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 801449c:	4a69      	ldr	r2, [pc, #420]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 801449e:	589b      	ldr	r3, [r3, r2]
 80144a0:	687a      	ldr	r2, [r7, #4]
 80144a2:	3330      	adds	r3, #48	; 0x30
 80144a4:	3204      	adds	r2, #4
 80144a6:	ca03      	ldmia	r2!, {r0, r1}
 80144a8:	c303      	stmia	r3!, {r0, r1}
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
            }
            break;
 80144aa:	e1a6      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 80144ac:	2317      	movs	r3, #23
 80144ae:	18fb      	adds	r3, r7, r3
 80144b0:	2203      	movs	r2, #3
 80144b2:	701a      	strb	r2, [r3, #0]
            break;
 80144b4:	e1a1      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_CHANNELS_DEFAULT_MASK:
        {
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;
 80144b6:	687b      	ldr	r3, [r7, #4]
 80144b8:	685a      	ldr	r2, [r3, #4]
 80144ba:	210c      	movs	r1, #12
 80144bc:	187b      	adds	r3, r7, r1
 80144be:	601a      	str	r2, [r3, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;
 80144c0:	187b      	adds	r3, r7, r1
 80144c2:	2201      	movs	r2, #1
 80144c4:	711a      	strb	r2, [r3, #4]

            if( RegionChanMaskSet( MacCtx.NvmCtx->Region, &chanMaskSet ) == false )
 80144c6:	4b5e      	ldr	r3, [pc, #376]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 80144c8:	4a5e      	ldr	r2, [pc, #376]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 80144ca:	589b      	ldr	r3, [r3, r2]
 80144cc:	781b      	ldrb	r3, [r3, #0]
 80144ce:	187a      	adds	r2, r7, r1
 80144d0:	0011      	movs	r1, r2
 80144d2:	0018      	movs	r0, r3
 80144d4:	f003 f8bc 	bl	8017650 <RegionChanMaskSet>
 80144d8:	0003      	movs	r3, r0
 80144da:	001a      	movs	r2, r3
 80144dc:	2301      	movs	r3, #1
 80144de:	4053      	eors	r3, r2
 80144e0:	b2db      	uxtb	r3, r3
 80144e2:	2b00      	cmp	r3, #0
 80144e4:	d100      	bne.n	80144e8 <LoRaMacMibSetRequestConfirm+0x6b8>
 80144e6:	e183      	b.n	80147f0 <LoRaMacMibSetRequestConfirm+0x9c0>
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 80144e8:	2317      	movs	r3, #23
 80144ea:	18fb      	adds	r3, r7, r3
 80144ec:	2203      	movs	r2, #3
 80144ee:	701a      	strb	r2, [r3, #0]
            }
            break;
 80144f0:	e17e      	b.n	80147f0 <LoRaMacMibSetRequestConfirm+0x9c0>
        }
        case MIB_CHANNELS_MASK:
        {
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;
 80144f2:	687b      	ldr	r3, [r7, #4]
 80144f4:	685a      	ldr	r2, [r3, #4]
 80144f6:	210c      	movs	r1, #12
 80144f8:	187b      	adds	r3, r7, r1
 80144fa:	601a      	str	r2, [r3, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 80144fc:	187b      	adds	r3, r7, r1
 80144fe:	2200      	movs	r2, #0
 8014500:	711a      	strb	r2, [r3, #4]

            if( RegionChanMaskSet( MacCtx.NvmCtx->Region, &chanMaskSet ) == false )
 8014502:	4b4f      	ldr	r3, [pc, #316]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014504:	4a4f      	ldr	r2, [pc, #316]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014506:	589b      	ldr	r3, [r3, r2]
 8014508:	781b      	ldrb	r3, [r3, #0]
 801450a:	187a      	adds	r2, r7, r1
 801450c:	0011      	movs	r1, r2
 801450e:	0018      	movs	r0, r3
 8014510:	f003 f89e 	bl	8017650 <RegionChanMaskSet>
 8014514:	0003      	movs	r3, r0
 8014516:	001a      	movs	r2, r3
 8014518:	2301      	movs	r3, #1
 801451a:	4053      	eors	r3, r2
 801451c:	b2db      	uxtb	r3, r3
 801451e:	2b00      	cmp	r3, #0
 8014520:	d100      	bne.n	8014524 <LoRaMacMibSetRequestConfirm+0x6f4>
 8014522:	e167      	b.n	80147f4 <LoRaMacMibSetRequestConfirm+0x9c4>
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014524:	2317      	movs	r3, #23
 8014526:	18fb      	adds	r3, r7, r3
 8014528:	2203      	movs	r2, #3
 801452a:	701a      	strb	r2, [r3, #0]
            }
            break;
 801452c:	e162      	b.n	80147f4 <LoRaMacMibSetRequestConfirm+0x9c4>
        }
        case MIB_CHANNELS_NB_TRANS:
        {
            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&
 801452e:	687b      	ldr	r3, [r7, #4]
 8014530:	791b      	ldrb	r3, [r3, #4]
 8014532:	2b00      	cmp	r3, #0
 8014534:	d00c      	beq.n	8014550 <LoRaMacMibSetRequestConfirm+0x720>
                ( mibSet->Param.ChannelsNbTrans <= 15 ) )
 8014536:	687b      	ldr	r3, [r7, #4]
 8014538:	791b      	ldrb	r3, [r3, #4]
            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&
 801453a:	2b0f      	cmp	r3, #15
 801453c:	d808      	bhi.n	8014550 <LoRaMacMibSetRequestConfirm+0x720>
            {
                MacCtx.NvmCtx->MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;
 801453e:	4b40      	ldr	r3, [pc, #256]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014540:	4a40      	ldr	r2, [pc, #256]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014542:	589a      	ldr	r2, [r3, r2]
 8014544:	687b      	ldr	r3, [r7, #4]
 8014546:	7919      	ldrb	r1, [r3, #4]
 8014548:	238c      	movs	r3, #140	; 0x8c
 801454a:	005b      	lsls	r3, r3, #1
 801454c:	54d1      	strb	r1, [r2, r3]
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
            }
            break;
 801454e:	e154      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014550:	2317      	movs	r3, #23
 8014552:	18fb      	adds	r3, r7, r3
 8014554:	2203      	movs	r2, #3
 8014556:	701a      	strb	r2, [r3, #0]
            break;
 8014558:	e14f      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_MAX_RX_WINDOW_DURATION:
        {
            MacCtx.NvmCtx->MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;
 801455a:	4b39      	ldr	r3, [pc, #228]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 801455c:	4a39      	ldr	r2, [pc, #228]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 801455e:	589a      	ldr	r2, [r3, r2]
 8014560:	687b      	ldr	r3, [r7, #4]
 8014562:	6859      	ldr	r1, [r3, #4]
 8014564:	2382      	movs	r3, #130	; 0x82
 8014566:	005b      	lsls	r3, r3, #1
 8014568:	50d1      	str	r1, [r2, r3]
            break;
 801456a:	e146      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_RECEIVE_DELAY_1:
        {
            MacCtx.NvmCtx->MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;
 801456c:	4b34      	ldr	r3, [pc, #208]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 801456e:	4a35      	ldr	r2, [pc, #212]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014570:	589a      	ldr	r2, [r3, r2]
 8014572:	687b      	ldr	r3, [r7, #4]
 8014574:	6859      	ldr	r1, [r3, #4]
 8014576:	2384      	movs	r3, #132	; 0x84
 8014578:	005b      	lsls	r3, r3, #1
 801457a:	50d1      	str	r1, [r2, r3]
            break;
 801457c:	e13d      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_RECEIVE_DELAY_2:
        {
            MacCtx.NvmCtx->MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;
 801457e:	4b30      	ldr	r3, [pc, #192]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014580:	4a30      	ldr	r2, [pc, #192]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014582:	589a      	ldr	r2, [r3, r2]
 8014584:	687b      	ldr	r3, [r7, #4]
 8014586:	6859      	ldr	r1, [r3, #4]
 8014588:	2386      	movs	r3, #134	; 0x86
 801458a:	005b      	lsls	r3, r3, #1
 801458c:	50d1      	str	r1, [r2, r3]
            break;
 801458e:	e134      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_JOIN_ACCEPT_DELAY_1:
        {
            MacCtx.NvmCtx->MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;
 8014590:	4b2b      	ldr	r3, [pc, #172]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014592:	4a2c      	ldr	r2, [pc, #176]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014594:	589a      	ldr	r2, [r3, r2]
 8014596:	687b      	ldr	r3, [r7, #4]
 8014598:	6859      	ldr	r1, [r3, #4]
 801459a:	2388      	movs	r3, #136	; 0x88
 801459c:	005b      	lsls	r3, r3, #1
 801459e:	50d1      	str	r1, [r2, r3]
            break;
 80145a0:	e12b      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_JOIN_ACCEPT_DELAY_2:
        {
            MacCtx.NvmCtx->MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;
 80145a2:	4b27      	ldr	r3, [pc, #156]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 80145a4:	4a27      	ldr	r2, [pc, #156]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 80145a6:	589a      	ldr	r2, [r3, r2]
 80145a8:	687b      	ldr	r3, [r7, #4]
 80145aa:	6859      	ldr	r1, [r3, #4]
 80145ac:	238a      	movs	r3, #138	; 0x8a
 80145ae:	005b      	lsls	r3, r3, #1
 80145b0:	50d1      	str	r1, [r2, r3]
            break;
 80145b2:	e122      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_CHANNELS_DEFAULT_DATARATE:
        {
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 80145b4:	687b      	ldr	r3, [r7, #4]
 80145b6:	2204      	movs	r2, #4
 80145b8:	569a      	ldrsb	r2, [r3, r2]
 80145ba:	2408      	movs	r4, #8
 80145bc:	193b      	adds	r3, r7, r4
 80145be:	701a      	strb	r2, [r3, #0]

            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_DEF_TX_DR ) == true )
 80145c0:	4b1f      	ldr	r3, [pc, #124]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 80145c2:	4a20      	ldr	r2, [pc, #128]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 80145c4:	589b      	ldr	r3, [r3, r2]
 80145c6:	781b      	ldrb	r3, [r3, #0]
 80145c8:	1939      	adds	r1, r7, r4
 80145ca:	2206      	movs	r2, #6
 80145cc:	0018      	movs	r0, r3
 80145ce:	f003 f80d 	bl	80175ec <RegionVerify>
 80145d2:	1e03      	subs	r3, r0, #0
 80145d4:	d007      	beq.n	80145e6 <LoRaMacMibSetRequestConfirm+0x7b6>
            {
                MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate = verify.DatarateParams.Datarate;
 80145d6:	4b1a      	ldr	r3, [pc, #104]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 80145d8:	4a1a      	ldr	r2, [pc, #104]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 80145da:	589b      	ldr	r3, [r3, r2]
 80145dc:	193a      	adds	r2, r7, r4
 80145de:	7812      	ldrb	r2, [r2, #0]
 80145e0:	b252      	sxtb	r2, r2
 80145e2:	715a      	strb	r2, [r3, #5]
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
            }
            break;
 80145e4:	e109      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 80145e6:	2317      	movs	r3, #23
 80145e8:	18fb      	adds	r3, r7, r3
 80145ea:	2203      	movs	r2, #3
 80145ec:	701a      	strb	r2, [r3, #0]
            break;
 80145ee:	e104      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_CHANNELS_DATARATE:
        {
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;
 80145f0:	687b      	ldr	r3, [r7, #4]
 80145f2:	2204      	movs	r2, #4
 80145f4:	569a      	ldrsb	r2, [r3, r2]
 80145f6:	2408      	movs	r4, #8
 80145f8:	193b      	adds	r3, r7, r4
 80145fa:	701a      	strb	r2, [r3, #0]
            verify.DatarateParams.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;
 80145fc:	4b10      	ldr	r3, [pc, #64]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 80145fe:	4a11      	ldr	r2, [pc, #68]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014600:	589a      	ldr	r2, [r3, r2]
 8014602:	2396      	movs	r3, #150	; 0x96
 8014604:	005b      	lsls	r3, r3, #1
 8014606:	5cd2      	ldrb	r2, [r2, r3]
 8014608:	193b      	adds	r3, r7, r4
 801460a:	709a      	strb	r2, [r3, #2]

            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_TX_DR ) == true )
 801460c:	4b0c      	ldr	r3, [pc, #48]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 801460e:	4a0d      	ldr	r2, [pc, #52]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014610:	589b      	ldr	r3, [r3, r2]
 8014612:	781b      	ldrb	r3, [r3, #0]
 8014614:	1939      	adds	r1, r7, r4
 8014616:	2205      	movs	r2, #5
 8014618:	0018      	movs	r0, r3
 801461a:	f002 ffe7 	bl	80175ec <RegionVerify>
 801461e:	1e03      	subs	r3, r0, #0
 8014620:	d008      	beq.n	8014634 <LoRaMacMibSetRequestConfirm+0x804>
            {
                MacCtx.NvmCtx->MacParams.ChannelsDatarate = verify.DatarateParams.Datarate;
 8014622:	4b07      	ldr	r3, [pc, #28]	; (8014640 <LoRaMacMibSetRequestConfirm+0x810>)
 8014624:	4a07      	ldr	r2, [pc, #28]	; (8014644 <LoRaMacMibSetRequestConfirm+0x814>)
 8014626:	589b      	ldr	r3, [r3, r2]
 8014628:	193a      	adds	r2, r7, r4
 801462a:	2100      	movs	r1, #0
 801462c:	5651      	ldrsb	r1, [r2, r1]
 801462e:	22f9      	movs	r2, #249	; 0xf9
 8014630:	5499      	strb	r1, [r3, r2]
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
            }
            break;
 8014632:	e0e2      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014634:	2317      	movs	r3, #23
 8014636:	18fb      	adds	r3, r7, r3
 8014638:	2203      	movs	r2, #3
 801463a:	701a      	strb	r2, [r3, #0]
            break;
 801463c:	e0dd      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
 801463e:	46c0      	nop			; (mov r8, r8)
 8014640:	200008ec 	.word	0x200008ec
 8014644:	00000484 	.word	0x00000484
 8014648:	0801ebd0 	.word	0x0801ebd0
 801464c:	20000ccc 	.word	0x20000ccc
        }
        case MIB_CHANNELS_DEFAULT_TX_POWER:
        {
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 8014650:	687b      	ldr	r3, [r7, #4]
 8014652:	2204      	movs	r2, #4
 8014654:	569a      	ldrsb	r2, [r3, r2]
 8014656:	2408      	movs	r4, #8
 8014658:	193b      	adds	r3, r7, r4
 801465a:	701a      	strb	r2, [r3, #0]

            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_DEF_TX_POWER ) == true )
 801465c:	4b6c      	ldr	r3, [pc, #432]	; (8014810 <LoRaMacMibSetRequestConfirm+0x9e0>)
 801465e:	4a6d      	ldr	r2, [pc, #436]	; (8014814 <LoRaMacMibSetRequestConfirm+0x9e4>)
 8014660:	589b      	ldr	r3, [r3, r2]
 8014662:	781b      	ldrb	r3, [r3, #0]
 8014664:	1939      	adds	r1, r7, r4
 8014666:	220a      	movs	r2, #10
 8014668:	0018      	movs	r0, r3
 801466a:	f002 ffbf 	bl	80175ec <RegionVerify>
 801466e:	1e03      	subs	r3, r0, #0
 8014670:	d007      	beq.n	8014682 <LoRaMacMibSetRequestConfirm+0x852>
            {
                MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower = verify.TxPower;
 8014672:	4b67      	ldr	r3, [pc, #412]	; (8014810 <LoRaMacMibSetRequestConfirm+0x9e0>)
 8014674:	4a67      	ldr	r2, [pc, #412]	; (8014814 <LoRaMacMibSetRequestConfirm+0x9e4>)
 8014676:	589b      	ldr	r3, [r3, r2]
 8014678:	193a      	adds	r2, r7, r4
 801467a:	7812      	ldrb	r2, [r2, #0]
 801467c:	b252      	sxtb	r2, r2
 801467e:	711a      	strb	r2, [r3, #4]
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
            }
            break;
 8014680:	e0bb      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014682:	2317      	movs	r3, #23
 8014684:	18fb      	adds	r3, r7, r3
 8014686:	2203      	movs	r2, #3
 8014688:	701a      	strb	r2, [r3, #0]
            break;
 801468a:	e0b6      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_CHANNELS_TX_POWER:
        {
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 801468c:	687b      	ldr	r3, [r7, #4]
 801468e:	2204      	movs	r2, #4
 8014690:	569a      	ldrsb	r2, [r3, r2]
 8014692:	2408      	movs	r4, #8
 8014694:	193b      	adds	r3, r7, r4
 8014696:	701a      	strb	r2, [r3, #0]

            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_TX_POWER ) == true )
 8014698:	4b5d      	ldr	r3, [pc, #372]	; (8014810 <LoRaMacMibSetRequestConfirm+0x9e0>)
 801469a:	4a5e      	ldr	r2, [pc, #376]	; (8014814 <LoRaMacMibSetRequestConfirm+0x9e4>)
 801469c:	589b      	ldr	r3, [r3, r2]
 801469e:	781b      	ldrb	r3, [r3, #0]
 80146a0:	1939      	adds	r1, r7, r4
 80146a2:	2209      	movs	r2, #9
 80146a4:	0018      	movs	r0, r3
 80146a6:	f002 ffa1 	bl	80175ec <RegionVerify>
 80146aa:	1e03      	subs	r3, r0, #0
 80146ac:	d008      	beq.n	80146c0 <LoRaMacMibSetRequestConfirm+0x890>
            {
                MacCtx.NvmCtx->MacParams.ChannelsTxPower = verify.TxPower;
 80146ae:	4b58      	ldr	r3, [pc, #352]	; (8014810 <LoRaMacMibSetRequestConfirm+0x9e0>)
 80146b0:	4a58      	ldr	r2, [pc, #352]	; (8014814 <LoRaMacMibSetRequestConfirm+0x9e4>)
 80146b2:	589b      	ldr	r3, [r3, r2]
 80146b4:	193a      	adds	r2, r7, r4
 80146b6:	2100      	movs	r1, #0
 80146b8:	5651      	ldrsb	r1, [r2, r1]
 80146ba:	22f8      	movs	r2, #248	; 0xf8
 80146bc:	5499      	strb	r1, [r3, r2]
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
            }
            break;
 80146be:	e09c      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 80146c0:	2317      	movs	r3, #23
 80146c2:	18fb      	adds	r3, r7, r3
 80146c4:	2203      	movs	r2, #3
 80146c6:	701a      	strb	r2, [r3, #0]
            break;
 80146c8:	e097      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_SYSTEM_MAX_RX_ERROR:
        {
            MacCtx.NvmCtx->MacParams.SystemMaxRxError = MacCtx.NvmCtx->MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;
 80146ca:	4b51      	ldr	r3, [pc, #324]	; (8014810 <LoRaMacMibSetRequestConfirm+0x9e0>)
 80146cc:	4a51      	ldr	r2, [pc, #324]	; (8014814 <LoRaMacMibSetRequestConfirm+0x9e4>)
 80146ce:	589b      	ldr	r3, [r3, r2]
 80146d0:	687a      	ldr	r2, [r7, #4]
 80146d2:	6852      	ldr	r2, [r2, #4]
 80146d4:	609a      	str	r2, [r3, #8]
 80146d6:	4a4e      	ldr	r2, [pc, #312]	; (8014810 <LoRaMacMibSetRequestConfirm+0x9e0>)
 80146d8:	494e      	ldr	r1, [pc, #312]	; (8014814 <LoRaMacMibSetRequestConfirm+0x9e4>)
 80146da:	5852      	ldr	r2, [r2, r1]
 80146dc:	689b      	ldr	r3, [r3, #8]
 80146de:	21fc      	movs	r1, #252	; 0xfc
 80146e0:	5053      	str	r3, [r2, r1]
            break;
 80146e2:	e08a      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_MIN_RX_SYMBOLS:
        {
            MacCtx.NvmCtx->MacParams.MinRxSymbols = MacCtx.NvmCtx->MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;
 80146e4:	4b4a      	ldr	r3, [pc, #296]	; (8014810 <LoRaMacMibSetRequestConfirm+0x9e0>)
 80146e6:	4a4b      	ldr	r2, [pc, #300]	; (8014814 <LoRaMacMibSetRequestConfirm+0x9e4>)
 80146e8:	589b      	ldr	r3, [r3, r2]
 80146ea:	687a      	ldr	r2, [r7, #4]
 80146ec:	7912      	ldrb	r2, [r2, #4]
 80146ee:	731a      	strb	r2, [r3, #12]
 80146f0:	4a47      	ldr	r2, [pc, #284]	; (8014810 <LoRaMacMibSetRequestConfirm+0x9e0>)
 80146f2:	4948      	ldr	r1, [pc, #288]	; (8014814 <LoRaMacMibSetRequestConfirm+0x9e4>)
 80146f4:	5852      	ldr	r2, [r2, r1]
 80146f6:	7b19      	ldrb	r1, [r3, #12]
 80146f8:	2380      	movs	r3, #128	; 0x80
 80146fa:	005b      	lsls	r3, r3, #1
 80146fc:	54d1      	strb	r1, [r2, r3]
            break;
 80146fe:	e07c      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_ANTENNA_GAIN:
        {
            MacCtx.NvmCtx->MacParams.AntennaGain = mibSet->Param.AntennaGain;
 8014700:	4b43      	ldr	r3, [pc, #268]	; (8014810 <LoRaMacMibSetRequestConfirm+0x9e0>)
 8014702:	4a44      	ldr	r2, [pc, #272]	; (8014814 <LoRaMacMibSetRequestConfirm+0x9e4>)
 8014704:	589a      	ldr	r2, [r3, r2]
 8014706:	687b      	ldr	r3, [r7, #4]
 8014708:	6859      	ldr	r1, [r3, #4]
 801470a:	239a      	movs	r3, #154	; 0x9a
 801470c:	005b      	lsls	r3, r3, #1
 801470e:	50d1      	str	r1, [r2, r3]
            break;
 8014710:	e073      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_DEFAULT_ANTENNA_GAIN:
        {
            MacCtx.NvmCtx->MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;
 8014712:	4b3f      	ldr	r3, [pc, #252]	; (8014810 <LoRaMacMibSetRequestConfirm+0x9e0>)
 8014714:	4a3f      	ldr	r2, [pc, #252]	; (8014814 <LoRaMacMibSetRequestConfirm+0x9e4>)
 8014716:	589b      	ldr	r3, [r3, r2]
 8014718:	687a      	ldr	r2, [r7, #4]
 801471a:	6852      	ldr	r2, [r2, #4]
 801471c:	641a      	str	r2, [r3, #64]	; 0x40
            break;
 801471e:	e06c      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_NVM_CTXS:
        {
            if( mibSet->Param.Contexts != 0 )
 8014720:	687b      	ldr	r3, [r7, #4]
 8014722:	685b      	ldr	r3, [r3, #4]
 8014724:	2b00      	cmp	r3, #0
 8014726:	d009      	beq.n	801473c <LoRaMacMibSetRequestConfirm+0x90c>
            {
                status = RestoreCtxs( mibSet->Param.Contexts );
 8014728:	687b      	ldr	r3, [r7, #4]
 801472a:	685b      	ldr	r3, [r3, #4]
 801472c:	2217      	movs	r2, #23
 801472e:	18bc      	adds	r4, r7, r2
 8014730:	0018      	movs	r0, r3
 8014732:	f7fe fb55 	bl	8012de0 <RestoreCtxs>
 8014736:	0003      	movs	r3, r0
 8014738:	7023      	strb	r3, [r4, #0]
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
            }
            break;
 801473a:	e05e      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 801473c:	2317      	movs	r3, #23
 801473e:	18fb      	adds	r3, r7, r3
 8014740:	2203      	movs	r2, #3
 8014742:	701a      	strb	r2, [r3, #0]
            break;
 8014744:	e059      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
        }
        case MIB_ABP_LORAWAN_VERSION:
        {
            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )
 8014746:	687b      	ldr	r3, [r7, #4]
 8014748:	799b      	ldrb	r3, [r3, #6]
 801474a:	2b01      	cmp	r3, #1
 801474c:	d810      	bhi.n	8014770 <LoRaMacMibSetRequestConfirm+0x940>
            {
                MacCtx.NvmCtx->Version = mibSet->Param.AbpLrWanVersion;
 801474e:	4b30      	ldr	r3, [pc, #192]	; (8014810 <LoRaMacMibSetRequestConfirm+0x9e0>)
 8014750:	4a30      	ldr	r2, [pc, #192]	; (8014814 <LoRaMacMibSetRequestConfirm+0x9e4>)
 8014752:	5899      	ldr	r1, [r3, r2]
 8014754:	23e8      	movs	r3, #232	; 0xe8
 8014756:	005a      	lsls	r2, r3, #1
 8014758:	687b      	ldr	r3, [r7, #4]
 801475a:	685b      	ldr	r3, [r3, #4]
 801475c:	508b      	str	r3, [r1, r2]

                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 801475e:	687b      	ldr	r3, [r7, #4]
 8014760:	685b      	ldr	r3, [r3, #4]
 8014762:	0018      	movs	r0, r3
 8014764:	f001 fdd6 	bl	8016314 <LoRaMacCryptoSetLrWanVersion>
 8014768:	1e03      	subs	r3, r0, #0
 801476a:	d045      	beq.n	80147f8 <LoRaMacMibSetRequestConfirm+0x9c8>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 801476c:	2311      	movs	r3, #17
 801476e:	e04b      	b.n	8014808 <LoRaMacMibSetRequestConfirm+0x9d8>
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8014770:	2317      	movs	r3, #23
 8014772:	18fb      	adds	r3, r7, r3
 8014774:	2203      	movs	r2, #3
 8014776:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014778:	e03e      	b.n	80147f8 <LoRaMacMibSetRequestConfirm+0x9c8>
        }
        default:
        {
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
 801477a:	2317      	movs	r3, #23
 801477c:	18fc      	adds	r4, r7, r3
 801477e:	687b      	ldr	r3, [r7, #4]
 8014780:	0018      	movs	r0, r3
 8014782:	f000 fc9b 	bl	80150bc <LoRaMacMibClassBSetRequestConfirm>
 8014786:	0003      	movs	r3, r0
 8014788:	7023      	strb	r3, [r4, #0]
            break;
 801478a:	e036      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 801478c:	46c0      	nop			; (mov r8, r8)
 801478e:	e034      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 8014790:	46c0      	nop			; (mov r8, r8)
 8014792:	e032      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 8014794:	46c0      	nop			; (mov r8, r8)
 8014796:	e030      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 8014798:	46c0      	nop			; (mov r8, r8)
 801479a:	e02e      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 801479c:	46c0      	nop			; (mov r8, r8)
 801479e:	e02c      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147a0:	46c0      	nop			; (mov r8, r8)
 80147a2:	e02a      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147a4:	46c0      	nop			; (mov r8, r8)
 80147a6:	e028      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147a8:	46c0      	nop			; (mov r8, r8)
 80147aa:	e026      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147ac:	46c0      	nop			; (mov r8, r8)
 80147ae:	e024      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147b0:	46c0      	nop			; (mov r8, r8)
 80147b2:	e022      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147b4:	46c0      	nop			; (mov r8, r8)
 80147b6:	e020      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147b8:	46c0      	nop			; (mov r8, r8)
 80147ba:	e01e      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147bc:	46c0      	nop			; (mov r8, r8)
 80147be:	e01c      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147c0:	46c0      	nop			; (mov r8, r8)
 80147c2:	e01a      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147c4:	46c0      	nop			; (mov r8, r8)
 80147c6:	e018      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147c8:	46c0      	nop			; (mov r8, r8)
 80147ca:	e016      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147cc:	46c0      	nop			; (mov r8, r8)
 80147ce:	e014      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147d0:	46c0      	nop			; (mov r8, r8)
 80147d2:	e012      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147d4:	46c0      	nop			; (mov r8, r8)
 80147d6:	e010      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147d8:	46c0      	nop			; (mov r8, r8)
 80147da:	e00e      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147dc:	46c0      	nop			; (mov r8, r8)
 80147de:	e00c      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147e0:	46c0      	nop			; (mov r8, r8)
 80147e2:	e00a      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147e4:	46c0      	nop			; (mov r8, r8)
 80147e6:	e008      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147e8:	46c0      	nop			; (mov r8, r8)
 80147ea:	e006      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147ec:	46c0      	nop			; (mov r8, r8)
 80147ee:	e004      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147f0:	46c0      	nop			; (mov r8, r8)
 80147f2:	e002      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147f4:	46c0      	nop			; (mov r8, r8)
 80147f6:	e000      	b.n	80147fa <LoRaMacMibSetRequestConfirm+0x9ca>
            break;
 80147f8:	46c0      	nop			; (mov r8, r8)
        }
    }
    EventRegionNvmCtxChanged( );
 80147fa:	f7fe fd0d 	bl	8013218 <EventRegionNvmCtxChanged>
    EventMacNvmCtxChanged( );
 80147fe:	f7fe fd03 	bl	8013208 <EventMacNvmCtxChanged>
    return status;
 8014802:	2317      	movs	r3, #23
 8014804:	18fb      	adds	r3, r7, r3
 8014806:	781b      	ldrb	r3, [r3, #0]
}
 8014808:	0018      	movs	r0, r3
 801480a:	46bd      	mov	sp, r7
 801480c:	b007      	add	sp, #28
 801480e:	bd90      	pop	{r4, r7, pc}
 8014810:	200008ec 	.word	0x200008ec
 8014814:	00000484 	.word	0x00000484

08014818 <LoRaMacMlmeRequest>:
    EventRegionNvmCtxChanged( );
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )
{
 8014818:	b5b0      	push	{r4, r5, r7, lr}
 801481a:	b086      	sub	sp, #24
 801481c:	af00      	add	r7, sp, #0
 801481e:	6078      	str	r0, [r7, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 8014820:	2317      	movs	r3, #23
 8014822:	18fb      	adds	r3, r7, r3
 8014824:	2202      	movs	r2, #2
 8014826:	701a      	strb	r2, [r3, #0]
    MlmeConfirmQueue_t queueElement;
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 8014828:	230c      	movs	r3, #12
 801482a:	18fb      	adds	r3, r7, r3
 801482c:	2200      	movs	r2, #0
 801482e:	801a      	strh	r2, [r3, #0]

    if( mlmeRequest == NULL )
 8014830:	687b      	ldr	r3, [r7, #4]
 8014832:	2b00      	cmp	r3, #0
 8014834:	d101      	bne.n	801483a <LoRaMacMlmeRequest+0x22>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8014836:	2303      	movs	r3, #3
 8014838:	e12d      	b.n	8014a96 <LoRaMacMlmeRequest+0x27e>
    }
    if( LoRaMacIsBusy( ) == true )
 801483a:	f7fb ff55 	bl	80106e8 <LoRaMacIsBusy>
 801483e:	1e03      	subs	r3, r0, #0
 8014840:	d001      	beq.n	8014846 <LoRaMacMlmeRequest+0x2e>
    {
        return LORAMAC_STATUS_BUSY;
 8014842:	2301      	movs	r3, #1
 8014844:	e127      	b.n	8014a96 <LoRaMacMlmeRequest+0x27e>
    }
    if( LoRaMacConfirmQueueIsFull( ) == true )
 8014846:	f001 f93b 	bl	8015ac0 <LoRaMacConfirmQueueIsFull>
 801484a:	1e03      	subs	r3, r0, #0
 801484c:	d001      	beq.n	8014852 <LoRaMacMlmeRequest+0x3a>
    {
        return LORAMAC_STATUS_BUSY;
 801484e:	2301      	movs	r3, #1
 8014850:	e121      	b.n	8014a96 <LoRaMacMlmeRequest+0x27e>
    }

    if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 8014852:	f001 f92b 	bl	8015aac <LoRaMacConfirmQueueGetCnt>
 8014856:	1e03      	subs	r3, r0, #0
 8014858:	d105      	bne.n	8014866 <LoRaMacMlmeRequest+0x4e>
    {
        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );
 801485a:	4b91      	ldr	r3, [pc, #580]	; (8014aa0 <LoRaMacMlmeRequest+0x288>)
 801485c:	2214      	movs	r2, #20
 801485e:	2100      	movs	r1, #0
 8014860:	0018      	movs	r0, r3
 8014862:	f006 feaf 	bl	801b5c4 <memset1>
    }
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8014866:	4b8f      	ldr	r3, [pc, #572]	; (8014aa4 <LoRaMacMlmeRequest+0x28c>)
 8014868:	4a8f      	ldr	r2, [pc, #572]	; (8014aa8 <LoRaMacMlmeRequest+0x290>)
 801486a:	2101      	movs	r1, #1
 801486c:	5499      	strb	r1, [r3, r2]

    MacCtx.MacFlags.Bits.MlmeReq = 1;
 801486e:	4b8d      	ldr	r3, [pc, #564]	; (8014aa4 <LoRaMacMlmeRequest+0x28c>)
 8014870:	4a8e      	ldr	r2, [pc, #568]	; (8014aac <LoRaMacMlmeRequest+0x294>)
 8014872:	5c99      	ldrb	r1, [r3, r2]
 8014874:	2004      	movs	r0, #4
 8014876:	4301      	orrs	r1, r0
 8014878:	5499      	strb	r1, [r3, r2]
    queueElement.Request = mlmeRequest->Type;
 801487a:	687b      	ldr	r3, [r7, #4]
 801487c:	781a      	ldrb	r2, [r3, #0]
 801487e:	2110      	movs	r1, #16
 8014880:	187b      	adds	r3, r7, r1
 8014882:	701a      	strb	r2, [r3, #0]
    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8014884:	187b      	adds	r3, r7, r1
 8014886:	2201      	movs	r2, #1
 8014888:	705a      	strb	r2, [r3, #1]
    queueElement.RestrictCommonReadyToHandle = false;
 801488a:	187b      	adds	r3, r7, r1
 801488c:	2200      	movs	r2, #0
 801488e:	70da      	strb	r2, [r3, #3]

    switch( mlmeRequest->Type )
 8014890:	687b      	ldr	r3, [r7, #4]
 8014892:	781b      	ldrb	r3, [r3, #0]
 8014894:	2b0d      	cmp	r3, #13
 8014896:	d900      	bls.n	801489a <LoRaMacMlmeRequest+0x82>
 8014898:	e0d4      	b.n	8014a44 <LoRaMacMlmeRequest+0x22c>
 801489a:	009a      	lsls	r2, r3, #2
 801489c:	4b84      	ldr	r3, [pc, #528]	; (8014ab0 <LoRaMacMlmeRequest+0x298>)
 801489e:	18d3      	adds	r3, r2, r3
 80148a0:	681b      	ldr	r3, [r3, #0]
 80148a2:	469f      	mov	pc, r3
    {
        case MLME_JOIN:
        {
            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )
 80148a4:	4a7f      	ldr	r2, [pc, #508]	; (8014aa4 <LoRaMacMlmeRequest+0x28c>)
 80148a6:	23d0      	movs	r3, #208	; 0xd0
 80148a8:	009b      	lsls	r3, r3, #2
 80148aa:	58d3      	ldr	r3, [r2, r3]
 80148ac:	2220      	movs	r2, #32
 80148ae:	4013      	ands	r3, r2
 80148b0:	d001      	beq.n	80148b6 <LoRaMacMlmeRequest+0x9e>
            {
                return LORAMAC_STATUS_BUSY;
 80148b2:	2301      	movs	r3, #1
 80148b4:	e0ef      	b.n	8014a96 <LoRaMacMlmeRequest+0x27e>
            }

            ResetMacParameters( );
 80148b6:	f7fd fe3f 	bl	8012538 <ResetMacParameters>

            MacCtx.NvmCtx->MacParams.ChannelsDatarate = RegionAlternateDr( MacCtx.NvmCtx->Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 80148ba:	4b7a      	ldr	r3, [pc, #488]	; (8014aa4 <LoRaMacMlmeRequest+0x28c>)
 80148bc:	4a7d      	ldr	r2, [pc, #500]	; (8014ab4 <LoRaMacMlmeRequest+0x29c>)
 80148be:	589b      	ldr	r3, [r3, r2]
 80148c0:	7818      	ldrb	r0, [r3, #0]
 80148c2:	687b      	ldr	r3, [r7, #4]
 80148c4:	791b      	ldrb	r3, [r3, #4]
 80148c6:	b259      	sxtb	r1, r3
 80148c8:	4b76      	ldr	r3, [pc, #472]	; (8014aa4 <LoRaMacMlmeRequest+0x28c>)
 80148ca:	4a7a      	ldr	r2, [pc, #488]	; (8014ab4 <LoRaMacMlmeRequest+0x29c>)
 80148cc:	589c      	ldr	r4, [r3, r2]
 80148ce:	2200      	movs	r2, #0
 80148d0:	f002 ffa3 	bl	801781a <RegionAlternateDr>
 80148d4:	0003      	movs	r3, r0
 80148d6:	001a      	movs	r2, r3
 80148d8:	23f9      	movs	r3, #249	; 0xf9
 80148da:	54e2      	strb	r2, [r4, r3]

            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 80148dc:	2310      	movs	r3, #16
 80148de:	18fb      	adds	r3, r7, r3
 80148e0:	2207      	movs	r2, #7
 80148e2:	705a      	strb	r2, [r3, #1]

            status = SendReJoinReq( JOIN_REQ );
 80148e4:	2517      	movs	r5, #23
 80148e6:	197c      	adds	r4, r7, r5
 80148e8:	20ff      	movs	r0, #255	; 0xff
 80148ea:	f7fd fb51 	bl	8011f90 <SendReJoinReq>
 80148ee:	0003      	movs	r3, r0
 80148f0:	7023      	strb	r3, [r4, #0]

            if( status != LORAMAC_STATUS_OK )
 80148f2:	197b      	adds	r3, r7, r5
 80148f4:	781b      	ldrb	r3, [r3, #0]
 80148f6:	2b00      	cmp	r3, #0
 80148f8:	d100      	bne.n	80148fc <LoRaMacMlmeRequest+0xe4>
 80148fa:	e0a5      	b.n	8014a48 <LoRaMacMlmeRequest+0x230>
            {
                // Revert back the previous datarate ( mainly used for US915 like regions )
                MacCtx.NvmCtx->MacParams.ChannelsDatarate = RegionAlternateDr( MacCtx.NvmCtx->Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );
 80148fc:	4b69      	ldr	r3, [pc, #420]	; (8014aa4 <LoRaMacMlmeRequest+0x28c>)
 80148fe:	4a6d      	ldr	r2, [pc, #436]	; (8014ab4 <LoRaMacMlmeRequest+0x29c>)
 8014900:	589b      	ldr	r3, [r3, r2]
 8014902:	7818      	ldrb	r0, [r3, #0]
 8014904:	687b      	ldr	r3, [r7, #4]
 8014906:	791b      	ldrb	r3, [r3, #4]
 8014908:	b259      	sxtb	r1, r3
 801490a:	4b66      	ldr	r3, [pc, #408]	; (8014aa4 <LoRaMacMlmeRequest+0x28c>)
 801490c:	4a69      	ldr	r2, [pc, #420]	; (8014ab4 <LoRaMacMlmeRequest+0x29c>)
 801490e:	589c      	ldr	r4, [r3, r2]
 8014910:	2201      	movs	r2, #1
 8014912:	f002 ff82 	bl	801781a <RegionAlternateDr>
 8014916:	0003      	movs	r3, r0
 8014918:	001a      	movs	r2, r3
 801491a:	23f9      	movs	r3, #249	; 0xf9
 801491c:	54e2      	strb	r2, [r4, r3]
            }
            break;
 801491e:	e093      	b.n	8014a48 <LoRaMacMlmeRequest+0x230>
        }
        case MLME_LINK_CHECK:
        {
            // LoRaMac will send this command piggy-pack
            status = LORAMAC_STATUS_OK;
 8014920:	2417      	movs	r4, #23
 8014922:	193b      	adds	r3, r7, r4
 8014924:	2200      	movs	r2, #0
 8014926:	701a      	strb	r2, [r3, #0]
            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 8014928:	230c      	movs	r3, #12
 801492a:	18fb      	adds	r3, r7, r3
 801492c:	2200      	movs	r2, #0
 801492e:	0019      	movs	r1, r3
 8014930:	2002      	movs	r0, #2
 8014932:	f000 fd79 	bl	8015428 <LoRaMacCommandsAddCmd>
 8014936:	1e03      	subs	r3, r0, #0
 8014938:	d100      	bne.n	801493c <LoRaMacMlmeRequest+0x124>
 801493a:	e087      	b.n	8014a4c <LoRaMacMlmeRequest+0x234>
            {
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 801493c:	193b      	adds	r3, r7, r4
 801493e:	2213      	movs	r2, #19
 8014940:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014942:	e083      	b.n	8014a4c <LoRaMacMlmeRequest+0x234>
        }
        case MLME_TXCW:
        {
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 8014944:	687b      	ldr	r3, [r7, #4]
 8014946:	889b      	ldrh	r3, [r3, #4]
 8014948:	2217      	movs	r2, #23
 801494a:	18bc      	adds	r4, r7, r2
 801494c:	0018      	movs	r0, r3
 801494e:	f7fe f97b 	bl	8012c48 <SetTxContinuousWave>
 8014952:	0003      	movs	r3, r0
 8014954:	7023      	strb	r3, [r4, #0]
            break;
 8014956:	e080      	b.n	8014a5a <LoRaMacMlmeRequest+0x242>
        }
        case MLME_TXCW_1:
        {

            status = SetTxContinuousWave1( mlmeRequest->Req.TxCw.Timeout, mlmeRequest->Req.TxCw.Frequency, mlmeRequest->Req.TxCw.Power );
 8014958:	687b      	ldr	r3, [r7, #4]
 801495a:	8898      	ldrh	r0, [r3, #4]
 801495c:	687b      	ldr	r3, [r7, #4]
 801495e:	6899      	ldr	r1, [r3, #8]
 8014960:	687b      	ldr	r3, [r7, #4]
 8014962:	7b1b      	ldrb	r3, [r3, #12]
 8014964:	2217      	movs	r2, #23
 8014966:	18bc      	adds	r4, r7, r2
 8014968:	001a      	movs	r2, r3
 801496a:	f7fe f9bb 	bl	8012ce4 <SetTxContinuousWave1>
 801496e:	0003      	movs	r3, r0
 8014970:	7023      	strb	r3, [r4, #0]
            break;
 8014972:	e072      	b.n	8014a5a <LoRaMacMlmeRequest+0x242>
        }
        case MLME_DEVICE_TIME:
        {
            // LoRaMac will send this command piggy-pack
            status = LORAMAC_STATUS_OK;
 8014974:	2417      	movs	r4, #23
 8014976:	193b      	adds	r3, r7, r4
 8014978:	2200      	movs	r2, #0
 801497a:	701a      	strb	r2, [r3, #0]
            if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 801497c:	230c      	movs	r3, #12
 801497e:	18fb      	adds	r3, r7, r3
 8014980:	2200      	movs	r2, #0
 8014982:	0019      	movs	r1, r3
 8014984:	200d      	movs	r0, #13
 8014986:	f000 fd4f 	bl	8015428 <LoRaMacCommandsAddCmd>
 801498a:	1e03      	subs	r3, r0, #0
 801498c:	d060      	beq.n	8014a50 <LoRaMacMlmeRequest+0x238>
            {
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 801498e:	193b      	adds	r3, r7, r4
 8014990:	2213      	movs	r2, #19
 8014992:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014994:	e05c      	b.n	8014a50 <LoRaMacMlmeRequest+0x238>
        }
        case MLME_PING_SLOT_INFO:
        {
            if( MacCtx.NvmCtx->DeviceClass == CLASS_A )
 8014996:	4b43      	ldr	r3, [pc, #268]	; (8014aa4 <LoRaMacMlmeRequest+0x28c>)
 8014998:	4a46      	ldr	r2, [pc, #280]	; (8014ab4 <LoRaMacMlmeRequest+0x29c>)
 801499a:	589b      	ldr	r3, [r3, r2]
 801499c:	22f0      	movs	r2, #240	; 0xf0
 801499e:	5c9b      	ldrb	r3, [r3, r2]
 80149a0:	2b00      	cmp	r3, #0
 80149a2:	d157      	bne.n	8014a54 <LoRaMacMlmeRequest+0x23c>
            {
                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;
 80149a4:	2416      	movs	r4, #22
 80149a6:	193b      	adds	r3, r7, r4
 80149a8:	687a      	ldr	r2, [r7, #4]
 80149aa:	7912      	ldrb	r2, [r2, #4]
 80149ac:	701a      	strb	r2, [r3, #0]

                // LoRaMac will send this command piggy-pack
                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );
 80149ae:	687b      	ldr	r3, [r7, #4]
 80149b0:	791b      	ldrb	r3, [r3, #4]
 80149b2:	075b      	lsls	r3, r3, #29
 80149b4:	0f5b      	lsrs	r3, r3, #29
 80149b6:	b2db      	uxtb	r3, r3
 80149b8:	0018      	movs	r0, r3
 80149ba:	f000 fb57 	bl	801506c <LoRaMacClassBSetPingSlotInfo>
                macCmdPayload[0] = value;
 80149be:	210c      	movs	r1, #12
 80149c0:	187b      	adds	r3, r7, r1
 80149c2:	193a      	adds	r2, r7, r4
 80149c4:	7812      	ldrb	r2, [r2, #0]
 80149c6:	701a      	strb	r2, [r3, #0]
                status = LORAMAC_STATUS_OK;
 80149c8:	2417      	movs	r4, #23
 80149ca:	193b      	adds	r3, r7, r4
 80149cc:	2200      	movs	r2, #0
 80149ce:	701a      	strb	r2, [r3, #0]
                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )
 80149d0:	187b      	adds	r3, r7, r1
 80149d2:	2201      	movs	r2, #1
 80149d4:	0019      	movs	r1, r3
 80149d6:	2010      	movs	r0, #16
 80149d8:	f000 fd26 	bl	8015428 <LoRaMacCommandsAddCmd>
 80149dc:	1e03      	subs	r3, r0, #0
 80149de:	d039      	beq.n	8014a54 <LoRaMacMlmeRequest+0x23c>
                {
                    status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80149e0:	193b      	adds	r3, r7, r4
 80149e2:	2213      	movs	r2, #19
 80149e4:	701a      	strb	r2, [r3, #0]
                }
            }
            break;
 80149e6:	e035      	b.n	8014a54 <LoRaMacMlmeRequest+0x23c>
        }
        case MLME_BEACON_TIMING:
        {
            // LoRaMac will send this command piggy-pack
            status = LORAMAC_STATUS_OK;
 80149e8:	2417      	movs	r4, #23
 80149ea:	193b      	adds	r3, r7, r4
 80149ec:	2200      	movs	r2, #0
 80149ee:	701a      	strb	r2, [r3, #0]
            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 80149f0:	230c      	movs	r3, #12
 80149f2:	18fb      	adds	r3, r7, r3
 80149f4:	2200      	movs	r2, #0
 80149f6:	0019      	movs	r1, r3
 80149f8:	2012      	movs	r0, #18
 80149fa:	f000 fd15 	bl	8015428 <LoRaMacCommandsAddCmd>
 80149fe:	1e03      	subs	r3, r0, #0
 8014a00:	d02a      	beq.n	8014a58 <LoRaMacMlmeRequest+0x240>
            {
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8014a02:	193b      	adds	r3, r7, r4
 8014a04:	2213      	movs	r2, #19
 8014a06:	701a      	strb	r2, [r3, #0]
            }
            break;
 8014a08:	e026      	b.n	8014a58 <LoRaMacMlmeRequest+0x240>
        }
        case MLME_BEACON_ACQUISITION:
        {
            // Apply the request
            queueElement.RestrictCommonReadyToHandle = true;
 8014a0a:	2310      	movs	r3, #16
 8014a0c:	18fb      	adds	r3, r7, r3
 8014a0e:	2201      	movs	r2, #1
 8014a10:	70da      	strb	r2, [r3, #3]

            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )
 8014a12:	f000 fae9 	bl	8014fe8 <LoRaMacClassBIsAcquisitionInProgress>
 8014a16:	0003      	movs	r3, r0
 8014a18:	001a      	movs	r2, r3
 8014a1a:	2301      	movs	r3, #1
 8014a1c:	4053      	eors	r3, r2
 8014a1e:	b2db      	uxtb	r3, r3
 8014a20:	2b00      	cmp	r3, #0
 8014a22:	d00a      	beq.n	8014a3a <LoRaMacMlmeRequest+0x222>
            {
                // Start class B algorithm
                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );
 8014a24:	2000      	movs	r0, #0
 8014a26:	f000 fac1 	bl	8014fac <LoRaMacClassBSetBeaconState>
                LoRaMacClassBBeaconTimerEvent( NULL );
 8014a2a:	2000      	movs	r0, #0
 8014a2c:	f000 fae2 	bl	8014ff4 <LoRaMacClassBBeaconTimerEvent>

                status = LORAMAC_STATUS_OK;
 8014a30:	2317      	movs	r3, #23
 8014a32:	18fb      	adds	r3, r7, r3
 8014a34:	2200      	movs	r2, #0
 8014a36:	701a      	strb	r2, [r3, #0]
            }
            else
            {
                status = LORAMAC_STATUS_BUSY;
            }
            break;
 8014a38:	e00f      	b.n	8014a5a <LoRaMacMlmeRequest+0x242>
                status = LORAMAC_STATUS_BUSY;
 8014a3a:	2317      	movs	r3, #23
 8014a3c:	18fb      	adds	r3, r7, r3
 8014a3e:	2201      	movs	r2, #1
 8014a40:	701a      	strb	r2, [r3, #0]
            break;
 8014a42:	e00a      	b.n	8014a5a <LoRaMacMlmeRequest+0x242>
        }
        default:
            break;
 8014a44:	46c0      	nop			; (mov r8, r8)
 8014a46:	e008      	b.n	8014a5a <LoRaMacMlmeRequest+0x242>
            break;
 8014a48:	46c0      	nop			; (mov r8, r8)
 8014a4a:	e006      	b.n	8014a5a <LoRaMacMlmeRequest+0x242>
            break;
 8014a4c:	46c0      	nop			; (mov r8, r8)
 8014a4e:	e004      	b.n	8014a5a <LoRaMacMlmeRequest+0x242>
            break;
 8014a50:	46c0      	nop			; (mov r8, r8)
 8014a52:	e002      	b.n	8014a5a <LoRaMacMlmeRequest+0x242>
            break;
 8014a54:	46c0      	nop			; (mov r8, r8)
 8014a56:	e000      	b.n	8014a5a <LoRaMacMlmeRequest+0x242>
            break;
 8014a58:	46c0      	nop			; (mov r8, r8)
    }

    if( status != LORAMAC_STATUS_OK )
 8014a5a:	2317      	movs	r3, #23
 8014a5c:	18fb      	adds	r3, r7, r3
 8014a5e:	781b      	ldrb	r3, [r3, #0]
 8014a60:	2b00      	cmp	r3, #0
 8014a62:	d00e      	beq.n	8014a82 <LoRaMacMlmeRequest+0x26a>
    {
        if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 8014a64:	f001 f822 	bl	8015aac <LoRaMacConfirmQueueGetCnt>
 8014a68:	1e03      	subs	r3, r0, #0
 8014a6a:	d111      	bne.n	8014a90 <LoRaMacMlmeRequest+0x278>
        {
            MacCtx.NodeAckRequested = false;
 8014a6c:	4b0d      	ldr	r3, [pc, #52]	; (8014aa4 <LoRaMacMlmeRequest+0x28c>)
 8014a6e:	4a12      	ldr	r2, [pc, #72]	; (8014ab8 <LoRaMacMlmeRequest+0x2a0>)
 8014a70:	2100      	movs	r1, #0
 8014a72:	5499      	strb	r1, [r3, r2]
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 8014a74:	4b0b      	ldr	r3, [pc, #44]	; (8014aa4 <LoRaMacMlmeRequest+0x28c>)
 8014a76:	4a0d      	ldr	r2, [pc, #52]	; (8014aac <LoRaMacMlmeRequest+0x294>)
 8014a78:	5c99      	ldrb	r1, [r3, r2]
 8014a7a:	2004      	movs	r0, #4
 8014a7c:	4381      	bics	r1, r0
 8014a7e:	5499      	strb	r1, [r3, r2]
 8014a80:	e006      	b.n	8014a90 <LoRaMacMlmeRequest+0x278>
        }
    }
    else
    {
        LoRaMacConfirmQueueAdd( &queueElement );
 8014a82:	2310      	movs	r3, #16
 8014a84:	18fb      	adds	r3, r7, r3
 8014a86:	0018      	movs	r0, r3
 8014a88:	f000 febe 	bl	8015808 <LoRaMacConfirmQueueAdd>
        EventMacNvmCtxChanged( );
 8014a8c:	f7fe fbbc 	bl	8013208 <EventMacNvmCtxChanged>
    }
    return status;
 8014a90:	2317      	movs	r3, #23
 8014a92:	18fb      	adds	r3, r7, r3
 8014a94:	781b      	ldrb	r3, [r3, #0]
}
 8014a96:	0018      	movs	r0, r3
 8014a98:	46bd      	mov	sp, r7
 8014a9a:	b006      	add	sp, #24
 8014a9c:	bdb0      	pop	{r4, r5, r7, pc}
 8014a9e:	46c0      	nop			; (mov r8, r8)
 8014aa0:	20000d3c 	.word	0x20000d3c
 8014aa4:	200008ec 	.word	0x200008ec
 8014aa8:	00000451 	.word	0x00000451
 8014aac:	00000481 	.word	0x00000481
 8014ab0:	0801f3e0 	.word	0x0801f3e0
 8014ab4:	00000484 	.word	0x00000484
 8014ab8:	00000414 	.word	0x00000414

08014abc <LoRaMacMcpsRequest>:

LoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest )
{
 8014abc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014abe:	b08b      	sub	sp, #44	; 0x2c
 8014ac0:	af00      	add	r7, sp, #0
 8014ac2:	6078      	str	r0, [r7, #4]
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 8014ac4:	2327      	movs	r3, #39	; 0x27
 8014ac6:	18fb      	adds	r3, r7, r3
 8014ac8:	2202      	movs	r2, #2
 8014aca:	701a      	strb	r2, [r3, #0]
    LoRaMacHeader_t macHdr;
    VerifyParams_t verify;
    uint8_t fPort = 0;
 8014acc:	2326      	movs	r3, #38	; 0x26
 8014ace:	18fb      	adds	r3, r7, r3
 8014ad0:	2200      	movs	r2, #0
 8014ad2:	701a      	strb	r2, [r3, #0]
    void* fBuffer;
    uint16_t fBufferSize;
    int8_t datarate = DR_0;
 8014ad4:	231d      	movs	r3, #29
 8014ad6:	18fb      	adds	r3, r7, r3
 8014ad8:	2200      	movs	r2, #0
 8014ada:	701a      	strb	r2, [r3, #0]
    bool readyToSend = false;
 8014adc:	231c      	movs	r3, #28
 8014ade:	18fb      	adds	r3, r7, r3
 8014ae0:	2200      	movs	r2, #0
 8014ae2:	701a      	strb	r2, [r3, #0]

    if( mcpsRequest == NULL )
 8014ae4:	687b      	ldr	r3, [r7, #4]
 8014ae6:	2b00      	cmp	r3, #0
 8014ae8:	d101      	bne.n	8014aee <LoRaMacMcpsRequest+0x32>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8014aea:	2303      	movs	r3, #3
 8014aec:	e115      	b.n	8014d1a <LoRaMacMcpsRequest+0x25e>
    }
    if( LoRaMacIsBusy( ) == true )
 8014aee:	f7fb fdfb 	bl	80106e8 <LoRaMacIsBusy>
 8014af2:	1e03      	subs	r3, r0, #0
 8014af4:	d001      	beq.n	8014afa <LoRaMacMcpsRequest+0x3e>
    {
        return LORAMAC_STATUS_BUSY;
 8014af6:	2301      	movs	r3, #1
 8014af8:	e10f      	b.n	8014d1a <LoRaMacMcpsRequest+0x25e>
    }

    macHdr.Value = 0;
 8014afa:	2310      	movs	r3, #16
 8014afc:	18fb      	adds	r3, r7, r3
 8014afe:	2200      	movs	r2, #0
 8014b00:	701a      	strb	r2, [r3, #0]
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 8014b02:	4b88      	ldr	r3, [pc, #544]	; (8014d24 <LoRaMacMcpsRequest+0x268>)
 8014b04:	2214      	movs	r2, #20
 8014b06:	2100      	movs	r1, #0
 8014b08:	0018      	movs	r0, r3
 8014b0a:	f006 fd5b 	bl	801b5c4 <memset1>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8014b0e:	4b86      	ldr	r3, [pc, #536]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014b10:	4a86      	ldr	r2, [pc, #536]	; (8014d2c <LoRaMacMcpsRequest+0x270>)
 8014b12:	2101      	movs	r1, #1
 8014b14:	5499      	strb	r1, [r3, r2]

    // AckTimeoutRetriesCounter must be reset every time a new request (unconfirmed or confirmed) is performed.
    MacCtx.AckTimeoutRetriesCounter = 1;
 8014b16:	4b84      	ldr	r3, [pc, #528]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014b18:	4a85      	ldr	r2, [pc, #532]	; (8014d30 <LoRaMacMcpsRequest+0x274>)
 8014b1a:	2101      	movs	r1, #1
 8014b1c:	5499      	strb	r1, [r3, r2]

    switch( mcpsRequest->Type )
 8014b1e:	687b      	ldr	r3, [r7, #4]
 8014b20:	781b      	ldrb	r3, [r3, #0]
 8014b22:	2b03      	cmp	r3, #3
 8014b24:	d056      	beq.n	8014bd4 <LoRaMacMcpsRequest+0x118>
 8014b26:	dc72      	bgt.n	8014c0e <LoRaMacMcpsRequest+0x152>
 8014b28:	2b00      	cmp	r3, #0
 8014b2a:	d002      	beq.n	8014b32 <LoRaMacMcpsRequest+0x76>
 8014b2c:	2b01      	cmp	r3, #1
 8014b2e:	d024      	beq.n	8014b7a <LoRaMacMcpsRequest+0xbe>
            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;
            datarate = mcpsRequest->Req.Proprietary.Datarate;
            break;
        }
        default:
            break;
 8014b30:	e06d      	b.n	8014c0e <LoRaMacMcpsRequest+0x152>
            readyToSend = true;
 8014b32:	231c      	movs	r3, #28
 8014b34:	18fb      	adds	r3, r7, r3
 8014b36:	2201      	movs	r2, #1
 8014b38:	701a      	strb	r2, [r3, #0]
            MacCtx.AckTimeoutRetries = 1;
 8014b3a:	4b7b      	ldr	r3, [pc, #492]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014b3c:	4a7d      	ldr	r2, [pc, #500]	; (8014d34 <LoRaMacMcpsRequest+0x278>)
 8014b3e:	2101      	movs	r1, #1
 8014b40:	5499      	strb	r1, [r3, r2]
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 8014b42:	2310      	movs	r3, #16
 8014b44:	18fb      	adds	r3, r7, r3
 8014b46:	781a      	ldrb	r2, [r3, #0]
 8014b48:	211f      	movs	r1, #31
 8014b4a:	400a      	ands	r2, r1
 8014b4c:	1c11      	adds	r1, r2, #0
 8014b4e:	2240      	movs	r2, #64	; 0x40
 8014b50:	430a      	orrs	r2, r1
 8014b52:	701a      	strb	r2, [r3, #0]
            fPort = mcpsRequest->Req.Unconfirmed.fPort;
 8014b54:	2326      	movs	r3, #38	; 0x26
 8014b56:	18fb      	adds	r3, r7, r3
 8014b58:	687a      	ldr	r2, [r7, #4]
 8014b5a:	7912      	ldrb	r2, [r2, #4]
 8014b5c:	701a      	strb	r2, [r3, #0]
            fBuffer = mcpsRequest->Req.Unconfirmed.fBuffer;
 8014b5e:	687b      	ldr	r3, [r7, #4]
 8014b60:	689b      	ldr	r3, [r3, #8]
 8014b62:	623b      	str	r3, [r7, #32]
            fBufferSize = mcpsRequest->Req.Unconfirmed.fBufferSize;
 8014b64:	231e      	movs	r3, #30
 8014b66:	18fb      	adds	r3, r7, r3
 8014b68:	687a      	ldr	r2, [r7, #4]
 8014b6a:	8992      	ldrh	r2, [r2, #12]
 8014b6c:	801a      	strh	r2, [r3, #0]
            datarate = mcpsRequest->Req.Unconfirmed.Datarate;
 8014b6e:	231d      	movs	r3, #29
 8014b70:	18fb      	adds	r3, r7, r3
 8014b72:	687a      	ldr	r2, [r7, #4]
 8014b74:	7b92      	ldrb	r2, [r2, #14]
 8014b76:	701a      	strb	r2, [r3, #0]
            break;
 8014b78:	e04a      	b.n	8014c10 <LoRaMacMcpsRequest+0x154>
            readyToSend = true;
 8014b7a:	231c      	movs	r3, #28
 8014b7c:	18fb      	adds	r3, r7, r3
 8014b7e:	2201      	movs	r2, #1
 8014b80:	701a      	strb	r2, [r3, #0]
            MacCtx.AckTimeoutRetries = MIN( mcpsRequest->Req.Confirmed.NbTrials, MAX_ACK_RETRIES );
 8014b82:	687b      	ldr	r3, [r7, #4]
 8014b84:	7bdb      	ldrb	r3, [r3, #15]
 8014b86:	1c1a      	adds	r2, r3, #0
 8014b88:	b2d3      	uxtb	r3, r2
 8014b8a:	2b08      	cmp	r3, #8
 8014b8c:	d901      	bls.n	8014b92 <LoRaMacMcpsRequest+0xd6>
 8014b8e:	2308      	movs	r3, #8
 8014b90:	1c1a      	adds	r2, r3, #0
 8014b92:	b2d1      	uxtb	r1, r2
 8014b94:	4b64      	ldr	r3, [pc, #400]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014b96:	4a67      	ldr	r2, [pc, #412]	; (8014d34 <LoRaMacMcpsRequest+0x278>)
 8014b98:	5499      	strb	r1, [r3, r2]
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 8014b9a:	2310      	movs	r3, #16
 8014b9c:	18fb      	adds	r3, r7, r3
 8014b9e:	781a      	ldrb	r2, [r3, #0]
 8014ba0:	211f      	movs	r1, #31
 8014ba2:	400a      	ands	r2, r1
 8014ba4:	1c11      	adds	r1, r2, #0
 8014ba6:	2280      	movs	r2, #128	; 0x80
 8014ba8:	4252      	negs	r2, r2
 8014baa:	430a      	orrs	r2, r1
 8014bac:	701a      	strb	r2, [r3, #0]
            fPort = mcpsRequest->Req.Confirmed.fPort;
 8014bae:	2326      	movs	r3, #38	; 0x26
 8014bb0:	18fb      	adds	r3, r7, r3
 8014bb2:	687a      	ldr	r2, [r7, #4]
 8014bb4:	7912      	ldrb	r2, [r2, #4]
 8014bb6:	701a      	strb	r2, [r3, #0]
            fBuffer = mcpsRequest->Req.Confirmed.fBuffer;
 8014bb8:	687b      	ldr	r3, [r7, #4]
 8014bba:	689b      	ldr	r3, [r3, #8]
 8014bbc:	623b      	str	r3, [r7, #32]
            fBufferSize = mcpsRequest->Req.Confirmed.fBufferSize;
 8014bbe:	231e      	movs	r3, #30
 8014bc0:	18fb      	adds	r3, r7, r3
 8014bc2:	687a      	ldr	r2, [r7, #4]
 8014bc4:	8992      	ldrh	r2, [r2, #12]
 8014bc6:	801a      	strh	r2, [r3, #0]
            datarate = mcpsRequest->Req.Confirmed.Datarate;
 8014bc8:	231d      	movs	r3, #29
 8014bca:	18fb      	adds	r3, r7, r3
 8014bcc:	687a      	ldr	r2, [r7, #4]
 8014bce:	7b92      	ldrb	r2, [r2, #14]
 8014bd0:	701a      	strb	r2, [r3, #0]
            break;
 8014bd2:	e01d      	b.n	8014c10 <LoRaMacMcpsRequest+0x154>
            readyToSend = true;
 8014bd4:	231c      	movs	r3, #28
 8014bd6:	18fb      	adds	r3, r7, r3
 8014bd8:	2201      	movs	r2, #1
 8014bda:	701a      	strb	r2, [r3, #0]
            MacCtx.AckTimeoutRetries = 1;
 8014bdc:	4b52      	ldr	r3, [pc, #328]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014bde:	4a55      	ldr	r2, [pc, #340]	; (8014d34 <LoRaMacMcpsRequest+0x278>)
 8014be0:	2101      	movs	r1, #1
 8014be2:	5499      	strb	r1, [r3, r2]
            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;
 8014be4:	2310      	movs	r3, #16
 8014be6:	18fb      	adds	r3, r7, r3
 8014be8:	781a      	ldrb	r2, [r3, #0]
 8014bea:	2120      	movs	r1, #32
 8014bec:	4249      	negs	r1, r1
 8014bee:	430a      	orrs	r2, r1
 8014bf0:	701a      	strb	r2, [r3, #0]
            fBuffer = mcpsRequest->Req.Proprietary.fBuffer;
 8014bf2:	687b      	ldr	r3, [r7, #4]
 8014bf4:	685b      	ldr	r3, [r3, #4]
 8014bf6:	623b      	str	r3, [r7, #32]
            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;
 8014bf8:	231e      	movs	r3, #30
 8014bfa:	18fb      	adds	r3, r7, r3
 8014bfc:	687a      	ldr	r2, [r7, #4]
 8014bfe:	8912      	ldrh	r2, [r2, #8]
 8014c00:	801a      	strh	r2, [r3, #0]
            datarate = mcpsRequest->Req.Proprietary.Datarate;
 8014c02:	231d      	movs	r3, #29
 8014c04:	18fb      	adds	r3, r7, r3
 8014c06:	687a      	ldr	r2, [r7, #4]
 8014c08:	7a92      	ldrb	r2, [r2, #10]
 8014c0a:	701a      	strb	r2, [r3, #0]
            break;
 8014c0c:	e000      	b.n	8014c10 <LoRaMacMcpsRequest+0x154>
            break;
 8014c0e:	46c0      	nop			; (mov r8, r8)
    }

    // Get the minimum possible datarate
    getPhy.Attribute = PHY_MIN_TX_DR;
 8014c10:	2118      	movs	r1, #24
 8014c12:	187b      	adds	r3, r7, r1
 8014c14:	2202      	movs	r2, #2
 8014c16:	701a      	strb	r2, [r3, #0]
    getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;
 8014c18:	4b43      	ldr	r3, [pc, #268]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014c1a:	4a47      	ldr	r2, [pc, #284]	; (8014d38 <LoRaMacMcpsRequest+0x27c>)
 8014c1c:	589a      	ldr	r2, [r3, r2]
 8014c1e:	2396      	movs	r3, #150	; 0x96
 8014c20:	005b      	lsls	r3, r3, #1
 8014c22:	5cd2      	ldrb	r2, [r2, r3]
 8014c24:	187b      	adds	r3, r7, r1
 8014c26:	709a      	strb	r2, [r3, #2]
    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );
 8014c28:	4b3f      	ldr	r3, [pc, #252]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014c2a:	4a43      	ldr	r2, [pc, #268]	; (8014d38 <LoRaMacMcpsRequest+0x27c>)
 8014c2c:	589b      	ldr	r3, [r3, r2]
 8014c2e:	781b      	ldrb	r3, [r3, #0]
 8014c30:	187a      	adds	r2, r7, r1
 8014c32:	0011      	movs	r1, r2
 8014c34:	0018      	movs	r0, r3
 8014c36:	f002 fc72 	bl	801751e <RegionGetPhyParam>
 8014c3a:	0003      	movs	r3, r0
 8014c3c:	001a      	movs	r2, r3
 8014c3e:	2114      	movs	r1, #20
 8014c40:	187b      	adds	r3, r7, r1
 8014c42:	601a      	str	r2, [r3, #0]
    // Apply the minimum possible datarate.
    // Some regions have limitations for the minimum datarate.
    datarate = MAX( datarate, ( int8_t )phyParam.Value );
 8014c44:	187b      	adds	r3, r7, r1
 8014c46:	681b      	ldr	r3, [r3, #0]
 8014c48:	b259      	sxtb	r1, r3
 8014c4a:	231d      	movs	r3, #29
 8014c4c:	18fa      	adds	r2, r7, r3
 8014c4e:	18fb      	adds	r3, r7, r3
 8014c50:	1c0c      	adds	r4, r1, #0
 8014c52:	781b      	ldrb	r3, [r3, #0]
 8014c54:	b258      	sxtb	r0, r3
 8014c56:	b261      	sxtb	r1, r4
 8014c58:	4288      	cmp	r0, r1
 8014c5a:	da00      	bge.n	8014c5e <LoRaMacMcpsRequest+0x1a2>
 8014c5c:	1c23      	adds	r3, r4, #0
 8014c5e:	7013      	strb	r3, [r2, #0]

    if( readyToSend == true )
 8014c60:	231c      	movs	r3, #28
 8014c62:	18fb      	adds	r3, r7, r3
 8014c64:	781b      	ldrb	r3, [r3, #0]
 8014c66:	2b00      	cmp	r3, #0
 8014c68:	d052      	beq.n	8014d10 <LoRaMacMcpsRequest+0x254>
    {
        if( MacCtx.NvmCtx->AdrCtrlOn == false )
 8014c6a:	4b2f      	ldr	r3, [pc, #188]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014c6c:	4a32      	ldr	r2, [pc, #200]	; (8014d38 <LoRaMacMcpsRequest+0x27c>)
 8014c6e:	589b      	ldr	r3, [r3, r2]
 8014c70:	22f2      	movs	r2, #242	; 0xf2
 8014c72:	5c9b      	ldrb	r3, [r3, r2]
 8014c74:	2201      	movs	r2, #1
 8014c76:	4053      	eors	r3, r2
 8014c78:	b2db      	uxtb	r3, r3
 8014c7a:	2b00      	cmp	r3, #0
 8014c7c:	d024      	beq.n	8014cc8 <LoRaMacMcpsRequest+0x20c>
        {
            verify.DatarateParams.Datarate = datarate;
 8014c7e:	210c      	movs	r1, #12
 8014c80:	187b      	adds	r3, r7, r1
 8014c82:	221d      	movs	r2, #29
 8014c84:	18ba      	adds	r2, r7, r2
 8014c86:	7812      	ldrb	r2, [r2, #0]
 8014c88:	701a      	strb	r2, [r3, #0]
            verify.DatarateParams.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;
 8014c8a:	4b27      	ldr	r3, [pc, #156]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014c8c:	4a2a      	ldr	r2, [pc, #168]	; (8014d38 <LoRaMacMcpsRequest+0x27c>)
 8014c8e:	589a      	ldr	r2, [r3, r2]
 8014c90:	2396      	movs	r3, #150	; 0x96
 8014c92:	005b      	lsls	r3, r3, #1
 8014c94:	5cd2      	ldrb	r2, [r2, r3]
 8014c96:	187b      	adds	r3, r7, r1
 8014c98:	709a      	strb	r2, [r3, #2]

            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_TX_DR ) == true )
 8014c9a:	4b23      	ldr	r3, [pc, #140]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014c9c:	4a26      	ldr	r2, [pc, #152]	; (8014d38 <LoRaMacMcpsRequest+0x27c>)
 8014c9e:	589b      	ldr	r3, [r3, r2]
 8014ca0:	781b      	ldrb	r3, [r3, #0]
 8014ca2:	000c      	movs	r4, r1
 8014ca4:	1879      	adds	r1, r7, r1
 8014ca6:	2205      	movs	r2, #5
 8014ca8:	0018      	movs	r0, r3
 8014caa:	f002 fc9f 	bl	80175ec <RegionVerify>
 8014cae:	1e03      	subs	r3, r0, #0
 8014cb0:	d008      	beq.n	8014cc4 <LoRaMacMcpsRequest+0x208>
            {
                MacCtx.NvmCtx->MacParams.ChannelsDatarate = verify.DatarateParams.Datarate;
 8014cb2:	4b1d      	ldr	r3, [pc, #116]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014cb4:	4a20      	ldr	r2, [pc, #128]	; (8014d38 <LoRaMacMcpsRequest+0x27c>)
 8014cb6:	589b      	ldr	r3, [r3, r2]
 8014cb8:	193a      	adds	r2, r7, r4
 8014cba:	2100      	movs	r1, #0
 8014cbc:	5651      	ldrsb	r1, [r2, r1]
 8014cbe:	22f9      	movs	r2, #249	; 0xf9
 8014cc0:	5499      	strb	r1, [r3, r2]
 8014cc2:	e001      	b.n	8014cc8 <LoRaMacMcpsRequest+0x20c>
            }
            else
            {
                return LORAMAC_STATUS_PARAMETER_INVALID;
 8014cc4:	2303      	movs	r3, #3
 8014cc6:	e028      	b.n	8014d1a <LoRaMacMcpsRequest+0x25e>
            }
        }

        status = Send( &macHdr, fPort, fBuffer, fBufferSize );
 8014cc8:	2627      	movs	r6, #39	; 0x27
 8014cca:	19bc      	adds	r4, r7, r6
 8014ccc:	231e      	movs	r3, #30
 8014cce:	18fb      	adds	r3, r7, r3
 8014cd0:	881d      	ldrh	r5, [r3, #0]
 8014cd2:	6a3a      	ldr	r2, [r7, #32]
 8014cd4:	2326      	movs	r3, #38	; 0x26
 8014cd6:	18fb      	adds	r3, r7, r3
 8014cd8:	7819      	ldrb	r1, [r3, #0]
 8014cda:	2310      	movs	r3, #16
 8014cdc:	18f8      	adds	r0, r7, r3
 8014cde:	002b      	movs	r3, r5
 8014ce0:	f7fd f820 	bl	8011d24 <Send>
 8014ce4:	0003      	movs	r3, r0
 8014ce6:	7023      	strb	r3, [r4, #0]
        if( status == LORAMAC_STATUS_OK )
 8014ce8:	19bb      	adds	r3, r7, r6
 8014cea:	781b      	ldrb	r3, [r3, #0]
 8014cec:	2b00      	cmp	r3, #0
 8014cee:	d10b      	bne.n	8014d08 <LoRaMacMcpsRequest+0x24c>
        {
            MacCtx.McpsConfirm.McpsRequest = mcpsRequest->Type;
 8014cf0:	687b      	ldr	r3, [r7, #4]
 8014cf2:	7819      	ldrb	r1, [r3, #0]
 8014cf4:	4b0c      	ldr	r3, [pc, #48]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014cf6:	4a11      	ldr	r2, [pc, #68]	; (8014d3c <LoRaMacMcpsRequest+0x280>)
 8014cf8:	5499      	strb	r1, [r3, r2]
            MacCtx.MacFlags.Bits.McpsReq = 1;
 8014cfa:	4b0b      	ldr	r3, [pc, #44]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014cfc:	4a10      	ldr	r2, [pc, #64]	; (8014d40 <LoRaMacMcpsRequest+0x284>)
 8014cfe:	5c99      	ldrb	r1, [r3, r2]
 8014d00:	2001      	movs	r0, #1
 8014d02:	4301      	orrs	r1, r0
 8014d04:	5499      	strb	r1, [r3, r2]
 8014d06:	e003      	b.n	8014d10 <LoRaMacMcpsRequest+0x254>
        }
        else
        {
            MacCtx.NodeAckRequested = false;
 8014d08:	4b07      	ldr	r3, [pc, #28]	; (8014d28 <LoRaMacMcpsRequest+0x26c>)
 8014d0a:	4a0e      	ldr	r2, [pc, #56]	; (8014d44 <LoRaMacMcpsRequest+0x288>)
 8014d0c:	2100      	movs	r1, #0
 8014d0e:	5499      	strb	r1, [r3, r2]
        }
    }

    EventMacNvmCtxChanged( );
 8014d10:	f7fe fa7a 	bl	8013208 <EventMacNvmCtxChanged>
    return status;
 8014d14:	2327      	movs	r3, #39	; 0x27
 8014d16:	18fb      	adds	r3, r7, r3
 8014d18:	781b      	ldrb	r3, [r3, #0]
}
 8014d1a:	0018      	movs	r0, r3
 8014d1c:	46bd      	mov	sp, r7
 8014d1e:	b00b      	add	sp, #44	; 0x2c
 8014d20:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8014d22:	46c0      	nop			; (mov r8, r8)
 8014d24:	20000d28 	.word	0x20000d28
 8014d28:	200008ec 	.word	0x200008ec
 8014d2c:	0000043d 	.word	0x0000043d
 8014d30:	00000412 	.word	0x00000412
 8014d34:	00000411 	.word	0x00000411
 8014d38:	00000484 	.word	0x00000484
 8014d3c:	0000043c 	.word	0x0000043c
 8014d40:	00000481 	.word	0x00000481
 8014d44:	00000414 	.word	0x00000414

08014d48 <LoRaMacTestSetDutyCycleOn>:

void LoRaMacTestSetDutyCycleOn( bool enable )
{
 8014d48:	b580      	push	{r7, lr}
 8014d4a:	b084      	sub	sp, #16
 8014d4c:	af00      	add	r7, sp, #0
 8014d4e:	0002      	movs	r2, r0
 8014d50:	1dfb      	adds	r3, r7, #7
 8014d52:	701a      	strb	r2, [r3, #0]
    VerifyParams_t verify;

    verify.DutyCycle = enable;
 8014d54:	210c      	movs	r1, #12
 8014d56:	187b      	adds	r3, r7, r1
 8014d58:	1dfa      	adds	r2, r7, #7
 8014d5a:	7812      	ldrb	r2, [r2, #0]
 8014d5c:	701a      	strb	r2, [r3, #0]

    if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_DUTY_CYCLE ) == true )
 8014d5e:	4b0b      	ldr	r3, [pc, #44]	; (8014d8c <LoRaMacTestSetDutyCycleOn+0x44>)
 8014d60:	4a0b      	ldr	r2, [pc, #44]	; (8014d90 <LoRaMacTestSetDutyCycleOn+0x48>)
 8014d62:	589b      	ldr	r3, [r3, r2]
 8014d64:	781b      	ldrb	r3, [r3, #0]
 8014d66:	1879      	adds	r1, r7, r1
 8014d68:	220f      	movs	r2, #15
 8014d6a:	0018      	movs	r0, r3
 8014d6c:	f002 fc3e 	bl	80175ec <RegionVerify>
 8014d70:	1e03      	subs	r3, r0, #0
 8014d72:	d007      	beq.n	8014d84 <LoRaMacTestSetDutyCycleOn+0x3c>
    {
        MacCtx.NvmCtx->DutyCycleOn = enable;
 8014d74:	4b05      	ldr	r3, [pc, #20]	; (8014d8c <LoRaMacTestSetDutyCycleOn+0x44>)
 8014d76:	4a06      	ldr	r2, [pc, #24]	; (8014d90 <LoRaMacTestSetDutyCycleOn+0x48>)
 8014d78:	589a      	ldr	r2, [r3, r2]
 8014d7a:	1df9      	adds	r1, r7, #7
 8014d7c:	233e      	movs	r3, #62	; 0x3e
 8014d7e:	33ff      	adds	r3, #255	; 0xff
 8014d80:	7809      	ldrb	r1, [r1, #0]
 8014d82:	54d1      	strb	r1, [r2, r3]
    }
}
 8014d84:	46c0      	nop			; (mov r8, r8)
 8014d86:	46bd      	mov	sp, r7
 8014d88:	b004      	add	sp, #16
 8014d8a:	bd80      	pop	{r7, pc}
 8014d8c:	200008ec 	.word	0x200008ec
 8014d90:	00000484 	.word	0x00000484

08014d94 <CalcNextV10X>:

#include "region/Region.h"
#include "LoRaMacAdr.h"

static bool CalcNextV10X( CalcNextAdrParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter )
{
 8014d94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014d96:	b08b      	sub	sp, #44	; 0x2c
 8014d98:	af00      	add	r7, sp, #0
 8014d9a:	60f8      	str	r0, [r7, #12]
 8014d9c:	60b9      	str	r1, [r7, #8]
 8014d9e:	607a      	str	r2, [r7, #4]
 8014da0:	603b      	str	r3, [r7, #0]
    bool adrAckReq = false;
 8014da2:	2327      	movs	r3, #39	; 0x27
 8014da4:	18fb      	adds	r3, r7, r3
 8014da6:	2200      	movs	r2, #0
 8014da8:	701a      	strb	r2, [r3, #0]
    int8_t datarate = adrNext->Datarate;
 8014daa:	2426      	movs	r4, #38	; 0x26
 8014dac:	193b      	adds	r3, r7, r4
 8014dae:	68fa      	ldr	r2, [r7, #12]
 8014db0:	7c12      	ldrb	r2, [r2, #16]
 8014db2:	701a      	strb	r2, [r3, #0]
    int8_t txPower = adrNext->TxPower;
 8014db4:	2325      	movs	r3, #37	; 0x25
 8014db6:	18fb      	adds	r3, r7, r3
 8014db8:	68fa      	ldr	r2, [r7, #12]
 8014dba:	7c52      	ldrb	r2, [r2, #17]
 8014dbc:	701a      	strb	r2, [r3, #0]
    int8_t minTxDatarate;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    // Report back the adr ack counter
    *adrAckCounter = adrNext->AdrAckCounter;
 8014dbe:	68fb      	ldr	r3, [r7, #12]
 8014dc0:	689a      	ldr	r2, [r3, #8]
 8014dc2:	683b      	ldr	r3, [r7, #0]
 8014dc4:	601a      	str	r2, [r3, #0]

    if( adrNext->AdrEnabled == true )
 8014dc6:	68fb      	ldr	r3, [r7, #12]
 8014dc8:	795b      	ldrb	r3, [r3, #5]
 8014dca:	2b00      	cmp	r3, #0
 8014dcc:	d100      	bne.n	8014dd0 <CalcNextV10X+0x3c>
 8014dce:	e0a5      	b.n	8014f1c <CalcNextV10X+0x188>
    {
        // Query minimum TX Datarate
        getPhy.Attribute = PHY_MIN_TX_DR;
 8014dd0:	2120      	movs	r1, #32
 8014dd2:	187b      	adds	r3, r7, r1
 8014dd4:	2202      	movs	r2, #2
 8014dd6:	701a      	strb	r2, [r3, #0]
        getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 8014dd8:	68fb      	ldr	r3, [r7, #12]
 8014dda:	7c9a      	ldrb	r2, [r3, #18]
 8014ddc:	187b      	adds	r3, r7, r1
 8014dde:	709a      	strb	r2, [r3, #2]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8014de0:	68fb      	ldr	r3, [r7, #12]
 8014de2:	7cdb      	ldrb	r3, [r3, #19]
 8014de4:	187a      	adds	r2, r7, r1
 8014de6:	0011      	movs	r1, r2
 8014de8:	0018      	movs	r0, r3
 8014dea:	f002 fb98 	bl	801751e <RegionGetPhyParam>
 8014dee:	0003      	movs	r3, r0
 8014df0:	001a      	movs	r2, r3
 8014df2:	211c      	movs	r1, #28
 8014df4:	187b      	adds	r3, r7, r1
 8014df6:	601a      	str	r2, [r3, #0]
        minTxDatarate = phyParam.Value;
 8014df8:	187b      	adds	r3, r7, r1
 8014dfa:	681a      	ldr	r2, [r3, #0]
 8014dfc:	2124      	movs	r1, #36	; 0x24
 8014dfe:	187b      	adds	r3, r7, r1
 8014e00:	701a      	strb	r2, [r3, #0]
        datarate = MAX( datarate, minTxDatarate );
 8014e02:	193a      	adds	r2, r7, r4
 8014e04:	187b      	adds	r3, r7, r1
 8014e06:	1939      	adds	r1, r7, r4
 8014e08:	780c      	ldrb	r4, [r1, #0]
 8014e0a:	781b      	ldrb	r3, [r3, #0]
 8014e0c:	b258      	sxtb	r0, r3
 8014e0e:	b261      	sxtb	r1, r4
 8014e10:	4288      	cmp	r0, r1
 8014e12:	da00      	bge.n	8014e16 <CalcNextV10X+0x82>
 8014e14:	1c23      	adds	r3, r4, #0
 8014e16:	7013      	strb	r3, [r2, #0]

        if( datarate == minTxDatarate )
 8014e18:	2326      	movs	r3, #38	; 0x26
 8014e1a:	18fa      	adds	r2, r7, r3
 8014e1c:	2324      	movs	r3, #36	; 0x24
 8014e1e:	18fb      	adds	r3, r7, r3
 8014e20:	7812      	ldrb	r2, [r2, #0]
 8014e22:	b252      	sxtb	r2, r2
 8014e24:	781b      	ldrb	r3, [r3, #0]
 8014e26:	b25b      	sxtb	r3, r3
 8014e28:	429a      	cmp	r2, r3
 8014e2a:	d107      	bne.n	8014e3c <CalcNextV10X+0xa8>
        {
            *adrAckCounter = 0;
 8014e2c:	683b      	ldr	r3, [r7, #0]
 8014e2e:	2200      	movs	r2, #0
 8014e30:	601a      	str	r2, [r3, #0]
            adrAckReq = false;
 8014e32:	2327      	movs	r3, #39	; 0x27
 8014e34:	18fb      	adds	r3, r7, r3
 8014e36:	2200      	movs	r2, #0
 8014e38:	701a      	strb	r2, [r3, #0]
 8014e3a:	e06f      	b.n	8014f1c <CalcNextV10X+0x188>
        }
        else
        {
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 8014e3c:	68fb      	ldr	r3, [r7, #12]
 8014e3e:	689b      	ldr	r3, [r3, #8]
 8014e40:	68fa      	ldr	r2, [r7, #12]
 8014e42:	8992      	ldrh	r2, [r2, #12]
 8014e44:	4293      	cmp	r3, r2
 8014e46:	d304      	bcc.n	8014e52 <CalcNextV10X+0xbe>
            {
                adrAckReq = true;
 8014e48:	2327      	movs	r3, #39	; 0x27
 8014e4a:	18fb      	adds	r3, r7, r3
 8014e4c:	2201      	movs	r2, #1
 8014e4e:	701a      	strb	r2, [r3, #0]
 8014e50:	e003      	b.n	8014e5a <CalcNextV10X+0xc6>
            }
            else
            {
                adrAckReq = false;
 8014e52:	2327      	movs	r3, #39	; 0x27
 8014e54:	18fb      	adds	r3, r7, r3
 8014e56:	2200      	movs	r2, #0
 8014e58:	701a      	strb	r2, [r3, #0]
            }
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 8014e5a:	68fb      	ldr	r3, [r7, #12]
 8014e5c:	689b      	ldr	r3, [r3, #8]
 8014e5e:	68fa      	ldr	r2, [r7, #12]
 8014e60:	8992      	ldrh	r2, [r2, #12]
 8014e62:	0011      	movs	r1, r2
 8014e64:	68fa      	ldr	r2, [r7, #12]
 8014e66:	89d2      	ldrh	r2, [r2, #14]
 8014e68:	188a      	adds	r2, r1, r2
 8014e6a:	4293      	cmp	r3, r2
 8014e6c:	d356      	bcc.n	8014f1c <CalcNextV10X+0x188>
            {
                // Set TX Power to maximum
                getPhy.Attribute = PHY_MAX_TX_POWER;
 8014e6e:	2420      	movs	r4, #32
 8014e70:	193b      	adds	r3, r7, r4
 8014e72:	2208      	movs	r2, #8
 8014e74:	701a      	strb	r2, [r3, #0]
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8014e76:	68fb      	ldr	r3, [r7, #12]
 8014e78:	7cdb      	ldrb	r3, [r3, #19]
 8014e7a:	193a      	adds	r2, r7, r4
 8014e7c:	0011      	movs	r1, r2
 8014e7e:	0018      	movs	r0, r3
 8014e80:	f002 fb4d 	bl	801751e <RegionGetPhyParam>
 8014e84:	0003      	movs	r3, r0
 8014e86:	001a      	movs	r2, r3
 8014e88:	251c      	movs	r5, #28
 8014e8a:	197b      	adds	r3, r7, r5
 8014e8c:	601a      	str	r2, [r3, #0]
                txPower = phyParam.Value;
 8014e8e:	197b      	adds	r3, r7, r5
 8014e90:	681a      	ldr	r2, [r3, #0]
 8014e92:	2325      	movs	r3, #37	; 0x25
 8014e94:	18fb      	adds	r3, r7, r3
 8014e96:	701a      	strb	r2, [r3, #0]

                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 8014e98:	68fb      	ldr	r3, [r7, #12]
 8014e9a:	689a      	ldr	r2, [r3, #8]
 8014e9c:	68fb      	ldr	r3, [r7, #12]
 8014e9e:	89db      	ldrh	r3, [r3, #14]
 8014ea0:	0019      	movs	r1, r3
 8014ea2:	0010      	movs	r0, r2
 8014ea4:	f7eb f9c0 	bl	8000228 <__aeabi_uidivmod>
 8014ea8:	000b      	movs	r3, r1
 8014eaa:	2b01      	cmp	r3, #1
 8014eac:	d136      	bne.n	8014f1c <CalcNextV10X+0x188>
                {
                    // Decrease the datarate
                    getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 8014eae:	193b      	adds	r3, r7, r4
 8014eb0:	2222      	movs	r2, #34	; 0x22
 8014eb2:	701a      	strb	r2, [r3, #0]
                    getPhy.Datarate = datarate;
 8014eb4:	193b      	adds	r3, r7, r4
 8014eb6:	2626      	movs	r6, #38	; 0x26
 8014eb8:	19ba      	adds	r2, r7, r6
 8014eba:	7812      	ldrb	r2, [r2, #0]
 8014ebc:	705a      	strb	r2, [r3, #1]
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 8014ebe:	68fb      	ldr	r3, [r7, #12]
 8014ec0:	7c9a      	ldrb	r2, [r3, #18]
 8014ec2:	193b      	adds	r3, r7, r4
 8014ec4:	709a      	strb	r2, [r3, #2]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8014ec6:	68fb      	ldr	r3, [r7, #12]
 8014ec8:	7cdb      	ldrb	r3, [r3, #19]
 8014eca:	193a      	adds	r2, r7, r4
 8014ecc:	0011      	movs	r1, r2
 8014ece:	0018      	movs	r0, r3
 8014ed0:	f002 fb25 	bl	801751e <RegionGetPhyParam>
 8014ed4:	0003      	movs	r3, r0
 8014ed6:	001a      	movs	r2, r3
 8014ed8:	197b      	adds	r3, r7, r5
 8014eda:	601a      	str	r2, [r3, #0]
                    datarate = phyParam.Value;
 8014edc:	197b      	adds	r3, r7, r5
 8014ede:	681a      	ldr	r2, [r3, #0]
 8014ee0:	19bb      	adds	r3, r7, r6
 8014ee2:	701a      	strb	r2, [r3, #0]

                    if( datarate == minTxDatarate )
 8014ee4:	19ba      	adds	r2, r7, r6
 8014ee6:	2324      	movs	r3, #36	; 0x24
 8014ee8:	18fb      	adds	r3, r7, r3
 8014eea:	7812      	ldrb	r2, [r2, #0]
 8014eec:	b252      	sxtb	r2, r2
 8014eee:	781b      	ldrb	r3, [r3, #0]
 8014ef0:	b25b      	sxtb	r3, r3
 8014ef2:	429a      	cmp	r2, r3
 8014ef4:	d112      	bne.n	8014f1c <CalcNextV10X+0x188>
                    {
                        // We must set adrAckReq to false as soon as we reach the lowest datarate
                        adrAckReq = false;
 8014ef6:	2327      	movs	r3, #39	; 0x27
 8014ef8:	18fb      	adds	r3, r7, r3
 8014efa:	2200      	movs	r2, #0
 8014efc:	701a      	strb	r2, [r3, #0]
                        if( adrNext->UpdateChanMask == true )
 8014efe:	68fb      	ldr	r3, [r7, #12]
 8014f00:	791b      	ldrb	r3, [r3, #4]
 8014f02:	2b00      	cmp	r3, #0
 8014f04:	d00a      	beq.n	8014f1c <CalcNextV10X+0x188>
                        {
                            InitDefaultsParams_t params;
                            params.Type = INIT_TYPE_RESTORE_DEFAULT_CHANNELS;
 8014f06:	2114      	movs	r1, #20
 8014f08:	187b      	adds	r3, r7, r1
 8014f0a:	2201      	movs	r2, #1
 8014f0c:	711a      	strb	r2, [r3, #4]
                            RegionInitDefaults( adrNext->Region, &params );
 8014f0e:	68fb      	ldr	r3, [r7, #12]
 8014f10:	7cdb      	ldrb	r3, [r3, #19]
 8014f12:	187a      	adds	r2, r7, r1
 8014f14:	0011      	movs	r1, r2
 8014f16:	0018      	movs	r0, r3
 8014f18:	f002 fb3d 	bl	8017596 <RegionInitDefaults>
                }
            }
        }
    }

    *drOut = datarate;
 8014f1c:	68bb      	ldr	r3, [r7, #8]
 8014f1e:	2226      	movs	r2, #38	; 0x26
 8014f20:	18ba      	adds	r2, r7, r2
 8014f22:	7812      	ldrb	r2, [r2, #0]
 8014f24:	701a      	strb	r2, [r3, #0]
    *txPowOut = txPower;
 8014f26:	687b      	ldr	r3, [r7, #4]
 8014f28:	2225      	movs	r2, #37	; 0x25
 8014f2a:	18ba      	adds	r2, r7, r2
 8014f2c:	7812      	ldrb	r2, [r2, #0]
 8014f2e:	701a      	strb	r2, [r3, #0]
    return adrAckReq;
 8014f30:	2327      	movs	r3, #39	; 0x27
 8014f32:	18fb      	adds	r3, r7, r3
 8014f34:	781b      	ldrb	r3, [r3, #0]
}
 8014f36:	0018      	movs	r0, r3
 8014f38:	46bd      	mov	sp, r7
 8014f3a:	b00b      	add	sp, #44	; 0x2c
 8014f3c:	bdf0      	pop	{r4, r5, r6, r7, pc}

08014f3e <LoRaMacAdrCalcNext>:
 * \param [OUT] adrAckCounter The calculated ADR acknowledgement counter.
 *
 * \retval Returns true, if an ADR request should be performed.
 */
bool LoRaMacAdrCalcNext( CalcNextAdrParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter )
{
 8014f3e:	b580      	push	{r7, lr}
 8014f40:	b084      	sub	sp, #16
 8014f42:	af00      	add	r7, sp, #0
 8014f44:	60f8      	str	r0, [r7, #12]
 8014f46:	60b9      	str	r1, [r7, #8]
 8014f48:	607a      	str	r2, [r7, #4]
 8014f4a:	603b      	str	r3, [r7, #0]
    if( adrNext->Version.Fields.Minor == 0 )
 8014f4c:	68fb      	ldr	r3, [r7, #12]
 8014f4e:	789b      	ldrb	r3, [r3, #2]
 8014f50:	2b00      	cmp	r3, #0
 8014f52:	d107      	bne.n	8014f64 <LoRaMacAdrCalcNext+0x26>
    {
        return CalcNextV10X( adrNext, drOut, txPowOut, adrAckCounter );
 8014f54:	683b      	ldr	r3, [r7, #0]
 8014f56:	687a      	ldr	r2, [r7, #4]
 8014f58:	68b9      	ldr	r1, [r7, #8]
 8014f5a:	68f8      	ldr	r0, [r7, #12]
 8014f5c:	f7ff ff1a 	bl	8014d94 <CalcNextV10X>
 8014f60:	0003      	movs	r3, r0
 8014f62:	e000      	b.n	8014f66 <LoRaMacAdrCalcNext+0x28>
    }
    return false;
 8014f64:	2300      	movs	r3, #0
}
 8014f66:	0018      	movs	r0, r3
 8014f68:	46bd      	mov	sp, r7
 8014f6a:	b004      	add	sp, #16
 8014f6c:	bd80      	pop	{r7, pc}

08014f6e <LoRaMacClassBInit>:
}

#endif // LORAMAC_CLASSB_ENABLED

void LoRaMacClassBInit( LoRaMacClassBParams_t *classBParams, LoRaMacClassBCallback_t *callbacks, LoRaMacClassBNvmEvent classBNvmCtxChanged )
{
 8014f6e:	b580      	push	{r7, lr}
 8014f70:	b084      	sub	sp, #16
 8014f72:	af00      	add	r7, sp, #0
 8014f74:	60f8      	str	r0, [r7, #12]
 8014f76:	60b9      	str	r1, [r7, #8]
 8014f78:	607a      	str	r2, [r7, #4]
    TimerInit( &Ctx.PingSlotTimer, LoRaMacClassBPingSlotTimerEvent );
    TimerInit( &Ctx.MulticastSlotTimer, LoRaMacClassBMulticastSlotTimerEvent );

    InitClassB( );
#endif // LORAMAC_CLASSB_ENABLED
}
 8014f7a:	46c0      	nop			; (mov r8, r8)
 8014f7c:	46bd      	mov	sp, r7
 8014f7e:	b004      	add	sp, #16
 8014f80:	bd80      	pop	{r7, pc}

08014f82 <LoRaMacClassBRestoreNvmCtx>:

bool LoRaMacClassBRestoreNvmCtx( void* classBNvmCtx )
{
 8014f82:	b580      	push	{r7, lr}
 8014f84:	b082      	sub	sp, #8
 8014f86:	af00      	add	r7, sp, #0
 8014f88:	6078      	str	r0, [r7, #4]
    else
    {
        return false;
    }
#else
    return true;
 8014f8a:	2301      	movs	r3, #1
#endif // LORAMAC_CLASSB_ENABLED
}
 8014f8c:	0018      	movs	r0, r3
 8014f8e:	46bd      	mov	sp, r7
 8014f90:	b002      	add	sp, #8
 8014f92:	bd80      	pop	{r7, pc}

08014f94 <LoRaMacClassBGetNvmCtx>:

void* LoRaMacClassBGetNvmCtx( size_t* classBNvmCtxSize )
{
 8014f94:	b580      	push	{r7, lr}
 8014f96:	b082      	sub	sp, #8
 8014f98:	af00      	add	r7, sp, #0
 8014f9a:	6078      	str	r0, [r7, #4]
#ifdef LORAMAC_CLASSB_ENABLED
    *classBNvmCtxSize = sizeof( NvmCtx );
    return &NvmCtx;
#else
    *classBNvmCtxSize = 0;
 8014f9c:	687b      	ldr	r3, [r7, #4]
 8014f9e:	2200      	movs	r2, #0
 8014fa0:	601a      	str	r2, [r3, #0]
    return NULL;
 8014fa2:	2300      	movs	r3, #0
#endif // LORAMAC_CLASSB_ENABLED
}
 8014fa4:	0018      	movs	r0, r3
 8014fa6:	46bd      	mov	sp, r7
 8014fa8:	b002      	add	sp, #8
 8014faa:	bd80      	pop	{r7, pc}

08014fac <LoRaMacClassBSetBeaconState>:

void LoRaMacClassBSetBeaconState( BeaconState_t beaconState )
{
 8014fac:	b580      	push	{r7, lr}
 8014fae:	b082      	sub	sp, #8
 8014fb0:	af00      	add	r7, sp, #0
 8014fb2:	0002      	movs	r2, r0
 8014fb4:	1dfb      	adds	r3, r7, #7
 8014fb6:	701a      	strb	r2, [r3, #0]
        {
            Ctx.BeaconState = beaconState;
        }
    }
#endif // LORAMAC_CLASSB_ENABLED
}
 8014fb8:	46c0      	nop			; (mov r8, r8)
 8014fba:	46bd      	mov	sp, r7
 8014fbc:	b002      	add	sp, #8
 8014fbe:	bd80      	pop	{r7, pc}

08014fc0 <LoRaMacClassBSetPingSlotState>:

void LoRaMacClassBSetPingSlotState( PingSlotState_t pingSlotState )
{
 8014fc0:	b580      	push	{r7, lr}
 8014fc2:	b082      	sub	sp, #8
 8014fc4:	af00      	add	r7, sp, #0
 8014fc6:	0002      	movs	r2, r0
 8014fc8:	1dfb      	adds	r3, r7, #7
 8014fca:	701a      	strb	r2, [r3, #0]
#ifdef LORAMAC_CLASSB_ENABLED
    Ctx.PingSlotState = pingSlotState;
#endif // LORAMAC_CLASSB_ENABLED
}
 8014fcc:	46c0      	nop			; (mov r8, r8)
 8014fce:	46bd      	mov	sp, r7
 8014fd0:	b002      	add	sp, #8
 8014fd2:	bd80      	pop	{r7, pc}

08014fd4 <LoRaMacClassBSetMulticastSlotState>:

void LoRaMacClassBSetMulticastSlotState( PingSlotState_t multicastSlotState )
{
 8014fd4:	b580      	push	{r7, lr}
 8014fd6:	b082      	sub	sp, #8
 8014fd8:	af00      	add	r7, sp, #0
 8014fda:	0002      	movs	r2, r0
 8014fdc:	1dfb      	adds	r3, r7, #7
 8014fde:	701a      	strb	r2, [r3, #0]
#ifdef LORAMAC_CLASSB_ENABLED
    Ctx.MulticastSlotState = multicastSlotState;
#endif // LORAMAC_CLASSB_ENABLED
}
 8014fe0:	46c0      	nop			; (mov r8, r8)
 8014fe2:	46bd      	mov	sp, r7
 8014fe4:	b002      	add	sp, #8
 8014fe6:	bd80      	pop	{r7, pc}

08014fe8 <LoRaMacClassBIsAcquisitionInProgress>:

bool LoRaMacClassBIsAcquisitionInProgress( void )
{
 8014fe8:	b580      	push	{r7, lr}
 8014fea:	af00      	add	r7, sp, #0
        // searches for a beacon.
        return true;
    }
    return false;
#else
    return false;
 8014fec:	2300      	movs	r3, #0
#endif // LORAMAC_CLASSB_ENABLED
}
 8014fee:	0018      	movs	r0, r3
 8014ff0:	46bd      	mov	sp, r7
 8014ff2:	bd80      	pop	{r7, pc}

08014ff4 <LoRaMacClassBBeaconTimerEvent>:

void LoRaMacClassBBeaconTimerEvent( void* context )
{
 8014ff4:	b580      	push	{r7, lr}
 8014ff6:	b082      	sub	sp, #8
 8014ff8:	af00      	add	r7, sp, #0
 8014ffa:	6078      	str	r0, [r7, #4]
    if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
    {
        Ctx.LoRaMacClassBCallbacks.MacProcessNotify( );
    }
#endif // LORAMAC_CLASSB_ENABLED
}
 8014ffc:	46c0      	nop			; (mov r8, r8)
 8014ffe:	46bd      	mov	sp, r7
 8015000:	b002      	add	sp, #8
 8015002:	bd80      	pop	{r7, pc}

08015004 <LoRaMacClassBPingSlotTimerEvent>:
    }
}
#endif // LORAMAC_CLASSB_ENABLED

void LoRaMacClassBPingSlotTimerEvent( void* context )
{
 8015004:	b580      	push	{r7, lr}
 8015006:	b082      	sub	sp, #8
 8015008:	af00      	add	r7, sp, #0
 801500a:	6078      	str	r0, [r7, #4]
    if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
    {
        Ctx.LoRaMacClassBCallbacks.MacProcessNotify( );
    }
#endif // LORAMAC_CLASSB_ENABLED
}
 801500c:	46c0      	nop			; (mov r8, r8)
 801500e:	46bd      	mov	sp, r7
 8015010:	b002      	add	sp, #8
 8015012:	bd80      	pop	{r7, pc}

08015014 <LoRaMacClassBMulticastSlotTimerEvent>:
    }
}
#endif // LORAMAC_CLASSB_ENABLED

void LoRaMacClassBMulticastSlotTimerEvent( void* context )
{
 8015014:	b580      	push	{r7, lr}
 8015016:	b082      	sub	sp, #8
 8015018:	af00      	add	r7, sp, #0
 801501a:	6078      	str	r0, [r7, #4]
    if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
    {
        Ctx.LoRaMacClassBCallbacks.MacProcessNotify( );
    }
#endif // LORAMAC_CLASSB_ENABLED
}
 801501c:	46c0      	nop			; (mov r8, r8)
 801501e:	46bd      	mov	sp, r7
 8015020:	b002      	add	sp, #8
 8015022:	bd80      	pop	{r7, pc}

08015024 <LoRaMacClassBRxBeacon>:
    }
}
#endif // LORAMAC_CLASSB_ENABLED

bool LoRaMacClassBRxBeacon( uint8_t *payload, uint16_t size )
{
 8015024:	b580      	push	{r7, lr}
 8015026:	b082      	sub	sp, #8
 8015028:	af00      	add	r7, sp, #0
 801502a:	6078      	str	r0, [r7, #4]
 801502c:	000a      	movs	r2, r1
 801502e:	1cbb      	adds	r3, r7, #2
 8015030:	801a      	strh	r2, [r3, #0]
        // valid beacon has been received.
        beaconProcessed = true;
    }
    return beaconProcessed;
#else
    return false;
 8015032:	2300      	movs	r3, #0
#endif // LORAMAC_CLASSB_ENABLED
}
 8015034:	0018      	movs	r0, r3
 8015036:	46bd      	mov	sp, r7
 8015038:	b002      	add	sp, #8
 801503a:	bd80      	pop	{r7, pc}

0801503c <LoRaMacClassBIsBeaconExpected>:

bool LoRaMacClassBIsBeaconExpected( void )
{
 801503c:	b580      	push	{r7, lr}
 801503e:	af00      	add	r7, sp, #0
    {
        return true;
    }
    return false;
#else
    return false;
 8015040:	2300      	movs	r3, #0
#endif // LORAMAC_CLASSB_ENABLED
}
 8015042:	0018      	movs	r0, r3
 8015044:	46bd      	mov	sp, r7
 8015046:	bd80      	pop	{r7, pc}

08015048 <LoRaMacClassBIsPingExpected>:

bool LoRaMacClassBIsPingExpected( void )
{
 8015048:	b580      	push	{r7, lr}
 801504a:	af00      	add	r7, sp, #0
    {
        return true;
    }
    return false;
#else
    return false;
 801504c:	2300      	movs	r3, #0
#endif // LORAMAC_CLASSB_ENABLED
}
 801504e:	0018      	movs	r0, r3
 8015050:	46bd      	mov	sp, r7
 8015052:	bd80      	pop	{r7, pc}

08015054 <LoRaMacClassBIsMulticastExpected>:

bool LoRaMacClassBIsMulticastExpected( void )
{
 8015054:	b580      	push	{r7, lr}
 8015056:	af00      	add	r7, sp, #0
    {
        return true;
    }
    return false;
#else
    return false;
 8015058:	2300      	movs	r3, #0
#endif // LORAMAC_CLASSB_ENABLED
}
 801505a:	0018      	movs	r0, r3
 801505c:	46bd      	mov	sp, r7
 801505e:	bd80      	pop	{r7, pc}

08015060 <LoRaMacClassBIsBeaconModeActive>:
    return false;
#endif // LORAMAC_CLASSB_ENABLED
}

bool LoRaMacClassBIsBeaconModeActive( void )
{
 8015060:	b580      	push	{r7, lr}
 8015062:	af00      	add	r7, sp, #0
    {
        return true;
    }
    return false;
#else
    return false;
 8015064:	2300      	movs	r3, #0
#endif // LORAMAC_CLASSB_ENABLED
}
 8015066:	0018      	movs	r0, r3
 8015068:	46bd      	mov	sp, r7
 801506a:	bd80      	pop	{r7, pc}

0801506c <LoRaMacClassBSetPingSlotInfo>:

void LoRaMacClassBSetPingSlotInfo( uint8_t periodicity )
{
 801506c:	b580      	push	{r7, lr}
 801506e:	b082      	sub	sp, #8
 8015070:	af00      	add	r7, sp, #0
 8015072:	0002      	movs	r2, r0
 8015074:	1dfb      	adds	r3, r7, #7
 8015076:	701a      	strb	r2, [r3, #0]
#ifdef LORAMAC_CLASSB_ENABLED
    Ctx.NvmCtx->PingSlotCtx.PingNb = CalcPingNb( periodicity );
    Ctx.NvmCtx->PingSlotCtx.PingPeriod = CalcPingPeriod( Ctx.NvmCtx->PingSlotCtx.PingNb );
    NvmContextChange( );
#endif // LORAMAC_CLASSB_ENABLED
}
 8015078:	46c0      	nop			; (mov r8, r8)
 801507a:	46bd      	mov	sp, r7
 801507c:	b002      	add	sp, #8
 801507e:	bd80      	pop	{r7, pc}

08015080 <LoRaMacClassBHaltBeaconing>:

void LoRaMacClassBHaltBeaconing( void )
{
 8015080:	b580      	push	{r7, lr}
 8015082:	af00      	add	r7, sp, #0

        // Halt ping and multicast slot state machines
        LoRaMacClassBStopRxSlots( );
    }
#endif // LORAMAC_CLASSB_ENABLED
}
 8015084:	46c0      	nop			; (mov r8, r8)
 8015086:	46bd      	mov	sp, r7
 8015088:	bd80      	pop	{r7, pc}

0801508a <LoRaMacClassBResumeBeaconing>:

void LoRaMacClassBResumeBeaconing( void )
{
 801508a:	b580      	push	{r7, lr}
 801508c:	af00      	add	r7, sp, #0
        }

        LoRaMacClassBBeaconTimerEvent( NULL );
    }
#endif // LORAMAC_CLASSB_ENABLED
}
 801508e:	46c0      	nop			; (mov r8, r8)
 8015090:	46bd      	mov	sp, r7
 8015092:	bd80      	pop	{r7, pc}

08015094 <LoRaMacClassBSwitchClass>:

LoRaMacStatus_t LoRaMacClassBSwitchClass( DeviceClass_t nextClass )
{
 8015094:	b580      	push	{r7, lr}
 8015096:	b082      	sub	sp, #8
 8015098:	af00      	add	r7, sp, #0
 801509a:	0002      	movs	r2, r0
 801509c:	1dfb      	adds	r3, r7, #7
 801509e:	701a      	strb	r2, [r3, #0]

        return LORAMAC_STATUS_OK;
    }
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
 80150a0:	2302      	movs	r3, #2
#endif // LORAMAC_CLASSB_ENABLED
}
 80150a2:	0018      	movs	r0, r3
 80150a4:	46bd      	mov	sp, r7
 80150a6:	b002      	add	sp, #8
 80150a8:	bd80      	pop	{r7, pc}

080150aa <LoRaMacClassBMibGetRequestConfirm>:

LoRaMacStatus_t LoRaMacClassBMibGetRequestConfirm( MibRequestConfirm_t *mibGet )
{
 80150aa:	b580      	push	{r7, lr}
 80150ac:	b082      	sub	sp, #8
 80150ae:	af00      	add	r7, sp, #0
 80150b0:	6078      	str	r0, [r7, #4]
            break;
        }
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
 80150b2:	2302      	movs	r3, #2
#endif // LORAMAC_CLASSB_ENABLED
}
 80150b4:	0018      	movs	r0, r3
 80150b6:	46bd      	mov	sp, r7
 80150b8:	b002      	add	sp, #8
 80150ba:	bd80      	pop	{r7, pc}

080150bc <LoRaMacMibClassBSetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibClassBSetRequestConfirm( MibRequestConfirm_t *mibSet )
{
 80150bc:	b580      	push	{r7, lr}
 80150be:	b082      	sub	sp, #8
 80150c0:	af00      	add	r7, sp, #0
 80150c2:	6078      	str	r0, [r7, #4]
            break;
        }
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
 80150c4:	2302      	movs	r3, #2
#endif // LORAMAC_CLASSB_ENABLED
}
 80150c6:	0018      	movs	r0, r3
 80150c8:	46bd      	mov	sp, r7
 80150ca:	b002      	add	sp, #8
 80150cc:	bd80      	pop	{r7, pc}

080150ce <LoRaMacClassBPingSlotInfoAns>:

void LoRaMacClassBPingSlotInfoAns( void )
{
 80150ce:	b580      	push	{r7, lr}
 80150d0:	af00      	add	r7, sp, #0
        LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );
        Ctx.NvmCtx->PingSlotCtx.Ctrl.Assigned = 1;
        NvmContextChange( );
    }
#endif // LORAMAC_CLASSB_ENABLED
}
 80150d2:	46c0      	nop			; (mov r8, r8)
 80150d4:	46bd      	mov	sp, r7
 80150d6:	bd80      	pop	{r7, pc}

080150d8 <LoRaMacClassBPingSlotChannelReq>:

uint8_t LoRaMacClassBPingSlotChannelReq( uint8_t datarate, uint32_t frequency )
{
 80150d8:	b580      	push	{r7, lr}
 80150da:	b082      	sub	sp, #8
 80150dc:	af00      	add	r7, sp, #0
 80150de:	0002      	movs	r2, r0
 80150e0:	6039      	str	r1, [r7, #0]
 80150e2:	1dfb      	adds	r3, r7, #7
 80150e4:	701a      	strb	r2, [r3, #0]
        NvmContextChange( );
    }

    return status;
#else
    return 0;
 80150e6:	2300      	movs	r3, #0
#endif // LORAMAC_CLASSB_ENABLED
}
 80150e8:	0018      	movs	r0, r3
 80150ea:	46bd      	mov	sp, r7
 80150ec:	b002      	add	sp, #8
 80150ee:	bd80      	pop	{r7, pc}

080150f0 <LoRaMacClassBBeaconTimingAns>:

void LoRaMacClassBBeaconTimingAns( uint16_t beaconTimingDelay, uint8_t beaconTimingChannel, TimerTime_t lastRxDone )
{
 80150f0:	b580      	push	{r7, lr}
 80150f2:	b082      	sub	sp, #8
 80150f4:	af00      	add	r7, sp, #0
 80150f6:	603a      	str	r2, [r7, #0]
 80150f8:	1dbb      	adds	r3, r7, #6
 80150fa:	1c02      	adds	r2, r0, #0
 80150fc:	801a      	strh	r2, [r3, #0]
 80150fe:	1d7b      	adds	r3, r7, #5
 8015100:	1c0a      	adds	r2, r1, #0
 8015102:	701a      	strb	r2, [r3, #0]

        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingDelay = Ctx.BeaconCtx.BeaconTimingDelay;
        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingChannel = Ctx.BeaconCtx.BeaconTimingChannel;
    }
#endif // LORAMAC_CLASSB_ENABLED
}
 8015104:	46c0      	nop			; (mov r8, r8)
 8015106:	46bd      	mov	sp, r7
 8015108:	b002      	add	sp, #8
 801510a:	bd80      	pop	{r7, pc}

0801510c <LoRaMacClassBDeviceTimeAns>:

void LoRaMacClassBDeviceTimeAns( void )
{
 801510c:	b580      	push	{r7, lr}
 801510e:	af00      	add	r7, sp, #0
            Ctx.BeaconCtx.BeaconTime.SubSeconds = 0;
            LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );
        }
    }
#endif // LORAMAC_CLASSB_ENABLED
}
 8015110:	46c0      	nop			; (mov r8, r8)
 8015112:	46bd      	mov	sp, r7
 8015114:	bd80      	pop	{r7, pc}

08015116 <LoRaMacClassBBeaconFreqReq>:

bool LoRaMacClassBBeaconFreqReq( uint32_t frequency )
{
 8015116:	b580      	push	{r7, lr}
 8015118:	b082      	sub	sp, #8
 801511a:	af00      	add	r7, sp, #0
 801511c:	6078      	str	r0, [r7, #4]
        NvmContextChange( );
        return true;
    }
    return false;
#else
    return false;
 801511e:	2300      	movs	r3, #0
#endif // LORAMAC_CLASSB_ENABLED
}
 8015120:	0018      	movs	r0, r3
 8015122:	46bd      	mov	sp, r7
 8015124:	b002      	add	sp, #8
 8015126:	bd80      	pop	{r7, pc}

08015128 <LoRaMacClassBIsUplinkCollision>:

TimerTime_t LoRaMacClassBIsUplinkCollision( TimerTime_t txTimeOnAir )
{
 8015128:	b580      	push	{r7, lr}
 801512a:	b082      	sub	sp, #8
 801512c:	af00      	add	r7, sp, #0
 801512e:	6078      	str	r0, [r7, #4]
    {// Next beacon will be sent during the next uplink.
        return CLASSB_BEACON_RESERVED;
    }
    return 0;
#else
    return 0;
 8015130:	2300      	movs	r3, #0
#endif // LORAMAC_CLASSB_ENABLED
}
 8015132:	0018      	movs	r0, r3
 8015134:	46bd      	mov	sp, r7
 8015136:	b002      	add	sp, #8
 8015138:	bd80      	pop	{r7, pc}

0801513a <LoRaMacClassBStopRxSlots>:

void LoRaMacClassBStopRxSlots( void )
{
 801513a:	b580      	push	{r7, lr}
 801513c:	af00      	add	r7, sp, #0
    CRITICAL_SECTION_BEGIN( );
    LoRaMacClassBEvents.Events.PingSlot = 0;
    LoRaMacClassBEvents.Events.MulticastSlot = 0;
    CRITICAL_SECTION_END( );
#endif // LORAMAC_CLASSB_ENABLED
}
 801513e:	46c0      	nop			; (mov r8, r8)
 8015140:	46bd      	mov	sp, r7
 8015142:	bd80      	pop	{r7, pc}

08015144 <LoRaMacClassBProcess>:
    }
#endif // LORAMAC_CLASSB_ENABLED
}

void LoRaMacClassBProcess( void )
{
 8015144:	b580      	push	{r7, lr}
 8015146:	af00      	add	r7, sp, #0
        {
            LoRaMacClassBProcessMulticastSlot( );
        }
    }
#endif // LORAMAC_CLASSB_ENABLED
}
 8015148:	46c0      	nop			; (mov r8, r8)
 801514a:	46bd      	mov	sp, r7
 801514c:	bd80      	pop	{r7, pc}

0801514e <IsSlotFree>:
 *
 * \param[IN]     slot           - Slot to check
 * \retval                       - Status of the operation
 */
static bool IsSlotFree( const MacCommand_t* slot )
{
 801514e:	b580      	push	{r7, lr}
 8015150:	b084      	sub	sp, #16
 8015152:	af00      	add	r7, sp, #0
 8015154:	6078      	str	r0, [r7, #4]
    uint8_t* mem = ( uint8_t* )slot;
 8015156:	687b      	ldr	r3, [r7, #4]
 8015158:	60bb      	str	r3, [r7, #8]

    for( uint16_t size = 0; size < sizeof( MacCommand_t ); size++ )
 801515a:	230e      	movs	r3, #14
 801515c:	18fb      	adds	r3, r7, r3
 801515e:	2200      	movs	r2, #0
 8015160:	801a      	strh	r2, [r3, #0]
 8015162:	e00f      	b.n	8015184 <IsSlotFree+0x36>
    {
        if( mem[size] != 0x00 )
 8015164:	230e      	movs	r3, #14
 8015166:	18fb      	adds	r3, r7, r3
 8015168:	881b      	ldrh	r3, [r3, #0]
 801516a:	68ba      	ldr	r2, [r7, #8]
 801516c:	18d3      	adds	r3, r2, r3
 801516e:	781b      	ldrb	r3, [r3, #0]
 8015170:	2b00      	cmp	r3, #0
 8015172:	d001      	beq.n	8015178 <IsSlotFree+0x2a>
        {
            return false;
 8015174:	2300      	movs	r3, #0
 8015176:	e00b      	b.n	8015190 <IsSlotFree+0x42>
    for( uint16_t size = 0; size < sizeof( MacCommand_t ); size++ )
 8015178:	210e      	movs	r1, #14
 801517a:	187b      	adds	r3, r7, r1
 801517c:	881a      	ldrh	r2, [r3, #0]
 801517e:	187b      	adds	r3, r7, r1
 8015180:	3201      	adds	r2, #1
 8015182:	801a      	strh	r2, [r3, #0]
 8015184:	230e      	movs	r3, #14
 8015186:	18fb      	adds	r3, r7, r3
 8015188:	881b      	ldrh	r3, [r3, #0]
 801518a:	2b0f      	cmp	r3, #15
 801518c:	d9ea      	bls.n	8015164 <IsSlotFree+0x16>
        }
    }
    return true;
 801518e:	2301      	movs	r3, #1
}
 8015190:	0018      	movs	r0, r3
 8015192:	46bd      	mov	sp, r7
 8015194:	b004      	add	sp, #16
 8015196:	bd80      	pop	{r7, pc}

08015198 <MallocNewMacCommandSlot>:
 * \brief Allocates a new MAC command memory slot
 *
 * \retval                       - Pointer to slot
 */
static MacCommand_t* MallocNewMacCommandSlot( void )
{
 8015198:	b580      	push	{r7, lr}
 801519a:	b082      	sub	sp, #8
 801519c:	af00      	add	r7, sp, #0
    uint8_t itr = 0;
 801519e:	1dfb      	adds	r3, r7, #7
 80151a0:	2200      	movs	r2, #0
 80151a2:	701a      	strb	r2, [r3, #0]

    while( IsSlotFree( ( const MacCommand_t* )&NvmCtx.MacCommandSlots[itr] ) == false )
 80151a4:	e00a      	b.n	80151bc <MallocNewMacCommandSlot+0x24>
    {
        itr++;
 80151a6:	1dfb      	adds	r3, r7, #7
 80151a8:	781a      	ldrb	r2, [r3, #0]
 80151aa:	1dfb      	adds	r3, r7, #7
 80151ac:	3201      	adds	r2, #1
 80151ae:	701a      	strb	r2, [r3, #0]
        if( itr == NUM_OF_MAC_COMMANDS )
 80151b0:	1dfb      	adds	r3, r7, #7
 80151b2:	781b      	ldrb	r3, [r3, #0]
 80151b4:	2b0f      	cmp	r3, #15
 80151b6:	d101      	bne.n	80151bc <MallocNewMacCommandSlot+0x24>
        {
            return 0;
 80151b8:	2300      	movs	r3, #0
 80151ba:	e017      	b.n	80151ec <MallocNewMacCommandSlot+0x54>
    while( IsSlotFree( ( const MacCommand_t* )&NvmCtx.MacCommandSlots[itr] ) == false )
 80151bc:	1dfb      	adds	r3, r7, #7
 80151be:	781b      	ldrb	r3, [r3, #0]
 80151c0:	011b      	lsls	r3, r3, #4
 80151c2:	3308      	adds	r3, #8
 80151c4:	001a      	movs	r2, r3
 80151c6:	4b0b      	ldr	r3, [pc, #44]	; (80151f4 <MallocNewMacCommandSlot+0x5c>)
 80151c8:	18d3      	adds	r3, r2, r3
 80151ca:	0018      	movs	r0, r3
 80151cc:	f7ff ffbf 	bl	801514e <IsSlotFree>
 80151d0:	0003      	movs	r3, r0
 80151d2:	001a      	movs	r2, r3
 80151d4:	2301      	movs	r3, #1
 80151d6:	4053      	eors	r3, r2
 80151d8:	b2db      	uxtb	r3, r3
 80151da:	2b00      	cmp	r3, #0
 80151dc:	d1e3      	bne.n	80151a6 <MallocNewMacCommandSlot+0xe>
        }
    }

    return &NvmCtx.MacCommandSlots[itr];
 80151de:	1dfb      	adds	r3, r7, #7
 80151e0:	781b      	ldrb	r3, [r3, #0]
 80151e2:	011b      	lsls	r3, r3, #4
 80151e4:	3308      	adds	r3, #8
 80151e6:	001a      	movs	r2, r3
 80151e8:	4b02      	ldr	r3, [pc, #8]	; (80151f4 <MallocNewMacCommandSlot+0x5c>)
 80151ea:	18d3      	adds	r3, r2, r3
}
 80151ec:	0018      	movs	r0, r3
 80151ee:	46bd      	mov	sp, r7
 80151f0:	b002      	add	sp, #8
 80151f2:	bd80      	pop	{r7, pc}
 80151f4:	20000f58 	.word	0x20000f58

080151f8 <FreeMacCommandSlot>:
 * \param[IN]     slot           - Slot to free
 *
 * \retval                       - Status of the operation
 */
static bool FreeMacCommandSlot( MacCommand_t* slot )
{
 80151f8:	b580      	push	{r7, lr}
 80151fa:	b082      	sub	sp, #8
 80151fc:	af00      	add	r7, sp, #0
 80151fe:	6078      	str	r0, [r7, #4]
    if( slot == 0 )
 8015200:	687b      	ldr	r3, [r7, #4]
 8015202:	2b00      	cmp	r3, #0
 8015204:	d101      	bne.n	801520a <FreeMacCommandSlot+0x12>
    {
        return false;
 8015206:	2300      	movs	r3, #0
 8015208:	e006      	b.n	8015218 <FreeMacCommandSlot+0x20>
    }

    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 801520a:	687b      	ldr	r3, [r7, #4]
 801520c:	2210      	movs	r2, #16
 801520e:	2100      	movs	r1, #0
 8015210:	0018      	movs	r0, r3
 8015212:	f006 f9d7 	bl	801b5c4 <memset1>

    return true;
 8015216:	2301      	movs	r3, #1
}
 8015218:	0018      	movs	r0, r3
 801521a:	46bd      	mov	sp, r7
 801521c:	b002      	add	sp, #8
 801521e:	bd80      	pop	{r7, pc}

08015220 <LinkedListInit>:
 *
 * \param[IN]     list           - List that shall be initialized
 * \retval                       - Status of the operation
 */
static bool LinkedListInit( MacCommandsList_t* list )
{
 8015220:	b580      	push	{r7, lr}
 8015222:	b082      	sub	sp, #8
 8015224:	af00      	add	r7, sp, #0
 8015226:	6078      	str	r0, [r7, #4]
    if( list == 0 )
 8015228:	687b      	ldr	r3, [r7, #4]
 801522a:	2b00      	cmp	r3, #0
 801522c:	d101      	bne.n	8015232 <LinkedListInit+0x12>
    {
        return false;
 801522e:	2300      	movs	r3, #0
 8015230:	e006      	b.n	8015240 <LinkedListInit+0x20>
    }

    list->First = 0;
 8015232:	687b      	ldr	r3, [r7, #4]
 8015234:	2200      	movs	r2, #0
 8015236:	601a      	str	r2, [r3, #0]
    list->Last = 0;
 8015238:	687b      	ldr	r3, [r7, #4]
 801523a:	2200      	movs	r2, #0
 801523c:	605a      	str	r2, [r3, #4]

    return true;
 801523e:	2301      	movs	r3, #1
}
 8015240:	0018      	movs	r0, r3
 8015242:	46bd      	mov	sp, r7
 8015244:	b002      	add	sp, #8
 8015246:	bd80      	pop	{r7, pc}

08015248 <LinkedListAdd>:
 * \param[IN]     list           - List where the element shall be added.
 * \param[IN]     element        - Element to add
 * \retval                       - Status of the operation
 */
static bool LinkedListAdd( MacCommandsList_t* list, MacCommand_t* element )
{
 8015248:	b580      	push	{r7, lr}
 801524a:	b082      	sub	sp, #8
 801524c:	af00      	add	r7, sp, #0
 801524e:	6078      	str	r0, [r7, #4]
 8015250:	6039      	str	r1, [r7, #0]
    if( ( list == 0 ) && ( element == 0 ) )
 8015252:	687b      	ldr	r3, [r7, #4]
 8015254:	2b00      	cmp	r3, #0
 8015256:	d104      	bne.n	8015262 <LinkedListAdd+0x1a>
 8015258:	683b      	ldr	r3, [r7, #0]
 801525a:	2b00      	cmp	r3, #0
 801525c:	d101      	bne.n	8015262 <LinkedListAdd+0x1a>
    {
        return false;
 801525e:	2300      	movs	r3, #0
 8015260:	e015      	b.n	801528e <LinkedListAdd+0x46>
    }

    // Check if this is the first entry to enter the list.
    if( list->First == 0 )
 8015262:	687b      	ldr	r3, [r7, #4]
 8015264:	681b      	ldr	r3, [r3, #0]
 8015266:	2b00      	cmp	r3, #0
 8015268:	d102      	bne.n	8015270 <LinkedListAdd+0x28>
    {
        list->First = element;
 801526a:	687b      	ldr	r3, [r7, #4]
 801526c:	683a      	ldr	r2, [r7, #0]
 801526e:	601a      	str	r2, [r3, #0]
    }

    // Check if the last entry exists and update its next point.
    if( list->Last )
 8015270:	687b      	ldr	r3, [r7, #4]
 8015272:	685b      	ldr	r3, [r3, #4]
 8015274:	2b00      	cmp	r3, #0
 8015276:	d003      	beq.n	8015280 <LinkedListAdd+0x38>
    {
        list->Last->Next = element;
 8015278:	687b      	ldr	r3, [r7, #4]
 801527a:	685b      	ldr	r3, [r3, #4]
 801527c:	683a      	ldr	r2, [r7, #0]
 801527e:	601a      	str	r2, [r3, #0]
    }

    // Update the next point of this entry.
    element->Next = 0;
 8015280:	683b      	ldr	r3, [r7, #0]
 8015282:	2200      	movs	r2, #0
 8015284:	601a      	str	r2, [r3, #0]

    // Update the last entry of the list.
    list->Last = element;
 8015286:	687b      	ldr	r3, [r7, #4]
 8015288:	683a      	ldr	r2, [r7, #0]
 801528a:	605a      	str	r2, [r3, #4]

    return true;
 801528c:	2301      	movs	r3, #1
}
 801528e:	0018      	movs	r0, r3
 8015290:	46bd      	mov	sp, r7
 8015292:	b002      	add	sp, #8
 8015294:	bd80      	pop	{r7, pc}

08015296 <LinkedListGetPrevious>:
 * \param[IN]     list           - List
 * \param[IN]     element        - Element where the previous element shall be searched
 * \retval                       - Status of the operation
 */
static MacCommand_t* LinkedListGetPrevious( MacCommandsList_t* list, MacCommand_t* element )
{
 8015296:	b580      	push	{r7, lr}
 8015298:	b084      	sub	sp, #16
 801529a:	af00      	add	r7, sp, #0
 801529c:	6078      	str	r0, [r7, #4]
 801529e:	6039      	str	r1, [r7, #0]
    if( ( list == 0 ) && ( element == 0 ) )
 80152a0:	687b      	ldr	r3, [r7, #4]
 80152a2:	2b00      	cmp	r3, #0
 80152a4:	d104      	bne.n	80152b0 <LinkedListGetPrevious+0x1a>
 80152a6:	683b      	ldr	r3, [r7, #0]
 80152a8:	2b00      	cmp	r3, #0
 80152aa:	d101      	bne.n	80152b0 <LinkedListGetPrevious+0x1a>
    {
        return NULL;
 80152ac:	2300      	movs	r3, #0
 80152ae:	e016      	b.n	80152de <LinkedListGetPrevious+0x48>
    }

    MacCommand_t* curElement;

    // Start at the head of the list
    curElement = list->First;
 80152b0:	687b      	ldr	r3, [r7, #4]
 80152b2:	681b      	ldr	r3, [r3, #0]
 80152b4:	60fb      	str	r3, [r7, #12]

    // When current element is the first of the list, there's no previous element so we can return NULL immediately.
    if( element != curElement )
 80152b6:	683a      	ldr	r2, [r7, #0]
 80152b8:	68fb      	ldr	r3, [r7, #12]
 80152ba:	429a      	cmp	r2, r3
 80152bc:	d00c      	beq.n	80152d8 <LinkedListGetPrevious+0x42>
    {
        // Loop through all elements until the end is reached or the next of current is the current element.
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 80152be:	e002      	b.n	80152c6 <LinkedListGetPrevious+0x30>
        {
            curElement = curElement->Next;
 80152c0:	68fb      	ldr	r3, [r7, #12]
 80152c2:	681b      	ldr	r3, [r3, #0]
 80152c4:	60fb      	str	r3, [r7, #12]
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 80152c6:	68fb      	ldr	r3, [r7, #12]
 80152c8:	2b00      	cmp	r3, #0
 80152ca:	d007      	beq.n	80152dc <LinkedListGetPrevious+0x46>
 80152cc:	68fb      	ldr	r3, [r7, #12]
 80152ce:	681b      	ldr	r3, [r3, #0]
 80152d0:	683a      	ldr	r2, [r7, #0]
 80152d2:	429a      	cmp	r2, r3
 80152d4:	d1f4      	bne.n	80152c0 <LinkedListGetPrevious+0x2a>
 80152d6:	e001      	b.n	80152dc <LinkedListGetPrevious+0x46>
        }
    }
    else
    {
        curElement = NULL;
 80152d8:	2300      	movs	r3, #0
 80152da:	60fb      	str	r3, [r7, #12]
    }

    return curElement;
 80152dc:	68fb      	ldr	r3, [r7, #12]
}
 80152de:	0018      	movs	r0, r3
 80152e0:	46bd      	mov	sp, r7
 80152e2:	b004      	add	sp, #16
 80152e4:	bd80      	pop	{r7, pc}

080152e6 <LinkedListRemove>:
 * \param[IN]     list           - List where the element shall be removed from.
 * \param[IN]     element        - Element to remove
 * \retval                       - Status of the operation
 */
static bool LinkedListRemove( MacCommandsList_t* list, MacCommand_t* element )
{
 80152e6:	b580      	push	{r7, lr}
 80152e8:	b084      	sub	sp, #16
 80152ea:	af00      	add	r7, sp, #0
 80152ec:	6078      	str	r0, [r7, #4]
 80152ee:	6039      	str	r1, [r7, #0]
    if( ( list == 0 ) && ( element == 0 ) )
 80152f0:	687b      	ldr	r3, [r7, #4]
 80152f2:	2b00      	cmp	r3, #0
 80152f4:	d104      	bne.n	8015300 <LinkedListRemove+0x1a>
 80152f6:	683b      	ldr	r3, [r7, #0]
 80152f8:	2b00      	cmp	r3, #0
 80152fa:	d101      	bne.n	8015300 <LinkedListRemove+0x1a>
    {
        return false;
 80152fc:	2300      	movs	r3, #0
 80152fe:	e023      	b.n	8015348 <LinkedListRemove+0x62>
    }

    MacCommand_t* PrevElement = LinkedListGetPrevious( list, element );
 8015300:	683a      	ldr	r2, [r7, #0]
 8015302:	687b      	ldr	r3, [r7, #4]
 8015304:	0011      	movs	r1, r2
 8015306:	0018      	movs	r0, r3
 8015308:	f7ff ffc5 	bl	8015296 <LinkedListGetPrevious>
 801530c:	0003      	movs	r3, r0
 801530e:	60fb      	str	r3, [r7, #12]

    if( list->First == element )
 8015310:	687b      	ldr	r3, [r7, #4]
 8015312:	681b      	ldr	r3, [r3, #0]
 8015314:	683a      	ldr	r2, [r7, #0]
 8015316:	429a      	cmp	r2, r3
 8015318:	d103      	bne.n	8015322 <LinkedListRemove+0x3c>
    {
        list->First = element->Next;
 801531a:	683b      	ldr	r3, [r7, #0]
 801531c:	681a      	ldr	r2, [r3, #0]
 801531e:	687b      	ldr	r3, [r7, #4]
 8015320:	601a      	str	r2, [r3, #0]
    }

    if( list->Last == element )
 8015322:	687b      	ldr	r3, [r7, #4]
 8015324:	685b      	ldr	r3, [r3, #4]
 8015326:	683a      	ldr	r2, [r7, #0]
 8015328:	429a      	cmp	r2, r3
 801532a:	d102      	bne.n	8015332 <LinkedListRemove+0x4c>
    {
        list->Last = PrevElement;
 801532c:	687b      	ldr	r3, [r7, #4]
 801532e:	68fa      	ldr	r2, [r7, #12]
 8015330:	605a      	str	r2, [r3, #4]
    }

    if( PrevElement != NULL )
 8015332:	68fb      	ldr	r3, [r7, #12]
 8015334:	2b00      	cmp	r3, #0
 8015336:	d003      	beq.n	8015340 <LinkedListRemove+0x5a>
    {
        PrevElement->Next = element->Next;
 8015338:	683b      	ldr	r3, [r7, #0]
 801533a:	681a      	ldr	r2, [r3, #0]
 801533c:	68fb      	ldr	r3, [r7, #12]
 801533e:	601a      	str	r2, [r3, #0]
    }

    element->Next = NULL;
 8015340:	683b      	ldr	r3, [r7, #0]
 8015342:	2200      	movs	r2, #0
 8015344:	601a      	str	r2, [r3, #0]

    return true;
 8015346:	2301      	movs	r3, #1
}
 8015348:	0018      	movs	r0, r3
 801534a:	46bd      	mov	sp, r7
 801534c:	b004      	add	sp, #16
 801534e:	bd80      	pop	{r7, pc}

08015350 <IsSticky>:
 * \param[IN]   cid                - MAC command identifier
 *
 * \retval                     - Status of the operation
 */
static bool IsSticky( uint8_t cid )
{
 8015350:	b580      	push	{r7, lr}
 8015352:	b082      	sub	sp, #8
 8015354:	af00      	add	r7, sp, #0
 8015356:	0002      	movs	r2, r0
 8015358:	1dfb      	adds	r3, r7, #7
 801535a:	701a      	strb	r2, [r3, #0]
    switch( cid )
 801535c:	1dfb      	adds	r3, r7, #7
 801535e:	781b      	ldrb	r3, [r3, #0]
 8015360:	220a      	movs	r2, #10
 8015362:	429a      	cmp	r2, r3
 8015364:	4192      	sbcs	r2, r2
 8015366:	4252      	negs	r2, r2
 8015368:	b2d2      	uxtb	r2, r2
 801536a:	2a00      	cmp	r2, #0
 801536c:	d10b      	bne.n	8015386 <IsSticky+0x36>
 801536e:	2201      	movs	r2, #1
 8015370:	409a      	lsls	r2, r3
 8015372:	23a4      	movs	r3, #164	; 0xa4
 8015374:	00db      	lsls	r3, r3, #3
 8015376:	4013      	ands	r3, r2
 8015378:	1e5a      	subs	r2, r3, #1
 801537a:	4193      	sbcs	r3, r2
 801537c:	b2db      	uxtb	r3, r3
 801537e:	2b00      	cmp	r3, #0
 8015380:	d001      	beq.n	8015386 <IsSticky+0x36>
    {
        case MOTE_MAC_DL_CHANNEL_ANS:
        case MOTE_MAC_RX_PARAM_SETUP_ANS:
        case MOTE_MAC_RX_TIMING_SETUP_ANS:
            return true;
 8015382:	2301      	movs	r3, #1
 8015384:	e000      	b.n	8015388 <IsSticky+0x38>
        default:
            return false;
 8015386:	2300      	movs	r3, #0
    }
}
 8015388:	0018      	movs	r0, r3
 801538a:	46bd      	mov	sp, r7
 801538c:	b002      	add	sp, #8
 801538e:	bd80      	pop	{r7, pc}

08015390 <NvmCtxCallback>:

/*
 * \brief Wrapper function for the NvmCtx
 */
static void NvmCtxCallback( void )
{
 8015390:	b580      	push	{r7, lr}
 8015392:	af00      	add	r7, sp, #0
    if( CommandsNvmCtxChanged != NULL )
 8015394:	4b04      	ldr	r3, [pc, #16]	; (80153a8 <NvmCtxCallback+0x18>)
 8015396:	681b      	ldr	r3, [r3, #0]
 8015398:	2b00      	cmp	r3, #0
 801539a:	d002      	beq.n	80153a2 <NvmCtxCallback+0x12>
    {
        CommandsNvmCtxChanged( );
 801539c:	4b02      	ldr	r3, [pc, #8]	; (80153a8 <NvmCtxCallback+0x18>)
 801539e:	681b      	ldr	r3, [r3, #0]
 80153a0:	4798      	blx	r3
    }
}
 80153a2:	46c0      	nop			; (mov r8, r8)
 80153a4:	46bd      	mov	sp, r7
 80153a6:	bd80      	pop	{r7, pc}
 80153a8:	20000f54 	.word	0x20000f54

080153ac <LoRaMacCommandsInit>:

LoRaMacCommandStatus_t LoRaMacCommandsInit( LoRaMacCommandsNvmEvent commandsNvmCtxChanged )
{
 80153ac:	b580      	push	{r7, lr}
 80153ae:	b082      	sub	sp, #8
 80153b0:	af00      	add	r7, sp, #0
 80153b2:	6078      	str	r0, [r7, #4]
    // Initialize with default
    memset1( ( uint8_t* )&NvmCtx, 0, sizeof( NvmCtx ) );
 80153b4:	4b08      	ldr	r3, [pc, #32]	; (80153d8 <LoRaMacCommandsInit+0x2c>)
 80153b6:	22fc      	movs	r2, #252	; 0xfc
 80153b8:	2100      	movs	r1, #0
 80153ba:	0018      	movs	r0, r3
 80153bc:	f006 f902 	bl	801b5c4 <memset1>

    LinkedListInit( &NvmCtx.MacCommandList );
 80153c0:	4b05      	ldr	r3, [pc, #20]	; (80153d8 <LoRaMacCommandsInit+0x2c>)
 80153c2:	0018      	movs	r0, r3
 80153c4:	f7ff ff2c 	bl	8015220 <LinkedListInit>

    // Assign callback
    CommandsNvmCtxChanged = commandsNvmCtxChanged;
 80153c8:	4b04      	ldr	r3, [pc, #16]	; (80153dc <LoRaMacCommandsInit+0x30>)
 80153ca:	687a      	ldr	r2, [r7, #4]
 80153cc:	601a      	str	r2, [r3, #0]

    return LORAMAC_COMMANDS_SUCCESS;
 80153ce:	2300      	movs	r3, #0
}
 80153d0:	0018      	movs	r0, r3
 80153d2:	46bd      	mov	sp, r7
 80153d4:	b002      	add	sp, #8
 80153d6:	bd80      	pop	{r7, pc}
 80153d8:	20000f58 	.word	0x20000f58
 80153dc:	20000f54 	.word	0x20000f54

080153e0 <LoRaMacCommandsRestoreNvmCtx>:

LoRaMacCommandStatus_t LoRaMacCommandsRestoreNvmCtx( void* commandsNvmCtx )
{
 80153e0:	b580      	push	{r7, lr}
 80153e2:	b082      	sub	sp, #8
 80153e4:	af00      	add	r7, sp, #0
 80153e6:	6078      	str	r0, [r7, #4]
    // Restore module context
    if( commandsNvmCtx != NULL )
 80153e8:	687b      	ldr	r3, [r7, #4]
 80153ea:	2b00      	cmp	r3, #0
 80153ec:	d007      	beq.n	80153fe <LoRaMacCommandsRestoreNvmCtx+0x1e>
    {
        memcpy1( ( uint8_t* )&NvmCtx, ( uint8_t* )commandsNvmCtx, sizeof( NvmCtx ) );
 80153ee:	6879      	ldr	r1, [r7, #4]
 80153f0:	4b05      	ldr	r3, [pc, #20]	; (8015408 <LoRaMacCommandsRestoreNvmCtx+0x28>)
 80153f2:	22fc      	movs	r2, #252	; 0xfc
 80153f4:	0018      	movs	r0, r3
 80153f6:	f006 f8a7 	bl	801b548 <memcpy1>
        return LORAMAC_COMMANDS_SUCCESS;
 80153fa:	2300      	movs	r3, #0
 80153fc:	e000      	b.n	8015400 <LoRaMacCommandsRestoreNvmCtx+0x20>
    }
    else
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
 80153fe:	2301      	movs	r3, #1
    }
}
 8015400:	0018      	movs	r0, r3
 8015402:	46bd      	mov	sp, r7
 8015404:	b002      	add	sp, #8
 8015406:	bd80      	pop	{r7, pc}
 8015408:	20000f58 	.word	0x20000f58

0801540c <LoRaMacCommandsGetNvmCtx>:

void* LoRaMacCommandsGetNvmCtx( size_t* commandsNvmCtxSize )
{
 801540c:	b580      	push	{r7, lr}
 801540e:	b082      	sub	sp, #8
 8015410:	af00      	add	r7, sp, #0
 8015412:	6078      	str	r0, [r7, #4]
    *commandsNvmCtxSize = sizeof( NvmCtx );
 8015414:	687b      	ldr	r3, [r7, #4]
 8015416:	22fc      	movs	r2, #252	; 0xfc
 8015418:	601a      	str	r2, [r3, #0]
    return &NvmCtx;
 801541a:	4b02      	ldr	r3, [pc, #8]	; (8015424 <LoRaMacCommandsGetNvmCtx+0x18>)
}
 801541c:	0018      	movs	r0, r3
 801541e:	46bd      	mov	sp, r7
 8015420:	b002      	add	sp, #8
 8015422:	bd80      	pop	{r7, pc}
 8015424:	20000f58 	.word	0x20000f58

08015428 <LoRaMacCommandsAddCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsAddCmd( uint8_t cid, uint8_t* payload, size_t payloadSize )
{
 8015428:	b590      	push	{r4, r7, lr}
 801542a:	b087      	sub	sp, #28
 801542c:	af00      	add	r7, sp, #0
 801542e:	60b9      	str	r1, [r7, #8]
 8015430:	607a      	str	r2, [r7, #4]
 8015432:	230f      	movs	r3, #15
 8015434:	18fb      	adds	r3, r7, r3
 8015436:	1c02      	adds	r2, r0, #0
 8015438:	701a      	strb	r2, [r3, #0]
    if( payload == 0 )
 801543a:	68bb      	ldr	r3, [r7, #8]
 801543c:	2b00      	cmp	r3, #0
 801543e:	d101      	bne.n	8015444 <LoRaMacCommandsAddCmd+0x1c>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
 8015440:	2301      	movs	r3, #1
 8015442:	e03c      	b.n	80154be <LoRaMacCommandsAddCmd+0x96>
    }
    MacCommand_t* newCmd;

    // Allocate a memory slot
    newCmd = MallocNewMacCommandSlot( );
 8015444:	f7ff fea8 	bl	8015198 <MallocNewMacCommandSlot>
 8015448:	0003      	movs	r3, r0
 801544a:	617b      	str	r3, [r7, #20]

    if( newCmd == 0 )
 801544c:	697b      	ldr	r3, [r7, #20]
 801544e:	2b00      	cmp	r3, #0
 8015450:	d101      	bne.n	8015456 <LoRaMacCommandsAddCmd+0x2e>
    {
        return LORAMAC_COMMANDS_ERROR_MEMORY;
 8015452:	2302      	movs	r3, #2
 8015454:	e033      	b.n	80154be <LoRaMacCommandsAddCmd+0x96>
    }

    // Add it to the list of Mac commands
    if( LinkedListAdd( &NvmCtx.MacCommandList, newCmd ) == false )
 8015456:	697a      	ldr	r2, [r7, #20]
 8015458:	4b1b      	ldr	r3, [pc, #108]	; (80154c8 <LoRaMacCommandsAddCmd+0xa0>)
 801545a:	0011      	movs	r1, r2
 801545c:	0018      	movs	r0, r3
 801545e:	f7ff fef3 	bl	8015248 <LinkedListAdd>
 8015462:	0003      	movs	r3, r0
 8015464:	001a      	movs	r2, r3
 8015466:	2301      	movs	r3, #1
 8015468:	4053      	eors	r3, r2
 801546a:	b2db      	uxtb	r3, r3
 801546c:	2b00      	cmp	r3, #0
 801546e:	d001      	beq.n	8015474 <LoRaMacCommandsAddCmd+0x4c>
    {
        return LORAMAC_COMMANDS_ERROR;
 8015470:	2305      	movs	r3, #5
 8015472:	e024      	b.n	80154be <LoRaMacCommandsAddCmd+0x96>
    }

    // Set Values
    newCmd->CID = cid;
 8015474:	697b      	ldr	r3, [r7, #20]
 8015476:	240f      	movs	r4, #15
 8015478:	193a      	adds	r2, r7, r4
 801547a:	7812      	ldrb	r2, [r2, #0]
 801547c:	711a      	strb	r2, [r3, #4]
    newCmd->PayloadSize = payloadSize;
 801547e:	697b      	ldr	r3, [r7, #20]
 8015480:	687a      	ldr	r2, [r7, #4]
 8015482:	609a      	str	r2, [r3, #8]
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 8015484:	697b      	ldr	r3, [r7, #20]
 8015486:	3305      	adds	r3, #5
 8015488:	687a      	ldr	r2, [r7, #4]
 801548a:	b292      	uxth	r2, r2
 801548c:	68b9      	ldr	r1, [r7, #8]
 801548e:	0018      	movs	r0, r3
 8015490:	f006 f85a 	bl	801b548 <memcpy1>
    newCmd->IsSticky = IsSticky( cid );
 8015494:	193b      	adds	r3, r7, r4
 8015496:	781b      	ldrb	r3, [r3, #0]
 8015498:	0018      	movs	r0, r3
 801549a:	f7ff ff59 	bl	8015350 <IsSticky>
 801549e:	0003      	movs	r3, r0
 80154a0:	001a      	movs	r2, r3
 80154a2:	697b      	ldr	r3, [r7, #20]
 80154a4:	731a      	strb	r2, [r3, #12]

    NvmCtx.SerializedCmdsSize += ( CID_FIELD_SIZE + payloadSize );
 80154a6:	4b08      	ldr	r3, [pc, #32]	; (80154c8 <LoRaMacCommandsAddCmd+0xa0>)
 80154a8:	22f8      	movs	r2, #248	; 0xf8
 80154aa:	589a      	ldr	r2, [r3, r2]
 80154ac:	687b      	ldr	r3, [r7, #4]
 80154ae:	18d3      	adds	r3, r2, r3
 80154b0:	1c5a      	adds	r2, r3, #1
 80154b2:	4b05      	ldr	r3, [pc, #20]	; (80154c8 <LoRaMacCommandsAddCmd+0xa0>)
 80154b4:	21f8      	movs	r1, #248	; 0xf8
 80154b6:	505a      	str	r2, [r3, r1]

    NvmCtxCallback( );
 80154b8:	f7ff ff6a 	bl	8015390 <NvmCtxCallback>

    return LORAMAC_COMMANDS_SUCCESS;
 80154bc:	2300      	movs	r3, #0
}
 80154be:	0018      	movs	r0, r3
 80154c0:	46bd      	mov	sp, r7
 80154c2:	b007      	add	sp, #28
 80154c4:	bd90      	pop	{r4, r7, pc}
 80154c6:	46c0      	nop			; (mov r8, r8)
 80154c8:	20000f58 	.word	0x20000f58

080154cc <LoRaMacCommandsRemoveCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveCmd( MacCommand_t* macCmd )
{
 80154cc:	b580      	push	{r7, lr}
 80154ce:	b082      	sub	sp, #8
 80154d0:	af00      	add	r7, sp, #0
 80154d2:	6078      	str	r0, [r7, #4]
    if( macCmd == NULL )
 80154d4:	687b      	ldr	r3, [r7, #4]
 80154d6:	2b00      	cmp	r3, #0
 80154d8:	d101      	bne.n	80154de <LoRaMacCommandsRemoveCmd+0x12>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
 80154da:	2301      	movs	r3, #1
 80154dc:	e028      	b.n	8015530 <LoRaMacCommandsRemoveCmd+0x64>
    }

    // Remove the Mac command element from MacCommandList
    if( LinkedListRemove( &NvmCtx.MacCommandList, macCmd ) == false )
 80154de:	687a      	ldr	r2, [r7, #4]
 80154e0:	4b15      	ldr	r3, [pc, #84]	; (8015538 <LoRaMacCommandsRemoveCmd+0x6c>)
 80154e2:	0011      	movs	r1, r2
 80154e4:	0018      	movs	r0, r3
 80154e6:	f7ff fefe 	bl	80152e6 <LinkedListRemove>
 80154ea:	0003      	movs	r3, r0
 80154ec:	001a      	movs	r2, r3
 80154ee:	2301      	movs	r3, #1
 80154f0:	4053      	eors	r3, r2
 80154f2:	b2db      	uxtb	r3, r3
 80154f4:	2b00      	cmp	r3, #0
 80154f6:	d001      	beq.n	80154fc <LoRaMacCommandsRemoveCmd+0x30>
    {
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
 80154f8:	2303      	movs	r3, #3
 80154fa:	e019      	b.n	8015530 <LoRaMacCommandsRemoveCmd+0x64>
    }

    NvmCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 80154fc:	4b0e      	ldr	r3, [pc, #56]	; (8015538 <LoRaMacCommandsRemoveCmd+0x6c>)
 80154fe:	22f8      	movs	r2, #248	; 0xf8
 8015500:	589a      	ldr	r2, [r3, r2]
 8015502:	687b      	ldr	r3, [r7, #4]
 8015504:	689b      	ldr	r3, [r3, #8]
 8015506:	1ad3      	subs	r3, r2, r3
 8015508:	1e5a      	subs	r2, r3, #1
 801550a:	4b0b      	ldr	r3, [pc, #44]	; (8015538 <LoRaMacCommandsRemoveCmd+0x6c>)
 801550c:	21f8      	movs	r1, #248	; 0xf8
 801550e:	505a      	str	r2, [r3, r1]

    // Free the MacCommand Slot
    if( FreeMacCommandSlot( macCmd ) == false )
 8015510:	687b      	ldr	r3, [r7, #4]
 8015512:	0018      	movs	r0, r3
 8015514:	f7ff fe70 	bl	80151f8 <FreeMacCommandSlot>
 8015518:	0003      	movs	r3, r0
 801551a:	001a      	movs	r2, r3
 801551c:	2301      	movs	r3, #1
 801551e:	4053      	eors	r3, r2
 8015520:	b2db      	uxtb	r3, r3
 8015522:	2b00      	cmp	r3, #0
 8015524:	d001      	beq.n	801552a <LoRaMacCommandsRemoveCmd+0x5e>
    {
        return LORAMAC_COMMANDS_ERROR;
 8015526:	2305      	movs	r3, #5
 8015528:	e002      	b.n	8015530 <LoRaMacCommandsRemoveCmd+0x64>
    }

    NvmCtxCallback( );
 801552a:	f7ff ff31 	bl	8015390 <NvmCtxCallback>

    return LORAMAC_COMMANDS_SUCCESS;
 801552e:	2300      	movs	r3, #0
}
 8015530:	0018      	movs	r0, r3
 8015532:	46bd      	mov	sp, r7
 8015534:	b002      	add	sp, #8
 8015536:	bd80      	pop	{r7, pc}
 8015538:	20000f58 	.word	0x20000f58

0801553c <LoRaMacCommandsRemoveNoneStickyCmds>:

    return LORAMAC_COMMANDS_SUCCESS;
}

LoRaMacCommandStatus_t LoRaMacCommandsRemoveNoneStickyCmds( void )
{
 801553c:	b580      	push	{r7, lr}
 801553e:	b082      	sub	sp, #8
 8015540:	af00      	add	r7, sp, #0
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = NvmCtx.MacCommandList.First;
 8015542:	4b11      	ldr	r3, [pc, #68]	; (8015588 <LoRaMacCommandsRemoveNoneStickyCmds+0x4c>)
 8015544:	681b      	ldr	r3, [r3, #0]
 8015546:	607b      	str	r3, [r7, #4]

    // Loop through all elements
    while( curElement != NULL )
 8015548:	e013      	b.n	8015572 <LoRaMacCommandsRemoveNoneStickyCmds+0x36>
    {
        if( curElement->IsSticky == false )
 801554a:	687b      	ldr	r3, [r7, #4]
 801554c:	7b1b      	ldrb	r3, [r3, #12]
 801554e:	2201      	movs	r2, #1
 8015550:	4053      	eors	r3, r2
 8015552:	b2db      	uxtb	r3, r3
 8015554:	2b00      	cmp	r3, #0
 8015556:	d009      	beq.n	801556c <LoRaMacCommandsRemoveNoneStickyCmds+0x30>
        {
            nexElement = curElement->Next;
 8015558:	687b      	ldr	r3, [r7, #4]
 801555a:	681b      	ldr	r3, [r3, #0]
 801555c:	603b      	str	r3, [r7, #0]
            LoRaMacCommandsRemoveCmd( curElement );
 801555e:	687b      	ldr	r3, [r7, #4]
 8015560:	0018      	movs	r0, r3
 8015562:	f7ff ffb3 	bl	80154cc <LoRaMacCommandsRemoveCmd>
            curElement = nexElement;
 8015566:	683b      	ldr	r3, [r7, #0]
 8015568:	607b      	str	r3, [r7, #4]
 801556a:	e002      	b.n	8015572 <LoRaMacCommandsRemoveNoneStickyCmds+0x36>
        }
        else
        {
            curElement = curElement->Next;
 801556c:	687b      	ldr	r3, [r7, #4]
 801556e:	681b      	ldr	r3, [r3, #0]
 8015570:	607b      	str	r3, [r7, #4]
    while( curElement != NULL )
 8015572:	687b      	ldr	r3, [r7, #4]
 8015574:	2b00      	cmp	r3, #0
 8015576:	d1e8      	bne.n	801554a <LoRaMacCommandsRemoveNoneStickyCmds+0xe>
        }
    }

    NvmCtxCallback( );
 8015578:	f7ff ff0a 	bl	8015390 <NvmCtxCallback>

    return LORAMAC_COMMANDS_SUCCESS;
 801557c:	2300      	movs	r3, #0
}
 801557e:	0018      	movs	r0, r3
 8015580:	46bd      	mov	sp, r7
 8015582:	b002      	add	sp, #8
 8015584:	bd80      	pop	{r7, pc}
 8015586:	46c0      	nop			; (mov r8, r8)
 8015588:	20000f58 	.word	0x20000f58

0801558c <LoRaMacCommandsRemoveStickyAnsCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveStickyAnsCmds( void )
{
 801558c:	b580      	push	{r7, lr}
 801558e:	b082      	sub	sp, #8
 8015590:	af00      	add	r7, sp, #0
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = NvmCtx.MacCommandList.First;
 8015592:	4b0f      	ldr	r3, [pc, #60]	; (80155d0 <LoRaMacCommandsRemoveStickyAnsCmds+0x44>)
 8015594:	681b      	ldr	r3, [r3, #0]
 8015596:	607b      	str	r3, [r7, #4]

    // Loop through all elements
    while( curElement != NULL )
 8015598:	e00f      	b.n	80155ba <LoRaMacCommandsRemoveStickyAnsCmds+0x2e>
    {
        nexElement = curElement->Next;
 801559a:	687b      	ldr	r3, [r7, #4]
 801559c:	681b      	ldr	r3, [r3, #0]
 801559e:	603b      	str	r3, [r7, #0]
        if( IsSticky( curElement->CID ) == true )
 80155a0:	687b      	ldr	r3, [r7, #4]
 80155a2:	791b      	ldrb	r3, [r3, #4]
 80155a4:	0018      	movs	r0, r3
 80155a6:	f7ff fed3 	bl	8015350 <IsSticky>
 80155aa:	1e03      	subs	r3, r0, #0
 80155ac:	d003      	beq.n	80155b6 <LoRaMacCommandsRemoveStickyAnsCmds+0x2a>
        {
            LoRaMacCommandsRemoveCmd( curElement );
 80155ae:	687b      	ldr	r3, [r7, #4]
 80155b0:	0018      	movs	r0, r3
 80155b2:	f7ff ff8b 	bl	80154cc <LoRaMacCommandsRemoveCmd>
        }
        curElement = nexElement;
 80155b6:	683b      	ldr	r3, [r7, #0]
 80155b8:	607b      	str	r3, [r7, #4]
    while( curElement != NULL )
 80155ba:	687b      	ldr	r3, [r7, #4]
 80155bc:	2b00      	cmp	r3, #0
 80155be:	d1ec      	bne.n	801559a <LoRaMacCommandsRemoveStickyAnsCmds+0xe>
    }

    NvmCtxCallback( );
 80155c0:	f7ff fee6 	bl	8015390 <NvmCtxCallback>

    return LORAMAC_COMMANDS_SUCCESS;
 80155c4:	2300      	movs	r3, #0
}
 80155c6:	0018      	movs	r0, r3
 80155c8:	46bd      	mov	sp, r7
 80155ca:	b002      	add	sp, #8
 80155cc:	bd80      	pop	{r7, pc}
 80155ce:	46c0      	nop			; (mov r8, r8)
 80155d0:	20000f58 	.word	0x20000f58

080155d4 <LoRaMacCommandsGetSizeSerializedCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsGetSizeSerializedCmds( size_t* size )
{
 80155d4:	b580      	push	{r7, lr}
 80155d6:	b082      	sub	sp, #8
 80155d8:	af00      	add	r7, sp, #0
 80155da:	6078      	str	r0, [r7, #4]
    if( size == NULL )
 80155dc:	687b      	ldr	r3, [r7, #4]
 80155de:	2b00      	cmp	r3, #0
 80155e0:	d101      	bne.n	80155e6 <LoRaMacCommandsGetSizeSerializedCmds+0x12>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
 80155e2:	2301      	movs	r3, #1
 80155e4:	e005      	b.n	80155f2 <LoRaMacCommandsGetSizeSerializedCmds+0x1e>
    }
    *size = NvmCtx.SerializedCmdsSize;
 80155e6:	4b05      	ldr	r3, [pc, #20]	; (80155fc <LoRaMacCommandsGetSizeSerializedCmds+0x28>)
 80155e8:	22f8      	movs	r2, #248	; 0xf8
 80155ea:	589a      	ldr	r2, [r3, r2]
 80155ec:	687b      	ldr	r3, [r7, #4]
 80155ee:	601a      	str	r2, [r3, #0]
    return LORAMAC_COMMANDS_SUCCESS;
 80155f0:	2300      	movs	r3, #0
}
 80155f2:	0018      	movs	r0, r3
 80155f4:	46bd      	mov	sp, r7
 80155f6:	b002      	add	sp, #8
 80155f8:	bd80      	pop	{r7, pc}
 80155fa:	46c0      	nop			; (mov r8, r8)
 80155fc:	20000f58 	.word	0x20000f58

08015600 <LoRaMacCommandsSerializeCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsSerializeCmds( size_t availableSize, size_t* effectiveSize, uint8_t* buffer )
{
 8015600:	b590      	push	{r4, r7, lr}
 8015602:	b087      	sub	sp, #28
 8015604:	af00      	add	r7, sp, #0
 8015606:	60f8      	str	r0, [r7, #12]
 8015608:	60b9      	str	r1, [r7, #8]
 801560a:	607a      	str	r2, [r7, #4]
    if( ( buffer == NULL ) || ( effectiveSize == NULL ) )
 801560c:	687b      	ldr	r3, [r7, #4]
 801560e:	2b00      	cmp	r3, #0
 8015610:	d002      	beq.n	8015618 <LoRaMacCommandsSerializeCmds+0x18>
 8015612:	68bb      	ldr	r3, [r7, #8]
 8015614:	2b00      	cmp	r3, #0
 8015616:	d101      	bne.n	801561c <LoRaMacCommandsSerializeCmds+0x1c>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
 8015618:	2301      	movs	r3, #1
 801561a:	e039      	b.n	8015690 <LoRaMacCommandsSerializeCmds+0x90>
    }
    MacCommand_t* curElement;
    curElement = NvmCtx.MacCommandList.First;
 801561c:	4b1e      	ldr	r3, [pc, #120]	; (8015698 <LoRaMacCommandsSerializeCmds+0x98>)
 801561e:	681b      	ldr	r3, [r3, #0]
 8015620:	617b      	str	r3, [r7, #20]
    uint8_t itr = 0;
 8015622:	2313      	movs	r3, #19
 8015624:	18fb      	adds	r3, r7, r3
 8015626:	2200      	movs	r2, #0
 8015628:	701a      	strb	r2, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 801562a:	e02b      	b.n	8015684 <LoRaMacCommandsSerializeCmds+0x84>
    {
        // If the next MAC command still fits into the buffer, add it.
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 801562c:	2413      	movs	r4, #19
 801562e:	193b      	adds	r3, r7, r4
 8015630:	781b      	ldrb	r3, [r3, #0]
 8015632:	68fa      	ldr	r2, [r7, #12]
 8015634:	1ad2      	subs	r2, r2, r3
 8015636:	697b      	ldr	r3, [r7, #20]
 8015638:	689b      	ldr	r3, [r3, #8]
 801563a:	3301      	adds	r3, #1
 801563c:	429a      	cmp	r2, r3
 801563e:	d325      	bcc.n	801568c <LoRaMacCommandsSerializeCmds+0x8c>
        {
            buffer[itr++] = curElement->CID;
 8015640:	193b      	adds	r3, r7, r4
 8015642:	781b      	ldrb	r3, [r3, #0]
 8015644:	193a      	adds	r2, r7, r4
 8015646:	1c59      	adds	r1, r3, #1
 8015648:	7011      	strb	r1, [r2, #0]
 801564a:	001a      	movs	r2, r3
 801564c:	687b      	ldr	r3, [r7, #4]
 801564e:	189b      	adds	r3, r3, r2
 8015650:	697a      	ldr	r2, [r7, #20]
 8015652:	7912      	ldrb	r2, [r2, #4]
 8015654:	701a      	strb	r2, [r3, #0]
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 8015656:	193b      	adds	r3, r7, r4
 8015658:	781b      	ldrb	r3, [r3, #0]
 801565a:	687a      	ldr	r2, [r7, #4]
 801565c:	18d0      	adds	r0, r2, r3
 801565e:	697b      	ldr	r3, [r7, #20]
 8015660:	1d59      	adds	r1, r3, #5
 8015662:	697b      	ldr	r3, [r7, #20]
 8015664:	689b      	ldr	r3, [r3, #8]
 8015666:	b29b      	uxth	r3, r3
 8015668:	001a      	movs	r2, r3
 801566a:	f005 ff6d 	bl	801b548 <memcpy1>
            itr = itr + curElement->PayloadSize;
 801566e:	697b      	ldr	r3, [r7, #20]
 8015670:	689b      	ldr	r3, [r3, #8]
 8015672:	b2d9      	uxtb	r1, r3
 8015674:	193b      	adds	r3, r7, r4
 8015676:	193a      	adds	r2, r7, r4
 8015678:	7812      	ldrb	r2, [r2, #0]
 801567a:	188a      	adds	r2, r1, r2
 801567c:	701a      	strb	r2, [r3, #0]
        }
        else
        {
            break;
        }
        curElement = curElement->Next;
 801567e:	697b      	ldr	r3, [r7, #20]
 8015680:	681b      	ldr	r3, [r3, #0]
 8015682:	617b      	str	r3, [r7, #20]
    while( curElement != NULL )
 8015684:	697b      	ldr	r3, [r7, #20]
 8015686:	2b00      	cmp	r3, #0
 8015688:	d1d0      	bne.n	801562c <LoRaMacCommandsSerializeCmds+0x2c>
 801568a:	e000      	b.n	801568e <LoRaMacCommandsSerializeCmds+0x8e>
            break;
 801568c:	46c0      	nop			; (mov r8, r8)
    }

    return LORAMAC_COMMANDS_SUCCESS;
 801568e:	2300      	movs	r3, #0
}
 8015690:	0018      	movs	r0, r3
 8015692:	46bd      	mov	sp, r7
 8015694:	b007      	add	sp, #28
 8015696:	bd90      	pop	{r4, r7, pc}
 8015698:	20000f58 	.word	0x20000f58

0801569c <LoRaMacCommandsStickyCmdsPending>:

LoRaMacCommandStatus_t LoRaMacCommandsStickyCmdsPending( bool* cmdsPending )
{
 801569c:	b580      	push	{r7, lr}
 801569e:	b084      	sub	sp, #16
 80156a0:	af00      	add	r7, sp, #0
 80156a2:	6078      	str	r0, [r7, #4]
    if( cmdsPending == NULL )
 80156a4:	687b      	ldr	r3, [r7, #4]
 80156a6:	2b00      	cmp	r3, #0
 80156a8:	d101      	bne.n	80156ae <LoRaMacCommandsStickyCmdsPending+0x12>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
 80156aa:	2301      	movs	r3, #1
 80156ac:	e016      	b.n	80156dc <LoRaMacCommandsStickyCmdsPending+0x40>
    }
    MacCommand_t* curElement;
    curElement = NvmCtx.MacCommandList.First;
 80156ae:	4b0d      	ldr	r3, [pc, #52]	; (80156e4 <LoRaMacCommandsStickyCmdsPending+0x48>)
 80156b0:	681b      	ldr	r3, [r3, #0]
 80156b2:	60fb      	str	r3, [r7, #12]

    *cmdsPending = false;
 80156b4:	687b      	ldr	r3, [r7, #4]
 80156b6:	2200      	movs	r2, #0
 80156b8:	701a      	strb	r2, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 80156ba:	e00b      	b.n	80156d4 <LoRaMacCommandsStickyCmdsPending+0x38>
    {
        if( curElement->IsSticky == true )
 80156bc:	68fb      	ldr	r3, [r7, #12]
 80156be:	7b1b      	ldrb	r3, [r3, #12]
 80156c0:	2b00      	cmp	r3, #0
 80156c2:	d004      	beq.n	80156ce <LoRaMacCommandsStickyCmdsPending+0x32>
        {
            // Found one sticky MAC command
            *cmdsPending = true;
 80156c4:	687b      	ldr	r3, [r7, #4]
 80156c6:	2201      	movs	r2, #1
 80156c8:	701a      	strb	r2, [r3, #0]
            return LORAMAC_COMMANDS_SUCCESS;
 80156ca:	2300      	movs	r3, #0
 80156cc:	e006      	b.n	80156dc <LoRaMacCommandsStickyCmdsPending+0x40>
        }
        curElement = curElement->Next;
 80156ce:	68fb      	ldr	r3, [r7, #12]
 80156d0:	681b      	ldr	r3, [r3, #0]
 80156d2:	60fb      	str	r3, [r7, #12]
    while( curElement != NULL )
 80156d4:	68fb      	ldr	r3, [r7, #12]
 80156d6:	2b00      	cmp	r3, #0
 80156d8:	d1f0      	bne.n	80156bc <LoRaMacCommandsStickyCmdsPending+0x20>
    }

    return LORAMAC_COMMANDS_SUCCESS;
 80156da:	2300      	movs	r3, #0
}
 80156dc:	0018      	movs	r0, r3
 80156de:	46bd      	mov	sp, r7
 80156e0:	b004      	add	sp, #16
 80156e2:	bd80      	pop	{r7, pc}
 80156e4:	20000f58 	.word	0x20000f58

080156e8 <IncreaseBufferPointer>:
 * Module context.
 */
static LoRaMacConfirmQueueCtx_t ConfirmQueueCtx;

static MlmeConfirmQueue_t* IncreaseBufferPointer( MlmeConfirmQueue_t* bufferPointer )
{
 80156e8:	b580      	push	{r7, lr}
 80156ea:	b082      	sub	sp, #8
 80156ec:	af00      	add	r7, sp, #0
 80156ee:	6078      	str	r0, [r7, #4]
    if( bufferPointer == &ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 80156f0:	4b08      	ldr	r3, [pc, #32]	; (8015714 <IncreaseBufferPointer+0x2c>)
 80156f2:	691b      	ldr	r3, [r3, #16]
 80156f4:	3310      	adds	r3, #16
 80156f6:	687a      	ldr	r2, [r7, #4]
 80156f8:	429a      	cmp	r2, r3
 80156fa:	d103      	bne.n	8015704 <IncreaseBufferPointer+0x1c>
    {
        // Reset to the first element
        bufferPointer = ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueue;
 80156fc:	4b05      	ldr	r3, [pc, #20]	; (8015714 <IncreaseBufferPointer+0x2c>)
 80156fe:	691b      	ldr	r3, [r3, #16]
 8015700:	607b      	str	r3, [r7, #4]
 8015702:	e002      	b.n	801570a <IncreaseBufferPointer+0x22>
    }
    else
    {
        // Increase
        bufferPointer++;
 8015704:	687b      	ldr	r3, [r7, #4]
 8015706:	3304      	adds	r3, #4
 8015708:	607b      	str	r3, [r7, #4]
    }
    return bufferPointer;
 801570a:	687b      	ldr	r3, [r7, #4]
}
 801570c:	0018      	movs	r0, r3
 801570e:	46bd      	mov	sp, r7
 8015710:	b002      	add	sp, #8
 8015712:	bd80      	pop	{r7, pc}
 8015714:	2000106c 	.word	0x2000106c

08015718 <GetElement>:
    }
    return bufferPointer;
}

static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
{
 8015718:	b580      	push	{r7, lr}
 801571a:	b086      	sub	sp, #24
 801571c:	af00      	add	r7, sp, #0
 801571e:	60b9      	str	r1, [r7, #8]
 8015720:	607a      	str	r2, [r7, #4]
 8015722:	230f      	movs	r3, #15
 8015724:	18fb      	adds	r3, r7, r3
 8015726:	1c02      	adds	r2, r0, #0
 8015728:	701a      	strb	r2, [r3, #0]
    MlmeConfirmQueue_t* element = bufferStart;
 801572a:	68bb      	ldr	r3, [r7, #8]
 801572c:	617b      	str	r3, [r7, #20]

    while( element != bufferEnd )
 801572e:	e00e      	b.n	801574e <GetElement+0x36>
    {
        if( element->Request == request )
 8015730:	697b      	ldr	r3, [r7, #20]
 8015732:	781b      	ldrb	r3, [r3, #0]
 8015734:	220f      	movs	r2, #15
 8015736:	18ba      	adds	r2, r7, r2
 8015738:	7812      	ldrb	r2, [r2, #0]
 801573a:	429a      	cmp	r2, r3
 801573c:	d101      	bne.n	8015742 <GetElement+0x2a>
        {
            // We have found the element
            return element;
 801573e:	697b      	ldr	r3, [r7, #20]
 8015740:	e00a      	b.n	8015758 <GetElement+0x40>
        }
        else
        {
            element = IncreaseBufferPointer( element );
 8015742:	697b      	ldr	r3, [r7, #20]
 8015744:	0018      	movs	r0, r3
 8015746:	f7ff ffcf 	bl	80156e8 <IncreaseBufferPointer>
 801574a:	0003      	movs	r3, r0
 801574c:	617b      	str	r3, [r7, #20]
    while( element != bufferEnd )
 801574e:	697a      	ldr	r2, [r7, #20]
 8015750:	687b      	ldr	r3, [r7, #4]
 8015752:	429a      	cmp	r2, r3
 8015754:	d1ec      	bne.n	8015730 <GetElement+0x18>
        }
    }
    return NULL;
 8015756:	2300      	movs	r3, #0
}
 8015758:	0018      	movs	r0, r3
 801575a:	46bd      	mov	sp, r7
 801575c:	b006      	add	sp, #24
 801575e:	bd80      	pop	{r7, pc}

08015760 <LoRaMacConfirmQueueInit>:

void LoRaMacConfirmQueueInit( LoRaMacPrimitives_t* primitives, LoRaMacConfirmQueueNvmEvent confirmQueueNvmCtxChanged )
{
 8015760:	b580      	push	{r7, lr}
 8015762:	b082      	sub	sp, #8
 8015764:	af00      	add	r7, sp, #0
 8015766:	6078      	str	r0, [r7, #4]
 8015768:	6039      	str	r1, [r7, #0]
    ConfirmQueueCtx.Primitives = primitives;
 801576a:	4b13      	ldr	r3, [pc, #76]	; (80157b8 <LoRaMacConfirmQueueInit+0x58>)
 801576c:	687a      	ldr	r2, [r7, #4]
 801576e:	601a      	str	r2, [r3, #0]

    // Assign nvm context
    ConfirmQueueCtx.ConfirmQueueNvmCtx = &ConfirmQueueNvmCtx;
 8015770:	4b11      	ldr	r3, [pc, #68]	; (80157b8 <LoRaMacConfirmQueueInit+0x58>)
 8015772:	4a12      	ldr	r2, [pc, #72]	; (80157bc <LoRaMacConfirmQueueInit+0x5c>)
 8015774:	611a      	str	r2, [r3, #16]

    // Init counter
    ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueueCnt = 0;
 8015776:	4b10      	ldr	r3, [pc, #64]	; (80157b8 <LoRaMacConfirmQueueInit+0x58>)
 8015778:	691b      	ldr	r3, [r3, #16]
 801577a:	2200      	movs	r2, #0
 801577c:	751a      	strb	r2, [r3, #20]

    // Init buffer
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueue;
 801577e:	4b0e      	ldr	r3, [pc, #56]	; (80157b8 <LoRaMacConfirmQueueInit+0x58>)
 8015780:	691b      	ldr	r3, [r3, #16]
 8015782:	001a      	movs	r2, r3
 8015784:	4b0c      	ldr	r3, [pc, #48]	; (80157b8 <LoRaMacConfirmQueueInit+0x58>)
 8015786:	605a      	str	r2, [r3, #4]
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueue;
 8015788:	4b0b      	ldr	r3, [pc, #44]	; (80157b8 <LoRaMacConfirmQueueInit+0x58>)
 801578a:	691b      	ldr	r3, [r3, #16]
 801578c:	001a      	movs	r2, r3
 801578e:	4b0a      	ldr	r3, [pc, #40]	; (80157b8 <LoRaMacConfirmQueueInit+0x58>)
 8015790:	609a      	str	r2, [r3, #8]

    memset1( ( uint8_t* )ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueue ) );
 8015792:	4b09      	ldr	r3, [pc, #36]	; (80157b8 <LoRaMacConfirmQueueInit+0x58>)
 8015794:	691b      	ldr	r3, [r3, #16]
 8015796:	2214      	movs	r2, #20
 8015798:	21ff      	movs	r1, #255	; 0xff
 801579a:	0018      	movs	r0, r3
 801579c:	f005 ff12 	bl	801b5c4 <memset1>

    // Common status
    ConfirmQueueCtx.ConfirmQueueNvmCtx->CommonStatus = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80157a0:	4b05      	ldr	r3, [pc, #20]	; (80157b8 <LoRaMacConfirmQueueInit+0x58>)
 80157a2:	691b      	ldr	r3, [r3, #16]
 80157a4:	2201      	movs	r2, #1
 80157a6:	755a      	strb	r2, [r3, #21]

    // Assign callback
    ConfirmQueueCtx.LoRaMacConfirmQueueNvmEvent = confirmQueueNvmCtxChanged;
 80157a8:	4b03      	ldr	r3, [pc, #12]	; (80157b8 <LoRaMacConfirmQueueInit+0x58>)
 80157aa:	683a      	ldr	r2, [r7, #0]
 80157ac:	60da      	str	r2, [r3, #12]
}
 80157ae:	46c0      	nop			; (mov r8, r8)
 80157b0:	46bd      	mov	sp, r7
 80157b2:	b002      	add	sp, #8
 80157b4:	bd80      	pop	{r7, pc}
 80157b6:	46c0      	nop			; (mov r8, r8)
 80157b8:	2000106c 	.word	0x2000106c
 80157bc:	20001054 	.word	0x20001054

080157c0 <LoRaMacConfirmQueueRestoreNvmCtx>:

bool LoRaMacConfirmQueueRestoreNvmCtx( void* confirmQueueNvmCtx )
{
 80157c0:	b580      	push	{r7, lr}
 80157c2:	b082      	sub	sp, #8
 80157c4:	af00      	add	r7, sp, #0
 80157c6:	6078      	str	r0, [r7, #4]
    // Restore module context
    if( confirmQueueNvmCtx != NULL )
 80157c8:	687b      	ldr	r3, [r7, #4]
 80157ca:	2b00      	cmp	r3, #0
 80157cc:	d007      	beq.n	80157de <LoRaMacConfirmQueueRestoreNvmCtx+0x1e>
    {
        memcpy1( ( uint8_t* )&ConfirmQueueNvmCtx, ( uint8_t* ) confirmQueueNvmCtx, sizeof( ConfirmQueueNvmCtx ) );
 80157ce:	6879      	ldr	r1, [r7, #4]
 80157d0:	4b05      	ldr	r3, [pc, #20]	; (80157e8 <LoRaMacConfirmQueueRestoreNvmCtx+0x28>)
 80157d2:	2216      	movs	r2, #22
 80157d4:	0018      	movs	r0, r3
 80157d6:	f005 feb7 	bl	801b548 <memcpy1>
        return true;
 80157da:	2301      	movs	r3, #1
 80157dc:	e000      	b.n	80157e0 <LoRaMacConfirmQueueRestoreNvmCtx+0x20>
    }
    else
    {
        return false;
 80157de:	2300      	movs	r3, #0
    }
}
 80157e0:	0018      	movs	r0, r3
 80157e2:	46bd      	mov	sp, r7
 80157e4:	b002      	add	sp, #8
 80157e6:	bd80      	pop	{r7, pc}
 80157e8:	20001054 	.word	0x20001054

080157ec <LoRaMacConfirmQueueGetNvmCtx>:

void* LoRaMacConfirmQueueGetNvmCtx( size_t* confirmQueueNvmCtxSize )
{
 80157ec:	b580      	push	{r7, lr}
 80157ee:	b082      	sub	sp, #8
 80157f0:	af00      	add	r7, sp, #0
 80157f2:	6078      	str	r0, [r7, #4]
    *confirmQueueNvmCtxSize = sizeof( ConfirmQueueNvmCtx );
 80157f4:	687b      	ldr	r3, [r7, #4]
 80157f6:	2216      	movs	r2, #22
 80157f8:	601a      	str	r2, [r3, #0]
    return &ConfirmQueueNvmCtx;
 80157fa:	4b02      	ldr	r3, [pc, #8]	; (8015804 <LoRaMacConfirmQueueGetNvmCtx+0x18>)
}
 80157fc:	0018      	movs	r0, r3
 80157fe:	46bd      	mov	sp, r7
 8015800:	b002      	add	sp, #8
 8015802:	bd80      	pop	{r7, pc}
 8015804:	20001054 	.word	0x20001054

08015808 <LoRaMacConfirmQueueAdd>:

bool LoRaMacConfirmQueueAdd( MlmeConfirmQueue_t* mlmeConfirm )
{
 8015808:	b580      	push	{r7, lr}
 801580a:	b082      	sub	sp, #8
 801580c:	af00      	add	r7, sp, #0
 801580e:	6078      	str	r0, [r7, #4]
    if( ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueueCnt >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8015810:	4b16      	ldr	r3, [pc, #88]	; (801586c <LoRaMacConfirmQueueAdd+0x64>)
 8015812:	691b      	ldr	r3, [r3, #16]
 8015814:	7d1b      	ldrb	r3, [r3, #20]
 8015816:	2b04      	cmp	r3, #4
 8015818:	d901      	bls.n	801581e <LoRaMacConfirmQueueAdd+0x16>
    {
        // Protect the buffer against overwrites
        return false;
 801581a:	2300      	movs	r3, #0
 801581c:	e021      	b.n	8015862 <LoRaMacConfirmQueueAdd+0x5a>
    }

    // Add the element to the ring buffer
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 801581e:	4b13      	ldr	r3, [pc, #76]	; (801586c <LoRaMacConfirmQueueAdd+0x64>)
 8015820:	689b      	ldr	r3, [r3, #8]
 8015822:	687a      	ldr	r2, [r7, #4]
 8015824:	7812      	ldrb	r2, [r2, #0]
 8015826:	701a      	strb	r2, [r3, #0]
    ConfirmQueueCtx.BufferEnd->Status = mlmeConfirm->Status;
 8015828:	4b10      	ldr	r3, [pc, #64]	; (801586c <LoRaMacConfirmQueueAdd+0x64>)
 801582a:	689b      	ldr	r3, [r3, #8]
 801582c:	687a      	ldr	r2, [r7, #4]
 801582e:	7852      	ldrb	r2, [r2, #1]
 8015830:	705a      	strb	r2, [r3, #1]
    ConfirmQueueCtx.BufferEnd->RestrictCommonReadyToHandle = mlmeConfirm->RestrictCommonReadyToHandle;
 8015832:	4b0e      	ldr	r3, [pc, #56]	; (801586c <LoRaMacConfirmQueueAdd+0x64>)
 8015834:	689b      	ldr	r3, [r3, #8]
 8015836:	687a      	ldr	r2, [r7, #4]
 8015838:	78d2      	ldrb	r2, [r2, #3]
 801583a:	70da      	strb	r2, [r3, #3]
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = false;
 801583c:	4b0b      	ldr	r3, [pc, #44]	; (801586c <LoRaMacConfirmQueueAdd+0x64>)
 801583e:	689b      	ldr	r3, [r3, #8]
 8015840:	2200      	movs	r2, #0
 8015842:	709a      	strb	r2, [r3, #2]
    // Increase counter
    ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueueCnt++;
 8015844:	4b09      	ldr	r3, [pc, #36]	; (801586c <LoRaMacConfirmQueueAdd+0x64>)
 8015846:	691b      	ldr	r3, [r3, #16]
 8015848:	7d1a      	ldrb	r2, [r3, #20]
 801584a:	3201      	adds	r2, #1
 801584c:	b2d2      	uxtb	r2, r2
 801584e:	751a      	strb	r2, [r3, #20]
    // Update end pointer
    ConfirmQueueCtx.BufferEnd = IncreaseBufferPointer( ConfirmQueueCtx.BufferEnd );
 8015850:	4b06      	ldr	r3, [pc, #24]	; (801586c <LoRaMacConfirmQueueAdd+0x64>)
 8015852:	689b      	ldr	r3, [r3, #8]
 8015854:	0018      	movs	r0, r3
 8015856:	f7ff ff47 	bl	80156e8 <IncreaseBufferPointer>
 801585a:	0002      	movs	r2, r0
 801585c:	4b03      	ldr	r3, [pc, #12]	; (801586c <LoRaMacConfirmQueueAdd+0x64>)
 801585e:	609a      	str	r2, [r3, #8]

    return true;
 8015860:	2301      	movs	r3, #1
}
 8015862:	0018      	movs	r0, r3
 8015864:	46bd      	mov	sp, r7
 8015866:	b002      	add	sp, #8
 8015868:	bd80      	pop	{r7, pc}
 801586a:	46c0      	nop			; (mov r8, r8)
 801586c:	2000106c 	.word	0x2000106c

08015870 <LoRaMacConfirmQueueRemoveFirst>:

    return true;
}

bool LoRaMacConfirmQueueRemoveFirst( void )
{
 8015870:	b580      	push	{r7, lr}
 8015872:	af00      	add	r7, sp, #0
    if( ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueueCnt == 0 )
 8015874:	4b0c      	ldr	r3, [pc, #48]	; (80158a8 <LoRaMacConfirmQueueRemoveFirst+0x38>)
 8015876:	691b      	ldr	r3, [r3, #16]
 8015878:	7d1b      	ldrb	r3, [r3, #20]
 801587a:	2b00      	cmp	r3, #0
 801587c:	d101      	bne.n	8015882 <LoRaMacConfirmQueueRemoveFirst+0x12>
    {
        return false;
 801587e:	2300      	movs	r3, #0
 8015880:	e00e      	b.n	80158a0 <LoRaMacConfirmQueueRemoveFirst+0x30>
    }

    // Increase counter
    ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueueCnt--;
 8015882:	4b09      	ldr	r3, [pc, #36]	; (80158a8 <LoRaMacConfirmQueueRemoveFirst+0x38>)
 8015884:	691b      	ldr	r3, [r3, #16]
 8015886:	7d1a      	ldrb	r2, [r3, #20]
 8015888:	3a01      	subs	r2, #1
 801588a:	b2d2      	uxtb	r2, r2
 801588c:	751a      	strb	r2, [r3, #20]
    // Update start pointer
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 801588e:	4b06      	ldr	r3, [pc, #24]	; (80158a8 <LoRaMacConfirmQueueRemoveFirst+0x38>)
 8015890:	685b      	ldr	r3, [r3, #4]
 8015892:	0018      	movs	r0, r3
 8015894:	f7ff ff28 	bl	80156e8 <IncreaseBufferPointer>
 8015898:	0002      	movs	r2, r0
 801589a:	4b03      	ldr	r3, [pc, #12]	; (80158a8 <LoRaMacConfirmQueueRemoveFirst+0x38>)
 801589c:	605a      	str	r2, [r3, #4]

    return true;
 801589e:	2301      	movs	r3, #1
}
 80158a0:	0018      	movs	r0, r3
 80158a2:	46bd      	mov	sp, r7
 80158a4:	bd80      	pop	{r7, pc}
 80158a6:	46c0      	nop			; (mov r8, r8)
 80158a8:	2000106c 	.word	0x2000106c

080158ac <LoRaMacConfirmQueueSetStatus>:

void LoRaMacConfirmQueueSetStatus( LoRaMacEventInfoStatus_t status, Mlme_t request )
{
 80158ac:	b580      	push	{r7, lr}
 80158ae:	b084      	sub	sp, #16
 80158b0:	af00      	add	r7, sp, #0
 80158b2:	0002      	movs	r2, r0
 80158b4:	1dfb      	adds	r3, r7, #7
 80158b6:	701a      	strb	r2, [r3, #0]
 80158b8:	1dbb      	adds	r3, r7, #6
 80158ba:	1c0a      	adds	r2, r1, #0
 80158bc:	701a      	strb	r2, [r3, #0]
    MlmeConfirmQueue_t* element = NULL;
 80158be:	2300      	movs	r3, #0
 80158c0:	60fb      	str	r3, [r7, #12]

    if( ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueueCnt > 0 )
 80158c2:	4b0f      	ldr	r3, [pc, #60]	; (8015900 <LoRaMacConfirmQueueSetStatus+0x54>)
 80158c4:	691b      	ldr	r3, [r3, #16]
 80158c6:	7d1b      	ldrb	r3, [r3, #20]
 80158c8:	2b00      	cmp	r3, #0
 80158ca:	d014      	beq.n	80158f6 <LoRaMacConfirmQueueSetStatus+0x4a>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 80158cc:	4b0c      	ldr	r3, [pc, #48]	; (8015900 <LoRaMacConfirmQueueSetStatus+0x54>)
 80158ce:	6859      	ldr	r1, [r3, #4]
 80158d0:	4b0b      	ldr	r3, [pc, #44]	; (8015900 <LoRaMacConfirmQueueSetStatus+0x54>)
 80158d2:	689a      	ldr	r2, [r3, #8]
 80158d4:	1dbb      	adds	r3, r7, #6
 80158d6:	781b      	ldrb	r3, [r3, #0]
 80158d8:	0018      	movs	r0, r3
 80158da:	f7ff ff1d 	bl	8015718 <GetElement>
 80158de:	0003      	movs	r3, r0
 80158e0:	60fb      	str	r3, [r7, #12]
        if( element != NULL )
 80158e2:	68fb      	ldr	r3, [r7, #12]
 80158e4:	2b00      	cmp	r3, #0
 80158e6:	d006      	beq.n	80158f6 <LoRaMacConfirmQueueSetStatus+0x4a>
        {
            element->Status = status;
 80158e8:	68fb      	ldr	r3, [r7, #12]
 80158ea:	1dfa      	adds	r2, r7, #7
 80158ec:	7812      	ldrb	r2, [r2, #0]
 80158ee:	705a      	strb	r2, [r3, #1]
            element->ReadyToHandle = true;
 80158f0:	68fb      	ldr	r3, [r7, #12]
 80158f2:	2201      	movs	r2, #1
 80158f4:	709a      	strb	r2, [r3, #2]
        }
    }
}
 80158f6:	46c0      	nop			; (mov r8, r8)
 80158f8:	46bd      	mov	sp, r7
 80158fa:	b004      	add	sp, #16
 80158fc:	bd80      	pop	{r7, pc}
 80158fe:	46c0      	nop			; (mov r8, r8)
 8015900:	2000106c 	.word	0x2000106c

08015904 <LoRaMacConfirmQueueGetStatus>:

LoRaMacEventInfoStatus_t LoRaMacConfirmQueueGetStatus( Mlme_t request )
{
 8015904:	b580      	push	{r7, lr}
 8015906:	b084      	sub	sp, #16
 8015908:	af00      	add	r7, sp, #0
 801590a:	0002      	movs	r2, r0
 801590c:	1dfb      	adds	r3, r7, #7
 801590e:	701a      	strb	r2, [r3, #0]
    MlmeConfirmQueue_t* element = NULL;
 8015910:	2300      	movs	r3, #0
 8015912:	60fb      	str	r3, [r7, #12]

    if( ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueueCnt > 0 )
 8015914:	4b0d      	ldr	r3, [pc, #52]	; (801594c <LoRaMacConfirmQueueGetStatus+0x48>)
 8015916:	691b      	ldr	r3, [r3, #16]
 8015918:	7d1b      	ldrb	r3, [r3, #20]
 801591a:	2b00      	cmp	r3, #0
 801591c:	d010      	beq.n	8015940 <LoRaMacConfirmQueueGetStatus+0x3c>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 801591e:	4b0b      	ldr	r3, [pc, #44]	; (801594c <LoRaMacConfirmQueueGetStatus+0x48>)
 8015920:	6859      	ldr	r1, [r3, #4]
 8015922:	4b0a      	ldr	r3, [pc, #40]	; (801594c <LoRaMacConfirmQueueGetStatus+0x48>)
 8015924:	689a      	ldr	r2, [r3, #8]
 8015926:	1dfb      	adds	r3, r7, #7
 8015928:	781b      	ldrb	r3, [r3, #0]
 801592a:	0018      	movs	r0, r3
 801592c:	f7ff fef4 	bl	8015718 <GetElement>
 8015930:	0003      	movs	r3, r0
 8015932:	60fb      	str	r3, [r7, #12]
        if( element != NULL )
 8015934:	68fb      	ldr	r3, [r7, #12]
 8015936:	2b00      	cmp	r3, #0
 8015938:	d002      	beq.n	8015940 <LoRaMacConfirmQueueGetStatus+0x3c>
        {
            return element->Status;
 801593a:	68fb      	ldr	r3, [r7, #12]
 801593c:	785b      	ldrb	r3, [r3, #1]
 801593e:	e000      	b.n	8015942 <LoRaMacConfirmQueueGetStatus+0x3e>
        }
    }
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
 8015940:	2301      	movs	r3, #1
}
 8015942:	0018      	movs	r0, r3
 8015944:	46bd      	mov	sp, r7
 8015946:	b004      	add	sp, #16
 8015948:	bd80      	pop	{r7, pc}
 801594a:	46c0      	nop			; (mov r8, r8)
 801594c:	2000106c 	.word	0x2000106c

08015950 <LoRaMacConfirmQueueSetStatusCmn>:

void LoRaMacConfirmQueueSetStatusCmn( LoRaMacEventInfoStatus_t status )
{
 8015950:	b580      	push	{r7, lr}
 8015952:	b084      	sub	sp, #16
 8015954:	af00      	add	r7, sp, #0
 8015956:	0002      	movs	r2, r0
 8015958:	1dfb      	adds	r3, r7, #7
 801595a:	701a      	strb	r2, [r3, #0]
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 801595c:	4b14      	ldr	r3, [pc, #80]	; (80159b0 <LoRaMacConfirmQueueSetStatusCmn+0x60>)
 801595e:	685b      	ldr	r3, [r3, #4]
 8015960:	60fb      	str	r3, [r7, #12]

    ConfirmQueueCtx.ConfirmQueueNvmCtx->CommonStatus = status;
 8015962:	4b13      	ldr	r3, [pc, #76]	; (80159b0 <LoRaMacConfirmQueueSetStatusCmn+0x60>)
 8015964:	691b      	ldr	r3, [r3, #16]
 8015966:	1dfa      	adds	r2, r7, #7
 8015968:	7812      	ldrb	r2, [r2, #0]
 801596a:	755a      	strb	r2, [r3, #21]

    if( ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueueCnt > 0 )
 801596c:	4b10      	ldr	r3, [pc, #64]	; (80159b0 <LoRaMacConfirmQueueSetStatusCmn+0x60>)
 801596e:	691b      	ldr	r3, [r3, #16]
 8015970:	7d1b      	ldrb	r3, [r3, #20]
 8015972:	2b00      	cmp	r3, #0
 8015974:	d018      	beq.n	80159a8 <LoRaMacConfirmQueueSetStatusCmn+0x58>
    {
        do
        {
            element->Status = status;
 8015976:	68fb      	ldr	r3, [r7, #12]
 8015978:	1dfa      	adds	r2, r7, #7
 801597a:	7812      	ldrb	r2, [r2, #0]
 801597c:	705a      	strb	r2, [r3, #1]
            // Set the status if it is allowed to set it with a call to
            // LoRaMacConfirmQueueSetStatusCmn.
            if( element->RestrictCommonReadyToHandle == false )
 801597e:	68fb      	ldr	r3, [r7, #12]
 8015980:	78db      	ldrb	r3, [r3, #3]
 8015982:	2201      	movs	r2, #1
 8015984:	4053      	eors	r3, r2
 8015986:	b2db      	uxtb	r3, r3
 8015988:	2b00      	cmp	r3, #0
 801598a:	d002      	beq.n	8015992 <LoRaMacConfirmQueueSetStatusCmn+0x42>
            {
                element->ReadyToHandle = true;
 801598c:	68fb      	ldr	r3, [r7, #12]
 801598e:	2201      	movs	r2, #1
 8015990:	709a      	strb	r2, [r3, #2]
            }
            element = IncreaseBufferPointer( element );
 8015992:	68fb      	ldr	r3, [r7, #12]
 8015994:	0018      	movs	r0, r3
 8015996:	f7ff fea7 	bl	80156e8 <IncreaseBufferPointer>
 801599a:	0003      	movs	r3, r0
 801599c:	60fb      	str	r3, [r7, #12]
        }while( element != ConfirmQueueCtx.BufferEnd );
 801599e:	4b04      	ldr	r3, [pc, #16]	; (80159b0 <LoRaMacConfirmQueueSetStatusCmn+0x60>)
 80159a0:	689b      	ldr	r3, [r3, #8]
 80159a2:	68fa      	ldr	r2, [r7, #12]
 80159a4:	429a      	cmp	r2, r3
 80159a6:	d1e6      	bne.n	8015976 <LoRaMacConfirmQueueSetStatusCmn+0x26>
    }
}
 80159a8:	46c0      	nop			; (mov r8, r8)
 80159aa:	46bd      	mov	sp, r7
 80159ac:	b004      	add	sp, #16
 80159ae:	bd80      	pop	{r7, pc}
 80159b0:	2000106c 	.word	0x2000106c

080159b4 <LoRaMacConfirmQueueIsCmdActive>:
{
    return ConfirmQueueCtx.ConfirmQueueNvmCtx->CommonStatus;
}

bool LoRaMacConfirmQueueIsCmdActive( Mlme_t request )
{
 80159b4:	b580      	push	{r7, lr}
 80159b6:	b082      	sub	sp, #8
 80159b8:	af00      	add	r7, sp, #0
 80159ba:	0002      	movs	r2, r0
 80159bc:	1dfb      	adds	r3, r7, #7
 80159be:	701a      	strb	r2, [r3, #0]
    if( GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd ) != NULL )
 80159c0:	4b08      	ldr	r3, [pc, #32]	; (80159e4 <LoRaMacConfirmQueueIsCmdActive+0x30>)
 80159c2:	6859      	ldr	r1, [r3, #4]
 80159c4:	4b07      	ldr	r3, [pc, #28]	; (80159e4 <LoRaMacConfirmQueueIsCmdActive+0x30>)
 80159c6:	689a      	ldr	r2, [r3, #8]
 80159c8:	1dfb      	adds	r3, r7, #7
 80159ca:	781b      	ldrb	r3, [r3, #0]
 80159cc:	0018      	movs	r0, r3
 80159ce:	f7ff fea3 	bl	8015718 <GetElement>
 80159d2:	1e03      	subs	r3, r0, #0
 80159d4:	d001      	beq.n	80159da <LoRaMacConfirmQueueIsCmdActive+0x26>
    {
        return true;
 80159d6:	2301      	movs	r3, #1
 80159d8:	e000      	b.n	80159dc <LoRaMacConfirmQueueIsCmdActive+0x28>
    }
    return false;
 80159da:	2300      	movs	r3, #0
}
 80159dc:	0018      	movs	r0, r3
 80159de:	46bd      	mov	sp, r7
 80159e0:	b002      	add	sp, #8
 80159e2:	bd80      	pop	{r7, pc}
 80159e4:	2000106c 	.word	0x2000106c

080159e8 <LoRaMacConfirmQueueHandleCb>:

void LoRaMacConfirmQueueHandleCb( MlmeConfirm_t* mlmeConfirm )
{
 80159e8:	b580      	push	{r7, lr}
 80159ea:	b084      	sub	sp, #16
 80159ec:	af00      	add	r7, sp, #0
 80159ee:	6078      	str	r0, [r7, #4]
    uint8_t nbElements = ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueueCnt;
 80159f0:	4b2d      	ldr	r3, [pc, #180]	; (8015aa8 <LoRaMacConfirmQueueHandleCb+0xc0>)
 80159f2:	691a      	ldr	r2, [r3, #16]
 80159f4:	230e      	movs	r3, #14
 80159f6:	18fb      	adds	r3, r7, r3
 80159f8:	7d12      	ldrb	r2, [r2, #20]
 80159fa:	701a      	strb	r2, [r3, #0]
    bool readyToHandle = false;
 80159fc:	230d      	movs	r3, #13
 80159fe:	18fb      	adds	r3, r7, r3
 8015a00:	2200      	movs	r2, #0
 8015a02:	701a      	strb	r2, [r3, #0]
    MlmeConfirmQueue_t mlmeConfirmToStore;

    for( uint8_t i = 0; i < nbElements; i++ )
 8015a04:	230f      	movs	r3, #15
 8015a06:	18fb      	adds	r3, r7, r3
 8015a08:	2200      	movs	r2, #0
 8015a0a:	701a      	strb	r2, [r3, #0]
 8015a0c:	e03f      	b.n	8015a8e <LoRaMacConfirmQueueHandleCb+0xa6>
    {
        mlmeConfirm->MlmeRequest = ConfirmQueueCtx.BufferStart->Request;
 8015a0e:	4b26      	ldr	r3, [pc, #152]	; (8015aa8 <LoRaMacConfirmQueueHandleCb+0xc0>)
 8015a10:	685b      	ldr	r3, [r3, #4]
 8015a12:	781a      	ldrb	r2, [r3, #0]
 8015a14:	687b      	ldr	r3, [r7, #4]
 8015a16:	701a      	strb	r2, [r3, #0]
        mlmeConfirm->Status = ConfirmQueueCtx.BufferStart->Status;
 8015a18:	4b23      	ldr	r3, [pc, #140]	; (8015aa8 <LoRaMacConfirmQueueHandleCb+0xc0>)
 8015a1a:	685b      	ldr	r3, [r3, #4]
 8015a1c:	785a      	ldrb	r2, [r3, #1]
 8015a1e:	687b      	ldr	r3, [r7, #4]
 8015a20:	705a      	strb	r2, [r3, #1]
        readyToHandle = ConfirmQueueCtx.BufferStart->ReadyToHandle;
 8015a22:	4b21      	ldr	r3, [pc, #132]	; (8015aa8 <LoRaMacConfirmQueueHandleCb+0xc0>)
 8015a24:	685a      	ldr	r2, [r3, #4]
 8015a26:	210d      	movs	r1, #13
 8015a28:	187b      	adds	r3, r7, r1
 8015a2a:	7892      	ldrb	r2, [r2, #2]
 8015a2c:	701a      	strb	r2, [r3, #0]

        if( readyToHandle == true )
 8015a2e:	187b      	adds	r3, r7, r1
 8015a30:	781b      	ldrb	r3, [r3, #0]
 8015a32:	2b00      	cmp	r3, #0
 8015a34:	d006      	beq.n	8015a44 <LoRaMacConfirmQueueHandleCb+0x5c>
        {
            ConfirmQueueCtx.Primitives->MacMlmeConfirm( mlmeConfirm );
 8015a36:	4b1c      	ldr	r3, [pc, #112]	; (8015aa8 <LoRaMacConfirmQueueHandleCb+0xc0>)
 8015a38:	681b      	ldr	r3, [r3, #0]
 8015a3a:	689b      	ldr	r3, [r3, #8]
 8015a3c:	687a      	ldr	r2, [r7, #4]
 8015a3e:	0010      	movs	r0, r2
 8015a40:	4798      	blx	r3
 8015a42:	e00f      	b.n	8015a64 <LoRaMacConfirmQueueHandleCb+0x7c>
        }
        else
        {
            // The request is not processed yet. Store the state.
            mlmeConfirmToStore.Request = ConfirmQueueCtx.BufferStart->Request;
 8015a44:	4b18      	ldr	r3, [pc, #96]	; (8015aa8 <LoRaMacConfirmQueueHandleCb+0xc0>)
 8015a46:	685b      	ldr	r3, [r3, #4]
 8015a48:	781a      	ldrb	r2, [r3, #0]
 8015a4a:	2108      	movs	r1, #8
 8015a4c:	187b      	adds	r3, r7, r1
 8015a4e:	701a      	strb	r2, [r3, #0]
            mlmeConfirmToStore.Status = ConfirmQueueCtx.BufferStart->Status;
 8015a50:	4b15      	ldr	r3, [pc, #84]	; (8015aa8 <LoRaMacConfirmQueueHandleCb+0xc0>)
 8015a52:	685b      	ldr	r3, [r3, #4]
 8015a54:	785a      	ldrb	r2, [r3, #1]
 8015a56:	187b      	adds	r3, r7, r1
 8015a58:	705a      	strb	r2, [r3, #1]
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 8015a5a:	4b13      	ldr	r3, [pc, #76]	; (8015aa8 <LoRaMacConfirmQueueHandleCb+0xc0>)
 8015a5c:	685b      	ldr	r3, [r3, #4]
 8015a5e:	78da      	ldrb	r2, [r3, #3]
 8015a60:	187b      	adds	r3, r7, r1
 8015a62:	70da      	strb	r2, [r3, #3]
        }

        // Increase the pointer afterwards to prevent overwrites
        LoRaMacConfirmQueueRemoveFirst( );
 8015a64:	f7ff ff04 	bl	8015870 <LoRaMacConfirmQueueRemoveFirst>

        if( readyToHandle == false )
 8015a68:	230d      	movs	r3, #13
 8015a6a:	18fb      	adds	r3, r7, r3
 8015a6c:	781b      	ldrb	r3, [r3, #0]
 8015a6e:	2201      	movs	r2, #1
 8015a70:	4053      	eors	r3, r2
 8015a72:	b2db      	uxtb	r3, r3
 8015a74:	2b00      	cmp	r3, #0
 8015a76:	d004      	beq.n	8015a82 <LoRaMacConfirmQueueHandleCb+0x9a>
        {
            // Add a request which has not been finished again to the queue
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
 8015a78:	2308      	movs	r3, #8
 8015a7a:	18fb      	adds	r3, r7, r3
 8015a7c:	0018      	movs	r0, r3
 8015a7e:	f7ff fec3 	bl	8015808 <LoRaMacConfirmQueueAdd>
    for( uint8_t i = 0; i < nbElements; i++ )
 8015a82:	210f      	movs	r1, #15
 8015a84:	187b      	adds	r3, r7, r1
 8015a86:	781a      	ldrb	r2, [r3, #0]
 8015a88:	187b      	adds	r3, r7, r1
 8015a8a:	3201      	adds	r2, #1
 8015a8c:	701a      	strb	r2, [r3, #0]
 8015a8e:	230f      	movs	r3, #15
 8015a90:	18fa      	adds	r2, r7, r3
 8015a92:	230e      	movs	r3, #14
 8015a94:	18fb      	adds	r3, r7, r3
 8015a96:	7812      	ldrb	r2, [r2, #0]
 8015a98:	781b      	ldrb	r3, [r3, #0]
 8015a9a:	429a      	cmp	r2, r3
 8015a9c:	d3b7      	bcc.n	8015a0e <LoRaMacConfirmQueueHandleCb+0x26>
        }
    }
}
 8015a9e:	46c0      	nop			; (mov r8, r8)
 8015aa0:	46c0      	nop			; (mov r8, r8)
 8015aa2:	46bd      	mov	sp, r7
 8015aa4:	b004      	add	sp, #16
 8015aa6:	bd80      	pop	{r7, pc}
 8015aa8:	2000106c 	.word	0x2000106c

08015aac <LoRaMacConfirmQueueGetCnt>:

uint8_t LoRaMacConfirmQueueGetCnt( void )
{
 8015aac:	b580      	push	{r7, lr}
 8015aae:	af00      	add	r7, sp, #0
    return ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueueCnt;
 8015ab0:	4b02      	ldr	r3, [pc, #8]	; (8015abc <LoRaMacConfirmQueueGetCnt+0x10>)
 8015ab2:	691b      	ldr	r3, [r3, #16]
 8015ab4:	7d1b      	ldrb	r3, [r3, #20]
}
 8015ab6:	0018      	movs	r0, r3
 8015ab8:	46bd      	mov	sp, r7
 8015aba:	bd80      	pop	{r7, pc}
 8015abc:	2000106c 	.word	0x2000106c

08015ac0 <LoRaMacConfirmQueueIsFull>:

bool LoRaMacConfirmQueueIsFull( void )
{
 8015ac0:	b580      	push	{r7, lr}
 8015ac2:	af00      	add	r7, sp, #0
    if( ConfirmQueueCtx.ConfirmQueueNvmCtx->MlmeConfirmQueueCnt >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8015ac4:	4b05      	ldr	r3, [pc, #20]	; (8015adc <LoRaMacConfirmQueueIsFull+0x1c>)
 8015ac6:	691b      	ldr	r3, [r3, #16]
 8015ac8:	7d1b      	ldrb	r3, [r3, #20]
 8015aca:	2b04      	cmp	r3, #4
 8015acc:	d901      	bls.n	8015ad2 <LoRaMacConfirmQueueIsFull+0x12>
    {
        return true;
 8015ace:	2301      	movs	r3, #1
 8015ad0:	e000      	b.n	8015ad4 <LoRaMacConfirmQueueIsFull+0x14>
    }
    else
    {
        return false;
 8015ad2:	2300      	movs	r3, #0
    }
}
 8015ad4:	0018      	movs	r0, r3
 8015ad6:	46bd      	mov	sp, r7
 8015ad8:	bd80      	pop	{r7, pc}
 8015ada:	46c0      	nop			; (mov r8, r8)
 8015adc:	2000106c 	.word	0x2000106c

08015ae0 <PayloadEncrypt>:
 * \param[IN]  size             - Size of data
 * \param[IN/OUT]  buffer       - Data buffer
 * \retval                      - Status of the operation
 */
static LoRaMacCryptoStatus_t PayloadEncrypt( uint8_t* buffer, int16_t size, KeyIdentifier_t keyID, uint32_t address, uint8_t dir, uint32_t frameCounter )
{
 8015ae0:	b590      	push	{r4, r7, lr}
 8015ae2:	b08f      	sub	sp, #60	; 0x3c
 8015ae4:	af00      	add	r7, sp, #0
 8015ae6:	60f8      	str	r0, [r7, #12]
 8015ae8:	0008      	movs	r0, r1
 8015aea:	0011      	movs	r1, r2
 8015aec:	607b      	str	r3, [r7, #4]
 8015aee:	230a      	movs	r3, #10
 8015af0:	18fb      	adds	r3, r7, r3
 8015af2:	1c02      	adds	r2, r0, #0
 8015af4:	801a      	strh	r2, [r3, #0]
 8015af6:	2309      	movs	r3, #9
 8015af8:	18fb      	adds	r3, r7, r3
 8015afa:	1c0a      	adds	r2, r1, #0
 8015afc:	701a      	strb	r2, [r3, #0]
    if( buffer == 0 )
 8015afe:	68fb      	ldr	r3, [r7, #12]
 8015b00:	2b00      	cmp	r3, #0
 8015b02:	d101      	bne.n	8015b08 <PayloadEncrypt+0x28>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 8015b04:	230a      	movs	r3, #10
 8015b06:	e0ae      	b.n	8015c66 <PayloadEncrypt+0x186>
    }

    uint8_t bufferIndex = 0;
 8015b08:	2337      	movs	r3, #55	; 0x37
 8015b0a:	18fb      	adds	r3, r7, r3
 8015b0c:	2200      	movs	r2, #0
 8015b0e:	701a      	strb	r2, [r3, #0]
    uint16_t ctr = 1;
 8015b10:	2334      	movs	r3, #52	; 0x34
 8015b12:	18fb      	adds	r3, r7, r3
 8015b14:	2201      	movs	r2, #1
 8015b16:	801a      	strh	r2, [r3, #0]
    uint8_t sBlock[16] = { 0 };
 8015b18:	2320      	movs	r3, #32
 8015b1a:	18fb      	adds	r3, r7, r3
 8015b1c:	2200      	movs	r2, #0
 8015b1e:	601a      	str	r2, [r3, #0]
 8015b20:	3304      	adds	r3, #4
 8015b22:	220c      	movs	r2, #12
 8015b24:	2100      	movs	r1, #0
 8015b26:	0018      	movs	r0, r3
 8015b28:	f007 fd14 	bl	801d554 <memset>
    uint8_t aBlock[16] = { 0 };
 8015b2c:	2410      	movs	r4, #16
 8015b2e:	193b      	adds	r3, r7, r4
 8015b30:	2200      	movs	r2, #0
 8015b32:	601a      	str	r2, [r3, #0]
 8015b34:	3304      	adds	r3, #4
 8015b36:	220c      	movs	r2, #12
 8015b38:	2100      	movs	r1, #0
 8015b3a:	0018      	movs	r0, r3
 8015b3c:	f007 fd0a 	bl	801d554 <memset>

    aBlock[0] = 0x01;
 8015b40:	0021      	movs	r1, r4
 8015b42:	187b      	adds	r3, r7, r1
 8015b44:	2201      	movs	r2, #1
 8015b46:	701a      	strb	r2, [r3, #0]

    aBlock[5] = dir;
 8015b48:	187a      	adds	r2, r7, r1
 8015b4a:	2340      	movs	r3, #64	; 0x40
 8015b4c:	2008      	movs	r0, #8
 8015b4e:	4684      	mov	ip, r0
 8015b50:	44bc      	add	ip, r7
 8015b52:	4463      	add	r3, ip
 8015b54:	781b      	ldrb	r3, [r3, #0]
 8015b56:	7153      	strb	r3, [r2, #5]

    aBlock[6] = address & 0xFF;
 8015b58:	687b      	ldr	r3, [r7, #4]
 8015b5a:	b2da      	uxtb	r2, r3
 8015b5c:	187b      	adds	r3, r7, r1
 8015b5e:	719a      	strb	r2, [r3, #6]
    aBlock[7] = ( address >> 8 ) & 0xFF;
 8015b60:	687b      	ldr	r3, [r7, #4]
 8015b62:	0a1b      	lsrs	r3, r3, #8
 8015b64:	b2da      	uxtb	r2, r3
 8015b66:	187b      	adds	r3, r7, r1
 8015b68:	71da      	strb	r2, [r3, #7]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 8015b6a:	687b      	ldr	r3, [r7, #4]
 8015b6c:	0c1b      	lsrs	r3, r3, #16
 8015b6e:	b2da      	uxtb	r2, r3
 8015b70:	187b      	adds	r3, r7, r1
 8015b72:	721a      	strb	r2, [r3, #8]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 8015b74:	687b      	ldr	r3, [r7, #4]
 8015b76:	0e1b      	lsrs	r3, r3, #24
 8015b78:	b2da      	uxtb	r2, r3
 8015b7a:	187b      	adds	r3, r7, r1
 8015b7c:	725a      	strb	r2, [r3, #9]

    aBlock[10] = frameCounter & 0xFF;
 8015b7e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015b80:	b2da      	uxtb	r2, r3
 8015b82:	187b      	adds	r3, r7, r1
 8015b84:	729a      	strb	r2, [r3, #10]
    aBlock[11] = ( frameCounter >> 8 ) & 0xFF;
 8015b86:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015b88:	0a1b      	lsrs	r3, r3, #8
 8015b8a:	b2da      	uxtb	r2, r3
 8015b8c:	187b      	adds	r3, r7, r1
 8015b8e:	72da      	strb	r2, [r3, #11]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 8015b90:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015b92:	0c1b      	lsrs	r3, r3, #16
 8015b94:	b2da      	uxtb	r2, r3
 8015b96:	187b      	adds	r3, r7, r1
 8015b98:	731a      	strb	r2, [r3, #12]
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 8015b9a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015b9c:	0e1b      	lsrs	r3, r3, #24
 8015b9e:	b2da      	uxtb	r2, r3
 8015ba0:	187b      	adds	r3, r7, r1
 8015ba2:	735a      	strb	r2, [r3, #13]

    while( size > 0 )
 8015ba4:	e058      	b.n	8015c58 <PayloadEncrypt+0x178>
    {
        aBlock[15] = ctr & 0xFF;
 8015ba6:	2134      	movs	r1, #52	; 0x34
 8015ba8:	187b      	adds	r3, r7, r1
 8015baa:	881b      	ldrh	r3, [r3, #0]
 8015bac:	b2da      	uxtb	r2, r3
 8015bae:	2010      	movs	r0, #16
 8015bb0:	183b      	adds	r3, r7, r0
 8015bb2:	73da      	strb	r2, [r3, #15]
        ctr++;
 8015bb4:	187b      	adds	r3, r7, r1
 8015bb6:	881a      	ldrh	r2, [r3, #0]
 8015bb8:	187b      	adds	r3, r7, r1
 8015bba:	3201      	adds	r2, #1
 8015bbc:	801a      	strh	r2, [r3, #0]
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 8015bbe:	2320      	movs	r3, #32
 8015bc0:	18f9      	adds	r1, r7, r3
 8015bc2:	2309      	movs	r3, #9
 8015bc4:	18fb      	adds	r3, r7, r3
 8015bc6:	781a      	ldrb	r2, [r3, #0]
 8015bc8:	1838      	adds	r0, r7, r0
 8015bca:	000b      	movs	r3, r1
 8015bcc:	2110      	movs	r1, #16
 8015bce:	f7f9 fbcd 	bl	800f36c <SecureElementAesEncrypt>
 8015bd2:	1e03      	subs	r3, r0, #0
 8015bd4:	d001      	beq.n	8015bda <PayloadEncrypt+0xfa>
        {
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8015bd6:	230f      	movs	r3, #15
 8015bd8:	e045      	b.n	8015c66 <PayloadEncrypt+0x186>
        }

        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8015bda:	2333      	movs	r3, #51	; 0x33
 8015bdc:	18fb      	adds	r3, r7, r3
 8015bde:	2200      	movs	r2, #0
 8015be0:	701a      	strb	r2, [r3, #0]
 8015be2:	e01f      	b.n	8015c24 <PayloadEncrypt+0x144>
        {
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 8015be4:	2037      	movs	r0, #55	; 0x37
 8015be6:	183b      	adds	r3, r7, r0
 8015be8:	781a      	ldrb	r2, [r3, #0]
 8015bea:	2433      	movs	r4, #51	; 0x33
 8015bec:	193b      	adds	r3, r7, r4
 8015bee:	781b      	ldrb	r3, [r3, #0]
 8015bf0:	18d3      	adds	r3, r2, r3
 8015bf2:	001a      	movs	r2, r3
 8015bf4:	68fb      	ldr	r3, [r7, #12]
 8015bf6:	189b      	adds	r3, r3, r2
 8015bf8:	7819      	ldrb	r1, [r3, #0]
 8015bfa:	193b      	adds	r3, r7, r4
 8015bfc:	781b      	ldrb	r3, [r3, #0]
 8015bfe:	2220      	movs	r2, #32
 8015c00:	18ba      	adds	r2, r7, r2
 8015c02:	5cd2      	ldrb	r2, [r2, r3]
 8015c04:	183b      	adds	r3, r7, r0
 8015c06:	7818      	ldrb	r0, [r3, #0]
 8015c08:	193b      	adds	r3, r7, r4
 8015c0a:	781b      	ldrb	r3, [r3, #0]
 8015c0c:	18c3      	adds	r3, r0, r3
 8015c0e:	0018      	movs	r0, r3
 8015c10:	68fb      	ldr	r3, [r7, #12]
 8015c12:	181b      	adds	r3, r3, r0
 8015c14:	404a      	eors	r2, r1
 8015c16:	b2d2      	uxtb	r2, r2
 8015c18:	701a      	strb	r2, [r3, #0]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8015c1a:	193b      	adds	r3, r7, r4
 8015c1c:	781a      	ldrb	r2, [r3, #0]
 8015c1e:	193b      	adds	r3, r7, r4
 8015c20:	3201      	adds	r2, #1
 8015c22:	701a      	strb	r2, [r3, #0]
 8015c24:	2333      	movs	r3, #51	; 0x33
 8015c26:	18fb      	adds	r3, r7, r3
 8015c28:	781a      	ldrb	r2, [r3, #0]
 8015c2a:	230a      	movs	r3, #10
 8015c2c:	18fb      	adds	r3, r7, r3
 8015c2e:	881b      	ldrh	r3, [r3, #0]
 8015c30:	b219      	sxth	r1, r3
 8015c32:	2910      	cmp	r1, #16
 8015c34:	dd00      	ble.n	8015c38 <PayloadEncrypt+0x158>
 8015c36:	2310      	movs	r3, #16
 8015c38:	b21b      	sxth	r3, r3
 8015c3a:	429a      	cmp	r2, r3
 8015c3c:	dbd2      	blt.n	8015be4 <PayloadEncrypt+0x104>
        }
        size -= 16;
 8015c3e:	210a      	movs	r1, #10
 8015c40:	187b      	adds	r3, r7, r1
 8015c42:	881b      	ldrh	r3, [r3, #0]
 8015c44:	3b10      	subs	r3, #16
 8015c46:	b29a      	uxth	r2, r3
 8015c48:	187b      	adds	r3, r7, r1
 8015c4a:	801a      	strh	r2, [r3, #0]
        bufferIndex += 16;
 8015c4c:	2237      	movs	r2, #55	; 0x37
 8015c4e:	18bb      	adds	r3, r7, r2
 8015c50:	18ba      	adds	r2, r7, r2
 8015c52:	7812      	ldrb	r2, [r2, #0]
 8015c54:	3210      	adds	r2, #16
 8015c56:	701a      	strb	r2, [r3, #0]
    while( size > 0 )
 8015c58:	230a      	movs	r3, #10
 8015c5a:	18fb      	adds	r3, r7, r3
 8015c5c:	2200      	movs	r2, #0
 8015c5e:	5e9b      	ldrsh	r3, [r3, r2]
 8015c60:	2b00      	cmp	r3, #0
 8015c62:	dca0      	bgt.n	8015ba6 <PayloadEncrypt+0xc6>
    }

    return LORAMAC_CRYPTO_SUCCESS;
 8015c64:	2300      	movs	r3, #0
}
 8015c66:	0018      	movs	r0, r3
 8015c68:	46bd      	mov	sp, r7
 8015c6a:	b00f      	add	sp, #60	; 0x3c
 8015c6c:	bd90      	pop	{r4, r7, pc}
	...

08015c70 <PrepareB0>:
 * \param[IN]  fCnt           - Frame counter
 * \param[IN/OUT]  b0         - B0 block
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t PrepareB0( uint16_t msgLen, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint8_t* b0 )
{
 8015c70:	b5b0      	push	{r4, r5, r7, lr}
 8015c72:	b084      	sub	sp, #16
 8015c74:	af00      	add	r7, sp, #0
 8015c76:	0005      	movs	r5, r0
 8015c78:	000c      	movs	r4, r1
 8015c7a:	0010      	movs	r0, r2
 8015c7c:	0019      	movs	r1, r3
 8015c7e:	1dbb      	adds	r3, r7, #6
 8015c80:	1c2a      	adds	r2, r5, #0
 8015c82:	801a      	strh	r2, [r3, #0]
 8015c84:	1d7b      	adds	r3, r7, #5
 8015c86:	1c22      	adds	r2, r4, #0
 8015c88:	701a      	strb	r2, [r3, #0]
 8015c8a:	1d3b      	adds	r3, r7, #4
 8015c8c:	1c02      	adds	r2, r0, #0
 8015c8e:	701a      	strb	r2, [r3, #0]
 8015c90:	1cfb      	adds	r3, r7, #3
 8015c92:	1c0a      	adds	r2, r1, #0
 8015c94:	701a      	strb	r2, [r3, #0]
    if( b0 == 0 )
 8015c96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015c98:	2b00      	cmp	r3, #0
 8015c9a:	d101      	bne.n	8015ca0 <PrepareB0+0x30>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 8015c9c:	230a      	movs	r3, #10
 8015c9e:	e070      	b.n	8015d82 <PrepareB0+0x112>
    }

    b0[0] = 0x49;
 8015ca0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015ca2:	2249      	movs	r2, #73	; 0x49
 8015ca4:	701a      	strb	r2, [r3, #0]

    if( ( isAck == true ) && ( dir == DOWNLINK ) )
 8015ca6:	1d3b      	adds	r3, r7, #4
 8015ca8:	781b      	ldrb	r3, [r3, #0]
 8015caa:	2b00      	cmp	r3, #0
 8015cac:	d01b      	beq.n	8015ce6 <PrepareB0+0x76>
 8015cae:	1cfb      	adds	r3, r7, #3
 8015cb0:	781b      	ldrb	r3, [r3, #0]
 8015cb2:	2b01      	cmp	r3, #1
 8015cb4:	d117      	bne.n	8015ce6 <PrepareB0+0x76>
    {
        // confFCnt contains the frame counter value modulo 2^16 of the "confirmed" uplink or downlink frame that is being acknowledged
        uint16_t confFCnt = 0;
 8015cb6:	210e      	movs	r1, #14
 8015cb8:	187b      	adds	r3, r7, r1
 8015cba:	2200      	movs	r2, #0
 8015cbc:	801a      	strh	r2, [r3, #0]

        confFCnt = ( uint16_t )( CryptoCtx.NvmCtx->FCntList.FCntUp % 65536 );
 8015cbe:	4b33      	ldr	r3, [pc, #204]	; (8015d8c <PrepareB0+0x11c>)
 8015cc0:	685b      	ldr	r3, [r3, #4]
 8015cc2:	68da      	ldr	r2, [r3, #12]
 8015cc4:	187b      	adds	r3, r7, r1
 8015cc6:	801a      	strh	r2, [r3, #0]

        b0[1] = confFCnt & 0xFF;
 8015cc8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015cca:	3301      	adds	r3, #1
 8015ccc:	187a      	adds	r2, r7, r1
 8015cce:	8812      	ldrh	r2, [r2, #0]
 8015cd0:	b2d2      	uxtb	r2, r2
 8015cd2:	701a      	strb	r2, [r3, #0]
        b0[2] = ( confFCnt >> 8 ) & 0xFF;
 8015cd4:	187b      	adds	r3, r7, r1
 8015cd6:	881b      	ldrh	r3, [r3, #0]
 8015cd8:	0a1b      	lsrs	r3, r3, #8
 8015cda:	b29a      	uxth	r2, r3
 8015cdc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015cde:	3302      	adds	r3, #2
 8015ce0:	b2d2      	uxtb	r2, r2
 8015ce2:	701a      	strb	r2, [r3, #0]
    {
 8015ce4:	e007      	b.n	8015cf6 <PrepareB0+0x86>
    }
    else
    {
        b0[1] = 0x00;
 8015ce6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015ce8:	3301      	adds	r3, #1
 8015cea:	2200      	movs	r2, #0
 8015cec:	701a      	strb	r2, [r3, #0]
        b0[2] = 0x00;
 8015cee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015cf0:	3302      	adds	r3, #2
 8015cf2:	2200      	movs	r2, #0
 8015cf4:	701a      	strb	r2, [r3, #0]
    }

    b0[3] = 0x00;
 8015cf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015cf8:	3303      	adds	r3, #3
 8015cfa:	2200      	movs	r2, #0
 8015cfc:	701a      	strb	r2, [r3, #0]
    b0[4] = 0x00;
 8015cfe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d00:	3304      	adds	r3, #4
 8015d02:	2200      	movs	r2, #0
 8015d04:	701a      	strb	r2, [r3, #0]

    b0[5] = dir;
 8015d06:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d08:	3305      	adds	r3, #5
 8015d0a:	1cfa      	adds	r2, r7, #3
 8015d0c:	7812      	ldrb	r2, [r2, #0]
 8015d0e:	701a      	strb	r2, [r3, #0]

    b0[6] = devAddr & 0xFF;
 8015d10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d12:	3306      	adds	r3, #6
 8015d14:	6a3a      	ldr	r2, [r7, #32]
 8015d16:	b2d2      	uxtb	r2, r2
 8015d18:	701a      	strb	r2, [r3, #0]
    b0[7] = ( devAddr >> 8 ) & 0xFF;
 8015d1a:	6a3b      	ldr	r3, [r7, #32]
 8015d1c:	0a1a      	lsrs	r2, r3, #8
 8015d1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d20:	3307      	adds	r3, #7
 8015d22:	b2d2      	uxtb	r2, r2
 8015d24:	701a      	strb	r2, [r3, #0]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8015d26:	6a3b      	ldr	r3, [r7, #32]
 8015d28:	0c1a      	lsrs	r2, r3, #16
 8015d2a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d2c:	3308      	adds	r3, #8
 8015d2e:	b2d2      	uxtb	r2, r2
 8015d30:	701a      	strb	r2, [r3, #0]
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8015d32:	6a3b      	ldr	r3, [r7, #32]
 8015d34:	0e1a      	lsrs	r2, r3, #24
 8015d36:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d38:	3309      	adds	r3, #9
 8015d3a:	b2d2      	uxtb	r2, r2
 8015d3c:	701a      	strb	r2, [r3, #0]

    b0[10] = fCnt & 0xFF;
 8015d3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d40:	330a      	adds	r3, #10
 8015d42:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015d44:	b2d2      	uxtb	r2, r2
 8015d46:	701a      	strb	r2, [r3, #0]
    b0[11] = ( fCnt >> 8 ) & 0xFF;
 8015d48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015d4a:	0a1a      	lsrs	r2, r3, #8
 8015d4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d4e:	330b      	adds	r3, #11
 8015d50:	b2d2      	uxtb	r2, r2
 8015d52:	701a      	strb	r2, [r3, #0]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8015d54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015d56:	0c1a      	lsrs	r2, r3, #16
 8015d58:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d5a:	330c      	adds	r3, #12
 8015d5c:	b2d2      	uxtb	r2, r2
 8015d5e:	701a      	strb	r2, [r3, #0]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8015d60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015d62:	0e1a      	lsrs	r2, r3, #24
 8015d64:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d66:	330d      	adds	r3, #13
 8015d68:	b2d2      	uxtb	r2, r2
 8015d6a:	701a      	strb	r2, [r3, #0]

    b0[14] = 0x00;
 8015d6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d6e:	330e      	adds	r3, #14
 8015d70:	2200      	movs	r2, #0
 8015d72:	701a      	strb	r2, [r3, #0]

    b0[15] = msgLen & 0xFF;
 8015d74:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d76:	330f      	adds	r3, #15
 8015d78:	1dba      	adds	r2, r7, #6
 8015d7a:	8812      	ldrh	r2, [r2, #0]
 8015d7c:	b2d2      	uxtb	r2, r2
 8015d7e:	701a      	strb	r2, [r3, #0]

    return LORAMAC_CRYPTO_SUCCESS;
 8015d80:	2300      	movs	r3, #0
}
 8015d82:	0018      	movs	r0, r3
 8015d84:	46bd      	mov	sp, r7
 8015d86:	b004      	add	sp, #16
 8015d88:	bdb0      	pop	{r4, r5, r7, pc}
 8015d8a:	46c0      	nop			; (mov r8, r8)
 8015d8c:	20001080 	.word	0x20001080

08015d90 <ComputeCmacB0>:
 * \param[IN]  fCnt           - Frame counter
 * \param[OUT] cmac           - Computed cmac
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t ComputeCmacB0( uint8_t* msg, uint16_t len, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint32_t* cmac )
{
 8015d90:	b5b0      	push	{r4, r5, r7, lr}
 8015d92:	b08a      	sub	sp, #40	; 0x28
 8015d94:	af04      	add	r7, sp, #16
 8015d96:	6078      	str	r0, [r7, #4]
 8015d98:	000c      	movs	r4, r1
 8015d9a:	0010      	movs	r0, r2
 8015d9c:	0019      	movs	r1, r3
 8015d9e:	1cbb      	adds	r3, r7, #2
 8015da0:	1c22      	adds	r2, r4, #0
 8015da2:	801a      	strh	r2, [r3, #0]
 8015da4:	1c7b      	adds	r3, r7, #1
 8015da6:	1c02      	adds	r2, r0, #0
 8015da8:	701a      	strb	r2, [r3, #0]
 8015daa:	003b      	movs	r3, r7
 8015dac:	1c0a      	adds	r2, r1, #0
 8015dae:	701a      	strb	r2, [r3, #0]
    if( ( msg == 0 ) || ( cmac == 0 ) )
 8015db0:	687b      	ldr	r3, [r7, #4]
 8015db2:	2b00      	cmp	r3, #0
 8015db4:	d002      	beq.n	8015dbc <ComputeCmacB0+0x2c>
 8015db6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015db8:	2b00      	cmp	r3, #0
 8015dba:	d101      	bne.n	8015dc0 <ComputeCmacB0+0x30>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 8015dbc:	230a      	movs	r3, #10
 8015dbe:	e02a      	b.n	8015e16 <ComputeCmacB0+0x86>
    }
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 8015dc0:	1cbb      	adds	r3, r7, #2
 8015dc2:	881a      	ldrh	r2, [r3, #0]
 8015dc4:	2380      	movs	r3, #128	; 0x80
 8015dc6:	005b      	lsls	r3, r3, #1
 8015dc8:	429a      	cmp	r2, r3
 8015dca:	d901      	bls.n	8015dd0 <ComputeCmacB0+0x40>
    {
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 8015dcc:	230e      	movs	r3, #14
 8015dce:	e022      	b.n	8015e16 <ComputeCmacB0+0x86>
    }

    uint8_t micBuff[MIC_BLOCK_BX_SIZE];

    // Initialize the first Block
    PrepareB0( len, keyID, isAck, dir, devAddr, fCnt, micBuff );
 8015dd0:	2328      	movs	r3, #40	; 0x28
 8015dd2:	18fb      	adds	r3, r7, r3
 8015dd4:	781c      	ldrb	r4, [r3, #0]
 8015dd6:	003b      	movs	r3, r7
 8015dd8:	781a      	ldrb	r2, [r3, #0]
 8015dda:	1c7b      	adds	r3, r7, #1
 8015ddc:	7819      	ldrb	r1, [r3, #0]
 8015dde:	1cbb      	adds	r3, r7, #2
 8015de0:	8818      	ldrh	r0, [r3, #0]
 8015de2:	2508      	movs	r5, #8
 8015de4:	197b      	adds	r3, r7, r5
 8015de6:	9302      	str	r3, [sp, #8]
 8015de8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015dea:	9301      	str	r3, [sp, #4]
 8015dec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015dee:	9300      	str	r3, [sp, #0]
 8015df0:	0023      	movs	r3, r4
 8015df2:	f7ff ff3d 	bl	8015c70 <PrepareB0>

    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 8015df6:	1c7b      	adds	r3, r7, #1
 8015df8:	781c      	ldrb	r4, [r3, #0]
 8015dfa:	1cbb      	adds	r3, r7, #2
 8015dfc:	881a      	ldrh	r2, [r3, #0]
 8015dfe:	6879      	ldr	r1, [r7, #4]
 8015e00:	1978      	adds	r0, r7, r5
 8015e02:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015e04:	9300      	str	r3, [sp, #0]
 8015e06:	0023      	movs	r3, r4
 8015e08:	f7f9 fa4e 	bl	800f2a8 <SecureElementComputeAesCmac>
 8015e0c:	1e03      	subs	r3, r0, #0
 8015e0e:	d001      	beq.n	8015e14 <ComputeCmacB0+0x84>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8015e10:	230f      	movs	r3, #15
 8015e12:	e000      	b.n	8015e16 <ComputeCmacB0+0x86>
    }
    return LORAMAC_CRYPTO_SUCCESS;
 8015e14:	2300      	movs	r3, #0
}
 8015e16:	0018      	movs	r0, r3
 8015e18:	46bd      	mov	sp, r7
 8015e1a:	b006      	add	sp, #24
 8015e1c:	bdb0      	pop	{r4, r5, r7, pc}
	...

08015e20 <VerifyCmacB0>:
 * \param[IN]  fCnt           - Frame counter
 * \param[in]  expectedCmac   - Expected cmac
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t VerifyCmacB0( uint8_t* msg, uint16_t len, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint32_t expectedCmac )
{
 8015e20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015e22:	b0cd      	sub	sp, #308	; 0x134
 8015e24:	af04      	add	r7, sp, #16
 8015e26:	6078      	str	r0, [r7, #4]
 8015e28:	000c      	movs	r4, r1
 8015e2a:	0010      	movs	r0, r2
 8015e2c:	0019      	movs	r1, r3
 8015e2e:	4b52      	ldr	r3, [pc, #328]	; (8015f78 <VerifyCmacB0+0x158>)
 8015e30:	2290      	movs	r2, #144	; 0x90
 8015e32:	0052      	lsls	r2, r2, #1
 8015e34:	4694      	mov	ip, r2
 8015e36:	44bc      	add	ip, r7
 8015e38:	4463      	add	r3, ip
 8015e3a:	1c22      	adds	r2, r4, #0
 8015e3c:	801a      	strh	r2, [r3, #0]
 8015e3e:	4b4f      	ldr	r3, [pc, #316]	; (8015f7c <VerifyCmacB0+0x15c>)
 8015e40:	2290      	movs	r2, #144	; 0x90
 8015e42:	0052      	lsls	r2, r2, #1
 8015e44:	4694      	mov	ip, r2
 8015e46:	44bc      	add	ip, r7
 8015e48:	4463      	add	r3, ip
 8015e4a:	1c02      	adds	r2, r0, #0
 8015e4c:	701a      	strb	r2, [r3, #0]
 8015e4e:	4b4c      	ldr	r3, [pc, #304]	; (8015f80 <VerifyCmacB0+0x160>)
 8015e50:	2290      	movs	r2, #144	; 0x90
 8015e52:	0052      	lsls	r2, r2, #1
 8015e54:	4694      	mov	ip, r2
 8015e56:	44bc      	add	ip, r7
 8015e58:	4463      	add	r3, ip
 8015e5a:	1c0a      	adds	r2, r1, #0
 8015e5c:	701a      	strb	r2, [r3, #0]
    if( msg == 0 )
 8015e5e:	687b      	ldr	r3, [r7, #4]
 8015e60:	2b00      	cmp	r3, #0
 8015e62:	d101      	bne.n	8015e68 <VerifyCmacB0+0x48>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 8015e64:	230a      	movs	r3, #10
 8015e66:	e083      	b.n	8015f70 <VerifyCmacB0+0x150>
    }
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 8015e68:	4b43      	ldr	r3, [pc, #268]	; (8015f78 <VerifyCmacB0+0x158>)
 8015e6a:	2290      	movs	r2, #144	; 0x90
 8015e6c:	0052      	lsls	r2, r2, #1
 8015e6e:	4694      	mov	ip, r2
 8015e70:	44bc      	add	ip, r7
 8015e72:	4463      	add	r3, ip
 8015e74:	881a      	ldrh	r2, [r3, #0]
 8015e76:	2380      	movs	r3, #128	; 0x80
 8015e78:	005b      	lsls	r3, r3, #1
 8015e7a:	429a      	cmp	r2, r3
 8015e7c:	d901      	bls.n	8015e82 <VerifyCmacB0+0x62>
    {
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 8015e7e:	230e      	movs	r3, #14
 8015e80:	e076      	b.n	8015f70 <VerifyCmacB0+0x150>
    }

    uint8_t micBuff[CRYPTO_BUFFER_SIZE];
    memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );
 8015e82:	2388      	movs	r3, #136	; 0x88
 8015e84:	005a      	lsls	r2, r3, #1
 8015e86:	250c      	movs	r5, #12
 8015e88:	197b      	adds	r3, r7, r5
 8015e8a:	2100      	movs	r1, #0
 8015e8c:	0018      	movs	r0, r3
 8015e8e:	f005 fb99 	bl	801b5c4 <memset1>

    // Initialize the first Block
    PrepareB0( len, keyID, isAck, dir, devAddr, fCnt, micBuff );
 8015e92:	2398      	movs	r3, #152	; 0x98
 8015e94:	005b      	lsls	r3, r3, #1
 8015e96:	2208      	movs	r2, #8
 8015e98:	4694      	mov	ip, r2
 8015e9a:	44bc      	add	ip, r7
 8015e9c:	4463      	add	r3, ip
 8015e9e:	781c      	ldrb	r4, [r3, #0]
 8015ea0:	4b37      	ldr	r3, [pc, #220]	; (8015f80 <VerifyCmacB0+0x160>)
 8015ea2:	2290      	movs	r2, #144	; 0x90
 8015ea4:	0052      	lsls	r2, r2, #1
 8015ea6:	4694      	mov	ip, r2
 8015ea8:	44bc      	add	ip, r7
 8015eaa:	4463      	add	r3, ip
 8015eac:	781a      	ldrb	r2, [r3, #0]
 8015eae:	4b33      	ldr	r3, [pc, #204]	; (8015f7c <VerifyCmacB0+0x15c>)
 8015eb0:	2190      	movs	r1, #144	; 0x90
 8015eb2:	0049      	lsls	r1, r1, #1
 8015eb4:	468c      	mov	ip, r1
 8015eb6:	44bc      	add	ip, r7
 8015eb8:	4463      	add	r3, ip
 8015eba:	7819      	ldrb	r1, [r3, #0]
 8015ebc:	4b2e      	ldr	r3, [pc, #184]	; (8015f78 <VerifyCmacB0+0x158>)
 8015ebe:	2090      	movs	r0, #144	; 0x90
 8015ec0:	0040      	lsls	r0, r0, #1
 8015ec2:	4684      	mov	ip, r0
 8015ec4:	44bc      	add	ip, r7
 8015ec6:	4463      	add	r3, ip
 8015ec8:	8818      	ldrh	r0, [r3, #0]
 8015eca:	197b      	adds	r3, r7, r5
 8015ecc:	9302      	str	r3, [sp, #8]
 8015ece:	239c      	movs	r3, #156	; 0x9c
 8015ed0:	005b      	lsls	r3, r3, #1
 8015ed2:	2608      	movs	r6, #8
 8015ed4:	46b4      	mov	ip, r6
 8015ed6:	44bc      	add	ip, r7
 8015ed8:	4463      	add	r3, ip
 8015eda:	681b      	ldr	r3, [r3, #0]
 8015edc:	9301      	str	r3, [sp, #4]
 8015ede:	239a      	movs	r3, #154	; 0x9a
 8015ee0:	005b      	lsls	r3, r3, #1
 8015ee2:	2608      	movs	r6, #8
 8015ee4:	46b4      	mov	ip, r6
 8015ee6:	44bc      	add	ip, r7
 8015ee8:	4463      	add	r3, ip
 8015eea:	681b      	ldr	r3, [r3, #0]
 8015eec:	9300      	str	r3, [sp, #0]
 8015eee:	0023      	movs	r3, r4
 8015ef0:	f7ff febe 	bl	8015c70 <PrepareB0>

    // Copy the given data to the mic computation buffer
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8015ef4:	197b      	adds	r3, r7, r5
 8015ef6:	3310      	adds	r3, #16
 8015ef8:	4a1f      	ldr	r2, [pc, #124]	; (8015f78 <VerifyCmacB0+0x158>)
 8015efa:	2190      	movs	r1, #144	; 0x90
 8015efc:	0049      	lsls	r1, r1, #1
 8015efe:	468c      	mov	ip, r1
 8015f00:	44bc      	add	ip, r7
 8015f02:	4462      	add	r2, ip
 8015f04:	8812      	ldrh	r2, [r2, #0]
 8015f06:	6879      	ldr	r1, [r7, #4]
 8015f08:	0018      	movs	r0, r3
 8015f0a:	f005 fb1d 	bl	801b548 <memcpy1>

    SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
 8015f0e:	2620      	movs	r6, #32
 8015f10:	36ff      	adds	r6, #255	; 0xff
 8015f12:	19bb      	adds	r3, r7, r6
 8015f14:	2206      	movs	r2, #6
 8015f16:	701a      	strb	r2, [r3, #0]
    retval = SecureElementVerifyAesCmac( micBuff, ( len + MIC_BLOCK_BX_SIZE ), expectedCmac, keyID );
 8015f18:	4b17      	ldr	r3, [pc, #92]	; (8015f78 <VerifyCmacB0+0x158>)
 8015f1a:	2290      	movs	r2, #144	; 0x90
 8015f1c:	0052      	lsls	r2, r2, #1
 8015f1e:	4694      	mov	ip, r2
 8015f20:	44bc      	add	ip, r7
 8015f22:	4463      	add	r3, ip
 8015f24:	881b      	ldrh	r3, [r3, #0]
 8015f26:	3310      	adds	r3, #16
 8015f28:	b299      	uxth	r1, r3
 8015f2a:	19bc      	adds	r4, r7, r6
 8015f2c:	4b13      	ldr	r3, [pc, #76]	; (8015f7c <VerifyCmacB0+0x15c>)
 8015f2e:	2290      	movs	r2, #144	; 0x90
 8015f30:	0052      	lsls	r2, r2, #1
 8015f32:	4694      	mov	ip, r2
 8015f34:	44bc      	add	ip, r7
 8015f36:	4463      	add	r3, ip
 8015f38:	781b      	ldrb	r3, [r3, #0]
 8015f3a:	229e      	movs	r2, #158	; 0x9e
 8015f3c:	0052      	lsls	r2, r2, #1
 8015f3e:	2008      	movs	r0, #8
 8015f40:	4684      	mov	ip, r0
 8015f42:	44bc      	add	ip, r7
 8015f44:	4462      	add	r2, ip
 8015f46:	6812      	ldr	r2, [r2, #0]
 8015f48:	1978      	adds	r0, r7, r5
 8015f4a:	f7f9 f9ce 	bl	800f2ea <SecureElementVerifyAesCmac>
 8015f4e:	0003      	movs	r3, r0
 8015f50:	7023      	strb	r3, [r4, #0]

    if( retval == SECURE_ELEMENT_SUCCESS )
 8015f52:	19bb      	adds	r3, r7, r6
 8015f54:	781b      	ldrb	r3, [r3, #0]
 8015f56:	2b00      	cmp	r3, #0
 8015f58:	d101      	bne.n	8015f5e <VerifyCmacB0+0x13e>
    {
        return LORAMAC_CRYPTO_SUCCESS;
 8015f5a:	2300      	movs	r3, #0
 8015f5c:	e008      	b.n	8015f70 <VerifyCmacB0+0x150>
    }
    else if( retval == SECURE_ELEMENT_FAIL_CMAC )
 8015f5e:	2320      	movs	r3, #32
 8015f60:	33ff      	adds	r3, #255	; 0xff
 8015f62:	18fb      	adds	r3, r7, r3
 8015f64:	781b      	ldrb	r3, [r3, #0]
 8015f66:	2b01      	cmp	r3, #1
 8015f68:	d101      	bne.n	8015f6e <VerifyCmacB0+0x14e>
    {
        return LORAMAC_CRYPTO_FAIL_MIC;
 8015f6a:	2301      	movs	r3, #1
 8015f6c:	e000      	b.n	8015f70 <VerifyCmacB0+0x150>
    }

    return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8015f6e:	230f      	movs	r3, #15
}
 8015f70:	0018      	movs	r0, r3
 8015f72:	46bd      	mov	sp, r7
 8015f74:	b049      	add	sp, #292	; 0x124
 8015f76:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015f78:	fffffee2 	.word	0xfffffee2
 8015f7c:	fffffee1 	.word	0xfffffee1
 8015f80:	fffffee0 	.word	0xfffffee0

08015f84 <GetKeyAddrItem>:
 * \param[IN]  addrID          - Address identifier
 * \param[OUT] keyItem        - Key item reference
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t GetKeyAddrItem( AddressIdentifier_t addrID, KeyAddr_t** item )
{
 8015f84:	b580      	push	{r7, lr}
 8015f86:	b084      	sub	sp, #16
 8015f88:	af00      	add	r7, sp, #0
 8015f8a:	0002      	movs	r2, r0
 8015f8c:	6039      	str	r1, [r7, #0]
 8015f8e:	1dfb      	adds	r3, r7, #7
 8015f90:	701a      	strb	r2, [r3, #0]
    for( uint8_t i = 0; i < NUM_OF_SEC_CTX; i++ )
 8015f92:	230f      	movs	r3, #15
 8015f94:	18fb      	adds	r3, r7, r3
 8015f96:	2200      	movs	r2, #0
 8015f98:	701a      	strb	r2, [r3, #0]
 8015f9a:	e018      	b.n	8015fce <GetKeyAddrItem+0x4a>
    {
        if( KeyAddrList[i].AddrID == addrID )
 8015f9c:	210f      	movs	r1, #15
 8015f9e:	187b      	adds	r3, r7, r1
 8015fa0:	781a      	ldrb	r2, [r3, #0]
 8015fa2:	4b10      	ldr	r3, [pc, #64]	; (8015fe4 <GetKeyAddrItem+0x60>)
 8015fa4:	0092      	lsls	r2, r2, #2
 8015fa6:	5cd3      	ldrb	r3, [r2, r3]
 8015fa8:	1dfa      	adds	r2, r7, #7
 8015faa:	7812      	ldrb	r2, [r2, #0]
 8015fac:	429a      	cmp	r2, r3
 8015fae:	d108      	bne.n	8015fc2 <GetKeyAddrItem+0x3e>
        {
            *item = &( KeyAddrList[i] );
 8015fb0:	187b      	adds	r3, r7, r1
 8015fb2:	781b      	ldrb	r3, [r3, #0]
 8015fb4:	009a      	lsls	r2, r3, #2
 8015fb6:	4b0b      	ldr	r3, [pc, #44]	; (8015fe4 <GetKeyAddrItem+0x60>)
 8015fb8:	18d2      	adds	r2, r2, r3
 8015fba:	683b      	ldr	r3, [r7, #0]
 8015fbc:	601a      	str	r2, [r3, #0]
            return LORAMAC_CRYPTO_SUCCESS;
 8015fbe:	2300      	movs	r3, #0
 8015fc0:	e00b      	b.n	8015fda <GetKeyAddrItem+0x56>
    for( uint8_t i = 0; i < NUM_OF_SEC_CTX; i++ )
 8015fc2:	210f      	movs	r1, #15
 8015fc4:	187b      	adds	r3, r7, r1
 8015fc6:	781a      	ldrb	r2, [r3, #0]
 8015fc8:	187b      	adds	r3, r7, r1
 8015fca:	3201      	adds	r2, #1
 8015fcc:	701a      	strb	r2, [r3, #0]
 8015fce:	230f      	movs	r3, #15
 8015fd0:	18fb      	adds	r3, r7, r3
 8015fd2:	781b      	ldrb	r3, [r3, #0]
 8015fd4:	2b04      	cmp	r3, #4
 8015fd6:	d9e1      	bls.n	8015f9c <GetKeyAddrItem+0x18>
        }
    }
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 8015fd8:	230c      	movs	r3, #12
}
 8015fda:	0018      	movs	r0, r3
 8015fdc:	46bd      	mov	sp, r7
 8015fde:	b004      	add	sp, #16
 8015fe0:	bd80      	pop	{r7, pc}
 8015fe2:	46c0      	nop			; (mov r8, r8)
 8015fe4:	2000018c 	.word	0x2000018c

08015fe8 <DeriveSessionKey10x>:
 * \param[IN]  netID          - Network Identifier
 * \param[IN]  deviceNonce    - Device nonce
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t DeriveSessionKey10x( KeyIdentifier_t keyID, uint8_t* joinNonce, uint8_t* netID, uint8_t* devNonce )
{
 8015fe8:	b590      	push	{r4, r7, lr}
 8015fea:	b089      	sub	sp, #36	; 0x24
 8015fec:	af00      	add	r7, sp, #0
 8015fee:	60b9      	str	r1, [r7, #8]
 8015ff0:	607a      	str	r2, [r7, #4]
 8015ff2:	603b      	str	r3, [r7, #0]
 8015ff4:	230f      	movs	r3, #15
 8015ff6:	18fb      	adds	r3, r7, r3
 8015ff8:	1c02      	adds	r2, r0, #0
 8015ffa:	701a      	strb	r2, [r3, #0]
    if( ( joinNonce == 0 ) || ( netID == 0 ) || ( devNonce == 0 ) )
 8015ffc:	68bb      	ldr	r3, [r7, #8]
 8015ffe:	2b00      	cmp	r3, #0
 8016000:	d005      	beq.n	801600e <DeriveSessionKey10x+0x26>
 8016002:	687b      	ldr	r3, [r7, #4]
 8016004:	2b00      	cmp	r3, #0
 8016006:	d002      	beq.n	801600e <DeriveSessionKey10x+0x26>
 8016008:	683b      	ldr	r3, [r7, #0]
 801600a:	2b00      	cmp	r3, #0
 801600c:	d101      	bne.n	8016012 <DeriveSessionKey10x+0x2a>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 801600e:	230a      	movs	r3, #10
 8016010:	e046      	b.n	80160a0 <DeriveSessionKey10x+0xb8>
    }

    uint8_t compBase[16] = { 0 };
 8016012:	2310      	movs	r3, #16
 8016014:	18fb      	adds	r3, r7, r3
 8016016:	2200      	movs	r2, #0
 8016018:	601a      	str	r2, [r3, #0]
 801601a:	3304      	adds	r3, #4
 801601c:	220c      	movs	r2, #12
 801601e:	2100      	movs	r1, #0
 8016020:	0018      	movs	r0, r3
 8016022:	f007 fa97 	bl	801d554 <memset>

    switch( keyID )
 8016026:	230f      	movs	r3, #15
 8016028:	18fb      	adds	r3, r7, r3
 801602a:	781b      	ldrb	r3, [r3, #0]
 801602c:	2b07      	cmp	r3, #7
 801602e:	dc02      	bgt.n	8016036 <DeriveSessionKey10x+0x4e>
 8016030:	2b05      	cmp	r3, #5
 8016032:	da03      	bge.n	801603c <DeriveSessionKey10x+0x54>
 8016034:	e00c      	b.n	8016050 <DeriveSessionKey10x+0x68>
 8016036:	2b08      	cmp	r3, #8
 8016038:	d005      	beq.n	8016046 <DeriveSessionKey10x+0x5e>
 801603a:	e009      	b.n	8016050 <DeriveSessionKey10x+0x68>
    {
        case F_NWK_S_INT_KEY:
        case S_NWK_S_INT_KEY:
        case NWK_S_ENC_KEY:
            compBase[0] = 0x01;
 801603c:	2310      	movs	r3, #16
 801603e:	18fb      	adds	r3, r7, r3
 8016040:	2201      	movs	r2, #1
 8016042:	701a      	strb	r2, [r3, #0]
            break;
 8016044:	e006      	b.n	8016054 <DeriveSessionKey10x+0x6c>
        case APP_S_KEY:
            compBase[0] = 0x02;
 8016046:	2310      	movs	r3, #16
 8016048:	18fb      	adds	r3, r7, r3
 801604a:	2202      	movs	r2, #2
 801604c:	701a      	strb	r2, [r3, #0]
            break;
 801604e:	e001      	b.n	8016054 <DeriveSessionKey10x+0x6c>
        default:
            return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
 8016050:	230b      	movs	r3, #11
 8016052:	e025      	b.n	80160a0 <DeriveSessionKey10x+0xb8>
    }

    memcpy1( compBase + 1, joinNonce, 3 );
 8016054:	2410      	movs	r4, #16
 8016056:	193b      	adds	r3, r7, r4
 8016058:	3301      	adds	r3, #1
 801605a:	68b9      	ldr	r1, [r7, #8]
 801605c:	2203      	movs	r2, #3
 801605e:	0018      	movs	r0, r3
 8016060:	f005 fa72 	bl	801b548 <memcpy1>
    memcpy1( compBase + 4, netID, 3 );
 8016064:	193b      	adds	r3, r7, r4
 8016066:	3304      	adds	r3, #4
 8016068:	6879      	ldr	r1, [r7, #4]
 801606a:	2203      	movs	r2, #3
 801606c:	0018      	movs	r0, r3
 801606e:	f005 fa6b 	bl	801b548 <memcpy1>
    memcpy1( compBase + 7, devNonce, 2 );
 8016072:	193b      	adds	r3, r7, r4
 8016074:	3307      	adds	r3, #7
 8016076:	6839      	ldr	r1, [r7, #0]
 8016078:	2202      	movs	r2, #2
 801607a:	0018      	movs	r0, r3
 801607c:	f005 fa64 	bl	801b548 <memcpy1>

    if( SecureElementDeriveAndStoreKey( CryptoCtx.NvmCtx->LrWanVersion, compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8016080:	4b09      	ldr	r3, [pc, #36]	; (80160a8 <DeriveSessionKey10x+0xc0>)
 8016082:	685b      	ldr	r3, [r3, #4]
 8016084:	220f      	movs	r2, #15
 8016086:	18ba      	adds	r2, r7, r2
 8016088:	7812      	ldrb	r2, [r2, #0]
 801608a:	1939      	adds	r1, r7, r4
 801608c:	6818      	ldr	r0, [r3, #0]
 801608e:	0013      	movs	r3, r2
 8016090:	2202      	movs	r2, #2
 8016092:	f7f9 f9d5 	bl	800f440 <SecureElementDeriveAndStoreKey>
 8016096:	1e03      	subs	r3, r0, #0
 8016098:	d001      	beq.n	801609e <DeriveSessionKey10x+0xb6>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 801609a:	230f      	movs	r3, #15
 801609c:	e000      	b.n	80160a0 <DeriveSessionKey10x+0xb8>
    }

    return LORAMAC_CRYPTO_SUCCESS;
 801609e:	2300      	movs	r3, #0
}
 80160a0:	0018      	movs	r0, r3
 80160a2:	46bd      	mov	sp, r7
 80160a4:	b009      	add	sp, #36	; 0x24
 80160a6:	bd90      	pop	{r4, r7, pc}
 80160a8:	20001080 	.word	0x20001080

080160ac <GetLastFcntDown>:
 * \param[IN]     lastDown     - Last downlink counter value
 *
 * \retval                     - Status of the operation
 */
static LoRaMacCryptoStatus_t GetLastFcntDown( FCntIdentifier_t fCntID, uint32_t* lastDown )
{
 80160ac:	b580      	push	{r7, lr}
 80160ae:	b082      	sub	sp, #8
 80160b0:	af00      	add	r7, sp, #0
 80160b2:	0002      	movs	r2, r0
 80160b4:	6039      	str	r1, [r7, #0]
 80160b6:	1dfb      	adds	r3, r7, #7
 80160b8:	701a      	strb	r2, [r3, #0]
    if( lastDown == NULL )
 80160ba:	683b      	ldr	r3, [r7, #0]
 80160bc:	2b00      	cmp	r3, #0
 80160be:	d101      	bne.n	80160c4 <GetLastFcntDown+0x18>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 80160c0:	230a      	movs	r3, #10
 80160c2:	e047      	b.n	8016154 <GetLastFcntDown+0xa8>
    }
    switch( fCntID )
 80160c4:	1dfb      	adds	r3, r7, #7
 80160c6:	781b      	ldrb	r3, [r3, #0]
 80160c8:	2b07      	cmp	r3, #7
 80160ca:	d840      	bhi.n	801614e <GetLastFcntDown+0xa2>
 80160cc:	009a      	lsls	r2, r3, #2
 80160ce:	4b23      	ldr	r3, [pc, #140]	; (801615c <GetLastFcntDown+0xb0>)
 80160d0:	18d3      	adds	r3, r2, r3
 80160d2:	681b      	ldr	r3, [r3, #0]
 80160d4:	469f      	mov	pc, r3
    {
        case N_FCNT_DOWN:
            *lastDown = CryptoCtx.NvmCtx->FCntList.NFCntDown;
 80160d6:	4b22      	ldr	r3, [pc, #136]	; (8016160 <GetLastFcntDown+0xb4>)
 80160d8:	685b      	ldr	r3, [r3, #4]
 80160da:	691a      	ldr	r2, [r3, #16]
 80160dc:	683b      	ldr	r3, [r7, #0]
 80160de:	601a      	str	r2, [r3, #0]
            CryptoCtx.NvmCtx->LastDownFCnt = &CryptoCtx.NvmCtx->FCntList.NFCntDown;
 80160e0:	4b1f      	ldr	r3, [pc, #124]	; (8016160 <GetLastFcntDown+0xb4>)
 80160e2:	685a      	ldr	r2, [r3, #4]
 80160e4:	4b1e      	ldr	r3, [pc, #120]	; (8016160 <GetLastFcntDown+0xb4>)
 80160e6:	685b      	ldr	r3, [r3, #4]
 80160e8:	3210      	adds	r2, #16
 80160ea:	631a      	str	r2, [r3, #48]	; 0x30
            break;
 80160ec:	e031      	b.n	8016152 <GetLastFcntDown+0xa6>
        case A_FCNT_DOWN:
            *lastDown = CryptoCtx.NvmCtx->FCntList.AFCntDown;
 80160ee:	4b1c      	ldr	r3, [pc, #112]	; (8016160 <GetLastFcntDown+0xb4>)
 80160f0:	685b      	ldr	r3, [r3, #4]
 80160f2:	695a      	ldr	r2, [r3, #20]
 80160f4:	683b      	ldr	r3, [r7, #0]
 80160f6:	601a      	str	r2, [r3, #0]
            CryptoCtx.NvmCtx->LastDownFCnt = &CryptoCtx.NvmCtx->FCntList.AFCntDown;
 80160f8:	4b19      	ldr	r3, [pc, #100]	; (8016160 <GetLastFcntDown+0xb4>)
 80160fa:	685a      	ldr	r2, [r3, #4]
 80160fc:	4b18      	ldr	r3, [pc, #96]	; (8016160 <GetLastFcntDown+0xb4>)
 80160fe:	685b      	ldr	r3, [r3, #4]
 8016100:	3214      	adds	r2, #20
 8016102:	631a      	str	r2, [r3, #48]	; 0x30
            break;
 8016104:	e025      	b.n	8016152 <GetLastFcntDown+0xa6>
        case FCNT_DOWN:
            *lastDown = CryptoCtx.NvmCtx->FCntList.FCntDown;
 8016106:	4b16      	ldr	r3, [pc, #88]	; (8016160 <GetLastFcntDown+0xb4>)
 8016108:	685b      	ldr	r3, [r3, #4]
 801610a:	699a      	ldr	r2, [r3, #24]
 801610c:	683b      	ldr	r3, [r7, #0]
 801610e:	601a      	str	r2, [r3, #0]
            CryptoCtx.NvmCtx->LastDownFCnt = &CryptoCtx.NvmCtx->FCntList.FCntDown;
 8016110:	4b13      	ldr	r3, [pc, #76]	; (8016160 <GetLastFcntDown+0xb4>)
 8016112:	685a      	ldr	r2, [r3, #4]
 8016114:	4b12      	ldr	r3, [pc, #72]	; (8016160 <GetLastFcntDown+0xb4>)
 8016116:	685b      	ldr	r3, [r3, #4]
 8016118:	3218      	adds	r2, #24
 801611a:	631a      	str	r2, [r3, #48]	; 0x30
            break;
 801611c:	e019      	b.n	8016152 <GetLastFcntDown+0xa6>
        case MC_FCNT_DOWN_0:
            *lastDown = CryptoCtx.NvmCtx->FCntList.McFCntDown0;
 801611e:	4b10      	ldr	r3, [pc, #64]	; (8016160 <GetLastFcntDown+0xb4>)
 8016120:	685b      	ldr	r3, [r3, #4]
 8016122:	69da      	ldr	r2, [r3, #28]
 8016124:	683b      	ldr	r3, [r7, #0]
 8016126:	601a      	str	r2, [r3, #0]
            break;
 8016128:	e013      	b.n	8016152 <GetLastFcntDown+0xa6>
        case MC_FCNT_DOWN_1:
            *lastDown = CryptoCtx.NvmCtx->FCntList.McFCntDown1;
 801612a:	4b0d      	ldr	r3, [pc, #52]	; (8016160 <GetLastFcntDown+0xb4>)
 801612c:	685b      	ldr	r3, [r3, #4]
 801612e:	6a1a      	ldr	r2, [r3, #32]
 8016130:	683b      	ldr	r3, [r7, #0]
 8016132:	601a      	str	r2, [r3, #0]
            break;
 8016134:	e00d      	b.n	8016152 <GetLastFcntDown+0xa6>
        case MC_FCNT_DOWN_2:
            *lastDown = CryptoCtx.NvmCtx->FCntList.McFCntDown2;
 8016136:	4b0a      	ldr	r3, [pc, #40]	; (8016160 <GetLastFcntDown+0xb4>)
 8016138:	685b      	ldr	r3, [r3, #4]
 801613a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801613c:	683b      	ldr	r3, [r7, #0]
 801613e:	601a      	str	r2, [r3, #0]
            break;
 8016140:	e007      	b.n	8016152 <GetLastFcntDown+0xa6>
        case MC_FCNT_DOWN_3:
            *lastDown = CryptoCtx.NvmCtx->FCntList.McFCntDown3;
 8016142:	4b07      	ldr	r3, [pc, #28]	; (8016160 <GetLastFcntDown+0xb4>)
 8016144:	685b      	ldr	r3, [r3, #4]
 8016146:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8016148:	683b      	ldr	r3, [r7, #0]
 801614a:	601a      	str	r2, [r3, #0]
            break;
 801614c:	e001      	b.n	8016152 <GetLastFcntDown+0xa6>
        default:
            return LORAMAC_CRYPTO_FAIL_FCNT_ID;
 801614e:	2305      	movs	r3, #5
 8016150:	e000      	b.n	8016154 <GetLastFcntDown+0xa8>
    }
    return LORAMAC_CRYPTO_SUCCESS;
 8016152:	2300      	movs	r3, #0
}
 8016154:	0018      	movs	r0, r3
 8016156:	46bd      	mov	sp, r7
 8016158:	b002      	add	sp, #8
 801615a:	bd80      	pop	{r7, pc}
 801615c:	0801f418 	.word	0x0801f418
 8016160:	20001080 	.word	0x20001080

08016164 <CheckFCntDown>:
 * \param[IN]     currentDown  - Current downlink counter value
 *
 * \retval                     - Status of the operation
 */
static bool CheckFCntDown( FCntIdentifier_t fCntID, uint32_t currentDown )
{
 8016164:	b580      	push	{r7, lr}
 8016166:	b084      	sub	sp, #16
 8016168:	af00      	add	r7, sp, #0
 801616a:	0002      	movs	r2, r0
 801616c:	6039      	str	r1, [r7, #0]
 801616e:	1dfb      	adds	r3, r7, #7
 8016170:	701a      	strb	r2, [r3, #0]
    uint32_t lastDown = 0;
 8016172:	2300      	movs	r3, #0
 8016174:	60fb      	str	r3, [r7, #12]
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 8016176:	230c      	movs	r3, #12
 8016178:	18fa      	adds	r2, r7, r3
 801617a:	1dfb      	adds	r3, r7, #7
 801617c:	781b      	ldrb	r3, [r3, #0]
 801617e:	0011      	movs	r1, r2
 8016180:	0018      	movs	r0, r3
 8016182:	f7ff ff93 	bl	80160ac <GetLastFcntDown>
 8016186:	1e03      	subs	r3, r0, #0
 8016188:	d001      	beq.n	801618e <CheckFCntDown+0x2a>
    {
        return false;
 801618a:	2300      	movs	r3, #0
 801618c:	e009      	b.n	80161a2 <CheckFCntDown+0x3e>
    }
    if( ( currentDown > lastDown ) ||
 801618e:	68fb      	ldr	r3, [r7, #12]
 8016190:	683a      	ldr	r2, [r7, #0]
 8016192:	429a      	cmp	r2, r3
 8016194:	d802      	bhi.n	801619c <CheckFCntDown+0x38>
        // For LoRaWAN 1.0.X only. Allow downlink frames of 0
        ( lastDown == FCNT_DOWN_INITAL_VALUE ) )
 8016196:	68fb      	ldr	r3, [r7, #12]
    if( ( currentDown > lastDown ) ||
 8016198:	3301      	adds	r3, #1
 801619a:	d101      	bne.n	80161a0 <CheckFCntDown+0x3c>
    {
        return true;
 801619c:	2301      	movs	r3, #1
 801619e:	e000      	b.n	80161a2 <CheckFCntDown+0x3e>
    }
    else
    {
        return false;
 80161a0:	2300      	movs	r3, #0
    }
}
 80161a2:	0018      	movs	r0, r3
 80161a4:	46bd      	mov	sp, r7
 80161a6:	b004      	add	sp, #16
 80161a8:	bd80      	pop	{r7, pc}
	...

080161ac <UpdateFCntDown>:
 * \param[IN]     currentDown   - Current downlink counter value
 *
 * \retval                     - Status of the operation
 */
static void UpdateFCntDown( FCntIdentifier_t fCntID, uint32_t currentDown )
{
 80161ac:	b580      	push	{r7, lr}
 80161ae:	b082      	sub	sp, #8
 80161b0:	af00      	add	r7, sp, #0
 80161b2:	0002      	movs	r2, r0
 80161b4:	6039      	str	r1, [r7, #0]
 80161b6:	1dfb      	adds	r3, r7, #7
 80161b8:	701a      	strb	r2, [r3, #0]
    switch( fCntID )
 80161ba:	1dfb      	adds	r3, r7, #7
 80161bc:	781b      	ldrb	r3, [r3, #0]
 80161be:	2b07      	cmp	r3, #7
 80161c0:	d827      	bhi.n	8016212 <UpdateFCntDown+0x66>
 80161c2:	009a      	lsls	r2, r3, #2
 80161c4:	4b17      	ldr	r3, [pc, #92]	; (8016224 <UpdateFCntDown+0x78>)
 80161c6:	18d3      	adds	r3, r2, r3
 80161c8:	681b      	ldr	r3, [r3, #0]
 80161ca:	469f      	mov	pc, r3
    {
        case N_FCNT_DOWN:
            CryptoCtx.NvmCtx->FCntList.NFCntDown = currentDown;
 80161cc:	4b16      	ldr	r3, [pc, #88]	; (8016228 <UpdateFCntDown+0x7c>)
 80161ce:	685b      	ldr	r3, [r3, #4]
 80161d0:	683a      	ldr	r2, [r7, #0]
 80161d2:	611a      	str	r2, [r3, #16]
            break;
 80161d4:	e01e      	b.n	8016214 <UpdateFCntDown+0x68>
        case A_FCNT_DOWN:
            CryptoCtx.NvmCtx->FCntList.AFCntDown = currentDown;
 80161d6:	4b14      	ldr	r3, [pc, #80]	; (8016228 <UpdateFCntDown+0x7c>)
 80161d8:	685b      	ldr	r3, [r3, #4]
 80161da:	683a      	ldr	r2, [r7, #0]
 80161dc:	615a      	str	r2, [r3, #20]
            break;
 80161de:	e019      	b.n	8016214 <UpdateFCntDown+0x68>
        case FCNT_DOWN:
            CryptoCtx.NvmCtx->FCntList.FCntDown = currentDown;
 80161e0:	4b11      	ldr	r3, [pc, #68]	; (8016228 <UpdateFCntDown+0x7c>)
 80161e2:	685b      	ldr	r3, [r3, #4]
 80161e4:	683a      	ldr	r2, [r7, #0]
 80161e6:	619a      	str	r2, [r3, #24]
            break;
 80161e8:	e014      	b.n	8016214 <UpdateFCntDown+0x68>
        case MC_FCNT_DOWN_0:
            CryptoCtx.NvmCtx->FCntList.McFCntDown0 = currentDown;
 80161ea:	4b0f      	ldr	r3, [pc, #60]	; (8016228 <UpdateFCntDown+0x7c>)
 80161ec:	685b      	ldr	r3, [r3, #4]
 80161ee:	683a      	ldr	r2, [r7, #0]
 80161f0:	61da      	str	r2, [r3, #28]
            break;
 80161f2:	e00f      	b.n	8016214 <UpdateFCntDown+0x68>
        case MC_FCNT_DOWN_1:
            CryptoCtx.NvmCtx->FCntList.McFCntDown1 = currentDown;
 80161f4:	4b0c      	ldr	r3, [pc, #48]	; (8016228 <UpdateFCntDown+0x7c>)
 80161f6:	685b      	ldr	r3, [r3, #4]
 80161f8:	683a      	ldr	r2, [r7, #0]
 80161fa:	621a      	str	r2, [r3, #32]
            break;
 80161fc:	e00a      	b.n	8016214 <UpdateFCntDown+0x68>
        case MC_FCNT_DOWN_2:
            CryptoCtx.NvmCtx->FCntList.McFCntDown2 = currentDown;
 80161fe:	4b0a      	ldr	r3, [pc, #40]	; (8016228 <UpdateFCntDown+0x7c>)
 8016200:	685b      	ldr	r3, [r3, #4]
 8016202:	683a      	ldr	r2, [r7, #0]
 8016204:	625a      	str	r2, [r3, #36]	; 0x24
            break;
 8016206:	e005      	b.n	8016214 <UpdateFCntDown+0x68>
        case MC_FCNT_DOWN_3:
            CryptoCtx.NvmCtx->FCntList.McFCntDown3 = currentDown;
 8016208:	4b07      	ldr	r3, [pc, #28]	; (8016228 <UpdateFCntDown+0x7c>)
 801620a:	685b      	ldr	r3, [r3, #4]
 801620c:	683a      	ldr	r2, [r7, #0]
 801620e:	629a      	str	r2, [r3, #40]	; 0x28
            break;
 8016210:	e000      	b.n	8016214 <UpdateFCntDown+0x68>
        default:
            break;
 8016212:	46c0      	nop			; (mov r8, r8)
    }
    CryptoCtx.EventCryptoNvmCtxChanged( );
 8016214:	4b04      	ldr	r3, [pc, #16]	; (8016228 <UpdateFCntDown+0x7c>)
 8016216:	689b      	ldr	r3, [r3, #8]
 8016218:	4798      	blx	r3
}
 801621a:	46c0      	nop			; (mov r8, r8)
 801621c:	46bd      	mov	sp, r7
 801621e:	b002      	add	sp, #8
 8016220:	bd80      	pop	{r7, pc}
 8016222:	46c0      	nop			; (mov r8, r8)
 8016224:	0801f438 	.word	0x0801f438
 8016228:	20001080 	.word	0x20001080

0801622c <ResetFCnts>:

/*!
 * Resets the frame counters
 */
static void ResetFCnts( void )
{
 801622c:	b580      	push	{r7, lr}
 801622e:	af00      	add	r7, sp, #0

    CryptoCtx.NvmCtx->FCntList.FCntUp = 0;
 8016230:	4b19      	ldr	r3, [pc, #100]	; (8016298 <ResetFCnts+0x6c>)
 8016232:	685b      	ldr	r3, [r3, #4]
 8016234:	2200      	movs	r2, #0
 8016236:	60da      	str	r2, [r3, #12]
    CryptoCtx.NvmCtx->FCntList.NFCntDown = FCNT_DOWN_INITAL_VALUE;
 8016238:	4b17      	ldr	r3, [pc, #92]	; (8016298 <ResetFCnts+0x6c>)
 801623a:	685b      	ldr	r3, [r3, #4]
 801623c:	2201      	movs	r2, #1
 801623e:	4252      	negs	r2, r2
 8016240:	611a      	str	r2, [r3, #16]
    CryptoCtx.NvmCtx->FCntList.AFCntDown = FCNT_DOWN_INITAL_VALUE;
 8016242:	4b15      	ldr	r3, [pc, #84]	; (8016298 <ResetFCnts+0x6c>)
 8016244:	685b      	ldr	r3, [r3, #4]
 8016246:	2201      	movs	r2, #1
 8016248:	4252      	negs	r2, r2
 801624a:	615a      	str	r2, [r3, #20]
    CryptoCtx.NvmCtx->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 801624c:	4b12      	ldr	r3, [pc, #72]	; (8016298 <ResetFCnts+0x6c>)
 801624e:	685b      	ldr	r3, [r3, #4]
 8016250:	2201      	movs	r2, #1
 8016252:	4252      	negs	r2, r2
 8016254:	619a      	str	r2, [r3, #24]
    CryptoCtx.NvmCtx->LastDownFCnt = &CryptoCtx.NvmCtx->FCntList.FCntDown;
 8016256:	4b10      	ldr	r3, [pc, #64]	; (8016298 <ResetFCnts+0x6c>)
 8016258:	685a      	ldr	r2, [r3, #4]
 801625a:	4b0f      	ldr	r3, [pc, #60]	; (8016298 <ResetFCnts+0x6c>)
 801625c:	685b      	ldr	r3, [r3, #4]
 801625e:	3218      	adds	r2, #24
 8016260:	631a      	str	r2, [r3, #48]	; 0x30

    CryptoCtx.NvmCtx->FCntList.McFCntDown0 = FCNT_DOWN_INITAL_VALUE;
 8016262:	4b0d      	ldr	r3, [pc, #52]	; (8016298 <ResetFCnts+0x6c>)
 8016264:	685b      	ldr	r3, [r3, #4]
 8016266:	2201      	movs	r2, #1
 8016268:	4252      	negs	r2, r2
 801626a:	61da      	str	r2, [r3, #28]
    CryptoCtx.NvmCtx->FCntList.McFCntDown1 = FCNT_DOWN_INITAL_VALUE;
 801626c:	4b0a      	ldr	r3, [pc, #40]	; (8016298 <ResetFCnts+0x6c>)
 801626e:	685b      	ldr	r3, [r3, #4]
 8016270:	2201      	movs	r2, #1
 8016272:	4252      	negs	r2, r2
 8016274:	621a      	str	r2, [r3, #32]
    CryptoCtx.NvmCtx->FCntList.McFCntDown2 = FCNT_DOWN_INITAL_VALUE;
 8016276:	4b08      	ldr	r3, [pc, #32]	; (8016298 <ResetFCnts+0x6c>)
 8016278:	685b      	ldr	r3, [r3, #4]
 801627a:	2201      	movs	r2, #1
 801627c:	4252      	negs	r2, r2
 801627e:	625a      	str	r2, [r3, #36]	; 0x24
    CryptoCtx.NvmCtx->FCntList.McFCntDown3 = FCNT_DOWN_INITAL_VALUE;
 8016280:	4b05      	ldr	r3, [pc, #20]	; (8016298 <ResetFCnts+0x6c>)
 8016282:	685b      	ldr	r3, [r3, #4]
 8016284:	2201      	movs	r2, #1
 8016286:	4252      	negs	r2, r2
 8016288:	629a      	str	r2, [r3, #40]	; 0x28

    CryptoCtx.EventCryptoNvmCtxChanged( );
 801628a:	4b03      	ldr	r3, [pc, #12]	; (8016298 <ResetFCnts+0x6c>)
 801628c:	689b      	ldr	r3, [r3, #8]
 801628e:	4798      	blx	r3
}
 8016290:	46c0      	nop			; (mov r8, r8)
 8016292:	46bd      	mov	sp, r7
 8016294:	bd80      	pop	{r7, pc}
 8016296:	46c0      	nop			; (mov r8, r8)
 8016298:	20001080 	.word	0x20001080

0801629c <DummyCB>:

/*
 * Dummy callback in case if the user provides NULL function pointer
 */
static void DummyCB( void )
{
 801629c:	b580      	push	{r7, lr}
 801629e:	af00      	add	r7, sp, #0
    return;
 80162a0:	46c0      	nop			; (mov r8, r8)
}
 80162a2:	46bd      	mov	sp, r7
 80162a4:	bd80      	pop	{r7, pc}
	...

080162a8 <LoRaMacCryptoInit>:
/*
 *  API functions
 */

LoRaMacCryptoStatus_t LoRaMacCryptoInit( LoRaMacCryptoNvmEvent cryptoNvmCtxChanged )
{
 80162a8:	b580      	push	{r7, lr}
 80162aa:	b082      	sub	sp, #8
 80162ac:	af00      	add	r7, sp, #0
 80162ae:	6078      	str	r0, [r7, #4]
    // Assign non volatile context
    CryptoCtx.NvmCtx = &NvmCryptoCtx;
 80162b0:	4b15      	ldr	r3, [pc, #84]	; (8016308 <LoRaMacCryptoInit+0x60>)
 80162b2:	4a16      	ldr	r2, [pc, #88]	; (801630c <LoRaMacCryptoInit+0x64>)
 80162b4:	605a      	str	r2, [r3, #4]

    // Assign callback
    if( cryptoNvmCtxChanged != 0 )
 80162b6:	687b      	ldr	r3, [r7, #4]
 80162b8:	2b00      	cmp	r3, #0
 80162ba:	d003      	beq.n	80162c4 <LoRaMacCryptoInit+0x1c>
    {
        CryptoCtx.EventCryptoNvmCtxChanged = cryptoNvmCtxChanged;
 80162bc:	4b12      	ldr	r3, [pc, #72]	; (8016308 <LoRaMacCryptoInit+0x60>)
 80162be:	687a      	ldr	r2, [r7, #4]
 80162c0:	609a      	str	r2, [r3, #8]
 80162c2:	e002      	b.n	80162ca <LoRaMacCryptoInit+0x22>
    }
    else
    {
        CryptoCtx.EventCryptoNvmCtxChanged = DummyCB;
 80162c4:	4b10      	ldr	r3, [pc, #64]	; (8016308 <LoRaMacCryptoInit+0x60>)
 80162c6:	4a12      	ldr	r2, [pc, #72]	; (8016310 <LoRaMacCryptoInit+0x68>)
 80162c8:	609a      	str	r2, [r3, #8]
    }

    // Initialize with default
    memset1( (uint8_t*) CryptoCtx.NvmCtx, 0, sizeof( LoRaMacCryptoNvmCtx_t ) );
 80162ca:	4b0f      	ldr	r3, [pc, #60]	; (8016308 <LoRaMacCryptoInit+0x60>)
 80162cc:	685b      	ldr	r3, [r3, #4]
 80162ce:	2234      	movs	r2, #52	; 0x34
 80162d0:	2100      	movs	r1, #0
 80162d2:	0018      	movs	r0, r3
 80162d4:	f005 f976 	bl	801b5c4 <memset1>

    // Set default LoRaWAN version
    CryptoCtx.NvmCtx->LrWanVersion.Fields.Major = 1;
 80162d8:	4b0b      	ldr	r3, [pc, #44]	; (8016308 <LoRaMacCryptoInit+0x60>)
 80162da:	685b      	ldr	r3, [r3, #4]
 80162dc:	2201      	movs	r2, #1
 80162de:	70da      	strb	r2, [r3, #3]
    CryptoCtx.NvmCtx->LrWanVersion.Fields.Minor = 1;
 80162e0:	4b09      	ldr	r3, [pc, #36]	; (8016308 <LoRaMacCryptoInit+0x60>)
 80162e2:	685b      	ldr	r3, [r3, #4]
 80162e4:	2201      	movs	r2, #1
 80162e6:	709a      	strb	r2, [r3, #2]
    CryptoCtx.NvmCtx->LrWanVersion.Fields.Revision = 1;
 80162e8:	4b07      	ldr	r3, [pc, #28]	; (8016308 <LoRaMacCryptoInit+0x60>)
 80162ea:	685b      	ldr	r3, [r3, #4]
 80162ec:	2201      	movs	r2, #1
 80162ee:	705a      	strb	r2, [r3, #1]
    CryptoCtx.NvmCtx->LrWanVersion.Fields.Rfu = 0;
 80162f0:	4b05      	ldr	r3, [pc, #20]	; (8016308 <LoRaMacCryptoInit+0x60>)
 80162f2:	685b      	ldr	r3, [r3, #4]
 80162f4:	2200      	movs	r2, #0
 80162f6:	701a      	strb	r2, [r3, #0]

    // Reset frame counters
    ResetFCnts( );
 80162f8:	f7ff ff98 	bl	801622c <ResetFCnts>

    return LORAMAC_CRYPTO_SUCCESS;
 80162fc:	2300      	movs	r3, #0
}
 80162fe:	0018      	movs	r0, r3
 8016300:	46bd      	mov	sp, r7
 8016302:	b002      	add	sp, #8
 8016304:	bd80      	pop	{r7, pc}
 8016306:	46c0      	nop			; (mov r8, r8)
 8016308:	20001080 	.word	0x20001080
 801630c:	2000108c 	.word	0x2000108c
 8016310:	0801629d 	.word	0x0801629d

08016314 <LoRaMacCryptoSetLrWanVersion>:

LoRaMacCryptoStatus_t LoRaMacCryptoSetLrWanVersion( Version_t version )
{
 8016314:	b580      	push	{r7, lr}
 8016316:	b082      	sub	sp, #8
 8016318:	af00      	add	r7, sp, #0
 801631a:	6078      	str	r0, [r7, #4]
    CryptoCtx.NvmCtx->LrWanVersion = version;
 801631c:	4b04      	ldr	r3, [pc, #16]	; (8016330 <LoRaMacCryptoSetLrWanVersion+0x1c>)
 801631e:	685b      	ldr	r3, [r3, #4]
 8016320:	687a      	ldr	r2, [r7, #4]
 8016322:	601a      	str	r2, [r3, #0]
    return LORAMAC_CRYPTO_SUCCESS;
 8016324:	2300      	movs	r3, #0
}
 8016326:	0018      	movs	r0, r3
 8016328:	46bd      	mov	sp, r7
 801632a:	b002      	add	sp, #8
 801632c:	bd80      	pop	{r7, pc}
 801632e:	46c0      	nop			; (mov r8, r8)
 8016330:	20001080 	.word	0x20001080

08016334 <LoRaMacCryptoRestoreNvmCtx>:

LoRaMacCryptoStatus_t LoRaMacCryptoRestoreNvmCtx( void* cryptoNvmCtx )
{
 8016334:	b580      	push	{r7, lr}
 8016336:	b082      	sub	sp, #8
 8016338:	af00      	add	r7, sp, #0
 801633a:	6078      	str	r0, [r7, #4]
    // Restore module context
    if( cryptoNvmCtx != 0 )
 801633c:	687b      	ldr	r3, [r7, #4]
 801633e:	2b00      	cmp	r3, #0
 8016340:	d007      	beq.n	8016352 <LoRaMacCryptoRestoreNvmCtx+0x1e>
    {
        memcpy1( ( uint8_t* ) &NvmCryptoCtx, ( uint8_t* ) cryptoNvmCtx, CRYPTO_NVM_CTX_SIZE );
 8016342:	6879      	ldr	r1, [r7, #4]
 8016344:	4b05      	ldr	r3, [pc, #20]	; (801635c <LoRaMacCryptoRestoreNvmCtx+0x28>)
 8016346:	2234      	movs	r2, #52	; 0x34
 8016348:	0018      	movs	r0, r3
 801634a:	f005 f8fd 	bl	801b548 <memcpy1>
        return LORAMAC_CRYPTO_SUCCESS;
 801634e:	2300      	movs	r3, #0
 8016350:	e000      	b.n	8016354 <LoRaMacCryptoRestoreNvmCtx+0x20>
    }
    else
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 8016352:	230a      	movs	r3, #10
    }
}
 8016354:	0018      	movs	r0, r3
 8016356:	46bd      	mov	sp, r7
 8016358:	b002      	add	sp, #8
 801635a:	bd80      	pop	{r7, pc}
 801635c:	2000108c 	.word	0x2000108c

08016360 <LoRaMacCryptoGetNvmCtx>:

void* LoRaMacCryptoGetNvmCtx( size_t* cryptoNvmCtxSize )
{
 8016360:	b580      	push	{r7, lr}
 8016362:	b082      	sub	sp, #8
 8016364:	af00      	add	r7, sp, #0
 8016366:	6078      	str	r0, [r7, #4]
    *cryptoNvmCtxSize = CRYPTO_NVM_CTX_SIZE;
 8016368:	687b      	ldr	r3, [r7, #4]
 801636a:	2234      	movs	r2, #52	; 0x34
 801636c:	601a      	str	r2, [r3, #0]
    return &NvmCryptoCtx;
 801636e:	4b02      	ldr	r3, [pc, #8]	; (8016378 <LoRaMacCryptoGetNvmCtx+0x18>)
}
 8016370:	0018      	movs	r0, r3
 8016372:	46bd      	mov	sp, r7
 8016374:	b002      	add	sp, #8
 8016376:	bd80      	pop	{r7, pc}
 8016378:	2000108c 	.word	0x2000108c

0801637c <LoRaMacCryptoGetFCntUp>:

LoRaMacCryptoStatus_t LoRaMacCryptoGetFCntUp( uint32_t* currentUp )
{
 801637c:	b580      	push	{r7, lr}
 801637e:	b082      	sub	sp, #8
 8016380:	af00      	add	r7, sp, #0
 8016382:	6078      	str	r0, [r7, #4]
    if( currentUp == NULL )
 8016384:	687b      	ldr	r3, [r7, #4]
 8016386:	2b00      	cmp	r3, #0
 8016388:	d101      	bne.n	801638e <LoRaMacCryptoGetFCntUp+0x12>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 801638a:	230a      	movs	r3, #10
 801638c:	e006      	b.n	801639c <LoRaMacCryptoGetFCntUp+0x20>
    }

    *currentUp = CryptoCtx.NvmCtx->FCntList.FCntUp + 1;
 801638e:	4b05      	ldr	r3, [pc, #20]	; (80163a4 <LoRaMacCryptoGetFCntUp+0x28>)
 8016390:	685b      	ldr	r3, [r3, #4]
 8016392:	68db      	ldr	r3, [r3, #12]
 8016394:	1c5a      	adds	r2, r3, #1
 8016396:	687b      	ldr	r3, [r7, #4]
 8016398:	601a      	str	r2, [r3, #0]

    return LORAMAC_CRYPTO_SUCCESS;
 801639a:	2300      	movs	r3, #0
}
 801639c:	0018      	movs	r0, r3
 801639e:	46bd      	mov	sp, r7
 80163a0:	b002      	add	sp, #8
 80163a2:	bd80      	pop	{r7, pc}
 80163a4:	20001080 	.word	0x20001080

080163a8 <LoRaMacCryptoGetFCntDown>:

LoRaMacCryptoStatus_t LoRaMacCryptoGetFCntDown( FCntIdentifier_t fCntID, uint16_t maxFCntGap, uint32_t frameFcnt, uint32_t* currentDown )
{
 80163a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80163aa:	b08d      	sub	sp, #52	; 0x34
 80163ac:	af00      	add	r7, sp, #0
 80163ae:	61ba      	str	r2, [r7, #24]
 80163b0:	617b      	str	r3, [r7, #20]
 80163b2:	230f      	movs	r3, #15
 80163b4:	2210      	movs	r2, #16
 80163b6:	4694      	mov	ip, r2
 80163b8:	44bc      	add	ip, r7
 80163ba:	4463      	add	r3, ip
 80163bc:	1c02      	adds	r2, r0, #0
 80163be:	701a      	strb	r2, [r3, #0]
 80163c0:	230c      	movs	r3, #12
 80163c2:	2210      	movs	r2, #16
 80163c4:	4694      	mov	ip, r2
 80163c6:	44bc      	add	ip, r7
 80163c8:	4463      	add	r3, ip
 80163ca:	1c0a      	adds	r2, r1, #0
 80163cc:	801a      	strh	r2, [r3, #0]
    uint32_t lastDown = 0;
 80163ce:	2300      	movs	r3, #0
 80163d0:	627b      	str	r3, [r7, #36]	; 0x24
    int32_t fCntDiff = 0;
 80163d2:	2300      	movs	r3, #0
 80163d4:	62fb      	str	r3, [r7, #44]	; 0x2c
    LoRaMacCryptoStatus_t cryptoStatus = LORAMAC_CRYPTO_ERROR;
 80163d6:	231b      	movs	r3, #27
 80163d8:	2210      	movs	r2, #16
 80163da:	4694      	mov	ip, r2
 80163dc:	44bc      	add	ip, r7
 80163de:	4463      	add	r3, ip
 80163e0:	2213      	movs	r2, #19
 80163e2:	701a      	strb	r2, [r3, #0]

    if( currentDown == NULL )
 80163e4:	697b      	ldr	r3, [r7, #20]
 80163e6:	2b00      	cmp	r3, #0
 80163e8:	d101      	bne.n	80163ee <LoRaMacCryptoGetFCntDown+0x46>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 80163ea:	230a      	movs	r3, #10
 80163ec:	e06b      	b.n	80164c6 <LoRaMacCryptoGetFCntDown+0x11e>
    }

    cryptoStatus = GetLastFcntDown( fCntID, &lastDown );
 80163ee:	221b      	movs	r2, #27
 80163f0:	2110      	movs	r1, #16
 80163f2:	187b      	adds	r3, r7, r1
 80163f4:	189e      	adds	r6, r3, r2
 80163f6:	2314      	movs	r3, #20
 80163f8:	187a      	adds	r2, r7, r1
 80163fa:	18d2      	adds	r2, r2, r3
 80163fc:	230f      	movs	r3, #15
 80163fe:	2010      	movs	r0, #16
 8016400:	4684      	mov	ip, r0
 8016402:	44bc      	add	ip, r7
 8016404:	4463      	add	r3, ip
 8016406:	781b      	ldrb	r3, [r3, #0]
 8016408:	0011      	movs	r1, r2
 801640a:	0018      	movs	r0, r3
 801640c:	f7ff fe4e 	bl	80160ac <GetLastFcntDown>
 8016410:	0003      	movs	r3, r0
 8016412:	7033      	strb	r3, [r6, #0]
    if( cryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8016414:	221b      	movs	r2, #27
 8016416:	2110      	movs	r1, #16
 8016418:	187b      	adds	r3, r7, r1
 801641a:	189b      	adds	r3, r3, r2
 801641c:	781b      	ldrb	r3, [r3, #0]
 801641e:	2b00      	cmp	r3, #0
 8016420:	d003      	beq.n	801642a <LoRaMacCryptoGetFCntDown+0x82>
    {
        return cryptoStatus;
 8016422:	187b      	adds	r3, r7, r1
 8016424:	189b      	adds	r3, r3, r2
 8016426:	781b      	ldrb	r3, [r3, #0]
 8016428:	e04d      	b.n	80164c6 <LoRaMacCryptoGetFCntDown+0x11e>
    }

    // For LoRaWAN 1.0.X only, allow downlink frames of 0
    if( lastDown == FCNT_DOWN_INITAL_VALUE )
 801642a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801642c:	3301      	adds	r3, #1
 801642e:	d103      	bne.n	8016438 <LoRaMacCryptoGetFCntDown+0x90>
    {
         *currentDown = frameFcnt;
 8016430:	697b      	ldr	r3, [r7, #20]
 8016432:	69ba      	ldr	r2, [r7, #24]
 8016434:	601a      	str	r2, [r3, #0]
 8016436:	e020      	b.n	801647a <LoRaMacCryptoGetFCntDown+0xd2>
    }
    else
    {
        // Add difference, consider roll-over
        fCntDiff = ( int32_t )( ( int64_t )frameFcnt - ( int64_t )( lastDown & 0x0000FFFF ) );
 8016438:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801643a:	041b      	lsls	r3, r3, #16
 801643c:	0c1b      	lsrs	r3, r3, #16
 801643e:	69ba      	ldr	r2, [r7, #24]
 8016440:	1ad3      	subs	r3, r2, r3
 8016442:	62fb      	str	r3, [r7, #44]	; 0x2c

        if( fCntDiff > 0 )
 8016444:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016446:	2b00      	cmp	r3, #0
 8016448:	dd05      	ble.n	8016456 <LoRaMacCryptoGetFCntDown+0xae>
        {  // Positive difference
            *currentDown = lastDown + fCntDiff;
 801644a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801644c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801644e:	18d2      	adds	r2, r2, r3
 8016450:	697b      	ldr	r3, [r7, #20]
 8016452:	601a      	str	r2, [r3, #0]
 8016454:	e011      	b.n	801647a <LoRaMacCryptoGetFCntDown+0xd2>
        }
        else if( fCntDiff == 0 )
 8016456:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016458:	2b00      	cmp	r3, #0
 801645a:	d104      	bne.n	8016466 <LoRaMacCryptoGetFCntDown+0xbe>
        {  // Duplicate FCnt value, keep the current value.
            *currentDown = lastDown;
 801645c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801645e:	697b      	ldr	r3, [r7, #20]
 8016460:	601a      	str	r2, [r3, #0]
            return LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED;
 8016462:	2307      	movs	r3, #7
 8016464:	e02f      	b.n	80164c6 <LoRaMacCryptoGetFCntDown+0x11e>
        }
        else
        {  // Negative difference, assume a roll-over of one uint16_t
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
 8016466:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016468:	0c1b      	lsrs	r3, r3, #16
 801646a:	041a      	lsls	r2, r3, #16
 801646c:	69bb      	ldr	r3, [r7, #24]
 801646e:	18d3      	adds	r3, r2, r3
 8016470:	2280      	movs	r2, #128	; 0x80
 8016472:	0252      	lsls	r2, r2, #9
 8016474:	189a      	adds	r2, r3, r2
 8016476:	697b      	ldr	r3, [r7, #20]
 8016478:	601a      	str	r2, [r3, #0]
        }
    }


    // For LoRaWAN 1.0.X only, check maxFCntGap
    if( CryptoCtx.NvmCtx->LrWanVersion.Fields.Minor == 0 )
 801647a:	4b15      	ldr	r3, [pc, #84]	; (80164d0 <LoRaMacCryptoGetFCntDown+0x128>)
 801647c:	685b      	ldr	r3, [r3, #4]
 801647e:	789b      	ldrb	r3, [r3, #2]
 8016480:	2b00      	cmp	r3, #0
 8016482:	d11f      	bne.n	80164c4 <LoRaMacCryptoGetFCntDown+0x11c>
    {
        if( ( ( int64_t )*currentDown - ( int64_t )lastDown ) >= maxFCntGap )
 8016484:	697b      	ldr	r3, [r7, #20]
 8016486:	681b      	ldr	r3, [r3, #0]
 8016488:	60bb      	str	r3, [r7, #8]
 801648a:	2300      	movs	r3, #0
 801648c:	60fb      	str	r3, [r7, #12]
 801648e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016490:	603b      	str	r3, [r7, #0]
 8016492:	2300      	movs	r3, #0
 8016494:	607b      	str	r3, [r7, #4]
 8016496:	68ba      	ldr	r2, [r7, #8]
 8016498:	68fb      	ldr	r3, [r7, #12]
 801649a:	6838      	ldr	r0, [r7, #0]
 801649c:	6879      	ldr	r1, [r7, #4]
 801649e:	1a12      	subs	r2, r2, r0
 80164a0:	418b      	sbcs	r3, r1
 80164a2:	210c      	movs	r1, #12
 80164a4:	2010      	movs	r0, #16
 80164a6:	4684      	mov	ip, r0
 80164a8:	44bc      	add	ip, r7
 80164aa:	4461      	add	r1, ip
 80164ac:	8809      	ldrh	r1, [r1, #0]
 80164ae:	b289      	uxth	r1, r1
 80164b0:	000c      	movs	r4, r1
 80164b2:	2100      	movs	r1, #0
 80164b4:	000d      	movs	r5, r1
 80164b6:	429d      	cmp	r5, r3
 80164b8:	dc04      	bgt.n	80164c4 <LoRaMacCryptoGetFCntDown+0x11c>
 80164ba:	d101      	bne.n	80164c0 <LoRaMacCryptoGetFCntDown+0x118>
 80164bc:	4294      	cmp	r4, r2
 80164be:	d801      	bhi.n	80164c4 <LoRaMacCryptoGetFCntDown+0x11c>
        {
            return LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT;
 80164c0:	2308      	movs	r3, #8
 80164c2:	e000      	b.n	80164c6 <LoRaMacCryptoGetFCntDown+0x11e>
        }
    }

    return LORAMAC_CRYPTO_SUCCESS;
 80164c4:	2300      	movs	r3, #0
}
 80164c6:	0018      	movs	r0, r3
 80164c8:	46bd      	mov	sp, r7
 80164ca:	b00d      	add	sp, #52	; 0x34
 80164cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80164ce:	46c0      	nop			; (mov r8, r8)
 80164d0:	20001080 	.word	0x20001080

080164d4 <LoRaMacCryptoSetMulticastReference>:

LoRaMacCryptoStatus_t LoRaMacCryptoSetMulticastReference( MulticastCtx_t* multicastList )
{
 80164d4:	b580      	push	{r7, lr}
 80164d6:	b082      	sub	sp, #8
 80164d8:	af00      	add	r7, sp, #0
 80164da:	6078      	str	r0, [r7, #4]
    if( multicastList == NULL )
 80164dc:	687b      	ldr	r3, [r7, #4]
 80164de:	2b00      	cmp	r3, #0
 80164e0:	d101      	bne.n	80164e6 <LoRaMacCryptoSetMulticastReference+0x12>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 80164e2:	230a      	movs	r3, #10
 80164e4:	e018      	b.n	8016518 <LoRaMacCryptoSetMulticastReference+0x44>
    }

    multicastList[0].DownLinkCounter = &CryptoCtx.NvmCtx->FCntList.McFCntDown0;
 80164e6:	4b0e      	ldr	r3, [pc, #56]	; (8016520 <LoRaMacCryptoSetMulticastReference+0x4c>)
 80164e8:	685b      	ldr	r3, [r3, #4]
 80164ea:	331c      	adds	r3, #28
 80164ec:	001a      	movs	r2, r3
 80164ee:	687b      	ldr	r3, [r7, #4]
 80164f0:	61da      	str	r2, [r3, #28]
    multicastList[1].DownLinkCounter = &CryptoCtx.NvmCtx->FCntList.McFCntDown1;
 80164f2:	4b0b      	ldr	r3, [pc, #44]	; (8016520 <LoRaMacCryptoSetMulticastReference+0x4c>)
 80164f4:	685a      	ldr	r2, [r3, #4]
 80164f6:	687b      	ldr	r3, [r7, #4]
 80164f8:	3328      	adds	r3, #40	; 0x28
 80164fa:	3220      	adds	r2, #32
 80164fc:	61da      	str	r2, [r3, #28]
    multicastList[2].DownLinkCounter = &CryptoCtx.NvmCtx->FCntList.McFCntDown2;
 80164fe:	4b08      	ldr	r3, [pc, #32]	; (8016520 <LoRaMacCryptoSetMulticastReference+0x4c>)
 8016500:	685a      	ldr	r2, [r3, #4]
 8016502:	687b      	ldr	r3, [r7, #4]
 8016504:	3350      	adds	r3, #80	; 0x50
 8016506:	3224      	adds	r2, #36	; 0x24
 8016508:	61da      	str	r2, [r3, #28]
    multicastList[3].DownLinkCounter = &CryptoCtx.NvmCtx->FCntList.McFCntDown3;
 801650a:	4b05      	ldr	r3, [pc, #20]	; (8016520 <LoRaMacCryptoSetMulticastReference+0x4c>)
 801650c:	685a      	ldr	r2, [r3, #4]
 801650e:	687b      	ldr	r3, [r7, #4]
 8016510:	3378      	adds	r3, #120	; 0x78
 8016512:	3228      	adds	r2, #40	; 0x28
 8016514:	61da      	str	r2, [r3, #28]

    return LORAMAC_CRYPTO_SUCCESS;
 8016516:	2300      	movs	r3, #0
}
 8016518:	0018      	movs	r0, r3
 801651a:	46bd      	mov	sp, r7
 801651c:	b002      	add	sp, #8
 801651e:	bd80      	pop	{r7, pc}
 8016520:	20001080 	.word	0x20001080

08016524 <LoRaMacCryptoSetKey>:

LoRaMacCryptoStatus_t LoRaMacCryptoSetKey( KeyIdentifier_t keyID, uint8_t* key )
{
 8016524:	b580      	push	{r7, lr}
 8016526:	b082      	sub	sp, #8
 8016528:	af00      	add	r7, sp, #0
 801652a:	0002      	movs	r2, r0
 801652c:	6039      	str	r1, [r7, #0]
 801652e:	1dfb      	adds	r3, r7, #7
 8016530:	701a      	strb	r2, [r3, #0]
    if( SecureElementSetKey( keyID, key ) != SECURE_ELEMENT_SUCCESS )
 8016532:	683a      	ldr	r2, [r7, #0]
 8016534:	1dfb      	adds	r3, r7, #7
 8016536:	781b      	ldrb	r3, [r3, #0]
 8016538:	0011      	movs	r1, r2
 801653a:	0018      	movs	r0, r3
 801653c:	f7f8 fe2a 	bl	800f194 <SecureElementSetKey>
 8016540:	1e03      	subs	r3, r0, #0
 8016542:	d001      	beq.n	8016548 <LoRaMacCryptoSetKey+0x24>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8016544:	230f      	movs	r3, #15
 8016546:	e018      	b.n	801657a <LoRaMacCryptoSetKey+0x56>
    }
    if( ( keyID == GEN_APP_KEY ) || ( keyID == APP_KEY ) )
 8016548:	1dfb      	adds	r3, r7, #7
 801654a:	781b      	ldrb	r3, [r3, #0]
 801654c:	2b01      	cmp	r3, #1
 801654e:	d003      	beq.n	8016558 <LoRaMacCryptoSetKey+0x34>
 8016550:	1dfb      	adds	r3, r7, #7
 8016552:	781b      	ldrb	r3, [r3, #0]
 8016554:	2b00      	cmp	r3, #0
 8016556:	d10f      	bne.n	8016578 <LoRaMacCryptoSetKey+0x54>
    {
        // Derive lifetime keys
        if( LoRaMacCryptoDeriveMcRootKey( keyID ) != LORAMAC_CRYPTO_SUCCESS )
 8016558:	1dfb      	adds	r3, r7, #7
 801655a:	781b      	ldrb	r3, [r3, #0]
 801655c:	0018      	movs	r0, r3
 801655e:	f000 fb9b 	bl	8016c98 <LoRaMacCryptoDeriveMcRootKey>
 8016562:	1e03      	subs	r3, r0, #0
 8016564:	d001      	beq.n	801656a <LoRaMacCryptoSetKey+0x46>
        {
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8016566:	230f      	movs	r3, #15
 8016568:	e007      	b.n	801657a <LoRaMacCryptoSetKey+0x56>
        }
        if( LoRaMacCryptoDeriveMcKEKey( MC_ROOT_KEY ) != LORAMAC_CRYPTO_SUCCESS )
 801656a:	2009      	movs	r0, #9
 801656c:	f000 fbd6 	bl	8016d1c <LoRaMacCryptoDeriveMcKEKey>
 8016570:	1e03      	subs	r3, r0, #0
 8016572:	d001      	beq.n	8016578 <LoRaMacCryptoSetKey+0x54>
        {
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8016574:	230f      	movs	r3, #15
 8016576:	e000      	b.n	801657a <LoRaMacCryptoSetKey+0x56>
        }
    }
    return LORAMAC_CRYPTO_SUCCESS;
 8016578:	2300      	movs	r3, #0
}
 801657a:	0018      	movs	r0, r3
 801657c:	46bd      	mov	sp, r7
 801657e:	b002      	add	sp, #8
 8016580:	bd80      	pop	{r7, pc}
	...

08016584 <LoRaMacCryptoPrepareJoinRequest>:

LoRaMacCryptoStatus_t LoRaMacCryptoPrepareJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
 8016584:	b580      	push	{r7, lr}
 8016586:	b086      	sub	sp, #24
 8016588:	af02      	add	r7, sp, #8
 801658a:	6078      	str	r0, [r7, #4]
    if( macMsg == 0 )
 801658c:	687b      	ldr	r3, [r7, #4]
 801658e:	2b00      	cmp	r3, #0
 8016590:	d101      	bne.n	8016596 <LoRaMacCryptoPrepareJoinRequest+0x12>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 8016592:	230a      	movs	r3, #10
 8016594:	e039      	b.n	801660a <LoRaMacCryptoPrepareJoinRequest+0x86>
    }
    KeyIdentifier_t micComputationKeyID = NWK_KEY;
 8016596:	230f      	movs	r3, #15
 8016598:	18fb      	adds	r3, r7, r3
 801659a:	2202      	movs	r2, #2
 801659c:	701a      	strb	r2, [r3, #0]

    // Add device nonce
#if ( USE_RANDOM_DEV_NONCE == 1 )
    uint32_t devNonce = 0;
 801659e:	2300      	movs	r3, #0
 80165a0:	60bb      	str	r3, [r7, #8]
    SecureElementRandomNumber( &devNonce );
 80165a2:	2308      	movs	r3, #8
 80165a4:	18fb      	adds	r3, r7, r3
 80165a6:	0018      	movs	r0, r3
 80165a8:	f7f8 ffa8 	bl	800f4fc <SecureElementRandomNumber>
    CryptoCtx.NvmCtx->DevNonce = devNonce;
 80165ac:	68ba      	ldr	r2, [r7, #8]
 80165ae:	4b19      	ldr	r3, [pc, #100]	; (8016614 <LoRaMacCryptoPrepareJoinRequest+0x90>)
 80165b0:	685b      	ldr	r3, [r3, #4]
 80165b2:	b292      	uxth	r2, r2
 80165b4:	809a      	strh	r2, [r3, #4]
#else
    CryptoCtx.NvmCtx->DevNonce++;
#endif
    CryptoCtx.EventCryptoNvmCtxChanged( );
 80165b6:	4b17      	ldr	r3, [pc, #92]	; (8016614 <LoRaMacCryptoPrepareJoinRequest+0x90>)
 80165b8:	689b      	ldr	r3, [r3, #8]
 80165ba:	4798      	blx	r3
    macMsg->DevNonce = CryptoCtx.NvmCtx->DevNonce;
 80165bc:	4b15      	ldr	r3, [pc, #84]	; (8016614 <LoRaMacCryptoPrepareJoinRequest+0x90>)
 80165be:	685b      	ldr	r3, [r3, #4]
 80165c0:	889a      	ldrh	r2, [r3, #4]
 80165c2:	687b      	ldr	r3, [r7, #4]
 80165c4:	82da      	strh	r2, [r3, #22]
        return LORAMAC_CRYPTO_ERROR;
    }
#endif

    // Serialize message
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 80165c6:	687b      	ldr	r3, [r7, #4]
 80165c8:	0018      	movs	r0, r3
 80165ca:	f000 fdd1 	bl	8017170 <LoRaMacSerializerJoinRequest>
 80165ce:	1e03      	subs	r3, r0, #0
 80165d0:	d001      	beq.n	80165d6 <LoRaMacCryptoPrepareJoinRequest+0x52>
    {
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 80165d2:	2311      	movs	r3, #17
 80165d4:	e019      	b.n	801660a <LoRaMacCryptoPrepareJoinRequest+0x86>
    }

    // Compute mic
    if( SecureElementComputeAesCmac( NULL, macMsg->Buffer, ( LORAMAC_JOIN_REQ_MSG_SIZE - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, &macMsg->MIC ) != SECURE_ELEMENT_SUCCESS )
 80165d6:	687b      	ldr	r3, [r7, #4]
 80165d8:	6819      	ldr	r1, [r3, #0]
 80165da:	687b      	ldr	r3, [r7, #4]
 80165dc:	3318      	adds	r3, #24
 80165de:	220f      	movs	r2, #15
 80165e0:	18ba      	adds	r2, r7, r2
 80165e2:	7812      	ldrb	r2, [r2, #0]
 80165e4:	9300      	str	r3, [sp, #0]
 80165e6:	0013      	movs	r3, r2
 80165e8:	2213      	movs	r2, #19
 80165ea:	2000      	movs	r0, #0
 80165ec:	f7f8 fe5c 	bl	800f2a8 <SecureElementComputeAesCmac>
 80165f0:	1e03      	subs	r3, r0, #0
 80165f2:	d001      	beq.n	80165f8 <LoRaMacCryptoPrepareJoinRequest+0x74>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80165f4:	230f      	movs	r3, #15
 80165f6:	e008      	b.n	801660a <LoRaMacCryptoPrepareJoinRequest+0x86>
    }

    // Reserialize message to add the MIC
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 80165f8:	687b      	ldr	r3, [r7, #4]
 80165fa:	0018      	movs	r0, r3
 80165fc:	f000 fdb8 	bl	8017170 <LoRaMacSerializerJoinRequest>
 8016600:	1e03      	subs	r3, r0, #0
 8016602:	d001      	beq.n	8016608 <LoRaMacCryptoPrepareJoinRequest+0x84>
    {
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 8016604:	2311      	movs	r3, #17
 8016606:	e000      	b.n	801660a <LoRaMacCryptoPrepareJoinRequest+0x86>
    }

    return LORAMAC_CRYPTO_SUCCESS;
 8016608:	2300      	movs	r3, #0
}
 801660a:	0018      	movs	r0, r3
 801660c:	46bd      	mov	sp, r7
 801660e:	b004      	add	sp, #16
 8016610:	bd80      	pop	{r7, pc}
 8016612:	46c0      	nop			; (mov r8, r8)
 8016614:	20001080 	.word	0x20001080

08016618 <LoRaMacCryptoHandleJoinAccept>:

    return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t LoRaMacCryptoHandleJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEUI, LoRaMacMessageJoinAccept_t* macMsg )
{
 8016618:	b5b0      	push	{r4, r5, r7, lr}
 801661a:	b0ca      	sub	sp, #296	; 0x128
 801661c:	af00      	add	r7, sp, #0
 801661e:	60b9      	str	r1, [r7, #8]
 8016620:	607a      	str	r2, [r7, #4]
 8016622:	4bdf      	ldr	r3, [pc, #892]	; (80169a0 <LoRaMacCryptoHandleJoinAccept+0x388>)
 8016624:	2294      	movs	r2, #148	; 0x94
 8016626:	0052      	lsls	r2, r2, #1
 8016628:	4694      	mov	ip, r2
 801662a:	44bc      	add	ip, r7
 801662c:	4463      	add	r3, ip
 801662e:	1c02      	adds	r2, r0, #0
 8016630:	701a      	strb	r2, [r3, #0]
    if( ( macMsg == 0 ) || ( joinEUI == 0 ) )
 8016632:	687b      	ldr	r3, [r7, #4]
 8016634:	2b00      	cmp	r3, #0
 8016636:	d002      	beq.n	801663e <LoRaMacCryptoHandleJoinAccept+0x26>
 8016638:	68bb      	ldr	r3, [r7, #8]
 801663a:	2b00      	cmp	r3, #0
 801663c:	d101      	bne.n	8016642 <LoRaMacCryptoHandleJoinAccept+0x2a>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 801663e:	230a      	movs	r3, #10
 8016640:	e1ce      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
    }

    LoRaMacCryptoStatus_t retval = LORAMAC_CRYPTO_ERROR;
 8016642:	2392      	movs	r3, #146	; 0x92
 8016644:	005b      	lsls	r3, r3, #1
 8016646:	18fb      	adds	r3, r7, r3
 8016648:	2213      	movs	r2, #19
 801664a:	701a      	strb	r2, [r3, #0]
    KeyIdentifier_t micComputationKeyID;
    KeyIdentifier_t encryptionKeyID;
    uint8_t micComputationOffset = 0;
 801664c:	2126      	movs	r1, #38	; 0x26
 801664e:	31ff      	adds	r1, #255	; 0xff
 8016650:	187b      	adds	r3, r7, r1
 8016652:	2200      	movs	r2, #0
 8016654:	701a      	strb	r2, [r3, #0]
#if( USE_LRWAN_1_1_X_CRYPTO == 1 )
    uint8_t* devNonceForKeyDerivation = ( uint8_t* ) &CryptoCtx.NvmCtx->DevNonce;
#endif

    // Determine decryption key and DevNonce for key derivation
    if( joinReqType == JOIN_REQ )
 8016656:	4bd2      	ldr	r3, [pc, #840]	; (80169a0 <LoRaMacCryptoHandleJoinAccept+0x388>)
 8016658:	2294      	movs	r2, #148	; 0x94
 801665a:	0052      	lsls	r2, r2, #1
 801665c:	4694      	mov	ip, r2
 801665e:	44bc      	add	ip, r7
 8016660:	4463      	add	r3, ip
 8016662:	781b      	ldrb	r3, [r3, #0]
 8016664:	2bff      	cmp	r3, #255	; 0xff
 8016666:	d107      	bne.n	8016678 <LoRaMacCryptoHandleJoinAccept+0x60>
    {
        encryptionKeyID = NWK_KEY;
 8016668:	2393      	movs	r3, #147	; 0x93
 801666a:	005b      	lsls	r3, r3, #1
 801666c:	18fb      	adds	r3, r7, r3
 801666e:	2202      	movs	r2, #2
 8016670:	701a      	strb	r2, [r3, #0]
        micComputationOffset = CRYPTO_MIC_COMPUTATION_OFFSET;
 8016672:	187b      	adds	r3, r7, r1
 8016674:	220c      	movs	r2, #12
 8016676:	701a      	strb	r2, [r3, #0]
        }
    }
#endif
    // Decrypt header, skip MHDR
    uint8_t procBuffer[CRYPTO_MAXMESSAGE_SIZE + CRYPTO_MIC_COMPUTATION_OFFSET];
    memset1( procBuffer, 0, ( macMsg->BufSize + micComputationOffset ) );
 8016678:	687b      	ldr	r3, [r7, #4]
 801667a:	791b      	ldrb	r3, [r3, #4]
 801667c:	b29a      	uxth	r2, r3
 801667e:	2426      	movs	r4, #38	; 0x26
 8016680:	34ff      	adds	r4, #255	; 0xff
 8016682:	193b      	adds	r3, r7, r4
 8016684:	781b      	ldrb	r3, [r3, #0]
 8016686:	b29b      	uxth	r3, r3
 8016688:	18d3      	adds	r3, r2, r3
 801668a:	b29a      	uxth	r2, r3
 801668c:	2510      	movs	r5, #16
 801668e:	197b      	adds	r3, r7, r5
 8016690:	2100      	movs	r1, #0
 8016692:	0018      	movs	r0, r3
 8016694:	f004 ff96 	bl	801b5c4 <memset1>

    if( SecureElementAesEncrypt( macMsg->Buffer + LORAMAC_MHDR_FIELD_SIZE, ( macMsg->BufSize - LORAMAC_MHDR_FIELD_SIZE ), encryptionKeyID, ( procBuffer + micComputationOffset ) ) != SECURE_ELEMENT_SUCCESS )
 8016698:	687b      	ldr	r3, [r7, #4]
 801669a:	681b      	ldr	r3, [r3, #0]
 801669c:	1c58      	adds	r0, r3, #1
 801669e:	687b      	ldr	r3, [r7, #4]
 80166a0:	791b      	ldrb	r3, [r3, #4]
 80166a2:	b29b      	uxth	r3, r3
 80166a4:	3b01      	subs	r3, #1
 80166a6:	b299      	uxth	r1, r3
 80166a8:	193b      	adds	r3, r7, r4
 80166aa:	781b      	ldrb	r3, [r3, #0]
 80166ac:	197a      	adds	r2, r7, r5
 80166ae:	18d4      	adds	r4, r2, r3
 80166b0:	2393      	movs	r3, #147	; 0x93
 80166b2:	005b      	lsls	r3, r3, #1
 80166b4:	18fb      	adds	r3, r7, r3
 80166b6:	781a      	ldrb	r2, [r3, #0]
 80166b8:	0023      	movs	r3, r4
 80166ba:	f7f8 fe57 	bl	800f36c <SecureElementAesEncrypt>
 80166be:	1e03      	subs	r3, r0, #0
 80166c0:	d001      	beq.n	80166c6 <LoRaMacCryptoHandleJoinAccept+0xae>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 80166c2:	230f      	movs	r3, #15
 80166c4:	e18c      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
    }
    // Copy the result to an offset location to keep space for additional information which have to be added in case of 1.1 and later
    memcpy1( macMsg->Buffer + LORAMAC_MHDR_FIELD_SIZE, ( procBuffer + micComputationOffset ), ( macMsg->BufSize - LORAMAC_MHDR_FIELD_SIZE ) );
 80166c6:	687b      	ldr	r3, [r7, #4]
 80166c8:	681b      	ldr	r3, [r3, #0]
 80166ca:	1c58      	adds	r0, r3, #1
 80166cc:	2326      	movs	r3, #38	; 0x26
 80166ce:	33ff      	adds	r3, #255	; 0xff
 80166d0:	18fb      	adds	r3, r7, r3
 80166d2:	781b      	ldrb	r3, [r3, #0]
 80166d4:	2210      	movs	r2, #16
 80166d6:	18ba      	adds	r2, r7, r2
 80166d8:	18d1      	adds	r1, r2, r3
 80166da:	687b      	ldr	r3, [r7, #4]
 80166dc:	791b      	ldrb	r3, [r3, #4]
 80166de:	b29b      	uxth	r3, r3
 80166e0:	3b01      	subs	r3, #1
 80166e2:	b29b      	uxth	r3, r3
 80166e4:	001a      	movs	r2, r3
 80166e6:	f004 ff2f 	bl	801b548 <memcpy1>

    // Parse the message
    if( LoRaMacParserJoinAccept( macMsg ) != LORAMAC_PARSER_SUCCESS )
 80166ea:	687b      	ldr	r3, [r7, #4]
 80166ec:	0018      	movs	r0, r3
 80166ee:	f000 fb3f 	bl	8016d70 <LoRaMacParserJoinAccept>
 80166f2:	1e03      	subs	r3, r0, #0
 80166f4:	d001      	beq.n	80166fa <LoRaMacCryptoHandleJoinAccept+0xe2>
    {
        return LORAMAC_CRYPTO_ERROR_PARSER;
 80166f6:	2310      	movs	r3, #16
 80166f8:	e172      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
    }

    // Is it a LoRaWAN 1.1.0 or later ?
    if( macMsg->DLSettings.Bits.OptNeg == 1 )
 80166fa:	687b      	ldr	r3, [r7, #4]
 80166fc:	7c1b      	ldrb	r3, [r3, #16]
 80166fe:	227f      	movs	r2, #127	; 0x7f
 8016700:	4393      	bics	r3, r2
 8016702:	b2db      	uxtb	r3, r3
 8016704:	2b00      	cmp	r3, #0
 8016706:	d009      	beq.n	801671c <LoRaMacCryptoHandleJoinAccept+0x104>
    {
        CryptoCtx.NvmCtx->LrWanVersion.Fields.Minor = 1;
 8016708:	4ba6      	ldr	r3, [pc, #664]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 801670a:	685b      	ldr	r3, [r3, #4]
 801670c:	2201      	movs	r2, #1
 801670e:	709a      	strb	r2, [r3, #2]
        micComputationKeyID = J_S_INT_KEY;
 8016710:	2328      	movs	r3, #40	; 0x28
 8016712:	33ff      	adds	r3, #255	; 0xff
 8016714:	18fb      	adds	r3, r7, r3
 8016716:	2203      	movs	r2, #3
 8016718:	701a      	strb	r2, [r3, #0]
 801671a:	e008      	b.n	801672e <LoRaMacCryptoHandleJoinAccept+0x116>
    }
    else
    {
        CryptoCtx.NvmCtx->LrWanVersion.Fields.Minor = 0;
 801671c:	4ba1      	ldr	r3, [pc, #644]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 801671e:	685b      	ldr	r3, [r3, #4]
 8016720:	2200      	movs	r2, #0
 8016722:	709a      	strb	r2, [r3, #2]
        micComputationKeyID = NWK_KEY;
 8016724:	2328      	movs	r3, #40	; 0x28
 8016726:	33ff      	adds	r3, #255	; 0xff
 8016728:	18fb      	adds	r3, r7, r3
 801672a:	2202      	movs	r2, #2
 801672c:	701a      	strb	r2, [r3, #0]
    }

    // Verify mic
    if( CryptoCtx.NvmCtx->LrWanVersion.Fields.Minor == 0 )
 801672e:	4b9d      	ldr	r3, [pc, #628]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 8016730:	685b      	ldr	r3, [r3, #4]
 8016732:	789b      	ldrb	r3, [r3, #2]
 8016734:	2b00      	cmp	r3, #0
 8016736:	d113      	bne.n	8016760 <LoRaMacCryptoHandleJoinAccept+0x148>
    {
        // For legacy mode :
        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList | CFListType)
        if( SecureElementVerifyAesCmac( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), macMsg->MIC, micComputationKeyID ) != SECURE_ELEMENT_SUCCESS )
 8016738:	687b      	ldr	r3, [r7, #4]
 801673a:	6818      	ldr	r0, [r3, #0]
 801673c:	687b      	ldr	r3, [r7, #4]
 801673e:	791b      	ldrb	r3, [r3, #4]
 8016740:	b29b      	uxth	r3, r3
 8016742:	3b04      	subs	r3, #4
 8016744:	b299      	uxth	r1, r3
 8016746:	687b      	ldr	r3, [r7, #4]
 8016748:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801674a:	2328      	movs	r3, #40	; 0x28
 801674c:	33ff      	adds	r3, #255	; 0xff
 801674e:	18fb      	adds	r3, r7, r3
 8016750:	781b      	ldrb	r3, [r3, #0]
 8016752:	f7f8 fdca 	bl	800f2ea <SecureElementVerifyAesCmac>
 8016756:	1e03      	subs	r3, r0, #0
 8016758:	d100      	bne.n	801675c <LoRaMacCryptoHandleJoinAccept+0x144>
 801675a:	e0a4      	b.n	80168a6 <LoRaMacCryptoHandleJoinAccept+0x28e>
        {
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 801675c:	230f      	movs	r3, #15
 801675e:	e13f      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
    {
        // For 1.1 and later:
        //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList | CFListType)

        // Prepare the msg for integrity check (adding JoinReqType, JoinEUI and DevNonce)
        uint16_t bufItr = 0;
 8016760:	2091      	movs	r0, #145	; 0x91
 8016762:	0040      	lsls	r0, r0, #1
 8016764:	183b      	adds	r3, r7, r0
 8016766:	2200      	movs	r2, #0
 8016768:	801a      	strh	r2, [r3, #0]
        procBuffer[bufItr++] = ( uint8_t ) joinReqType;
 801676a:	183b      	adds	r3, r7, r0
 801676c:	881b      	ldrh	r3, [r3, #0]
 801676e:	183a      	adds	r2, r7, r0
 8016770:	1c59      	adds	r1, r3, #1
 8016772:	8011      	strh	r1, [r2, #0]
 8016774:	0019      	movs	r1, r3
 8016776:	4b8c      	ldr	r3, [pc, #560]	; (80169a8 <LoRaMacCryptoHandleJoinAccept+0x390>)
 8016778:	2294      	movs	r2, #148	; 0x94
 801677a:	0052      	lsls	r2, r2, #1
 801677c:	4694      	mov	ip, r2
 801677e:	44bc      	add	ip, r7
 8016780:	4463      	add	r3, ip
 8016782:	4a87      	ldr	r2, [pc, #540]	; (80169a0 <LoRaMacCryptoHandleJoinAccept+0x388>)
 8016784:	2494      	movs	r4, #148	; 0x94
 8016786:	0064      	lsls	r4, r4, #1
 8016788:	46a4      	mov	ip, r4
 801678a:	44bc      	add	ip, r7
 801678c:	4462      	add	r2, ip
 801678e:	7812      	ldrb	r2, [r2, #0]
 8016790:	545a      	strb	r2, [r3, r1]

        memcpyr( &procBuffer[bufItr], joinEUI, LORAMAC_JOIN_EUI_FIELD_SIZE );
 8016792:	0004      	movs	r4, r0
 8016794:	193b      	adds	r3, r7, r4
 8016796:	881b      	ldrh	r3, [r3, #0]
 8016798:	2510      	movs	r5, #16
 801679a:	197a      	adds	r2, r7, r5
 801679c:	18d3      	adds	r3, r2, r3
 801679e:	68b9      	ldr	r1, [r7, #8]
 80167a0:	2208      	movs	r2, #8
 80167a2:	0018      	movs	r0, r3
 80167a4:	f004 feec 	bl	801b580 <memcpyr>
        bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;
 80167a8:	193b      	adds	r3, r7, r4
 80167aa:	193a      	adds	r2, r7, r4
 80167ac:	8812      	ldrh	r2, [r2, #0]
 80167ae:	3208      	adds	r2, #8
 80167b0:	801a      	strh	r2, [r3, #0]

        procBuffer[bufItr++] = CryptoCtx.NvmCtx->DevNonce & 0xFF;
 80167b2:	4b7c      	ldr	r3, [pc, #496]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 80167b4:	685b      	ldr	r3, [r3, #4]
 80167b6:	8899      	ldrh	r1, [r3, #4]
 80167b8:	193b      	adds	r3, r7, r4
 80167ba:	881b      	ldrh	r3, [r3, #0]
 80167bc:	193a      	adds	r2, r7, r4
 80167be:	1c58      	adds	r0, r3, #1
 80167c0:	8010      	strh	r0, [r2, #0]
 80167c2:	001a      	movs	r2, r3
 80167c4:	b2c9      	uxtb	r1, r1
 80167c6:	4b78      	ldr	r3, [pc, #480]	; (80169a8 <LoRaMacCryptoHandleJoinAccept+0x390>)
 80167c8:	2094      	movs	r0, #148	; 0x94
 80167ca:	0040      	lsls	r0, r0, #1
 80167cc:	4684      	mov	ip, r0
 80167ce:	44bc      	add	ip, r7
 80167d0:	4463      	add	r3, ip
 80167d2:	5499      	strb	r1, [r3, r2]
        procBuffer[bufItr++] = ( CryptoCtx.NvmCtx->DevNonce >> 8 ) & 0xFF;
 80167d4:	4b73      	ldr	r3, [pc, #460]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 80167d6:	685b      	ldr	r3, [r3, #4]
 80167d8:	889b      	ldrh	r3, [r3, #4]
 80167da:	0a1b      	lsrs	r3, r3, #8
 80167dc:	b299      	uxth	r1, r3
 80167de:	193b      	adds	r3, r7, r4
 80167e0:	881b      	ldrh	r3, [r3, #0]
 80167e2:	193a      	adds	r2, r7, r4
 80167e4:	1c58      	adds	r0, r3, #1
 80167e6:	8010      	strh	r0, [r2, #0]
 80167e8:	001a      	movs	r2, r3
 80167ea:	b2c9      	uxtb	r1, r1
 80167ec:	4b6e      	ldr	r3, [pc, #440]	; (80169a8 <LoRaMacCryptoHandleJoinAccept+0x390>)
 80167ee:	2094      	movs	r0, #148	; 0x94
 80167f0:	0040      	lsls	r0, r0, #1
 80167f2:	4684      	mov	ip, r0
 80167f4:	44bc      	add	ip, r7
 80167f6:	4463      	add	r3, ip
 80167f8:	5499      	strb	r1, [r3, r2]

        procBuffer[bufItr++] = macMsg->MHDR.Value;
 80167fa:	193b      	adds	r3, r7, r4
 80167fc:	881b      	ldrh	r3, [r3, #0]
 80167fe:	193a      	adds	r2, r7, r4
 8016800:	1c59      	adds	r1, r3, #1
 8016802:	8011      	strh	r1, [r2, #0]
 8016804:	001a      	movs	r2, r3
 8016806:	687b      	ldr	r3, [r7, #4]
 8016808:	7959      	ldrb	r1, [r3, #5]
 801680a:	4b67      	ldr	r3, [pc, #412]	; (80169a8 <LoRaMacCryptoHandleJoinAccept+0x390>)
 801680c:	2094      	movs	r0, #148	; 0x94
 801680e:	0040      	lsls	r0, r0, #1
 8016810:	4684      	mov	ip, r0
 8016812:	44bc      	add	ip, r7
 8016814:	4463      	add	r3, ip
 8016816:	5499      	strb	r1, [r3, r2]

        if( SecureElementVerifyAesCmac( procBuffer,  ( macMsg->BufSize + micComputationOffset - LORAMAC_MHDR_FIELD_SIZE - LORAMAC_MIC_FIELD_SIZE ), macMsg->MIC, micComputationKeyID ) != SECURE_ELEMENT_SUCCESS )
 8016818:	687b      	ldr	r3, [r7, #4]
 801681a:	791b      	ldrb	r3, [r3, #4]
 801681c:	b29a      	uxth	r2, r3
 801681e:	2326      	movs	r3, #38	; 0x26
 8016820:	33ff      	adds	r3, #255	; 0xff
 8016822:	18fb      	adds	r3, r7, r3
 8016824:	781b      	ldrb	r3, [r3, #0]
 8016826:	b29b      	uxth	r3, r3
 8016828:	18d3      	adds	r3, r2, r3
 801682a:	b29b      	uxth	r3, r3
 801682c:	3b05      	subs	r3, #5
 801682e:	b299      	uxth	r1, r3
 8016830:	687b      	ldr	r3, [r7, #4]
 8016832:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8016834:	2328      	movs	r3, #40	; 0x28
 8016836:	33ff      	adds	r3, #255	; 0xff
 8016838:	18fb      	adds	r3, r7, r3
 801683a:	781b      	ldrb	r3, [r3, #0]
 801683c:	1978      	adds	r0, r7, r5
 801683e:	f7f8 fd54 	bl	800f2ea <SecureElementVerifyAesCmac>
 8016842:	1e03      	subs	r3, r0, #0
 8016844:	d001      	beq.n	801684a <LoRaMacCryptoHandleJoinAccept+0x232>
        {
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8016846:	230f      	movs	r3, #15
 8016848:	e0ca      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
        }

        // Check if the JoinNonce is greater as the previous one
        uint32_t currentJoinNonce = 0;
 801684a:	2300      	movs	r3, #0
 801684c:	228e      	movs	r2, #142	; 0x8e
 801684e:	0052      	lsls	r2, r2, #1
 8016850:	18b9      	adds	r1, r7, r2
 8016852:	600b      	str	r3, [r1, #0]
        currentJoinNonce = ( uint32_t ) macMsg->JoinNonce[0];
 8016854:	687b      	ldr	r3, [r7, #4]
 8016856:	799b      	ldrb	r3, [r3, #6]
 8016858:	18b9      	adds	r1, r7, r2
 801685a:	600b      	str	r3, [r1, #0]
        currentJoinNonce |= ( ( uint32_t ) macMsg->JoinNonce[1] << 8 );
 801685c:	687b      	ldr	r3, [r7, #4]
 801685e:	79db      	ldrb	r3, [r3, #7]
 8016860:	021b      	lsls	r3, r3, #8
 8016862:	0011      	movs	r1, r2
 8016864:	18ba      	adds	r2, r7, r2
 8016866:	6812      	ldr	r2, [r2, #0]
 8016868:	4313      	orrs	r3, r2
 801686a:	000a      	movs	r2, r1
 801686c:	18b9      	adds	r1, r7, r2
 801686e:	600b      	str	r3, [r1, #0]
        currentJoinNonce |= ( ( uint32_t ) macMsg->JoinNonce[2] << 16 );
 8016870:	687b      	ldr	r3, [r7, #4]
 8016872:	7a1b      	ldrb	r3, [r3, #8]
 8016874:	041b      	lsls	r3, r3, #16
 8016876:	0011      	movs	r1, r2
 8016878:	187a      	adds	r2, r7, r1
 801687a:	6812      	ldr	r2, [r2, #0]
 801687c:	4313      	orrs	r3, r2
 801687e:	187a      	adds	r2, r7, r1
 8016880:	6013      	str	r3, [r2, #0]

        if( currentJoinNonce > CryptoCtx.NvmCtx->JoinNonce )
 8016882:	4b48      	ldr	r3, [pc, #288]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 8016884:	685b      	ldr	r3, [r3, #4]
 8016886:	689b      	ldr	r3, [r3, #8]
 8016888:	187a      	adds	r2, r7, r1
 801688a:	6812      	ldr	r2, [r2, #0]
 801688c:	429a      	cmp	r2, r3
 801688e:	d908      	bls.n	80168a2 <LoRaMacCryptoHandleJoinAccept+0x28a>
        {
            CryptoCtx.NvmCtx->JoinNonce = currentJoinNonce;
 8016890:	4b44      	ldr	r3, [pc, #272]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 8016892:	685b      	ldr	r3, [r3, #4]
 8016894:	187a      	adds	r2, r7, r1
 8016896:	6812      	ldr	r2, [r2, #0]
 8016898:	609a      	str	r2, [r3, #8]
            CryptoCtx.EventCryptoNvmCtxChanged( );
 801689a:	4b42      	ldr	r3, [pc, #264]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 801689c:	689b      	ldr	r3, [r3, #8]
 801689e:	4798      	blx	r3
 80168a0:	e001      	b.n	80168a6 <LoRaMacCryptoHandleJoinAccept+0x28e>
        }
        else
        {
            return LORAMAC_CRYPTO_FAIL_JOIN_NONCE;
 80168a2:	2303      	movs	r3, #3
 80168a4:	e09c      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
    }
    else
#endif
    {
        // prior LoRaWAN 1.1.0
        retval = LoRaMacCryptoDeriveMcRootKey( GEN_APP_KEY );
 80168a6:	2592      	movs	r5, #146	; 0x92
 80168a8:	006d      	lsls	r5, r5, #1
 80168aa:	197c      	adds	r4, r7, r5
 80168ac:	2001      	movs	r0, #1
 80168ae:	f000 f9f3 	bl	8016c98 <LoRaMacCryptoDeriveMcRootKey>
 80168b2:	0003      	movs	r3, r0
 80168b4:	7023      	strb	r3, [r4, #0]
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 80168b6:	002a      	movs	r2, r5
 80168b8:	18bb      	adds	r3, r7, r2
 80168ba:	781b      	ldrb	r3, [r3, #0]
 80168bc:	2b00      	cmp	r3, #0
 80168be:	d002      	beq.n	80168c6 <LoRaMacCryptoHandleJoinAccept+0x2ae>
        {
            return retval;
 80168c0:	18bb      	adds	r3, r7, r2
 80168c2:	781b      	ldrb	r3, [r3, #0]
 80168c4:	e08c      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
        }

        retval = LoRaMacCryptoDeriveMcKEKey( MC_ROOT_KEY );
 80168c6:	2592      	movs	r5, #146	; 0x92
 80168c8:	006d      	lsls	r5, r5, #1
 80168ca:	197c      	adds	r4, r7, r5
 80168cc:	2009      	movs	r0, #9
 80168ce:	f000 fa25 	bl	8016d1c <LoRaMacCryptoDeriveMcKEKey>
 80168d2:	0003      	movs	r3, r0
 80168d4:	7023      	strb	r3, [r4, #0]
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 80168d6:	002a      	movs	r2, r5
 80168d8:	18bb      	adds	r3, r7, r2
 80168da:	781b      	ldrb	r3, [r3, #0]
 80168dc:	2b00      	cmp	r3, #0
 80168de:	d002      	beq.n	80168e6 <LoRaMacCryptoHandleJoinAccept+0x2ce>
        {
            return retval;
 80168e0:	18bb      	adds	r3, r7, r2
 80168e2:	781b      	ldrb	r3, [r3, #0]
 80168e4:	e07c      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
        }

        retval = DeriveSessionKey10x( APP_S_KEY, macMsg->JoinNonce, macMsg->NetID, ( uint8_t* ) &CryptoCtx.NvmCtx->DevNonce );
 80168e6:	687b      	ldr	r3, [r7, #4]
 80168e8:	1d99      	adds	r1, r3, #6
 80168ea:	687b      	ldr	r3, [r7, #4]
 80168ec:	3309      	adds	r3, #9
 80168ee:	001a      	movs	r2, r3
 80168f0:	4b2c      	ldr	r3, [pc, #176]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 80168f2:	685b      	ldr	r3, [r3, #4]
 80168f4:	3304      	adds	r3, #4
 80168f6:	2592      	movs	r5, #146	; 0x92
 80168f8:	006d      	lsls	r5, r5, #1
 80168fa:	197c      	adds	r4, r7, r5
 80168fc:	2008      	movs	r0, #8
 80168fe:	f7ff fb73 	bl	8015fe8 <DeriveSessionKey10x>
 8016902:	0003      	movs	r3, r0
 8016904:	7023      	strb	r3, [r4, #0]
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 8016906:	197b      	adds	r3, r7, r5
 8016908:	781b      	ldrb	r3, [r3, #0]
 801690a:	2b00      	cmp	r3, #0
 801690c:	d002      	beq.n	8016914 <LoRaMacCryptoHandleJoinAccept+0x2fc>
        {
            return retval;
 801690e:	197b      	adds	r3, r7, r5
 8016910:	781b      	ldrb	r3, [r3, #0]
 8016912:	e065      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
        }

        retval = DeriveSessionKey10x( NWK_S_ENC_KEY, macMsg->JoinNonce, macMsg->NetID, ( uint8_t* ) &CryptoCtx.NvmCtx->DevNonce );
 8016914:	687b      	ldr	r3, [r7, #4]
 8016916:	1d99      	adds	r1, r3, #6
 8016918:	687b      	ldr	r3, [r7, #4]
 801691a:	3309      	adds	r3, #9
 801691c:	001a      	movs	r2, r3
 801691e:	4b21      	ldr	r3, [pc, #132]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 8016920:	685b      	ldr	r3, [r3, #4]
 8016922:	3304      	adds	r3, #4
 8016924:	2592      	movs	r5, #146	; 0x92
 8016926:	006d      	lsls	r5, r5, #1
 8016928:	197c      	adds	r4, r7, r5
 801692a:	2007      	movs	r0, #7
 801692c:	f7ff fb5c 	bl	8015fe8 <DeriveSessionKey10x>
 8016930:	0003      	movs	r3, r0
 8016932:	7023      	strb	r3, [r4, #0]
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 8016934:	197b      	adds	r3, r7, r5
 8016936:	781b      	ldrb	r3, [r3, #0]
 8016938:	2b00      	cmp	r3, #0
 801693a:	d002      	beq.n	8016942 <LoRaMacCryptoHandleJoinAccept+0x32a>
        {
            return retval;
 801693c:	197b      	adds	r3, r7, r5
 801693e:	781b      	ldrb	r3, [r3, #0]
 8016940:	e04e      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
        }

        retval = DeriveSessionKey10x( F_NWK_S_INT_KEY, macMsg->JoinNonce, macMsg->NetID, ( uint8_t* ) &CryptoCtx.NvmCtx->DevNonce );
 8016942:	687b      	ldr	r3, [r7, #4]
 8016944:	1d99      	adds	r1, r3, #6
 8016946:	687b      	ldr	r3, [r7, #4]
 8016948:	3309      	adds	r3, #9
 801694a:	001a      	movs	r2, r3
 801694c:	4b15      	ldr	r3, [pc, #84]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 801694e:	685b      	ldr	r3, [r3, #4]
 8016950:	3304      	adds	r3, #4
 8016952:	2592      	movs	r5, #146	; 0x92
 8016954:	006d      	lsls	r5, r5, #1
 8016956:	197c      	adds	r4, r7, r5
 8016958:	2005      	movs	r0, #5
 801695a:	f7ff fb45 	bl	8015fe8 <DeriveSessionKey10x>
 801695e:	0003      	movs	r3, r0
 8016960:	7023      	strb	r3, [r4, #0]
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 8016962:	197b      	adds	r3, r7, r5
 8016964:	781b      	ldrb	r3, [r3, #0]
 8016966:	2b00      	cmp	r3, #0
 8016968:	d002      	beq.n	8016970 <LoRaMacCryptoHandleJoinAccept+0x358>
        {
            return retval;
 801696a:	197b      	adds	r3, r7, r5
 801696c:	781b      	ldrb	r3, [r3, #0]
 801696e:	e037      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
        }

        retval = DeriveSessionKey10x( S_NWK_S_INT_KEY, macMsg->JoinNonce, macMsg->NetID, ( uint8_t* ) &CryptoCtx.NvmCtx->DevNonce );
 8016970:	687b      	ldr	r3, [r7, #4]
 8016972:	1d99      	adds	r1, r3, #6
 8016974:	687b      	ldr	r3, [r7, #4]
 8016976:	3309      	adds	r3, #9
 8016978:	001a      	movs	r2, r3
 801697a:	4b0a      	ldr	r3, [pc, #40]	; (80169a4 <LoRaMacCryptoHandleJoinAccept+0x38c>)
 801697c:	685b      	ldr	r3, [r3, #4]
 801697e:	3304      	adds	r3, #4
 8016980:	2592      	movs	r5, #146	; 0x92
 8016982:	006d      	lsls	r5, r5, #1
 8016984:	197c      	adds	r4, r7, r5
 8016986:	2006      	movs	r0, #6
 8016988:	f7ff fb2e 	bl	8015fe8 <DeriveSessionKey10x>
 801698c:	0003      	movs	r3, r0
 801698e:	7023      	strb	r3, [r4, #0]
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 8016990:	197b      	adds	r3, r7, r5
 8016992:	781b      	ldrb	r3, [r3, #0]
 8016994:	2b00      	cmp	r3, #0
 8016996:	d009      	beq.n	80169ac <LoRaMacCryptoHandleJoinAccept+0x394>
        {
            return retval;
 8016998:	197b      	adds	r3, r7, r5
 801699a:	781b      	ldrb	r3, [r3, #0]
 801699c:	e020      	b.n	80169e0 <LoRaMacCryptoHandleJoinAccept+0x3c8>
 801699e:	46c0      	nop			; (mov r8, r8)
 80169a0:	fffffee7 	.word	0xfffffee7
 80169a4:	20001080 	.word	0x20001080
 80169a8:	fffffee8 	.word	0xfffffee8
        }
    }

    // Join-Accept is successfully processed, reset frame counters
    CryptoCtx.RJcount0 = 0;
 80169ac:	4b0e      	ldr	r3, [pc, #56]	; (80169e8 <LoRaMacCryptoHandleJoinAccept+0x3d0>)
 80169ae:	2200      	movs	r2, #0
 80169b0:	801a      	strh	r2, [r3, #0]
    CryptoCtx.NvmCtx->FCntList.FCntUp = 0;
 80169b2:	4b0d      	ldr	r3, [pc, #52]	; (80169e8 <LoRaMacCryptoHandleJoinAccept+0x3d0>)
 80169b4:	685b      	ldr	r3, [r3, #4]
 80169b6:	2200      	movs	r2, #0
 80169b8:	60da      	str	r2, [r3, #12]
    CryptoCtx.NvmCtx->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 80169ba:	4b0b      	ldr	r3, [pc, #44]	; (80169e8 <LoRaMacCryptoHandleJoinAccept+0x3d0>)
 80169bc:	685b      	ldr	r3, [r3, #4]
 80169be:	2201      	movs	r2, #1
 80169c0:	4252      	negs	r2, r2
 80169c2:	619a      	str	r2, [r3, #24]
    CryptoCtx.NvmCtx->FCntList.NFCntDown = FCNT_DOWN_INITAL_VALUE;
 80169c4:	4b08      	ldr	r3, [pc, #32]	; (80169e8 <LoRaMacCryptoHandleJoinAccept+0x3d0>)
 80169c6:	685b      	ldr	r3, [r3, #4]
 80169c8:	2201      	movs	r2, #1
 80169ca:	4252      	negs	r2, r2
 80169cc:	611a      	str	r2, [r3, #16]
    CryptoCtx.NvmCtx->FCntList.AFCntDown = FCNT_DOWN_INITAL_VALUE;
 80169ce:	4b06      	ldr	r3, [pc, #24]	; (80169e8 <LoRaMacCryptoHandleJoinAccept+0x3d0>)
 80169d0:	685b      	ldr	r3, [r3, #4]
 80169d2:	2201      	movs	r2, #1
 80169d4:	4252      	negs	r2, r2
 80169d6:	615a      	str	r2, [r3, #20]
    CryptoCtx.EventCryptoNvmCtxChanged( );
 80169d8:	4b03      	ldr	r3, [pc, #12]	; (80169e8 <LoRaMacCryptoHandleJoinAccept+0x3d0>)
 80169da:	689b      	ldr	r3, [r3, #8]
 80169dc:	4798      	blx	r3

    return LORAMAC_CRYPTO_SUCCESS;
 80169de:	2300      	movs	r3, #0
}
 80169e0:	0018      	movs	r0, r3
 80169e2:	46bd      	mov	sp, r7
 80169e4:	b04a      	add	sp, #296	; 0x128
 80169e6:	bdb0      	pop	{r4, r5, r7, pc}
 80169e8:	20001080 	.word	0x20001080

080169ec <LoRaMacCryptoSecureMessage>:

LoRaMacCryptoStatus_t LoRaMacCryptoSecureMessage( uint32_t fCntUp, uint8_t txDr, uint8_t txCh, LoRaMacMessageData_t* macMsg )
{
 80169ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80169ee:	b08b      	sub	sp, #44	; 0x2c
 80169f0:	af04      	add	r7, sp, #16
 80169f2:	60f8      	str	r0, [r7, #12]
 80169f4:	0008      	movs	r0, r1
 80169f6:	0011      	movs	r1, r2
 80169f8:	607b      	str	r3, [r7, #4]
 80169fa:	230b      	movs	r3, #11
 80169fc:	18fb      	adds	r3, r7, r3
 80169fe:	1c02      	adds	r2, r0, #0
 8016a00:	701a      	strb	r2, [r3, #0]
 8016a02:	230a      	movs	r3, #10
 8016a04:	18fb      	adds	r3, r7, r3
 8016a06:	1c0a      	adds	r2, r1, #0
 8016a08:	701a      	strb	r2, [r3, #0]
    LoRaMacCryptoStatus_t retval = LORAMAC_CRYPTO_ERROR;
 8016a0a:	2316      	movs	r3, #22
 8016a0c:	18fb      	adds	r3, r7, r3
 8016a0e:	2213      	movs	r2, #19
 8016a10:	701a      	strb	r2, [r3, #0]
    KeyIdentifier_t payloadDecryptionKeyID = APP_S_KEY;
 8016a12:	2317      	movs	r3, #23
 8016a14:	18fb      	adds	r3, r7, r3
 8016a16:	2208      	movs	r2, #8
 8016a18:	701a      	strb	r2, [r3, #0]

    if( macMsg == NULL )
 8016a1a:	687b      	ldr	r3, [r7, #4]
 8016a1c:	2b00      	cmp	r3, #0
 8016a1e:	d101      	bne.n	8016a24 <LoRaMacCryptoSecureMessage+0x38>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 8016a20:	230a      	movs	r3, #10
 8016a22:	e06b      	b.n	8016afc <LoRaMacCryptoSecureMessage+0x110>
    }

    if( fCntUp < CryptoCtx.NvmCtx->FCntList.FCntUp )
 8016a24:	4b37      	ldr	r3, [pc, #220]	; (8016b04 <LoRaMacCryptoSecureMessage+0x118>)
 8016a26:	685b      	ldr	r3, [r3, #4]
 8016a28:	68db      	ldr	r3, [r3, #12]
 8016a2a:	68fa      	ldr	r2, [r7, #12]
 8016a2c:	429a      	cmp	r2, r3
 8016a2e:	d201      	bcs.n	8016a34 <LoRaMacCryptoSecureMessage+0x48>
    {
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 8016a30:	2306      	movs	r3, #6
 8016a32:	e063      	b.n	8016afc <LoRaMacCryptoSecureMessage+0x110>
    }

    // Encrypt payload
    if( macMsg->FPort == 0 )
 8016a34:	687b      	ldr	r3, [r7, #4]
 8016a36:	2220      	movs	r2, #32
 8016a38:	5c9b      	ldrb	r3, [r3, r2]
 8016a3a:	2b00      	cmp	r3, #0
 8016a3c:	d103      	bne.n	8016a46 <LoRaMacCryptoSecureMessage+0x5a>
    {
        // Use network session key
        payloadDecryptionKeyID = NWK_S_ENC_KEY;
 8016a3e:	2317      	movs	r3, #23
 8016a40:	18fb      	adds	r3, r7, r3
 8016a42:	2207      	movs	r2, #7
 8016a44:	701a      	strb	r2, [r3, #0]
    }

    if( fCntUp > CryptoCtx.NvmCtx->FCntList.FCntUp )
 8016a46:	4b2f      	ldr	r3, [pc, #188]	; (8016b04 <LoRaMacCryptoSecureMessage+0x118>)
 8016a48:	685b      	ldr	r3, [r3, #4]
 8016a4a:	68db      	ldr	r3, [r3, #12]
 8016a4c:	68fa      	ldr	r2, [r7, #12]
 8016a4e:	429a      	cmp	r2, r3
 8016a50:	d91c      	bls.n	8016a8c <LoRaMacCryptoSecureMessage+0xa0>
    {
        retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, macMsg->FHDR.DevAddr, UPLINK, fCntUp );
 8016a52:	687b      	ldr	r3, [r7, #4]
 8016a54:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8016a56:	687b      	ldr	r3, [r7, #4]
 8016a58:	2228      	movs	r2, #40	; 0x28
 8016a5a:	5c9b      	ldrb	r3, [r3, r2]
 8016a5c:	b219      	sxth	r1, r3
 8016a5e:	687b      	ldr	r3, [r7, #4]
 8016a60:	689d      	ldr	r5, [r3, #8]
 8016a62:	2616      	movs	r6, #22
 8016a64:	19bc      	adds	r4, r7, r6
 8016a66:	2317      	movs	r3, #23
 8016a68:	18fb      	adds	r3, r7, r3
 8016a6a:	781a      	ldrb	r2, [r3, #0]
 8016a6c:	68fb      	ldr	r3, [r7, #12]
 8016a6e:	9301      	str	r3, [sp, #4]
 8016a70:	2300      	movs	r3, #0
 8016a72:	9300      	str	r3, [sp, #0]
 8016a74:	002b      	movs	r3, r5
 8016a76:	f7ff f833 	bl	8015ae0 <PayloadEncrypt>
 8016a7a:	0003      	movs	r3, r0
 8016a7c:	7023      	strb	r3, [r4, #0]
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 8016a7e:	19bb      	adds	r3, r7, r6
 8016a80:	781b      	ldrb	r3, [r3, #0]
 8016a82:	2b00      	cmp	r3, #0
 8016a84:	d002      	beq.n	8016a8c <LoRaMacCryptoSecureMessage+0xa0>
        {
            return retval;
 8016a86:	19bb      	adds	r3, r7, r6
 8016a88:	781b      	ldrb	r3, [r3, #0]
 8016a8a:	e037      	b.n	8016afc <LoRaMacCryptoSecureMessage+0x110>
                return retval;
            }
        }
#endif
    }
    CryptoCtx.NvmCtx->FCntList.FCntUp = fCntUp;
 8016a8c:	4b1d      	ldr	r3, [pc, #116]	; (8016b04 <LoRaMacCryptoSecureMessage+0x118>)
 8016a8e:	685b      	ldr	r3, [r3, #4]
 8016a90:	68fa      	ldr	r2, [r7, #12]
 8016a92:	60da      	str	r2, [r3, #12]
    CryptoCtx.EventCryptoNvmCtxChanged( );
 8016a94:	4b1b      	ldr	r3, [pc, #108]	; (8016b04 <LoRaMacCryptoSecureMessage+0x118>)
 8016a96:	689b      	ldr	r3, [r3, #8]
 8016a98:	4798      	blx	r3

    // Serialize message
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 8016a9a:	687b      	ldr	r3, [r7, #4]
 8016a9c:	0018      	movs	r0, r3
 8016a9e:	f000 fc02 	bl	80172a6 <LoRaMacSerializerData>
 8016aa2:	1e03      	subs	r3, r0, #0
 8016aa4:	d001      	beq.n	8016aaa <LoRaMacCryptoSecureMessage+0xbe>
    {
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 8016aa6:	2311      	movs	r3, #17
 8016aa8:	e028      	b.n	8016afc <LoRaMacCryptoSecureMessage+0x110>
    else
#endif
    {
        // MIC = cmacF[0..3]
        // The IsAck parameter is every time false since the ConfFCnt field is not used in legacy mode.
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), NWK_S_ENC_KEY, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 8016aaa:	687b      	ldr	r3, [r7, #4]
 8016aac:	6818      	ldr	r0, [r3, #0]
 8016aae:	687b      	ldr	r3, [r7, #4]
 8016ab0:	791b      	ldrb	r3, [r3, #4]
 8016ab2:	b29b      	uxth	r3, r3
 8016ab4:	3b04      	subs	r3, #4
 8016ab6:	b299      	uxth	r1, r3
 8016ab8:	687b      	ldr	r3, [r7, #4]
 8016aba:	689b      	ldr	r3, [r3, #8]
 8016abc:	687a      	ldr	r2, [r7, #4]
 8016abe:	322c      	adds	r2, #44	; 0x2c
 8016ac0:	2516      	movs	r5, #22
 8016ac2:	197c      	adds	r4, r7, r5
 8016ac4:	9203      	str	r2, [sp, #12]
 8016ac6:	68fa      	ldr	r2, [r7, #12]
 8016ac8:	9202      	str	r2, [sp, #8]
 8016aca:	9301      	str	r3, [sp, #4]
 8016acc:	2300      	movs	r3, #0
 8016ace:	9300      	str	r3, [sp, #0]
 8016ad0:	2300      	movs	r3, #0
 8016ad2:	2207      	movs	r2, #7
 8016ad4:	f7ff f95c 	bl	8015d90 <ComputeCmacB0>
 8016ad8:	0003      	movs	r3, r0
 8016ada:	7023      	strb	r3, [r4, #0]
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 8016adc:	197b      	adds	r3, r7, r5
 8016ade:	781b      	ldrb	r3, [r3, #0]
 8016ae0:	2b00      	cmp	r3, #0
 8016ae2:	d002      	beq.n	8016aea <LoRaMacCryptoSecureMessage+0xfe>
        {
            return retval;
 8016ae4:	197b      	adds	r3, r7, r5
 8016ae6:	781b      	ldrb	r3, [r3, #0]
 8016ae8:	e008      	b.n	8016afc <LoRaMacCryptoSecureMessage+0x110>
        }
    }

    // Re-serialize message to add the MIC
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 8016aea:	687b      	ldr	r3, [r7, #4]
 8016aec:	0018      	movs	r0, r3
 8016aee:	f000 fbda 	bl	80172a6 <LoRaMacSerializerData>
 8016af2:	1e03      	subs	r3, r0, #0
 8016af4:	d001      	beq.n	8016afa <LoRaMacCryptoSecureMessage+0x10e>
    {
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 8016af6:	2311      	movs	r3, #17
 8016af8:	e000      	b.n	8016afc <LoRaMacCryptoSecureMessage+0x110>
    }

    return LORAMAC_CRYPTO_SUCCESS;
 8016afa:	2300      	movs	r3, #0
}
 8016afc:	0018      	movs	r0, r3
 8016afe:	46bd      	mov	sp, r7
 8016b00:	b007      	add	sp, #28
 8016b02:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8016b04:	20001080 	.word	0x20001080

08016b08 <LoRaMacCryptoUnsecureMessage>:

LoRaMacCryptoStatus_t LoRaMacCryptoUnsecureMessage( AddressIdentifier_t addrID, uint32_t address, FCntIdentifier_t fCntID, uint32_t fCntDown, LoRaMacMessageData_t* macMsg )
{
 8016b08:	b5f0      	push	{r4, r5, r6, r7, lr}
 8016b0a:	b08b      	sub	sp, #44	; 0x2c
 8016b0c:	af04      	add	r7, sp, #16
 8016b0e:	60b9      	str	r1, [r7, #8]
 8016b10:	0011      	movs	r1, r2
 8016b12:	607b      	str	r3, [r7, #4]
 8016b14:	230f      	movs	r3, #15
 8016b16:	18fb      	adds	r3, r7, r3
 8016b18:	1c02      	adds	r2, r0, #0
 8016b1a:	701a      	strb	r2, [r3, #0]
 8016b1c:	230e      	movs	r3, #14
 8016b1e:	18fb      	adds	r3, r7, r3
 8016b20:	1c0a      	adds	r2, r1, #0
 8016b22:	701a      	strb	r2, [r3, #0]
    if( macMsg == 0 )
 8016b24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016b26:	2b00      	cmp	r3, #0
 8016b28:	d101      	bne.n	8016b2e <LoRaMacCryptoUnsecureMessage+0x26>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 8016b2a:	230a      	movs	r3, #10
 8016b2c:	e0ae      	b.n	8016c8c <LoRaMacCryptoUnsecureMessage+0x184>
    }

    if( CheckFCntDown( fCntID, fCntDown ) == false )
 8016b2e:	687a      	ldr	r2, [r7, #4]
 8016b30:	230e      	movs	r3, #14
 8016b32:	18fb      	adds	r3, r7, r3
 8016b34:	781b      	ldrb	r3, [r3, #0]
 8016b36:	0011      	movs	r1, r2
 8016b38:	0018      	movs	r0, r3
 8016b3a:	f7ff fb13 	bl	8016164 <CheckFCntDown>
 8016b3e:	0003      	movs	r3, r0
 8016b40:	001a      	movs	r2, r3
 8016b42:	2301      	movs	r3, #1
 8016b44:	4053      	eors	r3, r2
 8016b46:	b2db      	uxtb	r3, r3
 8016b48:	2b00      	cmp	r3, #0
 8016b4a:	d001      	beq.n	8016b50 <LoRaMacCryptoUnsecureMessage+0x48>
    {
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 8016b4c:	2306      	movs	r3, #6
 8016b4e:	e09d      	b.n	8016c8c <LoRaMacCryptoUnsecureMessage+0x184>
    }

    LoRaMacCryptoStatus_t retval = LORAMAC_CRYPTO_ERROR;
 8016b50:	2315      	movs	r3, #21
 8016b52:	18fb      	adds	r3, r7, r3
 8016b54:	2213      	movs	r2, #19
 8016b56:	701a      	strb	r2, [r3, #0]
    KeyIdentifier_t payloadDecryptionKeyID = APP_S_KEY;
 8016b58:	2317      	movs	r3, #23
 8016b5a:	18fb      	adds	r3, r7, r3
 8016b5c:	2208      	movs	r2, #8
 8016b5e:	701a      	strb	r2, [r3, #0]
    KeyIdentifier_t micComputationKeyID = S_NWK_S_INT_KEY;
 8016b60:	2314      	movs	r3, #20
 8016b62:	18fb      	adds	r3, r7, r3
 8016b64:	2206      	movs	r2, #6
 8016b66:	701a      	strb	r2, [r3, #0]
    KeyAddr_t* curItem;

    // Parse the message
    if( LoRaMacParserData( macMsg ) != LORAMAC_PARSER_SUCCESS )
 8016b68:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016b6a:	0018      	movs	r0, r3
 8016b6c:	f000 f9f0 	bl	8016f50 <LoRaMacParserData>
 8016b70:	1e03      	subs	r3, r0, #0
 8016b72:	d001      	beq.n	8016b78 <LoRaMacCryptoUnsecureMessage+0x70>
    {
        return LORAMAC_CRYPTO_ERROR_PARSER;
 8016b74:	2310      	movs	r3, #16
 8016b76:	e089      	b.n	8016c8c <LoRaMacCryptoUnsecureMessage+0x184>
    }

    // Determine current security context
    retval = GetKeyAddrItem( addrID, &curItem );
 8016b78:	2515      	movs	r5, #21
 8016b7a:	197c      	adds	r4, r7, r5
 8016b7c:	2310      	movs	r3, #16
 8016b7e:	18fa      	adds	r2, r7, r3
 8016b80:	230f      	movs	r3, #15
 8016b82:	18fb      	adds	r3, r7, r3
 8016b84:	781b      	ldrb	r3, [r3, #0]
 8016b86:	0011      	movs	r1, r2
 8016b88:	0018      	movs	r0, r3
 8016b8a:	f7ff f9fb 	bl	8015f84 <GetKeyAddrItem>
 8016b8e:	0003      	movs	r3, r0
 8016b90:	7023      	strb	r3, [r4, #0]
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 8016b92:	197b      	adds	r3, r7, r5
 8016b94:	781b      	ldrb	r3, [r3, #0]
 8016b96:	2b00      	cmp	r3, #0
 8016b98:	d002      	beq.n	8016ba0 <LoRaMacCryptoUnsecureMessage+0x98>
    {
        return retval;
 8016b9a:	197b      	adds	r3, r7, r5
 8016b9c:	781b      	ldrb	r3, [r3, #0]
 8016b9e:	e075      	b.n	8016c8c <LoRaMacCryptoUnsecureMessage+0x184>
    }

    payloadDecryptionKeyID = curItem->AppSkey;
 8016ba0:	693a      	ldr	r2, [r7, #16]
 8016ba2:	2317      	movs	r3, #23
 8016ba4:	18fb      	adds	r3, r7, r3
 8016ba6:	7852      	ldrb	r2, [r2, #1]
 8016ba8:	701a      	strb	r2, [r3, #0]
    micComputationKeyID = curItem->NwkSkey;
 8016baa:	693a      	ldr	r2, [r7, #16]
 8016bac:	2314      	movs	r3, #20
 8016bae:	18fb      	adds	r3, r7, r3
 8016bb0:	7892      	ldrb	r2, [r2, #2]
 8016bb2:	701a      	strb	r2, [r3, #0]

    // Check if it is our address
    if( address != macMsg->FHDR.DevAddr )
 8016bb4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016bb6:	689b      	ldr	r3, [r3, #8]
 8016bb8:	68ba      	ldr	r2, [r7, #8]
 8016bba:	429a      	cmp	r2, r3
 8016bbc:	d001      	beq.n	8016bc2 <LoRaMacCryptoUnsecureMessage+0xba>
    {
        return LORAMAC_CRYPTO_FAIL_ADDRESS;
 8016bbe:	2302      	movs	r3, #2
 8016bc0:	e064      	b.n	8016c8c <LoRaMacCryptoUnsecureMessage+0x184>
    }

    // Compute mic
    bool isAck = macMsg->FHDR.FCtrl.Bits.Ack;
 8016bc2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016bc4:	7b1b      	ldrb	r3, [r3, #12]
 8016bc6:	069b      	lsls	r3, r3, #26
 8016bc8:	0fdb      	lsrs	r3, r3, #31
 8016bca:	b2db      	uxtb	r3, r3
 8016bcc:	001a      	movs	r2, r3
 8016bce:	2016      	movs	r0, #22
 8016bd0:	183b      	adds	r3, r7, r0
 8016bd2:	1e51      	subs	r1, r2, #1
 8016bd4:	418a      	sbcs	r2, r1
 8016bd6:	701a      	strb	r2, [r3, #0]
    if( CryptoCtx.NvmCtx->LrWanVersion.Fields.Minor == 0 )
 8016bd8:	4b2e      	ldr	r3, [pc, #184]	; (8016c94 <LoRaMacCryptoUnsecureMessage+0x18c>)
 8016bda:	685b      	ldr	r3, [r3, #4]
 8016bdc:	789b      	ldrb	r3, [r3, #2]
 8016bde:	2b00      	cmp	r3, #0
 8016be0:	d102      	bne.n	8016be8 <LoRaMacCryptoUnsecureMessage+0xe0>
    {
        // In legacy mode the IsAck parameter is forced to be false since the ConfFCnt field is not used.
        isAck = false;
 8016be2:	183b      	adds	r3, r7, r0
 8016be4:	2200      	movs	r2, #0
 8016be6:	701a      	strb	r2, [r3, #0]
    }

    // Verify mic
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 8016be8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016bea:	6818      	ldr	r0, [r3, #0]
 8016bec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016bee:	791b      	ldrb	r3, [r3, #4]
 8016bf0:	b29b      	uxth	r3, r3
 8016bf2:	3b04      	subs	r3, #4
 8016bf4:	b299      	uxth	r1, r3
 8016bf6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016bf8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8016bfa:	2615      	movs	r6, #21
 8016bfc:	19bc      	adds	r4, r7, r6
 8016bfe:	2216      	movs	r2, #22
 8016c00:	18ba      	adds	r2, r7, r2
 8016c02:	7815      	ldrb	r5, [r2, #0]
 8016c04:	2214      	movs	r2, #20
 8016c06:	18ba      	adds	r2, r7, r2
 8016c08:	7812      	ldrb	r2, [r2, #0]
 8016c0a:	9303      	str	r3, [sp, #12]
 8016c0c:	687b      	ldr	r3, [r7, #4]
 8016c0e:	9302      	str	r3, [sp, #8]
 8016c10:	68bb      	ldr	r3, [r7, #8]
 8016c12:	9301      	str	r3, [sp, #4]
 8016c14:	2301      	movs	r3, #1
 8016c16:	9300      	str	r3, [sp, #0]
 8016c18:	002b      	movs	r3, r5
 8016c1a:	f7ff f901 	bl	8015e20 <VerifyCmacB0>
 8016c1e:	0003      	movs	r3, r0
 8016c20:	7023      	strb	r3, [r4, #0]
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 8016c22:	19bb      	adds	r3, r7, r6
 8016c24:	781b      	ldrb	r3, [r3, #0]
 8016c26:	2b00      	cmp	r3, #0
 8016c28:	d002      	beq.n	8016c30 <LoRaMacCryptoUnsecureMessage+0x128>
    {
        return retval;
 8016c2a:	19bb      	adds	r3, r7, r6
 8016c2c:	781b      	ldrb	r3, [r3, #0]
 8016c2e:	e02d      	b.n	8016c8c <LoRaMacCryptoUnsecureMessage+0x184>
    }

    // Decrypt payload
    if( macMsg->FPort == 0 )
 8016c30:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016c32:	2220      	movs	r2, #32
 8016c34:	5c9b      	ldrb	r3, [r3, r2]
 8016c36:	2b00      	cmp	r3, #0
 8016c38:	d103      	bne.n	8016c42 <LoRaMacCryptoUnsecureMessage+0x13a>
    {
        // Use network session encryption key
        payloadDecryptionKeyID = NWK_S_ENC_KEY;
 8016c3a:	2317      	movs	r3, #23
 8016c3c:	18fb      	adds	r3, r7, r3
 8016c3e:	2207      	movs	r2, #7
 8016c40:	701a      	strb	r2, [r3, #0]
    }
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 8016c42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016c44:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8016c46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016c48:	2228      	movs	r2, #40	; 0x28
 8016c4a:	5c9b      	ldrb	r3, [r3, r2]
 8016c4c:	b219      	sxth	r1, r3
 8016c4e:	2615      	movs	r6, #21
 8016c50:	19bc      	adds	r4, r7, r6
 8016c52:	68bd      	ldr	r5, [r7, #8]
 8016c54:	2317      	movs	r3, #23
 8016c56:	18fb      	adds	r3, r7, r3
 8016c58:	781a      	ldrb	r2, [r3, #0]
 8016c5a:	687b      	ldr	r3, [r7, #4]
 8016c5c:	9301      	str	r3, [sp, #4]
 8016c5e:	2301      	movs	r3, #1
 8016c60:	9300      	str	r3, [sp, #0]
 8016c62:	002b      	movs	r3, r5
 8016c64:	f7fe ff3c 	bl	8015ae0 <PayloadEncrypt>
 8016c68:	0003      	movs	r3, r0
 8016c6a:	7023      	strb	r3, [r4, #0]
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 8016c6c:	19bb      	adds	r3, r7, r6
 8016c6e:	781b      	ldrb	r3, [r3, #0]
 8016c70:	2b00      	cmp	r3, #0
 8016c72:	d002      	beq.n	8016c7a <LoRaMacCryptoUnsecureMessage+0x172>
    {
        return retval;
 8016c74:	19bb      	adds	r3, r7, r6
 8016c76:	781b      	ldrb	r3, [r3, #0]
 8016c78:	e008      	b.n	8016c8c <LoRaMacCryptoUnsecureMessage+0x184>
            return retval;
        }
    }
#endif

    UpdateFCntDown( fCntID, fCntDown );
 8016c7a:	687a      	ldr	r2, [r7, #4]
 8016c7c:	230e      	movs	r3, #14
 8016c7e:	18fb      	adds	r3, r7, r3
 8016c80:	781b      	ldrb	r3, [r3, #0]
 8016c82:	0011      	movs	r1, r2
 8016c84:	0018      	movs	r0, r3
 8016c86:	f7ff fa91 	bl	80161ac <UpdateFCntDown>

    return LORAMAC_CRYPTO_SUCCESS;
 8016c8a:	2300      	movs	r3, #0
}
 8016c8c:	0018      	movs	r0, r3
 8016c8e:	46bd      	mov	sp, r7
 8016c90:	b007      	add	sp, #28
 8016c92:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8016c94:	20001080 	.word	0x20001080

08016c98 <LoRaMacCryptoDeriveMcRootKey>:

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcRootKey( KeyIdentifier_t keyID )
{
 8016c98:	b590      	push	{r4, r7, lr}
 8016c9a:	b087      	sub	sp, #28
 8016c9c:	af00      	add	r7, sp, #0
 8016c9e:	0002      	movs	r2, r0
 8016ca0:	1dfb      	adds	r3, r7, #7
 8016ca2:	701a      	strb	r2, [r3, #0]
    // Prevent other keys than GenAppKey for LoRaWAN 1.0.x or AppKey for LoRaWAN 1.1 or later
    if( ( ( keyID == APP_KEY ) && ( CryptoCtx.NvmCtx->LrWanVersion.Fields.Minor == 0 ) ) ||
 8016ca4:	1dfb      	adds	r3, r7, #7
 8016ca6:	781b      	ldrb	r3, [r3, #0]
 8016ca8:	2b00      	cmp	r3, #0
 8016caa:	d104      	bne.n	8016cb6 <LoRaMacCryptoDeriveMcRootKey+0x1e>
 8016cac:	4b1a      	ldr	r3, [pc, #104]	; (8016d18 <LoRaMacCryptoDeriveMcRootKey+0x80>)
 8016cae:	685b      	ldr	r3, [r3, #4]
 8016cb0:	789b      	ldrb	r3, [r3, #2]
 8016cb2:	2b00      	cmp	r3, #0
 8016cb4:	d008      	beq.n	8016cc8 <LoRaMacCryptoDeriveMcRootKey+0x30>
 8016cb6:	1dfb      	adds	r3, r7, #7
 8016cb8:	781b      	ldrb	r3, [r3, #0]
 8016cba:	2b01      	cmp	r3, #1
 8016cbc:	d106      	bne.n	8016ccc <LoRaMacCryptoDeriveMcRootKey+0x34>
        ( ( keyID == GEN_APP_KEY ) && ( CryptoCtx.NvmCtx->LrWanVersion.Fields.Minor == 1 ) ) )
 8016cbe:	4b16      	ldr	r3, [pc, #88]	; (8016d18 <LoRaMacCryptoDeriveMcRootKey+0x80>)
 8016cc0:	685b      	ldr	r3, [r3, #4]
 8016cc2:	789b      	ldrb	r3, [r3, #2]
 8016cc4:	2b01      	cmp	r3, #1
 8016cc6:	d101      	bne.n	8016ccc <LoRaMacCryptoDeriveMcRootKey+0x34>
    {
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
 8016cc8:	230b      	movs	r3, #11
 8016cca:	e020      	b.n	8016d0e <LoRaMacCryptoDeriveMcRootKey+0x76>
    }
    uint8_t compBase[16] = { 0 };
 8016ccc:	2408      	movs	r4, #8
 8016cce:	193b      	adds	r3, r7, r4
 8016cd0:	2200      	movs	r2, #0
 8016cd2:	601a      	str	r2, [r3, #0]
 8016cd4:	3304      	adds	r3, #4
 8016cd6:	220c      	movs	r2, #12
 8016cd8:	2100      	movs	r1, #0
 8016cda:	0018      	movs	r0, r3
 8016cdc:	f006 fc3a 	bl	801d554 <memset>

    if( CryptoCtx.NvmCtx->LrWanVersion.Fields.Minor == 1 )
 8016ce0:	4b0d      	ldr	r3, [pc, #52]	; (8016d18 <LoRaMacCryptoDeriveMcRootKey+0x80>)
 8016ce2:	685b      	ldr	r3, [r3, #4]
 8016ce4:	789b      	ldrb	r3, [r3, #2]
 8016ce6:	2b01      	cmp	r3, #1
 8016ce8:	d102      	bne.n	8016cf0 <LoRaMacCryptoDeriveMcRootKey+0x58>
    {
        compBase[0] = 0x20;
 8016cea:	193b      	adds	r3, r7, r4
 8016cec:	2220      	movs	r2, #32
 8016cee:	701a      	strb	r2, [r3, #0]
    }
    if( SecureElementDeriveAndStoreKey( CryptoCtx.NvmCtx->LrWanVersion, compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 8016cf0:	4b09      	ldr	r3, [pc, #36]	; (8016d18 <LoRaMacCryptoDeriveMcRootKey+0x80>)
 8016cf2:	685b      	ldr	r3, [r3, #4]
 8016cf4:	1dfa      	adds	r2, r7, #7
 8016cf6:	7812      	ldrb	r2, [r2, #0]
 8016cf8:	2108      	movs	r1, #8
 8016cfa:	1879      	adds	r1, r7, r1
 8016cfc:	6818      	ldr	r0, [r3, #0]
 8016cfe:	2309      	movs	r3, #9
 8016d00:	f7f8 fb9e 	bl	800f440 <SecureElementDeriveAndStoreKey>
 8016d04:	1e03      	subs	r3, r0, #0
 8016d06:	d001      	beq.n	8016d0c <LoRaMacCryptoDeriveMcRootKey+0x74>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8016d08:	230f      	movs	r3, #15
 8016d0a:	e000      	b.n	8016d0e <LoRaMacCryptoDeriveMcRootKey+0x76>
    }

    return LORAMAC_CRYPTO_SUCCESS;
 8016d0c:	2300      	movs	r3, #0
}
 8016d0e:	0018      	movs	r0, r3
 8016d10:	46bd      	mov	sp, r7
 8016d12:	b007      	add	sp, #28
 8016d14:	bd90      	pop	{r4, r7, pc}
 8016d16:	46c0      	nop			; (mov r8, r8)
 8016d18:	20001080 	.word	0x20001080

08016d1c <LoRaMacCryptoDeriveMcKEKey>:

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcKEKey( KeyIdentifier_t keyID )
{
 8016d1c:	b590      	push	{r4, r7, lr}
 8016d1e:	b087      	sub	sp, #28
 8016d20:	af00      	add	r7, sp, #0
 8016d22:	0002      	movs	r2, r0
 8016d24:	1dfb      	adds	r3, r7, #7
 8016d26:	701a      	strb	r2, [r3, #0]
    // Prevent other keys than McRootKey
    if( keyID != MC_ROOT_KEY )
 8016d28:	1dfb      	adds	r3, r7, #7
 8016d2a:	781b      	ldrb	r3, [r3, #0]
 8016d2c:	2b09      	cmp	r3, #9
 8016d2e:	d001      	beq.n	8016d34 <LoRaMacCryptoDeriveMcKEKey+0x18>
    {
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
 8016d30:	230b      	movs	r3, #11
 8016d32:	e017      	b.n	8016d64 <LoRaMacCryptoDeriveMcKEKey+0x48>
    }
    uint8_t compBase[16] = { 0 };
 8016d34:	2408      	movs	r4, #8
 8016d36:	193b      	adds	r3, r7, r4
 8016d38:	2200      	movs	r2, #0
 8016d3a:	601a      	str	r2, [r3, #0]
 8016d3c:	3304      	adds	r3, #4
 8016d3e:	220c      	movs	r2, #12
 8016d40:	2100      	movs	r1, #0
 8016d42:	0018      	movs	r0, r3
 8016d44:	f006 fc06 	bl	801d554 <memset>

    if( SecureElementDeriveAndStoreKey( CryptoCtx.NvmCtx->LrWanVersion, compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 8016d48:	4b08      	ldr	r3, [pc, #32]	; (8016d6c <LoRaMacCryptoDeriveMcKEKey+0x50>)
 8016d4a:	685b      	ldr	r3, [r3, #4]
 8016d4c:	1dfa      	adds	r2, r7, #7
 8016d4e:	7812      	ldrb	r2, [r2, #0]
 8016d50:	1939      	adds	r1, r7, r4
 8016d52:	6818      	ldr	r0, [r3, #0]
 8016d54:	237f      	movs	r3, #127	; 0x7f
 8016d56:	f7f8 fb73 	bl	800f440 <SecureElementDeriveAndStoreKey>
 8016d5a:	1e03      	subs	r3, r0, #0
 8016d5c:	d001      	beq.n	8016d62 <LoRaMacCryptoDeriveMcKEKey+0x46>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8016d5e:	230f      	movs	r3, #15
 8016d60:	e000      	b.n	8016d64 <LoRaMacCryptoDeriveMcKEKey+0x48>
    }

    return LORAMAC_CRYPTO_SUCCESS;
 8016d62:	2300      	movs	r3, #0
}
 8016d64:	0018      	movs	r0, r3
 8016d66:	46bd      	mov	sp, r7
 8016d68:	b007      	add	sp, #28
 8016d6a:	bd90      	pop	{r4, r7, pc}
 8016d6c:	20001080 	.word	0x20001080

08016d70 <LoRaMacParserJoinAccept>:
*/
#include "LoRaMacParser.h"
#include "utilities.h"

LoRaMacParserStatus_t LoRaMacParserJoinAccept( LoRaMacMessageJoinAccept_t* macMsg )
{
 8016d70:	b590      	push	{r4, r7, lr}
 8016d72:	b085      	sub	sp, #20
 8016d74:	af00      	add	r7, sp, #0
 8016d76:	6078      	str	r0, [r7, #4]
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8016d78:	687b      	ldr	r3, [r7, #4]
 8016d7a:	2b00      	cmp	r3, #0
 8016d7c:	d003      	beq.n	8016d86 <LoRaMacParserJoinAccept+0x16>
 8016d7e:	687b      	ldr	r3, [r7, #4]
 8016d80:	681b      	ldr	r3, [r3, #0]
 8016d82:	2b00      	cmp	r3, #0
 8016d84:	d101      	bne.n	8016d8a <LoRaMacParserJoinAccept+0x1a>
    {
        return LORAMAC_PARSER_ERROR_NPE;
 8016d86:	2302      	movs	r3, #2
 8016d88:	e0de      	b.n	8016f48 <LoRaMacParserJoinAccept+0x1d8>
    }

    uint16_t bufItr = 0;
 8016d8a:	240e      	movs	r4, #14
 8016d8c:	193b      	adds	r3, r7, r4
 8016d8e:	2200      	movs	r2, #0
 8016d90:	801a      	strh	r2, [r3, #0]

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 8016d92:	687b      	ldr	r3, [r7, #4]
 8016d94:	681a      	ldr	r2, [r3, #0]
 8016d96:	193b      	adds	r3, r7, r4
 8016d98:	881b      	ldrh	r3, [r3, #0]
 8016d9a:	1939      	adds	r1, r7, r4
 8016d9c:	1c58      	adds	r0, r3, #1
 8016d9e:	8008      	strh	r0, [r1, #0]
 8016da0:	18d3      	adds	r3, r2, r3
 8016da2:	781a      	ldrb	r2, [r3, #0]
 8016da4:	687b      	ldr	r3, [r7, #4]
 8016da6:	715a      	strb	r2, [r3, #5]

    memcpy1( macMsg->JoinNonce, &macMsg->Buffer[bufItr], 3 );
 8016da8:	687b      	ldr	r3, [r7, #4]
 8016daa:	1d98      	adds	r0, r3, #6
 8016dac:	687b      	ldr	r3, [r7, #4]
 8016dae:	681a      	ldr	r2, [r3, #0]
 8016db0:	193b      	adds	r3, r7, r4
 8016db2:	881b      	ldrh	r3, [r3, #0]
 8016db4:	18d3      	adds	r3, r2, r3
 8016db6:	2203      	movs	r2, #3
 8016db8:	0019      	movs	r1, r3
 8016dba:	f004 fbc5 	bl	801b548 <memcpy1>
    bufItr = bufItr + 3;
 8016dbe:	193b      	adds	r3, r7, r4
 8016dc0:	193a      	adds	r2, r7, r4
 8016dc2:	8812      	ldrh	r2, [r2, #0]
 8016dc4:	3203      	adds	r2, #3
 8016dc6:	801a      	strh	r2, [r3, #0]

    memcpy1( macMsg->NetID, &macMsg->Buffer[bufItr], 3 );
 8016dc8:	687b      	ldr	r3, [r7, #4]
 8016dca:	3309      	adds	r3, #9
 8016dcc:	0018      	movs	r0, r3
 8016dce:	687b      	ldr	r3, [r7, #4]
 8016dd0:	681a      	ldr	r2, [r3, #0]
 8016dd2:	193b      	adds	r3, r7, r4
 8016dd4:	881b      	ldrh	r3, [r3, #0]
 8016dd6:	18d3      	adds	r3, r2, r3
 8016dd8:	2203      	movs	r2, #3
 8016dda:	0019      	movs	r1, r3
 8016ddc:	f004 fbb4 	bl	801b548 <memcpy1>
    bufItr = bufItr + 3;
 8016de0:	193b      	adds	r3, r7, r4
 8016de2:	193a      	adds	r2, r7, r4
 8016de4:	8812      	ldrh	r2, [r2, #0]
 8016de6:	3203      	adds	r2, #3
 8016de8:	801a      	strh	r2, [r3, #0]

    macMsg->DevAddr = ( uint32_t ) macMsg->Buffer[bufItr++];
 8016dea:	687b      	ldr	r3, [r7, #4]
 8016dec:	681a      	ldr	r2, [r3, #0]
 8016dee:	193b      	adds	r3, r7, r4
 8016df0:	881b      	ldrh	r3, [r3, #0]
 8016df2:	1939      	adds	r1, r7, r4
 8016df4:	1c58      	adds	r0, r3, #1
 8016df6:	8008      	strh	r0, [r1, #0]
 8016df8:	18d3      	adds	r3, r2, r3
 8016dfa:	781b      	ldrb	r3, [r3, #0]
 8016dfc:	001a      	movs	r2, r3
 8016dfe:	687b      	ldr	r3, [r7, #4]
 8016e00:	60da      	str	r2, [r3, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8016e02:	687b      	ldr	r3, [r7, #4]
 8016e04:	681a      	ldr	r2, [r3, #0]
 8016e06:	193b      	adds	r3, r7, r4
 8016e08:	881b      	ldrh	r3, [r3, #0]
 8016e0a:	1939      	adds	r1, r7, r4
 8016e0c:	1c58      	adds	r0, r3, #1
 8016e0e:	8008      	strh	r0, [r1, #0]
 8016e10:	18d3      	adds	r3, r2, r3
 8016e12:	781b      	ldrb	r3, [r3, #0]
 8016e14:	021a      	lsls	r2, r3, #8
 8016e16:	687b      	ldr	r3, [r7, #4]
 8016e18:	68db      	ldr	r3, [r3, #12]
 8016e1a:	431a      	orrs	r2, r3
 8016e1c:	687b      	ldr	r3, [r7, #4]
 8016e1e:	60da      	str	r2, [r3, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 8016e20:	687b      	ldr	r3, [r7, #4]
 8016e22:	681a      	ldr	r2, [r3, #0]
 8016e24:	193b      	adds	r3, r7, r4
 8016e26:	881b      	ldrh	r3, [r3, #0]
 8016e28:	1939      	adds	r1, r7, r4
 8016e2a:	1c58      	adds	r0, r3, #1
 8016e2c:	8008      	strh	r0, [r1, #0]
 8016e2e:	18d3      	adds	r3, r2, r3
 8016e30:	781b      	ldrb	r3, [r3, #0]
 8016e32:	041a      	lsls	r2, r3, #16
 8016e34:	687b      	ldr	r3, [r7, #4]
 8016e36:	68db      	ldr	r3, [r3, #12]
 8016e38:	431a      	orrs	r2, r3
 8016e3a:	687b      	ldr	r3, [r7, #4]
 8016e3c:	60da      	str	r2, [r3, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 8016e3e:	687b      	ldr	r3, [r7, #4]
 8016e40:	681a      	ldr	r2, [r3, #0]
 8016e42:	193b      	adds	r3, r7, r4
 8016e44:	881b      	ldrh	r3, [r3, #0]
 8016e46:	1939      	adds	r1, r7, r4
 8016e48:	1c58      	adds	r0, r3, #1
 8016e4a:	8008      	strh	r0, [r1, #0]
 8016e4c:	18d3      	adds	r3, r2, r3
 8016e4e:	781b      	ldrb	r3, [r3, #0]
 8016e50:	061a      	lsls	r2, r3, #24
 8016e52:	687b      	ldr	r3, [r7, #4]
 8016e54:	68db      	ldr	r3, [r3, #12]
 8016e56:	431a      	orrs	r2, r3
 8016e58:	687b      	ldr	r3, [r7, #4]
 8016e5a:	60da      	str	r2, [r3, #12]

    macMsg->DLSettings.Value = macMsg->Buffer[bufItr++];
 8016e5c:	687b      	ldr	r3, [r7, #4]
 8016e5e:	681a      	ldr	r2, [r3, #0]
 8016e60:	193b      	adds	r3, r7, r4
 8016e62:	881b      	ldrh	r3, [r3, #0]
 8016e64:	1939      	adds	r1, r7, r4
 8016e66:	1c58      	adds	r0, r3, #1
 8016e68:	8008      	strh	r0, [r1, #0]
 8016e6a:	18d3      	adds	r3, r2, r3
 8016e6c:	781a      	ldrb	r2, [r3, #0]
 8016e6e:	687b      	ldr	r3, [r7, #4]
 8016e70:	741a      	strb	r2, [r3, #16]

    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 8016e72:	687b      	ldr	r3, [r7, #4]
 8016e74:	681a      	ldr	r2, [r3, #0]
 8016e76:	193b      	adds	r3, r7, r4
 8016e78:	881b      	ldrh	r3, [r3, #0]
 8016e7a:	1939      	adds	r1, r7, r4
 8016e7c:	1c58      	adds	r0, r3, #1
 8016e7e:	8008      	strh	r0, [r1, #0]
 8016e80:	18d3      	adds	r3, r2, r3
 8016e82:	781a      	ldrb	r2, [r3, #0]
 8016e84:	687b      	ldr	r3, [r7, #4]
 8016e86:	745a      	strb	r2, [r3, #17]

    if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) == LORAMAC_C_FLIST_FIELD_SIZE )
 8016e88:	687b      	ldr	r3, [r7, #4]
 8016e8a:	791b      	ldrb	r3, [r3, #4]
 8016e8c:	1f1a      	subs	r2, r3, #4
 8016e8e:	193b      	adds	r3, r7, r4
 8016e90:	881b      	ldrh	r3, [r3, #0]
 8016e92:	1ad3      	subs	r3, r2, r3
 8016e94:	2b10      	cmp	r3, #16
 8016e96:	d111      	bne.n	8016ebc <LoRaMacParserJoinAccept+0x14c>
    {
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_C_FLIST_FIELD_SIZE );
 8016e98:	687b      	ldr	r3, [r7, #4]
 8016e9a:	3312      	adds	r3, #18
 8016e9c:	0018      	movs	r0, r3
 8016e9e:	687b      	ldr	r3, [r7, #4]
 8016ea0:	681a      	ldr	r2, [r3, #0]
 8016ea2:	193b      	adds	r3, r7, r4
 8016ea4:	881b      	ldrh	r3, [r3, #0]
 8016ea6:	18d3      	adds	r3, r2, r3
 8016ea8:	2210      	movs	r2, #16
 8016eaa:	0019      	movs	r1, r3
 8016eac:	f004 fb4c 	bl	801b548 <memcpy1>
        bufItr = bufItr + LORAMAC_C_FLIST_FIELD_SIZE;
 8016eb0:	193b      	adds	r3, r7, r4
 8016eb2:	193a      	adds	r2, r7, r4
 8016eb4:	8812      	ldrh	r2, [r2, #0]
 8016eb6:	3210      	adds	r2, #16
 8016eb8:	801a      	strh	r2, [r3, #0]
 8016eba:	e00a      	b.n	8016ed2 <LoRaMacParserJoinAccept+0x162>
    }
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
 8016ebc:	687b      	ldr	r3, [r7, #4]
 8016ebe:	791b      	ldrb	r3, [r3, #4]
 8016ec0:	1f1a      	subs	r2, r3, #4
 8016ec2:	230e      	movs	r3, #14
 8016ec4:	18fb      	adds	r3, r7, r3
 8016ec6:	881b      	ldrh	r3, [r3, #0]
 8016ec8:	1ad3      	subs	r3, r2, r3
 8016eca:	2b00      	cmp	r3, #0
 8016ecc:	dd01      	ble.n	8016ed2 <LoRaMacParserJoinAccept+0x162>
    {
        return LORAMAC_PARSER_FAIL;
 8016ece:	2301      	movs	r3, #1
 8016ed0:	e03a      	b.n	8016f48 <LoRaMacParserJoinAccept+0x1d8>
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 8016ed2:	687b      	ldr	r3, [r7, #4]
 8016ed4:	681a      	ldr	r2, [r3, #0]
 8016ed6:	240e      	movs	r4, #14
 8016ed8:	193b      	adds	r3, r7, r4
 8016eda:	881b      	ldrh	r3, [r3, #0]
 8016edc:	1939      	adds	r1, r7, r4
 8016ede:	1c58      	adds	r0, r3, #1
 8016ee0:	8008      	strh	r0, [r1, #0]
 8016ee2:	18d3      	adds	r3, r2, r3
 8016ee4:	781b      	ldrb	r3, [r3, #0]
 8016ee6:	001a      	movs	r2, r3
 8016ee8:	687b      	ldr	r3, [r7, #4]
 8016eea:	625a      	str	r2, [r3, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8016eec:	687b      	ldr	r3, [r7, #4]
 8016eee:	681a      	ldr	r2, [r3, #0]
 8016ef0:	193b      	adds	r3, r7, r4
 8016ef2:	881b      	ldrh	r3, [r3, #0]
 8016ef4:	1939      	adds	r1, r7, r4
 8016ef6:	1c58      	adds	r0, r3, #1
 8016ef8:	8008      	strh	r0, [r1, #0]
 8016efa:	18d3      	adds	r3, r2, r3
 8016efc:	781b      	ldrb	r3, [r3, #0]
 8016efe:	021a      	lsls	r2, r3, #8
 8016f00:	687b      	ldr	r3, [r7, #4]
 8016f02:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016f04:	431a      	orrs	r2, r3
 8016f06:	687b      	ldr	r3, [r7, #4]
 8016f08:	625a      	str	r2, [r3, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 8016f0a:	687b      	ldr	r3, [r7, #4]
 8016f0c:	681a      	ldr	r2, [r3, #0]
 8016f0e:	193b      	adds	r3, r7, r4
 8016f10:	881b      	ldrh	r3, [r3, #0]
 8016f12:	1939      	adds	r1, r7, r4
 8016f14:	1c58      	adds	r0, r3, #1
 8016f16:	8008      	strh	r0, [r1, #0]
 8016f18:	18d3      	adds	r3, r2, r3
 8016f1a:	781b      	ldrb	r3, [r3, #0]
 8016f1c:	041a      	lsls	r2, r3, #16
 8016f1e:	687b      	ldr	r3, [r7, #4]
 8016f20:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016f22:	431a      	orrs	r2, r3
 8016f24:	687b      	ldr	r3, [r7, #4]
 8016f26:	625a      	str	r2, [r3, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 8016f28:	687b      	ldr	r3, [r7, #4]
 8016f2a:	681a      	ldr	r2, [r3, #0]
 8016f2c:	193b      	adds	r3, r7, r4
 8016f2e:	881b      	ldrh	r3, [r3, #0]
 8016f30:	1939      	adds	r1, r7, r4
 8016f32:	1c58      	adds	r0, r3, #1
 8016f34:	8008      	strh	r0, [r1, #0]
 8016f36:	18d3      	adds	r3, r2, r3
 8016f38:	781b      	ldrb	r3, [r3, #0]
 8016f3a:	061a      	lsls	r2, r3, #24
 8016f3c:	687b      	ldr	r3, [r7, #4]
 8016f3e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016f40:	431a      	orrs	r2, r3
 8016f42:	687b      	ldr	r3, [r7, #4]
 8016f44:	625a      	str	r2, [r3, #36]	; 0x24

    return LORAMAC_PARSER_SUCCESS;
 8016f46:	2300      	movs	r3, #0
}
 8016f48:	0018      	movs	r0, r3
 8016f4a:	46bd      	mov	sp, r7
 8016f4c:	b005      	add	sp, #20
 8016f4e:	bd90      	pop	{r4, r7, pc}

08016f50 <LoRaMacParserData>:

LoRaMacParserStatus_t LoRaMacParserData( LoRaMacMessageData_t* macMsg )
{
 8016f50:	b590      	push	{r4, r7, lr}
 8016f52:	b085      	sub	sp, #20
 8016f54:	af00      	add	r7, sp, #0
 8016f56:	6078      	str	r0, [r7, #4]
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8016f58:	687b      	ldr	r3, [r7, #4]
 8016f5a:	2b00      	cmp	r3, #0
 8016f5c:	d003      	beq.n	8016f66 <LoRaMacParserData+0x16>
 8016f5e:	687b      	ldr	r3, [r7, #4]
 8016f60:	681b      	ldr	r3, [r3, #0]
 8016f62:	2b00      	cmp	r3, #0
 8016f64:	d101      	bne.n	8016f6a <LoRaMacParserData+0x1a>
    {
        return LORAMAC_PARSER_ERROR_NPE;
 8016f66:	2302      	movs	r3, #2
 8016f68:	e0fe      	b.n	8017168 <LoRaMacParserData+0x218>
    }

    uint16_t bufItr = 0;
 8016f6a:	240e      	movs	r4, #14
 8016f6c:	193b      	adds	r3, r7, r4
 8016f6e:	2200      	movs	r2, #0
 8016f70:	801a      	strh	r2, [r3, #0]

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 8016f72:	687b      	ldr	r3, [r7, #4]
 8016f74:	681a      	ldr	r2, [r3, #0]
 8016f76:	193b      	adds	r3, r7, r4
 8016f78:	881b      	ldrh	r3, [r3, #0]
 8016f7a:	1939      	adds	r1, r7, r4
 8016f7c:	1c58      	adds	r0, r3, #1
 8016f7e:	8008      	strh	r0, [r1, #0]
 8016f80:	18d3      	adds	r3, r2, r3
 8016f82:	781a      	ldrb	r2, [r3, #0]
 8016f84:	687b      	ldr	r3, [r7, #4]
 8016f86:	715a      	strb	r2, [r3, #5]

    macMsg->FHDR.DevAddr = macMsg->Buffer[bufItr++];
 8016f88:	687b      	ldr	r3, [r7, #4]
 8016f8a:	681a      	ldr	r2, [r3, #0]
 8016f8c:	193b      	adds	r3, r7, r4
 8016f8e:	881b      	ldrh	r3, [r3, #0]
 8016f90:	1939      	adds	r1, r7, r4
 8016f92:	1c58      	adds	r0, r3, #1
 8016f94:	8008      	strh	r0, [r1, #0]
 8016f96:	18d3      	adds	r3, r2, r3
 8016f98:	781b      	ldrb	r3, [r3, #0]
 8016f9a:	001a      	movs	r2, r3
 8016f9c:	687b      	ldr	r3, [r7, #4]
 8016f9e:	609a      	str	r2, [r3, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 8016fa0:	687b      	ldr	r3, [r7, #4]
 8016fa2:	681a      	ldr	r2, [r3, #0]
 8016fa4:	193b      	adds	r3, r7, r4
 8016fa6:	881b      	ldrh	r3, [r3, #0]
 8016fa8:	1939      	adds	r1, r7, r4
 8016faa:	1c58      	adds	r0, r3, #1
 8016fac:	8008      	strh	r0, [r1, #0]
 8016fae:	18d3      	adds	r3, r2, r3
 8016fb0:	781b      	ldrb	r3, [r3, #0]
 8016fb2:	021a      	lsls	r2, r3, #8
 8016fb4:	687b      	ldr	r3, [r7, #4]
 8016fb6:	689b      	ldr	r3, [r3, #8]
 8016fb8:	431a      	orrs	r2, r3
 8016fba:	687b      	ldr	r3, [r7, #4]
 8016fbc:	609a      	str	r2, [r3, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 8016fbe:	687b      	ldr	r3, [r7, #4]
 8016fc0:	681a      	ldr	r2, [r3, #0]
 8016fc2:	193b      	adds	r3, r7, r4
 8016fc4:	881b      	ldrh	r3, [r3, #0]
 8016fc6:	1939      	adds	r1, r7, r4
 8016fc8:	1c58      	adds	r0, r3, #1
 8016fca:	8008      	strh	r0, [r1, #0]
 8016fcc:	18d3      	adds	r3, r2, r3
 8016fce:	781b      	ldrb	r3, [r3, #0]
 8016fd0:	041a      	lsls	r2, r3, #16
 8016fd2:	687b      	ldr	r3, [r7, #4]
 8016fd4:	689b      	ldr	r3, [r3, #8]
 8016fd6:	431a      	orrs	r2, r3
 8016fd8:	687b      	ldr	r3, [r7, #4]
 8016fda:	609a      	str	r2, [r3, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 8016fdc:	687b      	ldr	r3, [r7, #4]
 8016fde:	681a      	ldr	r2, [r3, #0]
 8016fe0:	193b      	adds	r3, r7, r4
 8016fe2:	881b      	ldrh	r3, [r3, #0]
 8016fe4:	1939      	adds	r1, r7, r4
 8016fe6:	1c58      	adds	r0, r3, #1
 8016fe8:	8008      	strh	r0, [r1, #0]
 8016fea:	18d3      	adds	r3, r2, r3
 8016fec:	781b      	ldrb	r3, [r3, #0]
 8016fee:	061a      	lsls	r2, r3, #24
 8016ff0:	687b      	ldr	r3, [r7, #4]
 8016ff2:	689b      	ldr	r3, [r3, #8]
 8016ff4:	431a      	orrs	r2, r3
 8016ff6:	687b      	ldr	r3, [r7, #4]
 8016ff8:	609a      	str	r2, [r3, #8]

    macMsg->FHDR.FCtrl.Value = macMsg->Buffer[bufItr++];
 8016ffa:	687b      	ldr	r3, [r7, #4]
 8016ffc:	681a      	ldr	r2, [r3, #0]
 8016ffe:	193b      	adds	r3, r7, r4
 8017000:	881b      	ldrh	r3, [r3, #0]
 8017002:	1939      	adds	r1, r7, r4
 8017004:	1c58      	adds	r0, r3, #1
 8017006:	8008      	strh	r0, [r1, #0]
 8017008:	18d3      	adds	r3, r2, r3
 801700a:	781a      	ldrb	r2, [r3, #0]
 801700c:	687b      	ldr	r3, [r7, #4]
 801700e:	731a      	strb	r2, [r3, #12]

    macMsg->FHDR.FCnt = macMsg->Buffer[bufItr++];
 8017010:	687b      	ldr	r3, [r7, #4]
 8017012:	681a      	ldr	r2, [r3, #0]
 8017014:	193b      	adds	r3, r7, r4
 8017016:	881b      	ldrh	r3, [r3, #0]
 8017018:	1939      	adds	r1, r7, r4
 801701a:	1c58      	adds	r0, r3, #1
 801701c:	8008      	strh	r0, [r1, #0]
 801701e:	18d3      	adds	r3, r2, r3
 8017020:	781b      	ldrb	r3, [r3, #0]
 8017022:	b29a      	uxth	r2, r3
 8017024:	687b      	ldr	r3, [r7, #4]
 8017026:	81da      	strh	r2, [r3, #14]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 8017028:	687b      	ldr	r3, [r7, #4]
 801702a:	681a      	ldr	r2, [r3, #0]
 801702c:	193b      	adds	r3, r7, r4
 801702e:	881b      	ldrh	r3, [r3, #0]
 8017030:	1939      	adds	r1, r7, r4
 8017032:	1c58      	adds	r0, r3, #1
 8017034:	8008      	strh	r0, [r1, #0]
 8017036:	18d3      	adds	r3, r2, r3
 8017038:	781b      	ldrb	r3, [r3, #0]
 801703a:	0219      	lsls	r1, r3, #8
 801703c:	687b      	ldr	r3, [r7, #4]
 801703e:	89db      	ldrh	r3, [r3, #14]
 8017040:	b21a      	sxth	r2, r3
 8017042:	b20b      	sxth	r3, r1
 8017044:	4313      	orrs	r3, r2
 8017046:	b21b      	sxth	r3, r3
 8017048:	b29a      	uxth	r2, r3
 801704a:	687b      	ldr	r3, [r7, #4]
 801704c:	81da      	strh	r2, [r3, #14]

    if( macMsg->FHDR.FCtrl.Bits.FOptsLen <= 15 )
    {
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 801704e:	687b      	ldr	r3, [r7, #4]
 8017050:	3310      	adds	r3, #16
 8017052:	0018      	movs	r0, r3
 8017054:	687b      	ldr	r3, [r7, #4]
 8017056:	681a      	ldr	r2, [r3, #0]
 8017058:	193b      	adds	r3, r7, r4
 801705a:	881b      	ldrh	r3, [r3, #0]
 801705c:	18d1      	adds	r1, r2, r3
 801705e:	687b      	ldr	r3, [r7, #4]
 8017060:	7b1b      	ldrb	r3, [r3, #12]
 8017062:	071b      	lsls	r3, r3, #28
 8017064:	0f1b      	lsrs	r3, r3, #28
 8017066:	b2db      	uxtb	r3, r3
 8017068:	b29b      	uxth	r3, r3
 801706a:	001a      	movs	r2, r3
 801706c:	f004 fa6c 	bl	801b548 <memcpy1>
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8017070:	687b      	ldr	r3, [r7, #4]
 8017072:	7b1b      	ldrb	r3, [r3, #12]
 8017074:	071b      	lsls	r3, r3, #28
 8017076:	0f1b      	lsrs	r3, r3, #28
 8017078:	b2db      	uxtb	r3, r3
 801707a:	b299      	uxth	r1, r3
 801707c:	193b      	adds	r3, r7, r4
 801707e:	193a      	adds	r2, r7, r4
 8017080:	8812      	ldrh	r2, [r2, #0]
 8017082:	188a      	adds	r2, r1, r2
 8017084:	801a      	strh	r2, [r3, #0]
    {
        return LORAMAC_PARSER_FAIL;
    }

    // Initialize anyway with zero.
    macMsg->FPort = 0;
 8017086:	687b      	ldr	r3, [r7, #4]
 8017088:	2220      	movs	r2, #32
 801708a:	2100      	movs	r1, #0
 801708c:	5499      	strb	r1, [r3, r2]
    macMsg->FRMPayloadSize = 0;
 801708e:	687b      	ldr	r3, [r7, #4]
 8017090:	2228      	movs	r2, #40	; 0x28
 8017092:	2100      	movs	r1, #0
 8017094:	5499      	strb	r1, [r3, r2]

    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 8017096:	687b      	ldr	r3, [r7, #4]
 8017098:	791b      	ldrb	r3, [r3, #4]
 801709a:	001a      	movs	r2, r3
 801709c:	193b      	adds	r3, r7, r4
 801709e:	881b      	ldrh	r3, [r3, #0]
 80170a0:	1ad3      	subs	r3, r2, r3
 80170a2:	2b04      	cmp	r3, #4
 80170a4:	dd2e      	ble.n	8017104 <LoRaMacParserData+0x1b4>
    {
        macMsg->FPort = macMsg->Buffer[bufItr++];
 80170a6:	687b      	ldr	r3, [r7, #4]
 80170a8:	681a      	ldr	r2, [r3, #0]
 80170aa:	193b      	adds	r3, r7, r4
 80170ac:	881b      	ldrh	r3, [r3, #0]
 80170ae:	1939      	adds	r1, r7, r4
 80170b0:	1c58      	adds	r0, r3, #1
 80170b2:	8008      	strh	r0, [r1, #0]
 80170b4:	18d3      	adds	r3, r2, r3
 80170b6:	7819      	ldrb	r1, [r3, #0]
 80170b8:	687b      	ldr	r3, [r7, #4]
 80170ba:	2220      	movs	r2, #32
 80170bc:	5499      	strb	r1, [r3, r2]

        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 80170be:	687b      	ldr	r3, [r7, #4]
 80170c0:	791a      	ldrb	r2, [r3, #4]
 80170c2:	193b      	adds	r3, r7, r4
 80170c4:	881b      	ldrh	r3, [r3, #0]
 80170c6:	b2db      	uxtb	r3, r3
 80170c8:	1ad3      	subs	r3, r2, r3
 80170ca:	b2db      	uxtb	r3, r3
 80170cc:	3b04      	subs	r3, #4
 80170ce:	b2d9      	uxtb	r1, r3
 80170d0:	687b      	ldr	r3, [r7, #4]
 80170d2:	2228      	movs	r2, #40	; 0x28
 80170d4:	5499      	strb	r1, [r3, r2]
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 80170d6:	687b      	ldr	r3, [r7, #4]
 80170d8:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80170da:	687b      	ldr	r3, [r7, #4]
 80170dc:	681a      	ldr	r2, [r3, #0]
 80170de:	193b      	adds	r3, r7, r4
 80170e0:	881b      	ldrh	r3, [r3, #0]
 80170e2:	18d1      	adds	r1, r2, r3
 80170e4:	687b      	ldr	r3, [r7, #4]
 80170e6:	2228      	movs	r2, #40	; 0x28
 80170e8:	5c9b      	ldrb	r3, [r3, r2]
 80170ea:	b29b      	uxth	r3, r3
 80170ec:	001a      	movs	r2, r3
 80170ee:	f004 fa2b 	bl	801b548 <memcpy1>
        bufItr = bufItr + macMsg->FRMPayloadSize;
 80170f2:	687b      	ldr	r3, [r7, #4]
 80170f4:	2228      	movs	r2, #40	; 0x28
 80170f6:	5c9b      	ldrb	r3, [r3, r2]
 80170f8:	b299      	uxth	r1, r3
 80170fa:	193b      	adds	r3, r7, r4
 80170fc:	193a      	adds	r2, r7, r4
 80170fe:	8812      	ldrh	r2, [r2, #0]
 8017100:	188a      	adds	r2, r1, r2
 8017102:	801a      	strh	r2, [r3, #0]
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 8017104:	687b      	ldr	r3, [r7, #4]
 8017106:	681a      	ldr	r2, [r3, #0]
 8017108:	687b      	ldr	r3, [r7, #4]
 801710a:	791b      	ldrb	r3, [r3, #4]
 801710c:	3b04      	subs	r3, #4
 801710e:	18d3      	adds	r3, r2, r3
 8017110:	781b      	ldrb	r3, [r3, #0]
 8017112:	001a      	movs	r2, r3
 8017114:	687b      	ldr	r3, [r7, #4]
 8017116:	62da      	str	r2, [r3, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
 8017118:	687b      	ldr	r3, [r7, #4]
 801711a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801711c:	687b      	ldr	r3, [r7, #4]
 801711e:	6819      	ldr	r1, [r3, #0]
 8017120:	687b      	ldr	r3, [r7, #4]
 8017122:	791b      	ldrb	r3, [r3, #4]
 8017124:	3b03      	subs	r3, #3
 8017126:	18cb      	adds	r3, r1, r3
 8017128:	781b      	ldrb	r3, [r3, #0]
 801712a:	021b      	lsls	r3, r3, #8
 801712c:	431a      	orrs	r2, r3
 801712e:	687b      	ldr	r3, [r7, #4]
 8017130:	62da      	str	r2, [r3, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
 8017132:	687b      	ldr	r3, [r7, #4]
 8017134:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8017136:	687b      	ldr	r3, [r7, #4]
 8017138:	6819      	ldr	r1, [r3, #0]
 801713a:	687b      	ldr	r3, [r7, #4]
 801713c:	791b      	ldrb	r3, [r3, #4]
 801713e:	3b02      	subs	r3, #2
 8017140:	18cb      	adds	r3, r1, r3
 8017142:	781b      	ldrb	r3, [r3, #0]
 8017144:	041b      	lsls	r3, r3, #16
 8017146:	431a      	orrs	r2, r3
 8017148:	687b      	ldr	r3, [r7, #4]
 801714a:	62da      	str	r2, [r3, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );
 801714c:	687b      	ldr	r3, [r7, #4]
 801714e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8017150:	687b      	ldr	r3, [r7, #4]
 8017152:	6819      	ldr	r1, [r3, #0]
 8017154:	687b      	ldr	r3, [r7, #4]
 8017156:	791b      	ldrb	r3, [r3, #4]
 8017158:	3b01      	subs	r3, #1
 801715a:	18cb      	adds	r3, r1, r3
 801715c:	781b      	ldrb	r3, [r3, #0]
 801715e:	061b      	lsls	r3, r3, #24
 8017160:	431a      	orrs	r2, r3
 8017162:	687b      	ldr	r3, [r7, #4]
 8017164:	62da      	str	r2, [r3, #44]	; 0x2c

    return LORAMAC_PARSER_SUCCESS;
 8017166:	2300      	movs	r3, #0
}
 8017168:	0018      	movs	r0, r3
 801716a:	46bd      	mov	sp, r7
 801716c:	b005      	add	sp, #20
 801716e:	bd90      	pop	{r4, r7, pc}

08017170 <LoRaMacSerializerJoinRequest>:
*/
#include "LoRaMacSerializer.h"
#include "utilities.h"

LoRaMacSerializerStatus_t LoRaMacSerializerJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
 8017170:	b5b0      	push	{r4, r5, r7, lr}
 8017172:	b084      	sub	sp, #16
 8017174:	af00      	add	r7, sp, #0
 8017176:	6078      	str	r0, [r7, #4]
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 8017178:	687b      	ldr	r3, [r7, #4]
 801717a:	2b00      	cmp	r3, #0
 801717c:	d003      	beq.n	8017186 <LoRaMacSerializerJoinRequest+0x16>
 801717e:	687b      	ldr	r3, [r7, #4]
 8017180:	681b      	ldr	r3, [r3, #0]
 8017182:	2b00      	cmp	r3, #0
 8017184:	d101      	bne.n	801718a <LoRaMacSerializerJoinRequest+0x1a>
    {
        return LORAMAC_SERIALIZER_ERROR_NPE;
 8017186:	2301      	movs	r3, #1
 8017188:	e089      	b.n	801729e <LoRaMacSerializerJoinRequest+0x12e>
    }

    uint16_t bufItr = 0;
 801718a:	230e      	movs	r3, #14
 801718c:	18fb      	adds	r3, r7, r3
 801718e:	2200      	movs	r2, #0
 8017190:	801a      	strh	r2, [r3, #0]

    // Check macMsg->BufSize
    if( macMsg->BufSize < LORAMAC_JOIN_REQ_MSG_SIZE )
 8017192:	687b      	ldr	r3, [r7, #4]
 8017194:	791b      	ldrb	r3, [r3, #4]
 8017196:	2b16      	cmp	r3, #22
 8017198:	d801      	bhi.n	801719e <LoRaMacSerializerJoinRequest+0x2e>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 801719a:	2302      	movs	r3, #2
 801719c:	e07f      	b.n	801729e <LoRaMacSerializerJoinRequest+0x12e>
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 801719e:	687b      	ldr	r3, [r7, #4]
 80171a0:	681a      	ldr	r2, [r3, #0]
 80171a2:	240e      	movs	r4, #14
 80171a4:	193b      	adds	r3, r7, r4
 80171a6:	881b      	ldrh	r3, [r3, #0]
 80171a8:	1939      	adds	r1, r7, r4
 80171aa:	1c58      	adds	r0, r3, #1
 80171ac:	8008      	strh	r0, [r1, #0]
 80171ae:	18d3      	adds	r3, r2, r3
 80171b0:	687a      	ldr	r2, [r7, #4]
 80171b2:	7952      	ldrb	r2, [r2, #5]
 80171b4:	701a      	strb	r2, [r3, #0]

    memcpyr( &macMsg->Buffer[bufItr], macMsg->JoinEUI, LORAMAC_JOIN_EUI_FIELD_SIZE );
 80171b6:	687b      	ldr	r3, [r7, #4]
 80171b8:	681a      	ldr	r2, [r3, #0]
 80171ba:	193b      	adds	r3, r7, r4
 80171bc:	881b      	ldrh	r3, [r3, #0]
 80171be:	18d0      	adds	r0, r2, r3
 80171c0:	687b      	ldr	r3, [r7, #4]
 80171c2:	3306      	adds	r3, #6
 80171c4:	2208      	movs	r2, #8
 80171c6:	0019      	movs	r1, r3
 80171c8:	f004 f9da 	bl	801b580 <memcpyr>
    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;
 80171cc:	193b      	adds	r3, r7, r4
 80171ce:	193a      	adds	r2, r7, r4
 80171d0:	8812      	ldrh	r2, [r2, #0]
 80171d2:	3208      	adds	r2, #8
 80171d4:	801a      	strh	r2, [r3, #0]

    memcpyr( &macMsg->Buffer[bufItr], macMsg->DevEUI, LORAMAC_DEV_EUI_FIELD_SIZE );
 80171d6:	687b      	ldr	r3, [r7, #4]
 80171d8:	681a      	ldr	r2, [r3, #0]
 80171da:	193b      	adds	r3, r7, r4
 80171dc:	881b      	ldrh	r3, [r3, #0]
 80171de:	18d0      	adds	r0, r2, r3
 80171e0:	687b      	ldr	r3, [r7, #4]
 80171e2:	330e      	adds	r3, #14
 80171e4:	2208      	movs	r2, #8
 80171e6:	0019      	movs	r1, r3
 80171e8:	f004 f9ca 	bl	801b580 <memcpyr>
    bufItr += LORAMAC_DEV_EUI_FIELD_SIZE;
 80171ec:	193b      	adds	r3, r7, r4
 80171ee:	0025      	movs	r5, r4
 80171f0:	193a      	adds	r2, r7, r4
 80171f2:	8812      	ldrh	r2, [r2, #0]
 80171f4:	3208      	adds	r2, #8
 80171f6:	801a      	strh	r2, [r3, #0]

    macMsg->Buffer[bufItr++] = macMsg->DevNonce & 0xFF;
 80171f8:	687b      	ldr	r3, [r7, #4]
 80171fa:	8ad8      	ldrh	r0, [r3, #22]
 80171fc:	687b      	ldr	r3, [r7, #4]
 80171fe:	681a      	ldr	r2, [r3, #0]
 8017200:	197b      	adds	r3, r7, r5
 8017202:	881b      	ldrh	r3, [r3, #0]
 8017204:	1979      	adds	r1, r7, r5
 8017206:	1c5c      	adds	r4, r3, #1
 8017208:	800c      	strh	r4, [r1, #0]
 801720a:	18d3      	adds	r3, r2, r3
 801720c:	b2c2      	uxtb	r2, r0
 801720e:	701a      	strb	r2, [r3, #0]
    macMsg->Buffer[bufItr++] = ( macMsg->DevNonce >> 8 ) & 0xFF;
 8017210:	687b      	ldr	r3, [r7, #4]
 8017212:	8adb      	ldrh	r3, [r3, #22]
 8017214:	0a1b      	lsrs	r3, r3, #8
 8017216:	b298      	uxth	r0, r3
 8017218:	687b      	ldr	r3, [r7, #4]
 801721a:	681a      	ldr	r2, [r3, #0]
 801721c:	197b      	adds	r3, r7, r5
 801721e:	881b      	ldrh	r3, [r3, #0]
 8017220:	1979      	adds	r1, r7, r5
 8017222:	1c5c      	adds	r4, r3, #1
 8017224:	800c      	strh	r4, [r1, #0]
 8017226:	18d3      	adds	r3, r2, r3
 8017228:	b2c2      	uxtb	r2, r0
 801722a:	701a      	strb	r2, [r3, #0]

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 801722c:	687b      	ldr	r3, [r7, #4]
 801722e:	6998      	ldr	r0, [r3, #24]
 8017230:	687b      	ldr	r3, [r7, #4]
 8017232:	681a      	ldr	r2, [r3, #0]
 8017234:	197b      	adds	r3, r7, r5
 8017236:	881b      	ldrh	r3, [r3, #0]
 8017238:	1979      	adds	r1, r7, r5
 801723a:	1c5c      	adds	r4, r3, #1
 801723c:	800c      	strh	r4, [r1, #0]
 801723e:	18d3      	adds	r3, r2, r3
 8017240:	b2c2      	uxtb	r2, r0
 8017242:	701a      	strb	r2, [r3, #0]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 8017244:	687b      	ldr	r3, [r7, #4]
 8017246:	699b      	ldr	r3, [r3, #24]
 8017248:	0a18      	lsrs	r0, r3, #8
 801724a:	687b      	ldr	r3, [r7, #4]
 801724c:	681a      	ldr	r2, [r3, #0]
 801724e:	197b      	adds	r3, r7, r5
 8017250:	881b      	ldrh	r3, [r3, #0]
 8017252:	1979      	adds	r1, r7, r5
 8017254:	1c5c      	adds	r4, r3, #1
 8017256:	800c      	strh	r4, [r1, #0]
 8017258:	18d3      	adds	r3, r2, r3
 801725a:	b2c2      	uxtb	r2, r0
 801725c:	701a      	strb	r2, [r3, #0]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 801725e:	687b      	ldr	r3, [r7, #4]
 8017260:	699b      	ldr	r3, [r3, #24]
 8017262:	0c18      	lsrs	r0, r3, #16
 8017264:	687b      	ldr	r3, [r7, #4]
 8017266:	681a      	ldr	r2, [r3, #0]
 8017268:	197b      	adds	r3, r7, r5
 801726a:	881b      	ldrh	r3, [r3, #0]
 801726c:	1979      	adds	r1, r7, r5
 801726e:	1c5c      	adds	r4, r3, #1
 8017270:	800c      	strh	r4, [r1, #0]
 8017272:	18d3      	adds	r3, r2, r3
 8017274:	b2c2      	uxtb	r2, r0
 8017276:	701a      	strb	r2, [r3, #0]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 8017278:	687b      	ldr	r3, [r7, #4]
 801727a:	699b      	ldr	r3, [r3, #24]
 801727c:	0e18      	lsrs	r0, r3, #24
 801727e:	687b      	ldr	r3, [r7, #4]
 8017280:	681a      	ldr	r2, [r3, #0]
 8017282:	197b      	adds	r3, r7, r5
 8017284:	881b      	ldrh	r3, [r3, #0]
 8017286:	1979      	adds	r1, r7, r5
 8017288:	1c5c      	adds	r4, r3, #1
 801728a:	800c      	strh	r4, [r1, #0]
 801728c:	18d3      	adds	r3, r2, r3
 801728e:	b2c2      	uxtb	r2, r0
 8017290:	701a      	strb	r2, [r3, #0]

    macMsg->BufSize = bufItr;
 8017292:	197b      	adds	r3, r7, r5
 8017294:	881b      	ldrh	r3, [r3, #0]
 8017296:	b2da      	uxtb	r2, r3
 8017298:	687b      	ldr	r3, [r7, #4]
 801729a:	711a      	strb	r2, [r3, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 801729c:	2300      	movs	r3, #0
}
 801729e:	0018      	movs	r0, r3
 80172a0:	46bd      	mov	sp, r7
 80172a2:	b004      	add	sp, #16
 80172a4:	bdb0      	pop	{r4, r5, r7, pc}

080172a6 <LoRaMacSerializerData>:

    return LORAMAC_SERIALIZER_SUCCESS;
}

LoRaMacSerializerStatus_t LoRaMacSerializerData( LoRaMacMessageData_t* macMsg )
{
 80172a6:	b5b0      	push	{r4, r5, r7, lr}
 80172a8:	b084      	sub	sp, #16
 80172aa:	af00      	add	r7, sp, #0
 80172ac:	6078      	str	r0, [r7, #4]
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 80172ae:	687b      	ldr	r3, [r7, #4]
 80172b0:	2b00      	cmp	r3, #0
 80172b2:	d003      	beq.n	80172bc <LoRaMacSerializerData+0x16>
 80172b4:	687b      	ldr	r3, [r7, #4]
 80172b6:	681b      	ldr	r3, [r3, #0]
 80172b8:	2b00      	cmp	r3, #0
 80172ba:	d101      	bne.n	80172c0 <LoRaMacSerializerData+0x1a>
    {
        return LORAMAC_SERIALIZER_ERROR_NPE;
 80172bc:	2301      	movs	r3, #1
 80172be:	e119      	b.n	80174f4 <LoRaMacSerializerData+0x24e>
    }

    uint16_t bufItr = 0;
 80172c0:	230e      	movs	r3, #14
 80172c2:	18fb      	adds	r3, r7, r3
 80172c4:	2200      	movs	r2, #0
 80172c6:	801a      	strh	r2, [r3, #0]

    // Check macMsg->BufSize
    uint16_t computedBufSize =   LORAMAC_MHDR_FIELD_SIZE
 80172c8:	200c      	movs	r0, #12
 80172ca:	183b      	adds	r3, r7, r0
 80172cc:	2208      	movs	r2, #8
 80172ce:	801a      	strh	r2, [r3, #0]
                               + LORAMAC_FHDR_DEV_ADD_FIELD_SIZE
                               + LORAMAC_FHDR_F_CTRL_FIELD_SIZE
                               + LORAMAC_FHDR_F_CNT_FIELD_SIZE;

    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 80172d0:	687b      	ldr	r3, [r7, #4]
 80172d2:	7b1b      	ldrb	r3, [r3, #12]
 80172d4:	071b      	lsls	r3, r3, #28
 80172d6:	0f1b      	lsrs	r3, r3, #28
 80172d8:	b2db      	uxtb	r3, r3
 80172da:	b299      	uxth	r1, r3
 80172dc:	183b      	adds	r3, r7, r0
 80172de:	183a      	adds	r2, r7, r0
 80172e0:	8812      	ldrh	r2, [r2, #0]
 80172e2:	188a      	adds	r2, r1, r2
 80172e4:	801a      	strh	r2, [r3, #0]

    if( macMsg->FRMPayloadSize > 0 )
 80172e6:	687b      	ldr	r3, [r7, #4]
 80172e8:	2228      	movs	r2, #40	; 0x28
 80172ea:	5c9b      	ldrb	r3, [r3, r2]
 80172ec:	2b00      	cmp	r3, #0
 80172ee:	d004      	beq.n	80172fa <LoRaMacSerializerData+0x54>
    {
        computedBufSize += LORAMAC_F_PORT_FIELD_SIZE;
 80172f0:	183b      	adds	r3, r7, r0
 80172f2:	183a      	adds	r2, r7, r0
 80172f4:	8812      	ldrh	r2, [r2, #0]
 80172f6:	3201      	adds	r2, #1
 80172f8:	801a      	strh	r2, [r3, #0]
    }

    computedBufSize += macMsg->FRMPayloadSize;
 80172fa:	687b      	ldr	r3, [r7, #4]
 80172fc:	2228      	movs	r2, #40	; 0x28
 80172fe:	5c9b      	ldrb	r3, [r3, r2]
 8017300:	b299      	uxth	r1, r3
 8017302:	200c      	movs	r0, #12
 8017304:	183b      	adds	r3, r7, r0
 8017306:	183a      	adds	r2, r7, r0
 8017308:	8812      	ldrh	r2, [r2, #0]
 801730a:	188a      	adds	r2, r1, r2
 801730c:	801a      	strh	r2, [r3, #0]
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;
 801730e:	0001      	movs	r1, r0
 8017310:	187b      	adds	r3, r7, r1
 8017312:	187a      	adds	r2, r7, r1
 8017314:	8812      	ldrh	r2, [r2, #0]
 8017316:	3204      	adds	r2, #4
 8017318:	801a      	strh	r2, [r3, #0]

    if( macMsg->BufSize < computedBufSize )
 801731a:	687b      	ldr	r3, [r7, #4]
 801731c:	791b      	ldrb	r3, [r3, #4]
 801731e:	b29b      	uxth	r3, r3
 8017320:	187a      	adds	r2, r7, r1
 8017322:	8812      	ldrh	r2, [r2, #0]
 8017324:	429a      	cmp	r2, r3
 8017326:	d901      	bls.n	801732c <LoRaMacSerializerData+0x86>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 8017328:	2302      	movs	r3, #2
 801732a:	e0e3      	b.n	80174f4 <LoRaMacSerializerData+0x24e>
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 801732c:	687b      	ldr	r3, [r7, #4]
 801732e:	681a      	ldr	r2, [r3, #0]
 8017330:	250e      	movs	r5, #14
 8017332:	197b      	adds	r3, r7, r5
 8017334:	881b      	ldrh	r3, [r3, #0]
 8017336:	1979      	adds	r1, r7, r5
 8017338:	1c58      	adds	r0, r3, #1
 801733a:	8008      	strh	r0, [r1, #0]
 801733c:	18d3      	adds	r3, r2, r3
 801733e:	687a      	ldr	r2, [r7, #4]
 8017340:	7952      	ldrb	r2, [r2, #5]
 8017342:	701a      	strb	r2, [r3, #0]

    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr ) & 0xFF;
 8017344:	687b      	ldr	r3, [r7, #4]
 8017346:	6898      	ldr	r0, [r3, #8]
 8017348:	687b      	ldr	r3, [r7, #4]
 801734a:	681a      	ldr	r2, [r3, #0]
 801734c:	197b      	adds	r3, r7, r5
 801734e:	881b      	ldrh	r3, [r3, #0]
 8017350:	1979      	adds	r1, r7, r5
 8017352:	1c5c      	adds	r4, r3, #1
 8017354:	800c      	strh	r4, [r1, #0]
 8017356:	18d3      	adds	r3, r2, r3
 8017358:	b2c2      	uxtb	r2, r0
 801735a:	701a      	strb	r2, [r3, #0]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 8 ) & 0xFF;
 801735c:	687b      	ldr	r3, [r7, #4]
 801735e:	689b      	ldr	r3, [r3, #8]
 8017360:	0a18      	lsrs	r0, r3, #8
 8017362:	687b      	ldr	r3, [r7, #4]
 8017364:	681a      	ldr	r2, [r3, #0]
 8017366:	197b      	adds	r3, r7, r5
 8017368:	881b      	ldrh	r3, [r3, #0]
 801736a:	1979      	adds	r1, r7, r5
 801736c:	1c5c      	adds	r4, r3, #1
 801736e:	800c      	strh	r4, [r1, #0]
 8017370:	18d3      	adds	r3, r2, r3
 8017372:	b2c2      	uxtb	r2, r0
 8017374:	701a      	strb	r2, [r3, #0]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 16 ) & 0xFF;
 8017376:	687b      	ldr	r3, [r7, #4]
 8017378:	689b      	ldr	r3, [r3, #8]
 801737a:	0c18      	lsrs	r0, r3, #16
 801737c:	687b      	ldr	r3, [r7, #4]
 801737e:	681a      	ldr	r2, [r3, #0]
 8017380:	197b      	adds	r3, r7, r5
 8017382:	881b      	ldrh	r3, [r3, #0]
 8017384:	1979      	adds	r1, r7, r5
 8017386:	1c5c      	adds	r4, r3, #1
 8017388:	800c      	strh	r4, [r1, #0]
 801738a:	18d3      	adds	r3, r2, r3
 801738c:	b2c2      	uxtb	r2, r0
 801738e:	701a      	strb	r2, [r3, #0]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 24 ) & 0xFF;
 8017390:	687b      	ldr	r3, [r7, #4]
 8017392:	689b      	ldr	r3, [r3, #8]
 8017394:	0e18      	lsrs	r0, r3, #24
 8017396:	687b      	ldr	r3, [r7, #4]
 8017398:	681a      	ldr	r2, [r3, #0]
 801739a:	197b      	adds	r3, r7, r5
 801739c:	881b      	ldrh	r3, [r3, #0]
 801739e:	1979      	adds	r1, r7, r5
 80173a0:	1c5c      	adds	r4, r3, #1
 80173a2:	800c      	strh	r4, [r1, #0]
 80173a4:	18d3      	adds	r3, r2, r3
 80173a6:	b2c2      	uxtb	r2, r0
 80173a8:	701a      	strb	r2, [r3, #0]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCtrl.Value;
 80173aa:	687b      	ldr	r3, [r7, #4]
 80173ac:	681a      	ldr	r2, [r3, #0]
 80173ae:	197b      	adds	r3, r7, r5
 80173b0:	881b      	ldrh	r3, [r3, #0]
 80173b2:	1979      	adds	r1, r7, r5
 80173b4:	1c58      	adds	r0, r3, #1
 80173b6:	8008      	strh	r0, [r1, #0]
 80173b8:	18d3      	adds	r3, r2, r3
 80173ba:	687a      	ldr	r2, [r7, #4]
 80173bc:	7b12      	ldrb	r2, [r2, #12]
 80173be:	701a      	strb	r2, [r3, #0]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCnt & 0xFF;
 80173c0:	687b      	ldr	r3, [r7, #4]
 80173c2:	89d8      	ldrh	r0, [r3, #14]
 80173c4:	687b      	ldr	r3, [r7, #4]
 80173c6:	681a      	ldr	r2, [r3, #0]
 80173c8:	197b      	adds	r3, r7, r5
 80173ca:	881b      	ldrh	r3, [r3, #0]
 80173cc:	1979      	adds	r1, r7, r5
 80173ce:	1c5c      	adds	r4, r3, #1
 80173d0:	800c      	strh	r4, [r1, #0]
 80173d2:	18d3      	adds	r3, r2, r3
 80173d4:	b2c2      	uxtb	r2, r0
 80173d6:	701a      	strb	r2, [r3, #0]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 80173d8:	687b      	ldr	r3, [r7, #4]
 80173da:	89db      	ldrh	r3, [r3, #14]
 80173dc:	0a1b      	lsrs	r3, r3, #8
 80173de:	b298      	uxth	r0, r3
 80173e0:	687b      	ldr	r3, [r7, #4]
 80173e2:	681a      	ldr	r2, [r3, #0]
 80173e4:	197b      	adds	r3, r7, r5
 80173e6:	881b      	ldrh	r3, [r3, #0]
 80173e8:	1979      	adds	r1, r7, r5
 80173ea:	1c5c      	adds	r4, r3, #1
 80173ec:	800c      	strh	r4, [r1, #0]
 80173ee:	18d3      	adds	r3, r2, r3
 80173f0:	b2c2      	uxtb	r2, r0
 80173f2:	701a      	strb	r2, [r3, #0]

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 80173f4:	687b      	ldr	r3, [r7, #4]
 80173f6:	681a      	ldr	r2, [r3, #0]
 80173f8:	002c      	movs	r4, r5
 80173fa:	197b      	adds	r3, r7, r5
 80173fc:	881b      	ldrh	r3, [r3, #0]
 80173fe:	18d0      	adds	r0, r2, r3
 8017400:	687b      	ldr	r3, [r7, #4]
 8017402:	3310      	adds	r3, #16
 8017404:	0019      	movs	r1, r3
 8017406:	687b      	ldr	r3, [r7, #4]
 8017408:	7b1b      	ldrb	r3, [r3, #12]
 801740a:	071b      	lsls	r3, r3, #28
 801740c:	0f1b      	lsrs	r3, r3, #28
 801740e:	b2db      	uxtb	r3, r3
 8017410:	b29b      	uxth	r3, r3
 8017412:	001a      	movs	r2, r3
 8017414:	f004 f898 	bl	801b548 <memcpy1>
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 8017418:	687b      	ldr	r3, [r7, #4]
 801741a:	7b1b      	ldrb	r3, [r3, #12]
 801741c:	071b      	lsls	r3, r3, #28
 801741e:	0f1b      	lsrs	r3, r3, #28
 8017420:	b2db      	uxtb	r3, r3
 8017422:	b299      	uxth	r1, r3
 8017424:	193b      	adds	r3, r7, r4
 8017426:	193a      	adds	r2, r7, r4
 8017428:	8812      	ldrh	r2, [r2, #0]
 801742a:	188a      	adds	r2, r1, r2
 801742c:	801a      	strh	r2, [r3, #0]

    if( macMsg->FRMPayloadSize > 0 )
 801742e:	687b      	ldr	r3, [r7, #4]
 8017430:	2228      	movs	r2, #40	; 0x28
 8017432:	5c9b      	ldrb	r3, [r3, r2]
 8017434:	2b00      	cmp	r3, #0
 8017436:	d00b      	beq.n	8017450 <LoRaMacSerializerData+0x1aa>
    {
        macMsg->Buffer[bufItr++] = macMsg->FPort;
 8017438:	687b      	ldr	r3, [r7, #4]
 801743a:	681a      	ldr	r2, [r3, #0]
 801743c:	193b      	adds	r3, r7, r4
 801743e:	881b      	ldrh	r3, [r3, #0]
 8017440:	1939      	adds	r1, r7, r4
 8017442:	1c58      	adds	r0, r3, #1
 8017444:	8008      	strh	r0, [r1, #0]
 8017446:	18d3      	adds	r3, r2, r3
 8017448:	687a      	ldr	r2, [r7, #4]
 801744a:	2120      	movs	r1, #32
 801744c:	5c52      	ldrb	r2, [r2, r1]
 801744e:	701a      	strb	r2, [r3, #0]
    }

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FRMPayload, macMsg->FRMPayloadSize );
 8017450:	687b      	ldr	r3, [r7, #4]
 8017452:	681a      	ldr	r2, [r3, #0]
 8017454:	240e      	movs	r4, #14
 8017456:	193b      	adds	r3, r7, r4
 8017458:	881b      	ldrh	r3, [r3, #0]
 801745a:	18d0      	adds	r0, r2, r3
 801745c:	687b      	ldr	r3, [r7, #4]
 801745e:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8017460:	687b      	ldr	r3, [r7, #4]
 8017462:	2228      	movs	r2, #40	; 0x28
 8017464:	5c9b      	ldrb	r3, [r3, r2]
 8017466:	b29b      	uxth	r3, r3
 8017468:	001a      	movs	r2, r3
 801746a:	f004 f86d 	bl	801b548 <memcpy1>
    bufItr = bufItr + macMsg->FRMPayloadSize;
 801746e:	687b      	ldr	r3, [r7, #4]
 8017470:	2228      	movs	r2, #40	; 0x28
 8017472:	5c9b      	ldrb	r3, [r3, r2]
 8017474:	b299      	uxth	r1, r3
 8017476:	193b      	adds	r3, r7, r4
 8017478:	193a      	adds	r2, r7, r4
 801747a:	8812      	ldrh	r2, [r2, #0]
 801747c:	188a      	adds	r2, r1, r2
 801747e:	801a      	strh	r2, [r3, #0]

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 8017480:	687b      	ldr	r3, [r7, #4]
 8017482:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8017484:	687b      	ldr	r3, [r7, #4]
 8017486:	681a      	ldr	r2, [r3, #0]
 8017488:	193b      	adds	r3, r7, r4
 801748a:	881b      	ldrh	r3, [r3, #0]
 801748c:	0025      	movs	r5, r4
 801748e:	1939      	adds	r1, r7, r4
 8017490:	1c5c      	adds	r4, r3, #1
 8017492:	800c      	strh	r4, [r1, #0]
 8017494:	18d3      	adds	r3, r2, r3
 8017496:	b2c2      	uxtb	r2, r0
 8017498:	701a      	strb	r2, [r3, #0]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 801749a:	687b      	ldr	r3, [r7, #4]
 801749c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801749e:	0a18      	lsrs	r0, r3, #8
 80174a0:	687b      	ldr	r3, [r7, #4]
 80174a2:	681a      	ldr	r2, [r3, #0]
 80174a4:	197b      	adds	r3, r7, r5
 80174a6:	881b      	ldrh	r3, [r3, #0]
 80174a8:	1979      	adds	r1, r7, r5
 80174aa:	1c5c      	adds	r4, r3, #1
 80174ac:	800c      	strh	r4, [r1, #0]
 80174ae:	18d3      	adds	r3, r2, r3
 80174b0:	b2c2      	uxtb	r2, r0
 80174b2:	701a      	strb	r2, [r3, #0]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 80174b4:	687b      	ldr	r3, [r7, #4]
 80174b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80174b8:	0c18      	lsrs	r0, r3, #16
 80174ba:	687b      	ldr	r3, [r7, #4]
 80174bc:	681a      	ldr	r2, [r3, #0]
 80174be:	197b      	adds	r3, r7, r5
 80174c0:	881b      	ldrh	r3, [r3, #0]
 80174c2:	1979      	adds	r1, r7, r5
 80174c4:	1c5c      	adds	r4, r3, #1
 80174c6:	800c      	strh	r4, [r1, #0]
 80174c8:	18d3      	adds	r3, r2, r3
 80174ca:	b2c2      	uxtb	r2, r0
 80174cc:	701a      	strb	r2, [r3, #0]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 80174ce:	687b      	ldr	r3, [r7, #4]
 80174d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80174d2:	0e18      	lsrs	r0, r3, #24
 80174d4:	687b      	ldr	r3, [r7, #4]
 80174d6:	681a      	ldr	r2, [r3, #0]
 80174d8:	197b      	adds	r3, r7, r5
 80174da:	881b      	ldrh	r3, [r3, #0]
 80174dc:	1979      	adds	r1, r7, r5
 80174de:	1c5c      	adds	r4, r3, #1
 80174e0:	800c      	strh	r4, [r1, #0]
 80174e2:	18d3      	adds	r3, r2, r3
 80174e4:	b2c2      	uxtb	r2, r0
 80174e6:	701a      	strb	r2, [r3, #0]

    macMsg->BufSize = bufItr;
 80174e8:	197b      	adds	r3, r7, r5
 80174ea:	881b      	ldrh	r3, [r3, #0]
 80174ec:	b2da      	uxtb	r2, r3
 80174ee:	687b      	ldr	r3, [r7, #4]
 80174f0:	711a      	strb	r2, [r3, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 80174f2:	2300      	movs	r3, #0
}
 80174f4:	0018      	movs	r0, r3
 80174f6:	46bd      	mov	sp, r7
 80174f8:	b004      	add	sp, #16
 80174fa:	bdb0      	pop	{r4, r5, r7, pc}

080174fc <RegionIsActive>:
#define RU864_APPLY_DR_OFFSET( )
#define RU864_RX_BEACON_SETUP( )
#endif

bool RegionIsActive( LoRaMacRegion_t region )
{
 80174fc:	b580      	push	{r7, lr}
 80174fe:	b082      	sub	sp, #8
 8017500:	af00      	add	r7, sp, #0
 8017502:	0002      	movs	r2, r0
 8017504:	1dfb      	adds	r3, r7, #7
 8017506:	701a      	strb	r2, [r3, #0]
    switch( region )
 8017508:	1dfb      	adds	r3, r7, #7
 801750a:	781b      	ldrb	r3, [r3, #0]
 801750c:	2b05      	cmp	r3, #5
 801750e:	d101      	bne.n	8017514 <RegionIsActive+0x18>
        AS923_IS_ACTIVE( );
        AU915_IS_ACTIVE( );
        CN470_IS_ACTIVE( );
        CN779_IS_ACTIVE( );
        EU433_IS_ACTIVE( );
        EU868_IS_ACTIVE( );
 8017510:	2301      	movs	r3, #1
 8017512:	e000      	b.n	8017516 <RegionIsActive+0x1a>
        IN865_IS_ACTIVE( );
        US915_IS_ACTIVE( );
        RU864_IS_ACTIVE( );
        default:
        {
            return false;
 8017514:	2300      	movs	r3, #0
        }
    }
}
 8017516:	0018      	movs	r0, r3
 8017518:	46bd      	mov	sp, r7
 801751a:	b002      	add	sp, #8
 801751c:	bd80      	pop	{r7, pc}

0801751e <RegionGetPhyParam>:

PhyParam_t RegionGetPhyParam( LoRaMacRegion_t region, GetPhyParams_t* getPhy )
{
 801751e:	b580      	push	{r7, lr}
 8017520:	b084      	sub	sp, #16
 8017522:	af00      	add	r7, sp, #0
 8017524:	0002      	movs	r2, r0
 8017526:	6039      	str	r1, [r7, #0]
 8017528:	1dfb      	adds	r3, r7, #7
 801752a:	701a      	strb	r2, [r3, #0]
    PhyParam_t phyParam = { 0 };
 801752c:	2308      	movs	r3, #8
 801752e:	18fb      	adds	r3, r7, r3
 8017530:	2200      	movs	r2, #0
 8017532:	601a      	str	r2, [r3, #0]
    switch( region )
 8017534:	1dfb      	adds	r3, r7, #7
 8017536:	781b      	ldrb	r3, [r3, #0]
 8017538:	2b05      	cmp	r3, #5
 801753a:	d109      	bne.n	8017550 <RegionGetPhyParam+0x32>
        AS923_GET_PHY_PARAM( );
        AU915_GET_PHY_PARAM( );
        CN470_GET_PHY_PARAM( );
        CN779_GET_PHY_PARAM( );
        EU433_GET_PHY_PARAM( );
        EU868_GET_PHY_PARAM( );
 801753c:	683b      	ldr	r3, [r7, #0]
 801753e:	0018      	movs	r0, r3
 8017540:	f001 f900 	bl	8018744 <RegionEU868GetPhyParam>
 8017544:	0003      	movs	r3, r0
 8017546:	001a      	movs	r2, r3
 8017548:	230c      	movs	r3, #12
 801754a:	18fb      	adds	r3, r7, r3
 801754c:	601a      	str	r2, [r3, #0]
 801754e:	e005      	b.n	801755c <RegionGetPhyParam+0x3e>
        IN865_GET_PHY_PARAM( );
        US915_GET_PHY_PARAM( );
        RU864_GET_PHY_PARAM( );
        default:
        {
            return phyParam;
 8017550:	230c      	movs	r3, #12
 8017552:	18fb      	adds	r3, r7, r3
 8017554:	2208      	movs	r2, #8
 8017556:	18ba      	adds	r2, r7, r2
 8017558:	6812      	ldr	r2, [r2, #0]
 801755a:	601a      	str	r2, [r3, #0]
 801755c:	230c      	movs	r3, #12
 801755e:	18fb      	adds	r3, r7, r3
 8017560:	2200      	movs	r2, #0
 8017562:	681a      	ldr	r2, [r3, #0]
 8017564:	0013      	movs	r3, r2
        }
    }
}
 8017566:	0018      	movs	r0, r3
 8017568:	46bd      	mov	sp, r7
 801756a:	b004      	add	sp, #16
 801756c:	bd80      	pop	{r7, pc}

0801756e <RegionSetBandTxDone>:

void RegionSetBandTxDone( LoRaMacRegion_t region, SetBandTxDoneParams_t* txDone )
{
 801756e:	b580      	push	{r7, lr}
 8017570:	b082      	sub	sp, #8
 8017572:	af00      	add	r7, sp, #0
 8017574:	0002      	movs	r2, r0
 8017576:	6039      	str	r1, [r7, #0]
 8017578:	1dfb      	adds	r3, r7, #7
 801757a:	701a      	strb	r2, [r3, #0]
    switch( region )
 801757c:	1dfb      	adds	r3, r7, #7
 801757e:	781b      	ldrb	r3, [r3, #0]
 8017580:	2b05      	cmp	r3, #5
 8017582:	d104      	bne.n	801758e <RegionSetBandTxDone+0x20>
        AS923_SET_BAND_TX_DONE( );
        AU915_SET_BAND_TX_DONE( );
        CN470_SET_BAND_TX_DONE( );
        CN779_SET_BAND_TX_DONE( );
        EU433_SET_BAND_TX_DONE( );
        EU868_SET_BAND_TX_DONE( );
 8017584:	683b      	ldr	r3, [r7, #0]
 8017586:	0018      	movs	r0, r3
 8017588:	f001 f9e0 	bl	801894c <RegionEU868SetBandTxDone>
 801758c:	e000      	b.n	8017590 <RegionSetBandTxDone+0x22>
        IN865_SET_BAND_TX_DONE( );
        US915_SET_BAND_TX_DONE( );
        RU864_SET_BAND_TX_DONE( );
        default:
        {
            return;
 801758e:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 8017590:	46bd      	mov	sp, r7
 8017592:	b002      	add	sp, #8
 8017594:	bd80      	pop	{r7, pc}

08017596 <RegionInitDefaults>:

void RegionInitDefaults( LoRaMacRegion_t region, InitDefaultsParams_t* params )
{
 8017596:	b580      	push	{r7, lr}
 8017598:	b082      	sub	sp, #8
 801759a:	af00      	add	r7, sp, #0
 801759c:	0002      	movs	r2, r0
 801759e:	6039      	str	r1, [r7, #0]
 80175a0:	1dfb      	adds	r3, r7, #7
 80175a2:	701a      	strb	r2, [r3, #0]
    switch( region )
 80175a4:	1dfb      	adds	r3, r7, #7
 80175a6:	781b      	ldrb	r3, [r3, #0]
 80175a8:	2b05      	cmp	r3, #5
 80175aa:	d104      	bne.n	80175b6 <RegionInitDefaults+0x20>
        AS923_INIT_DEFAULTS( );
        AU915_INIT_DEFAULTS( );
        CN470_INIT_DEFAULTS( );
        CN779_INIT_DEFAULTS( );
        EU433_INIT_DEFAULTS( );
        EU868_INIT_DEFAULTS( );
 80175ac:	683b      	ldr	r3, [r7, #0]
 80175ae:	0018      	movs	r0, r3
 80175b0:	f001 f9ec 	bl	801898c <RegionEU868InitDefaults>
 80175b4:	e000      	b.n	80175b8 <RegionInitDefaults+0x22>
        IN865_INIT_DEFAULTS( );
        US915_INIT_DEFAULTS( );
        RU864_INIT_DEFAULTS( );
        default:
        {
            break;
 80175b6:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 80175b8:	46c0      	nop			; (mov r8, r8)
 80175ba:	46bd      	mov	sp, r7
 80175bc:	b002      	add	sp, #8
 80175be:	bd80      	pop	{r7, pc}

080175c0 <RegionGetNvmCtx>:

void* RegionGetNvmCtx( LoRaMacRegion_t region, GetNvmCtxParams_t* params )
{
 80175c0:	b580      	push	{r7, lr}
 80175c2:	b082      	sub	sp, #8
 80175c4:	af00      	add	r7, sp, #0
 80175c6:	0002      	movs	r2, r0
 80175c8:	6039      	str	r1, [r7, #0]
 80175ca:	1dfb      	adds	r3, r7, #7
 80175cc:	701a      	strb	r2, [r3, #0]
    switch( region )
 80175ce:	1dfb      	adds	r3, r7, #7
 80175d0:	781b      	ldrb	r3, [r3, #0]
 80175d2:	2b05      	cmp	r3, #5
 80175d4:	d105      	bne.n	80175e2 <RegionGetNvmCtx+0x22>
        AS923_GET_NVM_CTX( );
        AU915_GET_NVM_CTX( );
        CN470_GET_NVM_CTX( );
        CN779_GET_NVM_CTX( );
        EU433_GET_NVM_CTX( );
        EU868_GET_NVM_CTX( );
 80175d6:	683b      	ldr	r3, [r7, #0]
 80175d8:	0018      	movs	r0, r3
 80175da:	f001 fa65 	bl	8018aa8 <RegionEU868GetNvmCtx>
 80175de:	0003      	movs	r3, r0
 80175e0:	e000      	b.n	80175e4 <RegionGetNvmCtx+0x24>
        IN865_GET_NVM_CTX( );
        US915_GET_NVM_CTX( );
        RU864_GET_NVM_CTX( );
        default:
        {
           return 0;
 80175e2:	2300      	movs	r3, #0
        }
    }
}
 80175e4:	0018      	movs	r0, r3
 80175e6:	46bd      	mov	sp, r7
 80175e8:	b002      	add	sp, #8
 80175ea:	bd80      	pop	{r7, pc}

080175ec <RegionVerify>:

bool RegionVerify( LoRaMacRegion_t region, VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 80175ec:	b580      	push	{r7, lr}
 80175ee:	b082      	sub	sp, #8
 80175f0:	af00      	add	r7, sp, #0
 80175f2:	6039      	str	r1, [r7, #0]
 80175f4:	0011      	movs	r1, r2
 80175f6:	1dfb      	adds	r3, r7, #7
 80175f8:	1c02      	adds	r2, r0, #0
 80175fa:	701a      	strb	r2, [r3, #0]
 80175fc:	1dbb      	adds	r3, r7, #6
 80175fe:	1c0a      	adds	r2, r1, #0
 8017600:	701a      	strb	r2, [r3, #0]
    switch( region )
 8017602:	1dfb      	adds	r3, r7, #7
 8017604:	781b      	ldrb	r3, [r3, #0]
 8017606:	2b05      	cmp	r3, #5
 8017608:	d108      	bne.n	801761c <RegionVerify+0x30>
        AS923_VERIFY( );
        AU915_VERIFY( );
        CN470_VERIFY( );
        CN779_VERIFY( );
        EU433_VERIFY( );
        EU868_VERIFY( );
 801760a:	1dbb      	adds	r3, r7, #6
 801760c:	781a      	ldrb	r2, [r3, #0]
 801760e:	683b      	ldr	r3, [r7, #0]
 8017610:	0011      	movs	r1, r2
 8017612:	0018      	movs	r0, r3
 8017614:	f001 fa58 	bl	8018ac8 <RegionEU868Verify>
 8017618:	0003      	movs	r3, r0
 801761a:	e000      	b.n	801761e <RegionVerify+0x32>
        IN865_VERIFY( );
        US915_VERIFY( );
        RU864_VERIFY( );
        default:
        {
            return false;
 801761c:	2300      	movs	r3, #0
        }
    }
}
 801761e:	0018      	movs	r0, r3
 8017620:	46bd      	mov	sp, r7
 8017622:	b002      	add	sp, #8
 8017624:	bd80      	pop	{r7, pc}

08017626 <RegionApplyCFList>:

void RegionApplyCFList( LoRaMacRegion_t region, ApplyCFListParams_t* applyCFList )
{
 8017626:	b580      	push	{r7, lr}
 8017628:	b082      	sub	sp, #8
 801762a:	af00      	add	r7, sp, #0
 801762c:	0002      	movs	r2, r0
 801762e:	6039      	str	r1, [r7, #0]
 8017630:	1dfb      	adds	r3, r7, #7
 8017632:	701a      	strb	r2, [r3, #0]
    switch( region )
 8017634:	1dfb      	adds	r3, r7, #7
 8017636:	781b      	ldrb	r3, [r3, #0]
 8017638:	2b05      	cmp	r3, #5
 801763a:	d104      	bne.n	8017646 <RegionApplyCFList+0x20>
        AS923_APPLY_CF_LIST( );
        AU915_APPLY_CF_LIST( );
        CN470_APPLY_CF_LIST( );
        CN779_APPLY_CF_LIST( );
        EU433_APPLY_CF_LIST( );
        EU868_APPLY_CF_LIST( );
 801763c:	683b      	ldr	r3, [r7, #0]
 801763e:	0018      	movs	r0, r3
 8017640:	f001 fa9c 	bl	8018b7c <RegionEU868ApplyCFList>
 8017644:	e000      	b.n	8017648 <RegionApplyCFList+0x22>
        IN865_APPLY_CF_LIST( );
        US915_APPLY_CF_LIST( );
        RU864_APPLY_CF_LIST( );
        default:
        {
            break;
 8017646:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 8017648:	46c0      	nop			; (mov r8, r8)
 801764a:	46bd      	mov	sp, r7
 801764c:	b002      	add	sp, #8
 801764e:	bd80      	pop	{r7, pc}

08017650 <RegionChanMaskSet>:

bool RegionChanMaskSet( LoRaMacRegion_t region, ChanMaskSetParams_t* chanMaskSet )
{
 8017650:	b580      	push	{r7, lr}
 8017652:	b082      	sub	sp, #8
 8017654:	af00      	add	r7, sp, #0
 8017656:	0002      	movs	r2, r0
 8017658:	6039      	str	r1, [r7, #0]
 801765a:	1dfb      	adds	r3, r7, #7
 801765c:	701a      	strb	r2, [r3, #0]
    switch( region )
 801765e:	1dfb      	adds	r3, r7, #7
 8017660:	781b      	ldrb	r3, [r3, #0]
 8017662:	2b05      	cmp	r3, #5
 8017664:	d105      	bne.n	8017672 <RegionChanMaskSet+0x22>
        AS923_CHAN_MASK_SET( );
        AU915_CHAN_MASK_SET( );
        CN470_CHAN_MASK_SET( );
        CN779_CHAN_MASK_SET( );
        EU433_CHAN_MASK_SET( );
        EU868_CHAN_MASK_SET( );
 8017666:	683b      	ldr	r3, [r7, #0]
 8017668:	0018      	movs	r0, r3
 801766a:	f001 fb17 	bl	8018c9c <RegionEU868ChanMaskSet>
 801766e:	0003      	movs	r3, r0
 8017670:	e000      	b.n	8017674 <RegionChanMaskSet+0x24>
        IN865_CHAN_MASK_SET( );
        US915_CHAN_MASK_SET( );
        RU864_CHAN_MASK_SET( );
        default:
        {
            return false;
 8017672:	2300      	movs	r3, #0
        }
    }
}
 8017674:	0018      	movs	r0, r3
 8017676:	46bd      	mov	sp, r7
 8017678:	b002      	add	sp, #8
 801767a:	bd80      	pop	{r7, pc}

0801767c <RegionComputeRxWindowParameters>:

void RegionComputeRxWindowParameters( LoRaMacRegion_t region, int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 801767c:	b590      	push	{r4, r7, lr}
 801767e:	b083      	sub	sp, #12
 8017680:	af00      	add	r7, sp, #0
 8017682:	0004      	movs	r4, r0
 8017684:	0008      	movs	r0, r1
 8017686:	0011      	movs	r1, r2
 8017688:	603b      	str	r3, [r7, #0]
 801768a:	1dfb      	adds	r3, r7, #7
 801768c:	1c22      	adds	r2, r4, #0
 801768e:	701a      	strb	r2, [r3, #0]
 8017690:	1dbb      	adds	r3, r7, #6
 8017692:	1c02      	adds	r2, r0, #0
 8017694:	701a      	strb	r2, [r3, #0]
 8017696:	1d7b      	adds	r3, r7, #5
 8017698:	1c0a      	adds	r2, r1, #0
 801769a:	701a      	strb	r2, [r3, #0]
    switch( region )
 801769c:	1dfb      	adds	r3, r7, #7
 801769e:	781b      	ldrb	r3, [r3, #0]
 80176a0:	2b05      	cmp	r3, #5
 80176a2:	d10a      	bne.n	80176ba <RegionComputeRxWindowParameters+0x3e>
        AS923_COMPUTE_RX_WINDOW_PARAMETERS( );
        AU915_COMPUTE_RX_WINDOW_PARAMETERS( );
        CN470_COMPUTE_RX_WINDOW_PARAMETERS( );
        CN779_COMPUTE_RX_WINDOW_PARAMETERS( );
        EU433_COMPUTE_RX_WINDOW_PARAMETERS( );
        EU868_COMPUTE_RX_WINDOW_PARAMETERS( );
 80176a4:	69bc      	ldr	r4, [r7, #24]
 80176a6:	683a      	ldr	r2, [r7, #0]
 80176a8:	1d7b      	adds	r3, r7, #5
 80176aa:	7819      	ldrb	r1, [r3, #0]
 80176ac:	1dbb      	adds	r3, r7, #6
 80176ae:	2000      	movs	r0, #0
 80176b0:	5618      	ldrsb	r0, [r3, r0]
 80176b2:	0023      	movs	r3, r4
 80176b4:	f001 fb18 	bl	8018ce8 <RegionEU868ComputeRxWindowParameters>
 80176b8:	e000      	b.n	80176bc <RegionComputeRxWindowParameters+0x40>
        IN865_COMPUTE_RX_WINDOW_PARAMETERS( );
        US915_COMPUTE_RX_WINDOW_PARAMETERS( );
        RU864_COMPUTE_RX_WINDOW_PARAMETERS( );
        default:
        {
            break;
 80176ba:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 80176bc:	46c0      	nop			; (mov r8, r8)
 80176be:	46bd      	mov	sp, r7
 80176c0:	b003      	add	sp, #12
 80176c2:	bd90      	pop	{r4, r7, pc}

080176c4 <RegionRxConfig>:

bool RegionRxConfig( LoRaMacRegion_t region, RxConfigParams_t* rxConfig, int8_t* datarate )
{
 80176c4:	b580      	push	{r7, lr}
 80176c6:	b084      	sub	sp, #16
 80176c8:	af00      	add	r7, sp, #0
 80176ca:	60b9      	str	r1, [r7, #8]
 80176cc:	607a      	str	r2, [r7, #4]
 80176ce:	210f      	movs	r1, #15
 80176d0:	187b      	adds	r3, r7, r1
 80176d2:	1c02      	adds	r2, r0, #0
 80176d4:	701a      	strb	r2, [r3, #0]
    switch( region )
 80176d6:	187b      	adds	r3, r7, r1
 80176d8:	781b      	ldrb	r3, [r3, #0]
 80176da:	2b05      	cmp	r3, #5
 80176dc:	d107      	bne.n	80176ee <RegionRxConfig+0x2a>
        AS923_RX_CONFIG( );
        AU915_RX_CONFIG( );
        CN470_RX_CONFIG( );
        CN779_RX_CONFIG( );
        EU433_RX_CONFIG( );
        EU868_RX_CONFIG( );
 80176de:	687a      	ldr	r2, [r7, #4]
 80176e0:	68bb      	ldr	r3, [r7, #8]
 80176e2:	0011      	movs	r1, r2
 80176e4:	0018      	movs	r0, r3
 80176e6:	f001 fb69 	bl	8018dbc <RegionEU868RxConfig>
 80176ea:	0003      	movs	r3, r0
 80176ec:	e000      	b.n	80176f0 <RegionRxConfig+0x2c>
        IN865_RX_CONFIG( );
        US915_RX_CONFIG( );
        RU864_RX_CONFIG( );
        default:
        {
            return false;
 80176ee:	2300      	movs	r3, #0
        }
    }
}
 80176f0:	0018      	movs	r0, r3
 80176f2:	46bd      	mov	sp, r7
 80176f4:	b004      	add	sp, #16
 80176f6:	bd80      	pop	{r7, pc}

080176f8 <RegionTxConfig>:

bool RegionTxConfig( LoRaMacRegion_t region, TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 80176f8:	b580      	push	{r7, lr}
 80176fa:	b084      	sub	sp, #16
 80176fc:	af00      	add	r7, sp, #0
 80176fe:	60b9      	str	r1, [r7, #8]
 8017700:	607a      	str	r2, [r7, #4]
 8017702:	603b      	str	r3, [r7, #0]
 8017704:	210f      	movs	r1, #15
 8017706:	187b      	adds	r3, r7, r1
 8017708:	1c02      	adds	r2, r0, #0
 801770a:	701a      	strb	r2, [r3, #0]
    switch( region )
 801770c:	187b      	adds	r3, r7, r1
 801770e:	781b      	ldrb	r3, [r3, #0]
 8017710:	2b05      	cmp	r3, #5
 8017712:	d107      	bne.n	8017724 <RegionTxConfig+0x2c>
        AS923_TX_CONFIG( );
        AU915_TX_CONFIG( );
        CN470_TX_CONFIG( );
        CN779_TX_CONFIG( );
        EU433_TX_CONFIG( );
        EU868_TX_CONFIG( );
 8017714:	683a      	ldr	r2, [r7, #0]
 8017716:	6879      	ldr	r1, [r7, #4]
 8017718:	68bb      	ldr	r3, [r7, #8]
 801771a:	0018      	movs	r0, r3
 801771c:	f001 fc38 	bl	8018f90 <RegionEU868TxConfig>
 8017720:	0003      	movs	r3, r0
 8017722:	e000      	b.n	8017726 <RegionTxConfig+0x2e>
        IN865_TX_CONFIG( );
        US915_TX_CONFIG( );
        RU864_TX_CONFIG( );
        default:
        {
            return false;
 8017724:	2300      	movs	r3, #0
        }
    }
}
 8017726:	0018      	movs	r0, r3
 8017728:	46bd      	mov	sp, r7
 801772a:	b004      	add	sp, #16
 801772c:	bd80      	pop	{r7, pc}

0801772e <RegionLinkAdrReq>:

uint8_t RegionLinkAdrReq( LoRaMacRegion_t region, LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 801772e:	b590      	push	{r4, r7, lr}
 8017730:	b087      	sub	sp, #28
 8017732:	af02      	add	r7, sp, #8
 8017734:	60b9      	str	r1, [r7, #8]
 8017736:	607a      	str	r2, [r7, #4]
 8017738:	603b      	str	r3, [r7, #0]
 801773a:	210f      	movs	r1, #15
 801773c:	187b      	adds	r3, r7, r1
 801773e:	1c02      	adds	r2, r0, #0
 8017740:	701a      	strb	r2, [r3, #0]
    switch( region )
 8017742:	187b      	adds	r3, r7, r1
 8017744:	781b      	ldrb	r3, [r3, #0]
 8017746:	2b05      	cmp	r3, #5
 8017748:	d10a      	bne.n	8017760 <RegionLinkAdrReq+0x32>
        AS923_LINK_ADR_REQ( );
        AU915_LINK_ADR_REQ( );
        CN470_LINK_ADR_REQ( );
        CN779_LINK_ADR_REQ( );
        EU433_LINK_ADR_REQ( );
        EU868_LINK_ADR_REQ( );
 801774a:	6a3c      	ldr	r4, [r7, #32]
 801774c:	683a      	ldr	r2, [r7, #0]
 801774e:	6879      	ldr	r1, [r7, #4]
 8017750:	68b8      	ldr	r0, [r7, #8]
 8017752:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017754:	9300      	str	r3, [sp, #0]
 8017756:	0023      	movs	r3, r4
 8017758:	f001 fcf2 	bl	8019140 <RegionEU868LinkAdrReq>
 801775c:	0003      	movs	r3, r0
 801775e:	e000      	b.n	8017762 <RegionLinkAdrReq+0x34>
        IN865_LINK_ADR_REQ( );
        US915_LINK_ADR_REQ( );
        RU864_LINK_ADR_REQ( );
        default:
        {
            return 0;
 8017760:	2300      	movs	r3, #0
        }
    }
}
 8017762:	0018      	movs	r0, r3
 8017764:	46bd      	mov	sp, r7
 8017766:	b005      	add	sp, #20
 8017768:	bd90      	pop	{r4, r7, pc}

0801776a <RegionRxParamSetupReq>:

uint8_t RegionRxParamSetupReq( LoRaMacRegion_t region, RxParamSetupReqParams_t* rxParamSetupReq )
{
 801776a:	b580      	push	{r7, lr}
 801776c:	b082      	sub	sp, #8
 801776e:	af00      	add	r7, sp, #0
 8017770:	0002      	movs	r2, r0
 8017772:	6039      	str	r1, [r7, #0]
 8017774:	1dfb      	adds	r3, r7, #7
 8017776:	701a      	strb	r2, [r3, #0]
    switch( region )
 8017778:	1dfb      	adds	r3, r7, #7
 801777a:	781b      	ldrb	r3, [r3, #0]
 801777c:	2b05      	cmp	r3, #5
 801777e:	d105      	bne.n	801778c <RegionRxParamSetupReq+0x22>
        AS923_RX_PARAM_SETUP_REQ( );
        AU915_RX_PARAM_SETUP_REQ( );
        CN470_RX_PARAM_SETUP_REQ( );
        CN779_RX_PARAM_SETUP_REQ( );
        EU433_RX_PARAM_SETUP_REQ( );
        EU868_RX_PARAM_SETUP_REQ( );
 8017780:	683b      	ldr	r3, [r7, #0]
 8017782:	0018      	movs	r0, r3
 8017784:	f001 fe2c 	bl	80193e0 <RegionEU868RxParamSetupReq>
 8017788:	0003      	movs	r3, r0
 801778a:	e000      	b.n	801778e <RegionRxParamSetupReq+0x24>
        IN865_RX_PARAM_SETUP_REQ( );
        US915_RX_PARAM_SETUP_REQ( );
        RU864_RX_PARAM_SETUP_REQ( );
        default:
        {
            return 0;
 801778c:	2300      	movs	r3, #0
        }
    }
}
 801778e:	0018      	movs	r0, r3
 8017790:	46bd      	mov	sp, r7
 8017792:	b002      	add	sp, #8
 8017794:	bd80      	pop	{r7, pc}

08017796 <RegionNewChannelReq>:

uint8_t RegionNewChannelReq( LoRaMacRegion_t region, NewChannelReqParams_t* newChannelReq )
{
 8017796:	b580      	push	{r7, lr}
 8017798:	b082      	sub	sp, #8
 801779a:	af00      	add	r7, sp, #0
 801779c:	0002      	movs	r2, r0
 801779e:	6039      	str	r1, [r7, #0]
 80177a0:	1dfb      	adds	r3, r7, #7
 80177a2:	701a      	strb	r2, [r3, #0]
    switch( region )
 80177a4:	1dfb      	adds	r3, r7, #7
 80177a6:	781b      	ldrb	r3, [r3, #0]
 80177a8:	2b05      	cmp	r3, #5
 80177aa:	d105      	bne.n	80177b8 <RegionNewChannelReq+0x22>
        AS923_NEW_CHANNEL_REQ( );
        AU915_NEW_CHANNEL_REQ( );
        CN470_NEW_CHANNEL_REQ( );
        CN779_NEW_CHANNEL_REQ( );
        EU433_NEW_CHANNEL_REQ( );
        EU868_NEW_CHANNEL_REQ( );
 80177ac:	683b      	ldr	r3, [r7, #0]
 80177ae:	0018      	movs	r0, r3
 80177b0:	f001 fe5f 	bl	8019472 <RegionEU868NewChannelReq>
 80177b4:	0003      	movs	r3, r0
 80177b6:	e000      	b.n	80177ba <RegionNewChannelReq+0x24>
        IN865_NEW_CHANNEL_REQ( );
        US915_NEW_CHANNEL_REQ( );
        RU864_NEW_CHANNEL_REQ( );
        default:
        {
            return 0;
 80177b8:	2300      	movs	r3, #0
        }
    }
}
 80177ba:	0018      	movs	r0, r3
 80177bc:	46bd      	mov	sp, r7
 80177be:	b002      	add	sp, #8
 80177c0:	bd80      	pop	{r7, pc}

080177c2 <RegionTxParamSetupReq>:

int8_t RegionTxParamSetupReq( LoRaMacRegion_t region, TxParamSetupReqParams_t* txParamSetupReq )
{
 80177c2:	b580      	push	{r7, lr}
 80177c4:	b082      	sub	sp, #8
 80177c6:	af00      	add	r7, sp, #0
 80177c8:	0002      	movs	r2, r0
 80177ca:	6039      	str	r1, [r7, #0]
 80177cc:	1dfb      	adds	r3, r7, #7
 80177ce:	701a      	strb	r2, [r3, #0]
    switch( region )
 80177d0:	1dfb      	adds	r3, r7, #7
 80177d2:	781b      	ldrb	r3, [r3, #0]
 80177d4:	2b05      	cmp	r3, #5
 80177d6:	d105      	bne.n	80177e4 <RegionTxParamSetupReq+0x22>
        AS923_TX_PARAM_SETUP_REQ( );
        AU915_TX_PARAM_SETUP_REQ( );
        CN470_TX_PARAM_SETUP_REQ( );
        CN779_TX_PARAM_SETUP_REQ( );
        EU433_TX_PARAM_SETUP_REQ( );
        EU868_TX_PARAM_SETUP_REQ( );
 80177d8:	683b      	ldr	r3, [r7, #0]
 80177da:	0018      	movs	r0, r3
 80177dc:	f001 feb1 	bl	8019542 <RegionEU868TxParamSetupReq>
 80177e0:	0003      	movs	r3, r0
 80177e2:	e000      	b.n	80177e6 <RegionTxParamSetupReq+0x24>
        IN865_TX_PARAM_SETUP_REQ( );
        US915_TX_PARAM_SETUP_REQ( );
        RU864_TX_PARAM_SETUP_REQ( );
        default:
        {
            return 0;
 80177e4:	2300      	movs	r3, #0
        }
    }
}
 80177e6:	0018      	movs	r0, r3
 80177e8:	46bd      	mov	sp, r7
 80177ea:	b002      	add	sp, #8
 80177ec:	bd80      	pop	{r7, pc}

080177ee <RegionDlChannelReq>:

uint8_t RegionDlChannelReq( LoRaMacRegion_t region, DlChannelReqParams_t* dlChannelReq )
{
 80177ee:	b580      	push	{r7, lr}
 80177f0:	b082      	sub	sp, #8
 80177f2:	af00      	add	r7, sp, #0
 80177f4:	0002      	movs	r2, r0
 80177f6:	6039      	str	r1, [r7, #0]
 80177f8:	1dfb      	adds	r3, r7, #7
 80177fa:	701a      	strb	r2, [r3, #0]
    switch( region )
 80177fc:	1dfb      	adds	r3, r7, #7
 80177fe:	781b      	ldrb	r3, [r3, #0]
 8017800:	2b05      	cmp	r3, #5
 8017802:	d105      	bne.n	8017810 <RegionDlChannelReq+0x22>
        AS923_DL_CHANNEL_REQ( );
        AU915_DL_CHANNEL_REQ( );
        CN470_DL_CHANNEL_REQ( );
        CN779_DL_CHANNEL_REQ( );
        EU433_DL_CHANNEL_REQ( );
        EU868_DL_CHANNEL_REQ( );
 8017804:	683b      	ldr	r3, [r7, #0]
 8017806:	0018      	movs	r0, r3
 8017808:	f001 fea6 	bl	8019558 <RegionEU868DlChannelReq>
 801780c:	0003      	movs	r3, r0
 801780e:	e000      	b.n	8017812 <RegionDlChannelReq+0x24>
        IN865_DL_CHANNEL_REQ( );
        US915_DL_CHANNEL_REQ( );
        RU864_DL_CHANNEL_REQ( );
        default:
        {
            return 0;
 8017810:	2300      	movs	r3, #0
        }
    }
}
 8017812:	0018      	movs	r0, r3
 8017814:	46bd      	mov	sp, r7
 8017816:	b002      	add	sp, #8
 8017818:	bd80      	pop	{r7, pc}

0801781a <RegionAlternateDr>:

int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr, AlternateDrType_t type )
{
 801781a:	b590      	push	{r4, r7, lr}
 801781c:	b083      	sub	sp, #12
 801781e:	af00      	add	r7, sp, #0
 8017820:	0004      	movs	r4, r0
 8017822:	0008      	movs	r0, r1
 8017824:	0011      	movs	r1, r2
 8017826:	1dfb      	adds	r3, r7, #7
 8017828:	1c22      	adds	r2, r4, #0
 801782a:	701a      	strb	r2, [r3, #0]
 801782c:	1dbb      	adds	r3, r7, #6
 801782e:	1c02      	adds	r2, r0, #0
 8017830:	701a      	strb	r2, [r3, #0]
 8017832:	1d7b      	adds	r3, r7, #5
 8017834:	1c0a      	adds	r2, r1, #0
 8017836:	701a      	strb	r2, [r3, #0]
    switch( region )
 8017838:	1dfb      	adds	r3, r7, #7
 801783a:	781b      	ldrb	r3, [r3, #0]
 801783c:	2b05      	cmp	r3, #5
 801783e:	d10a      	bne.n	8017856 <RegionAlternateDr+0x3c>
        AS923_ALTERNATE_DR( );
        AU915_ALTERNATE_DR( );
        CN470_ALTERNATE_DR( );
        CN779_ALTERNATE_DR( );
        EU433_ALTERNATE_DR( );
        EU868_ALTERNATE_DR( );
 8017840:	1d7b      	adds	r3, r7, #5
 8017842:	781a      	ldrb	r2, [r3, #0]
 8017844:	1dbb      	adds	r3, r7, #6
 8017846:	781b      	ldrb	r3, [r3, #0]
 8017848:	b25b      	sxtb	r3, r3
 801784a:	0011      	movs	r1, r2
 801784c:	0018      	movs	r0, r3
 801784e:	f001 fed1 	bl	80195f4 <RegionEU868AlternateDr>
 8017852:	0003      	movs	r3, r0
 8017854:	e000      	b.n	8017858 <RegionAlternateDr+0x3e>
        IN865_ALTERNATE_DR( );
        US915_ALTERNATE_DR( );
        RU864_ALTERNATE_DR( );
        default:
        {
            return 0;
 8017856:	2300      	movs	r3, #0
        }
    }
}
 8017858:	0018      	movs	r0, r3
 801785a:	46bd      	mov	sp, r7
 801785c:	b003      	add	sp, #12
 801785e:	bd90      	pop	{r4, r7, pc}

08017860 <RegionCalcBackOff>:

void RegionCalcBackOff( LoRaMacRegion_t region, CalcBackOffParams_t* calcBackOff )
{
 8017860:	b580      	push	{r7, lr}
 8017862:	b082      	sub	sp, #8
 8017864:	af00      	add	r7, sp, #0
 8017866:	0002      	movs	r2, r0
 8017868:	6039      	str	r1, [r7, #0]
 801786a:	1dfb      	adds	r3, r7, #7
 801786c:	701a      	strb	r2, [r3, #0]
    switch( region )
 801786e:	1dfb      	adds	r3, r7, #7
 8017870:	781b      	ldrb	r3, [r3, #0]
 8017872:	2b05      	cmp	r3, #5
 8017874:	d104      	bne.n	8017880 <RegionCalcBackOff+0x20>
        AS923_CALC_BACKOFF( );
        AU915_CALC_BACKOFF( );
        CN470_CALC_BACKOFF( );
        CN779_CALC_BACKOFF( );
        EU433_CALC_BACKOFF( );
        EU868_CALC_BACKOFF( );
 8017876:	683b      	ldr	r3, [r7, #0]
 8017878:	0018      	movs	r0, r3
 801787a:	f001 fecb 	bl	8019614 <RegionEU868CalcBackOff>
 801787e:	e000      	b.n	8017882 <RegionCalcBackOff+0x22>
        IN865_CALC_BACKOFF( );
        US915_CALC_BACKOFF( );
        RU864_CALC_BACKOFF( );
        default:
        {
            break;
 8017880:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 8017882:	46c0      	nop			; (mov r8, r8)
 8017884:	46bd      	mov	sp, r7
 8017886:	b002      	add	sp, #8
 8017888:	bd80      	pop	{r7, pc}

0801788a <RegionNextChannel>:

LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 801788a:	b580      	push	{r7, lr}
 801788c:	b084      	sub	sp, #16
 801788e:	af00      	add	r7, sp, #0
 8017890:	60b9      	str	r1, [r7, #8]
 8017892:	607a      	str	r2, [r7, #4]
 8017894:	603b      	str	r3, [r7, #0]
 8017896:	210f      	movs	r1, #15
 8017898:	187b      	adds	r3, r7, r1
 801789a:	1c02      	adds	r2, r0, #0
 801789c:	701a      	strb	r2, [r3, #0]
    switch( region )
 801789e:	187b      	adds	r3, r7, r1
 80178a0:	781b      	ldrb	r3, [r3, #0]
 80178a2:	2b05      	cmp	r3, #5
 80178a4:	d107      	bne.n	80178b6 <RegionNextChannel+0x2c>
        AS923_NEXT_CHANNEL( );
        AU915_NEXT_CHANNEL( );
        CN470_NEXT_CHANNEL( );
        CN779_NEXT_CHANNEL( );
        EU433_NEXT_CHANNEL( );
        EU868_NEXT_CHANNEL( );
 80178a6:	69bb      	ldr	r3, [r7, #24]
 80178a8:	683a      	ldr	r2, [r7, #0]
 80178aa:	6879      	ldr	r1, [r7, #4]
 80178ac:	68b8      	ldr	r0, [r7, #8]
 80178ae:	f001 fee1 	bl	8019674 <RegionEU868NextChannel>
 80178b2:	0003      	movs	r3, r0
 80178b4:	e000      	b.n	80178b8 <RegionNextChannel+0x2e>
        IN865_NEXT_CHANNEL( );
        US915_NEXT_CHANNEL( );
        RU864_NEXT_CHANNEL( );
        default:
        {
            return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
 80178b6:	2309      	movs	r3, #9
        }
    }
}
 80178b8:	0018      	movs	r0, r3
 80178ba:	46bd      	mov	sp, r7
 80178bc:	b004      	add	sp, #16
 80178be:	bd80      	pop	{r7, pc}

080178c0 <RegionSetContinuousWave>:
        }
    }
}

void RegionSetContinuousWave( LoRaMacRegion_t region, ContinuousWaveParams_t* continuousWave )
{
 80178c0:	b580      	push	{r7, lr}
 80178c2:	b082      	sub	sp, #8
 80178c4:	af00      	add	r7, sp, #0
 80178c6:	0002      	movs	r2, r0
 80178c8:	6039      	str	r1, [r7, #0]
 80178ca:	1dfb      	adds	r3, r7, #7
 80178cc:	701a      	strb	r2, [r3, #0]
    switch( region )
 80178ce:	1dfb      	adds	r3, r7, #7
 80178d0:	781b      	ldrb	r3, [r3, #0]
 80178d2:	2b05      	cmp	r3, #5
 80178d4:	d104      	bne.n	80178e0 <RegionSetContinuousWave+0x20>
        AS923_SET_CONTINUOUS_WAVE( );
        AU915_SET_CONTINUOUS_WAVE( );
        CN470_SET_CONTINUOUS_WAVE( );
        CN779_SET_CONTINUOUS_WAVE( );
        EU433_SET_CONTINUOUS_WAVE( );
        EU868_SET_CONTINUOUS_WAVE( );
 80178d6:	683b      	ldr	r3, [r7, #0]
 80178d8:	0018      	movs	r0, r3
 80178da:	f002 f867 	bl	80199ac <RegionEU868SetContinuousWave>
 80178de:	e000      	b.n	80178e2 <RegionSetContinuousWave+0x22>
        IN865_SET_CONTINUOUS_WAVE( );
        US915_SET_CONTINUOUS_WAVE( );
        RU864_SET_CONTINUOUS_WAVE( );
        default:
        {
            break;
 80178e0:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 80178e2:	46c0      	nop			; (mov r8, r8)
 80178e4:	46bd      	mov	sp, r7
 80178e6:	b002      	add	sp, #8
 80178e8:	bd80      	pop	{r7, pc}

080178ea <RegionApplyDrOffset>:

uint8_t RegionApplyDrOffset( LoRaMacRegion_t region, uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
 80178ea:	b5b0      	push	{r4, r5, r7, lr}
 80178ec:	b082      	sub	sp, #8
 80178ee:	af00      	add	r7, sp, #0
 80178f0:	0005      	movs	r5, r0
 80178f2:	000c      	movs	r4, r1
 80178f4:	0010      	movs	r0, r2
 80178f6:	0019      	movs	r1, r3
 80178f8:	1dfb      	adds	r3, r7, #7
 80178fa:	1c2a      	adds	r2, r5, #0
 80178fc:	701a      	strb	r2, [r3, #0]
 80178fe:	1dbb      	adds	r3, r7, #6
 8017900:	1c22      	adds	r2, r4, #0
 8017902:	701a      	strb	r2, [r3, #0]
 8017904:	1d7b      	adds	r3, r7, #5
 8017906:	1c02      	adds	r2, r0, #0
 8017908:	701a      	strb	r2, [r3, #0]
 801790a:	1d3b      	adds	r3, r7, #4
 801790c:	1c0a      	adds	r2, r1, #0
 801790e:	701a      	strb	r2, [r3, #0]
    switch( region )
 8017910:	1dfb      	adds	r3, r7, #7
 8017912:	781b      	ldrb	r3, [r3, #0]
 8017914:	2b05      	cmp	r3, #5
 8017916:	d10c      	bne.n	8017932 <RegionApplyDrOffset+0x48>
        AS923_APPLY_DR_OFFSET( );
        AU915_APPLY_DR_OFFSET( );
        CN470_APPLY_DR_OFFSET( );
        CN779_APPLY_DR_OFFSET( );
        EU433_APPLY_DR_OFFSET( );
        EU868_APPLY_DR_OFFSET( );
 8017918:	1d3b      	adds	r3, r7, #4
 801791a:	2200      	movs	r2, #0
 801791c:	569a      	ldrsb	r2, [r3, r2]
 801791e:	1d7b      	adds	r3, r7, #5
 8017920:	2100      	movs	r1, #0
 8017922:	5659      	ldrsb	r1, [r3, r1]
 8017924:	1dbb      	adds	r3, r7, #6
 8017926:	781b      	ldrb	r3, [r3, #0]
 8017928:	0018      	movs	r0, r3
 801792a:	f002 f893 	bl	8019a54 <RegionEU868ApplyDrOffset>
 801792e:	0003      	movs	r3, r0
 8017930:	e001      	b.n	8017936 <RegionApplyDrOffset+0x4c>
        IN865_APPLY_DR_OFFSET( );
        US915_APPLY_DR_OFFSET( );
        RU864_APPLY_DR_OFFSET( );
        default:
        {
            return dr;
 8017932:	1d7b      	adds	r3, r7, #5
 8017934:	781b      	ldrb	r3, [r3, #0]
        }
    }
}
 8017936:	0018      	movs	r0, r3
 8017938:	46bd      	mov	sp, r7
 801793a:	b002      	add	sp, #8
 801793c:	bdb0      	pop	{r4, r5, r7, pc}

0801793e <CountChannels>:
#define BACKOFF_DC_1_HOUR       100
#define BACKOFF_DC_10_HOURS     1000
#define BACKOFF_DC_24_HOURS     10000

static uint8_t CountChannels( uint16_t mask, uint8_t nbBits )
{
 801793e:	b580      	push	{r7, lr}
 8017940:	b084      	sub	sp, #16
 8017942:	af00      	add	r7, sp, #0
 8017944:	0002      	movs	r2, r0
 8017946:	1dbb      	adds	r3, r7, #6
 8017948:	801a      	strh	r2, [r3, #0]
 801794a:	1d7b      	adds	r3, r7, #5
 801794c:	1c0a      	adds	r2, r1, #0
 801794e:	701a      	strb	r2, [r3, #0]
    uint8_t nbActiveBits = 0;
 8017950:	230f      	movs	r3, #15
 8017952:	18fb      	adds	r3, r7, r3
 8017954:	2200      	movs	r2, #0
 8017956:	701a      	strb	r2, [r3, #0]

    for( uint8_t j = 0; j < nbBits; j++ )
 8017958:	230e      	movs	r3, #14
 801795a:	18fb      	adds	r3, r7, r3
 801795c:	2200      	movs	r2, #0
 801795e:	701a      	strb	r2, [r3, #0]
 8017960:	e01b      	b.n	801799a <CountChannels+0x5c>
    {
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 8017962:	1dbb      	adds	r3, r7, #6
 8017964:	881b      	ldrh	r3, [r3, #0]
 8017966:	200e      	movs	r0, #14
 8017968:	183a      	adds	r2, r7, r0
 801796a:	7812      	ldrb	r2, [r2, #0]
 801796c:	2101      	movs	r1, #1
 801796e:	4091      	lsls	r1, r2
 8017970:	000a      	movs	r2, r1
 8017972:	401a      	ands	r2, r3
 8017974:	183b      	adds	r3, r7, r0
 8017976:	781b      	ldrb	r3, [r3, #0]
 8017978:	2101      	movs	r1, #1
 801797a:	4099      	lsls	r1, r3
 801797c:	000b      	movs	r3, r1
 801797e:	429a      	cmp	r2, r3
 8017980:	d105      	bne.n	801798e <CountChannels+0x50>
        {
            nbActiveBits++;
 8017982:	210f      	movs	r1, #15
 8017984:	187b      	adds	r3, r7, r1
 8017986:	781a      	ldrb	r2, [r3, #0]
 8017988:	187b      	adds	r3, r7, r1
 801798a:	3201      	adds	r2, #1
 801798c:	701a      	strb	r2, [r3, #0]
    for( uint8_t j = 0; j < nbBits; j++ )
 801798e:	210e      	movs	r1, #14
 8017990:	187b      	adds	r3, r7, r1
 8017992:	781a      	ldrb	r2, [r3, #0]
 8017994:	187b      	adds	r3, r7, r1
 8017996:	3201      	adds	r2, #1
 8017998:	701a      	strb	r2, [r3, #0]
 801799a:	230e      	movs	r3, #14
 801799c:	18fa      	adds	r2, r7, r3
 801799e:	1d7b      	adds	r3, r7, #5
 80179a0:	7812      	ldrb	r2, [r2, #0]
 80179a2:	781b      	ldrb	r3, [r3, #0]
 80179a4:	429a      	cmp	r2, r3
 80179a6:	d3dc      	bcc.n	8017962 <CountChannels+0x24>
        }
    }
    return nbActiveBits;
 80179a8:	230f      	movs	r3, #15
 80179aa:	18fb      	adds	r3, r7, r3
 80179ac:	781b      	ldrb	r3, [r3, #0]
}
 80179ae:	0018      	movs	r0, r3
 80179b0:	46bd      	mov	sp, r7
 80179b2:	b004      	add	sp, #16
 80179b4:	bd80      	pop	{r7, pc}
	...

080179b8 <RegionCommonGetJoinDc>:

uint16_t RegionCommonGetJoinDc( TimerTime_t elapsedTime )
{
 80179b8:	b580      	push	{r7, lr}
 80179ba:	b084      	sub	sp, #16
 80179bc:	af00      	add	r7, sp, #0
 80179be:	6078      	str	r0, [r7, #4]
    uint16_t dutyCycle = 0;
 80179c0:	210e      	movs	r1, #14
 80179c2:	187b      	adds	r3, r7, r1
 80179c4:	2200      	movs	r2, #0
 80179c6:	801a      	strh	r2, [r3, #0]

    if( elapsedTime < 3600000 )
 80179c8:	687b      	ldr	r3, [r7, #4]
 80179ca:	4a0e      	ldr	r2, [pc, #56]	; (8017a04 <RegionCommonGetJoinDc+0x4c>)
 80179cc:	4293      	cmp	r3, r2
 80179ce:	d803      	bhi.n	80179d8 <RegionCommonGetJoinDc+0x20>
    {
        dutyCycle = BACKOFF_DC_1_HOUR;
 80179d0:	187b      	adds	r3, r7, r1
 80179d2:	2264      	movs	r2, #100	; 0x64
 80179d4:	801a      	strh	r2, [r3, #0]
 80179d6:	e00d      	b.n	80179f4 <RegionCommonGetJoinDc+0x3c>
    }
    else if( elapsedTime < ( 3600000 + 36000000 ) )
 80179d8:	687b      	ldr	r3, [r7, #4]
 80179da:	4a0b      	ldr	r2, [pc, #44]	; (8017a08 <RegionCommonGetJoinDc+0x50>)
 80179dc:	4293      	cmp	r3, r2
 80179de:	d805      	bhi.n	80179ec <RegionCommonGetJoinDc+0x34>
    {
        dutyCycle = BACKOFF_DC_10_HOURS;
 80179e0:	230e      	movs	r3, #14
 80179e2:	18fb      	adds	r3, r7, r3
 80179e4:	22fa      	movs	r2, #250	; 0xfa
 80179e6:	0092      	lsls	r2, r2, #2
 80179e8:	801a      	strh	r2, [r3, #0]
 80179ea:	e003      	b.n	80179f4 <RegionCommonGetJoinDc+0x3c>
    }
    else
    {
        dutyCycle = BACKOFF_DC_24_HOURS;
 80179ec:	230e      	movs	r3, #14
 80179ee:	18fb      	adds	r3, r7, r3
 80179f0:	4a06      	ldr	r2, [pc, #24]	; (8017a0c <RegionCommonGetJoinDc+0x54>)
 80179f2:	801a      	strh	r2, [r3, #0]
    }
    return dutyCycle;
 80179f4:	230e      	movs	r3, #14
 80179f6:	18fb      	adds	r3, r7, r3
 80179f8:	881b      	ldrh	r3, [r3, #0]
}
 80179fa:	0018      	movs	r0, r3
 80179fc:	46bd      	mov	sp, r7
 80179fe:	b004      	add	sp, #16
 8017a00:	bd80      	pop	{r7, pc}
 8017a02:	46c0      	nop			; (mov r8, r8)
 8017a04:	0036ee7f 	.word	0x0036ee7f
 8017a08:	025c3f7f 	.word	0x025c3f7f
 8017a0c:	00002710 	.word	0x00002710

08017a10 <RegionCommonChanVerifyDr>:

bool RegionCommonChanVerifyDr( uint8_t nbChannels, uint16_t* channelsMask, int8_t dr, int8_t minDr, int8_t maxDr, ChannelParams_t* channels )
{
 8017a10:	b590      	push	{r4, r7, lr}
 8017a12:	b085      	sub	sp, #20
 8017a14:	af00      	add	r7, sp, #0
 8017a16:	0004      	movs	r4, r0
 8017a18:	6039      	str	r1, [r7, #0]
 8017a1a:	0010      	movs	r0, r2
 8017a1c:	0019      	movs	r1, r3
 8017a1e:	1dfb      	adds	r3, r7, #7
 8017a20:	1c22      	adds	r2, r4, #0
 8017a22:	701a      	strb	r2, [r3, #0]
 8017a24:	1dbb      	adds	r3, r7, #6
 8017a26:	1c02      	adds	r2, r0, #0
 8017a28:	701a      	strb	r2, [r3, #0]
 8017a2a:	1d7b      	adds	r3, r7, #5
 8017a2c:	1c0a      	adds	r2, r1, #0
 8017a2e:	701a      	strb	r2, [r3, #0]
    if( RegionCommonValueInRange( dr, minDr, maxDr ) == 0 )
 8017a30:	2320      	movs	r3, #32
 8017a32:	18fb      	adds	r3, r7, r3
 8017a34:	2200      	movs	r2, #0
 8017a36:	569a      	ldrsb	r2, [r3, r2]
 8017a38:	1d7b      	adds	r3, r7, #5
 8017a3a:	2100      	movs	r1, #0
 8017a3c:	5659      	ldrsb	r1, [r3, r1]
 8017a3e:	1dbb      	adds	r3, r7, #6
 8017a40:	781b      	ldrb	r3, [r3, #0]
 8017a42:	b25b      	sxtb	r3, r3
 8017a44:	0018      	movs	r0, r3
 8017a46:	f000 f87c 	bl	8017b42 <RegionCommonValueInRange>
 8017a4a:	1e03      	subs	r3, r0, #0
 8017a4c:	d101      	bne.n	8017a52 <RegionCommonChanVerifyDr+0x42>
    {
        return false;
 8017a4e:	2300      	movs	r3, #0
 8017a50:	e073      	b.n	8017b3a <RegionCommonChanVerifyDr+0x12a>
    }

    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 8017a52:	230f      	movs	r3, #15
 8017a54:	18fb      	adds	r3, r7, r3
 8017a56:	2200      	movs	r2, #0
 8017a58:	701a      	strb	r2, [r3, #0]
 8017a5a:	230e      	movs	r3, #14
 8017a5c:	18fb      	adds	r3, r7, r3
 8017a5e:	2200      	movs	r2, #0
 8017a60:	701a      	strb	r2, [r3, #0]
 8017a62:	e062      	b.n	8017b2a <RegionCommonChanVerifyDr+0x11a>
    {
        for( uint8_t j = 0; j < 16; j++ )
 8017a64:	230d      	movs	r3, #13
 8017a66:	18fb      	adds	r3, r7, r3
 8017a68:	2200      	movs	r2, #0
 8017a6a:	701a      	strb	r2, [r3, #0]
 8017a6c:	e04c      	b.n	8017b08 <RegionCommonChanVerifyDr+0xf8>
        {
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 8017a6e:	230e      	movs	r3, #14
 8017a70:	18fb      	adds	r3, r7, r3
 8017a72:	781b      	ldrb	r3, [r3, #0]
 8017a74:	005b      	lsls	r3, r3, #1
 8017a76:	683a      	ldr	r2, [r7, #0]
 8017a78:	18d3      	adds	r3, r2, r3
 8017a7a:	881b      	ldrh	r3, [r3, #0]
 8017a7c:	001a      	movs	r2, r3
 8017a7e:	200d      	movs	r0, #13
 8017a80:	183b      	adds	r3, r7, r0
 8017a82:	781b      	ldrb	r3, [r3, #0]
 8017a84:	411a      	asrs	r2, r3
 8017a86:	0013      	movs	r3, r2
 8017a88:	2201      	movs	r2, #1
 8017a8a:	4013      	ands	r3, r2
 8017a8c:	d036      	beq.n	8017afc <RegionCommonChanVerifyDr+0xec>
            {// Check datarate validity for enabled channels
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 8017a8e:	240f      	movs	r4, #15
 8017a90:	193b      	adds	r3, r7, r4
 8017a92:	781a      	ldrb	r2, [r3, #0]
 8017a94:	183b      	adds	r3, r7, r0
 8017a96:	781b      	ldrb	r3, [r3, #0]
 8017a98:	18d3      	adds	r3, r2, r3
 8017a9a:	001a      	movs	r2, r3
 8017a9c:	0013      	movs	r3, r2
 8017a9e:	005b      	lsls	r3, r3, #1
 8017aa0:	189b      	adds	r3, r3, r2
 8017aa2:	009b      	lsls	r3, r3, #2
 8017aa4:	001a      	movs	r2, r3
 8017aa6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017aa8:	189b      	adds	r3, r3, r2
 8017aaa:	7a1b      	ldrb	r3, [r3, #8]
 8017aac:	011b      	lsls	r3, r3, #4
 8017aae:	b25b      	sxtb	r3, r3
 8017ab0:	111b      	asrs	r3, r3, #4
 8017ab2:	b25b      	sxtb	r3, r3
 8017ab4:	001a      	movs	r2, r3
 8017ab6:	230f      	movs	r3, #15
 8017ab8:	4013      	ands	r3, r2
 8017aba:	b259      	sxtb	r1, r3
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 8017abc:	193b      	adds	r3, r7, r4
 8017abe:	781a      	ldrb	r2, [r3, #0]
 8017ac0:	183b      	adds	r3, r7, r0
 8017ac2:	781b      	ldrb	r3, [r3, #0]
 8017ac4:	18d3      	adds	r3, r2, r3
 8017ac6:	001a      	movs	r2, r3
 8017ac8:	0013      	movs	r3, r2
 8017aca:	005b      	lsls	r3, r3, #1
 8017acc:	189b      	adds	r3, r3, r2
 8017ace:	009b      	lsls	r3, r3, #2
 8017ad0:	001a      	movs	r2, r3
 8017ad2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017ad4:	189b      	adds	r3, r3, r2
 8017ad6:	7a1b      	ldrb	r3, [r3, #8]
 8017ad8:	b25b      	sxtb	r3, r3
 8017ada:	111b      	asrs	r3, r3, #4
 8017adc:	b25b      	sxtb	r3, r3
 8017ade:	001a      	movs	r2, r3
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 8017ae0:	230f      	movs	r3, #15
 8017ae2:	4013      	ands	r3, r2
 8017ae4:	b25a      	sxtb	r2, r3
 8017ae6:	1dbb      	adds	r3, r7, #6
 8017ae8:	781b      	ldrb	r3, [r3, #0]
 8017aea:	b25b      	sxtb	r3, r3
 8017aec:	0018      	movs	r0, r3
 8017aee:	f000 f828 	bl	8017b42 <RegionCommonValueInRange>
 8017af2:	0003      	movs	r3, r0
 8017af4:	2b01      	cmp	r3, #1
 8017af6:	d101      	bne.n	8017afc <RegionCommonChanVerifyDr+0xec>
                {
                    // At least 1 channel has been found we can return OK.
                    return true;
 8017af8:	2301      	movs	r3, #1
 8017afa:	e01e      	b.n	8017b3a <RegionCommonChanVerifyDr+0x12a>
        for( uint8_t j = 0; j < 16; j++ )
 8017afc:	210d      	movs	r1, #13
 8017afe:	187b      	adds	r3, r7, r1
 8017b00:	781a      	ldrb	r2, [r3, #0]
 8017b02:	187b      	adds	r3, r7, r1
 8017b04:	3201      	adds	r2, #1
 8017b06:	701a      	strb	r2, [r3, #0]
 8017b08:	230d      	movs	r3, #13
 8017b0a:	18fb      	adds	r3, r7, r3
 8017b0c:	781b      	ldrb	r3, [r3, #0]
 8017b0e:	2b0f      	cmp	r3, #15
 8017b10:	d9ad      	bls.n	8017a6e <RegionCommonChanVerifyDr+0x5e>
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 8017b12:	220f      	movs	r2, #15
 8017b14:	18bb      	adds	r3, r7, r2
 8017b16:	18ba      	adds	r2, r7, r2
 8017b18:	7812      	ldrb	r2, [r2, #0]
 8017b1a:	3210      	adds	r2, #16
 8017b1c:	701a      	strb	r2, [r3, #0]
 8017b1e:	210e      	movs	r1, #14
 8017b20:	187b      	adds	r3, r7, r1
 8017b22:	781a      	ldrb	r2, [r3, #0]
 8017b24:	187b      	adds	r3, r7, r1
 8017b26:	3201      	adds	r2, #1
 8017b28:	701a      	strb	r2, [r3, #0]
 8017b2a:	230f      	movs	r3, #15
 8017b2c:	18fa      	adds	r2, r7, r3
 8017b2e:	1dfb      	adds	r3, r7, #7
 8017b30:	7812      	ldrb	r2, [r2, #0]
 8017b32:	781b      	ldrb	r3, [r3, #0]
 8017b34:	429a      	cmp	r2, r3
 8017b36:	d395      	bcc.n	8017a64 <RegionCommonChanVerifyDr+0x54>
                }
            }
        }
    }
    return false;
 8017b38:	2300      	movs	r3, #0
}
 8017b3a:	0018      	movs	r0, r3
 8017b3c:	46bd      	mov	sp, r7
 8017b3e:	b005      	add	sp, #20
 8017b40:	bd90      	pop	{r4, r7, pc}

08017b42 <RegionCommonValueInRange>:

uint8_t RegionCommonValueInRange( int8_t value, int8_t min, int8_t max )
{
 8017b42:	b590      	push	{r4, r7, lr}
 8017b44:	b083      	sub	sp, #12
 8017b46:	af00      	add	r7, sp, #0
 8017b48:	0004      	movs	r4, r0
 8017b4a:	0008      	movs	r0, r1
 8017b4c:	0011      	movs	r1, r2
 8017b4e:	1dfb      	adds	r3, r7, #7
 8017b50:	1c22      	adds	r2, r4, #0
 8017b52:	701a      	strb	r2, [r3, #0]
 8017b54:	1dbb      	adds	r3, r7, #6
 8017b56:	1c02      	adds	r2, r0, #0
 8017b58:	701a      	strb	r2, [r3, #0]
 8017b5a:	1d7b      	adds	r3, r7, #5
 8017b5c:	1c0a      	adds	r2, r1, #0
 8017b5e:	701a      	strb	r2, [r3, #0]
    if( ( value >= min ) && ( value <= max ) )
 8017b60:	1dfa      	adds	r2, r7, #7
 8017b62:	1dbb      	adds	r3, r7, #6
 8017b64:	7812      	ldrb	r2, [r2, #0]
 8017b66:	b252      	sxtb	r2, r2
 8017b68:	781b      	ldrb	r3, [r3, #0]
 8017b6a:	b25b      	sxtb	r3, r3
 8017b6c:	429a      	cmp	r2, r3
 8017b6e:	db09      	blt.n	8017b84 <RegionCommonValueInRange+0x42>
 8017b70:	1dfa      	adds	r2, r7, #7
 8017b72:	1d7b      	adds	r3, r7, #5
 8017b74:	7812      	ldrb	r2, [r2, #0]
 8017b76:	b252      	sxtb	r2, r2
 8017b78:	781b      	ldrb	r3, [r3, #0]
 8017b7a:	b25b      	sxtb	r3, r3
 8017b7c:	429a      	cmp	r2, r3
 8017b7e:	dc01      	bgt.n	8017b84 <RegionCommonValueInRange+0x42>
    {
        return 1;
 8017b80:	2301      	movs	r3, #1
 8017b82:	e000      	b.n	8017b86 <RegionCommonValueInRange+0x44>
    }
    return 0;
 8017b84:	2300      	movs	r3, #0
}
 8017b86:	0018      	movs	r0, r3
 8017b88:	46bd      	mov	sp, r7
 8017b8a:	b003      	add	sp, #12
 8017b8c:	bd90      	pop	{r4, r7, pc}

08017b8e <RegionCommonChanDisable>:

bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxChannels )
{
 8017b8e:	b580      	push	{r7, lr}
 8017b90:	b084      	sub	sp, #16
 8017b92:	af00      	add	r7, sp, #0
 8017b94:	6078      	str	r0, [r7, #4]
 8017b96:	0008      	movs	r0, r1
 8017b98:	0011      	movs	r1, r2
 8017b9a:	1cfb      	adds	r3, r7, #3
 8017b9c:	1c02      	adds	r2, r0, #0
 8017b9e:	701a      	strb	r2, [r3, #0]
 8017ba0:	1cbb      	adds	r3, r7, #2
 8017ba2:	1c0a      	adds	r2, r1, #0
 8017ba4:	701a      	strb	r2, [r3, #0]
    uint8_t index = id / 16;
 8017ba6:	210f      	movs	r1, #15
 8017ba8:	187b      	adds	r3, r7, r1
 8017baa:	1cfa      	adds	r2, r7, #3
 8017bac:	7812      	ldrb	r2, [r2, #0]
 8017bae:	0912      	lsrs	r2, r2, #4
 8017bb0:	701a      	strb	r2, [r3, #0]

    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 8017bb2:	1cbb      	adds	r3, r7, #2
 8017bb4:	781b      	ldrb	r3, [r3, #0]
 8017bb6:	091b      	lsrs	r3, r3, #4
 8017bb8:	b2db      	uxtb	r3, r3
 8017bba:	187a      	adds	r2, r7, r1
 8017bbc:	7812      	ldrb	r2, [r2, #0]
 8017bbe:	429a      	cmp	r2, r3
 8017bc0:	d805      	bhi.n	8017bce <RegionCommonChanDisable+0x40>
 8017bc2:	1cfa      	adds	r2, r7, #3
 8017bc4:	1cbb      	adds	r3, r7, #2
 8017bc6:	7812      	ldrb	r2, [r2, #0]
 8017bc8:	781b      	ldrb	r3, [r3, #0]
 8017bca:	429a      	cmp	r2, r3
 8017bcc:	d301      	bcc.n	8017bd2 <RegionCommonChanDisable+0x44>
    {
        return false;
 8017bce:	2300      	movs	r3, #0
 8017bd0:	e01b      	b.n	8017c0a <RegionCommonChanDisable+0x7c>
    }

    // Deactivate channel
    channelsMask[index] &= ~( 1 << ( id % 16 ) );
 8017bd2:	200f      	movs	r0, #15
 8017bd4:	183b      	adds	r3, r7, r0
 8017bd6:	781b      	ldrb	r3, [r3, #0]
 8017bd8:	005b      	lsls	r3, r3, #1
 8017bda:	687a      	ldr	r2, [r7, #4]
 8017bdc:	18d3      	adds	r3, r2, r3
 8017bde:	881b      	ldrh	r3, [r3, #0]
 8017be0:	b21b      	sxth	r3, r3
 8017be2:	1cfa      	adds	r2, r7, #3
 8017be4:	7812      	ldrb	r2, [r2, #0]
 8017be6:	210f      	movs	r1, #15
 8017be8:	400a      	ands	r2, r1
 8017bea:	2101      	movs	r1, #1
 8017bec:	4091      	lsls	r1, r2
 8017bee:	000a      	movs	r2, r1
 8017bf0:	b212      	sxth	r2, r2
 8017bf2:	43d2      	mvns	r2, r2
 8017bf4:	b212      	sxth	r2, r2
 8017bf6:	4013      	ands	r3, r2
 8017bf8:	b219      	sxth	r1, r3
 8017bfa:	183b      	adds	r3, r7, r0
 8017bfc:	781b      	ldrb	r3, [r3, #0]
 8017bfe:	005b      	lsls	r3, r3, #1
 8017c00:	687a      	ldr	r2, [r7, #4]
 8017c02:	18d3      	adds	r3, r2, r3
 8017c04:	b28a      	uxth	r2, r1
 8017c06:	801a      	strh	r2, [r3, #0]

    return true;
 8017c08:	2301      	movs	r3, #1
}
 8017c0a:	0018      	movs	r0, r3
 8017c0c:	46bd      	mov	sp, r7
 8017c0e:	b004      	add	sp, #16
 8017c10:	bd80      	pop	{r7, pc}

08017c12 <RegionCommonCountChannels>:

uint8_t RegionCommonCountChannels( uint16_t* channelsMask, uint8_t startIdx, uint8_t stopIdx )
{
 8017c12:	b590      	push	{r4, r7, lr}
 8017c14:	b085      	sub	sp, #20
 8017c16:	af00      	add	r7, sp, #0
 8017c18:	6078      	str	r0, [r7, #4]
 8017c1a:	0008      	movs	r0, r1
 8017c1c:	0011      	movs	r1, r2
 8017c1e:	1cfb      	adds	r3, r7, #3
 8017c20:	1c02      	adds	r2, r0, #0
 8017c22:	701a      	strb	r2, [r3, #0]
 8017c24:	1cbb      	adds	r3, r7, #2
 8017c26:	1c0a      	adds	r2, r1, #0
 8017c28:	701a      	strb	r2, [r3, #0]
    uint8_t nbChannels = 0;
 8017c2a:	230f      	movs	r3, #15
 8017c2c:	18fb      	adds	r3, r7, r3
 8017c2e:	2200      	movs	r2, #0
 8017c30:	701a      	strb	r2, [r3, #0]

    if( channelsMask == NULL )
 8017c32:	687b      	ldr	r3, [r7, #4]
 8017c34:	2b00      	cmp	r3, #0
 8017c36:	d101      	bne.n	8017c3c <RegionCommonCountChannels+0x2a>
    {
        return 0;
 8017c38:	2300      	movs	r3, #0
 8017c3a:	e027      	b.n	8017c8c <RegionCommonCountChannels+0x7a>
    }

    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8017c3c:	230e      	movs	r3, #14
 8017c3e:	18fb      	adds	r3, r7, r3
 8017c40:	1cfa      	adds	r2, r7, #3
 8017c42:	7812      	ldrb	r2, [r2, #0]
 8017c44:	701a      	strb	r2, [r3, #0]
 8017c46:	e017      	b.n	8017c78 <RegionCommonCountChannels+0x66>
    {
        nbChannels += CountChannels( channelsMask[i], 16 );
 8017c48:	240e      	movs	r4, #14
 8017c4a:	193b      	adds	r3, r7, r4
 8017c4c:	781b      	ldrb	r3, [r3, #0]
 8017c4e:	005b      	lsls	r3, r3, #1
 8017c50:	687a      	ldr	r2, [r7, #4]
 8017c52:	18d3      	adds	r3, r2, r3
 8017c54:	881b      	ldrh	r3, [r3, #0]
 8017c56:	2110      	movs	r1, #16
 8017c58:	0018      	movs	r0, r3
 8017c5a:	f7ff fe70 	bl	801793e <CountChannels>
 8017c5e:	0003      	movs	r3, r0
 8017c60:	0019      	movs	r1, r3
 8017c62:	220f      	movs	r2, #15
 8017c64:	18bb      	adds	r3, r7, r2
 8017c66:	18ba      	adds	r2, r7, r2
 8017c68:	7812      	ldrb	r2, [r2, #0]
 8017c6a:	188a      	adds	r2, r1, r2
 8017c6c:	701a      	strb	r2, [r3, #0]
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 8017c6e:	193b      	adds	r3, r7, r4
 8017c70:	781a      	ldrb	r2, [r3, #0]
 8017c72:	193b      	adds	r3, r7, r4
 8017c74:	3201      	adds	r2, #1
 8017c76:	701a      	strb	r2, [r3, #0]
 8017c78:	230e      	movs	r3, #14
 8017c7a:	18fa      	adds	r2, r7, r3
 8017c7c:	1cbb      	adds	r3, r7, #2
 8017c7e:	7812      	ldrb	r2, [r2, #0]
 8017c80:	781b      	ldrb	r3, [r3, #0]
 8017c82:	429a      	cmp	r2, r3
 8017c84:	d3e0      	bcc.n	8017c48 <RegionCommonCountChannels+0x36>
    }

    return nbChannels;
 8017c86:	230f      	movs	r3, #15
 8017c88:	18fb      	adds	r3, r7, r3
 8017c8a:	781b      	ldrb	r3, [r3, #0]
}
 8017c8c:	0018      	movs	r0, r3
 8017c8e:	46bd      	mov	sp, r7
 8017c90:	b005      	add	sp, #20
 8017c92:	bd90      	pop	{r4, r7, pc}

08017c94 <RegionCommonChanMaskCopy>:

void RegionCommonChanMaskCopy( uint16_t* channelsMaskDest, uint16_t* channelsMaskSrc, uint8_t len )
{
 8017c94:	b580      	push	{r7, lr}
 8017c96:	b086      	sub	sp, #24
 8017c98:	af00      	add	r7, sp, #0
 8017c9a:	60f8      	str	r0, [r7, #12]
 8017c9c:	60b9      	str	r1, [r7, #8]
 8017c9e:	1dfb      	adds	r3, r7, #7
 8017ca0:	701a      	strb	r2, [r3, #0]
    if( ( channelsMaskDest != NULL ) && ( channelsMaskSrc != NULL ) )
 8017ca2:	68fb      	ldr	r3, [r7, #12]
 8017ca4:	2b00      	cmp	r3, #0
 8017ca6:	d020      	beq.n	8017cea <RegionCommonChanMaskCopy+0x56>
 8017ca8:	68bb      	ldr	r3, [r7, #8]
 8017caa:	2b00      	cmp	r3, #0
 8017cac:	d01d      	beq.n	8017cea <RegionCommonChanMaskCopy+0x56>
    {
        for( uint8_t i = 0; i < len; i++ )
 8017cae:	2317      	movs	r3, #23
 8017cb0:	18fb      	adds	r3, r7, r3
 8017cb2:	2200      	movs	r2, #0
 8017cb4:	701a      	strb	r2, [r3, #0]
 8017cb6:	e011      	b.n	8017cdc <RegionCommonChanMaskCopy+0x48>
        {
            channelsMaskDest[i] = channelsMaskSrc[i];
 8017cb8:	2017      	movs	r0, #23
 8017cba:	183b      	adds	r3, r7, r0
 8017cbc:	781b      	ldrb	r3, [r3, #0]
 8017cbe:	005b      	lsls	r3, r3, #1
 8017cc0:	68ba      	ldr	r2, [r7, #8]
 8017cc2:	18d2      	adds	r2, r2, r3
 8017cc4:	183b      	adds	r3, r7, r0
 8017cc6:	781b      	ldrb	r3, [r3, #0]
 8017cc8:	005b      	lsls	r3, r3, #1
 8017cca:	68f9      	ldr	r1, [r7, #12]
 8017ccc:	18cb      	adds	r3, r1, r3
 8017cce:	8812      	ldrh	r2, [r2, #0]
 8017cd0:	801a      	strh	r2, [r3, #0]
        for( uint8_t i = 0; i < len; i++ )
 8017cd2:	183b      	adds	r3, r7, r0
 8017cd4:	781a      	ldrb	r2, [r3, #0]
 8017cd6:	183b      	adds	r3, r7, r0
 8017cd8:	3201      	adds	r2, #1
 8017cda:	701a      	strb	r2, [r3, #0]
 8017cdc:	2317      	movs	r3, #23
 8017cde:	18fa      	adds	r2, r7, r3
 8017ce0:	1dfb      	adds	r3, r7, #7
 8017ce2:	7812      	ldrb	r2, [r2, #0]
 8017ce4:	781b      	ldrb	r3, [r3, #0]
 8017ce6:	429a      	cmp	r2, r3
 8017ce8:	d3e6      	bcc.n	8017cb8 <RegionCommonChanMaskCopy+0x24>
        }
    }
}
 8017cea:	46c0      	nop			; (mov r8, r8)
 8017cec:	46bd      	mov	sp, r7
 8017cee:	b006      	add	sp, #24
 8017cf0:	bd80      	pop	{r7, pc}

08017cf2 <RegionCommonSetBandTxDone>:

void RegionCommonSetBandTxDone( bool joined, Band_t* band, TimerTime_t lastTxDone )
{
 8017cf2:	b580      	push	{r7, lr}
 8017cf4:	b084      	sub	sp, #16
 8017cf6:	af00      	add	r7, sp, #0
 8017cf8:	60b9      	str	r1, [r7, #8]
 8017cfa:	607a      	str	r2, [r7, #4]
 8017cfc:	210f      	movs	r1, #15
 8017cfe:	187b      	adds	r3, r7, r1
 8017d00:	1c02      	adds	r2, r0, #0
 8017d02:	701a      	strb	r2, [r3, #0]
    if( joined == true )
 8017d04:	187b      	adds	r3, r7, r1
 8017d06:	781b      	ldrb	r3, [r3, #0]
 8017d08:	2b00      	cmp	r3, #0
 8017d0a:	d003      	beq.n	8017d14 <RegionCommonSetBandTxDone+0x22>
    {
        band->LastTxDoneTime = lastTxDone;
 8017d0c:	68bb      	ldr	r3, [r7, #8]
 8017d0e:	687a      	ldr	r2, [r7, #4]
 8017d10:	609a      	str	r2, [r3, #8]
    else
    {
        band->LastTxDoneTime = lastTxDone;
        band->LastJoinTxDoneTime = lastTxDone;
    }
}
 8017d12:	e005      	b.n	8017d20 <RegionCommonSetBandTxDone+0x2e>
        band->LastTxDoneTime = lastTxDone;
 8017d14:	68bb      	ldr	r3, [r7, #8]
 8017d16:	687a      	ldr	r2, [r7, #4]
 8017d18:	609a      	str	r2, [r3, #8]
        band->LastJoinTxDoneTime = lastTxDone;
 8017d1a:	68bb      	ldr	r3, [r7, #8]
 8017d1c:	687a      	ldr	r2, [r7, #4]
 8017d1e:	605a      	str	r2, [r3, #4]
}
 8017d20:	46c0      	nop			; (mov r8, r8)
 8017d22:	46bd      	mov	sp, r7
 8017d24:	b004      	add	sp, #16
 8017d26:	bd80      	pop	{r7, pc}

08017d28 <RegionCommonUpdateBandTimeOff>:

TimerTime_t RegionCommonUpdateBandTimeOff( bool joined, bool dutyCycle, Band_t* bands, uint8_t nbBands )
{
 8017d28:	b590      	push	{r4, r7, lr}
 8017d2a:	b089      	sub	sp, #36	; 0x24
 8017d2c:	af00      	add	r7, sp, #0
 8017d2e:	0004      	movs	r4, r0
 8017d30:	0008      	movs	r0, r1
 8017d32:	603a      	str	r2, [r7, #0]
 8017d34:	0019      	movs	r1, r3
 8017d36:	1dfb      	adds	r3, r7, #7
 8017d38:	1c22      	adds	r2, r4, #0
 8017d3a:	701a      	strb	r2, [r3, #0]
 8017d3c:	1dbb      	adds	r3, r7, #6
 8017d3e:	1c02      	adds	r2, r0, #0
 8017d40:	701a      	strb	r2, [r3, #0]
 8017d42:	1d7b      	adds	r3, r7, #5
 8017d44:	1c0a      	adds	r2, r1, #0
 8017d46:	701a      	strb	r2, [r3, #0]
    TimerTime_t nextTxDelay = TIMERTIME_T_MAX;
 8017d48:	2301      	movs	r3, #1
 8017d4a:	425b      	negs	r3, r3
 8017d4c:	61fb      	str	r3, [r7, #28]

    // Update bands Time OFF
    for( uint8_t i = 0; i < nbBands; i++ )
 8017d4e:	231b      	movs	r3, #27
 8017d50:	18fb      	adds	r3, r7, r3
 8017d52:	2200      	movs	r2, #0
 8017d54:	701a      	strb	r2, [r3, #0]
 8017d56:	e098      	b.n	8017e8a <RegionCommonUpdateBandTimeOff+0x162>
    {
        if( joined == false )
 8017d58:	1dfb      	adds	r3, r7, #7
 8017d5a:	781b      	ldrb	r3, [r3, #0]
 8017d5c:	2201      	movs	r2, #1
 8017d5e:	4053      	eors	r3, r2
 8017d60:	b2db      	uxtb	r3, r3
 8017d62:	2b00      	cmp	r3, #0
 8017d64:	d04a      	beq.n	8017dfc <RegionCommonUpdateBandTimeOff+0xd4>
        {
            TimerTime_t elapsedJoin = TimerGetElapsedTime( bands[i].LastJoinTxDoneTime );
 8017d66:	241b      	movs	r4, #27
 8017d68:	193b      	adds	r3, r7, r4
 8017d6a:	781b      	ldrb	r3, [r3, #0]
 8017d6c:	011b      	lsls	r3, r3, #4
 8017d6e:	683a      	ldr	r2, [r7, #0]
 8017d70:	18d3      	adds	r3, r2, r3
 8017d72:	685b      	ldr	r3, [r3, #4]
 8017d74:	0018      	movs	r0, r3
 8017d76:	f003 fa14 	bl	801b1a2 <TimerGetElapsedTime>
 8017d7a:	0003      	movs	r3, r0
 8017d7c:	613b      	str	r3, [r7, #16]
            TimerTime_t elapsedTx = TimerGetElapsedTime( bands[i].LastTxDoneTime );
 8017d7e:	193b      	adds	r3, r7, r4
 8017d80:	781b      	ldrb	r3, [r3, #0]
 8017d82:	011b      	lsls	r3, r3, #4
 8017d84:	683a      	ldr	r2, [r7, #0]
 8017d86:	18d3      	adds	r3, r2, r3
 8017d88:	689b      	ldr	r3, [r3, #8]
 8017d8a:	0018      	movs	r0, r3
 8017d8c:	f003 fa09 	bl	801b1a2 <TimerGetElapsedTime>
 8017d90:	0003      	movs	r3, r0
 8017d92:	60fb      	str	r3, [r7, #12]
            TimerTime_t txDoneTime =  MAX( elapsedJoin,
 8017d94:	1dbb      	adds	r3, r7, #6
 8017d96:	781b      	ldrb	r3, [r3, #0]
 8017d98:	2b00      	cmp	r3, #0
 8017d9a:	d001      	beq.n	8017da0 <RegionCommonUpdateBandTimeOff+0x78>
 8017d9c:	68fb      	ldr	r3, [r7, #12]
 8017d9e:	e000      	b.n	8017da2 <RegionCommonUpdateBandTimeOff+0x7a>
 8017da0:	2300      	movs	r3, #0
 8017da2:	693a      	ldr	r2, [r7, #16]
 8017da4:	4293      	cmp	r3, r2
 8017da6:	d200      	bcs.n	8017daa <RegionCommonUpdateBandTimeOff+0x82>
 8017da8:	0013      	movs	r3, r2
 8017daa:	60bb      	str	r3, [r7, #8]
                                        ( dutyCycle == true ) ? elapsedTx : 0 );

            if( bands[i].TimeOff <= txDoneTime )
 8017dac:	211b      	movs	r1, #27
 8017dae:	187b      	adds	r3, r7, r1
 8017db0:	781b      	ldrb	r3, [r3, #0]
 8017db2:	011b      	lsls	r3, r3, #4
 8017db4:	683a      	ldr	r2, [r7, #0]
 8017db6:	18d3      	adds	r3, r2, r3
 8017db8:	68db      	ldr	r3, [r3, #12]
 8017dba:	68ba      	ldr	r2, [r7, #8]
 8017dbc:	429a      	cmp	r2, r3
 8017dbe:	d306      	bcc.n	8017dce <RegionCommonUpdateBandTimeOff+0xa6>
            {
                bands[i].TimeOff = 0;
 8017dc0:	187b      	adds	r3, r7, r1
 8017dc2:	781b      	ldrb	r3, [r3, #0]
 8017dc4:	011b      	lsls	r3, r3, #4
 8017dc6:	683a      	ldr	r2, [r7, #0]
 8017dc8:	18d3      	adds	r3, r2, r3
 8017dca:	2200      	movs	r2, #0
 8017dcc:	60da      	str	r2, [r3, #12]
            }
            if( bands[i].TimeOff != 0 )
 8017dce:	211b      	movs	r1, #27
 8017dd0:	187b      	adds	r3, r7, r1
 8017dd2:	781b      	ldrb	r3, [r3, #0]
 8017dd4:	011b      	lsls	r3, r3, #4
 8017dd6:	683a      	ldr	r2, [r7, #0]
 8017dd8:	18d3      	adds	r3, r2, r3
 8017dda:	68db      	ldr	r3, [r3, #12]
 8017ddc:	2b00      	cmp	r3, #0
 8017dde:	d04e      	beq.n	8017e7e <RegionCommonUpdateBandTimeOff+0x156>
            {
                nextTxDelay = MIN( bands[i].TimeOff - txDoneTime, nextTxDelay );
 8017de0:	187b      	adds	r3, r7, r1
 8017de2:	781b      	ldrb	r3, [r3, #0]
 8017de4:	011b      	lsls	r3, r3, #4
 8017de6:	683a      	ldr	r2, [r7, #0]
 8017de8:	18d3      	adds	r3, r2, r3
 8017dea:	68da      	ldr	r2, [r3, #12]
 8017dec:	68bb      	ldr	r3, [r7, #8]
 8017dee:	1ad2      	subs	r2, r2, r3
 8017df0:	69fb      	ldr	r3, [r7, #28]
 8017df2:	4293      	cmp	r3, r2
 8017df4:	d900      	bls.n	8017df8 <RegionCommonUpdateBandTimeOff+0xd0>
 8017df6:	0013      	movs	r3, r2
 8017df8:	61fb      	str	r3, [r7, #28]
 8017dfa:	e040      	b.n	8017e7e <RegionCommonUpdateBandTimeOff+0x156>
            }
        }
        else
        {
            if( dutyCycle == true )
 8017dfc:	1dbb      	adds	r3, r7, #6
 8017dfe:	781b      	ldrb	r3, [r3, #0]
 8017e00:	2b00      	cmp	r3, #0
 8017e02:	d032      	beq.n	8017e6a <RegionCommonUpdateBandTimeOff+0x142>
            {
                TimerTime_t elapsed = TimerGetElapsedTime( bands[i].LastTxDoneTime );
 8017e04:	241b      	movs	r4, #27
 8017e06:	193b      	adds	r3, r7, r4
 8017e08:	781b      	ldrb	r3, [r3, #0]
 8017e0a:	011b      	lsls	r3, r3, #4
 8017e0c:	683a      	ldr	r2, [r7, #0]
 8017e0e:	18d3      	adds	r3, r2, r3
 8017e10:	689b      	ldr	r3, [r3, #8]
 8017e12:	0018      	movs	r0, r3
 8017e14:	f003 f9c5 	bl	801b1a2 <TimerGetElapsedTime>
 8017e18:	0003      	movs	r3, r0
 8017e1a:	617b      	str	r3, [r7, #20]
                if( bands[i].TimeOff <= elapsed )
 8017e1c:	193b      	adds	r3, r7, r4
 8017e1e:	781b      	ldrb	r3, [r3, #0]
 8017e20:	011b      	lsls	r3, r3, #4
 8017e22:	683a      	ldr	r2, [r7, #0]
 8017e24:	18d3      	adds	r3, r2, r3
 8017e26:	68db      	ldr	r3, [r3, #12]
 8017e28:	697a      	ldr	r2, [r7, #20]
 8017e2a:	429a      	cmp	r2, r3
 8017e2c:	d306      	bcc.n	8017e3c <RegionCommonUpdateBandTimeOff+0x114>
                {
                    bands[i].TimeOff = 0;
 8017e2e:	193b      	adds	r3, r7, r4
 8017e30:	781b      	ldrb	r3, [r3, #0]
 8017e32:	011b      	lsls	r3, r3, #4
 8017e34:	683a      	ldr	r2, [r7, #0]
 8017e36:	18d3      	adds	r3, r2, r3
 8017e38:	2200      	movs	r2, #0
 8017e3a:	60da      	str	r2, [r3, #12]
                }
                if( bands[i].TimeOff != 0 )
 8017e3c:	211b      	movs	r1, #27
 8017e3e:	187b      	adds	r3, r7, r1
 8017e40:	781b      	ldrb	r3, [r3, #0]
 8017e42:	011b      	lsls	r3, r3, #4
 8017e44:	683a      	ldr	r2, [r7, #0]
 8017e46:	18d3      	adds	r3, r2, r3
 8017e48:	68db      	ldr	r3, [r3, #12]
 8017e4a:	2b00      	cmp	r3, #0
 8017e4c:	d017      	beq.n	8017e7e <RegionCommonUpdateBandTimeOff+0x156>
                {
                    nextTxDelay = MIN( bands[i].TimeOff - elapsed, nextTxDelay );
 8017e4e:	187b      	adds	r3, r7, r1
 8017e50:	781b      	ldrb	r3, [r3, #0]
 8017e52:	011b      	lsls	r3, r3, #4
 8017e54:	683a      	ldr	r2, [r7, #0]
 8017e56:	18d3      	adds	r3, r2, r3
 8017e58:	68da      	ldr	r2, [r3, #12]
 8017e5a:	697b      	ldr	r3, [r7, #20]
 8017e5c:	1ad2      	subs	r2, r2, r3
 8017e5e:	69fb      	ldr	r3, [r7, #28]
 8017e60:	4293      	cmp	r3, r2
 8017e62:	d900      	bls.n	8017e66 <RegionCommonUpdateBandTimeOff+0x13e>
 8017e64:	0013      	movs	r3, r2
 8017e66:	61fb      	str	r3, [r7, #28]
 8017e68:	e009      	b.n	8017e7e <RegionCommonUpdateBandTimeOff+0x156>
                }
            }
            else
            {
                nextTxDelay = 0;
 8017e6a:	2300      	movs	r3, #0
 8017e6c:	61fb      	str	r3, [r7, #28]
                bands[i].TimeOff = 0;
 8017e6e:	231b      	movs	r3, #27
 8017e70:	18fb      	adds	r3, r7, r3
 8017e72:	781b      	ldrb	r3, [r3, #0]
 8017e74:	011b      	lsls	r3, r3, #4
 8017e76:	683a      	ldr	r2, [r7, #0]
 8017e78:	18d3      	adds	r3, r2, r3
 8017e7a:	2200      	movs	r2, #0
 8017e7c:	60da      	str	r2, [r3, #12]
    for( uint8_t i = 0; i < nbBands; i++ )
 8017e7e:	211b      	movs	r1, #27
 8017e80:	187b      	adds	r3, r7, r1
 8017e82:	781a      	ldrb	r2, [r3, #0]
 8017e84:	187b      	adds	r3, r7, r1
 8017e86:	3201      	adds	r2, #1
 8017e88:	701a      	strb	r2, [r3, #0]
 8017e8a:	231b      	movs	r3, #27
 8017e8c:	18fa      	adds	r2, r7, r3
 8017e8e:	1d7b      	adds	r3, r7, #5
 8017e90:	7812      	ldrb	r2, [r2, #0]
 8017e92:	781b      	ldrb	r3, [r3, #0]
 8017e94:	429a      	cmp	r2, r3
 8017e96:	d200      	bcs.n	8017e9a <RegionCommonUpdateBandTimeOff+0x172>
 8017e98:	e75e      	b.n	8017d58 <RegionCommonUpdateBandTimeOff+0x30>
            }
        }
    }

    return ( nextTxDelay == TIMERTIME_T_MAX ) ? 0 : nextTxDelay;
 8017e9a:	69fb      	ldr	r3, [r7, #28]
 8017e9c:	3301      	adds	r3, #1
 8017e9e:	d001      	beq.n	8017ea4 <RegionCommonUpdateBandTimeOff+0x17c>
 8017ea0:	69fb      	ldr	r3, [r7, #28]
 8017ea2:	e000      	b.n	8017ea6 <RegionCommonUpdateBandTimeOff+0x17e>
 8017ea4:	2300      	movs	r3, #0
}
 8017ea6:	0018      	movs	r0, r3
 8017ea8:	46bd      	mov	sp, r7
 8017eaa:	b009      	add	sp, #36	; 0x24
 8017eac:	bd90      	pop	{r4, r7, pc}

08017eae <RegionCommonParseLinkAdrReq>:

uint8_t RegionCommonParseLinkAdrReq( uint8_t* payload, RegionCommonLinkAdrParams_t* linkAdrParams )
{
 8017eae:	b580      	push	{r7, lr}
 8017eb0:	b084      	sub	sp, #16
 8017eb2:	af00      	add	r7, sp, #0
 8017eb4:	6078      	str	r0, [r7, #4]
 8017eb6:	6039      	str	r1, [r7, #0]
    uint8_t retIndex = 0;
 8017eb8:	210f      	movs	r1, #15
 8017eba:	187b      	adds	r3, r7, r1
 8017ebc:	2200      	movs	r2, #0
 8017ebe:	701a      	strb	r2, [r3, #0]

    if( payload[0] == SRV_MAC_LINK_ADR_REQ )
 8017ec0:	687b      	ldr	r3, [r7, #4]
 8017ec2:	781b      	ldrb	r3, [r3, #0]
 8017ec4:	2b03      	cmp	r3, #3
 8017ec6:	d140      	bne.n	8017f4a <RegionCommonParseLinkAdrReq+0x9c>
    {
        // Parse datarate and tx power
        linkAdrParams->Datarate = payload[1];
 8017ec8:	687b      	ldr	r3, [r7, #4]
 8017eca:	3301      	adds	r3, #1
 8017ecc:	781b      	ldrb	r3, [r3, #0]
 8017ece:	b25a      	sxtb	r2, r3
 8017ed0:	683b      	ldr	r3, [r7, #0]
 8017ed2:	705a      	strb	r2, [r3, #1]
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 8017ed4:	683b      	ldr	r3, [r7, #0]
 8017ed6:	785b      	ldrb	r3, [r3, #1]
 8017ed8:	b25b      	sxtb	r3, r3
 8017eda:	220f      	movs	r2, #15
 8017edc:	4013      	ands	r3, r2
 8017ede:	b25a      	sxtb	r2, r3
 8017ee0:	683b      	ldr	r3, [r7, #0]
 8017ee2:	709a      	strb	r2, [r3, #2]
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 8017ee4:	683b      	ldr	r3, [r7, #0]
 8017ee6:	785b      	ldrb	r3, [r3, #1]
 8017ee8:	b25b      	sxtb	r3, r3
 8017eea:	b2db      	uxtb	r3, r3
 8017eec:	091b      	lsrs	r3, r3, #4
 8017eee:	b2db      	uxtb	r3, r3
 8017ef0:	b25a      	sxtb	r2, r3
 8017ef2:	683b      	ldr	r3, [r7, #0]
 8017ef4:	705a      	strb	r2, [r3, #1]
        // Parse ChMask
        linkAdrParams->ChMask = ( uint16_t )payload[2];
 8017ef6:	687b      	ldr	r3, [r7, #4]
 8017ef8:	3302      	adds	r3, #2
 8017efa:	781b      	ldrb	r3, [r3, #0]
 8017efc:	b29a      	uxth	r2, r3
 8017efe:	683b      	ldr	r3, [r7, #0]
 8017f00:	809a      	strh	r2, [r3, #4]
        linkAdrParams->ChMask |= ( uint16_t )payload[3] << 8;
 8017f02:	683b      	ldr	r3, [r7, #0]
 8017f04:	889b      	ldrh	r3, [r3, #4]
 8017f06:	b21a      	sxth	r2, r3
 8017f08:	687b      	ldr	r3, [r7, #4]
 8017f0a:	3303      	adds	r3, #3
 8017f0c:	781b      	ldrb	r3, [r3, #0]
 8017f0e:	021b      	lsls	r3, r3, #8
 8017f10:	b21b      	sxth	r3, r3
 8017f12:	4313      	orrs	r3, r2
 8017f14:	b21b      	sxth	r3, r3
 8017f16:	b29a      	uxth	r2, r3
 8017f18:	683b      	ldr	r3, [r7, #0]
 8017f1a:	809a      	strh	r2, [r3, #4]
        // Parse ChMaskCtrl and nbRep
        linkAdrParams->NbRep = payload[4];
 8017f1c:	687b      	ldr	r3, [r7, #4]
 8017f1e:	791a      	ldrb	r2, [r3, #4]
 8017f20:	683b      	ldr	r3, [r7, #0]
 8017f22:	701a      	strb	r2, [r3, #0]
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 8017f24:	683b      	ldr	r3, [r7, #0]
 8017f26:	781b      	ldrb	r3, [r3, #0]
 8017f28:	091b      	lsrs	r3, r3, #4
 8017f2a:	b2db      	uxtb	r3, r3
 8017f2c:	2207      	movs	r2, #7
 8017f2e:	4013      	ands	r3, r2
 8017f30:	b2da      	uxtb	r2, r3
 8017f32:	683b      	ldr	r3, [r7, #0]
 8017f34:	70da      	strb	r2, [r3, #3]
        linkAdrParams->NbRep &= 0x0F;
 8017f36:	683b      	ldr	r3, [r7, #0]
 8017f38:	781b      	ldrb	r3, [r3, #0]
 8017f3a:	220f      	movs	r2, #15
 8017f3c:	4013      	ands	r3, r2
 8017f3e:	b2da      	uxtb	r2, r3
 8017f40:	683b      	ldr	r3, [r7, #0]
 8017f42:	701a      	strb	r2, [r3, #0]

        // LinkAdrReq has 4 bytes length + 1 byte CMD
        retIndex = 5;
 8017f44:	187b      	adds	r3, r7, r1
 8017f46:	2205      	movs	r2, #5
 8017f48:	701a      	strb	r2, [r3, #0]
    }
    return retIndex;
 8017f4a:	230f      	movs	r3, #15
 8017f4c:	18fb      	adds	r3, r7, r3
 8017f4e:	781b      	ldrb	r3, [r3, #0]
}
 8017f50:	0018      	movs	r0, r3
 8017f52:	46bd      	mov	sp, r7
 8017f54:	b004      	add	sp, #16
 8017f56:	bd80      	pop	{r7, pc}

08017f58 <RegionCommonLinkAdrReqVerifyParams>:

uint8_t RegionCommonLinkAdrReqVerifyParams( RegionCommonLinkAdrReqVerifyParams_t* verifyParams, int8_t* dr, int8_t* txPow, uint8_t* nbRep )
{
 8017f58:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017f5a:	b089      	sub	sp, #36	; 0x24
 8017f5c:	af02      	add	r7, sp, #8
 8017f5e:	60f8      	str	r0, [r7, #12]
 8017f60:	60b9      	str	r1, [r7, #8]
 8017f62:	607a      	str	r2, [r7, #4]
 8017f64:	603b      	str	r3, [r7, #0]
    uint8_t status = verifyParams->Status;
 8017f66:	2317      	movs	r3, #23
 8017f68:	18fb      	adds	r3, r7, r3
 8017f6a:	68fa      	ldr	r2, [r7, #12]
 8017f6c:	7912      	ldrb	r2, [r2, #4]
 8017f6e:	701a      	strb	r2, [r3, #0]
    int8_t datarate = verifyParams->Datarate;
 8017f70:	2116      	movs	r1, #22
 8017f72:	187b      	adds	r3, r7, r1
 8017f74:	68fa      	ldr	r2, [r7, #12]
 8017f76:	7992      	ldrb	r2, [r2, #6]
 8017f78:	701a      	strb	r2, [r3, #0]
    int8_t txPower = verifyParams->TxPower;
 8017f7a:	2015      	movs	r0, #21
 8017f7c:	183b      	adds	r3, r7, r0
 8017f7e:	68fa      	ldr	r2, [r7, #12]
 8017f80:	79d2      	ldrb	r2, [r2, #7]
 8017f82:	701a      	strb	r2, [r3, #0]
    int8_t nbRepetitions = verifyParams->NbRep;
 8017f84:	68fb      	ldr	r3, [r7, #12]
 8017f86:	7a1a      	ldrb	r2, [r3, #8]
 8017f88:	2414      	movs	r4, #20
 8017f8a:	193b      	adds	r3, r7, r4
 8017f8c:	701a      	strb	r2, [r3, #0]

    // Handle the case when ADR is off.
    if( verifyParams->AdrEnabled == false )
 8017f8e:	68fb      	ldr	r3, [r7, #12]
 8017f90:	795b      	ldrb	r3, [r3, #5]
 8017f92:	2201      	movs	r2, #1
 8017f94:	4053      	eors	r3, r2
 8017f96:	b2db      	uxtb	r3, r3
 8017f98:	2b00      	cmp	r3, #0
 8017f9a:	d00b      	beq.n	8017fb4 <RegionCommonLinkAdrReqVerifyParams+0x5c>
    {
        // When ADR is off, we are allowed to change the channels mask
        nbRepetitions = verifyParams->CurrentNbRep;
 8017f9c:	193b      	adds	r3, r7, r4
 8017f9e:	68fa      	ldr	r2, [r7, #12]
 8017fa0:	7ad2      	ldrb	r2, [r2, #11]
 8017fa2:	701a      	strb	r2, [r3, #0]
        datarate =  verifyParams->CurrentDatarate;
 8017fa4:	187b      	adds	r3, r7, r1
 8017fa6:	68fa      	ldr	r2, [r7, #12]
 8017fa8:	7a52      	ldrb	r2, [r2, #9]
 8017faa:	701a      	strb	r2, [r3, #0]
        txPower =  verifyParams->CurrentTxPower;
 8017fac:	183b      	adds	r3, r7, r0
 8017fae:	68fa      	ldr	r2, [r7, #12]
 8017fb0:	7a92      	ldrb	r2, [r2, #10]
 8017fb2:	701a      	strb	r2, [r3, #0]
    }

    if( status != 0 )
 8017fb4:	2617      	movs	r6, #23
 8017fb6:	19bb      	adds	r3, r7, r6
 8017fb8:	781b      	ldrb	r3, [r3, #0]
 8017fba:	2b00      	cmp	r3, #0
 8017fbc:	d046      	beq.n	801804c <RegionCommonLinkAdrReqVerifyParams+0xf4>
    {
        // Verify datarate. The variable phyParam. Value contains the minimum allowed datarate.
        if( RegionCommonChanVerifyDr( verifyParams->NbChannels, verifyParams->ChannelsMask, datarate,
 8017fbe:	68fb      	ldr	r3, [r7, #12]
 8017fc0:	7b18      	ldrb	r0, [r3, #12]
 8017fc2:	68fb      	ldr	r3, [r7, #12]
 8017fc4:	691c      	ldr	r4, [r3, #16]
 8017fc6:	68fb      	ldr	r3, [r7, #12]
 8017fc8:	2514      	movs	r5, #20
 8017fca:	575d      	ldrsb	r5, [r3, r5]
 8017fcc:	68fb      	ldr	r3, [r7, #12]
 8017fce:	2215      	movs	r2, #21
 8017fd0:	569a      	ldrsb	r2, [r3, r2]
 8017fd2:	68fb      	ldr	r3, [r7, #12]
 8017fd4:	699b      	ldr	r3, [r3, #24]
 8017fd6:	2116      	movs	r1, #22
 8017fd8:	1879      	adds	r1, r7, r1
 8017fda:	7809      	ldrb	r1, [r1, #0]
 8017fdc:	b249      	sxtb	r1, r1
 8017fde:	9301      	str	r3, [sp, #4]
 8017fe0:	9200      	str	r2, [sp, #0]
 8017fe2:	002b      	movs	r3, r5
 8017fe4:	000a      	movs	r2, r1
 8017fe6:	0021      	movs	r1, r4
 8017fe8:	f7ff fd12 	bl	8017a10 <RegionCommonChanVerifyDr>
 8017fec:	0003      	movs	r3, r0
 8017fee:	001a      	movs	r2, r3
                                      verifyParams->MinDatarate, verifyParams->MaxDatarate, verifyParams->Channels  ) == false )
 8017ff0:	2301      	movs	r3, #1
 8017ff2:	4053      	eors	r3, r2
 8017ff4:	b2db      	uxtb	r3, r3
        if( RegionCommonChanVerifyDr( verifyParams->NbChannels, verifyParams->ChannelsMask, datarate,
 8017ff6:	2b00      	cmp	r3, #0
 8017ff8:	d005      	beq.n	8018006 <RegionCommonLinkAdrReqVerifyParams+0xae>
        {
            status &= 0xFD; // Datarate KO
 8017ffa:	19bb      	adds	r3, r7, r6
 8017ffc:	19ba      	adds	r2, r7, r6
 8017ffe:	7812      	ldrb	r2, [r2, #0]
 8018000:	2102      	movs	r1, #2
 8018002:	438a      	bics	r2, r1
 8018004:	701a      	strb	r2, [r3, #0]
        }

        // Verify tx power
        if( RegionCommonValueInRange( txPower, verifyParams->MaxTxPower, verifyParams->MinTxPower ) == 0 )
 8018006:	68fb      	ldr	r3, [r7, #12]
 8018008:	211d      	movs	r1, #29
 801800a:	5659      	ldrsb	r1, [r3, r1]
 801800c:	68fb      	ldr	r3, [r7, #12]
 801800e:	221c      	movs	r2, #28
 8018010:	569a      	ldrsb	r2, [r3, r2]
 8018012:	2415      	movs	r4, #21
 8018014:	193b      	adds	r3, r7, r4
 8018016:	781b      	ldrb	r3, [r3, #0]
 8018018:	b25b      	sxtb	r3, r3
 801801a:	0018      	movs	r0, r3
 801801c:	f7ff fd91 	bl	8017b42 <RegionCommonValueInRange>
 8018020:	1e03      	subs	r3, r0, #0
 8018022:	d113      	bne.n	801804c <RegionCommonLinkAdrReqVerifyParams+0xf4>
        {
            // Verify if the maximum TX power is exceeded
            if( verifyParams->MaxTxPower > txPower )
 8018024:	68fb      	ldr	r3, [r7, #12]
 8018026:	7f5b      	ldrb	r3, [r3, #29]
 8018028:	b25b      	sxtb	r3, r3
 801802a:	193a      	adds	r2, r7, r4
 801802c:	7812      	ldrb	r2, [r2, #0]
 801802e:	b252      	sxtb	r2, r2
 8018030:	429a      	cmp	r2, r3
 8018032:	da04      	bge.n	801803e <RegionCommonLinkAdrReqVerifyParams+0xe6>
            { // Apply maximum TX power. Accept TX power.
                txPower = verifyParams->MaxTxPower;
 8018034:	193b      	adds	r3, r7, r4
 8018036:	68fa      	ldr	r2, [r7, #12]
 8018038:	7f52      	ldrb	r2, [r2, #29]
 801803a:	701a      	strb	r2, [r3, #0]
 801803c:	e006      	b.n	801804c <RegionCommonLinkAdrReqVerifyParams+0xf4>
            }
            else
            {
                status &= 0xFB; // TxPower KO
 801803e:	2217      	movs	r2, #23
 8018040:	18bb      	adds	r3, r7, r2
 8018042:	18ba      	adds	r2, r7, r2
 8018044:	7812      	ldrb	r2, [r2, #0]
 8018046:	2104      	movs	r1, #4
 8018048:	438a      	bics	r2, r1
 801804a:	701a      	strb	r2, [r3, #0]
            }
        }
    }

    // If the status is ok, verify the NbRep
    if( status == 0x07 )
 801804c:	2317      	movs	r3, #23
 801804e:	18fb      	adds	r3, r7, r3
 8018050:	781b      	ldrb	r3, [r3, #0]
 8018052:	2b07      	cmp	r3, #7
 8018054:	d108      	bne.n	8018068 <RegionCommonLinkAdrReqVerifyParams+0x110>
    {
        if( nbRepetitions == 0 )
 8018056:	2214      	movs	r2, #20
 8018058:	18bb      	adds	r3, r7, r2
 801805a:	781b      	ldrb	r3, [r3, #0]
 801805c:	b25b      	sxtb	r3, r3
 801805e:	2b00      	cmp	r3, #0
 8018060:	d102      	bne.n	8018068 <RegionCommonLinkAdrReqVerifyParams+0x110>
        { // Restore the default value according to the LoRaWAN specification
            nbRepetitions = 1;
 8018062:	18bb      	adds	r3, r7, r2
 8018064:	2201      	movs	r2, #1
 8018066:	701a      	strb	r2, [r3, #0]
        }
    }

    // Apply changes
    *dr = datarate;
 8018068:	68bb      	ldr	r3, [r7, #8]
 801806a:	2216      	movs	r2, #22
 801806c:	18ba      	adds	r2, r7, r2
 801806e:	7812      	ldrb	r2, [r2, #0]
 8018070:	701a      	strb	r2, [r3, #0]
    *txPow = txPower;
 8018072:	687b      	ldr	r3, [r7, #4]
 8018074:	2215      	movs	r2, #21
 8018076:	18ba      	adds	r2, r7, r2
 8018078:	7812      	ldrb	r2, [r2, #0]
 801807a:	701a      	strb	r2, [r3, #0]
    *nbRep = nbRepetitions;
 801807c:	2314      	movs	r3, #20
 801807e:	18fb      	adds	r3, r7, r3
 8018080:	781a      	ldrb	r2, [r3, #0]
 8018082:	683b      	ldr	r3, [r7, #0]
 8018084:	701a      	strb	r2, [r3, #0]

    return status;
 8018086:	2317      	movs	r3, #23
 8018088:	18fb      	adds	r3, r7, r3
 801808a:	781b      	ldrb	r3, [r3, #0]
}
 801808c:	0018      	movs	r0, r3
 801808e:	46bd      	mov	sp, r7
 8018090:	b007      	add	sp, #28
 8018092:	bdf0      	pop	{r4, r5, r6, r7, pc}

08018094 <RegionCommonComputeSymbolTimeLoRa>:

double RegionCommonComputeSymbolTimeLoRa( uint8_t phyDr, uint32_t bandwidth )
{
 8018094:	b5b0      	push	{r4, r5, r7, lr}
 8018096:	b082      	sub	sp, #8
 8018098:	af00      	add	r7, sp, #0
 801809a:	0002      	movs	r2, r0
 801809c:	6039      	str	r1, [r7, #0]
 801809e:	1dfb      	adds	r3, r7, #7
 80180a0:	701a      	strb	r2, [r3, #0]
    return ( ( double )( 1 << phyDr ) / ( double )bandwidth ) * 1000;
 80180a2:	1dfb      	adds	r3, r7, #7
 80180a4:	781b      	ldrb	r3, [r3, #0]
 80180a6:	2201      	movs	r2, #1
 80180a8:	409a      	lsls	r2, r3
 80180aa:	0013      	movs	r3, r2
 80180ac:	0018      	movs	r0, r3
 80180ae:	f7ea ffd3 	bl	8003058 <__aeabi_i2d>
 80180b2:	0004      	movs	r4, r0
 80180b4:	000d      	movs	r5, r1
 80180b6:	6838      	ldr	r0, [r7, #0]
 80180b8:	f7ea fffe 	bl	80030b8 <__aeabi_ui2d>
 80180bc:	0002      	movs	r2, r0
 80180be:	000b      	movs	r3, r1
 80180c0:	0020      	movs	r0, r4
 80180c2:	0029      	movs	r1, r5
 80180c4:	f7e9 fd8e 	bl	8001be4 <__aeabi_ddiv>
 80180c8:	0002      	movs	r2, r0
 80180ca:	000b      	movs	r3, r1
 80180cc:	0010      	movs	r0, r2
 80180ce:	0019      	movs	r1, r3
 80180d0:	2200      	movs	r2, #0
 80180d2:	4b05      	ldr	r3, [pc, #20]	; (80180e8 <RegionCommonComputeSymbolTimeLoRa+0x54>)
 80180d4:	f7ea f98c 	bl	80023f0 <__aeabi_dmul>
 80180d8:	0002      	movs	r2, r0
 80180da:	000b      	movs	r3, r1
}
 80180dc:	0010      	movs	r0, r2
 80180de:	0019      	movs	r1, r3
 80180e0:	46bd      	mov	sp, r7
 80180e2:	b002      	add	sp, #8
 80180e4:	bdb0      	pop	{r4, r5, r7, pc}
 80180e6:	46c0      	nop			; (mov r8, r8)
 80180e8:	408f4000 	.word	0x408f4000

080180ec <RegionCommonComputeSymbolTimeFsk>:

double RegionCommonComputeSymbolTimeFsk( uint8_t phyDr )
{
 80180ec:	b580      	push	{r7, lr}
 80180ee:	b082      	sub	sp, #8
 80180f0:	af00      	add	r7, sp, #0
 80180f2:	0002      	movs	r2, r0
 80180f4:	1dfb      	adds	r3, r7, #7
 80180f6:	701a      	strb	r2, [r3, #0]
    return ( 8.0 / ( double )phyDr ); // 1 symbol equals 1 byte
 80180f8:	1dfb      	adds	r3, r7, #7
 80180fa:	781b      	ldrb	r3, [r3, #0]
 80180fc:	0018      	movs	r0, r3
 80180fe:	f7ea ffdb 	bl	80030b8 <__aeabi_ui2d>
 8018102:	0002      	movs	r2, r0
 8018104:	000b      	movs	r3, r1
 8018106:	2000      	movs	r0, #0
 8018108:	4904      	ldr	r1, [pc, #16]	; (801811c <RegionCommonComputeSymbolTimeFsk+0x30>)
 801810a:	f7e9 fd6b 	bl	8001be4 <__aeabi_ddiv>
 801810e:	0002      	movs	r2, r0
 8018110:	000b      	movs	r3, r1
}
 8018112:	0010      	movs	r0, r2
 8018114:	0019      	movs	r1, r3
 8018116:	46bd      	mov	sp, r7
 8018118:	b002      	add	sp, #8
 801811a:	bd80      	pop	{r7, pc}
 801811c:	40200000 	.word	0x40200000

08018120 <RegionCommonComputeRxWindowParameters>:

void RegionCommonComputeRxWindowParameters( double tSymbol, uint8_t minRxSymbols, uint32_t rxError, uint32_t wakeUpTime, uint32_t* windowTimeout, int32_t* windowOffset )
{
 8018120:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018122:	b085      	sub	sp, #20
 8018124:	af00      	add	r7, sp, #0
 8018126:	60b8      	str	r0, [r7, #8]
 8018128:	60f9      	str	r1, [r7, #12]
 801812a:	603b      	str	r3, [r7, #0]
 801812c:	1dfb      	adds	r3, r7, #7
 801812e:	701a      	strb	r2, [r3, #0]
    *windowTimeout = MAX( ( uint32_t )ceil( ( ( 2 * minRxSymbols - 8 ) * tSymbol + 2 * rxError ) / tSymbol ), minRxSymbols ); // Computed number of symbols
 8018130:	1dfb      	adds	r3, r7, #7
 8018132:	781e      	ldrb	r6, [r3, #0]
 8018134:	1dfb      	adds	r3, r7, #7
 8018136:	781b      	ldrb	r3, [r3, #0]
 8018138:	3b04      	subs	r3, #4
 801813a:	005b      	lsls	r3, r3, #1
 801813c:	0018      	movs	r0, r3
 801813e:	f7ea ff8b 	bl	8003058 <__aeabi_i2d>
 8018142:	68ba      	ldr	r2, [r7, #8]
 8018144:	68fb      	ldr	r3, [r7, #12]
 8018146:	f7ea f953 	bl	80023f0 <__aeabi_dmul>
 801814a:	0002      	movs	r2, r0
 801814c:	000b      	movs	r3, r1
 801814e:	0014      	movs	r4, r2
 8018150:	001d      	movs	r5, r3
 8018152:	683b      	ldr	r3, [r7, #0]
 8018154:	005b      	lsls	r3, r3, #1
 8018156:	0018      	movs	r0, r3
 8018158:	f7ea ffae 	bl	80030b8 <__aeabi_ui2d>
 801815c:	0002      	movs	r2, r0
 801815e:	000b      	movs	r3, r1
 8018160:	0020      	movs	r0, r4
 8018162:	0029      	movs	r1, r5
 8018164:	f7e9 f9d4 	bl	8001510 <__aeabi_dadd>
 8018168:	0002      	movs	r2, r0
 801816a:	000b      	movs	r3, r1
 801816c:	0010      	movs	r0, r2
 801816e:	0019      	movs	r1, r3
 8018170:	68ba      	ldr	r2, [r7, #8]
 8018172:	68fb      	ldr	r3, [r7, #12]
 8018174:	f7e9 fd36 	bl	8001be4 <__aeabi_ddiv>
 8018178:	0002      	movs	r2, r0
 801817a:	000b      	movs	r3, r1
 801817c:	0010      	movs	r0, r2
 801817e:	0019      	movs	r1, r3
 8018180:	f006 fb72 	bl	801e868 <ceil>
 8018184:	0002      	movs	r2, r0
 8018186:	000b      	movs	r3, r1
 8018188:	0010      	movs	r0, r2
 801818a:	0019      	movs	r1, r3
 801818c:	f7e8 f9ec 	bl	8000568 <__aeabi_d2uiz>
 8018190:	0002      	movs	r2, r0
 8018192:	0033      	movs	r3, r6
 8018194:	4293      	cmp	r3, r2
 8018196:	d200      	bcs.n	801819a <RegionCommonComputeRxWindowParameters+0x7a>
 8018198:	0013      	movs	r3, r2
 801819a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801819c:	6013      	str	r3, [r2, #0]
    *windowOffset = ( int32_t )ceil( ( 4.0 * tSymbol ) - ( ( *windowTimeout * tSymbol ) / 2.0 ) - wakeUpTime );
 801819e:	2200      	movs	r2, #0
 80181a0:	4b20      	ldr	r3, [pc, #128]	; (8018224 <RegionCommonComputeRxWindowParameters+0x104>)
 80181a2:	68b8      	ldr	r0, [r7, #8]
 80181a4:	68f9      	ldr	r1, [r7, #12]
 80181a6:	f7ea f923 	bl	80023f0 <__aeabi_dmul>
 80181aa:	0002      	movs	r2, r0
 80181ac:	000b      	movs	r3, r1
 80181ae:	0014      	movs	r4, r2
 80181b0:	001d      	movs	r5, r3
 80181b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80181b4:	681b      	ldr	r3, [r3, #0]
 80181b6:	0018      	movs	r0, r3
 80181b8:	f7ea ff7e 	bl	80030b8 <__aeabi_ui2d>
 80181bc:	68ba      	ldr	r2, [r7, #8]
 80181be:	68fb      	ldr	r3, [r7, #12]
 80181c0:	f7ea f916 	bl	80023f0 <__aeabi_dmul>
 80181c4:	0002      	movs	r2, r0
 80181c6:	000b      	movs	r3, r1
 80181c8:	0010      	movs	r0, r2
 80181ca:	0019      	movs	r1, r3
 80181cc:	2200      	movs	r2, #0
 80181ce:	2380      	movs	r3, #128	; 0x80
 80181d0:	05db      	lsls	r3, r3, #23
 80181d2:	f7e9 fd07 	bl	8001be4 <__aeabi_ddiv>
 80181d6:	0002      	movs	r2, r0
 80181d8:	000b      	movs	r3, r1
 80181da:	0020      	movs	r0, r4
 80181dc:	0029      	movs	r1, r5
 80181de:	f7ea fb73 	bl	80028c8 <__aeabi_dsub>
 80181e2:	0002      	movs	r2, r0
 80181e4:	000b      	movs	r3, r1
 80181e6:	0014      	movs	r4, r2
 80181e8:	001d      	movs	r5, r3
 80181ea:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80181ec:	f7ea ff64 	bl	80030b8 <__aeabi_ui2d>
 80181f0:	0002      	movs	r2, r0
 80181f2:	000b      	movs	r3, r1
 80181f4:	0020      	movs	r0, r4
 80181f6:	0029      	movs	r1, r5
 80181f8:	f7ea fb66 	bl	80028c8 <__aeabi_dsub>
 80181fc:	0002      	movs	r2, r0
 80181fe:	000b      	movs	r3, r1
 8018200:	0010      	movs	r0, r2
 8018202:	0019      	movs	r1, r3
 8018204:	f006 fb30 	bl	801e868 <ceil>
 8018208:	0002      	movs	r2, r0
 801820a:	000b      	movs	r3, r1
 801820c:	0010      	movs	r0, r2
 801820e:	0019      	movs	r1, r3
 8018210:	f7ea feec 	bl	8002fec <__aeabi_d2iz>
 8018214:	0002      	movs	r2, r0
 8018216:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8018218:	601a      	str	r2, [r3, #0]
}
 801821a:	46c0      	nop			; (mov r8, r8)
 801821c:	46bd      	mov	sp, r7
 801821e:	b005      	add	sp, #20
 8018220:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8018222:	46c0      	nop			; (mov r8, r8)
 8018224:	40100000 	.word	0x40100000

08018228 <RegionCommonComputeTxPower>:

int8_t RegionCommonComputeTxPower( int8_t txPowerIndex, float maxEirp, float antennaGain )
{
 8018228:	b5b0      	push	{r4, r5, r7, lr}
 801822a:	b086      	sub	sp, #24
 801822c:	af00      	add	r7, sp, #0
 801822e:	60b9      	str	r1, [r7, #8]
 8018230:	607a      	str	r2, [r7, #4]
 8018232:	210f      	movs	r1, #15
 8018234:	187b      	adds	r3, r7, r1
 8018236:	1c02      	adds	r2, r0, #0
 8018238:	701a      	strb	r2, [r3, #0]
    int8_t phyTxPower = 0;
 801823a:	2417      	movs	r4, #23
 801823c:	193b      	adds	r3, r7, r4
 801823e:	2200      	movs	r2, #0
 8018240:	701a      	strb	r2, [r3, #0]

    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 8018242:	187b      	adds	r3, r7, r1
 8018244:	781b      	ldrb	r3, [r3, #0]
 8018246:	b25b      	sxtb	r3, r3
 8018248:	005b      	lsls	r3, r3, #1
 801824a:	0018      	movs	r0, r3
 801824c:	f7e9 f924 	bl	8001498 <__aeabi_ui2f>
 8018250:	1c03      	adds	r3, r0, #0
 8018252:	1c19      	adds	r1, r3, #0
 8018254:	68b8      	ldr	r0, [r7, #8]
 8018256:	f7e8 fef1 	bl	800103c <__aeabi_fsub>
 801825a:	1c03      	adds	r3, r0, #0
 801825c:	6879      	ldr	r1, [r7, #4]
 801825e:	1c18      	adds	r0, r3, #0
 8018260:	f7e8 feec 	bl	800103c <__aeabi_fsub>
 8018264:	1c03      	adds	r3, r0, #0
 8018266:	1c18      	adds	r0, r3, #0
 8018268:	f7ea ff4c 	bl	8003104 <__aeabi_f2d>
 801826c:	0002      	movs	r2, r0
 801826e:	000b      	movs	r3, r1
 8018270:	0010      	movs	r0, r2
 8018272:	0019      	movs	r1, r3
 8018274:	f006 fb82 	bl	801e97c <floor>
 8018278:	0002      	movs	r2, r0
 801827a:	000b      	movs	r3, r1
 801827c:	0025      	movs	r5, r4
 801827e:	193c      	adds	r4, r7, r4
 8018280:	0010      	movs	r0, r2
 8018282:	0019      	movs	r1, r3
 8018284:	f7ea feb2 	bl	8002fec <__aeabi_d2iz>
 8018288:	0003      	movs	r3, r0
 801828a:	7023      	strb	r3, [r4, #0]

    return phyTxPower;
 801828c:	197b      	adds	r3, r7, r5
 801828e:	781b      	ldrb	r3, [r3, #0]
 8018290:	b25b      	sxtb	r3, r3
}
 8018292:	0018      	movs	r0, r3
 8018294:	46bd      	mov	sp, r7
 8018296:	b006      	add	sp, #24
 8018298:	bdb0      	pop	{r4, r5, r7, pc}

0801829a <RegionCommonCalcBackOff>:

void RegionCommonCalcBackOff( RegionCommonCalcBackOffParams_t* calcBackOffParams )
{
 801829a:	b5f0      	push	{r4, r5, r6, r7, lr}
 801829c:	b085      	sub	sp, #20
 801829e:	af00      	add	r7, sp, #0
 80182a0:	6078      	str	r0, [r7, #4]
    uint8_t bandIdx = calcBackOffParams->Channels[calcBackOffParams->Channel].Band;
 80182a2:	687b      	ldr	r3, [r7, #4]
 80182a4:	681a      	ldr	r2, [r3, #0]
 80182a6:	687b      	ldr	r3, [r7, #4]
 80182a8:	7adb      	ldrb	r3, [r3, #11]
 80182aa:	0019      	movs	r1, r3
 80182ac:	000b      	movs	r3, r1
 80182ae:	005b      	lsls	r3, r3, #1
 80182b0:	185b      	adds	r3, r3, r1
 80182b2:	009b      	lsls	r3, r3, #2
 80182b4:	18d2      	adds	r2, r2, r3
 80182b6:	210f      	movs	r1, #15
 80182b8:	187b      	adds	r3, r7, r1
 80182ba:	7a52      	ldrb	r2, [r2, #9]
 80182bc:	701a      	strb	r2, [r3, #0]
    uint16_t dutyCycle = calcBackOffParams->Bands[bandIdx].DCycle;
 80182be:	687b      	ldr	r3, [r7, #4]
 80182c0:	685a      	ldr	r2, [r3, #4]
 80182c2:	187b      	adds	r3, r7, r1
 80182c4:	781b      	ldrb	r3, [r3, #0]
 80182c6:	011b      	lsls	r3, r3, #4
 80182c8:	18d2      	adds	r2, r2, r3
 80182ca:	250c      	movs	r5, #12
 80182cc:	197b      	adds	r3, r7, r5
 80182ce:	8812      	ldrh	r2, [r2, #0]
 80182d0:	801a      	strh	r2, [r3, #0]
    uint16_t joinDutyCycle = 0;
 80182d2:	200a      	movs	r0, #10
 80182d4:	183b      	adds	r3, r7, r0
 80182d6:	2200      	movs	r2, #0
 80182d8:	801a      	strh	r2, [r3, #0]

    // Reset time-off to initial value.
    calcBackOffParams->Bands[bandIdx].TimeOff = 0;
 80182da:	687b      	ldr	r3, [r7, #4]
 80182dc:	685a      	ldr	r2, [r3, #4]
 80182de:	187b      	adds	r3, r7, r1
 80182e0:	781b      	ldrb	r3, [r3, #0]
 80182e2:	011b      	lsls	r3, r3, #4
 80182e4:	18d3      	adds	r3, r2, r3
 80182e6:	2200      	movs	r2, #0
 80182e8:	60da      	str	r2, [r3, #12]

    if( calcBackOffParams->Joined == false )
 80182ea:	687b      	ldr	r3, [r7, #4]
 80182ec:	7a5b      	ldrb	r3, [r3, #9]
 80182ee:	2201      	movs	r2, #1
 80182f0:	4053      	eors	r3, r2
 80182f2:	b2db      	uxtb	r3, r3
 80182f4:	2b00      	cmp	r3, #0
 80182f6:	d03b      	beq.n	8018370 <RegionCommonCalcBackOff+0xd6>
    {
        // Get the join duty cycle
        joinDutyCycle = RegionCommonGetJoinDc( calcBackOffParams->ElapsedTime );
 80182f8:	687b      	ldr	r3, [r7, #4]
 80182fa:	68db      	ldr	r3, [r3, #12]
 80182fc:	0006      	movs	r6, r0
 80182fe:	183c      	adds	r4, r7, r0
 8018300:	0018      	movs	r0, r3
 8018302:	f7ff fb59 	bl	80179b8 <RegionCommonGetJoinDc>
 8018306:	0003      	movs	r3, r0
 8018308:	8023      	strh	r3, [r4, #0]
        // Apply the most restricting duty cycle
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 801830a:	197a      	adds	r2, r7, r5
 801830c:	19bb      	adds	r3, r7, r6
 801830e:	1979      	adds	r1, r7, r5
 8018310:	880c      	ldrh	r4, [r1, #0]
 8018312:	881b      	ldrh	r3, [r3, #0]
 8018314:	b298      	uxth	r0, r3
 8018316:	b2a1      	uxth	r1, r4
 8018318:	4288      	cmp	r0, r1
 801831a:	d200      	bcs.n	801831e <RegionCommonCalcBackOff+0x84>
 801831c:	1c23      	adds	r3, r4, #0
 801831e:	8013      	strh	r3, [r2, #0]
        // Reset the timeoff if the last frame was not a join request and when the duty cycle is not enabled
        if( ( calcBackOffParams->DutyCycleEnabled == false ) && ( calcBackOffParams->LastTxIsJoinRequest == false ) )
 8018320:	687b      	ldr	r3, [r7, #4]
 8018322:	7a9b      	ldrb	r3, [r3, #10]
 8018324:	2201      	movs	r2, #1
 8018326:	4053      	eors	r3, r2
 8018328:	b2db      	uxtb	r3, r3
 801832a:	2b00      	cmp	r3, #0
 801832c:	d010      	beq.n	8018350 <RegionCommonCalcBackOff+0xb6>
 801832e:	687b      	ldr	r3, [r7, #4]
 8018330:	7a1b      	ldrb	r3, [r3, #8]
 8018332:	2201      	movs	r2, #1
 8018334:	4053      	eors	r3, r2
 8018336:	b2db      	uxtb	r3, r3
 8018338:	2b00      	cmp	r3, #0
 801833a:	d009      	beq.n	8018350 <RegionCommonCalcBackOff+0xb6>
        {
            // This is the case when the duty cycle is off and the last uplink frame was not a join.
            // This could happen in case of a rejoin, e.g. in compliance test mode.
            // In this special case we have to set the time off to 0, since the join duty cycle shall only
            // be applied after the first join request.
            calcBackOffParams->Bands[bandIdx].TimeOff = 0;
 801833c:	687b      	ldr	r3, [r7, #4]
 801833e:	685a      	ldr	r2, [r3, #4]
 8018340:	230f      	movs	r3, #15
 8018342:	18fb      	adds	r3, r7, r3
 8018344:	781b      	ldrb	r3, [r3, #0]
 8018346:	011b      	lsls	r3, r3, #4
 8018348:	18d3      	adds	r3, r2, r3
 801834a:	2200      	movs	r2, #0
 801834c:	60da      	str	r2, [r3, #12]
        else
        {
            calcBackOffParams->Bands[bandIdx].TimeOff = 0;
        }
    }
}
 801834e:	e02c      	b.n	80183aa <RegionCommonCalcBackOff+0x110>
            calcBackOffParams->Bands[bandIdx].TimeOff = calcBackOffParams->TxTimeOnAir * dutyCycle - calcBackOffParams->TxTimeOnAir;
 8018350:	230c      	movs	r3, #12
 8018352:	18fb      	adds	r3, r7, r3
 8018354:	881b      	ldrh	r3, [r3, #0]
 8018356:	1e5a      	subs	r2, r3, #1
 8018358:	687b      	ldr	r3, [r7, #4]
 801835a:	6919      	ldr	r1, [r3, #16]
 801835c:	687b      	ldr	r3, [r7, #4]
 801835e:	6858      	ldr	r0, [r3, #4]
 8018360:	230f      	movs	r3, #15
 8018362:	18fb      	adds	r3, r7, r3
 8018364:	781b      	ldrb	r3, [r3, #0]
 8018366:	011b      	lsls	r3, r3, #4
 8018368:	18c3      	adds	r3, r0, r3
 801836a:	434a      	muls	r2, r1
 801836c:	60da      	str	r2, [r3, #12]
}
 801836e:	e01c      	b.n	80183aa <RegionCommonCalcBackOff+0x110>
        if( calcBackOffParams->DutyCycleEnabled == true )
 8018370:	687b      	ldr	r3, [r7, #4]
 8018372:	7a9b      	ldrb	r3, [r3, #10]
 8018374:	2b00      	cmp	r3, #0
 8018376:	d00f      	beq.n	8018398 <RegionCommonCalcBackOff+0xfe>
            calcBackOffParams->Bands[bandIdx].TimeOff = calcBackOffParams->TxTimeOnAir * dutyCycle - calcBackOffParams->TxTimeOnAir;
 8018378:	230c      	movs	r3, #12
 801837a:	18fb      	adds	r3, r7, r3
 801837c:	881b      	ldrh	r3, [r3, #0]
 801837e:	1e5a      	subs	r2, r3, #1
 8018380:	687b      	ldr	r3, [r7, #4]
 8018382:	6919      	ldr	r1, [r3, #16]
 8018384:	687b      	ldr	r3, [r7, #4]
 8018386:	6858      	ldr	r0, [r3, #4]
 8018388:	230f      	movs	r3, #15
 801838a:	18fb      	adds	r3, r7, r3
 801838c:	781b      	ldrb	r3, [r3, #0]
 801838e:	011b      	lsls	r3, r3, #4
 8018390:	18c3      	adds	r3, r0, r3
 8018392:	434a      	muls	r2, r1
 8018394:	60da      	str	r2, [r3, #12]
}
 8018396:	e008      	b.n	80183aa <RegionCommonCalcBackOff+0x110>
            calcBackOffParams->Bands[bandIdx].TimeOff = 0;
 8018398:	687b      	ldr	r3, [r7, #4]
 801839a:	685a      	ldr	r2, [r3, #4]
 801839c:	230f      	movs	r3, #15
 801839e:	18fb      	adds	r3, r7, r3
 80183a0:	781b      	ldrb	r3, [r3, #0]
 80183a2:	011b      	lsls	r3, r3, #4
 80183a4:	18d3      	adds	r3, r2, r3
 80183a6:	2200      	movs	r2, #0
 80183a8:	60da      	str	r2, [r3, #12]
}
 80183aa:	46c0      	nop			; (mov r8, r8)
 80183ac:	46bd      	mov	sp, r7
 80183ae:	b005      	add	sp, #20
 80183b0:	bdf0      	pop	{r4, r5, r6, r7, pc}

080183b2 <GetNextLowerTxDr>:
 */
static RegionEU868NvmCtx_t NvmCtx;

// Static functions
static int8_t GetNextLowerTxDr( int8_t dr, int8_t minDr )
{
 80183b2:	b580      	push	{r7, lr}
 80183b4:	b084      	sub	sp, #16
 80183b6:	af00      	add	r7, sp, #0
 80183b8:	0002      	movs	r2, r0
 80183ba:	1dfb      	adds	r3, r7, #7
 80183bc:	701a      	strb	r2, [r3, #0]
 80183be:	1dbb      	adds	r3, r7, #6
 80183c0:	1c0a      	adds	r2, r1, #0
 80183c2:	701a      	strb	r2, [r3, #0]
    uint8_t nextLowerDr = 0;
 80183c4:	210f      	movs	r1, #15
 80183c6:	187b      	adds	r3, r7, r1
 80183c8:	2200      	movs	r2, #0
 80183ca:	701a      	strb	r2, [r3, #0]

    if( dr == minDr )
 80183cc:	1dfa      	adds	r2, r7, #7
 80183ce:	1dbb      	adds	r3, r7, #6
 80183d0:	7812      	ldrb	r2, [r2, #0]
 80183d2:	b252      	sxtb	r2, r2
 80183d4:	781b      	ldrb	r3, [r3, #0]
 80183d6:	b25b      	sxtb	r3, r3
 80183d8:	429a      	cmp	r2, r3
 80183da:	d104      	bne.n	80183e6 <GetNextLowerTxDr+0x34>
    {
        nextLowerDr = minDr;
 80183dc:	187b      	adds	r3, r7, r1
 80183de:	1dba      	adds	r2, r7, #6
 80183e0:	7812      	ldrb	r2, [r2, #0]
 80183e2:	701a      	strb	r2, [r3, #0]
 80183e4:	e005      	b.n	80183f2 <GetNextLowerTxDr+0x40>
    }
    else
    {
        nextLowerDr = dr - 1;
 80183e6:	1dfb      	adds	r3, r7, #7
 80183e8:	781a      	ldrb	r2, [r3, #0]
 80183ea:	230f      	movs	r3, #15
 80183ec:	18fb      	adds	r3, r7, r3
 80183ee:	3a01      	subs	r2, #1
 80183f0:	701a      	strb	r2, [r3, #0]
    }
    return nextLowerDr;
 80183f2:	230f      	movs	r3, #15
 80183f4:	18fb      	adds	r3, r7, r3
 80183f6:	781b      	ldrb	r3, [r3, #0]
 80183f8:	b25b      	sxtb	r3, r3
}
 80183fa:	0018      	movs	r0, r3
 80183fc:	46bd      	mov	sp, r7
 80183fe:	b004      	add	sp, #16
 8018400:	bd80      	pop	{r7, pc}
	...

08018404 <GetBandwidth>:

static uint32_t GetBandwidth( uint32_t drIndex )
{
 8018404:	b580      	push	{r7, lr}
 8018406:	b082      	sub	sp, #8
 8018408:	af00      	add	r7, sp, #0
 801840a:	6078      	str	r0, [r7, #4]
    switch( BandwidthsEU868[drIndex] )
 801840c:	4b09      	ldr	r3, [pc, #36]	; (8018434 <GetBandwidth+0x30>)
 801840e:	687a      	ldr	r2, [r7, #4]
 8018410:	0092      	lsls	r2, r2, #2
 8018412:	58d3      	ldr	r3, [r2, r3]
 8018414:	4a08      	ldr	r2, [pc, #32]	; (8018438 <GetBandwidth+0x34>)
 8018416:	4293      	cmp	r3, r2
 8018418:	d004      	beq.n	8018424 <GetBandwidth+0x20>
 801841a:	4a08      	ldr	r2, [pc, #32]	; (801843c <GetBandwidth+0x38>)
 801841c:	4293      	cmp	r3, r2
 801841e:	d003      	beq.n	8018428 <GetBandwidth+0x24>
    {
        default:
        case 125000:
            return 0;
 8018420:	2300      	movs	r3, #0
 8018422:	e002      	b.n	801842a <GetBandwidth+0x26>
        case 250000:
            return 1;
 8018424:	2301      	movs	r3, #1
 8018426:	e000      	b.n	801842a <GetBandwidth+0x26>
        case 500000:
            return 2;
 8018428:	2302      	movs	r3, #2
    }
}
 801842a:	0018      	movs	r0, r3
 801842c:	46bd      	mov	sp, r7
 801842e:	b002      	add	sp, #8
 8018430:	bd80      	pop	{r7, pc}
 8018432:	46c0      	nop			; (mov r8, r8)
 8018434:	0801f470 	.word	0x0801f470
 8018438:	0003d090 	.word	0x0003d090
 801843c:	0007a120 	.word	0x0007a120

08018440 <LimitTxPower>:

static int8_t LimitTxPower( int8_t txPower, int8_t maxBandTxPower, int8_t datarate, uint16_t* channelsMask )
{
 8018440:	b590      	push	{r4, r7, lr}
 8018442:	b085      	sub	sp, #20
 8018444:	af00      	add	r7, sp, #0
 8018446:	0004      	movs	r4, r0
 8018448:	0008      	movs	r0, r1
 801844a:	0011      	movs	r1, r2
 801844c:	603b      	str	r3, [r7, #0]
 801844e:	1dfb      	adds	r3, r7, #7
 8018450:	1c22      	adds	r2, r4, #0
 8018452:	701a      	strb	r2, [r3, #0]
 8018454:	1dbb      	adds	r3, r7, #6
 8018456:	1c02      	adds	r2, r0, #0
 8018458:	701a      	strb	r2, [r3, #0]
 801845a:	1d7b      	adds	r3, r7, #5
 801845c:	1c0a      	adds	r2, r1, #0
 801845e:	701a      	strb	r2, [r3, #0]
    int8_t txPowerResult = txPower;
 8018460:	210f      	movs	r1, #15
 8018462:	187b      	adds	r3, r7, r1
 8018464:	1dfa      	adds	r2, r7, #7
 8018466:	7812      	ldrb	r2, [r2, #0]
 8018468:	701a      	strb	r2, [r3, #0]

    // Limit tx power to the band max
    txPowerResult =  MAX( txPower, maxBandTxPower );
 801846a:	187a      	adds	r2, r7, r1
 801846c:	1dbb      	adds	r3, r7, #6
 801846e:	1df9      	adds	r1, r7, #7
 8018470:	780c      	ldrb	r4, [r1, #0]
 8018472:	781b      	ldrb	r3, [r3, #0]
 8018474:	b258      	sxtb	r0, r3
 8018476:	b261      	sxtb	r1, r4
 8018478:	4288      	cmp	r0, r1
 801847a:	da00      	bge.n	801847e <LimitTxPower+0x3e>
 801847c:	1c23      	adds	r3, r4, #0
 801847e:	7013      	strb	r3, [r2, #0]

    return txPowerResult;
 8018480:	230f      	movs	r3, #15
 8018482:	18fb      	adds	r3, r7, r3
 8018484:	781b      	ldrb	r3, [r3, #0]
 8018486:	b25b      	sxtb	r3, r3
}
 8018488:	0018      	movs	r0, r3
 801848a:	46bd      	mov	sp, r7
 801848c:	b005      	add	sp, #20
 801848e:	bd90      	pop	{r4, r7, pc}

08018490 <VerifyRfFreq>:

static bool VerifyRfFreq( uint32_t freq, uint8_t *band )
{
 8018490:	b580      	push	{r7, lr}
 8018492:	b082      	sub	sp, #8
 8018494:	af00      	add	r7, sp, #0
 8018496:	6078      	str	r0, [r7, #4]
 8018498:	6039      	str	r1, [r7, #0]
    // Check radio driver support
    if( Radio.CheckRfFrequency( freq ) == false )
 801849a:	4b2e      	ldr	r3, [pc, #184]	; (8018554 <VerifyRfFreq+0xc4>)
 801849c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801849e:	687a      	ldr	r2, [r7, #4]
 80184a0:	0010      	movs	r0, r2
 80184a2:	4798      	blx	r3
 80184a4:	0003      	movs	r3, r0
 80184a6:	001a      	movs	r2, r3
 80184a8:	2301      	movs	r3, #1
 80184aa:	4053      	eors	r3, r2
 80184ac:	b2db      	uxtb	r3, r3
 80184ae:	2b00      	cmp	r3, #0
 80184b0:	d001      	beq.n	80184b6 <VerifyRfFreq+0x26>
    {
        return false;
 80184b2:	2300      	movs	r3, #0
 80184b4:	e04a      	b.n	801854c <VerifyRfFreq+0xbc>
    }

    // Check frequency bands
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 80184b6:	687b      	ldr	r3, [r7, #4]
 80184b8:	4a27      	ldr	r2, [pc, #156]	; (8018558 <VerifyRfFreq+0xc8>)
 80184ba:	4293      	cmp	r3, r2
 80184bc:	d907      	bls.n	80184ce <VerifyRfFreq+0x3e>
 80184be:	687b      	ldr	r3, [r7, #4]
 80184c0:	4a26      	ldr	r2, [pc, #152]	; (801855c <VerifyRfFreq+0xcc>)
 80184c2:	4293      	cmp	r3, r2
 80184c4:	d803      	bhi.n	80184ce <VerifyRfFreq+0x3e>
    {
        *band = 2;
 80184c6:	683b      	ldr	r3, [r7, #0]
 80184c8:	2202      	movs	r2, #2
 80184ca:	701a      	strb	r2, [r3, #0]
 80184cc:	e03d      	b.n	801854a <VerifyRfFreq+0xba>
    }
    else if( ( freq >= 865000000 ) && ( freq <= 868000000 ) )
 80184ce:	687b      	ldr	r3, [r7, #4]
 80184d0:	4a22      	ldr	r2, [pc, #136]	; (801855c <VerifyRfFreq+0xcc>)
 80184d2:	4293      	cmp	r3, r2
 80184d4:	d907      	bls.n	80184e6 <VerifyRfFreq+0x56>
 80184d6:	687b      	ldr	r3, [r7, #4]
 80184d8:	4a21      	ldr	r2, [pc, #132]	; (8018560 <VerifyRfFreq+0xd0>)
 80184da:	4293      	cmp	r3, r2
 80184dc:	d803      	bhi.n	80184e6 <VerifyRfFreq+0x56>
    {
        *band = 0;
 80184de:	683b      	ldr	r3, [r7, #0]
 80184e0:	2200      	movs	r2, #0
 80184e2:	701a      	strb	r2, [r3, #0]
 80184e4:	e031      	b.n	801854a <VerifyRfFreq+0xba>
    }
    else if( ( freq > 868000000 ) && ( freq <= 868600000 ) )
 80184e6:	687b      	ldr	r3, [r7, #4]
 80184e8:	4a1d      	ldr	r2, [pc, #116]	; (8018560 <VerifyRfFreq+0xd0>)
 80184ea:	4293      	cmp	r3, r2
 80184ec:	d907      	bls.n	80184fe <VerifyRfFreq+0x6e>
 80184ee:	687b      	ldr	r3, [r7, #4]
 80184f0:	4a1c      	ldr	r2, [pc, #112]	; (8018564 <VerifyRfFreq+0xd4>)
 80184f2:	4293      	cmp	r3, r2
 80184f4:	d803      	bhi.n	80184fe <VerifyRfFreq+0x6e>
    {
        *band = 1;
 80184f6:	683b      	ldr	r3, [r7, #0]
 80184f8:	2201      	movs	r2, #1
 80184fa:	701a      	strb	r2, [r3, #0]
 80184fc:	e025      	b.n	801854a <VerifyRfFreq+0xba>
    }
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 80184fe:	687b      	ldr	r3, [r7, #4]
 8018500:	4a19      	ldr	r2, [pc, #100]	; (8018568 <VerifyRfFreq+0xd8>)
 8018502:	4293      	cmp	r3, r2
 8018504:	d907      	bls.n	8018516 <VerifyRfFreq+0x86>
 8018506:	687b      	ldr	r3, [r7, #4]
 8018508:	4a18      	ldr	r2, [pc, #96]	; (801856c <VerifyRfFreq+0xdc>)
 801850a:	4293      	cmp	r3, r2
 801850c:	d803      	bhi.n	8018516 <VerifyRfFreq+0x86>
    {
        *band = 5;
 801850e:	683b      	ldr	r3, [r7, #0]
 8018510:	2205      	movs	r2, #5
 8018512:	701a      	strb	r2, [r3, #0]
 8018514:	e019      	b.n	801854a <VerifyRfFreq+0xba>
    }
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 8018516:	687b      	ldr	r3, [r7, #4]
 8018518:	4a15      	ldr	r2, [pc, #84]	; (8018570 <VerifyRfFreq+0xe0>)
 801851a:	4293      	cmp	r3, r2
 801851c:	d907      	bls.n	801852e <VerifyRfFreq+0x9e>
 801851e:	687b      	ldr	r3, [r7, #4]
 8018520:	4a14      	ldr	r2, [pc, #80]	; (8018574 <VerifyRfFreq+0xe4>)
 8018522:	4293      	cmp	r3, r2
 8018524:	d803      	bhi.n	801852e <VerifyRfFreq+0x9e>
    {
        *band = 3;
 8018526:	683b      	ldr	r3, [r7, #0]
 8018528:	2203      	movs	r2, #3
 801852a:	701a      	strb	r2, [r3, #0]
 801852c:	e00d      	b.n	801854a <VerifyRfFreq+0xba>
    }
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 801852e:	687b      	ldr	r3, [r7, #4]
 8018530:	4a11      	ldr	r2, [pc, #68]	; (8018578 <VerifyRfFreq+0xe8>)
 8018532:	4293      	cmp	r3, r2
 8018534:	d907      	bls.n	8018546 <VerifyRfFreq+0xb6>
 8018536:	687b      	ldr	r3, [r7, #4]
 8018538:	4a10      	ldr	r2, [pc, #64]	; (801857c <VerifyRfFreq+0xec>)
 801853a:	4293      	cmp	r3, r2
 801853c:	d803      	bhi.n	8018546 <VerifyRfFreq+0xb6>
    {
        *band = 4;
 801853e:	683b      	ldr	r3, [r7, #0]
 8018540:	2204      	movs	r2, #4
 8018542:	701a      	strb	r2, [r3, #0]
 8018544:	e001      	b.n	801854a <VerifyRfFreq+0xba>
    }
    else
    {
        return false;
 8018546:	2300      	movs	r3, #0
 8018548:	e000      	b.n	801854c <VerifyRfFreq+0xbc>
    }
    return true;
 801854a:	2301      	movs	r3, #1
}
 801854c:	0018      	movs	r0, r3
 801854e:	46bd      	mov	sp, r7
 8018550:	b002      	add	sp, #8
 8018552:	bd80      	pop	{r7, pc}
 8018554:	0801ebd0 	.word	0x0801ebd0
 8018558:	337055bf 	.word	0x337055bf
 801855c:	338eda3f 	.word	0x338eda3f
 8018560:	33bca100 	.word	0x33bca100
 8018564:	33c5c8c0 	.word	0x33c5c8c0
 8018568:	33c74f5f 	.word	0x33c74f5f
 801856c:	33cef080 	.word	0x33cef080
 8018570:	33d1fdbf 	.word	0x33d1fdbf
 8018574:	33d5ce50 	.word	0x33d5ce50
 8018578:	33d6919f 	.word	0x33d6919f
 801857c:	33db2580 	.word	0x33db2580

08018580 <CountNbOfEnabledChannels>:

static uint8_t CountNbOfEnabledChannels( bool joined, uint8_t datarate, uint16_t* channelsMask, ChannelParams_t* channels, Band_t* bands, uint8_t* enabledChannels, uint8_t* delayTx )
{
 8018580:	b5b0      	push	{r4, r5, r7, lr}
 8018582:	b086      	sub	sp, #24
 8018584:	af00      	add	r7, sp, #0
 8018586:	60ba      	str	r2, [r7, #8]
 8018588:	607b      	str	r3, [r7, #4]
 801858a:	230f      	movs	r3, #15
 801858c:	18fb      	adds	r3, r7, r3
 801858e:	1c02      	adds	r2, r0, #0
 8018590:	701a      	strb	r2, [r3, #0]
 8018592:	230e      	movs	r3, #14
 8018594:	18fb      	adds	r3, r7, r3
 8018596:	1c0a      	adds	r2, r1, #0
 8018598:	701a      	strb	r2, [r3, #0]
    uint8_t nbEnabledChannels = 0;
 801859a:	2317      	movs	r3, #23
 801859c:	18fb      	adds	r3, r7, r3
 801859e:	2200      	movs	r2, #0
 80185a0:	701a      	strb	r2, [r3, #0]
    uint8_t delayTransmission = 0;
 80185a2:	2316      	movs	r3, #22
 80185a4:	18fb      	adds	r3, r7, r3
 80185a6:	2200      	movs	r2, #0
 80185a8:	701a      	strb	r2, [r3, #0]

    for( uint8_t i = 0, k = 0; i < EU868_MAX_NB_CHANNELS; i += 16, k++ )
 80185aa:	2315      	movs	r3, #21
 80185ac:	18fb      	adds	r3, r7, r3
 80185ae:	2200      	movs	r2, #0
 80185b0:	701a      	strb	r2, [r3, #0]
 80185b2:	2314      	movs	r3, #20
 80185b4:	18fb      	adds	r3, r7, r3
 80185b6:	2200      	movs	r2, #0
 80185b8:	701a      	strb	r2, [r3, #0]
 80185ba:	e0b0      	b.n	801871e <CountNbOfEnabledChannels+0x19e>
    {
        for( uint8_t j = 0; j < 16; j++ )
 80185bc:	2313      	movs	r3, #19
 80185be:	18fb      	adds	r3, r7, r3
 80185c0:	2200      	movs	r2, #0
 80185c2:	701a      	strb	r2, [r3, #0]
 80185c4:	e099      	b.n	80186fa <CountNbOfEnabledChannels+0x17a>
        {
            if( ( channelsMask[k] & ( 1 << j ) ) != 0 )
 80185c6:	2314      	movs	r3, #20
 80185c8:	18fb      	adds	r3, r7, r3
 80185ca:	781b      	ldrb	r3, [r3, #0]
 80185cc:	005b      	lsls	r3, r3, #1
 80185ce:	68ba      	ldr	r2, [r7, #8]
 80185d0:	18d3      	adds	r3, r2, r3
 80185d2:	881b      	ldrh	r3, [r3, #0]
 80185d4:	001a      	movs	r2, r3
 80185d6:	2113      	movs	r1, #19
 80185d8:	187b      	adds	r3, r7, r1
 80185da:	781b      	ldrb	r3, [r3, #0]
 80185dc:	411a      	asrs	r2, r3
 80185de:	0013      	movs	r3, r2
 80185e0:	2201      	movs	r2, #1
 80185e2:	4013      	ands	r3, r2
 80185e4:	d100      	bne.n	80185e8 <CountNbOfEnabledChannels+0x68>
 80185e6:	e082      	b.n	80186ee <CountNbOfEnabledChannels+0x16e>
            {
                if( channels[i + j].Frequency == 0 )
 80185e8:	2315      	movs	r3, #21
 80185ea:	18fb      	adds	r3, r7, r3
 80185ec:	781a      	ldrb	r2, [r3, #0]
 80185ee:	187b      	adds	r3, r7, r1
 80185f0:	781b      	ldrb	r3, [r3, #0]
 80185f2:	18d3      	adds	r3, r2, r3
 80185f4:	001a      	movs	r2, r3
 80185f6:	0013      	movs	r3, r2
 80185f8:	005b      	lsls	r3, r3, #1
 80185fa:	189b      	adds	r3, r3, r2
 80185fc:	009b      	lsls	r3, r3, #2
 80185fe:	001a      	movs	r2, r3
 8018600:	687b      	ldr	r3, [r7, #4]
 8018602:	189b      	adds	r3, r3, r2
 8018604:	681b      	ldr	r3, [r3, #0]
 8018606:	2b00      	cmp	r3, #0
 8018608:	d06c      	beq.n	80186e4 <CountNbOfEnabledChannels+0x164>
                { // Check if the channel is enabled
                    continue;
                }
                if( joined == false )
 801860a:	230f      	movs	r3, #15
 801860c:	18fb      	adds	r3, r7, r3
 801860e:	781b      	ldrb	r3, [r3, #0]
 8018610:	2201      	movs	r2, #1
 8018612:	4053      	eors	r3, r2
 8018614:	b2db      	uxtb	r3, r3
 8018616:	2b00      	cmp	r3, #0
 8018618:	d007      	beq.n	801862a <CountNbOfEnabledChannels+0xaa>
                {
                    if( ( EU868_JOIN_CHANNELS & ( 1 << j ) ) == 0 )
 801861a:	187b      	adds	r3, r7, r1
 801861c:	781b      	ldrb	r3, [r3, #0]
 801861e:	2207      	movs	r2, #7
 8018620:	411a      	asrs	r2, r3
 8018622:	0013      	movs	r3, r2
 8018624:	2201      	movs	r2, #1
 8018626:	4013      	ands	r3, r2
 8018628:	d05e      	beq.n	80186e8 <CountNbOfEnabledChannels+0x168>
                    {
                        continue;
                    }
                }
                if( RegionCommonValueInRange( datarate, channels[i + j].DrRange.Fields.Min,
 801862a:	230e      	movs	r3, #14
 801862c:	18fb      	adds	r3, r7, r3
 801862e:	2000      	movs	r0, #0
 8018630:	5618      	ldrsb	r0, [r3, r0]
 8018632:	2415      	movs	r4, #21
 8018634:	193b      	adds	r3, r7, r4
 8018636:	781a      	ldrb	r2, [r3, #0]
 8018638:	2513      	movs	r5, #19
 801863a:	197b      	adds	r3, r7, r5
 801863c:	781b      	ldrb	r3, [r3, #0]
 801863e:	18d3      	adds	r3, r2, r3
 8018640:	001a      	movs	r2, r3
 8018642:	0013      	movs	r3, r2
 8018644:	005b      	lsls	r3, r3, #1
 8018646:	189b      	adds	r3, r3, r2
 8018648:	009b      	lsls	r3, r3, #2
 801864a:	001a      	movs	r2, r3
 801864c:	687b      	ldr	r3, [r7, #4]
 801864e:	189b      	adds	r3, r3, r2
 8018650:	7a1b      	ldrb	r3, [r3, #8]
 8018652:	011b      	lsls	r3, r3, #4
 8018654:	b25b      	sxtb	r3, r3
 8018656:	111b      	asrs	r3, r3, #4
 8018658:	b25b      	sxtb	r3, r3
 801865a:	0019      	movs	r1, r3
                                              channels[i + j].DrRange.Fields.Max ) == false )
 801865c:	193b      	adds	r3, r7, r4
 801865e:	781a      	ldrb	r2, [r3, #0]
 8018660:	197b      	adds	r3, r7, r5
 8018662:	781b      	ldrb	r3, [r3, #0]
 8018664:	18d3      	adds	r3, r2, r3
 8018666:	001a      	movs	r2, r3
 8018668:	0013      	movs	r3, r2
 801866a:	005b      	lsls	r3, r3, #1
 801866c:	189b      	adds	r3, r3, r2
 801866e:	009b      	lsls	r3, r3, #2
 8018670:	001a      	movs	r2, r3
 8018672:	687b      	ldr	r3, [r7, #4]
 8018674:	189b      	adds	r3, r3, r2
 8018676:	7a1b      	ldrb	r3, [r3, #8]
 8018678:	b25b      	sxtb	r3, r3
 801867a:	111b      	asrs	r3, r3, #4
 801867c:	b25b      	sxtb	r3, r3
                if( RegionCommonValueInRange( datarate, channels[i + j].DrRange.Fields.Min,
 801867e:	001a      	movs	r2, r3
 8018680:	f7ff fa5f 	bl	8017b42 <RegionCommonValueInRange>
 8018684:	1e03      	subs	r3, r0, #0
 8018686:	d031      	beq.n	80186ec <CountNbOfEnabledChannels+0x16c>
                { // Check if the current channel selection supports the given datarate
                    continue;
                }
                if( bands[channels[i + j].Band].TimeOff > 0 )
 8018688:	193b      	adds	r3, r7, r4
 801868a:	781a      	ldrb	r2, [r3, #0]
 801868c:	197b      	adds	r3, r7, r5
 801868e:	781b      	ldrb	r3, [r3, #0]
 8018690:	18d3      	adds	r3, r2, r3
 8018692:	001a      	movs	r2, r3
 8018694:	0013      	movs	r3, r2
 8018696:	005b      	lsls	r3, r3, #1
 8018698:	189b      	adds	r3, r3, r2
 801869a:	009b      	lsls	r3, r3, #2
 801869c:	001a      	movs	r2, r3
 801869e:	687b      	ldr	r3, [r7, #4]
 80186a0:	189b      	adds	r3, r3, r2
 80186a2:	7a5b      	ldrb	r3, [r3, #9]
 80186a4:	011b      	lsls	r3, r3, #4
 80186a6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80186a8:	18d3      	adds	r3, r2, r3
 80186aa:	68db      	ldr	r3, [r3, #12]
 80186ac:	2b00      	cmp	r3, #0
 80186ae:	d006      	beq.n	80186be <CountNbOfEnabledChannels+0x13e>
                { // Check if the band is available for transmission
                    delayTransmission++;
 80186b0:	2116      	movs	r1, #22
 80186b2:	187b      	adds	r3, r7, r1
 80186b4:	781a      	ldrb	r2, [r3, #0]
 80186b6:	187b      	adds	r3, r7, r1
 80186b8:	3201      	adds	r2, #1
 80186ba:	701a      	strb	r2, [r3, #0]
                    continue;
 80186bc:	e017      	b.n	80186ee <CountNbOfEnabledChannels+0x16e>
                }
                enabledChannels[nbEnabledChannels++] = i + j;
 80186be:	2217      	movs	r2, #23
 80186c0:	18bb      	adds	r3, r7, r2
 80186c2:	781b      	ldrb	r3, [r3, #0]
 80186c4:	18ba      	adds	r2, r7, r2
 80186c6:	1c59      	adds	r1, r3, #1
 80186c8:	7011      	strb	r1, [r2, #0]
 80186ca:	001a      	movs	r2, r3
 80186cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80186ce:	189b      	adds	r3, r3, r2
 80186d0:	2215      	movs	r2, #21
 80186d2:	18b9      	adds	r1, r7, r2
 80186d4:	2213      	movs	r2, #19
 80186d6:	18ba      	adds	r2, r7, r2
 80186d8:	7809      	ldrb	r1, [r1, #0]
 80186da:	7812      	ldrb	r2, [r2, #0]
 80186dc:	188a      	adds	r2, r1, r2
 80186de:	b2d2      	uxtb	r2, r2
 80186e0:	701a      	strb	r2, [r3, #0]
 80186e2:	e004      	b.n	80186ee <CountNbOfEnabledChannels+0x16e>
                    continue;
 80186e4:	46c0      	nop			; (mov r8, r8)
 80186e6:	e002      	b.n	80186ee <CountNbOfEnabledChannels+0x16e>
                        continue;
 80186e8:	46c0      	nop			; (mov r8, r8)
 80186ea:	e000      	b.n	80186ee <CountNbOfEnabledChannels+0x16e>
                    continue;
 80186ec:	46c0      	nop			; (mov r8, r8)
        for( uint8_t j = 0; j < 16; j++ )
 80186ee:	2113      	movs	r1, #19
 80186f0:	187b      	adds	r3, r7, r1
 80186f2:	781a      	ldrb	r2, [r3, #0]
 80186f4:	187b      	adds	r3, r7, r1
 80186f6:	3201      	adds	r2, #1
 80186f8:	701a      	strb	r2, [r3, #0]
 80186fa:	2313      	movs	r3, #19
 80186fc:	18fb      	adds	r3, r7, r3
 80186fe:	781b      	ldrb	r3, [r3, #0]
 8018700:	2b0f      	cmp	r3, #15
 8018702:	d800      	bhi.n	8018706 <CountNbOfEnabledChannels+0x186>
 8018704:	e75f      	b.n	80185c6 <CountNbOfEnabledChannels+0x46>
    for( uint8_t i = 0, k = 0; i < EU868_MAX_NB_CHANNELS; i += 16, k++ )
 8018706:	2215      	movs	r2, #21
 8018708:	18bb      	adds	r3, r7, r2
 801870a:	18ba      	adds	r2, r7, r2
 801870c:	7812      	ldrb	r2, [r2, #0]
 801870e:	3210      	adds	r2, #16
 8018710:	701a      	strb	r2, [r3, #0]
 8018712:	2114      	movs	r1, #20
 8018714:	187b      	adds	r3, r7, r1
 8018716:	781a      	ldrb	r2, [r3, #0]
 8018718:	187b      	adds	r3, r7, r1
 801871a:	3201      	adds	r2, #1
 801871c:	701a      	strb	r2, [r3, #0]
 801871e:	2315      	movs	r3, #21
 8018720:	18fb      	adds	r3, r7, r3
 8018722:	781b      	ldrb	r3, [r3, #0]
 8018724:	2b0f      	cmp	r3, #15
 8018726:	d800      	bhi.n	801872a <CountNbOfEnabledChannels+0x1aa>
 8018728:	e748      	b.n	80185bc <CountNbOfEnabledChannels+0x3c>
            }
        }
    }

    *delayTx = delayTransmission;
 801872a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801872c:	2216      	movs	r2, #22
 801872e:	18ba      	adds	r2, r7, r2
 8018730:	7812      	ldrb	r2, [r2, #0]
 8018732:	701a      	strb	r2, [r3, #0]
    return nbEnabledChannels;
 8018734:	2317      	movs	r3, #23
 8018736:	18fb      	adds	r3, r7, r3
 8018738:	781b      	ldrb	r3, [r3, #0]
}
 801873a:	0018      	movs	r0, r3
 801873c:	46bd      	mov	sp, r7
 801873e:	b006      	add	sp, #24
 8018740:	bdb0      	pop	{r4, r5, r7, pc}
	...

08018744 <RegionEU868GetPhyParam>:

PhyParam_t RegionEU868GetPhyParam( GetPhyParams_t* getPhy )
{
 8018744:	b580      	push	{r7, lr}
 8018746:	b084      	sub	sp, #16
 8018748:	af00      	add	r7, sp, #0
 801874a:	6078      	str	r0, [r7, #4]
    PhyParam_t phyParam = { 0 };
 801874c:	2308      	movs	r3, #8
 801874e:	18fb      	adds	r3, r7, r3
 8018750:	2200      	movs	r2, #0
 8018752:	601a      	str	r2, [r3, #0]

    switch( getPhy->Attribute )
 8018754:	687b      	ldr	r3, [r7, #4]
 8018756:	781b      	ldrb	r3, [r3, #0]
 8018758:	2b35      	cmp	r3, #53	; 0x35
 801875a:	d900      	bls.n	801875e <RegionEU868GetPhyParam+0x1a>
 801875c:	e0ce      	b.n	80188fc <RegionEU868GetPhyParam+0x1b8>
 801875e:	009a      	lsls	r2, r3, #2
 8018760:	4b6e      	ldr	r3, [pc, #440]	; (801891c <RegionEU868GetPhyParam+0x1d8>)
 8018762:	18d3      	adds	r3, r2, r3
 8018764:	681b      	ldr	r3, [r3, #0]
 8018766:	469f      	mov	pc, r3
    {
        case PHY_MIN_RX_DR:
        {
            phyParam.Value = EU868_RX_MIN_DATARATE;
 8018768:	2308      	movs	r3, #8
 801876a:	18fb      	adds	r3, r7, r3
 801876c:	2200      	movs	r2, #0
 801876e:	601a      	str	r2, [r3, #0]
            break;
 8018770:	e0c5      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_MIN_TX_DR:
        {
            phyParam.Value = EU868_TX_MIN_DATARATE;
 8018772:	2308      	movs	r3, #8
 8018774:	18fb      	adds	r3, r7, r3
 8018776:	2200      	movs	r2, #0
 8018778:	601a      	str	r2, [r3, #0]
            break;
 801877a:	e0c0      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_DEF_TX_DR:
        {
            phyParam.Value = EU868_DEFAULT_DATARATE;
 801877c:	2308      	movs	r3, #8
 801877e:	18fb      	adds	r3, r7, r3
 8018780:	2200      	movs	r2, #0
 8018782:	601a      	str	r2, [r3, #0]
            break;
 8018784:	e0bb      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_NEXT_LOWER_TX_DR:
        {
            phyParam.Value = GetNextLowerTxDr( getPhy->Datarate, EU868_TX_MIN_DATARATE );
 8018786:	687b      	ldr	r3, [r7, #4]
 8018788:	785b      	ldrb	r3, [r3, #1]
 801878a:	b25b      	sxtb	r3, r3
 801878c:	2100      	movs	r1, #0
 801878e:	0018      	movs	r0, r3
 8018790:	f7ff fe0f 	bl	80183b2 <GetNextLowerTxDr>
 8018794:	0003      	movs	r3, r0
 8018796:	001a      	movs	r2, r3
 8018798:	2308      	movs	r3, #8
 801879a:	18fb      	adds	r3, r7, r3
 801879c:	601a      	str	r2, [r3, #0]
            break;
 801879e:	e0ae      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_MAX_TX_POWER:
        {
            phyParam.Value = EU868_MAX_TX_POWER;
 80187a0:	2308      	movs	r3, #8
 80187a2:	18fb      	adds	r3, r7, r3
 80187a4:	2200      	movs	r2, #0
 80187a6:	601a      	str	r2, [r3, #0]
            break;
 80187a8:	e0a9      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_DEF_TX_POWER:
        {
            phyParam.Value = EU868_DEFAULT_TX_POWER;
 80187aa:	2308      	movs	r3, #8
 80187ac:	18fb      	adds	r3, r7, r3
 80187ae:	2200      	movs	r2, #0
 80187b0:	601a      	str	r2, [r3, #0]
            break;
 80187b2:	e0a4      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_DEF_ADR_ACK_LIMIT:
        {
            phyParam.Value = EU868_ADR_ACK_LIMIT;
 80187b4:	2308      	movs	r3, #8
 80187b6:	18fb      	adds	r3, r7, r3
 80187b8:	2240      	movs	r2, #64	; 0x40
 80187ba:	601a      	str	r2, [r3, #0]
            break;
 80187bc:	e09f      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_DEF_ADR_ACK_DELAY:
        {
            phyParam.Value = EU868_ADR_ACK_DELAY;
 80187be:	2308      	movs	r3, #8
 80187c0:	18fb      	adds	r3, r7, r3
 80187c2:	2220      	movs	r2, #32
 80187c4:	601a      	str	r2, [r3, #0]
            break;
 80187c6:	e09a      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_MAX_PAYLOAD:
        {
            phyParam.Value = MaxPayloadOfDatarateEU868[getPhy->Datarate];
 80187c8:	687b      	ldr	r3, [r7, #4]
 80187ca:	785b      	ldrb	r3, [r3, #1]
 80187cc:	b25b      	sxtb	r3, r3
 80187ce:	001a      	movs	r2, r3
 80187d0:	4b53      	ldr	r3, [pc, #332]	; (8018920 <RegionEU868GetPhyParam+0x1dc>)
 80187d2:	5c9b      	ldrb	r3, [r3, r2]
 80187d4:	001a      	movs	r2, r3
 80187d6:	2308      	movs	r3, #8
 80187d8:	18fb      	adds	r3, r7, r3
 80187da:	601a      	str	r2, [r3, #0]
            break;
 80187dc:	e08f      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_MAX_PAYLOAD_REPEATER:
        {
            phyParam.Value = MaxPayloadOfDatarateRepeaterEU868[getPhy->Datarate];
 80187de:	687b      	ldr	r3, [r7, #4]
 80187e0:	785b      	ldrb	r3, [r3, #1]
 80187e2:	b25b      	sxtb	r3, r3
 80187e4:	001a      	movs	r2, r3
 80187e6:	4b4f      	ldr	r3, [pc, #316]	; (8018924 <RegionEU868GetPhyParam+0x1e0>)
 80187e8:	5c9b      	ldrb	r3, [r3, r2]
 80187ea:	001a      	movs	r2, r3
 80187ec:	2308      	movs	r3, #8
 80187ee:	18fb      	adds	r3, r7, r3
 80187f0:	601a      	str	r2, [r3, #0]
            break;
 80187f2:	e084      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_DUTY_CYCLE:
        {
            phyParam.Value = EU868_DUTY_CYCLE_ENABLED;
 80187f4:	2308      	movs	r3, #8
 80187f6:	18fb      	adds	r3, r7, r3
 80187f8:	2201      	movs	r2, #1
 80187fa:	601a      	str	r2, [r3, #0]
            break;
 80187fc:	e07f      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_MAX_RX_WINDOW:
        {
            phyParam.Value = EU868_MAX_RX_WINDOW;
 80187fe:	2308      	movs	r3, #8
 8018800:	18fb      	adds	r3, r7, r3
 8018802:	4a49      	ldr	r2, [pc, #292]	; (8018928 <RegionEU868GetPhyParam+0x1e4>)
 8018804:	601a      	str	r2, [r3, #0]
            break;
 8018806:	e07a      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_RECEIVE_DELAY1:
        {
            phyParam.Value = EU868_RECEIVE_DELAY1;
 8018808:	2308      	movs	r3, #8
 801880a:	18fb      	adds	r3, r7, r3
 801880c:	22fa      	movs	r2, #250	; 0xfa
 801880e:	0092      	lsls	r2, r2, #2
 8018810:	601a      	str	r2, [r3, #0]
            break;
 8018812:	e074      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_RECEIVE_DELAY2:
        {
            phyParam.Value = EU868_RECEIVE_DELAY2;
 8018814:	2308      	movs	r3, #8
 8018816:	18fb      	adds	r3, r7, r3
 8018818:	22fa      	movs	r2, #250	; 0xfa
 801881a:	00d2      	lsls	r2, r2, #3
 801881c:	601a      	str	r2, [r3, #0]
            break;
 801881e:	e06e      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_JOIN_ACCEPT_DELAY1:
        {
            phyParam.Value = EU868_JOIN_ACCEPT_DELAY1;
 8018820:	2308      	movs	r3, #8
 8018822:	18fb      	adds	r3, r7, r3
 8018824:	4a41      	ldr	r2, [pc, #260]	; (801892c <RegionEU868GetPhyParam+0x1e8>)
 8018826:	601a      	str	r2, [r3, #0]
            break;
 8018828:	e069      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_JOIN_ACCEPT_DELAY2:
        {
            phyParam.Value = EU868_JOIN_ACCEPT_DELAY2;
 801882a:	2308      	movs	r3, #8
 801882c:	18fb      	adds	r3, r7, r3
 801882e:	4a40      	ldr	r2, [pc, #256]	; (8018930 <RegionEU868GetPhyParam+0x1ec>)
 8018830:	601a      	str	r2, [r3, #0]
            break;
 8018832:	e064      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_MAX_FCNT_GAP:
        {
            phyParam.Value = EU868_MAX_FCNT_GAP;
 8018834:	2308      	movs	r3, #8
 8018836:	18fb      	adds	r3, r7, r3
 8018838:	2280      	movs	r2, #128	; 0x80
 801883a:	01d2      	lsls	r2, r2, #7
 801883c:	601a      	str	r2, [r3, #0]
            break;
 801883e:	e05e      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_ACK_TIMEOUT:
        {
            phyParam.Value = ( EU868_ACKTIMEOUT + randr( -EU868_ACK_TIMEOUT_RND, EU868_ACK_TIMEOUT_RND ) );
 8018840:	23fa      	movs	r3, #250	; 0xfa
 8018842:	009b      	lsls	r3, r3, #2
 8018844:	4a3b      	ldr	r2, [pc, #236]	; (8018934 <RegionEU868GetPhyParam+0x1f0>)
 8018846:	0019      	movs	r1, r3
 8018848:	0010      	movs	r0, r2
 801884a:	f002 fe67 	bl	801b51c <randr>
 801884e:	0003      	movs	r3, r0
 8018850:	22fa      	movs	r2, #250	; 0xfa
 8018852:	00d2      	lsls	r2, r2, #3
 8018854:	4694      	mov	ip, r2
 8018856:	4463      	add	r3, ip
 8018858:	001a      	movs	r2, r3
 801885a:	2308      	movs	r3, #8
 801885c:	18fb      	adds	r3, r7, r3
 801885e:	601a      	str	r2, [r3, #0]
            break;
 8018860:	e04d      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_DEF_DR1_OFFSET:
        {
            phyParam.Value = EU868_DEFAULT_RX1_DR_OFFSET;
 8018862:	2308      	movs	r3, #8
 8018864:	18fb      	adds	r3, r7, r3
 8018866:	2200      	movs	r2, #0
 8018868:	601a      	str	r2, [r3, #0]
            break;
 801886a:	e048      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_DEF_RX2_FREQUENCY:
        {
            phyParam.Value = EU868_RX_WND_2_FREQ;
 801886c:	2308      	movs	r3, #8
 801886e:	18fb      	adds	r3, r7, r3
 8018870:	4a31      	ldr	r2, [pc, #196]	; (8018938 <RegionEU868GetPhyParam+0x1f4>)
 8018872:	601a      	str	r2, [r3, #0]
            break;
 8018874:	e043      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_DEF_RX2_DR:
        {
            phyParam.Value = EU868_RX_WND_2_DR;
 8018876:	2308      	movs	r3, #8
 8018878:	18fb      	adds	r3, r7, r3
 801887a:	2200      	movs	r2, #0
 801887c:	601a      	str	r2, [r3, #0]
            break;
 801887e:	e03e      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_CHANNELS_MASK:
        {
            phyParam.ChannelsMask = NvmCtx.ChannelsMask;
 8018880:	2308      	movs	r3, #8
 8018882:	18fb      	adds	r3, r7, r3
 8018884:	4a2d      	ldr	r2, [pc, #180]	; (801893c <RegionEU868GetPhyParam+0x1f8>)
 8018886:	601a      	str	r2, [r3, #0]
            break;
 8018888:	e039      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_CHANNELS_DEFAULT_MASK:
        {
            phyParam.ChannelsMask = NvmCtx.ChannelsDefaultMask;
 801888a:	2308      	movs	r3, #8
 801888c:	18fb      	adds	r3, r7, r3
 801888e:	4a2c      	ldr	r2, [pc, #176]	; (8018940 <RegionEU868GetPhyParam+0x1fc>)
 8018890:	601a      	str	r2, [r3, #0]
            break;
 8018892:	e034      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_MAX_NB_CHANNELS:
        {
            phyParam.Value = EU868_MAX_NB_CHANNELS;
 8018894:	2308      	movs	r3, #8
 8018896:	18fb      	adds	r3, r7, r3
 8018898:	2210      	movs	r2, #16
 801889a:	601a      	str	r2, [r3, #0]
            break;
 801889c:	e02f      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_CHANNELS:
        {
            phyParam.Channels = NvmCtx.Channels;
 801889e:	2308      	movs	r3, #8
 80188a0:	18fb      	adds	r3, r7, r3
 80188a2:	4a28      	ldr	r2, [pc, #160]	; (8018944 <RegionEU868GetPhyParam+0x200>)
 80188a4:	601a      	str	r2, [r3, #0]
            break;
 80188a6:	e02a      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_DEF_UPLINK_DWELL_TIME:
        case PHY_DEF_DOWNLINK_DWELL_TIME:
        {
            phyParam.Value = 0;
 80188a8:	2308      	movs	r3, #8
 80188aa:	18fb      	adds	r3, r7, r3
 80188ac:	2200      	movs	r2, #0
 80188ae:	601a      	str	r2, [r3, #0]
            break;
 80188b0:	e025      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_DEF_MAX_EIRP:
        {
            phyParam.fValue = EU868_DEFAULT_MAX_EIRP;
 80188b2:	2308      	movs	r3, #8
 80188b4:	18fb      	adds	r3, r7, r3
 80188b6:	2283      	movs	r2, #131	; 0x83
 80188b8:	05d2      	lsls	r2, r2, #23
 80188ba:	601a      	str	r2, [r3, #0]
            break;
 80188bc:	e01f      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_DEF_ANTENNA_GAIN:
        {
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 80188be:	2308      	movs	r3, #8
 80188c0:	18fb      	adds	r3, r7, r3
 80188c2:	4a21      	ldr	r2, [pc, #132]	; (8018948 <RegionEU868GetPhyParam+0x204>)
 80188c4:	601a      	str	r2, [r3, #0]
            break;
 80188c6:	e01a      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_BEACON_CHANNEL_FREQ:
        {
            phyParam.Value = EU868_BEACON_CHANNEL_FREQ;
 80188c8:	2308      	movs	r3, #8
 80188ca:	18fb      	adds	r3, r7, r3
 80188cc:	4a1a      	ldr	r2, [pc, #104]	; (8018938 <RegionEU868GetPhyParam+0x1f4>)
 80188ce:	601a      	str	r2, [r3, #0]
            break;
 80188d0:	e015      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_BEACON_FORMAT:
        {
            phyParam.BeaconFormat.BeaconSize = EU868_BEACON_SIZE;
 80188d2:	2108      	movs	r1, #8
 80188d4:	187b      	adds	r3, r7, r1
 80188d6:	2211      	movs	r2, #17
 80188d8:	701a      	strb	r2, [r3, #0]
            phyParam.BeaconFormat.Rfu1Size = EU868_RFU1_SIZE;
 80188da:	187b      	adds	r3, r7, r1
 80188dc:	2202      	movs	r2, #2
 80188de:	705a      	strb	r2, [r3, #1]
            phyParam.BeaconFormat.Rfu2Size = EU868_RFU2_SIZE;
 80188e0:	187b      	adds	r3, r7, r1
 80188e2:	2200      	movs	r2, #0
 80188e4:	709a      	strb	r2, [r3, #2]
            break;
 80188e6:	e00a      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_BEACON_CHANNEL_DR:
        {
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 80188e8:	2308      	movs	r3, #8
 80188ea:	18fb      	adds	r3, r7, r3
 80188ec:	2203      	movs	r2, #3
 80188ee:	601a      	str	r2, [r3, #0]
            break;
 80188f0:	e005      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        case PHY_PING_SLOT_CHANNEL_DR:
        {
            phyParam.Value = EU868_PING_SLOT_CHANNEL_DR;
 80188f2:	2308      	movs	r3, #8
 80188f4:	18fb      	adds	r3, r7, r3
 80188f6:	2203      	movs	r2, #3
 80188f8:	601a      	str	r2, [r3, #0]
            break;
 80188fa:	e000      	b.n	80188fe <RegionEU868GetPhyParam+0x1ba>
        }
        default:
        {
            break;
 80188fc:	46c0      	nop			; (mov r8, r8)
        }
    }

    return phyParam;
 80188fe:	210c      	movs	r1, #12
 8018900:	187b      	adds	r3, r7, r1
 8018902:	2208      	movs	r2, #8
 8018904:	18ba      	adds	r2, r7, r2
 8018906:	6812      	ldr	r2, [r2, #0]
 8018908:	601a      	str	r2, [r3, #0]
 801890a:	187b      	adds	r3, r7, r1
 801890c:	2200      	movs	r2, #0
 801890e:	681a      	ldr	r2, [r3, #0]
 8018910:	0013      	movs	r3, r2
}
 8018912:	0018      	movs	r0, r3
 8018914:	46bd      	mov	sp, r7
 8018916:	b004      	add	sp, #16
 8018918:	bd80      	pop	{r7, pc}
 801891a:	46c0      	nop			; (mov r8, r8)
 801891c:	0801f4a0 	.word	0x0801f4a0
 8018920:	0801f490 	.word	0x0801f490
 8018924:	0801f498 	.word	0x0801f498
 8018928:	00000bb8 	.word	0x00000bb8
 801892c:	00001388 	.word	0x00001388
 8018930:	00001770 	.word	0x00001770
 8018934:	fffffc18 	.word	0xfffffc18
 8018938:	33d3e608 	.word	0x33d3e608
 801893c:	200011e0 	.word	0x200011e0
 8018940:	200011e2 	.word	0x200011e2
 8018944:	200010c0 	.word	0x200010c0
 8018948:	4009999a 	.word	0x4009999a

0801894c <RegionEU868SetBandTxDone>:

void RegionEU868SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 801894c:	b580      	push	{r7, lr}
 801894e:	b082      	sub	sp, #8
 8018950:	af00      	add	r7, sp, #0
 8018952:	6078      	str	r0, [r7, #4]
    RegionCommonSetBandTxDone( txDone->Joined, &NvmCtx.Bands[NvmCtx.Channels[txDone->Channel].Band], txDone->LastTxDoneTime );
 8018954:	687b      	ldr	r3, [r7, #4]
 8018956:	7858      	ldrb	r0, [r3, #1]
 8018958:	687b      	ldr	r3, [r7, #4]
 801895a:	781b      	ldrb	r3, [r3, #0]
 801895c:	0019      	movs	r1, r3
 801895e:	4a0a      	ldr	r2, [pc, #40]	; (8018988 <RegionEU868SetBandTxDone+0x3c>)
 8018960:	000b      	movs	r3, r1
 8018962:	005b      	lsls	r3, r3, #1
 8018964:	185b      	adds	r3, r3, r1
 8018966:	009b      	lsls	r3, r3, #2
 8018968:	18d3      	adds	r3, r2, r3
 801896a:	3309      	adds	r3, #9
 801896c:	781b      	ldrb	r3, [r3, #0]
 801896e:	330c      	adds	r3, #12
 8018970:	011a      	lsls	r2, r3, #4
 8018972:	4b05      	ldr	r3, [pc, #20]	; (8018988 <RegionEU868SetBandTxDone+0x3c>)
 8018974:	18d1      	adds	r1, r2, r3
 8018976:	687b      	ldr	r3, [r7, #4]
 8018978:	685b      	ldr	r3, [r3, #4]
 801897a:	001a      	movs	r2, r3
 801897c:	f7ff f9b9 	bl	8017cf2 <RegionCommonSetBandTxDone>
}
 8018980:	46c0      	nop			; (mov r8, r8)
 8018982:	46bd      	mov	sp, r7
 8018984:	b002      	add	sp, #8
 8018986:	bd80      	pop	{r7, pc}
 8018988:	200010c0 	.word	0x200010c0

0801898c <RegionEU868InitDefaults>:

void RegionEU868InitDefaults( InitDefaultsParams_t* params )
{
 801898c:	b590      	push	{r4, r7, lr}
 801898e:	b0ad      	sub	sp, #180	; 0xb4
 8018990:	af00      	add	r7, sp, #0
 8018992:	6078      	str	r0, [r7, #4]
    Band_t bands[EU868_MAX_NB_BANDS] =
 8018994:	2450      	movs	r4, #80	; 0x50
 8018996:	193b      	adds	r3, r7, r4
 8018998:	0018      	movs	r0, r3
 801899a:	2360      	movs	r3, #96	; 0x60
 801899c:	001a      	movs	r2, r3
 801899e:	2100      	movs	r1, #0
 80189a0:	f004 fdd8 	bl	801d554 <memset>
 80189a4:	0021      	movs	r1, r4
 80189a6:	187b      	adds	r3, r7, r1
 80189a8:	2264      	movs	r2, #100	; 0x64
 80189aa:	801a      	strh	r2, [r3, #0]
 80189ac:	187b      	adds	r3, r7, r1
 80189ae:	2264      	movs	r2, #100	; 0x64
 80189b0:	821a      	strh	r2, [r3, #16]
 80189b2:	187b      	adds	r3, r7, r1
 80189b4:	22fa      	movs	r2, #250	; 0xfa
 80189b6:	0092      	lsls	r2, r2, #2
 80189b8:	841a      	strh	r2, [r3, #32]
 80189ba:	187b      	adds	r3, r7, r1
 80189bc:	220a      	movs	r2, #10
 80189be:	861a      	strh	r2, [r3, #48]	; 0x30
 80189c0:	0008      	movs	r0, r1
 80189c2:	187b      	adds	r3, r7, r1
 80189c4:	2240      	movs	r2, #64	; 0x40
 80189c6:	2164      	movs	r1, #100	; 0x64
 80189c8:	5299      	strh	r1, [r3, r2]
 80189ca:	183b      	adds	r3, r7, r0
 80189cc:	2250      	movs	r2, #80	; 0x50
 80189ce:	21fa      	movs	r1, #250	; 0xfa
 80189d0:	0089      	lsls	r1, r1, #2
 80189d2:	5299      	strh	r1, [r3, r2]
        EU868_BAND3,
        EU868_BAND4,
        EU868_BAND5,
    };

    switch( params->Type )
 80189d4:	687b      	ldr	r3, [r7, #4]
 80189d6:	791b      	ldrb	r3, [r3, #4]
 80189d8:	2b02      	cmp	r3, #2
 80189da:	d026      	beq.n	8018a2a <RegionEU868InitDefaults+0x9e>
 80189dc:	dc4f      	bgt.n	8018a7e <RegionEU868InitDefaults+0xf2>
 80189de:	2b00      	cmp	r3, #0
 80189e0:	d002      	beq.n	80189e8 <RegionEU868InitDefaults+0x5c>
 80189e2:	2b01      	cmp	r3, #1
 80189e4:	d02e      	beq.n	8018a44 <RegionEU868InitDefaults+0xb8>
            NvmCtx.Channels[2] = ( ChannelParams_t ) EU868_LC3;
            break;
        }
        default:
        {
            break;
 80189e6:	e04a      	b.n	8018a7e <RegionEU868InitDefaults+0xf2>
            memcpy1( ( uint8_t* )NvmCtx.Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 80189e8:	2350      	movs	r3, #80	; 0x50
 80189ea:	18f9      	adds	r1, r7, r3
 80189ec:	4b27      	ldr	r3, [pc, #156]	; (8018a8c <RegionEU868InitDefaults+0x100>)
 80189ee:	2260      	movs	r2, #96	; 0x60
 80189f0:	0018      	movs	r0, r3
 80189f2:	f002 fda9 	bl	801b548 <memcpy1>
            NvmCtx.Channels[0] = ( ChannelParams_t ) EU868_LC1;
 80189f6:	4b26      	ldr	r3, [pc, #152]	; (8018a90 <RegionEU868InitDefaults+0x104>)
 80189f8:	4a26      	ldr	r2, [pc, #152]	; (8018a94 <RegionEU868InitDefaults+0x108>)
 80189fa:	ca13      	ldmia	r2!, {r0, r1, r4}
 80189fc:	c313      	stmia	r3!, {r0, r1, r4}
            NvmCtx.Channels[1] = ( ChannelParams_t ) EU868_LC2;
 80189fe:	4b24      	ldr	r3, [pc, #144]	; (8018a90 <RegionEU868InitDefaults+0x104>)
 8018a00:	4a25      	ldr	r2, [pc, #148]	; (8018a98 <RegionEU868InitDefaults+0x10c>)
 8018a02:	330c      	adds	r3, #12
 8018a04:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018a06:	c313      	stmia	r3!, {r0, r1, r4}
            NvmCtx.Channels[2] = ( ChannelParams_t ) EU868_LC3;
 8018a08:	4b21      	ldr	r3, [pc, #132]	; (8018a90 <RegionEU868InitDefaults+0x104>)
 8018a0a:	4a24      	ldr	r2, [pc, #144]	; (8018a9c <RegionEU868InitDefaults+0x110>)
 8018a0c:	3318      	adds	r3, #24
 8018a0e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018a10:	c313      	stmia	r3!, {r0, r1, r4}
            NvmCtx.ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 8018a12:	4a1f      	ldr	r2, [pc, #124]	; (8018a90 <RegionEU868InitDefaults+0x104>)
 8018a14:	2391      	movs	r3, #145	; 0x91
 8018a16:	005b      	lsls	r3, r3, #1
 8018a18:	2107      	movs	r1, #7
 8018a1a:	52d1      	strh	r1, [r2, r3]
            RegionCommonChanMaskCopy( NvmCtx.ChannelsMask, NvmCtx.ChannelsDefaultMask, 1 );
 8018a1c:	4920      	ldr	r1, [pc, #128]	; (8018aa0 <RegionEU868InitDefaults+0x114>)
 8018a1e:	4b21      	ldr	r3, [pc, #132]	; (8018aa4 <RegionEU868InitDefaults+0x118>)
 8018a20:	2201      	movs	r2, #1
 8018a22:	0018      	movs	r0, r3
 8018a24:	f7ff f936 	bl	8017c94 <RegionCommonChanMaskCopy>
            break;
 8018a28:	e02c      	b.n	8018a84 <RegionEU868InitDefaults+0xf8>
            if( params->NvmCtx != 0 )
 8018a2a:	687b      	ldr	r3, [r7, #4]
 8018a2c:	681b      	ldr	r3, [r3, #0]
 8018a2e:	2b00      	cmp	r3, #0
 8018a30:	d027      	beq.n	8018a82 <RegionEU868InitDefaults+0xf6>
                memcpy1( (uint8_t*) &NvmCtx, (uint8_t*) params->NvmCtx, sizeof( NvmCtx ) );
 8018a32:	687b      	ldr	r3, [r7, #4]
 8018a34:	6819      	ldr	r1, [r3, #0]
 8018a36:	2392      	movs	r3, #146	; 0x92
 8018a38:	005a      	lsls	r2, r3, #1
 8018a3a:	4b15      	ldr	r3, [pc, #84]	; (8018a90 <RegionEU868InitDefaults+0x104>)
 8018a3c:	0018      	movs	r0, r3
 8018a3e:	f002 fd83 	bl	801b548 <memcpy1>
            break;
 8018a42:	e01e      	b.n	8018a82 <RegionEU868InitDefaults+0xf6>
            NvmCtx.ChannelsMask[0] |= NvmCtx.ChannelsDefaultMask[0];
 8018a44:	4a12      	ldr	r2, [pc, #72]	; (8018a90 <RegionEU868InitDefaults+0x104>)
 8018a46:	2390      	movs	r3, #144	; 0x90
 8018a48:	005b      	lsls	r3, r3, #1
 8018a4a:	5ad2      	ldrh	r2, [r2, r3]
 8018a4c:	4910      	ldr	r1, [pc, #64]	; (8018a90 <RegionEU868InitDefaults+0x104>)
 8018a4e:	2391      	movs	r3, #145	; 0x91
 8018a50:	005b      	lsls	r3, r3, #1
 8018a52:	5acb      	ldrh	r3, [r1, r3]
 8018a54:	4313      	orrs	r3, r2
 8018a56:	b299      	uxth	r1, r3
 8018a58:	4a0d      	ldr	r2, [pc, #52]	; (8018a90 <RegionEU868InitDefaults+0x104>)
 8018a5a:	2390      	movs	r3, #144	; 0x90
 8018a5c:	005b      	lsls	r3, r3, #1
 8018a5e:	52d1      	strh	r1, [r2, r3]
            NvmCtx.Channels[0] = ( ChannelParams_t ) EU868_LC1;
 8018a60:	4b0b      	ldr	r3, [pc, #44]	; (8018a90 <RegionEU868InitDefaults+0x104>)
 8018a62:	4a0c      	ldr	r2, [pc, #48]	; (8018a94 <RegionEU868InitDefaults+0x108>)
 8018a64:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018a66:	c313      	stmia	r3!, {r0, r1, r4}
            NvmCtx.Channels[1] = ( ChannelParams_t ) EU868_LC2;
 8018a68:	4b09      	ldr	r3, [pc, #36]	; (8018a90 <RegionEU868InitDefaults+0x104>)
 8018a6a:	4a0b      	ldr	r2, [pc, #44]	; (8018a98 <RegionEU868InitDefaults+0x10c>)
 8018a6c:	330c      	adds	r3, #12
 8018a6e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018a70:	c313      	stmia	r3!, {r0, r1, r4}
            NvmCtx.Channels[2] = ( ChannelParams_t ) EU868_LC3;
 8018a72:	4b07      	ldr	r3, [pc, #28]	; (8018a90 <RegionEU868InitDefaults+0x104>)
 8018a74:	4a09      	ldr	r2, [pc, #36]	; (8018a9c <RegionEU868InitDefaults+0x110>)
 8018a76:	3318      	adds	r3, #24
 8018a78:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018a7a:	c313      	stmia	r3!, {r0, r1, r4}
            break;
 8018a7c:	e002      	b.n	8018a84 <RegionEU868InitDefaults+0xf8>
            break;
 8018a7e:	46c0      	nop			; (mov r8, r8)
 8018a80:	e000      	b.n	8018a84 <RegionEU868InitDefaults+0xf8>
            break;
 8018a82:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 8018a84:	46c0      	nop			; (mov r8, r8)
 8018a86:	46bd      	mov	sp, r7
 8018a88:	b02d      	add	sp, #180	; 0xb4
 8018a8a:	bd90      	pop	{r4, r7, pc}
 8018a8c:	20001180 	.word	0x20001180
 8018a90:	200010c0 	.word	0x200010c0
 8018a94:	0801f578 	.word	0x0801f578
 8018a98:	0801f584 	.word	0x0801f584
 8018a9c:	0801f590 	.word	0x0801f590
 8018aa0:	200011e2 	.word	0x200011e2
 8018aa4:	200011e0 	.word	0x200011e0

08018aa8 <RegionEU868GetNvmCtx>:

void* RegionEU868GetNvmCtx( GetNvmCtxParams_t* params )
{
 8018aa8:	b580      	push	{r7, lr}
 8018aaa:	b082      	sub	sp, #8
 8018aac:	af00      	add	r7, sp, #0
 8018aae:	6078      	str	r0, [r7, #4]
    params->nvmCtxSize = sizeof( RegionEU868NvmCtx_t );
 8018ab0:	687b      	ldr	r3, [r7, #4]
 8018ab2:	2292      	movs	r2, #146	; 0x92
 8018ab4:	0052      	lsls	r2, r2, #1
 8018ab6:	601a      	str	r2, [r3, #0]
    return &NvmCtx;
 8018ab8:	4b02      	ldr	r3, [pc, #8]	; (8018ac4 <RegionEU868GetNvmCtx+0x1c>)
}
 8018aba:	0018      	movs	r0, r3
 8018abc:	46bd      	mov	sp, r7
 8018abe:	b002      	add	sp, #8
 8018ac0:	bd80      	pop	{r7, pc}
 8018ac2:	46c0      	nop			; (mov r8, r8)
 8018ac4:	200010c0 	.word	0x200010c0

08018ac8 <RegionEU868Verify>:

bool RegionEU868Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 8018ac8:	b580      	push	{r7, lr}
 8018aca:	b084      	sub	sp, #16
 8018acc:	af00      	add	r7, sp, #0
 8018ace:	6078      	str	r0, [r7, #4]
 8018ad0:	000a      	movs	r2, r1
 8018ad2:	1cfb      	adds	r3, r7, #3
 8018ad4:	701a      	strb	r2, [r3, #0]
    switch( phyAttribute )
 8018ad6:	1cfb      	adds	r3, r7, #3
 8018ad8:	781b      	ldrb	r3, [r3, #0]
 8018ada:	2b0f      	cmp	r3, #15
 8018adc:	d847      	bhi.n	8018b6e <RegionEU868Verify+0xa6>
 8018ade:	009a      	lsls	r2, r3, #2
 8018ae0:	4b25      	ldr	r3, [pc, #148]	; (8018b78 <RegionEU868Verify+0xb0>)
 8018ae2:	18d3      	adds	r3, r2, r3
 8018ae4:	681b      	ldr	r3, [r3, #0]
 8018ae6:	469f      	mov	pc, r3
    {
        case PHY_FREQUENCY:
        {
            uint8_t band = 0;
 8018ae8:	210f      	movs	r1, #15
 8018aea:	187b      	adds	r3, r7, r1
 8018aec:	2200      	movs	r2, #0
 8018aee:	701a      	strb	r2, [r3, #0]
            return VerifyRfFreq( verify->Frequency, &band );
 8018af0:	687b      	ldr	r3, [r7, #4]
 8018af2:	681b      	ldr	r3, [r3, #0]
 8018af4:	187a      	adds	r2, r7, r1
 8018af6:	0011      	movs	r1, r2
 8018af8:	0018      	movs	r0, r3
 8018afa:	f7ff fcc9 	bl	8018490 <VerifyRfFreq>
 8018afe:	0003      	movs	r3, r0
 8018b00:	e036      	b.n	8018b70 <RegionEU868Verify+0xa8>
        }
        case PHY_TX_DR:
        {
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE );
 8018b02:	687b      	ldr	r3, [r7, #4]
 8018b04:	781b      	ldrb	r3, [r3, #0]
 8018b06:	b25b      	sxtb	r3, r3
 8018b08:	2207      	movs	r2, #7
 8018b0a:	2100      	movs	r1, #0
 8018b0c:	0018      	movs	r0, r3
 8018b0e:	f7ff f818 	bl	8017b42 <RegionCommonValueInRange>
 8018b12:	0003      	movs	r3, r0
 8018b14:	1e5a      	subs	r2, r3, #1
 8018b16:	4193      	sbcs	r3, r2
 8018b18:	b2db      	uxtb	r3, r3
 8018b1a:	e029      	b.n	8018b70 <RegionEU868Verify+0xa8>
        }
        case PHY_DEF_TX_DR:
        {
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
 8018b1c:	687b      	ldr	r3, [r7, #4]
 8018b1e:	781b      	ldrb	r3, [r3, #0]
 8018b20:	b25b      	sxtb	r3, r3
 8018b22:	2205      	movs	r2, #5
 8018b24:	2100      	movs	r1, #0
 8018b26:	0018      	movs	r0, r3
 8018b28:	f7ff f80b 	bl	8017b42 <RegionCommonValueInRange>
 8018b2c:	0003      	movs	r3, r0
 8018b2e:	1e5a      	subs	r2, r3, #1
 8018b30:	4193      	sbcs	r3, r2
 8018b32:	b2db      	uxtb	r3, r3
 8018b34:	e01c      	b.n	8018b70 <RegionEU868Verify+0xa8>
        }
        case PHY_RX_DR:
        {
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE );
 8018b36:	687b      	ldr	r3, [r7, #4]
 8018b38:	781b      	ldrb	r3, [r3, #0]
 8018b3a:	b25b      	sxtb	r3, r3
 8018b3c:	2207      	movs	r2, #7
 8018b3e:	2100      	movs	r1, #0
 8018b40:	0018      	movs	r0, r3
 8018b42:	f7fe fffe 	bl	8017b42 <RegionCommonValueInRange>
 8018b46:	0003      	movs	r3, r0
 8018b48:	1e5a      	subs	r2, r3, #1
 8018b4a:	4193      	sbcs	r3, r2
 8018b4c:	b2db      	uxtb	r3, r3
 8018b4e:	e00f      	b.n	8018b70 <RegionEU868Verify+0xa8>
        }
        case PHY_DEF_TX_POWER:
        case PHY_TX_POWER:
        {
            // Remark: switched min and max!
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
 8018b50:	687b      	ldr	r3, [r7, #4]
 8018b52:	781b      	ldrb	r3, [r3, #0]
 8018b54:	b25b      	sxtb	r3, r3
 8018b56:	2207      	movs	r2, #7
 8018b58:	2100      	movs	r1, #0
 8018b5a:	0018      	movs	r0, r3
 8018b5c:	f7fe fff1 	bl	8017b42 <RegionCommonValueInRange>
 8018b60:	0003      	movs	r3, r0
 8018b62:	1e5a      	subs	r2, r3, #1
 8018b64:	4193      	sbcs	r3, r2
 8018b66:	b2db      	uxtb	r3, r3
 8018b68:	e002      	b.n	8018b70 <RegionEU868Verify+0xa8>
        }
        case PHY_DUTY_CYCLE:
        {
            return EU868_DUTY_CYCLE_ENABLED;
 8018b6a:	2301      	movs	r3, #1
 8018b6c:	e000      	b.n	8018b70 <RegionEU868Verify+0xa8>
        }
        default:
            return false;
 8018b6e:	2300      	movs	r3, #0
    }
}
 8018b70:	0018      	movs	r0, r3
 8018b72:	46bd      	mov	sp, r7
 8018b74:	b004      	add	sp, #16
 8018b76:	bd80      	pop	{r7, pc}
 8018b78:	0801f59c 	.word	0x0801f59c

08018b7c <RegionEU868ApplyCFList>:

void RegionEU868ApplyCFList( ApplyCFListParams_t* applyCFList )
{
 8018b7c:	b590      	push	{r4, r7, lr}
 8018b7e:	b08b      	sub	sp, #44	; 0x2c
 8018b80:	af00      	add	r7, sp, #0
 8018b82:	6078      	str	r0, [r7, #4]
    ChannelParams_t newChannel;
    ChannelAddParams_t channelAdd;
    ChannelRemoveParams_t channelRemove;

    // Setup default datarate range
    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;
 8018b84:	2318      	movs	r3, #24
 8018b86:	18fb      	adds	r3, r7, r3
 8018b88:	2250      	movs	r2, #80	; 0x50
 8018b8a:	721a      	strb	r2, [r3, #8]

    // Size of the optional CF list
    if( applyCFList->Size != 16 )
 8018b8c:	687b      	ldr	r3, [r7, #4]
 8018b8e:	791b      	ldrb	r3, [r3, #4]
 8018b90:	2b10      	cmp	r3, #16
 8018b92:	d000      	beq.n	8018b96 <RegionEU868ApplyCFList+0x1a>
 8018b94:	e07c      	b.n	8018c90 <RegionEU868ApplyCFList+0x114>
    {
        return;
    }

    // Last byte CFListType must be 0 to indicate the CFList contains a list of frequencies
    if( applyCFList->Payload[15] != 0 )
 8018b96:	687b      	ldr	r3, [r7, #4]
 8018b98:	681b      	ldr	r3, [r3, #0]
 8018b9a:	330f      	adds	r3, #15
 8018b9c:	781b      	ldrb	r3, [r3, #0]
 8018b9e:	2b00      	cmp	r3, #0
 8018ba0:	d000      	beq.n	8018ba4 <RegionEU868ApplyCFList+0x28>
 8018ba2:	e077      	b.n	8018c94 <RegionEU868ApplyCFList+0x118>
    {
        return;
    }

    // Last byte is RFU, don't take it into account
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 8018ba4:	2327      	movs	r3, #39	; 0x27
 8018ba6:	18fb      	adds	r3, r7, r3
 8018ba8:	2200      	movs	r2, #0
 8018baa:	701a      	strb	r2, [r3, #0]
 8018bac:	2326      	movs	r3, #38	; 0x26
 8018bae:	18fb      	adds	r3, r7, r3
 8018bb0:	2203      	movs	r2, #3
 8018bb2:	701a      	strb	r2, [r3, #0]
 8018bb4:	e066      	b.n	8018c84 <RegionEU868ApplyCFList+0x108>
    {
        if( chanIdx < ( EU868_NUMB_CHANNELS_CF_LIST + EU868_NUMB_DEFAULT_CHANNELS ) )
 8018bb6:	2326      	movs	r3, #38	; 0x26
 8018bb8:	18fb      	adds	r3, r7, r3
 8018bba:	781b      	ldrb	r3, [r3, #0]
 8018bbc:	2b07      	cmp	r3, #7
 8018bbe:	d82e      	bhi.n	8018c1e <RegionEU868ApplyCFList+0xa2>
        {
            // Channel frequency
            newChannel.Frequency = (uint32_t) applyCFList->Payload[i];
 8018bc0:	687b      	ldr	r3, [r7, #4]
 8018bc2:	681a      	ldr	r2, [r3, #0]
 8018bc4:	2427      	movs	r4, #39	; 0x27
 8018bc6:	193b      	adds	r3, r7, r4
 8018bc8:	781b      	ldrb	r3, [r3, #0]
 8018bca:	18d3      	adds	r3, r2, r3
 8018bcc:	781b      	ldrb	r3, [r3, #0]
 8018bce:	001a      	movs	r2, r3
 8018bd0:	2018      	movs	r0, #24
 8018bd2:	183b      	adds	r3, r7, r0
 8018bd4:	601a      	str	r2, [r3, #0]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 1] << 8 );
 8018bd6:	183b      	adds	r3, r7, r0
 8018bd8:	681a      	ldr	r2, [r3, #0]
 8018bda:	687b      	ldr	r3, [r7, #4]
 8018bdc:	6819      	ldr	r1, [r3, #0]
 8018bde:	193b      	adds	r3, r7, r4
 8018be0:	781b      	ldrb	r3, [r3, #0]
 8018be2:	3301      	adds	r3, #1
 8018be4:	18cb      	adds	r3, r1, r3
 8018be6:	781b      	ldrb	r3, [r3, #0]
 8018be8:	021b      	lsls	r3, r3, #8
 8018bea:	431a      	orrs	r2, r3
 8018bec:	183b      	adds	r3, r7, r0
 8018bee:	601a      	str	r2, [r3, #0]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 2] << 16 );
 8018bf0:	183b      	adds	r3, r7, r0
 8018bf2:	681a      	ldr	r2, [r3, #0]
 8018bf4:	687b      	ldr	r3, [r7, #4]
 8018bf6:	6819      	ldr	r1, [r3, #0]
 8018bf8:	193b      	adds	r3, r7, r4
 8018bfa:	781b      	ldrb	r3, [r3, #0]
 8018bfc:	3302      	adds	r3, #2
 8018bfe:	18cb      	adds	r3, r1, r3
 8018c00:	781b      	ldrb	r3, [r3, #0]
 8018c02:	041b      	lsls	r3, r3, #16
 8018c04:	431a      	orrs	r2, r3
 8018c06:	183b      	adds	r3, r7, r0
 8018c08:	601a      	str	r2, [r3, #0]
            newChannel.Frequency *= 100;
 8018c0a:	183b      	adds	r3, r7, r0
 8018c0c:	681b      	ldr	r3, [r3, #0]
 8018c0e:	2264      	movs	r2, #100	; 0x64
 8018c10:	435a      	muls	r2, r3
 8018c12:	183b      	adds	r3, r7, r0
 8018c14:	601a      	str	r2, [r3, #0]

            // Initialize alternative frequency to 0
            newChannel.Rx1Frequency = 0;
 8018c16:	183b      	adds	r3, r7, r0
 8018c18:	2200      	movs	r2, #0
 8018c1a:	605a      	str	r2, [r3, #4]
 8018c1c:	e009      	b.n	8018c32 <RegionEU868ApplyCFList+0xb6>
        }
        else
        {
            newChannel.Frequency = 0;
 8018c1e:	2118      	movs	r1, #24
 8018c20:	187b      	adds	r3, r7, r1
 8018c22:	2200      	movs	r2, #0
 8018c24:	601a      	str	r2, [r3, #0]
            newChannel.DrRange.Value = 0;
 8018c26:	187b      	adds	r3, r7, r1
 8018c28:	2200      	movs	r2, #0
 8018c2a:	721a      	strb	r2, [r3, #8]
            newChannel.Rx1Frequency = 0;
 8018c2c:	187b      	adds	r3, r7, r1
 8018c2e:	2200      	movs	r2, #0
 8018c30:	605a      	str	r2, [r3, #4]
        }

        if( newChannel.Frequency != 0 )
 8018c32:	2218      	movs	r2, #24
 8018c34:	18bb      	adds	r3, r7, r2
 8018c36:	681b      	ldr	r3, [r3, #0]
 8018c38:	2b00      	cmp	r3, #0
 8018c3a:	d00d      	beq.n	8018c58 <RegionEU868ApplyCFList+0xdc>
        {
            channelAdd.NewChannel = &newChannel;
 8018c3c:	2110      	movs	r1, #16
 8018c3e:	187b      	adds	r3, r7, r1
 8018c40:	18ba      	adds	r2, r7, r2
 8018c42:	601a      	str	r2, [r3, #0]
            channelAdd.ChannelId = chanIdx;
 8018c44:	187b      	adds	r3, r7, r1
 8018c46:	2226      	movs	r2, #38	; 0x26
 8018c48:	18ba      	adds	r2, r7, r2
 8018c4a:	7812      	ldrb	r2, [r2, #0]
 8018c4c:	711a      	strb	r2, [r3, #4]

            // Try to add all channels
            RegionEU868ChannelAdd( &channelAdd );
 8018c4e:	187b      	adds	r3, r7, r1
 8018c50:	0018      	movs	r0, r3
 8018c52:	f000 fdb9 	bl	80197c8 <RegionEU868ChannelAdd>
 8018c56:	e009      	b.n	8018c6c <RegionEU868ApplyCFList+0xf0>
        }
        else
        {
            channelRemove.ChannelId = chanIdx;
 8018c58:	210c      	movs	r1, #12
 8018c5a:	187b      	adds	r3, r7, r1
 8018c5c:	2226      	movs	r2, #38	; 0x26
 8018c5e:	18ba      	adds	r2, r7, r2
 8018c60:	7812      	ldrb	r2, [r2, #0]
 8018c62:	701a      	strb	r2, [r3, #0]

            RegionEU868ChannelsRemove( &channelRemove );
 8018c64:	187b      	adds	r3, r7, r1
 8018c66:	0018      	movs	r0, r3
 8018c68:	f000 fe72 	bl	8019950 <RegionEU868ChannelsRemove>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 8018c6c:	2227      	movs	r2, #39	; 0x27
 8018c6e:	18bb      	adds	r3, r7, r2
 8018c70:	18ba      	adds	r2, r7, r2
 8018c72:	7812      	ldrb	r2, [r2, #0]
 8018c74:	3203      	adds	r2, #3
 8018c76:	701a      	strb	r2, [r3, #0]
 8018c78:	2126      	movs	r1, #38	; 0x26
 8018c7a:	187b      	adds	r3, r7, r1
 8018c7c:	781a      	ldrb	r2, [r3, #0]
 8018c7e:	187b      	adds	r3, r7, r1
 8018c80:	3201      	adds	r2, #1
 8018c82:	701a      	strb	r2, [r3, #0]
 8018c84:	2326      	movs	r3, #38	; 0x26
 8018c86:	18fb      	adds	r3, r7, r3
 8018c88:	781b      	ldrb	r3, [r3, #0]
 8018c8a:	2b0f      	cmp	r3, #15
 8018c8c:	d993      	bls.n	8018bb6 <RegionEU868ApplyCFList+0x3a>
 8018c8e:	e002      	b.n	8018c96 <RegionEU868ApplyCFList+0x11a>
        return;
 8018c90:	46c0      	nop			; (mov r8, r8)
 8018c92:	e000      	b.n	8018c96 <RegionEU868ApplyCFList+0x11a>
        return;
 8018c94:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 8018c96:	46bd      	mov	sp, r7
 8018c98:	b00b      	add	sp, #44	; 0x2c
 8018c9a:	bd90      	pop	{r4, r7, pc}

08018c9c <RegionEU868ChanMaskSet>:

bool RegionEU868ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 8018c9c:	b580      	push	{r7, lr}
 8018c9e:	b082      	sub	sp, #8
 8018ca0:	af00      	add	r7, sp, #0
 8018ca2:	6078      	str	r0, [r7, #4]
    switch( chanMaskSet->ChannelsMaskType )
 8018ca4:	687b      	ldr	r3, [r7, #4]
 8018ca6:	791b      	ldrb	r3, [r3, #4]
 8018ca8:	2b00      	cmp	r3, #0
 8018caa:	d002      	beq.n	8018cb2 <RegionEU868ChanMaskSet+0x16>
 8018cac:	2b01      	cmp	r3, #1
 8018cae:	d008      	beq.n	8018cc2 <RegionEU868ChanMaskSet+0x26>
 8018cb0:	e00f      	b.n	8018cd2 <RegionEU868ChanMaskSet+0x36>
    {
        case CHANNELS_MASK:
        {
            RegionCommonChanMaskCopy( NvmCtx.ChannelsMask, chanMaskSet->ChannelsMaskIn, 1 );
 8018cb2:	687b      	ldr	r3, [r7, #4]
 8018cb4:	6819      	ldr	r1, [r3, #0]
 8018cb6:	4b0a      	ldr	r3, [pc, #40]	; (8018ce0 <RegionEU868ChanMaskSet+0x44>)
 8018cb8:	2201      	movs	r2, #1
 8018cba:	0018      	movs	r0, r3
 8018cbc:	f7fe ffea 	bl	8017c94 <RegionCommonChanMaskCopy>
            break;
 8018cc0:	e009      	b.n	8018cd6 <RegionEU868ChanMaskSet+0x3a>
        }
        case CHANNELS_DEFAULT_MASK:
        {
            RegionCommonChanMaskCopy( NvmCtx.ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, 1 );
 8018cc2:	687b      	ldr	r3, [r7, #4]
 8018cc4:	6819      	ldr	r1, [r3, #0]
 8018cc6:	4b07      	ldr	r3, [pc, #28]	; (8018ce4 <RegionEU868ChanMaskSet+0x48>)
 8018cc8:	2201      	movs	r2, #1
 8018cca:	0018      	movs	r0, r3
 8018ccc:	f7fe ffe2 	bl	8017c94 <RegionCommonChanMaskCopy>
            break;
 8018cd0:	e001      	b.n	8018cd6 <RegionEU868ChanMaskSet+0x3a>
        }
        default:
            return false;
 8018cd2:	2300      	movs	r3, #0
 8018cd4:	e000      	b.n	8018cd8 <RegionEU868ChanMaskSet+0x3c>
    }
    return true;
 8018cd6:	2301      	movs	r3, #1
}
 8018cd8:	0018      	movs	r0, r3
 8018cda:	46bd      	mov	sp, r7
 8018cdc:	b002      	add	sp, #8
 8018cde:	bd80      	pop	{r7, pc}
 8018ce0:	200011e0 	.word	0x200011e0
 8018ce4:	200011e2 	.word	0x200011e2

08018ce8 <RegionEU868ComputeRxWindowParameters>:

void RegionEU868ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 8018ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018cea:	b08b      	sub	sp, #44	; 0x2c
 8018cec:	af04      	add	r7, sp, #16
 8018cee:	60ba      	str	r2, [r7, #8]
 8018cf0:	607b      	str	r3, [r7, #4]
 8018cf2:	240f      	movs	r4, #15
 8018cf4:	193b      	adds	r3, r7, r4
 8018cf6:	1c02      	adds	r2, r0, #0
 8018cf8:	701a      	strb	r2, [r3, #0]
 8018cfa:	230e      	movs	r3, #14
 8018cfc:	18fb      	adds	r3, r7, r3
 8018cfe:	1c0a      	adds	r2, r1, #0
 8018d00:	701a      	strb	r2, [r3, #0]
    double tSymbol = 0.0;
 8018d02:	2200      	movs	r2, #0
 8018d04:	2300      	movs	r3, #0
 8018d06:	613a      	str	r2, [r7, #16]
 8018d08:	617b      	str	r3, [r7, #20]

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 8018d0a:	193b      	adds	r3, r7, r4
 8018d0c:	781b      	ldrb	r3, [r3, #0]
 8018d0e:	b25a      	sxtb	r2, r3
 8018d10:	2a07      	cmp	r2, #7
 8018d12:	dd00      	ble.n	8018d16 <RegionEU868ComputeRxWindowParameters+0x2e>
 8018d14:	2307      	movs	r3, #7
 8018d16:	b25a      	sxtb	r2, r3
 8018d18:	687b      	ldr	r3, [r7, #4]
 8018d1a:	705a      	strb	r2, [r3, #1]
    rxConfigParams->Bandwidth = GetBandwidth( rxConfigParams->Datarate );
 8018d1c:	687b      	ldr	r3, [r7, #4]
 8018d1e:	785b      	ldrb	r3, [r3, #1]
 8018d20:	b25b      	sxtb	r3, r3
 8018d22:	0018      	movs	r0, r3
 8018d24:	f7ff fb6e 	bl	8018404 <GetBandwidth>
 8018d28:	0003      	movs	r3, r0
 8018d2a:	b2da      	uxtb	r2, r3
 8018d2c:	687b      	ldr	r3, [r7, #4]
 8018d2e:	709a      	strb	r2, [r3, #2]

    if( rxConfigParams->Datarate == DR_7 )
 8018d30:	687b      	ldr	r3, [r7, #4]
 8018d32:	785b      	ldrb	r3, [r3, #1]
 8018d34:	b25b      	sxtb	r3, r3
 8018d36:	2b07      	cmp	r3, #7
 8018d38:	d10d      	bne.n	8018d56 <RegionEU868ComputeRxWindowParameters+0x6e>
    { // FSK
        tSymbol = RegionCommonComputeSymbolTimeFsk( DataratesEU868[rxConfigParams->Datarate] );
 8018d3a:	687b      	ldr	r3, [r7, #4]
 8018d3c:	785b      	ldrb	r3, [r3, #1]
 8018d3e:	b25b      	sxtb	r3, r3
 8018d40:	001a      	movs	r2, r3
 8018d42:	4b1b      	ldr	r3, [pc, #108]	; (8018db0 <RegionEU868ComputeRxWindowParameters+0xc8>)
 8018d44:	5c9b      	ldrb	r3, [r3, r2]
 8018d46:	0018      	movs	r0, r3
 8018d48:	f7ff f9d0 	bl	80180ec <RegionCommonComputeSymbolTimeFsk>
 8018d4c:	0002      	movs	r2, r0
 8018d4e:	000b      	movs	r3, r1
 8018d50:	613a      	str	r2, [r7, #16]
 8018d52:	617b      	str	r3, [r7, #20]
 8018d54:	e013      	b.n	8018d7e <RegionEU868ComputeRxWindowParameters+0x96>
    }
    else
    { // LoRa
        tSymbol = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 8018d56:	687b      	ldr	r3, [r7, #4]
 8018d58:	785b      	ldrb	r3, [r3, #1]
 8018d5a:	b25b      	sxtb	r3, r3
 8018d5c:	001a      	movs	r2, r3
 8018d5e:	4b14      	ldr	r3, [pc, #80]	; (8018db0 <RegionEU868ComputeRxWindowParameters+0xc8>)
 8018d60:	5c98      	ldrb	r0, [r3, r2]
 8018d62:	687b      	ldr	r3, [r7, #4]
 8018d64:	785b      	ldrb	r3, [r3, #1]
 8018d66:	b25b      	sxtb	r3, r3
 8018d68:	001a      	movs	r2, r3
 8018d6a:	4b12      	ldr	r3, [pc, #72]	; (8018db4 <RegionEU868ComputeRxWindowParameters+0xcc>)
 8018d6c:	0092      	lsls	r2, r2, #2
 8018d6e:	58d3      	ldr	r3, [r2, r3]
 8018d70:	0019      	movs	r1, r3
 8018d72:	f7ff f98f 	bl	8018094 <RegionCommonComputeSymbolTimeLoRa>
 8018d76:	0002      	movs	r2, r0
 8018d78:	000b      	movs	r3, r1
 8018d7a:	613a      	str	r2, [r7, #16]
 8018d7c:	617b      	str	r3, [r7, #20]
    }

    RegionCommonComputeRxWindowParameters( tSymbol, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8018d7e:	4b0e      	ldr	r3, [pc, #56]	; (8018db8 <RegionEU868ComputeRxWindowParameters+0xd0>)
 8018d80:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8018d82:	4798      	blx	r3
 8018d84:	0006      	movs	r6, r0
 8018d86:	687b      	ldr	r3, [r7, #4]
 8018d88:	3308      	adds	r3, #8
 8018d8a:	687a      	ldr	r2, [r7, #4]
 8018d8c:	320c      	adds	r2, #12
 8018d8e:	68bd      	ldr	r5, [r7, #8]
 8018d90:	210e      	movs	r1, #14
 8018d92:	1879      	adds	r1, r7, r1
 8018d94:	780c      	ldrb	r4, [r1, #0]
 8018d96:	6938      	ldr	r0, [r7, #16]
 8018d98:	6979      	ldr	r1, [r7, #20]
 8018d9a:	9202      	str	r2, [sp, #8]
 8018d9c:	9301      	str	r3, [sp, #4]
 8018d9e:	9600      	str	r6, [sp, #0]
 8018da0:	002b      	movs	r3, r5
 8018da2:	0022      	movs	r2, r4
 8018da4:	f7ff f9bc 	bl	8018120 <RegionCommonComputeRxWindowParameters>
}
 8018da8:	46c0      	nop			; (mov r8, r8)
 8018daa:	46bd      	mov	sp, r7
 8018dac:	b007      	add	sp, #28
 8018dae:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8018db0:	0801f468 	.word	0x0801f468
 8018db4:	0801f470 	.word	0x0801f470
 8018db8:	0801ebd0 	.word	0x0801ebd0

08018dbc <RegionEU868RxConfig>:

bool RegionEU868RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 8018dbc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018dbe:	b091      	sub	sp, #68	; 0x44
 8018dc0:	af0a      	add	r7, sp, #40	; 0x28
 8018dc2:	6078      	str	r0, [r7, #4]
 8018dc4:	6039      	str	r1, [r7, #0]
    RadioModems_t modem;
    int8_t dr = rxConfig->Datarate;
 8018dc6:	230f      	movs	r3, #15
 8018dc8:	18fb      	adds	r3, r7, r3
 8018dca:	687a      	ldr	r2, [r7, #4]
 8018dcc:	7852      	ldrb	r2, [r2, #1]
 8018dce:	701a      	strb	r2, [r3, #0]
    uint8_t maxPayload = 0;
 8018dd0:	2316      	movs	r3, #22
 8018dd2:	18fb      	adds	r3, r7, r3
 8018dd4:	2200      	movs	r2, #0
 8018dd6:	701a      	strb	r2, [r3, #0]
    int8_t phyDr = 0;
 8018dd8:	230e      	movs	r3, #14
 8018dda:	18fb      	adds	r3, r7, r3
 8018ddc:	2200      	movs	r2, #0
 8018dde:	701a      	strb	r2, [r3, #0]
    uint32_t frequency = rxConfig->Frequency;
 8018de0:	687b      	ldr	r3, [r7, #4]
 8018de2:	685b      	ldr	r3, [r3, #4]
 8018de4:	613b      	str	r3, [r7, #16]

    if( Radio.GetStatus( ) != RF_IDLE )
 8018de6:	4b63      	ldr	r3, [pc, #396]	; (8018f74 <RegionEU868RxConfig+0x1b8>)
 8018de8:	68db      	ldr	r3, [r3, #12]
 8018dea:	4798      	blx	r3
 8018dec:	1e03      	subs	r3, r0, #0
 8018dee:	d001      	beq.n	8018df4 <RegionEU868RxConfig+0x38>
    {
        return false;
 8018df0:	2300      	movs	r3, #0
 8018df2:	e0bb      	b.n	8018f6c <RegionEU868RxConfig+0x1b0>
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 8018df4:	687b      	ldr	r3, [r7, #4]
 8018df6:	7cdb      	ldrb	r3, [r3, #19]
 8018df8:	2b00      	cmp	r3, #0
 8018dfa:	d122      	bne.n	8018e42 <RegionEU868RxConfig+0x86>
    {
        // Apply window 1 frequency
        frequency = NvmCtx.Channels[rxConfig->Channel].Frequency;
 8018dfc:	687b      	ldr	r3, [r7, #4]
 8018dfe:	781b      	ldrb	r3, [r3, #0]
 8018e00:	0019      	movs	r1, r3
 8018e02:	4a5d      	ldr	r2, [pc, #372]	; (8018f78 <RegionEU868RxConfig+0x1bc>)
 8018e04:	000b      	movs	r3, r1
 8018e06:	005b      	lsls	r3, r3, #1
 8018e08:	185b      	adds	r3, r3, r1
 8018e0a:	009b      	lsls	r3, r3, #2
 8018e0c:	589b      	ldr	r3, [r3, r2]
 8018e0e:	613b      	str	r3, [r7, #16]
        // Apply the alternative RX 1 window frequency, if it is available
        if( NvmCtx.Channels[rxConfig->Channel].Rx1Frequency != 0 )
 8018e10:	687b      	ldr	r3, [r7, #4]
 8018e12:	781b      	ldrb	r3, [r3, #0]
 8018e14:	0019      	movs	r1, r3
 8018e16:	4a58      	ldr	r2, [pc, #352]	; (8018f78 <RegionEU868RxConfig+0x1bc>)
 8018e18:	000b      	movs	r3, r1
 8018e1a:	005b      	lsls	r3, r3, #1
 8018e1c:	185b      	adds	r3, r3, r1
 8018e1e:	009b      	lsls	r3, r3, #2
 8018e20:	18d3      	adds	r3, r2, r3
 8018e22:	3304      	adds	r3, #4
 8018e24:	681b      	ldr	r3, [r3, #0]
 8018e26:	2b00      	cmp	r3, #0
 8018e28:	d00b      	beq.n	8018e42 <RegionEU868RxConfig+0x86>
        {
            frequency = NvmCtx.Channels[rxConfig->Channel].Rx1Frequency;
 8018e2a:	687b      	ldr	r3, [r7, #4]
 8018e2c:	781b      	ldrb	r3, [r3, #0]
 8018e2e:	0019      	movs	r1, r3
 8018e30:	4a51      	ldr	r2, [pc, #324]	; (8018f78 <RegionEU868RxConfig+0x1bc>)
 8018e32:	000b      	movs	r3, r1
 8018e34:	005b      	lsls	r3, r3, #1
 8018e36:	185b      	adds	r3, r3, r1
 8018e38:	009b      	lsls	r3, r3, #2
 8018e3a:	18d3      	adds	r3, r2, r3
 8018e3c:	3304      	adds	r3, #4
 8018e3e:	681b      	ldr	r3, [r3, #0]
 8018e40:	613b      	str	r3, [r7, #16]
        }
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesEU868[dr];
 8018e42:	240f      	movs	r4, #15
 8018e44:	193b      	adds	r3, r7, r4
 8018e46:	781b      	ldrb	r3, [r3, #0]
 8018e48:	b25b      	sxtb	r3, r3
 8018e4a:	4a4c      	ldr	r2, [pc, #304]	; (8018f7c <RegionEU868RxConfig+0x1c0>)
 8018e4c:	5cd2      	ldrb	r2, [r2, r3]
 8018e4e:	250e      	movs	r5, #14
 8018e50:	197b      	adds	r3, r7, r5
 8018e52:	701a      	strb	r2, [r3, #0]

    Radio.SetChannel( frequency );
 8018e54:	4b47      	ldr	r3, [pc, #284]	; (8018f74 <RegionEU868RxConfig+0x1b8>)
 8018e56:	695b      	ldr	r3, [r3, #20]
 8018e58:	693a      	ldr	r2, [r7, #16]
 8018e5a:	0010      	movs	r0, r2
 8018e5c:	4798      	blx	r3

    // Radio configuration
    if( dr == DR_7 )
 8018e5e:	193b      	adds	r3, r7, r4
 8018e60:	781b      	ldrb	r3, [r3, #0]
 8018e62:	b25b      	sxtb	r3, r3
 8018e64:	2b07      	cmp	r3, #7
 8018e66:	d12e      	bne.n	8018ec6 <RegionEU868RxConfig+0x10a>
    {
        modem = MODEM_FSK;
 8018e68:	2117      	movs	r1, #23
 8018e6a:	187b      	adds	r3, r7, r1
 8018e6c:	2200      	movs	r2, #0
 8018e6e:	701a      	strb	r2, [r3, #0]
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 8018e70:	4b40      	ldr	r3, [pc, #256]	; (8018f74 <RegionEU868RxConfig+0x1b8>)
 8018e72:	6a1c      	ldr	r4, [r3, #32]
 8018e74:	197b      	adds	r3, r7, r5
 8018e76:	2200      	movs	r2, #0
 8018e78:	569a      	ldrsb	r2, [r3, r2]
 8018e7a:	0013      	movs	r3, r2
 8018e7c:	015b      	lsls	r3, r3, #5
 8018e7e:	1a9b      	subs	r3, r3, r2
 8018e80:	009b      	lsls	r3, r3, #2
 8018e82:	189b      	adds	r3, r3, r2
 8018e84:	00db      	lsls	r3, r3, #3
 8018e86:	001e      	movs	r6, r3
 8018e88:	687b      	ldr	r3, [r7, #4]
 8018e8a:	689b      	ldr	r3, [r3, #8]
 8018e8c:	b29b      	uxth	r3, r3
 8018e8e:	687a      	ldr	r2, [r7, #4]
 8018e90:	7c92      	ldrb	r2, [r2, #18]
 8018e92:	4d3b      	ldr	r5, [pc, #236]	; (8018f80 <RegionEU868RxConfig+0x1c4>)
 8018e94:	1879      	adds	r1, r7, r1
 8018e96:	7808      	ldrb	r0, [r1, #0]
 8018e98:	9209      	str	r2, [sp, #36]	; 0x24
 8018e9a:	2200      	movs	r2, #0
 8018e9c:	9208      	str	r2, [sp, #32]
 8018e9e:	2200      	movs	r2, #0
 8018ea0:	9207      	str	r2, [sp, #28]
 8018ea2:	2200      	movs	r2, #0
 8018ea4:	9206      	str	r2, [sp, #24]
 8018ea6:	2201      	movs	r2, #1
 8018ea8:	9205      	str	r2, [sp, #20]
 8018eaa:	2200      	movs	r2, #0
 8018eac:	9204      	str	r2, [sp, #16]
 8018eae:	2200      	movs	r2, #0
 8018eb0:	9203      	str	r2, [sp, #12]
 8018eb2:	9302      	str	r3, [sp, #8]
 8018eb4:	2305      	movs	r3, #5
 8018eb6:	9301      	str	r3, [sp, #4]
 8018eb8:	4b32      	ldr	r3, [pc, #200]	; (8018f84 <RegionEU868RxConfig+0x1c8>)
 8018eba:	9300      	str	r3, [sp, #0]
 8018ebc:	2300      	movs	r3, #0
 8018ebe:	0032      	movs	r2, r6
 8018ec0:	0029      	movs	r1, r5
 8018ec2:	47a0      	blx	r4
 8018ec4:	e029      	b.n	8018f1a <RegionEU868RxConfig+0x15e>
    }
    else
    {
        modem = MODEM_LORA;
 8018ec6:	2117      	movs	r1, #23
 8018ec8:	187b      	adds	r3, r7, r1
 8018eca:	2201      	movs	r2, #1
 8018ecc:	701a      	strb	r2, [r3, #0]
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 8018ece:	4b29      	ldr	r3, [pc, #164]	; (8018f74 <RegionEU868RxConfig+0x1b8>)
 8018ed0:	6a1c      	ldr	r4, [r3, #32]
 8018ed2:	687b      	ldr	r3, [r7, #4]
 8018ed4:	789b      	ldrb	r3, [r3, #2]
 8018ed6:	001e      	movs	r6, r3
 8018ed8:	230e      	movs	r3, #14
 8018eda:	18fb      	adds	r3, r7, r3
 8018edc:	2500      	movs	r5, #0
 8018ede:	575d      	ldrsb	r5, [r3, r5]
 8018ee0:	687b      	ldr	r3, [r7, #4]
 8018ee2:	689b      	ldr	r3, [r3, #8]
 8018ee4:	b29b      	uxth	r3, r3
 8018ee6:	687a      	ldr	r2, [r7, #4]
 8018ee8:	7c92      	ldrb	r2, [r2, #18]
 8018eea:	1879      	adds	r1, r7, r1
 8018eec:	7808      	ldrb	r0, [r1, #0]
 8018eee:	9209      	str	r2, [sp, #36]	; 0x24
 8018ef0:	2201      	movs	r2, #1
 8018ef2:	9208      	str	r2, [sp, #32]
 8018ef4:	2200      	movs	r2, #0
 8018ef6:	9207      	str	r2, [sp, #28]
 8018ef8:	2200      	movs	r2, #0
 8018efa:	9206      	str	r2, [sp, #24]
 8018efc:	2200      	movs	r2, #0
 8018efe:	9205      	str	r2, [sp, #20]
 8018f00:	2200      	movs	r2, #0
 8018f02:	9204      	str	r2, [sp, #16]
 8018f04:	2200      	movs	r2, #0
 8018f06:	9203      	str	r2, [sp, #12]
 8018f08:	9302      	str	r3, [sp, #8]
 8018f0a:	2308      	movs	r3, #8
 8018f0c:	9301      	str	r3, [sp, #4]
 8018f0e:	2300      	movs	r3, #0
 8018f10:	9300      	str	r3, [sp, #0]
 8018f12:	2301      	movs	r3, #1
 8018f14:	002a      	movs	r2, r5
 8018f16:	0031      	movs	r1, r6
 8018f18:	47a0      	blx	r4
    }

    if( rxConfig->RepeaterSupport == true )
 8018f1a:	687b      	ldr	r3, [r7, #4]
 8018f1c:	7c5b      	ldrb	r3, [r3, #17]
 8018f1e:	2b00      	cmp	r3, #0
 8018f20:	d009      	beq.n	8018f36 <RegionEU868RxConfig+0x17a>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterEU868[dr];
 8018f22:	230f      	movs	r3, #15
 8018f24:	18fb      	adds	r3, r7, r3
 8018f26:	2200      	movs	r2, #0
 8018f28:	569a      	ldrsb	r2, [r3, r2]
 8018f2a:	2316      	movs	r3, #22
 8018f2c:	18fb      	adds	r3, r7, r3
 8018f2e:	4916      	ldr	r1, [pc, #88]	; (8018f88 <RegionEU868RxConfig+0x1cc>)
 8018f30:	5c8a      	ldrb	r2, [r1, r2]
 8018f32:	701a      	strb	r2, [r3, #0]
 8018f34:	e008      	b.n	8018f48 <RegionEU868RxConfig+0x18c>
    }
    else
    {
        maxPayload = MaxPayloadOfDatarateEU868[dr];
 8018f36:	230f      	movs	r3, #15
 8018f38:	18fb      	adds	r3, r7, r3
 8018f3a:	2200      	movs	r2, #0
 8018f3c:	569a      	ldrsb	r2, [r3, r2]
 8018f3e:	2316      	movs	r3, #22
 8018f40:	18fb      	adds	r3, r7, r3
 8018f42:	4912      	ldr	r1, [pc, #72]	; (8018f8c <RegionEU868RxConfig+0x1d0>)
 8018f44:	5c8a      	ldrb	r2, [r1, r2]
 8018f46:	701a      	strb	r2, [r3, #0]
    }

    Radio.SetMaxPayloadLength( modem, maxPayload + LORA_MAC_FRMPAYLOAD_OVERHEAD );
 8018f48:	4b0a      	ldr	r3, [pc, #40]	; (8018f74 <RegionEU868RxConfig+0x1b8>)
 8018f4a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8018f4c:	2216      	movs	r2, #22
 8018f4e:	18ba      	adds	r2, r7, r2
 8018f50:	7812      	ldrb	r2, [r2, #0]
 8018f52:	320d      	adds	r2, #13
 8018f54:	b2d1      	uxtb	r1, r2
 8018f56:	2217      	movs	r2, #23
 8018f58:	18ba      	adds	r2, r7, r2
 8018f5a:	7812      	ldrb	r2, [r2, #0]
 8018f5c:	0010      	movs	r0, r2
 8018f5e:	4798      	blx	r3
    TVL1( PRINTF( "RX on freq %d Hz at DR %d\n\r", frequency, dr );)

    *datarate = (uint8_t) dr;
 8018f60:	683b      	ldr	r3, [r7, #0]
 8018f62:	220f      	movs	r2, #15
 8018f64:	18ba      	adds	r2, r7, r2
 8018f66:	7812      	ldrb	r2, [r2, #0]
 8018f68:	701a      	strb	r2, [r3, #0]
    return true;
 8018f6a:	2301      	movs	r3, #1
}
 8018f6c:	0018      	movs	r0, r3
 8018f6e:	46bd      	mov	sp, r7
 8018f70:	b007      	add	sp, #28
 8018f72:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8018f74:	0801ebd0 	.word	0x0801ebd0
 8018f78:	200010c0 	.word	0x200010c0
 8018f7c:	0801f468 	.word	0x0801f468
 8018f80:	0000c350 	.word	0x0000c350
 8018f84:	00014585 	.word	0x00014585
 8018f88:	0801f498 	.word	0x0801f498
 8018f8c:	0801f490 	.word	0x0801f490

08018f90 <RegionEU868TxConfig>:

bool RegionEU868TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 8018f90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018f92:	b093      	sub	sp, #76	; 0x4c
 8018f94:	af0a      	add	r7, sp, #40	; 0x28
 8018f96:	60f8      	str	r0, [r7, #12]
 8018f98:	60b9      	str	r1, [r7, #8]
 8018f9a:	607a      	str	r2, [r7, #4]
    RadioModems_t modem;
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 8018f9c:	68fb      	ldr	r3, [r7, #12]
 8018f9e:	785b      	ldrb	r3, [r3, #1]
 8018fa0:	b25b      	sxtb	r3, r3
 8018fa2:	001a      	movs	r2, r3
 8018fa4:	4b61      	ldr	r3, [pc, #388]	; (801912c <RegionEU868TxConfig+0x19c>)
 8018fa6:	5c9a      	ldrb	r2, [r3, r2]
 8018fa8:	251e      	movs	r5, #30
 8018faa:	197b      	adds	r3, r7, r5
 8018fac:	701a      	strb	r2, [r3, #0]
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, NvmCtx.Bands[NvmCtx.Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, NvmCtx.ChannelsMask );
 8018fae:	68fb      	ldr	r3, [r7, #12]
 8018fb0:	2002      	movs	r0, #2
 8018fb2:	5618      	ldrsb	r0, [r3, r0]
 8018fb4:	68fb      	ldr	r3, [r7, #12]
 8018fb6:	781b      	ldrb	r3, [r3, #0]
 8018fb8:	0019      	movs	r1, r3
 8018fba:	4a5d      	ldr	r2, [pc, #372]	; (8019130 <RegionEU868TxConfig+0x1a0>)
 8018fbc:	000b      	movs	r3, r1
 8018fbe:	005b      	lsls	r3, r3, #1
 8018fc0:	185b      	adds	r3, r3, r1
 8018fc2:	009b      	lsls	r3, r3, #2
 8018fc4:	18d3      	adds	r3, r2, r3
 8018fc6:	3309      	adds	r3, #9
 8018fc8:	781b      	ldrb	r3, [r3, #0]
 8018fca:	4a59      	ldr	r2, [pc, #356]	; (8019130 <RegionEU868TxConfig+0x1a0>)
 8018fcc:	330c      	adds	r3, #12
 8018fce:	011b      	lsls	r3, r3, #4
 8018fd0:	18d3      	adds	r3, r2, r3
 8018fd2:	3302      	adds	r3, #2
 8018fd4:	2100      	movs	r1, #0
 8018fd6:	5659      	ldrsb	r1, [r3, r1]
 8018fd8:	68fb      	ldr	r3, [r7, #12]
 8018fda:	2201      	movs	r2, #1
 8018fdc:	569a      	ldrsb	r2, [r3, r2]
 8018fde:	261d      	movs	r6, #29
 8018fe0:	19bc      	adds	r4, r7, r6
 8018fe2:	4b54      	ldr	r3, [pc, #336]	; (8019134 <RegionEU868TxConfig+0x1a4>)
 8018fe4:	f7ff fa2c 	bl	8018440 <LimitTxPower>
 8018fe8:	0003      	movs	r3, r0
 8018fea:	7023      	strb	r3, [r4, #0]
    uint32_t bandwidth = GetBandwidth( txConfig->Datarate );
 8018fec:	68fb      	ldr	r3, [r7, #12]
 8018fee:	785b      	ldrb	r3, [r3, #1]
 8018ff0:	b25b      	sxtb	r3, r3
 8018ff2:	0018      	movs	r0, r3
 8018ff4:	f7ff fa06 	bl	8018404 <GetBandwidth>
 8018ff8:	0003      	movs	r3, r0
 8018ffa:	61bb      	str	r3, [r7, #24]
    int8_t phyTxPower = 0;
 8018ffc:	2017      	movs	r0, #23
 8018ffe:	183b      	adds	r3, r7, r0
 8019000:	2200      	movs	r2, #0
 8019002:	701a      	strb	r2, [r3, #0]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 8019004:	68fb      	ldr	r3, [r7, #12]
 8019006:	6859      	ldr	r1, [r3, #4]
 8019008:	68fb      	ldr	r3, [r7, #12]
 801900a:	689a      	ldr	r2, [r3, #8]
 801900c:	183c      	adds	r4, r7, r0
 801900e:	19bb      	adds	r3, r7, r6
 8019010:	781b      	ldrb	r3, [r3, #0]
 8019012:	b25b      	sxtb	r3, r3
 8019014:	0018      	movs	r0, r3
 8019016:	f7ff f907 	bl	8018228 <RegionCommonComputeTxPower>
 801901a:	0003      	movs	r3, r0
 801901c:	7023      	strb	r3, [r4, #0]

    // Setup the radio frequency
    Radio.SetChannel( NvmCtx.Channels[txConfig->Channel].Frequency );
 801901e:	4b46      	ldr	r3, [pc, #280]	; (8019138 <RegionEU868TxConfig+0x1a8>)
 8019020:	695a      	ldr	r2, [r3, #20]
 8019022:	68fb      	ldr	r3, [r7, #12]
 8019024:	781b      	ldrb	r3, [r3, #0]
 8019026:	0018      	movs	r0, r3
 8019028:	4941      	ldr	r1, [pc, #260]	; (8019130 <RegionEU868TxConfig+0x1a0>)
 801902a:	0003      	movs	r3, r0
 801902c:	005b      	lsls	r3, r3, #1
 801902e:	181b      	adds	r3, r3, r0
 8019030:	009b      	lsls	r3, r3, #2
 8019032:	585b      	ldr	r3, [r3, r1]
 8019034:	0018      	movs	r0, r3
 8019036:	4790      	blx	r2

    if( txConfig->Datarate == DR_7 )
 8019038:	68fb      	ldr	r3, [r7, #12]
 801903a:	785b      	ldrb	r3, [r3, #1]
 801903c:	b25b      	sxtb	r3, r3
 801903e:	2b07      	cmp	r3, #7
 8019040:	d12e      	bne.n	80190a0 <RegionEU868TxConfig+0x110>
    { // High Speed FSK channel
        modem = MODEM_FSK;
 8019042:	231f      	movs	r3, #31
 8019044:	18fb      	adds	r3, r7, r3
 8019046:	2200      	movs	r2, #0
 8019048:	701a      	strb	r2, [r3, #0]
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 801904a:	4b3b      	ldr	r3, [pc, #236]	; (8019138 <RegionEU868TxConfig+0x1a8>)
 801904c:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 801904e:	197b      	adds	r3, r7, r5
 8019050:	2200      	movs	r2, #0
 8019052:	569a      	ldrsb	r2, [r3, r2]
 8019054:	0013      	movs	r3, r2
 8019056:	015b      	lsls	r3, r3, #5
 8019058:	1a9b      	subs	r3, r3, r2
 801905a:	009b      	lsls	r3, r3, #2
 801905c:	189b      	adds	r3, r3, r2
 801905e:	00db      	lsls	r3, r3, #3
 8019060:	001e      	movs	r6, r3
 8019062:	69ba      	ldr	r2, [r7, #24]
 8019064:	4d35      	ldr	r5, [pc, #212]	; (801913c <RegionEU868TxConfig+0x1ac>)
 8019066:	2017      	movs	r0, #23
 8019068:	183b      	adds	r3, r7, r0
 801906a:	2100      	movs	r1, #0
 801906c:	5659      	ldrsb	r1, [r3, r1]
 801906e:	231f      	movs	r3, #31
 8019070:	18fb      	adds	r3, r7, r3
 8019072:	7818      	ldrb	r0, [r3, #0]
 8019074:	23fa      	movs	r3, #250	; 0xfa
 8019076:	011b      	lsls	r3, r3, #4
 8019078:	9308      	str	r3, [sp, #32]
 801907a:	2300      	movs	r3, #0
 801907c:	9307      	str	r3, [sp, #28]
 801907e:	2300      	movs	r3, #0
 8019080:	9306      	str	r3, [sp, #24]
 8019082:	2300      	movs	r3, #0
 8019084:	9305      	str	r3, [sp, #20]
 8019086:	2301      	movs	r3, #1
 8019088:	9304      	str	r3, [sp, #16]
 801908a:	2300      	movs	r3, #0
 801908c:	9303      	str	r3, [sp, #12]
 801908e:	2305      	movs	r3, #5
 8019090:	9302      	str	r3, [sp, #8]
 8019092:	2300      	movs	r3, #0
 8019094:	9301      	str	r3, [sp, #4]
 8019096:	9600      	str	r6, [sp, #0]
 8019098:	0013      	movs	r3, r2
 801909a:	002a      	movs	r2, r5
 801909c:	47a0      	blx	r4
 801909e:	e025      	b.n	80190ec <RegionEU868TxConfig+0x15c>
    }
    else
    {
        modem = MODEM_LORA;
 80190a0:	201f      	movs	r0, #31
 80190a2:	183b      	adds	r3, r7, r0
 80190a4:	2201      	movs	r2, #1
 80190a6:	701a      	strb	r2, [r3, #0]
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 80190a8:	4b23      	ldr	r3, [pc, #140]	; (8019138 <RegionEU868TxConfig+0x1a8>)
 80190aa:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80190ac:	231e      	movs	r3, #30
 80190ae:	18fb      	adds	r3, r7, r3
 80190b0:	781b      	ldrb	r3, [r3, #0]
 80190b2:	b25b      	sxtb	r3, r3
 80190b4:	69bd      	ldr	r5, [r7, #24]
 80190b6:	2217      	movs	r2, #23
 80190b8:	18ba      	adds	r2, r7, r2
 80190ba:	2100      	movs	r1, #0
 80190bc:	5651      	ldrsb	r1, [r2, r1]
 80190be:	183a      	adds	r2, r7, r0
 80190c0:	7810      	ldrb	r0, [r2, #0]
 80190c2:	22fa      	movs	r2, #250	; 0xfa
 80190c4:	0112      	lsls	r2, r2, #4
 80190c6:	9208      	str	r2, [sp, #32]
 80190c8:	2200      	movs	r2, #0
 80190ca:	9207      	str	r2, [sp, #28]
 80190cc:	2200      	movs	r2, #0
 80190ce:	9206      	str	r2, [sp, #24]
 80190d0:	2200      	movs	r2, #0
 80190d2:	9205      	str	r2, [sp, #20]
 80190d4:	2201      	movs	r2, #1
 80190d6:	9204      	str	r2, [sp, #16]
 80190d8:	2200      	movs	r2, #0
 80190da:	9203      	str	r2, [sp, #12]
 80190dc:	2208      	movs	r2, #8
 80190de:	9202      	str	r2, [sp, #8]
 80190e0:	2201      	movs	r2, #1
 80190e2:	9201      	str	r2, [sp, #4]
 80190e4:	9300      	str	r3, [sp, #0]
 80190e6:	002b      	movs	r3, r5
 80190e8:	2200      	movs	r2, #0
 80190ea:	47a0      	blx	r4
    }
    TVL1( PRINTF( "TX on freq %d Hz at DR %d\n\r", NvmCtx.Channels[txConfig->Channel].Frequency, txConfig->Datarate );)

    // Setup maximum payload lenght of the radio driver
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 80190ec:	4b12      	ldr	r3, [pc, #72]	; (8019138 <RegionEU868TxConfig+0x1a8>)
 80190ee:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80190f0:	68fa      	ldr	r2, [r7, #12]
 80190f2:	8992      	ldrh	r2, [r2, #12]
 80190f4:	b2d1      	uxtb	r1, r2
 80190f6:	241f      	movs	r4, #31
 80190f8:	193a      	adds	r2, r7, r4
 80190fa:	7812      	ldrb	r2, [r2, #0]
 80190fc:	0010      	movs	r0, r2
 80190fe:	4798      	blx	r3
    // Get the time-on-air of the next tx frame
    *txTimeOnAir = Radio.TimeOnAir( modem, txConfig->PktLen );
 8019100:	4b0d      	ldr	r3, [pc, #52]	; (8019138 <RegionEU868TxConfig+0x1a8>)
 8019102:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8019104:	68fa      	ldr	r2, [r7, #12]
 8019106:	8992      	ldrh	r2, [r2, #12]
 8019108:	b2d1      	uxtb	r1, r2
 801910a:	193a      	adds	r2, r7, r4
 801910c:	7812      	ldrb	r2, [r2, #0]
 801910e:	0010      	movs	r0, r2
 8019110:	4798      	blx	r3
 8019112:	0002      	movs	r2, r0
 8019114:	687b      	ldr	r3, [r7, #4]
 8019116:	601a      	str	r2, [r3, #0]

    *txPower = txPowerLimited;
 8019118:	68bb      	ldr	r3, [r7, #8]
 801911a:	221d      	movs	r2, #29
 801911c:	18ba      	adds	r2, r7, r2
 801911e:	7812      	ldrb	r2, [r2, #0]
 8019120:	701a      	strb	r2, [r3, #0]
    return true;
 8019122:	2301      	movs	r3, #1
}
 8019124:	0018      	movs	r0, r3
 8019126:	46bd      	mov	sp, r7
 8019128:	b009      	add	sp, #36	; 0x24
 801912a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801912c:	0801f468 	.word	0x0801f468
 8019130:	200010c0 	.word	0x200010c0
 8019134:	200011e0 	.word	0x200011e0
 8019138:	0801ebd0 	.word	0x0801ebd0
 801913c:	000061a8 	.word	0x000061a8

08019140 <RegionEU868LinkAdrReq>:

uint8_t RegionEU868LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 8019140:	b5f0      	push	{r4, r5, r6, r7, lr}
 8019142:	b093      	sub	sp, #76	; 0x4c
 8019144:	af00      	add	r7, sp, #0
 8019146:	60f8      	str	r0, [r7, #12]
 8019148:	60b9      	str	r1, [r7, #8]
 801914a:	607a      	str	r2, [r7, #4]
 801914c:	603b      	str	r3, [r7, #0]
    uint8_t status = 0x07;
 801914e:	2347      	movs	r3, #71	; 0x47
 8019150:	18fb      	adds	r3, r7, r3
 8019152:	2207      	movs	r2, #7
 8019154:	701a      	strb	r2, [r3, #0]
    RegionCommonLinkAdrParams_t linkAdrParams;
    uint8_t nextIndex = 0;
 8019156:	2344      	movs	r3, #68	; 0x44
 8019158:	18fb      	adds	r3, r7, r3
 801915a:	2200      	movs	r2, #0
 801915c:	701a      	strb	r2, [r3, #0]
    uint8_t bytesProcessed = 0;
 801915e:	2346      	movs	r3, #70	; 0x46
 8019160:	18fb      	adds	r3, r7, r3
 8019162:	2200      	movs	r2, #0
 8019164:	701a      	strb	r2, [r3, #0]
    uint16_t chMask = 0;
 8019166:	233a      	movs	r3, #58	; 0x3a
 8019168:	18fb      	adds	r3, r7, r3
 801916a:	2200      	movs	r2, #0
 801916c:	801a      	strh	r2, [r3, #0]
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;

    while( bytesProcessed < linkAdrReq->PayloadSize )
 801916e:	e098      	b.n	80192a2 <RegionEU868LinkAdrReq+0x162>
    {
        // Get ADR request parameters
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 8019170:	68fb      	ldr	r3, [r7, #12]
 8019172:	685a      	ldr	r2, [r3, #4]
 8019174:	2546      	movs	r5, #70	; 0x46
 8019176:	197b      	adds	r3, r7, r5
 8019178:	781b      	ldrb	r3, [r3, #0]
 801917a:	18d3      	adds	r3, r2, r3
 801917c:	2644      	movs	r6, #68	; 0x44
 801917e:	19bc      	adds	r4, r7, r6
 8019180:	203c      	movs	r0, #60	; 0x3c
 8019182:	183a      	adds	r2, r7, r0
 8019184:	0011      	movs	r1, r2
 8019186:	0018      	movs	r0, r3
 8019188:	f7fe fe91 	bl	8017eae <RegionCommonParseLinkAdrReq>
 801918c:	0003      	movs	r3, r0
 801918e:	7023      	strb	r3, [r4, #0]

        if( nextIndex == 0 )
 8019190:	0032      	movs	r2, r6
 8019192:	18bb      	adds	r3, r7, r2
 8019194:	781b      	ldrb	r3, [r3, #0]
 8019196:	2b00      	cmp	r3, #0
 8019198:	d100      	bne.n	801919c <RegionEU868LinkAdrReq+0x5c>
 801919a:	e08b      	b.n	80192b4 <RegionEU868LinkAdrReq+0x174>
            break; // break loop, since no more request has been found

        // Update bytes processed
        bytesProcessed += nextIndex;
 801919c:	197b      	adds	r3, r7, r5
 801919e:	1979      	adds	r1, r7, r5
 80191a0:	18ba      	adds	r2, r7, r2
 80191a2:	7809      	ldrb	r1, [r1, #0]
 80191a4:	7812      	ldrb	r2, [r2, #0]
 80191a6:	188a      	adds	r2, r1, r2
 80191a8:	701a      	strb	r2, [r3, #0]

        // Revert status, as we only check the last ADR request for the channel mask KO
        status = 0x07;
 80191aa:	2147      	movs	r1, #71	; 0x47
 80191ac:	187b      	adds	r3, r7, r1
 80191ae:	2207      	movs	r2, #7
 80191b0:	701a      	strb	r2, [r3, #0]

        // Setup temporary channels mask
        chMask = linkAdrParams.ChMask;
 80191b2:	203c      	movs	r0, #60	; 0x3c
 80191b4:	183b      	adds	r3, r7, r0
 80191b6:	889a      	ldrh	r2, [r3, #4]
 80191b8:	243a      	movs	r4, #58	; 0x3a
 80191ba:	193b      	adds	r3, r7, r4
 80191bc:	801a      	strh	r2, [r3, #0]

        // Verify channels mask
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 80191be:	183b      	adds	r3, r7, r0
 80191c0:	78db      	ldrb	r3, [r3, #3]
 80191c2:	2b00      	cmp	r3, #0
 80191c4:	d10a      	bne.n	80191dc <RegionEU868LinkAdrReq+0x9c>
 80191c6:	193b      	adds	r3, r7, r4
 80191c8:	881b      	ldrh	r3, [r3, #0]
 80191ca:	2b00      	cmp	r3, #0
 80191cc:	d106      	bne.n	80191dc <RegionEU868LinkAdrReq+0x9c>
        {
            status &= 0xFE; // Channel mask KO
 80191ce:	187b      	adds	r3, r7, r1
 80191d0:	187a      	adds	r2, r7, r1
 80191d2:	7812      	ldrb	r2, [r2, #0]
 80191d4:	2101      	movs	r1, #1
 80191d6:	438a      	bics	r2, r1
 80191d8:	701a      	strb	r2, [r3, #0]
 80191da:	e062      	b.n	80192a2 <RegionEU868LinkAdrReq+0x162>
        }
        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
 80191dc:	223c      	movs	r2, #60	; 0x3c
 80191de:	18bb      	adds	r3, r7, r2
 80191e0:	78db      	ldrb	r3, [r3, #3]
 80191e2:	2b00      	cmp	r3, #0
 80191e4:	d003      	beq.n	80191ee <RegionEU868LinkAdrReq+0xae>
 80191e6:	18bb      	adds	r3, r7, r2
 80191e8:	78db      	ldrb	r3, [r3, #3]
 80191ea:	2b05      	cmp	r3, #5
 80191ec:	d904      	bls.n	80191f8 <RegionEU868LinkAdrReq+0xb8>
                ( linkAdrParams.ChMaskCtrl >= 7 ) )
 80191ee:	233c      	movs	r3, #60	; 0x3c
 80191f0:	18fb      	adds	r3, r7, r3
 80191f2:	78db      	ldrb	r3, [r3, #3]
        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
 80191f4:	2b06      	cmp	r3, #6
 80191f6:	d907      	bls.n	8019208 <RegionEU868LinkAdrReq+0xc8>
        {
            // RFU
            status &= 0xFE; // Channel mask KO
 80191f8:	2247      	movs	r2, #71	; 0x47
 80191fa:	18bb      	adds	r3, r7, r2
 80191fc:	18ba      	adds	r2, r7, r2
 80191fe:	7812      	ldrb	r2, [r2, #0]
 8019200:	2101      	movs	r1, #1
 8019202:	438a      	bics	r2, r1
 8019204:	701a      	strb	r2, [r3, #0]
 8019206:	e04c      	b.n	80192a2 <RegionEU868LinkAdrReq+0x162>
        }
        else
        {
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 8019208:	2345      	movs	r3, #69	; 0x45
 801920a:	18fb      	adds	r3, r7, r3
 801920c:	2200      	movs	r2, #0
 801920e:	701a      	strb	r2, [r3, #0]
 8019210:	e042      	b.n	8019298 <RegionEU868LinkAdrReq+0x158>
            {
                if( linkAdrParams.ChMaskCtrl == 6 )
 8019212:	233c      	movs	r3, #60	; 0x3c
 8019214:	18fb      	adds	r3, r7, r3
 8019216:	78db      	ldrb	r3, [r3, #3]
 8019218:	2b06      	cmp	r3, #6
 801921a:	d11a      	bne.n	8019252 <RegionEU868LinkAdrReq+0x112>
                {
                    if( NvmCtx.Channels[i].Frequency != 0 )
 801921c:	2045      	movs	r0, #69	; 0x45
 801921e:	183b      	adds	r3, r7, r0
 8019220:	781a      	ldrb	r2, [r3, #0]
 8019222:	496d      	ldr	r1, [pc, #436]	; (80193d8 <RegionEU868LinkAdrReq+0x298>)
 8019224:	0013      	movs	r3, r2
 8019226:	005b      	lsls	r3, r3, #1
 8019228:	189b      	adds	r3, r3, r2
 801922a:	009b      	lsls	r3, r3, #2
 801922c:	585b      	ldr	r3, [r3, r1]
 801922e:	2b00      	cmp	r3, #0
 8019230:	d02c      	beq.n	801928c <RegionEU868LinkAdrReq+0x14c>
                    {
                        chMask |= 1 << i;
 8019232:	183b      	adds	r3, r7, r0
 8019234:	781b      	ldrb	r3, [r3, #0]
 8019236:	2201      	movs	r2, #1
 8019238:	409a      	lsls	r2, r3
 801923a:	0013      	movs	r3, r2
 801923c:	b21a      	sxth	r2, r3
 801923e:	213a      	movs	r1, #58	; 0x3a
 8019240:	187b      	adds	r3, r7, r1
 8019242:	881b      	ldrh	r3, [r3, #0]
 8019244:	b21b      	sxth	r3, r3
 8019246:	4313      	orrs	r3, r2
 8019248:	b21b      	sxth	r3, r3
 801924a:	b29a      	uxth	r2, r3
 801924c:	187b      	adds	r3, r7, r1
 801924e:	801a      	strh	r2, [r3, #0]
 8019250:	e01c      	b.n	801928c <RegionEU868LinkAdrReq+0x14c>
                    }
                }
                else
                {
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 8019252:	233a      	movs	r3, #58	; 0x3a
 8019254:	18fb      	adds	r3, r7, r3
 8019256:	881b      	ldrh	r3, [r3, #0]
 8019258:	001a      	movs	r2, r3
 801925a:	2145      	movs	r1, #69	; 0x45
 801925c:	187b      	adds	r3, r7, r1
 801925e:	781b      	ldrb	r3, [r3, #0]
 8019260:	411a      	asrs	r2, r3
 8019262:	0013      	movs	r3, r2
 8019264:	2201      	movs	r2, #1
 8019266:	4013      	ands	r3, r2
 8019268:	d010      	beq.n	801928c <RegionEU868LinkAdrReq+0x14c>
                        ( NvmCtx.Channels[i].Frequency == 0 ) )
 801926a:	187b      	adds	r3, r7, r1
 801926c:	781a      	ldrb	r2, [r3, #0]
 801926e:	495a      	ldr	r1, [pc, #360]	; (80193d8 <RegionEU868LinkAdrReq+0x298>)
 8019270:	0013      	movs	r3, r2
 8019272:	005b      	lsls	r3, r3, #1
 8019274:	189b      	adds	r3, r3, r2
 8019276:	009b      	lsls	r3, r3, #2
 8019278:	585b      	ldr	r3, [r3, r1]
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 801927a:	2b00      	cmp	r3, #0
 801927c:	d106      	bne.n	801928c <RegionEU868LinkAdrReq+0x14c>
                    {// Trying to enable an undefined channel
                        status &= 0xFE; // Channel mask KO
 801927e:	2247      	movs	r2, #71	; 0x47
 8019280:	18bb      	adds	r3, r7, r2
 8019282:	18ba      	adds	r2, r7, r2
 8019284:	7812      	ldrb	r2, [r2, #0]
 8019286:	2101      	movs	r1, #1
 8019288:	438a      	bics	r2, r1
 801928a:	701a      	strb	r2, [r3, #0]
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 801928c:	2145      	movs	r1, #69	; 0x45
 801928e:	187b      	adds	r3, r7, r1
 8019290:	781a      	ldrb	r2, [r3, #0]
 8019292:	187b      	adds	r3, r7, r1
 8019294:	3201      	adds	r2, #1
 8019296:	701a      	strb	r2, [r3, #0]
 8019298:	2345      	movs	r3, #69	; 0x45
 801929a:	18fb      	adds	r3, r7, r3
 801929c:	781b      	ldrb	r3, [r3, #0]
 801929e:	2b0f      	cmp	r3, #15
 80192a0:	d9b7      	bls.n	8019212 <RegionEU868LinkAdrReq+0xd2>
    while( bytesProcessed < linkAdrReq->PayloadSize )
 80192a2:	68fb      	ldr	r3, [r7, #12]
 80192a4:	7a1b      	ldrb	r3, [r3, #8]
 80192a6:	2246      	movs	r2, #70	; 0x46
 80192a8:	18ba      	adds	r2, r7, r2
 80192aa:	7812      	ldrb	r2, [r2, #0]
 80192ac:	429a      	cmp	r2, r3
 80192ae:	d200      	bcs.n	80192b2 <RegionEU868LinkAdrReq+0x172>
 80192b0:	e75e      	b.n	8019170 <RegionEU868LinkAdrReq+0x30>
 80192b2:	e000      	b.n	80192b6 <RegionEU868LinkAdrReq+0x176>
            break; // break loop, since no more request has been found
 80192b4:	46c0      	nop			; (mov r8, r8)
            }
        }
    }

    // Get the minimum possible datarate
    getPhy.Attribute = PHY_MIN_TX_DR;
 80192b6:	2134      	movs	r1, #52	; 0x34
 80192b8:	187b      	adds	r3, r7, r1
 80192ba:	2202      	movs	r2, #2
 80192bc:	701a      	strb	r2, [r3, #0]
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
 80192be:	68fb      	ldr	r3, [r7, #12]
 80192c0:	7a5a      	ldrb	r2, [r3, #9]
 80192c2:	187b      	adds	r3, r7, r1
 80192c4:	709a      	strb	r2, [r3, #2]
    phyParam = RegionEU868GetPhyParam( &getPhy );
 80192c6:	187b      	adds	r3, r7, r1
 80192c8:	0018      	movs	r0, r3
 80192ca:	f7ff fa3b 	bl	8018744 <RegionEU868GetPhyParam>
 80192ce:	0003      	movs	r3, r0
 80192d0:	001a      	movs	r2, r3
 80192d2:	2030      	movs	r0, #48	; 0x30
 80192d4:	183b      	adds	r3, r7, r0
 80192d6:	601a      	str	r2, [r3, #0]

    linkAdrVerifyParams.Status = status;
 80192d8:	2110      	movs	r1, #16
 80192da:	187b      	adds	r3, r7, r1
 80192dc:	2447      	movs	r4, #71	; 0x47
 80192de:	193a      	adds	r2, r7, r4
 80192e0:	7812      	ldrb	r2, [r2, #0]
 80192e2:	711a      	strb	r2, [r3, #4]
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 80192e4:	68fb      	ldr	r3, [r7, #12]
 80192e6:	7a9a      	ldrb	r2, [r3, #10]
 80192e8:	187b      	adds	r3, r7, r1
 80192ea:	715a      	strb	r2, [r3, #5]
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 80192ec:	253c      	movs	r5, #60	; 0x3c
 80192ee:	197b      	adds	r3, r7, r5
 80192f0:	2201      	movs	r2, #1
 80192f2:	569a      	ldrsb	r2, [r3, r2]
 80192f4:	187b      	adds	r3, r7, r1
 80192f6:	719a      	strb	r2, [r3, #6]
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 80192f8:	197b      	adds	r3, r7, r5
 80192fa:	2202      	movs	r2, #2
 80192fc:	569a      	ldrsb	r2, [r3, r2]
 80192fe:	187b      	adds	r3, r7, r1
 8019300:	71da      	strb	r2, [r3, #7]
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 8019302:	197b      	adds	r3, r7, r5
 8019304:	781a      	ldrb	r2, [r3, #0]
 8019306:	187b      	adds	r3, r7, r1
 8019308:	721a      	strb	r2, [r3, #8]
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 801930a:	68fb      	ldr	r3, [r7, #12]
 801930c:	220b      	movs	r2, #11
 801930e:	569a      	ldrsb	r2, [r3, r2]
 8019310:	187b      	adds	r3, r7, r1
 8019312:	725a      	strb	r2, [r3, #9]
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 8019314:	68fb      	ldr	r3, [r7, #12]
 8019316:	220c      	movs	r2, #12
 8019318:	569a      	ldrsb	r2, [r3, r2]
 801931a:	187b      	adds	r3, r7, r1
 801931c:	729a      	strb	r2, [r3, #10]
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 801931e:	68fb      	ldr	r3, [r7, #12]
 8019320:	7b5b      	ldrb	r3, [r3, #13]
 8019322:	b25a      	sxtb	r2, r3
 8019324:	187b      	adds	r3, r7, r1
 8019326:	72da      	strb	r2, [r3, #11]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 8019328:	187b      	adds	r3, r7, r1
 801932a:	2210      	movs	r2, #16
 801932c:	731a      	strb	r2, [r3, #12]
    linkAdrVerifyParams.ChannelsMask = &chMask;
 801932e:	187b      	adds	r3, r7, r1
 8019330:	223a      	movs	r2, #58	; 0x3a
 8019332:	18ba      	adds	r2, r7, r2
 8019334:	611a      	str	r2, [r3, #16]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 8019336:	183b      	adds	r3, r7, r0
 8019338:	681b      	ldr	r3, [r3, #0]
 801933a:	b25a      	sxtb	r2, r3
 801933c:	0008      	movs	r0, r1
 801933e:	183b      	adds	r3, r7, r0
 8019340:	751a      	strb	r2, [r3, #20]
    linkAdrVerifyParams.MaxDatarate = EU868_TX_MAX_DATARATE;
 8019342:	183b      	adds	r3, r7, r0
 8019344:	2207      	movs	r2, #7
 8019346:	755a      	strb	r2, [r3, #21]
    linkAdrVerifyParams.Channels = NvmCtx.Channels;
 8019348:	183b      	adds	r3, r7, r0
 801934a:	4a23      	ldr	r2, [pc, #140]	; (80193d8 <RegionEU868LinkAdrReq+0x298>)
 801934c:	619a      	str	r2, [r3, #24]
    linkAdrVerifyParams.MinTxPower = EU868_MIN_TX_POWER;
 801934e:	183b      	adds	r3, r7, r0
 8019350:	2207      	movs	r2, #7
 8019352:	771a      	strb	r2, [r3, #28]
    linkAdrVerifyParams.MaxTxPower = EU868_MAX_TX_POWER;
 8019354:	183b      	adds	r3, r7, r0
 8019356:	2200      	movs	r2, #0
 8019358:	775a      	strb	r2, [r3, #29]
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 801935a:	183b      	adds	r3, r7, r0
 801935c:	68fa      	ldr	r2, [r7, #12]
 801935e:	6812      	ldr	r2, [r2, #0]
 8019360:	601a      	str	r2, [r3, #0]

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8019362:	0026      	movs	r6, r4
 8019364:	193c      	adds	r4, r7, r4
 8019366:	0029      	movs	r1, r5
 8019368:	187d      	adds	r5, r7, r1
 801936a:	187b      	adds	r3, r7, r1
 801936c:	1c9a      	adds	r2, r3, #2
 801936e:	187b      	adds	r3, r7, r1
 8019370:	1c59      	adds	r1, r3, #1
 8019372:	1838      	adds	r0, r7, r0
 8019374:	002b      	movs	r3, r5
 8019376:	f7fe fdef 	bl	8017f58 <RegionCommonLinkAdrReqVerifyParams>
 801937a:	0003      	movs	r3, r0
 801937c:	7023      	strb	r3, [r4, #0]

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 801937e:	19bb      	adds	r3, r7, r6
 8019380:	781b      	ldrb	r3, [r3, #0]
 8019382:	2b07      	cmp	r3, #7
 8019384:	d10c      	bne.n	80193a0 <RegionEU868LinkAdrReq+0x260>
    {
        // Set the channels mask to a default value
        memset1( ( uint8_t* ) NvmCtx.ChannelsMask, 0, sizeof( NvmCtx.ChannelsMask ) );
 8019386:	4b15      	ldr	r3, [pc, #84]	; (80193dc <RegionEU868LinkAdrReq+0x29c>)
 8019388:	2202      	movs	r2, #2
 801938a:	2100      	movs	r1, #0
 801938c:	0018      	movs	r0, r3
 801938e:	f002 f919 	bl	801b5c4 <memset1>
        // Update the channels mask
        NvmCtx.ChannelsMask[0] = chMask;
 8019392:	223a      	movs	r2, #58	; 0x3a
 8019394:	18bb      	adds	r3, r7, r2
 8019396:	8819      	ldrh	r1, [r3, #0]
 8019398:	4a0f      	ldr	r2, [pc, #60]	; (80193d8 <RegionEU868LinkAdrReq+0x298>)
 801939a:	2390      	movs	r3, #144	; 0x90
 801939c:	005b      	lsls	r3, r3, #1
 801939e:	52d1      	strh	r1, [r2, r3]
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 80193a0:	213c      	movs	r1, #60	; 0x3c
 80193a2:	187b      	adds	r3, r7, r1
 80193a4:	2201      	movs	r2, #1
 80193a6:	569a      	ldrsb	r2, [r3, r2]
 80193a8:	68bb      	ldr	r3, [r7, #8]
 80193aa:	701a      	strb	r2, [r3, #0]
    *txPowOut = linkAdrParams.TxPower;
 80193ac:	187b      	adds	r3, r7, r1
 80193ae:	2202      	movs	r2, #2
 80193b0:	569a      	ldrsb	r2, [r3, r2]
 80193b2:	687b      	ldr	r3, [r7, #4]
 80193b4:	701a      	strb	r2, [r3, #0]
    *nbRepOut = linkAdrParams.NbRep;
 80193b6:	187b      	adds	r3, r7, r1
 80193b8:	781a      	ldrb	r2, [r3, #0]
 80193ba:	683b      	ldr	r3, [r7, #0]
 80193bc:	701a      	strb	r2, [r3, #0]
    *nbBytesParsed = bytesProcessed;
 80193be:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80193c0:	2246      	movs	r2, #70	; 0x46
 80193c2:	18ba      	adds	r2, r7, r2
 80193c4:	7812      	ldrb	r2, [r2, #0]
 80193c6:	701a      	strb	r2, [r3, #0]

    return status;
 80193c8:	2347      	movs	r3, #71	; 0x47
 80193ca:	18fb      	adds	r3, r7, r3
 80193cc:	781b      	ldrb	r3, [r3, #0]
}
 80193ce:	0018      	movs	r0, r3
 80193d0:	46bd      	mov	sp, r7
 80193d2:	b013      	add	sp, #76	; 0x4c
 80193d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80193d6:	46c0      	nop			; (mov r8, r8)
 80193d8:	200010c0 	.word	0x200010c0
 80193dc:	200011e0 	.word	0x200011e0

080193e0 <RegionEU868RxParamSetupReq>:

uint8_t RegionEU868RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 80193e0:	b590      	push	{r4, r7, lr}
 80193e2:	b085      	sub	sp, #20
 80193e4:	af00      	add	r7, sp, #0
 80193e6:	6078      	str	r0, [r7, #4]
    uint8_t status = 0x07;
 80193e8:	240f      	movs	r4, #15
 80193ea:	193b      	adds	r3, r7, r4
 80193ec:	2207      	movs	r2, #7
 80193ee:	701a      	strb	r2, [r3, #0]
    uint8_t band = 0;
 80193f0:	210e      	movs	r1, #14
 80193f2:	187b      	adds	r3, r7, r1
 80193f4:	2200      	movs	r2, #0
 80193f6:	701a      	strb	r2, [r3, #0]

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 80193f8:	687b      	ldr	r3, [r7, #4]
 80193fa:	685b      	ldr	r3, [r3, #4]
 80193fc:	187a      	adds	r2, r7, r1
 80193fe:	0011      	movs	r1, r2
 8019400:	0018      	movs	r0, r3
 8019402:	f7ff f845 	bl	8018490 <VerifyRfFreq>
 8019406:	0003      	movs	r3, r0
 8019408:	001a      	movs	r2, r3
 801940a:	2301      	movs	r3, #1
 801940c:	4053      	eors	r3, r2
 801940e:	b2db      	uxtb	r3, r3
 8019410:	2b00      	cmp	r3, #0
 8019412:	d005      	beq.n	8019420 <RegionEU868RxParamSetupReq+0x40>
    {
        status &= 0xFE; // Channel frequency KO
 8019414:	193b      	adds	r3, r7, r4
 8019416:	193a      	adds	r2, r7, r4
 8019418:	7812      	ldrb	r2, [r2, #0]
 801941a:	2101      	movs	r1, #1
 801941c:	438a      	bics	r2, r1
 801941e:	701a      	strb	r2, [r3, #0]
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 8019420:	687b      	ldr	r3, [r7, #4]
 8019422:	781b      	ldrb	r3, [r3, #0]
 8019424:	b25b      	sxtb	r3, r3
 8019426:	2207      	movs	r2, #7
 8019428:	2100      	movs	r1, #0
 801942a:	0018      	movs	r0, r3
 801942c:	f7fe fb89 	bl	8017b42 <RegionCommonValueInRange>
 8019430:	1e03      	subs	r3, r0, #0
 8019432:	d106      	bne.n	8019442 <RegionEU868RxParamSetupReq+0x62>
    {
        status &= 0xFD; // Datarate KO
 8019434:	220f      	movs	r2, #15
 8019436:	18bb      	adds	r3, r7, r2
 8019438:	18ba      	adds	r2, r7, r2
 801943a:	7812      	ldrb	r2, [r2, #0]
 801943c:	2102      	movs	r1, #2
 801943e:	438a      	bics	r2, r1
 8019440:	701a      	strb	r2, [r3, #0]
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, EU868_MIN_RX1_DR_OFFSET, EU868_MAX_RX1_DR_OFFSET ) == false )
 8019442:	687b      	ldr	r3, [r7, #4]
 8019444:	785b      	ldrb	r3, [r3, #1]
 8019446:	b25b      	sxtb	r3, r3
 8019448:	2205      	movs	r2, #5
 801944a:	2100      	movs	r1, #0
 801944c:	0018      	movs	r0, r3
 801944e:	f7fe fb78 	bl	8017b42 <RegionCommonValueInRange>
 8019452:	1e03      	subs	r3, r0, #0
 8019454:	d106      	bne.n	8019464 <RegionEU868RxParamSetupReq+0x84>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 8019456:	220f      	movs	r2, #15
 8019458:	18bb      	adds	r3, r7, r2
 801945a:	18ba      	adds	r2, r7, r2
 801945c:	7812      	ldrb	r2, [r2, #0]
 801945e:	2104      	movs	r1, #4
 8019460:	438a      	bics	r2, r1
 8019462:	701a      	strb	r2, [r3, #0]
    }

    return status;
 8019464:	230f      	movs	r3, #15
 8019466:	18fb      	adds	r3, r7, r3
 8019468:	781b      	ldrb	r3, [r3, #0]
}
 801946a:	0018      	movs	r0, r3
 801946c:	46bd      	mov	sp, r7
 801946e:	b005      	add	sp, #20
 8019470:	bd90      	pop	{r4, r7, pc}

08019472 <RegionEU868NewChannelReq>:

uint8_t RegionEU868NewChannelReq( NewChannelReqParams_t* newChannelReq )
{
 8019472:	b590      	push	{r4, r7, lr}
 8019474:	b087      	sub	sp, #28
 8019476:	af00      	add	r7, sp, #0
 8019478:	6078      	str	r0, [r7, #4]
    uint8_t status = 0x03;
 801947a:	2417      	movs	r4, #23
 801947c:	193b      	adds	r3, r7, r4
 801947e:	2203      	movs	r2, #3
 8019480:	701a      	strb	r2, [r3, #0]
    ChannelAddParams_t channelAdd;
    ChannelRemoveParams_t channelRemove;

    if( newChannelReq->NewChannel->Frequency == 0 )
 8019482:	687b      	ldr	r3, [r7, #4]
 8019484:	681b      	ldr	r3, [r3, #0]
 8019486:	681b      	ldr	r3, [r3, #0]
 8019488:	2b00      	cmp	r3, #0
 801948a:	d118      	bne.n	80194be <RegionEU868NewChannelReq+0x4c>
    {
        channelRemove.ChannelId = newChannelReq->ChannelId;
 801948c:	687b      	ldr	r3, [r7, #4]
 801948e:	791b      	ldrb	r3, [r3, #4]
 8019490:	b25b      	sxtb	r3, r3
 8019492:	b2da      	uxtb	r2, r3
 8019494:	2108      	movs	r1, #8
 8019496:	187b      	adds	r3, r7, r1
 8019498:	701a      	strb	r2, [r3, #0]

        // Remove
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 801949a:	187b      	adds	r3, r7, r1
 801949c:	0018      	movs	r0, r3
 801949e:	f000 fa57 	bl	8019950 <RegionEU868ChannelsRemove>
 80194a2:	0003      	movs	r3, r0
 80194a4:	001a      	movs	r2, r3
 80194a6:	2301      	movs	r3, #1
 80194a8:	4053      	eors	r3, r2
 80194aa:	b2db      	uxtb	r3, r3
 80194ac:	2b00      	cmp	r3, #0
 80194ae:	d041      	beq.n	8019534 <RegionEU868NewChannelReq+0xc2>
        {
            status &= 0xFC;
 80194b0:	193b      	adds	r3, r7, r4
 80194b2:	193a      	adds	r2, r7, r4
 80194b4:	7812      	ldrb	r2, [r2, #0]
 80194b6:	2103      	movs	r1, #3
 80194b8:	438a      	bics	r2, r1
 80194ba:	701a      	strb	r2, [r3, #0]
 80194bc:	e03a      	b.n	8019534 <RegionEU868NewChannelReq+0xc2>
        }
    }
    else
    {
        channelAdd.NewChannel = newChannelReq->NewChannel;
 80194be:	687b      	ldr	r3, [r7, #4]
 80194c0:	681a      	ldr	r2, [r3, #0]
 80194c2:	210c      	movs	r1, #12
 80194c4:	187b      	adds	r3, r7, r1
 80194c6:	601a      	str	r2, [r3, #0]
        channelAdd.ChannelId = newChannelReq->ChannelId;
 80194c8:	687b      	ldr	r3, [r7, #4]
 80194ca:	791b      	ldrb	r3, [r3, #4]
 80194cc:	b25b      	sxtb	r3, r3
 80194ce:	b2da      	uxtb	r2, r3
 80194d0:	187b      	adds	r3, r7, r1
 80194d2:	711a      	strb	r2, [r3, #4]

        switch( RegionEU868ChannelAdd( &channelAdd ) )
 80194d4:	187b      	adds	r3, r7, r1
 80194d6:	0018      	movs	r0, r3
 80194d8:	f000 f976 	bl	80197c8 <RegionEU868ChannelAdd>
 80194dc:	0003      	movs	r3, r0
 80194de:	2b06      	cmp	r3, #6
 80194e0:	d017      	beq.n	8019512 <RegionEU868NewChannelReq+0xa0>
 80194e2:	dc1e      	bgt.n	8019522 <RegionEU868NewChannelReq+0xb0>
 80194e4:	2b05      	cmp	r3, #5
 80194e6:	d00c      	beq.n	8019502 <RegionEU868NewChannelReq+0x90>
 80194e8:	dc1b      	bgt.n	8019522 <RegionEU868NewChannelReq+0xb0>
 80194ea:	2b00      	cmp	r3, #0
 80194ec:	d021      	beq.n	8019532 <RegionEU868NewChannelReq+0xc0>
 80194ee:	2b04      	cmp	r3, #4
 80194f0:	d117      	bne.n	8019522 <RegionEU868NewChannelReq+0xb0>
            {
                break;
            }
            case LORAMAC_STATUS_FREQUENCY_INVALID:
            {
                status &= 0xFE;
 80194f2:	2217      	movs	r2, #23
 80194f4:	18bb      	adds	r3, r7, r2
 80194f6:	18ba      	adds	r2, r7, r2
 80194f8:	7812      	ldrb	r2, [r2, #0]
 80194fa:	2101      	movs	r1, #1
 80194fc:	438a      	bics	r2, r1
 80194fe:	701a      	strb	r2, [r3, #0]
                break;
 8019500:	e018      	b.n	8019534 <RegionEU868NewChannelReq+0xc2>
            }
            case LORAMAC_STATUS_DATARATE_INVALID:
            {
                status &= 0xFD;
 8019502:	2217      	movs	r2, #23
 8019504:	18bb      	adds	r3, r7, r2
 8019506:	18ba      	adds	r2, r7, r2
 8019508:	7812      	ldrb	r2, [r2, #0]
 801950a:	2102      	movs	r1, #2
 801950c:	438a      	bics	r2, r1
 801950e:	701a      	strb	r2, [r3, #0]
                break;
 8019510:	e010      	b.n	8019534 <RegionEU868NewChannelReq+0xc2>
            }
            case LORAMAC_STATUS_FREQ_AND_DR_INVALID:
            {
                status &= 0xFC;
 8019512:	2217      	movs	r2, #23
 8019514:	18bb      	adds	r3, r7, r2
 8019516:	18ba      	adds	r2, r7, r2
 8019518:	7812      	ldrb	r2, [r2, #0]
 801951a:	2103      	movs	r1, #3
 801951c:	438a      	bics	r2, r1
 801951e:	701a      	strb	r2, [r3, #0]
                break;
 8019520:	e008      	b.n	8019534 <RegionEU868NewChannelReq+0xc2>
            }
            default:
            {
                status &= 0xFC;
 8019522:	2217      	movs	r2, #23
 8019524:	18bb      	adds	r3, r7, r2
 8019526:	18ba      	adds	r2, r7, r2
 8019528:	7812      	ldrb	r2, [r2, #0]
 801952a:	2103      	movs	r1, #3
 801952c:	438a      	bics	r2, r1
 801952e:	701a      	strb	r2, [r3, #0]
                break;
 8019530:	e000      	b.n	8019534 <RegionEU868NewChannelReq+0xc2>
                break;
 8019532:	46c0      	nop			; (mov r8, r8)
            }
        }
    }

    return status;
 8019534:	2317      	movs	r3, #23
 8019536:	18fb      	adds	r3, r7, r3
 8019538:	781b      	ldrb	r3, [r3, #0]
}
 801953a:	0018      	movs	r0, r3
 801953c:	46bd      	mov	sp, r7
 801953e:	b007      	add	sp, #28
 8019540:	bd90      	pop	{r4, r7, pc}

08019542 <RegionEU868TxParamSetupReq>:

int8_t RegionEU868TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
{
 8019542:	b580      	push	{r7, lr}
 8019544:	b082      	sub	sp, #8
 8019546:	af00      	add	r7, sp, #0
 8019548:	6078      	str	r0, [r7, #4]
    return -1;
 801954a:	2301      	movs	r3, #1
 801954c:	425b      	negs	r3, r3
}
 801954e:	0018      	movs	r0, r3
 8019550:	46bd      	mov	sp, r7
 8019552:	b002      	add	sp, #8
 8019554:	bd80      	pop	{r7, pc}
	...

08019558 <RegionEU868DlChannelReq>:

uint8_t RegionEU868DlChannelReq( DlChannelReqParams_t* dlChannelReq )
{
 8019558:	b590      	push	{r4, r7, lr}
 801955a:	b085      	sub	sp, #20
 801955c:	af00      	add	r7, sp, #0
 801955e:	6078      	str	r0, [r7, #4]
    uint8_t status = 0x03;
 8019560:	240f      	movs	r4, #15
 8019562:	193b      	adds	r3, r7, r4
 8019564:	2203      	movs	r2, #3
 8019566:	701a      	strb	r2, [r3, #0]
    uint8_t band = 0;
 8019568:	210e      	movs	r1, #14
 801956a:	187b      	adds	r3, r7, r1
 801956c:	2200      	movs	r2, #0
 801956e:	701a      	strb	r2, [r3, #0]

    // Verify if the frequency is supported
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 8019570:	687b      	ldr	r3, [r7, #4]
 8019572:	685b      	ldr	r3, [r3, #4]
 8019574:	187a      	adds	r2, r7, r1
 8019576:	0011      	movs	r1, r2
 8019578:	0018      	movs	r0, r3
 801957a:	f7fe ff89 	bl	8018490 <VerifyRfFreq>
 801957e:	0003      	movs	r3, r0
 8019580:	001a      	movs	r2, r3
 8019582:	2301      	movs	r3, #1
 8019584:	4053      	eors	r3, r2
 8019586:	b2db      	uxtb	r3, r3
 8019588:	2b00      	cmp	r3, #0
 801958a:	d005      	beq.n	8019598 <RegionEU868DlChannelReq+0x40>
    {
        status &= 0xFE;
 801958c:	193b      	adds	r3, r7, r4
 801958e:	193a      	adds	r2, r7, r4
 8019590:	7812      	ldrb	r2, [r2, #0]
 8019592:	2101      	movs	r1, #1
 8019594:	438a      	bics	r2, r1
 8019596:	701a      	strb	r2, [r3, #0]
    }

    // Verify if an uplink frequency exists
    if( NvmCtx.Channels[dlChannelReq->ChannelId].Frequency == 0 )
 8019598:	687b      	ldr	r3, [r7, #4]
 801959a:	781b      	ldrb	r3, [r3, #0]
 801959c:	0019      	movs	r1, r3
 801959e:	4a14      	ldr	r2, [pc, #80]	; (80195f0 <RegionEU868DlChannelReq+0x98>)
 80195a0:	000b      	movs	r3, r1
 80195a2:	005b      	lsls	r3, r3, #1
 80195a4:	185b      	adds	r3, r3, r1
 80195a6:	009b      	lsls	r3, r3, #2
 80195a8:	589b      	ldr	r3, [r3, r2]
 80195aa:	2b00      	cmp	r3, #0
 80195ac:	d106      	bne.n	80195bc <RegionEU868DlChannelReq+0x64>
    {
        status &= 0xFD;
 80195ae:	220f      	movs	r2, #15
 80195b0:	18bb      	adds	r3, r7, r2
 80195b2:	18ba      	adds	r2, r7, r2
 80195b4:	7812      	ldrb	r2, [r2, #0]
 80195b6:	2102      	movs	r1, #2
 80195b8:	438a      	bics	r2, r1
 80195ba:	701a      	strb	r2, [r3, #0]
    }

    // Apply Rx1 frequency, if the status is OK
    if( status == 0x03 )
 80195bc:	230f      	movs	r3, #15
 80195be:	18fb      	adds	r3, r7, r3
 80195c0:	781b      	ldrb	r3, [r3, #0]
 80195c2:	2b03      	cmp	r3, #3
 80195c4:	d10c      	bne.n	80195e0 <RegionEU868DlChannelReq+0x88>
    {
        NvmCtx.Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
 80195c6:	687b      	ldr	r3, [r7, #4]
 80195c8:	781b      	ldrb	r3, [r3, #0]
 80195ca:	0018      	movs	r0, r3
 80195cc:	687b      	ldr	r3, [r7, #4]
 80195ce:	685a      	ldr	r2, [r3, #4]
 80195d0:	4907      	ldr	r1, [pc, #28]	; (80195f0 <RegionEU868DlChannelReq+0x98>)
 80195d2:	0003      	movs	r3, r0
 80195d4:	005b      	lsls	r3, r3, #1
 80195d6:	181b      	adds	r3, r3, r0
 80195d8:	009b      	lsls	r3, r3, #2
 80195da:	18cb      	adds	r3, r1, r3
 80195dc:	3304      	adds	r3, #4
 80195de:	601a      	str	r2, [r3, #0]
    }

    return status;
 80195e0:	230f      	movs	r3, #15
 80195e2:	18fb      	adds	r3, r7, r3
 80195e4:	781b      	ldrb	r3, [r3, #0]
}
 80195e6:	0018      	movs	r0, r3
 80195e8:	46bd      	mov	sp, r7
 80195ea:	b005      	add	sp, #20
 80195ec:	bd90      	pop	{r4, r7, pc}
 80195ee:	46c0      	nop			; (mov r8, r8)
 80195f0:	200010c0 	.word	0x200010c0

080195f4 <RegionEU868AlternateDr>:

int8_t RegionEU868AlternateDr( int8_t currentDr, AlternateDrType_t type )
{
 80195f4:	b580      	push	{r7, lr}
 80195f6:	b082      	sub	sp, #8
 80195f8:	af00      	add	r7, sp, #0
 80195fa:	0002      	movs	r2, r0
 80195fc:	1dfb      	adds	r3, r7, #7
 80195fe:	701a      	strb	r2, [r3, #0]
 8019600:	1dbb      	adds	r3, r7, #6
 8019602:	1c0a      	adds	r2, r1, #0
 8019604:	701a      	strb	r2, [r3, #0]
    return currentDr;
 8019606:	1dfb      	adds	r3, r7, #7
 8019608:	781b      	ldrb	r3, [r3, #0]
 801960a:	b25b      	sxtb	r3, r3
}
 801960c:	0018      	movs	r0, r3
 801960e:	46bd      	mov	sp, r7
 8019610:	b002      	add	sp, #8
 8019612:	bd80      	pop	{r7, pc}

08019614 <RegionEU868CalcBackOff>:

void RegionEU868CalcBackOff( CalcBackOffParams_t* calcBackOff )
{
 8019614:	b580      	push	{r7, lr}
 8019616:	b088      	sub	sp, #32
 8019618:	af00      	add	r7, sp, #0
 801961a:	6078      	str	r0, [r7, #4]
    RegionCommonCalcBackOffParams_t calcBackOffParams;

    calcBackOffParams.Channels = NvmCtx.Channels;
 801961c:	210c      	movs	r1, #12
 801961e:	187b      	adds	r3, r7, r1
 8019620:	4a12      	ldr	r2, [pc, #72]	; (801966c <RegionEU868CalcBackOff+0x58>)
 8019622:	601a      	str	r2, [r3, #0]
    calcBackOffParams.Bands = NvmCtx.Bands;
 8019624:	187b      	adds	r3, r7, r1
 8019626:	4a12      	ldr	r2, [pc, #72]	; (8019670 <RegionEU868CalcBackOff+0x5c>)
 8019628:	605a      	str	r2, [r3, #4]
    calcBackOffParams.LastTxIsJoinRequest = calcBackOff->LastTxIsJoinRequest;
 801962a:	687b      	ldr	r3, [r7, #4]
 801962c:	785a      	ldrb	r2, [r3, #1]
 801962e:	187b      	adds	r3, r7, r1
 8019630:	721a      	strb	r2, [r3, #8]
    calcBackOffParams.Joined = calcBackOff->Joined;
 8019632:	687b      	ldr	r3, [r7, #4]
 8019634:	781a      	ldrb	r2, [r3, #0]
 8019636:	187b      	adds	r3, r7, r1
 8019638:	725a      	strb	r2, [r3, #9]
    calcBackOffParams.DutyCycleEnabled = calcBackOff->DutyCycleEnabled;
 801963a:	687b      	ldr	r3, [r7, #4]
 801963c:	789a      	ldrb	r2, [r3, #2]
 801963e:	187b      	adds	r3, r7, r1
 8019640:	729a      	strb	r2, [r3, #10]
    calcBackOffParams.Channel = calcBackOff->Channel;
 8019642:	687b      	ldr	r3, [r7, #4]
 8019644:	78da      	ldrb	r2, [r3, #3]
 8019646:	187b      	adds	r3, r7, r1
 8019648:	72da      	strb	r2, [r3, #11]
    calcBackOffParams.ElapsedTime = calcBackOff->ElapsedTime;
 801964a:	687b      	ldr	r3, [r7, #4]
 801964c:	685a      	ldr	r2, [r3, #4]
 801964e:	187b      	adds	r3, r7, r1
 8019650:	60da      	str	r2, [r3, #12]
    calcBackOffParams.TxTimeOnAir = calcBackOff->TxTimeOnAir;
 8019652:	687b      	ldr	r3, [r7, #4]
 8019654:	689a      	ldr	r2, [r3, #8]
 8019656:	187b      	adds	r3, r7, r1
 8019658:	611a      	str	r2, [r3, #16]

    RegionCommonCalcBackOff( &calcBackOffParams );
 801965a:	187b      	adds	r3, r7, r1
 801965c:	0018      	movs	r0, r3
 801965e:	f7fe fe1c 	bl	801829a <RegionCommonCalcBackOff>
}
 8019662:	46c0      	nop			; (mov r8, r8)
 8019664:	46bd      	mov	sp, r7
 8019666:	b008      	add	sp, #32
 8019668:	bd80      	pop	{r7, pc}
 801966a:	46c0      	nop			; (mov r8, r8)
 801966c:	200010c0 	.word	0x200010c0
 8019670:	20001180 	.word	0x20001180

08019674 <RegionEU868NextChannel>:

LoRaMacStatus_t RegionEU868NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 8019674:	b5b0      	push	{r4, r5, r7, lr}
 8019676:	b090      	sub	sp, #64	; 0x40
 8019678:	af04      	add	r7, sp, #16
 801967a:	60f8      	str	r0, [r7, #12]
 801967c:	60b9      	str	r1, [r7, #8]
 801967e:	607a      	str	r2, [r7, #4]
 8019680:	603b      	str	r3, [r7, #0]
    uint8_t nbEnabledChannels = 0;
 8019682:	232f      	movs	r3, #47	; 0x2f
 8019684:	18fb      	adds	r3, r7, r3
 8019686:	2200      	movs	r2, #0
 8019688:	701a      	strb	r2, [r3, #0]
    uint8_t delayTx = 0;
 801968a:	2323      	movs	r3, #35	; 0x23
 801968c:	18fb      	adds	r3, r7, r3
 801968e:	2200      	movs	r2, #0
 8019690:	701a      	strb	r2, [r3, #0]
    uint8_t enabledChannels[EU868_MAX_NB_CHANNELS] = { 0 };
 8019692:	2310      	movs	r3, #16
 8019694:	18fb      	adds	r3, r7, r3
 8019696:	2200      	movs	r2, #0
 8019698:	601a      	str	r2, [r3, #0]
 801969a:	3304      	adds	r3, #4
 801969c:	220c      	movs	r2, #12
 801969e:	2100      	movs	r1, #0
 80196a0:	0018      	movs	r0, r3
 80196a2:	f003 ff57 	bl	801d554 <memset>
    TimerTime_t nextTxDelay = 0;
 80196a6:	2300      	movs	r3, #0
 80196a8:	62bb      	str	r3, [r7, #40]	; 0x28

    if( RegionCommonCountChannels( NvmCtx.ChannelsMask, 0, 1 ) == 0 )
 80196aa:	4b44      	ldr	r3, [pc, #272]	; (80197bc <RegionEU868NextChannel+0x148>)
 80196ac:	2201      	movs	r2, #1
 80196ae:	2100      	movs	r1, #0
 80196b0:	0018      	movs	r0, r3
 80196b2:	f7fe faae 	bl	8017c12 <RegionCommonCountChannels>
 80196b6:	1e03      	subs	r3, r0, #0
 80196b8:	d10a      	bne.n	80196d0 <RegionEU868NextChannel+0x5c>
    { // Reactivate default channels
        NvmCtx.ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 80196ba:	4a41      	ldr	r2, [pc, #260]	; (80197c0 <RegionEU868NextChannel+0x14c>)
 80196bc:	2390      	movs	r3, #144	; 0x90
 80196be:	005b      	lsls	r3, r3, #1
 80196c0:	5ad3      	ldrh	r3, [r2, r3]
 80196c2:	2207      	movs	r2, #7
 80196c4:	4313      	orrs	r3, r2
 80196c6:	b299      	uxth	r1, r3
 80196c8:	4a3d      	ldr	r2, [pc, #244]	; (80197c0 <RegionEU868NextChannel+0x14c>)
 80196ca:	2390      	movs	r3, #144	; 0x90
 80196cc:	005b      	lsls	r3, r3, #1
 80196ce:	52d1      	strh	r1, [r2, r3]
    }

    TimerTime_t elapsed = TimerGetElapsedTime( nextChanParams->LastAggrTx );
 80196d0:	68fb      	ldr	r3, [r7, #12]
 80196d2:	685b      	ldr	r3, [r3, #4]
 80196d4:	0018      	movs	r0, r3
 80196d6:	f001 fd64 	bl	801b1a2 <TimerGetElapsedTime>
 80196da:	0003      	movs	r3, r0
 80196dc:	627b      	str	r3, [r7, #36]	; 0x24
    if( ( nextChanParams->LastAggrTx == 0 ) || ( nextChanParams->AggrTimeOff <= elapsed ) )
 80196de:	68fb      	ldr	r3, [r7, #12]
 80196e0:	685b      	ldr	r3, [r3, #4]
 80196e2:	2b00      	cmp	r3, #0
 80196e4:	d004      	beq.n	80196f0 <RegionEU868NextChannel+0x7c>
 80196e6:	68fb      	ldr	r3, [r7, #12]
 80196e8:	681b      	ldr	r3, [r3, #0]
 80196ea:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80196ec:	429a      	cmp	r2, r3
 80196ee:	d324      	bcc.n	801973a <RegionEU868NextChannel+0xc6>
    {
        // Reset Aggregated time off
        *aggregatedTimeOff = 0;
 80196f0:	683b      	ldr	r3, [r7, #0]
 80196f2:	2200      	movs	r2, #0
 80196f4:	601a      	str	r2, [r3, #0]

        // Update bands Time OFF
        nextTxDelay = RegionCommonUpdateBandTimeOff( nextChanParams->Joined, nextChanParams->DutyCycleEnabled, NvmCtx.Bands, EU868_MAX_NB_BANDS );
 80196f6:	68fb      	ldr	r3, [r7, #12]
 80196f8:	7a58      	ldrb	r0, [r3, #9]
 80196fa:	68fb      	ldr	r3, [r7, #12]
 80196fc:	7a99      	ldrb	r1, [r3, #10]
 80196fe:	4a31      	ldr	r2, [pc, #196]	; (80197c4 <RegionEU868NextChannel+0x150>)
 8019700:	2306      	movs	r3, #6
 8019702:	f7fe fb11 	bl	8017d28 <RegionCommonUpdateBandTimeOff>
 8019706:	0003      	movs	r3, r0
 8019708:	62bb      	str	r3, [r7, #40]	; 0x28

        // Search how many channels are enabled
        nbEnabledChannels = CountNbOfEnabledChannels( nextChanParams->Joined, nextChanParams->Datarate,
 801970a:	68fb      	ldr	r3, [r7, #12]
 801970c:	7a58      	ldrb	r0, [r3, #9]
 801970e:	68fb      	ldr	r3, [r7, #12]
 8019710:	7a1b      	ldrb	r3, [r3, #8]
 8019712:	b25b      	sxtb	r3, r3
 8019714:	b2d9      	uxtb	r1, r3
 8019716:	232f      	movs	r3, #47	; 0x2f
 8019718:	18fc      	adds	r4, r7, r3
 801971a:	4d29      	ldr	r5, [pc, #164]	; (80197c0 <RegionEU868NextChannel+0x14c>)
 801971c:	4a27      	ldr	r2, [pc, #156]	; (80197bc <RegionEU868NextChannel+0x148>)
 801971e:	2323      	movs	r3, #35	; 0x23
 8019720:	18fb      	adds	r3, r7, r3
 8019722:	9302      	str	r3, [sp, #8]
 8019724:	2310      	movs	r3, #16
 8019726:	18fb      	adds	r3, r7, r3
 8019728:	9301      	str	r3, [sp, #4]
 801972a:	4b26      	ldr	r3, [pc, #152]	; (80197c4 <RegionEU868NextChannel+0x150>)
 801972c:	9300      	str	r3, [sp, #0]
 801972e:	002b      	movs	r3, r5
 8019730:	f7fe ff26 	bl	8018580 <CountNbOfEnabledChannels>
 8019734:	0003      	movs	r3, r0
 8019736:	7023      	strb	r3, [r4, #0]
 8019738:	e00b      	b.n	8019752 <RegionEU868NextChannel+0xde>
                                                      NvmCtx.ChannelsMask, NvmCtx.Channels,
                                                      NvmCtx.Bands, enabledChannels, &delayTx );
    }
    else
    {
        delayTx++;
 801973a:	2123      	movs	r1, #35	; 0x23
 801973c:	187b      	adds	r3, r7, r1
 801973e:	781b      	ldrb	r3, [r3, #0]
 8019740:	3301      	adds	r3, #1
 8019742:	b2da      	uxtb	r2, r3
 8019744:	187b      	adds	r3, r7, r1
 8019746:	701a      	strb	r2, [r3, #0]
        nextTxDelay = nextChanParams->AggrTimeOff - elapsed;
 8019748:	68fb      	ldr	r3, [r7, #12]
 801974a:	681a      	ldr	r2, [r3, #0]
 801974c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801974e:	1ad3      	subs	r3, r2, r3
 8019750:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    if( nbEnabledChannels > 0 )
 8019752:	222f      	movs	r2, #47	; 0x2f
 8019754:	18bb      	adds	r3, r7, r2
 8019756:	781b      	ldrb	r3, [r3, #0]
 8019758:	2b00      	cmp	r3, #0
 801975a:	d011      	beq.n	8019780 <RegionEU868NextChannel+0x10c>
    {
        // We found a valid channel
        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 801975c:	18bb      	adds	r3, r7, r2
 801975e:	781b      	ldrb	r3, [r3, #0]
 8019760:	3b01      	subs	r3, #1
 8019762:	0019      	movs	r1, r3
 8019764:	2000      	movs	r0, #0
 8019766:	f001 fed9 	bl	801b51c <randr>
 801976a:	0002      	movs	r2, r0
 801976c:	2310      	movs	r3, #16
 801976e:	18fb      	adds	r3, r7, r3
 8019770:	5c9a      	ldrb	r2, [r3, r2]
 8019772:	68bb      	ldr	r3, [r7, #8]
 8019774:	701a      	strb	r2, [r3, #0]

        *time = 0;
 8019776:	687b      	ldr	r3, [r7, #4]
 8019778:	2200      	movs	r2, #0
 801977a:	601a      	str	r2, [r3, #0]
        return LORAMAC_STATUS_OK;
 801977c:	2300      	movs	r3, #0
 801977e:	e018      	b.n	80197b2 <RegionEU868NextChannel+0x13e>
    }
    else
    {
        if( delayTx > 0 )
 8019780:	2323      	movs	r3, #35	; 0x23
 8019782:	18fb      	adds	r3, r7, r3
 8019784:	781b      	ldrb	r3, [r3, #0]
 8019786:	2b00      	cmp	r3, #0
 8019788:	d004      	beq.n	8019794 <RegionEU868NextChannel+0x120>
        {
            // Delay transmission due to AggregatedTimeOff or to a band time off
            *time = nextTxDelay;
 801978a:	687b      	ldr	r3, [r7, #4]
 801978c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801978e:	601a      	str	r2, [r3, #0]
            return LORAMAC_STATUS_DUTYCYCLE_RESTRICTED;
 8019790:	230b      	movs	r3, #11
 8019792:	e00e      	b.n	80197b2 <RegionEU868NextChannel+0x13e>
        }
        // Datarate not supported by any channel, restore defaults
        NvmCtx.ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 8019794:	4a0a      	ldr	r2, [pc, #40]	; (80197c0 <RegionEU868NextChannel+0x14c>)
 8019796:	2390      	movs	r3, #144	; 0x90
 8019798:	005b      	lsls	r3, r3, #1
 801979a:	5ad3      	ldrh	r3, [r2, r3]
 801979c:	2207      	movs	r2, #7
 801979e:	4313      	orrs	r3, r2
 80197a0:	b299      	uxth	r1, r3
 80197a2:	4a07      	ldr	r2, [pc, #28]	; (80197c0 <RegionEU868NextChannel+0x14c>)
 80197a4:	2390      	movs	r3, #144	; 0x90
 80197a6:	005b      	lsls	r3, r3, #1
 80197a8:	52d1      	strh	r1, [r2, r3]
        *time = 0;
 80197aa:	687b      	ldr	r3, [r7, #4]
 80197ac:	2200      	movs	r2, #0
 80197ae:	601a      	str	r2, [r3, #0]
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
 80197b0:	230c      	movs	r3, #12
    }
}
 80197b2:	0018      	movs	r0, r3
 80197b4:	46bd      	mov	sp, r7
 80197b6:	b00c      	add	sp, #48	; 0x30
 80197b8:	bdb0      	pop	{r4, r5, r7, pc}
 80197ba:	46c0      	nop			; (mov r8, r8)
 80197bc:	200011e0 	.word	0x200011e0
 80197c0:	200010c0 	.word	0x200010c0
 80197c4:	20001180 	.word	0x20001180

080197c8 <RegionEU868ChannelAdd>:

LoRaMacStatus_t RegionEU868ChannelAdd( ChannelAddParams_t* channelAdd )
{
 80197c8:	b590      	push	{r4, r7, lr}
 80197ca:	b085      	sub	sp, #20
 80197cc:	af00      	add	r7, sp, #0
 80197ce:	6078      	str	r0, [r7, #4]
    uint8_t band = 0;
 80197d0:	230c      	movs	r3, #12
 80197d2:	18fb      	adds	r3, r7, r3
 80197d4:	2200      	movs	r2, #0
 80197d6:	701a      	strb	r2, [r3, #0]
    bool drInvalid = false;
 80197d8:	230f      	movs	r3, #15
 80197da:	18fb      	adds	r3, r7, r3
 80197dc:	2200      	movs	r2, #0
 80197de:	701a      	strb	r2, [r3, #0]
    bool freqInvalid = false;
 80197e0:	230e      	movs	r3, #14
 80197e2:	18fb      	adds	r3, r7, r3
 80197e4:	2200      	movs	r2, #0
 80197e6:	701a      	strb	r2, [r3, #0]
    uint8_t id = channelAdd->ChannelId;
 80197e8:	210d      	movs	r1, #13
 80197ea:	187b      	adds	r3, r7, r1
 80197ec:	687a      	ldr	r2, [r7, #4]
 80197ee:	7912      	ldrb	r2, [r2, #4]
 80197f0:	701a      	strb	r2, [r3, #0]

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 80197f2:	187b      	adds	r3, r7, r1
 80197f4:	781b      	ldrb	r3, [r3, #0]
 80197f6:	2b02      	cmp	r3, #2
 80197f8:	d801      	bhi.n	80197fe <RegionEU868ChannelAdd+0x36>
    {
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
 80197fa:	2306      	movs	r3, #6
 80197fc:	e0a1      	b.n	8019942 <RegionEU868ChannelAdd+0x17a>
    }

    if( id >= EU868_MAX_NB_CHANNELS )
 80197fe:	230d      	movs	r3, #13
 8019800:	18fb      	adds	r3, r7, r3
 8019802:	781b      	ldrb	r3, [r3, #0]
 8019804:	2b0f      	cmp	r3, #15
 8019806:	d901      	bls.n	801980c <RegionEU868ChannelAdd+0x44>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8019808:	2303      	movs	r3, #3
 801980a:	e09a      	b.n	8019942 <RegionEU868ChannelAdd+0x17a>
    }

    // Validate the datarate range
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 801980c:	687b      	ldr	r3, [r7, #4]
 801980e:	681b      	ldr	r3, [r3, #0]
 8019810:	7a1b      	ldrb	r3, [r3, #8]
 8019812:	011b      	lsls	r3, r3, #4
 8019814:	b25b      	sxtb	r3, r3
 8019816:	111b      	asrs	r3, r3, #4
 8019818:	b25b      	sxtb	r3, r3
 801981a:	2207      	movs	r2, #7
 801981c:	2100      	movs	r1, #0
 801981e:	0018      	movs	r0, r3
 8019820:	f7fe f98f 	bl	8017b42 <RegionCommonValueInRange>
 8019824:	1e03      	subs	r3, r0, #0
 8019826:	d103      	bne.n	8019830 <RegionEU868ChannelAdd+0x68>
    {
        drInvalid = true;
 8019828:	230f      	movs	r3, #15
 801982a:	18fb      	adds	r3, r7, r3
 801982c:	2201      	movs	r2, #1
 801982e:	701a      	strb	r2, [r3, #0]
    }
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 8019830:	687b      	ldr	r3, [r7, #4]
 8019832:	681b      	ldr	r3, [r3, #0]
 8019834:	7a1b      	ldrb	r3, [r3, #8]
 8019836:	b25b      	sxtb	r3, r3
 8019838:	111b      	asrs	r3, r3, #4
 801983a:	b25b      	sxtb	r3, r3
 801983c:	2207      	movs	r2, #7
 801983e:	2100      	movs	r1, #0
 8019840:	0018      	movs	r0, r3
 8019842:	f7fe f97e 	bl	8017b42 <RegionCommonValueInRange>
 8019846:	1e03      	subs	r3, r0, #0
 8019848:	d103      	bne.n	8019852 <RegionEU868ChannelAdd+0x8a>
    {
        drInvalid = true;
 801984a:	230f      	movs	r3, #15
 801984c:	18fb      	adds	r3, r7, r3
 801984e:	2201      	movs	r2, #1
 8019850:	701a      	strb	r2, [r3, #0]
    }
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 8019852:	687b      	ldr	r3, [r7, #4]
 8019854:	681b      	ldr	r3, [r3, #0]
 8019856:	7a1b      	ldrb	r3, [r3, #8]
 8019858:	011b      	lsls	r3, r3, #4
 801985a:	b25b      	sxtb	r3, r3
 801985c:	111b      	asrs	r3, r3, #4
 801985e:	b25a      	sxtb	r2, r3
 8019860:	687b      	ldr	r3, [r7, #4]
 8019862:	681b      	ldr	r3, [r3, #0]
 8019864:	7a1b      	ldrb	r3, [r3, #8]
 8019866:	b25b      	sxtb	r3, r3
 8019868:	111b      	asrs	r3, r3, #4
 801986a:	b25b      	sxtb	r3, r3
 801986c:	429a      	cmp	r2, r3
 801986e:	dd03      	ble.n	8019878 <RegionEU868ChannelAdd+0xb0>
    {
        drInvalid = true;
 8019870:	230f      	movs	r3, #15
 8019872:	18fb      	adds	r3, r7, r3
 8019874:	2201      	movs	r2, #1
 8019876:	701a      	strb	r2, [r3, #0]
    }

    // Check frequency
    if( freqInvalid == false )
 8019878:	240e      	movs	r4, #14
 801987a:	193b      	adds	r3, r7, r4
 801987c:	781b      	ldrb	r3, [r3, #0]
 801987e:	2201      	movs	r2, #1
 8019880:	4053      	eors	r3, r2
 8019882:	b2db      	uxtb	r3, r3
 8019884:	2b00      	cmp	r3, #0
 8019886:	d012      	beq.n	80198ae <RegionEU868ChannelAdd+0xe6>
    {
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8019888:	687b      	ldr	r3, [r7, #4]
 801988a:	681b      	ldr	r3, [r3, #0]
 801988c:	681b      	ldr	r3, [r3, #0]
 801988e:	220c      	movs	r2, #12
 8019890:	18ba      	adds	r2, r7, r2
 8019892:	0011      	movs	r1, r2
 8019894:	0018      	movs	r0, r3
 8019896:	f7fe fdfb 	bl	8018490 <VerifyRfFreq>
 801989a:	0003      	movs	r3, r0
 801989c:	001a      	movs	r2, r3
 801989e:	2301      	movs	r3, #1
 80198a0:	4053      	eors	r3, r2
 80198a2:	b2db      	uxtb	r3, r3
 80198a4:	2b00      	cmp	r3, #0
 80198a6:	d002      	beq.n	80198ae <RegionEU868ChannelAdd+0xe6>
        {
            freqInvalid = true;
 80198a8:	193b      	adds	r3, r7, r4
 80198aa:	2201      	movs	r2, #1
 80198ac:	701a      	strb	r2, [r3, #0]
        }
    }

    // Check status
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 80198ae:	230f      	movs	r3, #15
 80198b0:	18fb      	adds	r3, r7, r3
 80198b2:	781b      	ldrb	r3, [r3, #0]
 80198b4:	2b00      	cmp	r3, #0
 80198b6:	d006      	beq.n	80198c6 <RegionEU868ChannelAdd+0xfe>
 80198b8:	230e      	movs	r3, #14
 80198ba:	18fb      	adds	r3, r7, r3
 80198bc:	781b      	ldrb	r3, [r3, #0]
 80198be:	2b00      	cmp	r3, #0
 80198c0:	d001      	beq.n	80198c6 <RegionEU868ChannelAdd+0xfe>
    {
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
 80198c2:	2306      	movs	r3, #6
 80198c4:	e03d      	b.n	8019942 <RegionEU868ChannelAdd+0x17a>
    }
    if( drInvalid == true )
 80198c6:	230f      	movs	r3, #15
 80198c8:	18fb      	adds	r3, r7, r3
 80198ca:	781b      	ldrb	r3, [r3, #0]
 80198cc:	2b00      	cmp	r3, #0
 80198ce:	d001      	beq.n	80198d4 <RegionEU868ChannelAdd+0x10c>
    {
        return LORAMAC_STATUS_DATARATE_INVALID;
 80198d0:	2305      	movs	r3, #5
 80198d2:	e036      	b.n	8019942 <RegionEU868ChannelAdd+0x17a>
    }
    if( freqInvalid == true )
 80198d4:	230e      	movs	r3, #14
 80198d6:	18fb      	adds	r3, r7, r3
 80198d8:	781b      	ldrb	r3, [r3, #0]
 80198da:	2b00      	cmp	r3, #0
 80198dc:	d001      	beq.n	80198e2 <RegionEU868ChannelAdd+0x11a>
    {
        return LORAMAC_STATUS_FREQUENCY_INVALID;
 80198de:	2304      	movs	r3, #4
 80198e0:	e02f      	b.n	8019942 <RegionEU868ChannelAdd+0x17a>
    }

    memcpy1( ( uint8_t* ) &(NvmCtx.Channels[id]), ( uint8_t* ) channelAdd->NewChannel, sizeof( NvmCtx.Channels[id] ) );
 80198e2:	240d      	movs	r4, #13
 80198e4:	193b      	adds	r3, r7, r4
 80198e6:	781a      	ldrb	r2, [r3, #0]
 80198e8:	0013      	movs	r3, r2
 80198ea:	005b      	lsls	r3, r3, #1
 80198ec:	189b      	adds	r3, r3, r2
 80198ee:	009b      	lsls	r3, r3, #2
 80198f0:	4a16      	ldr	r2, [pc, #88]	; (801994c <RegionEU868ChannelAdd+0x184>)
 80198f2:	1898      	adds	r0, r3, r2
 80198f4:	687b      	ldr	r3, [r7, #4]
 80198f6:	681b      	ldr	r3, [r3, #0]
 80198f8:	220c      	movs	r2, #12
 80198fa:	0019      	movs	r1, r3
 80198fc:	f001 fe24 	bl	801b548 <memcpy1>
    NvmCtx.Channels[id].Band = band;
 8019900:	193b      	adds	r3, r7, r4
 8019902:	781a      	ldrb	r2, [r3, #0]
 8019904:	230c      	movs	r3, #12
 8019906:	18fb      	adds	r3, r7, r3
 8019908:	7818      	ldrb	r0, [r3, #0]
 801990a:	4910      	ldr	r1, [pc, #64]	; (801994c <RegionEU868ChannelAdd+0x184>)
 801990c:	0013      	movs	r3, r2
 801990e:	005b      	lsls	r3, r3, #1
 8019910:	189b      	adds	r3, r3, r2
 8019912:	009b      	lsls	r3, r3, #2
 8019914:	18cb      	adds	r3, r1, r3
 8019916:	3309      	adds	r3, #9
 8019918:	1c02      	adds	r2, r0, #0
 801991a:	701a      	strb	r2, [r3, #0]
    NvmCtx.ChannelsMask[0] |= ( 1 << id );
 801991c:	4a0b      	ldr	r2, [pc, #44]	; (801994c <RegionEU868ChannelAdd+0x184>)
 801991e:	2390      	movs	r3, #144	; 0x90
 8019920:	005b      	lsls	r3, r3, #1
 8019922:	5ad3      	ldrh	r3, [r2, r3]
 8019924:	b21a      	sxth	r2, r3
 8019926:	193b      	adds	r3, r7, r4
 8019928:	781b      	ldrb	r3, [r3, #0]
 801992a:	2101      	movs	r1, #1
 801992c:	4099      	lsls	r1, r3
 801992e:	000b      	movs	r3, r1
 8019930:	b21b      	sxth	r3, r3
 8019932:	4313      	orrs	r3, r2
 8019934:	b21b      	sxth	r3, r3
 8019936:	b299      	uxth	r1, r3
 8019938:	4a04      	ldr	r2, [pc, #16]	; (801994c <RegionEU868ChannelAdd+0x184>)
 801993a:	2390      	movs	r3, #144	; 0x90
 801993c:	005b      	lsls	r3, r3, #1
 801993e:	52d1      	strh	r1, [r2, r3]
    return LORAMAC_STATUS_OK;
 8019940:	2300      	movs	r3, #0
}
 8019942:	0018      	movs	r0, r3
 8019944:	46bd      	mov	sp, r7
 8019946:	b005      	add	sp, #20
 8019948:	bd90      	pop	{r4, r7, pc}
 801994a:	46c0      	nop			; (mov r8, r8)
 801994c:	200010c0 	.word	0x200010c0

08019950 <RegionEU868ChannelsRemove>:

bool RegionEU868ChannelsRemove( ChannelRemoveParams_t* channelRemove  )
{
 8019950:	b590      	push	{r4, r7, lr}
 8019952:	b087      	sub	sp, #28
 8019954:	af00      	add	r7, sp, #0
 8019956:	6078      	str	r0, [r7, #4]
    uint8_t id = channelRemove->ChannelId;
 8019958:	2117      	movs	r1, #23
 801995a:	187b      	adds	r3, r7, r1
 801995c:	687a      	ldr	r2, [r7, #4]
 801995e:	7812      	ldrb	r2, [r2, #0]
 8019960:	701a      	strb	r2, [r3, #0]

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 8019962:	187b      	adds	r3, r7, r1
 8019964:	781b      	ldrb	r3, [r3, #0]
 8019966:	2b02      	cmp	r3, #2
 8019968:	d801      	bhi.n	801996e <RegionEU868ChannelsRemove+0x1e>
    {
        return false;
 801996a:	2300      	movs	r3, #0
 801996c:	e015      	b.n	801999a <RegionEU868ChannelsRemove+0x4a>
    }

    // Remove the channel from the list of channels
    NvmCtx.Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 801996e:	2417      	movs	r4, #23
 8019970:	193b      	adds	r3, r7, r4
 8019972:	781a      	ldrb	r2, [r3, #0]
 8019974:	490b      	ldr	r1, [pc, #44]	; (80199a4 <RegionEU868ChannelsRemove+0x54>)
 8019976:	0013      	movs	r3, r2
 8019978:	005b      	lsls	r3, r3, #1
 801997a:	189b      	adds	r3, r3, r2
 801997c:	009b      	lsls	r3, r3, #2
 801997e:	18cb      	adds	r3, r1, r3
 8019980:	220c      	movs	r2, #12
 8019982:	2100      	movs	r1, #0
 8019984:	0018      	movs	r0, r3
 8019986:	f003 fde5 	bl	801d554 <memset>

    return RegionCommonChanDisable( NvmCtx.ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 801998a:	193b      	adds	r3, r7, r4
 801998c:	7819      	ldrb	r1, [r3, #0]
 801998e:	4b06      	ldr	r3, [pc, #24]	; (80199a8 <RegionEU868ChannelsRemove+0x58>)
 8019990:	2210      	movs	r2, #16
 8019992:	0018      	movs	r0, r3
 8019994:	f7fe f8fb 	bl	8017b8e <RegionCommonChanDisable>
 8019998:	0003      	movs	r3, r0
}
 801999a:	0018      	movs	r0, r3
 801999c:	46bd      	mov	sp, r7
 801999e:	b007      	add	sp, #28
 80199a0:	bd90      	pop	{r4, r7, pc}
 80199a2:	46c0      	nop			; (mov r8, r8)
 80199a4:	200010c0 	.word	0x200010c0
 80199a8:	200011e0 	.word	0x200011e0

080199ac <RegionEU868SetContinuousWave>:

void RegionEU868SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 80199ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80199ae:	b085      	sub	sp, #20
 80199b0:	af00      	add	r7, sp, #0
 80199b2:	6078      	str	r0, [r7, #4]
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, NvmCtx.Bands[NvmCtx.Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, NvmCtx.ChannelsMask );
 80199b4:	687b      	ldr	r3, [r7, #4]
 80199b6:	2002      	movs	r0, #2
 80199b8:	5618      	ldrsb	r0, [r3, r0]
 80199ba:	687b      	ldr	r3, [r7, #4]
 80199bc:	781b      	ldrb	r3, [r3, #0]
 80199be:	0019      	movs	r1, r3
 80199c0:	4a21      	ldr	r2, [pc, #132]	; (8019a48 <RegionEU868SetContinuousWave+0x9c>)
 80199c2:	000b      	movs	r3, r1
 80199c4:	005b      	lsls	r3, r3, #1
 80199c6:	185b      	adds	r3, r3, r1
 80199c8:	009b      	lsls	r3, r3, #2
 80199ca:	18d3      	adds	r3, r2, r3
 80199cc:	3309      	adds	r3, #9
 80199ce:	781b      	ldrb	r3, [r3, #0]
 80199d0:	4a1d      	ldr	r2, [pc, #116]	; (8019a48 <RegionEU868SetContinuousWave+0x9c>)
 80199d2:	330c      	adds	r3, #12
 80199d4:	011b      	lsls	r3, r3, #4
 80199d6:	18d3      	adds	r3, r2, r3
 80199d8:	3302      	adds	r3, #2
 80199da:	2100      	movs	r1, #0
 80199dc:	5659      	ldrsb	r1, [r3, r1]
 80199de:	687b      	ldr	r3, [r7, #4]
 80199e0:	2201      	movs	r2, #1
 80199e2:	569a      	ldrsb	r2, [r3, r2]
 80199e4:	260f      	movs	r6, #15
 80199e6:	19bc      	adds	r4, r7, r6
 80199e8:	4b18      	ldr	r3, [pc, #96]	; (8019a4c <RegionEU868SetContinuousWave+0xa0>)
 80199ea:	f7fe fd29 	bl	8018440 <LimitTxPower>
 80199ee:	0003      	movs	r3, r0
 80199f0:	7023      	strb	r3, [r4, #0]
    int8_t phyTxPower = 0;
 80199f2:	200e      	movs	r0, #14
 80199f4:	183b      	adds	r3, r7, r0
 80199f6:	2200      	movs	r2, #0
 80199f8:	701a      	strb	r2, [r3, #0]
    uint32_t frequency = NvmCtx.Channels[continuousWave->Channel].Frequency;
 80199fa:	687b      	ldr	r3, [r7, #4]
 80199fc:	781b      	ldrb	r3, [r3, #0]
 80199fe:	0019      	movs	r1, r3
 8019a00:	4a11      	ldr	r2, [pc, #68]	; (8019a48 <RegionEU868SetContinuousWave+0x9c>)
 8019a02:	000b      	movs	r3, r1
 8019a04:	005b      	lsls	r3, r3, #1
 8019a06:	185b      	adds	r3, r3, r1
 8019a08:	009b      	lsls	r3, r3, #2
 8019a0a:	589b      	ldr	r3, [r3, r2]
 8019a0c:	60bb      	str	r3, [r7, #8]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 8019a0e:	687b      	ldr	r3, [r7, #4]
 8019a10:	6859      	ldr	r1, [r3, #4]
 8019a12:	687b      	ldr	r3, [r7, #4]
 8019a14:	689a      	ldr	r2, [r3, #8]
 8019a16:	0005      	movs	r5, r0
 8019a18:	183c      	adds	r4, r7, r0
 8019a1a:	19bb      	adds	r3, r7, r6
 8019a1c:	781b      	ldrb	r3, [r3, #0]
 8019a1e:	b25b      	sxtb	r3, r3
 8019a20:	0018      	movs	r0, r3
 8019a22:	f7fe fc01 	bl	8018228 <RegionCommonComputeTxPower>
 8019a26:	0003      	movs	r3, r0
 8019a28:	7023      	strb	r3, [r4, #0]

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8019a2a:	4b09      	ldr	r3, [pc, #36]	; (8019a50 <RegionEU868SetContinuousWave+0xa4>)
 8019a2c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8019a2e:	687a      	ldr	r2, [r7, #4]
 8019a30:	8994      	ldrh	r4, [r2, #12]
 8019a32:	197a      	adds	r2, r7, r5
 8019a34:	2100      	movs	r1, #0
 8019a36:	5651      	ldrsb	r1, [r2, r1]
 8019a38:	68b8      	ldr	r0, [r7, #8]
 8019a3a:	0022      	movs	r2, r4
 8019a3c:	4798      	blx	r3
}
 8019a3e:	46c0      	nop			; (mov r8, r8)
 8019a40:	46bd      	mov	sp, r7
 8019a42:	b005      	add	sp, #20
 8019a44:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8019a46:	46c0      	nop			; (mov r8, r8)
 8019a48:	200010c0 	.word	0x200010c0
 8019a4c:	200011e0 	.word	0x200011e0
 8019a50:	0801ebd0 	.word	0x0801ebd0

08019a54 <RegionEU868ApplyDrOffset>:

uint8_t RegionEU868ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
 8019a54:	b590      	push	{r4, r7, lr}
 8019a56:	b085      	sub	sp, #20
 8019a58:	af00      	add	r7, sp, #0
 8019a5a:	0004      	movs	r4, r0
 8019a5c:	0008      	movs	r0, r1
 8019a5e:	0011      	movs	r1, r2
 8019a60:	1dfb      	adds	r3, r7, #7
 8019a62:	1c22      	adds	r2, r4, #0
 8019a64:	701a      	strb	r2, [r3, #0]
 8019a66:	1dbb      	adds	r3, r7, #6
 8019a68:	1c02      	adds	r2, r0, #0
 8019a6a:	701a      	strb	r2, [r3, #0]
 8019a6c:	1d7b      	adds	r3, r7, #5
 8019a6e:	1c0a      	adds	r2, r1, #0
 8019a70:	701a      	strb	r2, [r3, #0]
    int8_t datarate = dr - drOffset;
 8019a72:	1dbb      	adds	r3, r7, #6
 8019a74:	781a      	ldrb	r2, [r3, #0]
 8019a76:	1d7b      	adds	r3, r7, #5
 8019a78:	781b      	ldrb	r3, [r3, #0]
 8019a7a:	1ad3      	subs	r3, r2, r3
 8019a7c:	b2da      	uxtb	r2, r3
 8019a7e:	210f      	movs	r1, #15
 8019a80:	187b      	adds	r3, r7, r1
 8019a82:	701a      	strb	r2, [r3, #0]

    if( datarate < 0 )
 8019a84:	000a      	movs	r2, r1
 8019a86:	18bb      	adds	r3, r7, r2
 8019a88:	781b      	ldrb	r3, [r3, #0]
 8019a8a:	2b7f      	cmp	r3, #127	; 0x7f
 8019a8c:	d902      	bls.n	8019a94 <RegionEU868ApplyDrOffset+0x40>
    {
        datarate = DR_0;
 8019a8e:	18bb      	adds	r3, r7, r2
 8019a90:	2200      	movs	r2, #0
 8019a92:	701a      	strb	r2, [r3, #0]
    }
    return datarate;
 8019a94:	230f      	movs	r3, #15
 8019a96:	18fb      	adds	r3, r7, r3
 8019a98:	781b      	ldrb	r3, [r3, #0]
}
 8019a9a:	0018      	movs	r0, r3
 8019a9c:	46bd      	mov	sp, r7
 8019a9e:	b005      	add	sp, #20
 8019aa0:	bd90      	pop	{r4, r7, pc}
	...

08019aa4 <certif_running>:
static void OnCertifTxNextPacketTimerEvent( void* context );
static bool certif_tx( void );

/* Exported functions definition---------------------------------------------------------*/
bool certif_running(void)
{
 8019aa4:	b580      	push	{r7, lr}
 8019aa6:	af00      	add	r7, sp, #0
    return certifParam.Running;
 8019aa8:	4b02      	ldr	r3, [pc, #8]	; (8019ab4 <certif_running+0x10>)
 8019aaa:	781b      	ldrb	r3, [r3, #0]
}
 8019aac:	0018      	movs	r0, r3
 8019aae:	46bd      	mov	sp, r7
 8019ab0:	bd80      	pop	{r7, pc}
 8019ab2:	46c0      	nop			; (mov r8, r8)
 8019ab4:	200011fc 	.word	0x200011fc

08019ab8 <certif_DownLinkIncrement>:

void certif_DownLinkIncrement( void )
{
 8019ab8:	b580      	push	{r7, lr}
 8019aba:	af00      	add	r7, sp, #0
    certifParam.DownLinkCounter++;
 8019abc:	4b05      	ldr	r3, [pc, #20]	; (8019ad4 <certif_DownLinkIncrement+0x1c>)
 8019abe:	22f6      	movs	r2, #246	; 0xf6
 8019ac0:	5a9b      	ldrh	r3, [r3, r2]
 8019ac2:	3301      	adds	r3, #1
 8019ac4:	b299      	uxth	r1, r3
 8019ac6:	4b03      	ldr	r3, [pc, #12]	; (8019ad4 <certif_DownLinkIncrement+0x1c>)
 8019ac8:	22f6      	movs	r2, #246	; 0xf6
 8019aca:	5299      	strh	r1, [r3, r2]
}
 8019acc:	46c0      	nop			; (mov r8, r8)
 8019ace:	46bd      	mov	sp, r7
 8019ad0:	bd80      	pop	{r7, pc}
 8019ad2:	46c0      	nop			; (mov r8, r8)
 8019ad4:	200011fc 	.word	0x200011fc

08019ad8 <certif_linkCheck>:

void certif_linkCheck(MlmeConfirm_t *mlmeConfirm)
{
 8019ad8:	b580      	push	{r7, lr}
 8019ada:	b082      	sub	sp, #8
 8019adc:	af00      	add	r7, sp, #0
 8019ade:	6078      	str	r0, [r7, #4]
  certifParam.LinkCheck = true;
 8019ae0:	4b08      	ldr	r3, [pc, #32]	; (8019b04 <certif_linkCheck+0x2c>)
 8019ae2:	22f8      	movs	r2, #248	; 0xf8
 8019ae4:	2101      	movs	r1, #1
 8019ae6:	5499      	strb	r1, [r3, r2]
  certifParam.DemodMargin = mlmeConfirm->DemodMargin;
 8019ae8:	687b      	ldr	r3, [r7, #4]
 8019aea:	7a19      	ldrb	r1, [r3, #8]
 8019aec:	4b05      	ldr	r3, [pc, #20]	; (8019b04 <certif_linkCheck+0x2c>)
 8019aee:	22f9      	movs	r2, #249	; 0xf9
 8019af0:	5499      	strb	r1, [r3, r2]
  certifParam.NbGateways = mlmeConfirm->NbGateways;
 8019af2:	687b      	ldr	r3, [r7, #4]
 8019af4:	7a59      	ldrb	r1, [r3, #9]
 8019af6:	4b03      	ldr	r3, [pc, #12]	; (8019b04 <certif_linkCheck+0x2c>)
 8019af8:	22fa      	movs	r2, #250	; 0xfa
 8019afa:	5499      	strb	r1, [r3, r2]
}
 8019afc:	46c0      	nop			; (mov r8, r8)
 8019afe:	46bd      	mov	sp, r7
 8019b00:	b002      	add	sp, #8
 8019b02:	bd80      	pop	{r7, pc}
 8019b04:	200011fc 	.word	0x200011fc

08019b08 <certif_tx>:

static bool certif_tx( void )
{
 8019b08:	b580      	push	{r7, lr}
 8019b0a:	b086      	sub	sp, #24
 8019b0c:	af00      	add	r7, sp, #0
  McpsReq_t mcpsReq;
  LoRaMacTxInfo_t txInfo;
  
  if( certifParam.LinkCheck == true )
 8019b0e:	4b47      	ldr	r3, [pc, #284]	; (8019c2c <certif_tx+0x124>)
 8019b10:	22f8      	movs	r2, #248	; 0xf8
 8019b12:	5c9b      	ldrb	r3, [r3, r2]
 8019b14:	2b00      	cmp	r3, #0
 8019b16:	d017      	beq.n	8019b48 <certif_tx+0x40>
  {
    certifParam.LinkCheck = false;
 8019b18:	4b44      	ldr	r3, [pc, #272]	; (8019c2c <certif_tx+0x124>)
 8019b1a:	22f8      	movs	r2, #248	; 0xf8
 8019b1c:	2100      	movs	r1, #0
 8019b1e:	5499      	strb	r1, [r3, r2]
    certifParam.DataBufferSize = 3;
 8019b20:	4b42      	ldr	r3, [pc, #264]	; (8019c2c <certif_tx+0x124>)
 8019b22:	2203      	movs	r2, #3
 8019b24:	70da      	strb	r2, [r3, #3]
    certifParam.DataBuffer[0] = 5;
 8019b26:	4b41      	ldr	r3, [pc, #260]	; (8019c2c <certif_tx+0x124>)
 8019b28:	2205      	movs	r2, #5
 8019b2a:	711a      	strb	r2, [r3, #4]
    certifParam.DataBuffer[1] = certifParam.DemodMargin;
 8019b2c:	4b3f      	ldr	r3, [pc, #252]	; (8019c2c <certif_tx+0x124>)
 8019b2e:	22f9      	movs	r2, #249	; 0xf9
 8019b30:	5c9a      	ldrb	r2, [r3, r2]
 8019b32:	4b3e      	ldr	r3, [pc, #248]	; (8019c2c <certif_tx+0x124>)
 8019b34:	715a      	strb	r2, [r3, #5]
    certifParam.DataBuffer[2] = certifParam.NbGateways;
 8019b36:	4b3d      	ldr	r3, [pc, #244]	; (8019c2c <certif_tx+0x124>)
 8019b38:	22fa      	movs	r2, #250	; 0xfa
 8019b3a:	5c9a      	ldrb	r2, [r3, r2]
 8019b3c:	4b3b      	ldr	r3, [pc, #236]	; (8019c2c <certif_tx+0x124>)
 8019b3e:	719a      	strb	r2, [r3, #6]
    certifParam.State = 1;
 8019b40:	4b3a      	ldr	r3, [pc, #232]	; (8019c2c <certif_tx+0x124>)
 8019b42:	2201      	movs	r2, #1
 8019b44:	705a      	strb	r2, [r3, #1]
 8019b46:	e01b      	b.n	8019b80 <certif_tx+0x78>
  }
  else
  {
    switch( certifParam.State )
 8019b48:	4b38      	ldr	r3, [pc, #224]	; (8019c2c <certif_tx+0x124>)
 8019b4a:	785b      	ldrb	r3, [r3, #1]
 8019b4c:	2b01      	cmp	r3, #1
 8019b4e:	d005      	beq.n	8019b5c <certif_tx+0x54>
 8019b50:	2b04      	cmp	r3, #4
 8019b52:	d115      	bne.n	8019b80 <certif_tx+0x78>
    {
    case 4:
      certifParam.State = 1;
 8019b54:	4b35      	ldr	r3, [pc, #212]	; (8019c2c <certif_tx+0x124>)
 8019b56:	2201      	movs	r2, #1
 8019b58:	705a      	strb	r2, [r3, #1]
      break;
 8019b5a:	e011      	b.n	8019b80 <certif_tx+0x78>
    case 1:
      certifParam.DataBufferSize = 2;
 8019b5c:	4b33      	ldr	r3, [pc, #204]	; (8019c2c <certif_tx+0x124>)
 8019b5e:	2202      	movs	r2, #2
 8019b60:	70da      	strb	r2, [r3, #3]
      certifParam.DataBuffer[0] = certifParam.DownLinkCounter >> 8;
 8019b62:	4b32      	ldr	r3, [pc, #200]	; (8019c2c <certif_tx+0x124>)
 8019b64:	22f6      	movs	r2, #246	; 0xf6
 8019b66:	5a9b      	ldrh	r3, [r3, r2]
 8019b68:	0a1b      	lsrs	r3, r3, #8
 8019b6a:	b29b      	uxth	r3, r3
 8019b6c:	b2da      	uxtb	r2, r3
 8019b6e:	4b2f      	ldr	r3, [pc, #188]	; (8019c2c <certif_tx+0x124>)
 8019b70:	711a      	strb	r2, [r3, #4]
      certifParam.DataBuffer[1] = certifParam.DownLinkCounter;
 8019b72:	4b2e      	ldr	r3, [pc, #184]	; (8019c2c <certif_tx+0x124>)
 8019b74:	22f6      	movs	r2, #246	; 0xf6
 8019b76:	5a9b      	ldrh	r3, [r3, r2]
 8019b78:	b2da      	uxtb	r2, r3
 8019b7a:	4b2c      	ldr	r3, [pc, #176]	; (8019c2c <certif_tx+0x124>)
 8019b7c:	715a      	strb	r2, [r3, #5]
      break;
 8019b7e:	46c0      	nop			; (mov r8, r8)
    }
  }
    
  if( LoRaMacQueryTxPossible( certifParam.DataBufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 8019b80:	4b2a      	ldr	r3, [pc, #168]	; (8019c2c <certif_tx+0x124>)
 8019b82:	78db      	ldrb	r3, [r3, #3]
 8019b84:	1d3a      	adds	r2, r7, #4
 8019b86:	0011      	movs	r1, r2
 8019b88:	0018      	movs	r0, r3
 8019b8a:	f7f9 ff47 	bl	8013a1c <LoRaMacQueryTxPossible>
 8019b8e:	1e03      	subs	r3, r0, #0
 8019b90:	d00d      	beq.n	8019bae <certif_tx+0xa6>
  {
      // Send empty frame in order to flush MAC commands
      mcpsReq.Type = MCPS_UNCONFIRMED;
 8019b92:	2108      	movs	r1, #8
 8019b94:	187b      	adds	r3, r7, r1
 8019b96:	2200      	movs	r2, #0
 8019b98:	701a      	strb	r2, [r3, #0]
      mcpsReq.Req.Unconfirmed.fBuffer = NULL;
 8019b9a:	187b      	adds	r3, r7, r1
 8019b9c:	2200      	movs	r2, #0
 8019b9e:	609a      	str	r2, [r3, #8]
      mcpsReq.Req.Unconfirmed.fBufferSize = 0;
 8019ba0:	187b      	adds	r3, r7, r1
 8019ba2:	2200      	movs	r2, #0
 8019ba4:	819a      	strh	r2, [r3, #12]
      mcpsReq.Req.Unconfirmed.Datarate = DR_0;
 8019ba6:	187b      	adds	r3, r7, r1
 8019ba8:	2200      	movs	r2, #0
 8019baa:	739a      	strb	r2, [r3, #14]
 8019bac:	e02b      	b.n	8019c06 <certif_tx+0xfe>
  }
  else
  {
      if( IsTxConfirmed == LORAWAN_UNCONFIRMED_MSG )
 8019bae:	4b20      	ldr	r3, [pc, #128]	; (8019c30 <certif_tx+0x128>)
 8019bb0:	781b      	ldrb	r3, [r3, #0]
 8019bb2:	2b00      	cmp	r3, #0
 8019bb4:	d112      	bne.n	8019bdc <certif_tx+0xd4>
      {
          mcpsReq.Type = MCPS_UNCONFIRMED;
 8019bb6:	2108      	movs	r1, #8
 8019bb8:	187b      	adds	r3, r7, r1
 8019bba:	2200      	movs	r2, #0
 8019bbc:	701a      	strb	r2, [r3, #0]
          mcpsReq.Req.Unconfirmed.fPort = CERTIF_PORT;
 8019bbe:	187b      	adds	r3, r7, r1
 8019bc0:	22e0      	movs	r2, #224	; 0xe0
 8019bc2:	711a      	strb	r2, [r3, #4]
          mcpsReq.Req.Unconfirmed.fBufferSize = certifParam.DataBufferSize;
 8019bc4:	4b19      	ldr	r3, [pc, #100]	; (8019c2c <certif_tx+0x124>)
 8019bc6:	78db      	ldrb	r3, [r3, #3]
 8019bc8:	b29a      	uxth	r2, r3
 8019bca:	187b      	adds	r3, r7, r1
 8019bcc:	819a      	strh	r2, [r3, #12]
          mcpsReq.Req.Unconfirmed.fBuffer = &(certifParam.DataBuffer);
 8019bce:	187b      	adds	r3, r7, r1
 8019bd0:	4a18      	ldr	r2, [pc, #96]	; (8019c34 <certif_tx+0x12c>)
 8019bd2:	609a      	str	r2, [r3, #8]
          mcpsReq.Req.Unconfirmed.Datarate = DR_0;
 8019bd4:	187b      	adds	r3, r7, r1
 8019bd6:	2200      	movs	r2, #0
 8019bd8:	739a      	strb	r2, [r3, #14]
 8019bda:	e014      	b.n	8019c06 <certif_tx+0xfe>
      }
      else
      {
          mcpsReq.Type = MCPS_CONFIRMED;
 8019bdc:	2108      	movs	r1, #8
 8019bde:	187b      	adds	r3, r7, r1
 8019be0:	2201      	movs	r2, #1
 8019be2:	701a      	strb	r2, [r3, #0]
          mcpsReq.Req.Confirmed.fPort = CERTIF_PORT;
 8019be4:	187b      	adds	r3, r7, r1
 8019be6:	22e0      	movs	r2, #224	; 0xe0
 8019be8:	711a      	strb	r2, [r3, #4]
          mcpsReq.Req.Confirmed.fBufferSize = certifParam.DataBufferSize;
 8019bea:	4b10      	ldr	r3, [pc, #64]	; (8019c2c <certif_tx+0x124>)
 8019bec:	78db      	ldrb	r3, [r3, #3]
 8019bee:	b29a      	uxth	r2, r3
 8019bf0:	187b      	adds	r3, r7, r1
 8019bf2:	819a      	strh	r2, [r3, #12]
          mcpsReq.Req.Confirmed.fBuffer = &(certifParam.DataBuffer);
 8019bf4:	187b      	adds	r3, r7, r1
 8019bf6:	4a0f      	ldr	r2, [pc, #60]	; (8019c34 <certif_tx+0x12c>)
 8019bf8:	609a      	str	r2, [r3, #8]
          mcpsReq.Req.Confirmed.NbTrials = 8;
 8019bfa:	187b      	adds	r3, r7, r1
 8019bfc:	2208      	movs	r2, #8
 8019bfe:	73da      	strb	r2, [r3, #15]
          mcpsReq.Req.Confirmed.Datarate = DR_0;
 8019c00:	187b      	adds	r3, r7, r1
 8019c02:	2200      	movs	r2, #0
 8019c04:	739a      	strb	r2, [r3, #14]
      }
  }

  /*cerification test on-going*/
  TimerStart( &CertifTxNextPacketTimer );
 8019c06:	4b0c      	ldr	r3, [pc, #48]	; (8019c38 <certif_tx+0x130>)
 8019c08:	0018      	movs	r0, r3
 8019c0a:	f001 f93b 	bl	801ae84 <TimerStart>
	
  if( LoRaMacMcpsRequest( &mcpsReq ) == LORAMAC_STATUS_OK )
 8019c0e:	2308      	movs	r3, #8
 8019c10:	18fb      	adds	r3, r7, r3
 8019c12:	0018      	movs	r0, r3
 8019c14:	f7fa ff52 	bl	8014abc <LoRaMacMcpsRequest>
 8019c18:	1e03      	subs	r3, r0, #0
 8019c1a:	d101      	bne.n	8019c20 <certif_tx+0x118>
  {
      return false;
 8019c1c:	2300      	movs	r3, #0
 8019c1e:	e000      	b.n	8019c22 <certif_tx+0x11a>
  }
    return true;
 8019c20:	2301      	movs	r3, #1
}
 8019c22:	0018      	movs	r0, r3
 8019c24:	46bd      	mov	sp, r7
 8019c26:	b006      	add	sp, #24
 8019c28:	bd80      	pop	{r7, pc}
 8019c2a:	46c0      	nop			; (mov r8, r8)
 8019c2c:	200011fc 	.word	0x200011fc
 8019c30:	200012f8 	.word	0x200012f8
 8019c34:	20001200 	.word	0x20001200
 8019c38:	200011e4 	.word	0x200011e4

08019c3c <certif_rx>:

void certif_rx( McpsIndication_t *mcpsIndication, MlmeReqJoin_t* JoinParameters)
{
 8019c3c:	b590      	push	{r4, r7, lr}
 8019c3e:	b0a1      	sub	sp, #132	; 0x84
 8019c40:	af00      	add	r7, sp, #0
 8019c42:	6078      	str	r0, [r7, #4]
 8019c44:	6039      	str	r1, [r7, #0]
  if( certifParam.Running == false )
 8019c46:	4bb3      	ldr	r3, [pc, #716]	; (8019f14 <certif_rx+0x2d8>)
 8019c48:	781b      	ldrb	r3, [r3, #0]
 8019c4a:	2201      	movs	r2, #1
 8019c4c:	4053      	eors	r3, r2
 8019c4e:	b2db      	uxtb	r3, r3
 8019c50:	2b00      	cmp	r3, #0
 8019c52:	d065      	beq.n	8019d20 <certif_rx+0xe4>
  {
      // Check compliance test enable command (i)
      if( ( mcpsIndication->BufferSize == 4 ) &&
 8019c54:	687b      	ldr	r3, [r7, #4]
 8019c56:	7b1b      	ldrb	r3, [r3, #12]
 8019c58:	2b04      	cmp	r3, #4
 8019c5a:	d000      	beq.n	8019c5e <certif_rx+0x22>
 8019c5c:	e14a      	b.n	8019ef4 <certif_rx+0x2b8>
          ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8019c5e:	687b      	ldr	r3, [r7, #4]
 8019c60:	689b      	ldr	r3, [r3, #8]
 8019c62:	781b      	ldrb	r3, [r3, #0]
      if( ( mcpsIndication->BufferSize == 4 ) &&
 8019c64:	2b01      	cmp	r3, #1
 8019c66:	d000      	beq.n	8019c6a <certif_rx+0x2e>
 8019c68:	e144      	b.n	8019ef4 <certif_rx+0x2b8>
          ( mcpsIndication->Buffer[1] == 0x01 ) &&
 8019c6a:	687b      	ldr	r3, [r7, #4]
 8019c6c:	689b      	ldr	r3, [r3, #8]
 8019c6e:	3301      	adds	r3, #1
 8019c70:	781b      	ldrb	r3, [r3, #0]
          ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8019c72:	2b01      	cmp	r3, #1
 8019c74:	d000      	beq.n	8019c78 <certif_rx+0x3c>
 8019c76:	e13d      	b.n	8019ef4 <certif_rx+0x2b8>
          ( mcpsIndication->Buffer[2] == 0x01 ) &&
 8019c78:	687b      	ldr	r3, [r7, #4]
 8019c7a:	689b      	ldr	r3, [r3, #8]
 8019c7c:	3302      	adds	r3, #2
 8019c7e:	781b      	ldrb	r3, [r3, #0]
          ( mcpsIndication->Buffer[1] == 0x01 ) &&
 8019c80:	2b01      	cmp	r3, #1
 8019c82:	d000      	beq.n	8019c86 <certif_rx+0x4a>
 8019c84:	e136      	b.n	8019ef4 <certif_rx+0x2b8>
          ( mcpsIndication->Buffer[3] == 0x01 ) )
 8019c86:	687b      	ldr	r3, [r7, #4]
 8019c88:	689b      	ldr	r3, [r3, #8]
 8019c8a:	3303      	adds	r3, #3
 8019c8c:	781b      	ldrb	r3, [r3, #0]
          ( mcpsIndication->Buffer[2] == 0x01 ) &&
 8019c8e:	2b01      	cmp	r3, #1
 8019c90:	d000      	beq.n	8019c94 <certif_rx+0x58>
 8019c92:	e12f      	b.n	8019ef4 <certif_rx+0x2b8>
      {
          MibRequestConfirm_t mibReq;
          IsTxConfirmed = LORAWAN_UNCONFIRMED_MSG;
 8019c94:	4ba0      	ldr	r3, [pc, #640]	; (8019f18 <certif_rx+0x2dc>)
 8019c96:	2200      	movs	r2, #0
 8019c98:	701a      	strb	r2, [r3, #0]
          certifParam.DataBufferSize = 2;
 8019c9a:	4b9e      	ldr	r3, [pc, #632]	; (8019f14 <certif_rx+0x2d8>)
 8019c9c:	2202      	movs	r2, #2
 8019c9e:	70da      	strb	r2, [r3, #3]
          certifParam.DownLinkCounter = 0;
 8019ca0:	4b9c      	ldr	r3, [pc, #624]	; (8019f14 <certif_rx+0x2d8>)
 8019ca2:	22f6      	movs	r2, #246	; 0xf6
 8019ca4:	2100      	movs	r1, #0
 8019ca6:	5299      	strh	r1, [r3, r2]
          certifParam.LinkCheck = false;
 8019ca8:	4b9a      	ldr	r3, [pc, #616]	; (8019f14 <certif_rx+0x2d8>)
 8019caa:	22f8      	movs	r2, #248	; 0xf8
 8019cac:	2100      	movs	r1, #0
 8019cae:	5499      	strb	r1, [r3, r2]
          certifParam.DemodMargin = 0;
 8019cb0:	4b98      	ldr	r3, [pc, #608]	; (8019f14 <certif_rx+0x2d8>)
 8019cb2:	22f9      	movs	r2, #249	; 0xf9
 8019cb4:	2100      	movs	r1, #0
 8019cb6:	5499      	strb	r1, [r3, r2]
          certifParam.NbGateways = 0;
 8019cb8:	4b96      	ldr	r3, [pc, #600]	; (8019f14 <certif_rx+0x2d8>)
 8019cba:	22fa      	movs	r2, #250	; 0xfa
 8019cbc:	2100      	movs	r1, #0
 8019cbe:	5499      	strb	r1, [r3, r2]
          certifParam.Running = true;
 8019cc0:	4b94      	ldr	r3, [pc, #592]	; (8019f14 <certif_rx+0x2d8>)
 8019cc2:	2201      	movs	r2, #1
 8019cc4:	701a      	strb	r2, [r3, #0]
          certifParam.State = 1;
 8019cc6:	4b93      	ldr	r3, [pc, #588]	; (8019f14 <certif_rx+0x2d8>)
 8019cc8:	2201      	movs	r2, #1
 8019cca:	705a      	strb	r2, [r3, #1]

          mibReq.Type = MIB_ADR;
 8019ccc:	210c      	movs	r1, #12
 8019cce:	187b      	adds	r3, r7, r1
 8019cd0:	2204      	movs	r2, #4
 8019cd2:	701a      	strb	r2, [r3, #0]

          LoRaMacMibGetRequestConfirm( &mibReq );
 8019cd4:	000c      	movs	r4, r1
 8019cd6:	187b      	adds	r3, r7, r1
 8019cd8:	0018      	movs	r0, r3
 8019cda:	f7f9 ff4d 	bl	8013b78 <LoRaMacMibGetRequestConfirm>
          AdrEnableInit=mibReq.Param.AdrEnable;
 8019cde:	0021      	movs	r1, r4
 8019ce0:	187b      	adds	r3, r7, r1
 8019ce2:	791a      	ldrb	r2, [r3, #4]
 8019ce4:	4b8d      	ldr	r3, [pc, #564]	; (8019f1c <certif_rx+0x2e0>)
 8019ce6:	701a      	strb	r2, [r3, #0]
          
          mibReq.Type = MIB_ADR;
 8019ce8:	187b      	adds	r3, r7, r1
 8019cea:	2204      	movs	r2, #4
 8019cec:	701a      	strb	r2, [r3, #0]
          mibReq.Param.AdrEnable = true;
 8019cee:	187b      	adds	r3, r7, r1
 8019cf0:	2201      	movs	r2, #1
 8019cf2:	711a      	strb	r2, [r3, #4]
          LoRaMacMibSetRequestConfirm( &mibReq );
 8019cf4:	187b      	adds	r3, r7, r1
 8019cf6:	0018      	movs	r0, r3
 8019cf8:	f7fa f89a 	bl	8013e30 <LoRaMacMibSetRequestConfirm>

#if defined( REGION_EU868 ) || defined( REGION_RU864 ) || defined( REGION_CN779 ) || defined( REGION_EU433 )
          LoRaMacTestSetDutyCycleOn( false );
 8019cfc:	2000      	movs	r0, #0
 8019cfe:	f7fb f823 	bl	8014d48 <LoRaMacTestSetDutyCycleOn>
#endif

         
        TimerInit( &CertifTxNextPacketTimer, OnCertifTxNextPacketTimerEvent );
 8019d02:	4a87      	ldr	r2, [pc, #540]	; (8019f20 <certif_rx+0x2e4>)
 8019d04:	4b87      	ldr	r3, [pc, #540]	; (8019f24 <certif_rx+0x2e8>)
 8019d06:	0011      	movs	r1, r2
 8019d08:	0018      	movs	r0, r3
 8019d0a:	f001 f89d 	bl	801ae48 <TimerInit>
        TimerSetValue( &CertifTxNextPacketTimer,  TEST_TX_DUTYCYCLE); 
 8019d0e:	4a86      	ldr	r2, [pc, #536]	; (8019f28 <certif_rx+0x2ec>)
 8019d10:	4b84      	ldr	r3, [pc, #528]	; (8019f24 <certif_rx+0x2e8>)
 8019d12:	0011      	movs	r1, r2
 8019d14:	0018      	movs	r0, r3
 8019d16:	f001 fa0f 	bl	801b138 <TimerSetValue>
        
        /*confirm test mode activation */
        certif_tx( );
 8019d1a:	f7ff fef5 	bl	8019b08 <certif_tx>
 8019d1e:	e0e9      	b.n	8019ef4 <certif_rx+0x2b8>
      }
  }

  else
  {
      certifParam.State = mcpsIndication->Buffer[0];
 8019d20:	687b      	ldr	r3, [r7, #4]
 8019d22:	689b      	ldr	r3, [r3, #8]
 8019d24:	781a      	ldrb	r2, [r3, #0]
 8019d26:	4b7b      	ldr	r3, [pc, #492]	; (8019f14 <certif_rx+0x2d8>)
 8019d28:	705a      	strb	r2, [r3, #1]
      switch( certifParam.State )
 8019d2a:	4b7a      	ldr	r3, [pc, #488]	; (8019f14 <certif_rx+0x2d8>)
 8019d2c:	785b      	ldrb	r3, [r3, #1]
 8019d2e:	2b08      	cmp	r3, #8
 8019d30:	d900      	bls.n	8019d34 <certif_rx+0xf8>
 8019d32:	e0de      	b.n	8019ef2 <certif_rx+0x2b6>
 8019d34:	009a      	lsls	r2, r3, #2
 8019d36:	4b7d      	ldr	r3, [pc, #500]	; (8019f2c <certif_rx+0x2f0>)
 8019d38:	18d3      	adds	r3, r2, r3
 8019d3a:	681b      	ldr	r3, [r3, #0]
 8019d3c:	469f      	mov	pc, r3
      {
        case 0: // Check compliance test disable command (ii)
        {
          
          certifParam.DownLinkCounter = 0;
 8019d3e:	4b75      	ldr	r3, [pc, #468]	; (8019f14 <certif_rx+0x2d8>)
 8019d40:	22f6      	movs	r2, #246	; 0xf6
 8019d42:	2100      	movs	r1, #0
 8019d44:	5299      	strh	r1, [r3, r2]
          certifParam.Running = false;
 8019d46:	4b73      	ldr	r3, [pc, #460]	; (8019f14 <certif_rx+0x2d8>)
 8019d48:	2200      	movs	r2, #0
 8019d4a:	701a      	strb	r2, [r3, #0]
          
          MibRequestConfirm_t mibReq;
          mibReq.Type = MIB_ADR;
 8019d4c:	210c      	movs	r1, #12
 8019d4e:	187b      	adds	r3, r7, r1
 8019d50:	2204      	movs	r2, #4
 8019d52:	701a      	strb	r2, [r3, #0]
          mibReq.Param.AdrEnable = AdrEnableInit;
 8019d54:	4b71      	ldr	r3, [pc, #452]	; (8019f1c <certif_rx+0x2e0>)
 8019d56:	781a      	ldrb	r2, [r3, #0]
 8019d58:	187b      	adds	r3, r7, r1
 8019d5a:	711a      	strb	r2, [r3, #4]
          LoRaMacMibSetRequestConfirm( &mibReq );
 8019d5c:	187b      	adds	r3, r7, r1
 8019d5e:	0018      	movs	r0, r3
 8019d60:	f7fa f866 	bl	8013e30 <LoRaMacMibSetRequestConfirm>
#if defined( REGION_EU868 ) || defined( REGION_RU864 ) || defined( REGION_CN779 ) || defined( REGION_EU433 )
          LoRaMacTestSetDutyCycleOn( true );
 8019d64:	2001      	movs	r0, #1
 8019d66:	f7fa ffef 	bl	8014d48 <LoRaMacTestSetDutyCycleOn>
#endif
          
          break;
 8019d6a:	e0c3      	b.n	8019ef4 <certif_rx+0x2b8>
        }
        case 1: // (iii, iv)
          certifParam.DataBufferSize = 2;
 8019d6c:	4b69      	ldr	r3, [pc, #420]	; (8019f14 <certif_rx+0x2d8>)
 8019d6e:	2202      	movs	r2, #2
 8019d70:	70da      	strb	r2, [r3, #3]
          break;
 8019d72:	e0bf      	b.n	8019ef4 <certif_rx+0x2b8>
        case 2: // Enable confirmed messages (v)
          IsTxConfirmed = LORAWAN_CONFIRMED_MSG;
 8019d74:	4b68      	ldr	r3, [pc, #416]	; (8019f18 <certif_rx+0x2dc>)
 8019d76:	2201      	movs	r2, #1
 8019d78:	701a      	strb	r2, [r3, #0]
          certifParam.State = 1;
 8019d7a:	4b66      	ldr	r3, [pc, #408]	; (8019f14 <certif_rx+0x2d8>)
 8019d7c:	2201      	movs	r2, #1
 8019d7e:	705a      	strb	r2, [r3, #1]
          break;
 8019d80:	e0b8      	b.n	8019ef4 <certif_rx+0x2b8>
        case 3:  // Disable confirmed messages (vi)
          IsTxConfirmed = LORAWAN_UNCONFIRMED_MSG;
 8019d82:	4b65      	ldr	r3, [pc, #404]	; (8019f18 <certif_rx+0x2dc>)
 8019d84:	2200      	movs	r2, #0
 8019d86:	701a      	strb	r2, [r3, #0]
          certifParam.State = 1;
 8019d88:	4b62      	ldr	r3, [pc, #392]	; (8019f14 <certif_rx+0x2d8>)
 8019d8a:	2201      	movs	r2, #1
 8019d8c:	705a      	strb	r2, [r3, #1]
          break;
 8019d8e:	e0b1      	b.n	8019ef4 <certif_rx+0x2b8>
        case 4: // (vii)
          certifParam.DataBufferSize = mcpsIndication->BufferSize;
 8019d90:	687b      	ldr	r3, [r7, #4]
 8019d92:	7b1a      	ldrb	r2, [r3, #12]
 8019d94:	4b5f      	ldr	r3, [pc, #380]	; (8019f14 <certif_rx+0x2d8>)
 8019d96:	70da      	strb	r2, [r3, #3]

          certifParam.DataBuffer[0] = 4;
 8019d98:	4b5e      	ldr	r3, [pc, #376]	; (8019f14 <certif_rx+0x2d8>)
 8019d9a:	2204      	movs	r2, #4
 8019d9c:	711a      	strb	r2, [r3, #4]
          for( uint8_t i = 1; i < certifParam.DataBufferSize; i++ )
 8019d9e:	237f      	movs	r3, #127	; 0x7f
 8019da0:	18fb      	adds	r3, r7, r3
 8019da2:	2201      	movs	r2, #1
 8019da4:	701a      	strb	r2, [r3, #0]
 8019da6:	e013      	b.n	8019dd0 <certif_rx+0x194>
          {
              certifParam.DataBuffer[i] = mcpsIndication->Buffer[i] + 1;
 8019da8:	687b      	ldr	r3, [r7, #4]
 8019daa:	689a      	ldr	r2, [r3, #8]
 8019dac:	207f      	movs	r0, #127	; 0x7f
 8019dae:	183b      	adds	r3, r7, r0
 8019db0:	781b      	ldrb	r3, [r3, #0]
 8019db2:	18d3      	adds	r3, r2, r3
 8019db4:	781a      	ldrb	r2, [r3, #0]
 8019db6:	183b      	adds	r3, r7, r0
 8019db8:	781b      	ldrb	r3, [r3, #0]
 8019dba:	3201      	adds	r2, #1
 8019dbc:	b2d1      	uxtb	r1, r2
 8019dbe:	4a55      	ldr	r2, [pc, #340]	; (8019f14 <certif_rx+0x2d8>)
 8019dc0:	18d3      	adds	r3, r2, r3
 8019dc2:	1c0a      	adds	r2, r1, #0
 8019dc4:	711a      	strb	r2, [r3, #4]
          for( uint8_t i = 1; i < certifParam.DataBufferSize; i++ )
 8019dc6:	183b      	adds	r3, r7, r0
 8019dc8:	781a      	ldrb	r2, [r3, #0]
 8019dca:	183b      	adds	r3, r7, r0
 8019dcc:	3201      	adds	r2, #1
 8019dce:	701a      	strb	r2, [r3, #0]
 8019dd0:	4b50      	ldr	r3, [pc, #320]	; (8019f14 <certif_rx+0x2d8>)
 8019dd2:	78db      	ldrb	r3, [r3, #3]
 8019dd4:	227f      	movs	r2, #127	; 0x7f
 8019dd6:	18ba      	adds	r2, r7, r2
 8019dd8:	7812      	ldrb	r2, [r2, #0]
 8019dda:	429a      	cmp	r2, r3
 8019ddc:	d3e4      	bcc.n	8019da8 <certif_rx+0x16c>
          }
          break;
 8019dde:	e089      	b.n	8019ef4 <certif_rx+0x2b8>
        case 5: // (viii)
        {
          MlmeReq_t mlmeReq;
          mlmeReq.Type = MLME_LINK_CHECK;
 8019de0:	216c      	movs	r1, #108	; 0x6c
 8019de2:	187b      	adds	r3, r7, r1
 8019de4:	2203      	movs	r2, #3
 8019de6:	701a      	strb	r2, [r3, #0]
          LoRaMacMlmeRequest( &mlmeReq );
 8019de8:	187b      	adds	r3, r7, r1
 8019dea:	0018      	movs	r0, r3
 8019dec:	f7fa fd14 	bl	8014818 <LoRaMacMlmeRequest>
          break;
 8019df0:	e080      	b.n	8019ef4 <certif_rx+0x2b8>
        {
            MlmeReq_t mlmeReq;

            // Disable TestMode and revert back to normal operation

            certifParam.DownLinkCounter = 0;
 8019df2:	4b48      	ldr	r3, [pc, #288]	; (8019f14 <certif_rx+0x2d8>)
 8019df4:	22f6      	movs	r2, #246	; 0xf6
 8019df6:	2100      	movs	r1, #0
 8019df8:	5299      	strh	r1, [r3, r2]
            certifParam.Running = false;
 8019dfa:	4b46      	ldr	r3, [pc, #280]	; (8019f14 <certif_rx+0x2d8>)
 8019dfc:	2200      	movs	r2, #0
 8019dfe:	701a      	strb	r2, [r3, #0]

            MibRequestConfirm_t mibReq;
            mibReq.Type = MIB_ADR;
 8019e00:	210c      	movs	r1, #12
 8019e02:	187b      	adds	r3, r7, r1
 8019e04:	2204      	movs	r2, #4
 8019e06:	701a      	strb	r2, [r3, #0]
            mibReq.Param.AdrEnable = AdrEnableInit;
 8019e08:	4b44      	ldr	r3, [pc, #272]	; (8019f1c <certif_rx+0x2e0>)
 8019e0a:	781a      	ldrb	r2, [r3, #0]
 8019e0c:	187b      	adds	r3, r7, r1
 8019e0e:	711a      	strb	r2, [r3, #4]
            LoRaMacMibSetRequestConfirm( &mibReq );
 8019e10:	187b      	adds	r3, r7, r1
 8019e12:	0018      	movs	r0, r3
 8019e14:	f7fa f80c 	bl	8013e30 <LoRaMacMibSetRequestConfirm>

            mlmeReq.Type = MLME_JOIN;
 8019e18:	215c      	movs	r1, #92	; 0x5c
 8019e1a:	187b      	adds	r3, r7, r1
 8019e1c:	2200      	movs	r2, #0
 8019e1e:	701a      	strb	r2, [r3, #0]
            mlmeReq.Req.Join = *JoinParameters;
 8019e20:	187b      	adds	r3, r7, r1
 8019e22:	683a      	ldr	r2, [r7, #0]
 8019e24:	7812      	ldrb	r2, [r2, #0]
 8019e26:	711a      	strb	r2, [r3, #4]

            LoRaMacMlmeRequest( &mlmeReq );
 8019e28:	187b      	adds	r3, r7, r1
 8019e2a:	0018      	movs	r0, r3
 8019e2c:	f7fa fcf4 	bl	8014818 <LoRaMacMlmeRequest>
            break;
 8019e30:	e060      	b.n	8019ef4 <certif_rx+0x2b8>
        }

        case 7: // (x)
        {
          if( mcpsIndication->BufferSize == 3 )
 8019e32:	687b      	ldr	r3, [r7, #4]
 8019e34:	7b1b      	ldrb	r3, [r3, #12]
 8019e36:	2b03      	cmp	r3, #3
 8019e38:	d118      	bne.n	8019e6c <certif_rx+0x230>
          {
              MlmeReq_t mlmeReq;
              mlmeReq.Type = MLME_TXCW;
 8019e3a:	214c      	movs	r1, #76	; 0x4c
 8019e3c:	187b      	adds	r3, r7, r1
 8019e3e:	2204      	movs	r2, #4
 8019e40:	701a      	strb	r2, [r3, #0]
              mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 8019e42:	687b      	ldr	r3, [r7, #4]
 8019e44:	689b      	ldr	r3, [r3, #8]
 8019e46:	3301      	adds	r3, #1
 8019e48:	781b      	ldrb	r3, [r3, #0]
 8019e4a:	021b      	lsls	r3, r3, #8
 8019e4c:	b21a      	sxth	r2, r3
 8019e4e:	687b      	ldr	r3, [r7, #4]
 8019e50:	689b      	ldr	r3, [r3, #8]
 8019e52:	3302      	adds	r3, #2
 8019e54:	781b      	ldrb	r3, [r3, #0]
 8019e56:	b21b      	sxth	r3, r3
 8019e58:	4313      	orrs	r3, r2
 8019e5a:	b21b      	sxth	r3, r3
 8019e5c:	b29a      	uxth	r2, r3
 8019e5e:	187b      	adds	r3, r7, r1
 8019e60:	809a      	strh	r2, [r3, #4]
              LoRaMacMlmeRequest( &mlmeReq );
 8019e62:	187b      	adds	r3, r7, r1
 8019e64:	0018      	movs	r0, r3
 8019e66:	f7fa fcd7 	bl	8014818 <LoRaMacMlmeRequest>
 8019e6a:	e035      	b.n	8019ed8 <certif_rx+0x29c>
          }
          else if( mcpsIndication->BufferSize == 7 )
 8019e6c:	687b      	ldr	r3, [r7, #4]
 8019e6e:	7b1b      	ldrb	r3, [r3, #12]
 8019e70:	2b07      	cmp	r3, #7
 8019e72:	d131      	bne.n	8019ed8 <certif_rx+0x29c>
          {
              MlmeReq_t mlmeReq;
              mlmeReq.Type = MLME_TXCW_1;
 8019e74:	213c      	movs	r1, #60	; 0x3c
 8019e76:	187b      	adds	r3, r7, r1
 8019e78:	2205      	movs	r2, #5
 8019e7a:	701a      	strb	r2, [r3, #0]
              mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 8019e7c:	687b      	ldr	r3, [r7, #4]
 8019e7e:	689b      	ldr	r3, [r3, #8]
 8019e80:	3301      	adds	r3, #1
 8019e82:	781b      	ldrb	r3, [r3, #0]
 8019e84:	021b      	lsls	r3, r3, #8
 8019e86:	b21a      	sxth	r2, r3
 8019e88:	687b      	ldr	r3, [r7, #4]
 8019e8a:	689b      	ldr	r3, [r3, #8]
 8019e8c:	3302      	adds	r3, #2
 8019e8e:	781b      	ldrb	r3, [r3, #0]
 8019e90:	b21b      	sxth	r3, r3
 8019e92:	4313      	orrs	r3, r2
 8019e94:	b21b      	sxth	r3, r3
 8019e96:	b29a      	uxth	r2, r3
 8019e98:	187b      	adds	r3, r7, r1
 8019e9a:	809a      	strh	r2, [r3, #4]
              mlmeReq.Req.TxCw.Frequency = ( uint32_t )( ( mcpsIndication->Buffer[3] << 16 ) | ( mcpsIndication->Buffer[4] << 8 ) | mcpsIndication->Buffer[5] ) * 100;
 8019e9c:	687b      	ldr	r3, [r7, #4]
 8019e9e:	689b      	ldr	r3, [r3, #8]
 8019ea0:	3303      	adds	r3, #3
 8019ea2:	781b      	ldrb	r3, [r3, #0]
 8019ea4:	041a      	lsls	r2, r3, #16
 8019ea6:	687b      	ldr	r3, [r7, #4]
 8019ea8:	689b      	ldr	r3, [r3, #8]
 8019eaa:	3304      	adds	r3, #4
 8019eac:	781b      	ldrb	r3, [r3, #0]
 8019eae:	021b      	lsls	r3, r3, #8
 8019eb0:	431a      	orrs	r2, r3
 8019eb2:	687b      	ldr	r3, [r7, #4]
 8019eb4:	689b      	ldr	r3, [r3, #8]
 8019eb6:	3305      	adds	r3, #5
 8019eb8:	781b      	ldrb	r3, [r3, #0]
 8019eba:	4313      	orrs	r3, r2
 8019ebc:	001a      	movs	r2, r3
 8019ebe:	2364      	movs	r3, #100	; 0x64
 8019ec0:	435a      	muls	r2, r3
 8019ec2:	187b      	adds	r3, r7, r1
 8019ec4:	609a      	str	r2, [r3, #8]
              mlmeReq.Req.TxCw.Power = mcpsIndication->Buffer[6];
 8019ec6:	687b      	ldr	r3, [r7, #4]
 8019ec8:	689b      	ldr	r3, [r3, #8]
 8019eca:	799a      	ldrb	r2, [r3, #6]
 8019ecc:	187b      	adds	r3, r7, r1
 8019ece:	731a      	strb	r2, [r3, #12]
              LoRaMacMlmeRequest( &mlmeReq );
 8019ed0:	187b      	adds	r3, r7, r1
 8019ed2:	0018      	movs	r0, r3
 8019ed4:	f7fa fca0 	bl	8014818 <LoRaMacMlmeRequest>
          }
          certifParam.State = 1;
 8019ed8:	4b0e      	ldr	r3, [pc, #56]	; (8019f14 <certif_rx+0x2d8>)
 8019eda:	2201      	movs	r2, #1
 8019edc:	705a      	strb	r2, [r3, #1]
          break;
 8019ede:	e009      	b.n	8019ef4 <certif_rx+0x2b8>
		
        case 8: // Send DeviceTimeReq
        {
          MlmeReq_t mlmeReq;

          mlmeReq.Type = MLME_DEVICE_TIME;
 8019ee0:	212c      	movs	r1, #44	; 0x2c
 8019ee2:	187b      	adds	r3, r7, r1
 8019ee4:	2209      	movs	r2, #9
 8019ee6:	701a      	strb	r2, [r3, #0]

          LoRaMacMlmeRequest( &mlmeReq );
 8019ee8:	187b      	adds	r3, r7, r1
 8019eea:	0018      	movs	r0, r3
 8019eec:	f7fa fc94 	bl	8014818 <LoRaMacMlmeRequest>
          break;
 8019ef0:	e000      	b.n	8019ef4 <certif_rx+0x2b8>
          LoRaMacMlmeRequest( &mlmeReq );
          break;
        }
#endif /* LORAMAC_CLASSB_ENABLED */
        default:                  
          break;
 8019ef2:	46c0      	nop			; (mov r8, r8)
        }
    }
  
    if ( certifParam.Running == false )
 8019ef4:	4b07      	ldr	r3, [pc, #28]	; (8019f14 <certif_rx+0x2d8>)
 8019ef6:	781b      	ldrb	r3, [r3, #0]
 8019ef8:	2201      	movs	r2, #1
 8019efa:	4053      	eors	r3, r2
 8019efc:	b2db      	uxtb	r3, r3
 8019efe:	2b00      	cmp	r3, #0
 8019f00:	d003      	beq.n	8019f0a <certif_rx+0x2ce>
    {
      /*cerification test stops*/
      TimerStop( &CertifTxNextPacketTimer );
 8019f02:	4b08      	ldr	r3, [pc, #32]	; (8019f24 <certif_rx+0x2e8>)
 8019f04:	0018      	movs	r0, r3
 8019f06:	f001 f899 	bl	801b03c <TimerStop>
    }
}
 8019f0a:	46c0      	nop			; (mov r8, r8)
 8019f0c:	46bd      	mov	sp, r7
 8019f0e:	b021      	add	sp, #132	; 0x84
 8019f10:	bd90      	pop	{r4, r7, pc}
 8019f12:	46c0      	nop			; (mov r8, r8)
 8019f14:	200011fc 	.word	0x200011fc
 8019f18:	200012f8 	.word	0x200012f8
 8019f1c:	200012f9 	.word	0x200012f9
 8019f20:	08019f31 	.word	0x08019f31
 8019f24:	200011e4 	.word	0x200011e4
 8019f28:	00001388 	.word	0x00001388
 8019f2c:	0801f5ec 	.word	0x0801f5ec

08019f30 <OnCertifTxNextPacketTimerEvent>:

/*!
 * \brief Function executed on TxNextPacket Timeout event
 */
static void OnCertifTxNextPacketTimerEvent( void* context )
{
 8019f30:	b580      	push	{r7, lr}
 8019f32:	b082      	sub	sp, #8
 8019f34:	af00      	add	r7, sp, #0
 8019f36:	6078      	str	r0, [r7, #4]
    certif_tx( );
 8019f38:	f7ff fde6 	bl	8019b08 <certif_tx>

}
 8019f3c:	46c0      	nop			; (mov r8, r8)
 8019f3e:	46bd      	mov	sp, r7
 8019f40:	b002      	add	sp, #8
 8019f42:	bd80      	pop	{r7, pc}

08019f44 <McpsConfirm>:
 *
 * \param   [IN] McpsConfirm - Pointer to the confirm structure,
 *               containing confirm attributes.
 */
static void McpsConfirm( McpsConfirm_t *mcpsConfirm )
{
 8019f44:	b580      	push	{r7, lr}
 8019f46:	b084      	sub	sp, #16
 8019f48:	af00      	add	r7, sp, #0
 8019f4a:	6078      	str	r0, [r7, #4]
    TVL2( PRINTNOW(); PRINTF("APP> McpsConfirm STATUS: %s\r\n", EventInfoStatusStrings[mcpsConfirm->Status] ); )
  
    if( mcpsConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
 8019f4c:	687b      	ldr	r3, [r7, #4]
 8019f4e:	785b      	ldrb	r3, [r3, #1]
 8019f50:	2b00      	cmp	r3, #0
 8019f52:	d109      	bne.n	8019f68 <McpsConfirm+0x24>
    {
        switch( mcpsConfirm->McpsRequest )
 8019f54:	687b      	ldr	r3, [r7, #4]
 8019f56:	781b      	ldrb	r3, [r3, #0]
 8019f58:	2b03      	cmp	r3, #3
 8019f5a:	d007      	beq.n	8019f6c <McpsConfirm+0x28>
 8019f5c:	dc08      	bgt.n	8019f70 <McpsConfirm+0x2c>
 8019f5e:	2b00      	cmp	r3, #0
 8019f60:	d008      	beq.n	8019f74 <McpsConfirm+0x30>
 8019f62:	2b01      	cmp	r3, #1
 8019f64:	d008      	beq.n	8019f78 <McpsConfirm+0x34>
            case MCPS_PROPRIETARY:
            {
                break;
            }
            default:
                break;
 8019f66:	e003      	b.n	8019f70 <McpsConfirm+0x2c>
        }
    }
 8019f68:	46c0      	nop			; (mov r8, r8)
 8019f6a:	e006      	b.n	8019f7a <McpsConfirm+0x36>
                break;
 8019f6c:	46c0      	nop			; (mov r8, r8)
 8019f6e:	e004      	b.n	8019f7a <McpsConfirm+0x36>
                break;
 8019f70:	46c0      	nop			; (mov r8, r8)
 8019f72:	e002      	b.n	8019f7a <McpsConfirm+0x36>
                break;
 8019f74:	46c0      	nop			; (mov r8, r8)
 8019f76:	e000      	b.n	8019f7a <McpsConfirm+0x36>
                break;
 8019f78:	46c0      	nop			; (mov r8, r8)
    
    /*implicitely desactivated when VERBOSE_LEVEL < 2*/
    TraceUpLinkFrame(mcpsConfirm);
 8019f7a:	687b      	ldr	r3, [r7, #4]
 8019f7c:	0018      	movs	r0, r3
 8019f7e:	f000 fb2d 	bl	801a5dc <TraceUpLinkFrame>
}
 8019f82:	46c0      	nop			; (mov r8, r8)
 8019f84:	46bd      	mov	sp, r7
 8019f86:	b004      	add	sp, #16
 8019f88:	bd80      	pop	{r7, pc}
	...

08019f8c <McpsIndication>:
 *
 * \param   [IN] mcpsIndication - Pointer to the indication structure,
 *               containing indication attributes.
 */
static void McpsIndication( McpsIndication_t *mcpsIndication )
{
 8019f8c:	b580      	push	{r7, lr}
 8019f8e:	b086      	sub	sp, #24
 8019f90:	af00      	add	r7, sp, #0
 8019f92:	6078      	str	r0, [r7, #4]
    TVL2( PRINTNOW(); PRINTF("APP> McpsInd STATUS: %s\r\n", EventInfoStatusStrings[mcpsIndication->Status] );)
    
    lora_AppData_t AppData;
    if( mcpsIndication->Status != LORAMAC_EVENT_INFO_STATUS_OK )
 8019f94:	687b      	ldr	r3, [r7, #4]
 8019f96:	785b      	ldrb	r3, [r3, #1]
 8019f98:	2b00      	cmp	r3, #0
 8019f9a:	d14c      	bne.n	801a036 <McpsIndication+0xaa>
    {
        return;
    }

    switch( mcpsIndication->McpsIndication )
 8019f9c:	687b      	ldr	r3, [r7, #4]
 8019f9e:	781b      	ldrb	r3, [r3, #0]
 8019fa0:	2b03      	cmp	r3, #3
 8019fa2:	d008      	beq.n	8019fb6 <McpsIndication+0x2a>
 8019fa4:	dc09      	bgt.n	8019fba <McpsIndication+0x2e>
 8019fa6:	2b02      	cmp	r3, #2
 8019fa8:	d009      	beq.n	8019fbe <McpsIndication+0x32>
 8019faa:	dc06      	bgt.n	8019fba <McpsIndication+0x2e>
 8019fac:	2b00      	cmp	r3, #0
 8019fae:	d008      	beq.n	8019fc2 <McpsIndication+0x36>
 8019fb0:	2b01      	cmp	r3, #1
 8019fb2:	d008      	beq.n	8019fc6 <McpsIndication+0x3a>
        case MCPS_MULTICAST:
        {
            break;
        }
        default:
            break;
 8019fb4:	e001      	b.n	8019fba <McpsIndication+0x2e>
            break;
 8019fb6:	46c0      	nop			; (mov r8, r8)
 8019fb8:	e006      	b.n	8019fc8 <McpsIndication+0x3c>
            break;
 8019fba:	46c0      	nop			; (mov r8, r8)
 8019fbc:	e004      	b.n	8019fc8 <McpsIndication+0x3c>
            break;
 8019fbe:	46c0      	nop			; (mov r8, r8)
 8019fc0:	e002      	b.n	8019fc8 <McpsIndication+0x3c>
            break;
 8019fc2:	46c0      	nop			; (mov r8, r8)
 8019fc4:	e000      	b.n	8019fc8 <McpsIndication+0x3c>
            break;
 8019fc6:	46c0      	nop			; (mov r8, r8)

    // Check Multicast
    // Check Port
    // Check Datarate
    // Check FramePending
    if( mcpsIndication->FramePending == true )
 8019fc8:	687b      	ldr	r3, [r7, #4]
 8019fca:	795b      	ldrb	r3, [r3, #5]
 8019fcc:	2b01      	cmp	r3, #1
 8019fce:	d103      	bne.n	8019fd8 <McpsIndication+0x4c>
    {
        // The server signals that it has pending data to be sent.
        // We schedule an uplink as soon as possible to flush the server.
        LoRaMainCallbacks->LORA_TxNeeded( );
 8019fd0:	4b1b      	ldr	r3, [pc, #108]	; (801a040 <McpsIndication+0xb4>)
 8019fd2:	681b      	ldr	r3, [r3, #0]
 8019fd4:	69db      	ldr	r3, [r3, #28]
 8019fd6:	4798      	blx	r3
    // Check Buffer
    // Check BufferSize
    // Check Rssi
    // Check Snr
    // Check RxSlot
    if (certif_running() == true )
 8019fd8:	f7ff fd64 	bl	8019aa4 <certif_running>
 8019fdc:	1e03      	subs	r3, r0, #0
 8019fde:	d001      	beq.n	8019fe4 <McpsIndication+0x58>
    {
      certif_DownLinkIncrement( );
 8019fe0:	f7ff fd6a 	bl	8019ab8 <certif_DownLinkIncrement>
    }

    if( mcpsIndication->RxData == true )
 8019fe4:	687b      	ldr	r3, [r7, #4]
 8019fe6:	7b5b      	ldrb	r3, [r3, #13]
 8019fe8:	2b00      	cmp	r3, #0
 8019fea:	d01e      	beq.n	801a02a <McpsIndication+0x9e>
    {
      switch( mcpsIndication->Port )
 8019fec:	687b      	ldr	r3, [r7, #4]
 8019fee:	78db      	ldrb	r3, [r3, #3]
 8019ff0:	2be0      	cmp	r3, #224	; 0xe0
 8019ff2:	d106      	bne.n	801a002 <McpsIndication+0x76>
      {
        case CERTIF_PORT:
          certif_rx( mcpsIndication, &JoinParameters );
 8019ff4:	4a13      	ldr	r2, [pc, #76]	; (801a044 <McpsIndication+0xb8>)
 8019ff6:	687b      	ldr	r3, [r7, #4]
 8019ff8:	0011      	movs	r1, r2
 8019ffa:	0018      	movs	r0, r3
 8019ffc:	f7ff fe1e 	bl	8019c3c <certif_rx>
          break;
 801a000:	e014      	b.n	801a02c <McpsIndication+0xa0>
        default:
          
          AppData.Port = mcpsIndication->Port;
 801a002:	687b      	ldr	r3, [r7, #4]
 801a004:	78da      	ldrb	r2, [r3, #3]
 801a006:	2110      	movs	r1, #16
 801a008:	187b      	adds	r3, r7, r1
 801a00a:	715a      	strb	r2, [r3, #5]
          AppData.BuffSize = mcpsIndication->BufferSize;
 801a00c:	687b      	ldr	r3, [r7, #4]
 801a00e:	7b1a      	ldrb	r2, [r3, #12]
 801a010:	187b      	adds	r3, r7, r1
 801a012:	711a      	strb	r2, [r3, #4]
          AppData.Buff = mcpsIndication->Buffer;
 801a014:	687b      	ldr	r3, [r7, #4]
 801a016:	689a      	ldr	r2, [r3, #8]
 801a018:	187b      	adds	r3, r7, r1
 801a01a:	601a      	str	r2, [r3, #0]
        
          LoRaMainCallbacks->LORA_RxData( &AppData );
 801a01c:	4b08      	ldr	r3, [pc, #32]	; (801a040 <McpsIndication+0xb4>)
 801a01e:	681b      	ldr	r3, [r3, #0]
 801a020:	691b      	ldr	r3, [r3, #16]
 801a022:	187a      	adds	r2, r7, r1
 801a024:	0010      	movs	r0, r2
 801a026:	4798      	blx	r3
          break;
 801a028:	e000      	b.n	801a02c <McpsIndication+0xa0>
      }
    }
 801a02a:	46c0      	nop			; (mov r8, r8)
    
    /*implicitely desactivated when VERBOSE_LEVEL < 2*/
    TraceDownLinkFrame(mcpsIndication);
 801a02c:	687b      	ldr	r3, [r7, #4]
 801a02e:	0018      	movs	r0, r3
 801a030:	f000 fafe 	bl	801a630 <TraceDownLinkFrame>
 801a034:	e000      	b.n	801a038 <McpsIndication+0xac>
        return;
 801a036:	46c0      	nop			; (mov r8, r8)
}
 801a038:	46bd      	mov	sp, r7
 801a03a:	b006      	add	sp, #24
 801a03c:	bd80      	pop	{r7, pc}
 801a03e:	46c0      	nop			; (mov r8, r8)
 801a040:	20001344 	.word	0x20001344
 801a044:	200012fc 	.word	0x200012fc

0801a048 <MlmeConfirm>:
 *
 * \param   [IN] MlmeConfirm - Pointer to the confirm structure,
 *               containing confirm attributes.
 */
static void MlmeConfirm( MlmeConfirm_t *mlmeConfirm )
{
 801a048:	b580      	push	{r7, lr}
 801a04a:	b084      	sub	sp, #16
 801a04c:	af00      	add	r7, sp, #0
 801a04e:	6078      	str	r0, [r7, #4]
    MibRequestConfirm_t mibReq;
#endif /* LORAMAC_CLASSB_ENABLED */

    TVL2( PRINTNOW(); PRINTF("APP> MlmeConfirm STATUS: %s\r\n", EventInfoStatusStrings[mlmeConfirm->Status] );)
    
    switch( mlmeConfirm->MlmeRequest )
 801a050:	687b      	ldr	r3, [r7, #4]
 801a052:	781b      	ldrb	r3, [r3, #0]
 801a054:	2b00      	cmp	r3, #0
 801a056:	d002      	beq.n	801a05e <MlmeConfirm+0x16>
 801a058:	2b03      	cmp	r3, #3
 801a05a:	d00c      	beq.n	801a076 <MlmeConfirm+0x2e>
            }  
        }              
#endif /* USE_DEVICE_TIMING */
#endif /* LORAMAC_CLASSB_ENABLED */
        default:
            break;
 801a05c:	e018      	b.n	801a090 <MlmeConfirm+0x48>
            if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
 801a05e:	687b      	ldr	r3, [r7, #4]
 801a060:	785b      	ldrb	r3, [r3, #1]
 801a062:	2b00      	cmp	r3, #0
 801a064:	d104      	bne.n	801a070 <MlmeConfirm+0x28>
              LoRaMainCallbacks->LORA_HasJoined();
 801a066:	4b0c      	ldr	r3, [pc, #48]	; (801a098 <MlmeConfirm+0x50>)
 801a068:	681b      	ldr	r3, [r3, #0]
 801a06a:	695b      	ldr	r3, [r3, #20]
 801a06c:	4798      	blx	r3
            break;
 801a06e:	e00f      	b.n	801a090 <MlmeConfirm+0x48>
                LORA_Join();
 801a070:	f000 f9a4 	bl	801a3bc <LORA_Join>
            break;
 801a074:	e00c      	b.n	801a090 <MlmeConfirm+0x48>
            if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
 801a076:	687b      	ldr	r3, [r7, #4]
 801a078:	785b      	ldrb	r3, [r3, #1]
 801a07a:	2b00      	cmp	r3, #0
 801a07c:	d107      	bne.n	801a08e <MlmeConfirm+0x46>
                if (certif_running() == true )
 801a07e:	f7ff fd11 	bl	8019aa4 <certif_running>
 801a082:	1e03      	subs	r3, r0, #0
 801a084:	d003      	beq.n	801a08e <MlmeConfirm+0x46>
                     certif_linkCheck( mlmeConfirm);
 801a086:	687b      	ldr	r3, [r7, #4]
 801a088:	0018      	movs	r0, r3
 801a08a:	f7ff fd25 	bl	8019ad8 <certif_linkCheck>
            break;
 801a08e:	46c0      	nop			; (mov r8, r8)
    }
}
 801a090:	46c0      	nop			; (mov r8, r8)
 801a092:	46bd      	mov	sp, r7
 801a094:	b004      	add	sp, #16
 801a096:	bd80      	pop	{r7, pc}
 801a098:	20001344 	.word	0x20001344

0801a09c <MlmeIndication>:
 * \brief   MLME-Indication event function
 *
 * \param   [IN] MlmeIndication - Pointer to the indication structure.
 */
static void MlmeIndication( MlmeIndication_t *MlmeIndication )
{
 801a09c:	b580      	push	{r7, lr}
 801a09e:	b084      	sub	sp, #16
 801a0a0:	af00      	add	r7, sp, #0
 801a0a2:	6078      	str	r0, [r7, #4]
    MibRequestConfirm_t mibReq;
#endif /* LORAMAC_CLASSB_ENABLED */

    TVL2( PRINTNOW(); PRINTF("APP> MLMEInd STATUS: %s\r\n", EventInfoStatusStrings[MlmeIndication->Status] );    )

    switch( MlmeIndication->MlmeIndication )
 801a0a4:	687b      	ldr	r3, [r7, #4]
 801a0a6:	781b      	ldrb	r3, [r3, #0]
 801a0a8:	2b06      	cmp	r3, #6
 801a0aa:	d104      	bne.n	801a0b6 <MlmeIndication+0x1a>
    {
        case MLME_SCHEDULE_UPLINK:
        {
            // The MAC signals that we shall provide an uplink as soon as possible
            LoRaMainCallbacks->LORA_TxNeeded( );			
 801a0ac:	4b04      	ldr	r3, [pc, #16]	; (801a0c0 <MlmeIndication+0x24>)
 801a0ae:	681b      	ldr	r3, [r3, #0]
 801a0b0:	69db      	ldr	r3, [r3, #28]
 801a0b2:	4798      	blx	r3
            break;
 801a0b4:	e000      	b.n	801a0b8 <MlmeIndication+0x1c>
            break;

        }
#endif /* LORAMAC_CLASSB_ENABLED */
        default:
            break;
 801a0b6:	46c0      	nop			; (mov r8, r8)
    }
}
 801a0b8:	46c0      	nop			; (mov r8, r8)
 801a0ba:	46bd      	mov	sp, r7
 801a0bc:	b004      	add	sp, #16
 801a0be:	bd80      	pop	{r7, pc}
 801a0c0:	20001344 	.word	0x20001344

0801a0c4 <LORA_Init>:
/**
 *  lora Init
 */
void LORA_Init (LoRaMainCallback_t *callbacks, LoRaParam_t* LoRaParam )
{
 801a0c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a0c6:	46de      	mov	lr, fp
 801a0c8:	4657      	mov	r7, sl
 801a0ca:	464e      	mov	r6, r9
 801a0cc:	4645      	mov	r5, r8
 801a0ce:	b5e0      	push	{r5, r6, r7, lr}
 801a0d0:	b09b      	sub	sp, #108	; 0x6c
 801a0d2:	af0e      	add	r7, sp, #56	; 0x38
 801a0d4:	61f8      	str	r0, [r7, #28]
 801a0d6:	61b9      	str	r1, [r7, #24]



  uint8_t devEui[] = LORAWAN_DEVICE_EUI;
 801a0d8:	2310      	movs	r3, #16
 801a0da:	2218      	movs	r2, #24
 801a0dc:	4694      	mov	ip, r2
 801a0de:	44bc      	add	ip, r7
 801a0e0:	4463      	add	r3, ip
 801a0e2:	4aa5      	ldr	r2, [pc, #660]	; (801a378 <LORA_Init+0x2b4>)
 801a0e4:	ca03      	ldmia	r2!, {r0, r1}
 801a0e6:	c303      	stmia	r3!, {r0, r1}
  uint8_t joinEui[] = LORAWAN_JOIN_EUI;
 801a0e8:	2308      	movs	r3, #8
 801a0ea:	2218      	movs	r2, #24
 801a0ec:	4694      	mov	ip, r2
 801a0ee:	44bc      	add	ip, r7
 801a0f0:	4463      	add	r3, ip
 801a0f2:	4aa2      	ldr	r2, [pc, #648]	; (801a37c <LORA_Init+0x2b8>)
 801a0f4:	ca03      	ldmia	r2!, {r0, r1}
 801a0f6:	c303      	stmia	r3!, {r0, r1}
  
  /* init the Tx Duty Cycle*/
  LoRaParamInit = LoRaParam;
 801a0f8:	4ba1      	ldr	r3, [pc, #644]	; (801a380 <LORA_Init+0x2bc>)
 801a0fa:	69ba      	ldr	r2, [r7, #24]
 801a0fc:	601a      	str	r2, [r3, #0]
  
  /* init the main call backs*/
  LoRaMainCallbacks = callbacks;
 801a0fe:	4ba1      	ldr	r3, [pc, #644]	; (801a384 <LORA_Init+0x2c0>)
 801a100:	69fa      	ldr	r2, [r7, #28]
 801a102:	601a      	str	r2, [r3, #0]
  LoRaMainCallbacks->BoardGetUniqueId( devEui );  
#endif
  
#if( OVER_THE_AIR_ACTIVATION != 0 )

  PPRINTF( "OTAA\n\r"); 
 801a104:	4ba0      	ldr	r3, [pc, #640]	; (801a388 <LORA_Init+0x2c4>)
 801a106:	0018      	movs	r0, r3
 801a108:	f001 f90c 	bl	801b324 <TraceSend>
 801a10c:	1e03      	subs	r3, r0, #0
 801a10e:	d1f9      	bne.n	801a104 <LORA_Init+0x40>
  PPRINTF( "DevEui= %02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X\n\r", HEX8(devEui));
 801a110:	2010      	movs	r0, #16
 801a112:	2518      	movs	r5, #24
 801a114:	197b      	adds	r3, r7, r5
 801a116:	181b      	adds	r3, r3, r0
 801a118:	781b      	ldrb	r3, [r3, #0]
 801a11a:	001e      	movs	r6, r3
 801a11c:	197b      	adds	r3, r7, r5
 801a11e:	181b      	adds	r3, r3, r0
 801a120:	785b      	ldrb	r3, [r3, #1]
 801a122:	469c      	mov	ip, r3
 801a124:	197b      	adds	r3, r7, r5
 801a126:	181b      	adds	r3, r3, r0
 801a128:	789b      	ldrb	r3, [r3, #2]
 801a12a:	4698      	mov	r8, r3
 801a12c:	197b      	adds	r3, r7, r5
 801a12e:	181b      	adds	r3, r3, r0
 801a130:	78db      	ldrb	r3, [r3, #3]
 801a132:	001a      	movs	r2, r3
 801a134:	197b      	adds	r3, r7, r5
 801a136:	181b      	adds	r3, r3, r0
 801a138:	791b      	ldrb	r3, [r3, #4]
 801a13a:	0019      	movs	r1, r3
 801a13c:	197b      	adds	r3, r7, r5
 801a13e:	181b      	adds	r3, r3, r0
 801a140:	795b      	ldrb	r3, [r3, #5]
 801a142:	001c      	movs	r4, r3
 801a144:	197b      	adds	r3, r7, r5
 801a146:	181b      	adds	r3, r3, r0
 801a148:	799b      	ldrb	r3, [r3, #6]
 801a14a:	001d      	movs	r5, r3
 801a14c:	2318      	movs	r3, #24
 801a14e:	18fb      	adds	r3, r7, r3
 801a150:	181b      	adds	r3, r3, r0
 801a152:	79db      	ldrb	r3, [r3, #7]
 801a154:	488d      	ldr	r0, [pc, #564]	; (801a38c <LORA_Init+0x2c8>)
 801a156:	9304      	str	r3, [sp, #16]
 801a158:	9503      	str	r5, [sp, #12]
 801a15a:	9402      	str	r4, [sp, #8]
 801a15c:	9101      	str	r1, [sp, #4]
 801a15e:	9200      	str	r2, [sp, #0]
 801a160:	4643      	mov	r3, r8
 801a162:	4662      	mov	r2, ip
 801a164:	0031      	movs	r1, r6
 801a166:	f001 f8dd 	bl	801b324 <TraceSend>
 801a16a:	1e03      	subs	r3, r0, #0
 801a16c:	d1d0      	bne.n	801a110 <LORA_Init+0x4c>
  PPRINTF( "AppEui= %02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X\n\r", HEX8(joinEui));
 801a16e:	2008      	movs	r0, #8
 801a170:	2518      	movs	r5, #24
 801a172:	197b      	adds	r3, r7, r5
 801a174:	181b      	adds	r3, r3, r0
 801a176:	781b      	ldrb	r3, [r3, #0]
 801a178:	001e      	movs	r6, r3
 801a17a:	197b      	adds	r3, r7, r5
 801a17c:	181b      	adds	r3, r3, r0
 801a17e:	785b      	ldrb	r3, [r3, #1]
 801a180:	469c      	mov	ip, r3
 801a182:	197b      	adds	r3, r7, r5
 801a184:	181b      	adds	r3, r3, r0
 801a186:	789b      	ldrb	r3, [r3, #2]
 801a188:	4698      	mov	r8, r3
 801a18a:	197b      	adds	r3, r7, r5
 801a18c:	181b      	adds	r3, r3, r0
 801a18e:	78db      	ldrb	r3, [r3, #3]
 801a190:	001a      	movs	r2, r3
 801a192:	197b      	adds	r3, r7, r5
 801a194:	181b      	adds	r3, r3, r0
 801a196:	791b      	ldrb	r3, [r3, #4]
 801a198:	0019      	movs	r1, r3
 801a19a:	197b      	adds	r3, r7, r5
 801a19c:	181b      	adds	r3, r3, r0
 801a19e:	795b      	ldrb	r3, [r3, #5]
 801a1a0:	001c      	movs	r4, r3
 801a1a2:	197b      	adds	r3, r7, r5
 801a1a4:	181b      	adds	r3, r3, r0
 801a1a6:	799b      	ldrb	r3, [r3, #6]
 801a1a8:	001d      	movs	r5, r3
 801a1aa:	2318      	movs	r3, #24
 801a1ac:	18fb      	adds	r3, r7, r3
 801a1ae:	181b      	adds	r3, r3, r0
 801a1b0:	79db      	ldrb	r3, [r3, #7]
 801a1b2:	4877      	ldr	r0, [pc, #476]	; (801a390 <LORA_Init+0x2cc>)
 801a1b4:	9304      	str	r3, [sp, #16]
 801a1b6:	9503      	str	r5, [sp, #12]
 801a1b8:	9402      	str	r4, [sp, #8]
 801a1ba:	9101      	str	r1, [sp, #4]
 801a1bc:	9200      	str	r2, [sp, #0]
 801a1be:	4643      	mov	r3, r8
 801a1c0:	4662      	mov	r2, ip
 801a1c2:	0031      	movs	r1, r6
 801a1c4:	f001 f8ae 	bl	801b324 <TraceSend>
 801a1c8:	1e03      	subs	r3, r0, #0
 801a1ca:	d1d0      	bne.n	801a16e <LORA_Init+0xaa>
  PPRINTF( "AppKey= %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X\n\r", HEX16(AppKey));
 801a1cc:	4b71      	ldr	r3, [pc, #452]	; (801a394 <LORA_Init+0x2d0>)
 801a1ce:	781b      	ldrb	r3, [r3, #0]
 801a1d0:	617b      	str	r3, [r7, #20]
 801a1d2:	4b70      	ldr	r3, [pc, #448]	; (801a394 <LORA_Init+0x2d0>)
 801a1d4:	785b      	ldrb	r3, [r3, #1]
 801a1d6:	613b      	str	r3, [r7, #16]
 801a1d8:	4b6e      	ldr	r3, [pc, #440]	; (801a394 <LORA_Init+0x2d0>)
 801a1da:	789b      	ldrb	r3, [r3, #2]
 801a1dc:	60fb      	str	r3, [r7, #12]
 801a1de:	4b6d      	ldr	r3, [pc, #436]	; (801a394 <LORA_Init+0x2d0>)
 801a1e0:	78db      	ldrb	r3, [r3, #3]
 801a1e2:	001d      	movs	r5, r3
 801a1e4:	4b6b      	ldr	r3, [pc, #428]	; (801a394 <LORA_Init+0x2d0>)
 801a1e6:	791b      	ldrb	r3, [r3, #4]
 801a1e8:	001e      	movs	r6, r3
 801a1ea:	4b6a      	ldr	r3, [pc, #424]	; (801a394 <LORA_Init+0x2d0>)
 801a1ec:	795b      	ldrb	r3, [r3, #5]
 801a1ee:	469c      	mov	ip, r3
 801a1f0:	4b68      	ldr	r3, [pc, #416]	; (801a394 <LORA_Init+0x2d0>)
 801a1f2:	799b      	ldrb	r3, [r3, #6]
 801a1f4:	4698      	mov	r8, r3
 801a1f6:	4b67      	ldr	r3, [pc, #412]	; (801a394 <LORA_Init+0x2d0>)
 801a1f8:	79db      	ldrb	r3, [r3, #7]
 801a1fa:	4699      	mov	r9, r3
 801a1fc:	4b65      	ldr	r3, [pc, #404]	; (801a394 <LORA_Init+0x2d0>)
 801a1fe:	7a1b      	ldrb	r3, [r3, #8]
 801a200:	469a      	mov	sl, r3
 801a202:	4b64      	ldr	r3, [pc, #400]	; (801a394 <LORA_Init+0x2d0>)
 801a204:	7a5b      	ldrb	r3, [r3, #9]
 801a206:	469b      	mov	fp, r3
 801a208:	4b62      	ldr	r3, [pc, #392]	; (801a394 <LORA_Init+0x2d0>)
 801a20a:	7a9b      	ldrb	r3, [r3, #10]
 801a20c:	60bb      	str	r3, [r7, #8]
 801a20e:	4b61      	ldr	r3, [pc, #388]	; (801a394 <LORA_Init+0x2d0>)
 801a210:	7adb      	ldrb	r3, [r3, #11]
 801a212:	607b      	str	r3, [r7, #4]
 801a214:	4b5f      	ldr	r3, [pc, #380]	; (801a394 <LORA_Init+0x2d0>)
 801a216:	7b1b      	ldrb	r3, [r3, #12]
 801a218:	001c      	movs	r4, r3
 801a21a:	4b5e      	ldr	r3, [pc, #376]	; (801a394 <LORA_Init+0x2d0>)
 801a21c:	7b5b      	ldrb	r3, [r3, #13]
 801a21e:	0019      	movs	r1, r3
 801a220:	4b5c      	ldr	r3, [pc, #368]	; (801a394 <LORA_Init+0x2d0>)
 801a222:	7b9b      	ldrb	r3, [r3, #14]
 801a224:	001a      	movs	r2, r3
 801a226:	4b5b      	ldr	r3, [pc, #364]	; (801a394 <LORA_Init+0x2d0>)
 801a228:	7bdb      	ldrb	r3, [r3, #15]
 801a22a:	485b      	ldr	r0, [pc, #364]	; (801a398 <LORA_Init+0x2d4>)
 801a22c:	930c      	str	r3, [sp, #48]	; 0x30
 801a22e:	920b      	str	r2, [sp, #44]	; 0x2c
 801a230:	910a      	str	r1, [sp, #40]	; 0x28
 801a232:	9409      	str	r4, [sp, #36]	; 0x24
 801a234:	687c      	ldr	r4, [r7, #4]
 801a236:	9408      	str	r4, [sp, #32]
 801a238:	68bc      	ldr	r4, [r7, #8]
 801a23a:	9407      	str	r4, [sp, #28]
 801a23c:	465c      	mov	r4, fp
 801a23e:	9406      	str	r4, [sp, #24]
 801a240:	4654      	mov	r4, sl
 801a242:	9405      	str	r4, [sp, #20]
 801a244:	464c      	mov	r4, r9
 801a246:	9404      	str	r4, [sp, #16]
 801a248:	4644      	mov	r4, r8
 801a24a:	9403      	str	r4, [sp, #12]
 801a24c:	4664      	mov	r4, ip
 801a24e:	9402      	str	r4, [sp, #8]
 801a250:	9601      	str	r6, [sp, #4]
 801a252:	9500      	str	r5, [sp, #0]
 801a254:	68fb      	ldr	r3, [r7, #12]
 801a256:	693a      	ldr	r2, [r7, #16]
 801a258:	6979      	ldr	r1, [r7, #20]
 801a25a:	f001 f863 	bl	801b324 <TraceSend>
 801a25e:	1e03      	subs	r3, r0, #0
 801a260:	d1b4      	bne.n	801a1cc <LORA_Init+0x108>
  PPRINTF( "DevEui= %02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X\n\r", HEX8(devEui));
  PPRINTF( "DevAdd=  %08X\n\r", DevAddr) ;
  PPRINTF( "NwkSKey= %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X\n\r", HEX16(NwkSEncKey));
  PPRINTF( "AppSKey= %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X\n\r", HEX16(AppSKey));
#endif
  LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 801a262:	4b4e      	ldr	r3, [pc, #312]	; (801a39c <LORA_Init+0x2d8>)
 801a264:	4a4e      	ldr	r2, [pc, #312]	; (801a3a0 <LORA_Init+0x2dc>)
 801a266:	601a      	str	r2, [r3, #0]
  LoRaMacPrimitives.MacMcpsIndication = McpsIndication;
 801a268:	4b4c      	ldr	r3, [pc, #304]	; (801a39c <LORA_Init+0x2d8>)
 801a26a:	4a4e      	ldr	r2, [pc, #312]	; (801a3a4 <LORA_Init+0x2e0>)
 801a26c:	605a      	str	r2, [r3, #4]
  LoRaMacPrimitives.MacMlmeConfirm = MlmeConfirm;
 801a26e:	4b4b      	ldr	r3, [pc, #300]	; (801a39c <LORA_Init+0x2d8>)
 801a270:	4a4d      	ldr	r2, [pc, #308]	; (801a3a8 <LORA_Init+0x2e4>)
 801a272:	609a      	str	r2, [r3, #8]
  LoRaMacPrimitives.MacMlmeIndication = MlmeIndication;
 801a274:	4b49      	ldr	r3, [pc, #292]	; (801a39c <LORA_Init+0x2d8>)
 801a276:	4a4d      	ldr	r2, [pc, #308]	; (801a3ac <LORA_Init+0x2e8>)
 801a278:	60da      	str	r2, [r3, #12]
  LoRaMacCallbacks.GetBatteryLevel = LoRaMainCallbacks->BoardGetBatteryLevel;
 801a27a:	4b42      	ldr	r3, [pc, #264]	; (801a384 <LORA_Init+0x2c0>)
 801a27c:	681b      	ldr	r3, [r3, #0]
 801a27e:	681a      	ldr	r2, [r3, #0]
 801a280:	4b4b      	ldr	r3, [pc, #300]	; (801a3b0 <LORA_Init+0x2ec>)
 801a282:	601a      	str	r2, [r3, #0]
  LoRaMacCallbacks.GetTemperatureLevel = LoRaMainCallbacks->BoardGetTemperatureLevel;
 801a284:	4b3f      	ldr	r3, [pc, #252]	; (801a384 <LORA_Init+0x2c0>)
 801a286:	681b      	ldr	r3, [r3, #0]
 801a288:	685a      	ldr	r2, [r3, #4]
 801a28a:	4b49      	ldr	r3, [pc, #292]	; (801a3b0 <LORA_Init+0x2ec>)
 801a28c:	605a      	str	r2, [r3, #4]
  LoRaMacCallbacks.MacProcessNotify = LoRaMainCallbacks->MacProcessNotify;
 801a28e:	4b3d      	ldr	r3, [pc, #244]	; (801a384 <LORA_Init+0x2c0>)
 801a290:	681b      	ldr	r3, [r3, #0]
 801a292:	6a1a      	ldr	r2, [r3, #32]
 801a294:	4b46      	ldr	r3, [pc, #280]	; (801a3b0 <LORA_Init+0x2ec>)
 801a296:	60da      	str	r2, [r3, #12]
#elif defined( REGION_EU433 )
  LoRaMacInitialization( &LoRaMacPrimitives, &LoRaMacCallbacks, LORAMAC_REGION_EU433 );
#elif defined( REGION_IN865 )
  LoRaMacInitialization( &LoRaMacPrimitives, &LoRaMacCallbacks, LORAMAC_REGION_IN865 );
#elif defined( REGION_EU868 )
  LoRaMacInitialization( &LoRaMacPrimitives, &LoRaMacCallbacks, LORAMAC_REGION_EU868 );
 801a298:	4945      	ldr	r1, [pc, #276]	; (801a3b0 <LORA_Init+0x2ec>)
 801a29a:	4b40      	ldr	r3, [pc, #256]	; (801a39c <LORA_Init+0x2d8>)
 801a29c:	2205      	movs	r2, #5
 801a29e:	0018      	movs	r0, r3
 801a2a0:	f7f9 f806 	bl	80132b0 <LoRaMacInitialization>
  mibReq.Param.ChannelsDefaultMask = channelMask;
  LoRaMacMibSetRequestConfirm( &mibReq );
#endif
#endif

  mibReq.Type = MIB_DEV_EUI;
 801a2a4:	4b43      	ldr	r3, [pc, #268]	; (801a3b4 <LORA_Init+0x2f0>)
 801a2a6:	2202      	movs	r2, #2
 801a2a8:	701a      	strb	r2, [r3, #0]
  mibReq.Param.DevEui = devEui;
 801a2aa:	4b42      	ldr	r3, [pc, #264]	; (801a3b4 <LORA_Init+0x2f0>)
 801a2ac:	2210      	movs	r2, #16
 801a2ae:	2118      	movs	r1, #24
 801a2b0:	468c      	mov	ip, r1
 801a2b2:	44bc      	add	ip, r7
 801a2b4:	4462      	add	r2, ip
 801a2b6:	605a      	str	r2, [r3, #4]
  LoRaMacMibSetRequestConfirm( &mibReq );
 801a2b8:	4b3e      	ldr	r3, [pc, #248]	; (801a3b4 <LORA_Init+0x2f0>)
 801a2ba:	0018      	movs	r0, r3
 801a2bc:	f7f9 fdb8 	bl	8013e30 <LoRaMacMibSetRequestConfirm>
  
  mibReq.Type = MIB_JOIN_EUI;
 801a2c0:	4b3c      	ldr	r3, [pc, #240]	; (801a3b4 <LORA_Init+0x2f0>)
 801a2c2:	2203      	movs	r2, #3
 801a2c4:	701a      	strb	r2, [r3, #0]
  mibReq.Param.JoinEui = joinEui;
 801a2c6:	4b3b      	ldr	r3, [pc, #236]	; (801a3b4 <LORA_Init+0x2f0>)
 801a2c8:	2208      	movs	r2, #8
 801a2ca:	2118      	movs	r1, #24
 801a2cc:	468c      	mov	ip, r1
 801a2ce:	44bc      	add	ip, r7
 801a2d0:	4462      	add	r2, ip
 801a2d2:	605a      	str	r2, [r3, #4]
  LoRaMacMibSetRequestConfirm( &mibReq );
 801a2d4:	4b37      	ldr	r3, [pc, #220]	; (801a3b4 <LORA_Init+0x2f0>)
 801a2d6:	0018      	movs	r0, r3
 801a2d8:	f7f9 fdaa 	bl	8013e30 <LoRaMacMibSetRequestConfirm>

  mibReq.Type = MIB_ADR;
 801a2dc:	4b35      	ldr	r3, [pc, #212]	; (801a3b4 <LORA_Init+0x2f0>)
 801a2de:	2204      	movs	r2, #4
 801a2e0:	701a      	strb	r2, [r3, #0]
  mibReq.Param.AdrEnable = LoRaParamInit->AdrEnable;
 801a2e2:	4b27      	ldr	r3, [pc, #156]	; (801a380 <LORA_Init+0x2bc>)
 801a2e4:	681b      	ldr	r3, [r3, #0]
 801a2e6:	781a      	ldrb	r2, [r3, #0]
 801a2e8:	4b32      	ldr	r3, [pc, #200]	; (801a3b4 <LORA_Init+0x2f0>)
 801a2ea:	711a      	strb	r2, [r3, #4]
  LoRaMacMibSetRequestConfirm( &mibReq );
 801a2ec:	4b31      	ldr	r3, [pc, #196]	; (801a3b4 <LORA_Init+0x2f0>)
 801a2ee:	0018      	movs	r0, r3
 801a2f0:	f7f9 fd9e 	bl	8013e30 <LoRaMacMibSetRequestConfirm>

  mibReq.Type = MIB_PUBLIC_NETWORK;
 801a2f4:	4b2f      	ldr	r3, [pc, #188]	; (801a3b4 <LORA_Init+0x2f0>)
 801a2f6:	221d      	movs	r2, #29
 801a2f8:	701a      	strb	r2, [r3, #0]
  mibReq.Param.EnablePublicNetwork = LoRaParamInit->EnablePublicNetwork;
 801a2fa:	4b21      	ldr	r3, [pc, #132]	; (801a380 <LORA_Init+0x2bc>)
 801a2fc:	681b      	ldr	r3, [r3, #0]
 801a2fe:	789a      	ldrb	r2, [r3, #2]
 801a300:	4b2c      	ldr	r3, [pc, #176]	; (801a3b4 <LORA_Init+0x2f0>)
 801a302:	711a      	strb	r2, [r3, #4]
  LoRaMacMibSetRequestConfirm( &mibReq );
 801a304:	4b2b      	ldr	r3, [pc, #172]	; (801a3b4 <LORA_Init+0x2f0>)
 801a306:	0018      	movs	r0, r3
 801a308:	f7f9 fd92 	bl	8013e30 <LoRaMacMibSetRequestConfirm>
  
  mibReq.Type = MIB_APP_KEY;
 801a30c:	4b29      	ldr	r3, [pc, #164]	; (801a3b4 <LORA_Init+0x2f0>)
 801a30e:	2208      	movs	r2, #8
 801a310:	701a      	strb	r2, [r3, #0]
  mibReq.Param.AppKey = AppKey;
 801a312:	4b28      	ldr	r3, [pc, #160]	; (801a3b4 <LORA_Init+0x2f0>)
 801a314:	4a1f      	ldr	r2, [pc, #124]	; (801a394 <LORA_Init+0x2d0>)
 801a316:	605a      	str	r2, [r3, #4]
  LoRaMacMibSetRequestConfirm( &mibReq );
 801a318:	4b26      	ldr	r3, [pc, #152]	; (801a3b4 <LORA_Init+0x2f0>)
 801a31a:	0018      	movs	r0, r3
 801a31c:	f7f9 fd88 	bl	8013e30 <LoRaMacMibSetRequestConfirm>

  mibReq.Type = MIB_NWK_KEY;
 801a320:	4b24      	ldr	r3, [pc, #144]	; (801a3b4 <LORA_Init+0x2f0>)
 801a322:	2209      	movs	r2, #9
 801a324:	701a      	strb	r2, [r3, #0]
  mibReq.Param.NwkKey = NwkKey;
 801a326:	4b23      	ldr	r3, [pc, #140]	; (801a3b4 <LORA_Init+0x2f0>)
 801a328:	4a23      	ldr	r2, [pc, #140]	; (801a3b8 <LORA_Init+0x2f4>)
 801a32a:	605a      	str	r2, [r3, #4]
  LoRaMacMibSetRequestConfirm( &mibReq );
 801a32c:	4b21      	ldr	r3, [pc, #132]	; (801a3b4 <LORA_Init+0x2f0>)
 801a32e:	0018      	movs	r0, r3
 801a330:	f7f9 fd7e 	bl	8013e30 <LoRaMacMibSetRequestConfirm>
                      
  mibReq.Type = MIB_DEVICE_CLASS;
 801a334:	4b1f      	ldr	r3, [pc, #124]	; (801a3b4 <LORA_Init+0x2f0>)
 801a336:	2200      	movs	r2, #0
 801a338:	701a      	strb	r2, [r3, #0]
  mibReq.Param.Class= CLASS_A;
 801a33a:	4b1e      	ldr	r3, [pc, #120]	; (801a3b4 <LORA_Init+0x2f0>)
 801a33c:	2200      	movs	r2, #0
 801a33e:	711a      	strb	r2, [r3, #4]
  LoRaMacMibSetRequestConfirm( &mibReq );
 801a340:	4b1c      	ldr	r3, [pc, #112]	; (801a3b4 <LORA_Init+0x2f0>)
 801a342:	0018      	movs	r0, r3
 801a344:	f7f9 fd74 	bl	8013e30 <LoRaMacMibSetRequestConfirm>

#if defined( REGION_EU868 ) || defined( REGION_RU864 ) || defined( REGION_CN779 ) || defined( REGION_EU433 )
  LoRaMacTestSetDutyCycleOn( LORAWAN_DUTYCYCLE_ON );
 801a348:	2001      	movs	r0, #1
 801a34a:	f7fa fcfd 	bl	8014d48 <LoRaMacTestSetDutyCycleOn>
#endif
      
  mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 801a34e:	4b19      	ldr	r3, [pc, #100]	; (801a3b4 <LORA_Init+0x2f0>)
 801a350:	2230      	movs	r2, #48	; 0x30
 801a352:	701a      	strb	r2, [r3, #0]
  mibReq.Param.SystemMaxRxError = 20;
 801a354:	4b17      	ldr	r3, [pc, #92]	; (801a3b4 <LORA_Init+0x2f0>)
 801a356:	2214      	movs	r2, #20
 801a358:	605a      	str	r2, [r3, #4]
  LoRaMacMibSetRequestConfirm( &mibReq );
 801a35a:	4b16      	ldr	r3, [pc, #88]	; (801a3b4 <LORA_Init+0x2f0>)
 801a35c:	0018      	movs	r0, r3
 801a35e:	f7f9 fd67 	bl	8013e30 <LoRaMacMibSetRequestConfirm>

  /*set Mac statein Idle*/
  LoRaMacStart( );
 801a362:	f7f9 fb4d 	bl	8013a00 <LoRaMacStart>
}
 801a366:	46c0      	nop			; (mov r8, r8)
 801a368:	46bd      	mov	sp, r7
 801a36a:	b00d      	add	sp, #52	; 0x34
 801a36c:	bcf0      	pop	{r4, r5, r6, r7}
 801a36e:	46bb      	mov	fp, r7
 801a370:	46b2      	mov	sl, r6
 801a372:	46a9      	mov	r9, r5
 801a374:	46a0      	mov	r8, r4
 801a376:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801a378:	0801fae4 	.word	0x0801fae4
 801a37c:	0801faec 	.word	0x0801faec
 801a380:	20001300 	.word	0x20001300
 801a384:	20001344 	.word	0x20001344
 801a388:	0801fa18 	.word	0x0801fa18
 801a38c:	0801fa20 	.word	0x0801fa20
 801a390:	0801fa54 	.word	0x0801fa54
 801a394:	200001a0 	.word	0x200001a0
 801a398:	0801fa88 	.word	0x0801fa88
 801a39c:	20001304 	.word	0x20001304
 801a3a0:	08019f45 	.word	0x08019f45
 801a3a4:	08019f8d 	.word	0x08019f8d
 801a3a8:	0801a049 	.word	0x0801a049
 801a3ac:	0801a09d 	.word	0x0801a09d
 801a3b0:	20001314 	.word	0x20001314
 801a3b4:	20001324 	.word	0x20001324
 801a3b8:	200001b0 	.word	0x200001b0

0801a3bc <LORA_Join>:


void LORA_Join( void)
{
 801a3bc:	b580      	push	{r7, lr}
 801a3be:	b084      	sub	sp, #16
 801a3c0:	af00      	add	r7, sp, #0
    MlmeReq_t mlmeReq;
  
    mlmeReq.Type = MLME_JOIN;
 801a3c2:	003b      	movs	r3, r7
 801a3c4:	2200      	movs	r2, #0
 801a3c6:	701a      	strb	r2, [r3, #0]
    mlmeReq.Req.Join.Datarate = LoRaParamInit->TxDatarate;
 801a3c8:	4b09      	ldr	r3, [pc, #36]	; (801a3f0 <LORA_Join+0x34>)
 801a3ca:	681b      	ldr	r3, [r3, #0]
 801a3cc:	785b      	ldrb	r3, [r3, #1]
 801a3ce:	b25b      	sxtb	r3, r3
 801a3d0:	b2da      	uxtb	r2, r3
 801a3d2:	003b      	movs	r3, r7
 801a3d4:	711a      	strb	r2, [r3, #4]
  
    JoinParameters = mlmeReq.Req.Join;
 801a3d6:	4b07      	ldr	r3, [pc, #28]	; (801a3f4 <LORA_Join+0x38>)
 801a3d8:	003a      	movs	r2, r7
 801a3da:	7912      	ldrb	r2, [r2, #4]
 801a3dc:	701a      	strb	r2, [r3, #0]

#if( OVER_THE_AIR_ACTIVATION != 0 )
    LoRaMacMlmeRequest( &mlmeReq );
 801a3de:	003b      	movs	r3, r7
 801a3e0:	0018      	movs	r0, r3
 801a3e2:	f7fa fa19 	bl	8014818 <LoRaMacMlmeRequest>
    mibReq.Param.AbpLrWanVersion = abpLrWanVersion;
    LoRaMacMibSetRequestConfirm( &mibReq );

    LoRaMainCallbacks->LORA_HasJoined();
#endif
}
 801a3e6:	46c0      	nop			; (mov r8, r8)
 801a3e8:	46bd      	mov	sp, r7
 801a3ea:	b004      	add	sp, #16
 801a3ec:	bd80      	pop	{r7, pc}
 801a3ee:	46c0      	nop			; (mov r8, r8)
 801a3f0:	20001300 	.word	0x20001300
 801a3f4:	200012fc 	.word	0x200012fc

0801a3f8 <LORA_JoinStatus>:

LoraFlagStatus LORA_JoinStatus( void)
{
 801a3f8:	b580      	push	{r7, lr}
 801a3fa:	b088      	sub	sp, #32
 801a3fc:	af00      	add	r7, sp, #0
  MibRequestConfirm_t mibReq;

  mibReq.Type = MIB_NETWORK_ACTIVATION;
 801a3fe:	003b      	movs	r3, r7
 801a400:	2201      	movs	r2, #1
 801a402:	701a      	strb	r2, [r3, #0]
  
  LoRaMacMibGetRequestConfirm( &mibReq );
 801a404:	003b      	movs	r3, r7
 801a406:	0018      	movs	r0, r3
 801a408:	f7f9 fbb6 	bl	8013b78 <LoRaMacMibGetRequestConfirm>

  if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 801a40c:	003b      	movs	r3, r7
 801a40e:	791b      	ldrb	r3, [r3, #4]
 801a410:	2b00      	cmp	r3, #0
 801a412:	d101      	bne.n	801a418 <LORA_JoinStatus+0x20>
  {
    return LORA_RESET;
 801a414:	2300      	movs	r3, #0
 801a416:	e000      	b.n	801a41a <LORA_JoinStatus+0x22>
  }
  else
  {
    return LORA_SET;
 801a418:	2301      	movs	r3, #1
  }
}
 801a41a:	0018      	movs	r0, r3
 801a41c:	46bd      	mov	sp, r7
 801a41e:	b008      	add	sp, #32
 801a420:	bd80      	pop	{r7, pc}
	...

0801a424 <LORA_send>:



bool LORA_send(lora_AppData_t* AppData, LoraConfirm_t IsTxConfirmed)
{
 801a424:	b580      	push	{r7, lr}
 801a426:	b088      	sub	sp, #32
 801a428:	af00      	add	r7, sp, #0
 801a42a:	6078      	str	r0, [r7, #4]
 801a42c:	000a      	movs	r2, r1
 801a42e:	1cfb      	adds	r3, r7, #3
 801a430:	701a      	strb	r2, [r3, #0]
    McpsReq_t mcpsReq;
    LoRaMacTxInfo_t txInfo;
  
    /*if certification test are on going, application data is not sent*/
    if (certif_running() == true)
 801a432:	f7ff fb37 	bl	8019aa4 <certif_running>
 801a436:	1e03      	subs	r3, r0, #0
 801a438:	d001      	beq.n	801a43e <LORA_send+0x1a>
    {
      return false;
 801a43a:	2300      	movs	r3, #0
 801a43c:	e05a      	b.n	801a4f4 <LORA_send+0xd0>
    }
    
    if( LoRaMacQueryTxPossible( AppData->BuffSize, &txInfo ) != LORAMAC_STATUS_OK )
 801a43e:	687b      	ldr	r3, [r7, #4]
 801a440:	791b      	ldrb	r3, [r3, #4]
 801a442:	220c      	movs	r2, #12
 801a444:	18ba      	adds	r2, r7, r2
 801a446:	0011      	movs	r1, r2
 801a448:	0018      	movs	r0, r3
 801a44a:	f7f9 fae7 	bl	8013a1c <LoRaMacQueryTxPossible>
 801a44e:	1e03      	subs	r3, r0, #0
 801a450:	d010      	beq.n	801a474 <LORA_send+0x50>
    {
        // Send empty frame in order to flush MAC commands
        mcpsReq.Type = MCPS_UNCONFIRMED;
 801a452:	2110      	movs	r1, #16
 801a454:	187b      	adds	r3, r7, r1
 801a456:	2200      	movs	r2, #0
 801a458:	701a      	strb	r2, [r3, #0]
        mcpsReq.Req.Unconfirmed.fBuffer = NULL;
 801a45a:	187b      	adds	r3, r7, r1
 801a45c:	2200      	movs	r2, #0
 801a45e:	609a      	str	r2, [r3, #8]
        mcpsReq.Req.Unconfirmed.fBufferSize = 0;
 801a460:	187b      	adds	r3, r7, r1
 801a462:	2200      	movs	r2, #0
 801a464:	819a      	strh	r2, [r3, #12]
        mcpsReq.Req.Unconfirmed.Datarate = LoRaParamInit->TxDatarate;
 801a466:	4b25      	ldr	r3, [pc, #148]	; (801a4fc <LORA_send+0xd8>)
 801a468:	681b      	ldr	r3, [r3, #0]
 801a46a:	2201      	movs	r2, #1
 801a46c:	569a      	ldrsb	r2, [r3, r2]
 801a46e:	187b      	adds	r3, r7, r1
 801a470:	739a      	strb	r2, [r3, #14]
 801a472:	e035      	b.n	801a4e0 <LORA_send+0xbc>
    }
    else
    {
        if( IsTxConfirmed == LORAWAN_UNCONFIRMED_MSG )
 801a474:	1cfb      	adds	r3, r7, #3
 801a476:	781b      	ldrb	r3, [r3, #0]
 801a478:	2b00      	cmp	r3, #0
 801a47a:	d117      	bne.n	801a4ac <LORA_send+0x88>
        {
            mcpsReq.Type = MCPS_UNCONFIRMED;
 801a47c:	2110      	movs	r1, #16
 801a47e:	187b      	adds	r3, r7, r1
 801a480:	2200      	movs	r2, #0
 801a482:	701a      	strb	r2, [r3, #0]
            mcpsReq.Req.Unconfirmed.fPort = AppData->Port;
 801a484:	687b      	ldr	r3, [r7, #4]
 801a486:	795a      	ldrb	r2, [r3, #5]
 801a488:	187b      	adds	r3, r7, r1
 801a48a:	711a      	strb	r2, [r3, #4]
            mcpsReq.Req.Unconfirmed.fBufferSize = AppData->BuffSize;
 801a48c:	687b      	ldr	r3, [r7, #4]
 801a48e:	791b      	ldrb	r3, [r3, #4]
 801a490:	b29a      	uxth	r2, r3
 801a492:	187b      	adds	r3, r7, r1
 801a494:	819a      	strh	r2, [r3, #12]
            mcpsReq.Req.Unconfirmed.fBuffer = AppData->Buff;
 801a496:	687b      	ldr	r3, [r7, #4]
 801a498:	681a      	ldr	r2, [r3, #0]
 801a49a:	187b      	adds	r3, r7, r1
 801a49c:	609a      	str	r2, [r3, #8]
            mcpsReq.Req.Unconfirmed.Datarate = LoRaParamInit->TxDatarate;
 801a49e:	4b17      	ldr	r3, [pc, #92]	; (801a4fc <LORA_send+0xd8>)
 801a4a0:	681b      	ldr	r3, [r3, #0]
 801a4a2:	2201      	movs	r2, #1
 801a4a4:	569a      	ldrsb	r2, [r3, r2]
 801a4a6:	187b      	adds	r3, r7, r1
 801a4a8:	739a      	strb	r2, [r3, #14]
 801a4aa:	e019      	b.n	801a4e0 <LORA_send+0xbc>
        }
        else
        {
            mcpsReq.Type = MCPS_CONFIRMED;
 801a4ac:	2110      	movs	r1, #16
 801a4ae:	187b      	adds	r3, r7, r1
 801a4b0:	2201      	movs	r2, #1
 801a4b2:	701a      	strb	r2, [r3, #0]
            mcpsReq.Req.Confirmed.fPort = AppData->Port;
 801a4b4:	687b      	ldr	r3, [r7, #4]
 801a4b6:	795a      	ldrb	r2, [r3, #5]
 801a4b8:	187b      	adds	r3, r7, r1
 801a4ba:	711a      	strb	r2, [r3, #4]
            mcpsReq.Req.Confirmed.fBufferSize = AppData->BuffSize;
 801a4bc:	687b      	ldr	r3, [r7, #4]
 801a4be:	791b      	ldrb	r3, [r3, #4]
 801a4c0:	b29a      	uxth	r2, r3
 801a4c2:	187b      	adds	r3, r7, r1
 801a4c4:	819a      	strh	r2, [r3, #12]
            mcpsReq.Req.Confirmed.fBuffer = AppData->Buff;
 801a4c6:	687b      	ldr	r3, [r7, #4]
 801a4c8:	681a      	ldr	r2, [r3, #0]
 801a4ca:	187b      	adds	r3, r7, r1
 801a4cc:	609a      	str	r2, [r3, #8]
            mcpsReq.Req.Confirmed.NbTrials = 8;
 801a4ce:	187b      	adds	r3, r7, r1
 801a4d0:	2208      	movs	r2, #8
 801a4d2:	73da      	strb	r2, [r3, #15]
            mcpsReq.Req.Confirmed.Datarate = LoRaParamInit->TxDatarate;
 801a4d4:	4b09      	ldr	r3, [pc, #36]	; (801a4fc <LORA_send+0xd8>)
 801a4d6:	681b      	ldr	r3, [r3, #0]
 801a4d8:	2201      	movs	r2, #1
 801a4da:	569a      	ldrsb	r2, [r3, r2]
 801a4dc:	187b      	adds	r3, r7, r1
 801a4de:	739a      	strb	r2, [r3, #14]
        }
    }
    if( LoRaMacMcpsRequest( &mcpsReq ) == LORAMAC_STATUS_OK )
 801a4e0:	2310      	movs	r3, #16
 801a4e2:	18fb      	adds	r3, r7, r3
 801a4e4:	0018      	movs	r0, r3
 801a4e6:	f7fa fae9 	bl	8014abc <LoRaMacMcpsRequest>
 801a4ea:	1e03      	subs	r3, r0, #0
 801a4ec:	d101      	bne.n	801a4f2 <LORA_send+0xce>
    {
        return false;
 801a4ee:	2300      	movs	r3, #0
 801a4f0:	e000      	b.n	801a4f4 <LORA_send+0xd0>
    }
    return true;
 801a4f2:	2301      	movs	r3, #1
}  
 801a4f4:	0018      	movs	r0, r3
 801a4f6:	46bd      	mov	sp, r7
 801a4f8:	b008      	add	sp, #32
 801a4fa:	bd80      	pop	{r7, pc}
 801a4fc:	20001300 	.word	0x20001300

0801a500 <LORA_RequestClass>:
  }
}
#endif /* LORAMAC_CLASSB_ENABLED */

LoraErrorStatus LORA_RequestClass( DeviceClass_t newClass )
{
 801a500:	b590      	push	{r4, r7, lr}
 801a502:	b08d      	sub	sp, #52	; 0x34
 801a504:	af00      	add	r7, sp, #0
 801a506:	0002      	movs	r2, r0
 801a508:	1dfb      	adds	r3, r7, #7
 801a50a:	701a      	strb	r2, [r3, #0]
  LoraErrorStatus Errorstatus = LORA_SUCCESS;
 801a50c:	232f      	movs	r3, #47	; 0x2f
 801a50e:	18fb      	adds	r3, r7, r3
 801a510:	2200      	movs	r2, #0
 801a512:	701a      	strb	r2, [r3, #0]
  MibRequestConfirm_t mibReq;
  DeviceClass_t currentClass;
  
  mibReq.Type = MIB_DEVICE_CLASS;
 801a514:	240c      	movs	r4, #12
 801a516:	193b      	adds	r3, r7, r4
 801a518:	2200      	movs	r2, #0
 801a51a:	701a      	strb	r2, [r3, #0]
  LoRaMacMibGetRequestConfirm( &mibReq );
 801a51c:	193b      	adds	r3, r7, r4
 801a51e:	0018      	movs	r0, r3
 801a520:	f7f9 fb2a 	bl	8013b78 <LoRaMacMibGetRequestConfirm>
  
  currentClass = mibReq.Param.Class;
 801a524:	212e      	movs	r1, #46	; 0x2e
 801a526:	187b      	adds	r3, r7, r1
 801a528:	193a      	adds	r2, r7, r4
 801a52a:	7912      	ldrb	r2, [r2, #4]
 801a52c:	701a      	strb	r2, [r3, #0]
  /*attempt to swicth only if class update*/
  if (currentClass != newClass)
 801a52e:	187a      	adds	r2, r7, r1
 801a530:	1dfb      	adds	r3, r7, #7
 801a532:	7812      	ldrb	r2, [r2, #0]
 801a534:	781b      	ldrb	r3, [r3, #0]
 801a536:	429a      	cmp	r2, r3
 801a538:	d041      	beq.n	801a5be <LORA_RequestClass+0xbe>
  {
    switch (newClass)
 801a53a:	1dfb      	adds	r3, r7, #7
 801a53c:	781b      	ldrb	r3, [r3, #0]
 801a53e:	2b02      	cmp	r3, #2
 801a540:	d01f      	beq.n	801a582 <LORA_RequestClass+0x82>
 801a542:	dc3e      	bgt.n	801a5c2 <LORA_RequestClass+0xc2>
 801a544:	2b00      	cmp	r3, #0
 801a546:	d002      	beq.n	801a54e <LORA_RequestClass+0x4e>
 801a548:	2b01      	cmp	r3, #1
 801a54a:	d015      	beq.n	801a578 <LORA_RequestClass+0x78>
            Errorstatus = LORA_ERROR;
        }
        break;
      }
      default:
        break;
 801a54c:	e039      	b.n	801a5c2 <LORA_RequestClass+0xc2>
        mibReq.Param.Class = CLASS_A;
 801a54e:	210c      	movs	r1, #12
 801a550:	187b      	adds	r3, r7, r1
 801a552:	2200      	movs	r2, #0
 801a554:	711a      	strb	r2, [r3, #4]
        if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 801a556:	187b      	adds	r3, r7, r1
 801a558:	0018      	movs	r0, r3
 801a55a:	f7f9 fc69 	bl	8013e30 <LoRaMacMibSetRequestConfirm>
 801a55e:	1e03      	subs	r3, r0, #0
 801a560:	d105      	bne.n	801a56e <LORA_RequestClass+0x6e>
          LoRaMainCallbacks->LORA_ConfirmClass(CLASS_A);
 801a562:	4b1c      	ldr	r3, [pc, #112]	; (801a5d4 <LORA_RequestClass+0xd4>)
 801a564:	681b      	ldr	r3, [r3, #0]
 801a566:	699b      	ldr	r3, [r3, #24]
 801a568:	2000      	movs	r0, #0
 801a56a:	4798      	blx	r3
        break;
 801a56c:	e02a      	b.n	801a5c4 <LORA_RequestClass+0xc4>
          Errorstatus = LORA_ERROR;
 801a56e:	232f      	movs	r3, #47	; 0x2f
 801a570:	18fb      	adds	r3, r7, r3
 801a572:	22ff      	movs	r2, #255	; 0xff
 801a574:	701a      	strb	r2, [r3, #0]
        break;
 801a576:	e025      	b.n	801a5c4 <LORA_RequestClass+0xc4>
        PRINTF( "warning: LORAMAC_CLASSB_ENABLED has not been defined at compilation\n\r");
 801a578:	4b17      	ldr	r3, [pc, #92]	; (801a5d8 <LORA_RequestClass+0xd8>)
 801a57a:	0018      	movs	r0, r3
 801a57c:	f000 fed2 	bl	801b324 <TraceSend>
        break;
 801a580:	e020      	b.n	801a5c4 <LORA_RequestClass+0xc4>
        if (currentClass != CLASS_A)
 801a582:	232e      	movs	r3, #46	; 0x2e
 801a584:	18fb      	adds	r3, r7, r3
 801a586:	781b      	ldrb	r3, [r3, #0]
 801a588:	2b00      	cmp	r3, #0
 801a58a:	d003      	beq.n	801a594 <LORA_RequestClass+0x94>
          Errorstatus = LORA_ERROR;
 801a58c:	232f      	movs	r3, #47	; 0x2f
 801a58e:	18fb      	adds	r3, r7, r3
 801a590:	22ff      	movs	r2, #255	; 0xff
 801a592:	701a      	strb	r2, [r3, #0]
        mibReq.Param.Class = CLASS_C;
 801a594:	210c      	movs	r1, #12
 801a596:	187b      	adds	r3, r7, r1
 801a598:	2202      	movs	r2, #2
 801a59a:	711a      	strb	r2, [r3, #4]
        if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 801a59c:	187b      	adds	r3, r7, r1
 801a59e:	0018      	movs	r0, r3
 801a5a0:	f7f9 fc46 	bl	8013e30 <LoRaMacMibSetRequestConfirm>
 801a5a4:	1e03      	subs	r3, r0, #0
 801a5a6:	d105      	bne.n	801a5b4 <LORA_RequestClass+0xb4>
          LoRaMainCallbacks->LORA_ConfirmClass(CLASS_C);
 801a5a8:	4b0a      	ldr	r3, [pc, #40]	; (801a5d4 <LORA_RequestClass+0xd4>)
 801a5aa:	681b      	ldr	r3, [r3, #0]
 801a5ac:	699b      	ldr	r3, [r3, #24]
 801a5ae:	2002      	movs	r0, #2
 801a5b0:	4798      	blx	r3
        break;
 801a5b2:	e007      	b.n	801a5c4 <LORA_RequestClass+0xc4>
            Errorstatus = LORA_ERROR;
 801a5b4:	232f      	movs	r3, #47	; 0x2f
 801a5b6:	18fb      	adds	r3, r7, r3
 801a5b8:	22ff      	movs	r2, #255	; 0xff
 801a5ba:	701a      	strb	r2, [r3, #0]
        break;
 801a5bc:	e002      	b.n	801a5c4 <LORA_RequestClass+0xc4>
    } 
  }
 801a5be:	46c0      	nop			; (mov r8, r8)
 801a5c0:	e000      	b.n	801a5c4 <LORA_RequestClass+0xc4>
        break;
 801a5c2:	46c0      	nop			; (mov r8, r8)
  return Errorstatus;
 801a5c4:	232f      	movs	r3, #47	; 0x2f
 801a5c6:	18fb      	adds	r3, r7, r3
 801a5c8:	781b      	ldrb	r3, [r3, #0]
 801a5ca:	b25b      	sxtb	r3, r3
}
 801a5cc:	0018      	movs	r0, r3
 801a5ce:	46bd      	mov	sp, r7
 801a5d0:	b00d      	add	sp, #52	; 0x34
 801a5d2:	bd90      	pop	{r4, r7, pc}
 801a5d4:	20001344 	.word	0x20001344
 801a5d8:	0801faf4 	.word	0x0801faf4

0801a5dc <TraceUpLinkFrame>:
  *currentClass = mibReq.Param.Class;
}


static void TraceUpLinkFrame(McpsConfirm_t *mcpsConfirm)
{
 801a5dc:	b580      	push	{r7, lr}
 801a5de:	b096      	sub	sp, #88	; 0x58
 801a5e0:	af00      	add	r7, sp, #0
 801a5e2:	6078      	str	r0, [r7, #4]

    MibRequestConfirm_t mibGet;
    MibRequestConfirm_t mibReq;

    mibReq.Type = MIB_DEVICE_CLASS;
 801a5e4:	2114      	movs	r1, #20
 801a5e6:	187b      	adds	r3, r7, r1
 801a5e8:	2200      	movs	r2, #0
 801a5ea:	701a      	strb	r2, [r3, #0]
    LoRaMacMibGetRequestConfirm( &mibReq );
 801a5ec:	187b      	adds	r3, r7, r1
 801a5ee:	0018      	movs	r0, r3
 801a5f0:	f7f9 fac2 	bl	8013b78 <LoRaMacMibGetRequestConfirm>
                             "ABC"[mibReq.Param.Class], \
                             AppData.Port, \
                             AppData.BuffSize, \
                             mcpsConfirm->TxPower );)

    mibGet.Type  = MIB_CHANNELS_MASK;
 801a5f4:	2134      	movs	r1, #52	; 0x34
 801a5f6:	187b      	adds	r3, r7, r1
 801a5f8:	2224      	movs	r2, #36	; 0x24
 801a5fa:	701a      	strb	r2, [r3, #0]
    if( LoRaMacMibGetRequestConfirm( &mibGet ) == LORAMAC_STATUS_OK )
 801a5fc:	187b      	adds	r3, r7, r1
 801a5fe:	0018      	movs	r0, r3
 801a600:	f7f9 faba 	bl	8013b78 <LoRaMacMibGetRequestConfirm>
 801a604:	1e03      	subs	r3, r0, #0
 801a606:	d10f      	bne.n	801a628 <TraceUpLinkFrame+0x4c>
#if defined( REGION_AS923 ) || defined( REGION_CN779 ) || \
    defined( REGION_EU868 ) || defined( REGION_IN865 ) || \
    defined( REGION_KR920 ) || defined( REGION_EU433 ) || \
    defined( REGION_RU864 )

        for( uint8_t i = 0; i < 1; i++)
 801a608:	2357      	movs	r3, #87	; 0x57
 801a60a:	18fb      	adds	r3, r7, r3
 801a60c:	2200      	movs	r2, #0
 801a60e:	701a      	strb	r2, [r3, #0]
 801a610:	e005      	b.n	801a61e <TraceUpLinkFrame+0x42>
 801a612:	2157      	movs	r1, #87	; 0x57
 801a614:	187b      	adds	r3, r7, r1
 801a616:	781a      	ldrb	r2, [r3, #0]
 801a618:	187b      	adds	r3, r7, r1
 801a61a:	3201      	adds	r2, #1
 801a61c:	701a      	strb	r2, [r3, #0]
 801a61e:	2357      	movs	r3, #87	; 0x57
 801a620:	18fb      	adds	r3, r7, r3
 801a622:	781b      	ldrb	r3, [r3, #0]
 801a624:	2b00      	cmp	r3, #0
 801a626:	d0f4      	beq.n	801a612 <TraceUpLinkFrame+0x36>
            TVL2( PRINTF( "%04X ", mibGet.Param.ChannelsMask[i] );)
        }
    }

    TVL2( PRINTF("\r\n\r\n" );)
} 
 801a628:	46c0      	nop			; (mov r8, r8)
 801a62a:	46bd      	mov	sp, r7
 801a62c:	b016      	add	sp, #88	; 0x58
 801a62e:	bd80      	pop	{r7, pc}

0801a630 <TraceDownLinkFrame>:


static void TraceDownLinkFrame(McpsIndication_t *mcpsIndication)
{
 801a630:	b590      	push	{r4, r7, lr}
 801a632:	b08b      	sub	sp, #44	; 0x2c
 801a634:	af00      	add	r7, sp, #0
 801a636:	6078      	str	r0, [r7, #4]
    const char *slotStrings[] = { "1", "2", "C", "Ping-Slot", "Multicast Ping-Slot" };
 801a638:	2314      	movs	r3, #20
 801a63a:	18fb      	adds	r3, r7, r3
 801a63c:	4a04      	ldr	r2, [pc, #16]	; (801a650 <TraceDownLinkFrame+0x20>)
 801a63e:	ca13      	ldmia	r2!, {r0, r1, r4}
 801a640:	c313      	stmia	r3!, {r0, r1, r4}
 801a642:	ca03      	ldmia	r2!, {r0, r1}
 801a644:	c303      	stmia	r3!, {r0, r1}
                             slotStrings[mcpsIndication->RxSlot], \
                             mcpsIndication->Port, \
                             mcpsIndication->BufferSize, \
                             mcpsIndication->Rssi, \
                             mcpsIndication->Snr );)
}  
 801a646:	46c0      	nop			; (mov r8, r8)
 801a648:	46bd      	mov	sp, r7
 801a64a:	b00b      	add	sp, #44	; 0x2c
 801a64c:	bd90      	pop	{r4, r7, pc}
 801a64e:	46c0      	nop			; (mov r8, r8)
 801a650:	0801fb3c 	.word	0x0801fb3c

0801a654 <LPM_SetOffMode>:

/* Global variables ----------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Functions Definition ------------------------------------------------------*/
void LPM_SetOffMode(LPM_Id_t id, LPM_SetMode_t mode)
{
 801a654:	b580      	push	{r7, lr}
 801a656:	b086      	sub	sp, #24
 801a658:	af00      	add	r7, sp, #0
 801a65a:	0002      	movs	r2, r0
 801a65c:	1dfb      	adds	r3, r7, #7
 801a65e:	701a      	strb	r2, [r3, #0]
 801a660:	1dbb      	adds	r3, r7, #6
 801a662:	1c0a      	adds	r2, r1, #0
 801a664:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801a666:	f3ef 8310 	mrs	r3, PRIMASK
 801a66a:	613b      	str	r3, [r7, #16]
  return(result);
 801a66c:	693b      	ldr	r3, [r7, #16]
  BACKUP_PRIMASK();
 801a66e:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801a670:	b672      	cpsid	i
}
 801a672:	46c0      	nop			; (mov r8, r8)
  
  DISABLE_IRQ( );
  
  
  switch(mode)
 801a674:	1dbb      	adds	r3, r7, #6
 801a676:	781b      	ldrb	r3, [r3, #0]
 801a678:	2b00      	cmp	r3, #0
 801a67a:	d009      	beq.n	801a690 <LPM_SetOffMode+0x3c>
 801a67c:	2b01      	cmp	r3, #1
 801a67e:	d110      	bne.n	801a6a2 <LPM_SetOffMode+0x4e>
  {
    case LPM_Disable:
    {
      OffModeDisable |= (uint32_t)id;
 801a680:	1dfb      	adds	r3, r7, #7
 801a682:	781a      	ldrb	r2, [r3, #0]
 801a684:	4b0c      	ldr	r3, [pc, #48]	; (801a6b8 <LPM_SetOffMode+0x64>)
 801a686:	681b      	ldr	r3, [r3, #0]
 801a688:	431a      	orrs	r2, r3
 801a68a:	4b0b      	ldr	r3, [pc, #44]	; (801a6b8 <LPM_SetOffMode+0x64>)
 801a68c:	601a      	str	r2, [r3, #0]
      break;
 801a68e:	e009      	b.n	801a6a4 <LPM_SetOffMode+0x50>
    }
    case LPM_Enable:
    {
      OffModeDisable &= ~(uint32_t)id;
 801a690:	1dfb      	adds	r3, r7, #7
 801a692:	781b      	ldrb	r3, [r3, #0]
 801a694:	43da      	mvns	r2, r3
 801a696:	4b08      	ldr	r3, [pc, #32]	; (801a6b8 <LPM_SetOffMode+0x64>)
 801a698:	681b      	ldr	r3, [r3, #0]
 801a69a:	401a      	ands	r2, r3
 801a69c:	4b06      	ldr	r3, [pc, #24]	; (801a6b8 <LPM_SetOffMode+0x64>)
 801a69e:	601a      	str	r2, [r3, #0]
      break;
 801a6a0:	e000      	b.n	801a6a4 <LPM_SetOffMode+0x50>
    }
    default:
      break;
 801a6a2:	46c0      	nop			; (mov r8, r8)
 801a6a4:	697b      	ldr	r3, [r7, #20]
 801a6a6:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801a6a8:	68fb      	ldr	r3, [r7, #12]
 801a6aa:	f383 8810 	msr	PRIMASK, r3
}
 801a6ae:	46c0      	nop			; (mov r8, r8)
  }
  
  RESTORE_PRIMASK( );

  return;
 801a6b0:	46c0      	nop			; (mov r8, r8)
}
 801a6b2:	46bd      	mov	sp, r7
 801a6b4:	b006      	add	sp, #24
 801a6b6:	bd80      	pop	{r7, pc}
 801a6b8:	2000134c 	.word	0x2000134c

0801a6bc <LPM_SetStopMode>:

void LPM_SetStopMode(LPM_Id_t id, LPM_SetMode_t mode)
{
 801a6bc:	b580      	push	{r7, lr}
 801a6be:	b086      	sub	sp, #24
 801a6c0:	af00      	add	r7, sp, #0
 801a6c2:	0002      	movs	r2, r0
 801a6c4:	1dfb      	adds	r3, r7, #7
 801a6c6:	701a      	strb	r2, [r3, #0]
 801a6c8:	1dbb      	adds	r3, r7, #6
 801a6ca:	1c0a      	adds	r2, r1, #0
 801a6cc:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801a6ce:	f3ef 8310 	mrs	r3, PRIMASK
 801a6d2:	613b      	str	r3, [r7, #16]
  return(result);
 801a6d4:	693b      	ldr	r3, [r7, #16]
  BACKUP_PRIMASK();
 801a6d6:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801a6d8:	b672      	cpsid	i
}
 801a6da:	46c0      	nop			; (mov r8, r8)
  
  DISABLE_IRQ( );
  
  
  switch(mode)
 801a6dc:	1dbb      	adds	r3, r7, #6
 801a6de:	781b      	ldrb	r3, [r3, #0]
 801a6e0:	2b00      	cmp	r3, #0
 801a6e2:	d009      	beq.n	801a6f8 <LPM_SetStopMode+0x3c>
 801a6e4:	2b01      	cmp	r3, #1
 801a6e6:	d110      	bne.n	801a70a <LPM_SetStopMode+0x4e>
  {
    case LPM_Disable:
    {
      StopModeDisable |= (uint32_t)id;
 801a6e8:	1dfb      	adds	r3, r7, #7
 801a6ea:	781a      	ldrb	r2, [r3, #0]
 801a6ec:	4b0c      	ldr	r3, [pc, #48]	; (801a720 <LPM_SetStopMode+0x64>)
 801a6ee:	681b      	ldr	r3, [r3, #0]
 801a6f0:	431a      	orrs	r2, r3
 801a6f2:	4b0b      	ldr	r3, [pc, #44]	; (801a720 <LPM_SetStopMode+0x64>)
 801a6f4:	601a      	str	r2, [r3, #0]
      break;
 801a6f6:	e009      	b.n	801a70c <LPM_SetStopMode+0x50>
    }
    case LPM_Enable:
    {
      StopModeDisable &= ~(uint32_t)id;
 801a6f8:	1dfb      	adds	r3, r7, #7
 801a6fa:	781b      	ldrb	r3, [r3, #0]
 801a6fc:	43da      	mvns	r2, r3
 801a6fe:	4b08      	ldr	r3, [pc, #32]	; (801a720 <LPM_SetStopMode+0x64>)
 801a700:	681b      	ldr	r3, [r3, #0]
 801a702:	401a      	ands	r2, r3
 801a704:	4b06      	ldr	r3, [pc, #24]	; (801a720 <LPM_SetStopMode+0x64>)
 801a706:	601a      	str	r2, [r3, #0]
      break;
 801a708:	e000      	b.n	801a70c <LPM_SetStopMode+0x50>
    }
    default:
      break;
 801a70a:	46c0      	nop			; (mov r8, r8)
 801a70c:	697b      	ldr	r3, [r7, #20]
 801a70e:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801a710:	68fb      	ldr	r3, [r7, #12]
 801a712:	f383 8810 	msr	PRIMASK, r3
}
 801a716:	46c0      	nop			; (mov r8, r8)
  }
  RESTORE_PRIMASK( );

  return;
 801a718:	46c0      	nop			; (mov r8, r8)
}
 801a71a:	46bd      	mov	sp, r7
 801a71c:	b006      	add	sp, #24
 801a71e:	bd80      	pop	{r7, pc}
 801a720:	20001348 	.word	0x20001348

0801a724 <LPM_GetMode>:

  return;
}

LPM_GetMode_t LPM_GetMode(void)
{
 801a724:	b580      	push	{r7, lr}
 801a726:	b084      	sub	sp, #16
 801a728:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801a72a:	f3ef 8310 	mrs	r3, PRIMASK
 801a72e:	607b      	str	r3, [r7, #4]
  return(result);
 801a730:	687b      	ldr	r3, [r7, #4]
  LPM_GetMode_t mode_selected;

  BACKUP_PRIMASK();
 801a732:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("cpsid i" : : : "memory");
 801a734:	b672      	cpsid	i
}
 801a736:	46c0      	nop			; (mov r8, r8)
  
  DISABLE_IRQ( );

  if(StopModeDisable )
 801a738:	4b11      	ldr	r3, [pc, #68]	; (801a780 <LPM_GetMode+0x5c>)
 801a73a:	681b      	ldr	r3, [r3, #0]
 801a73c:	2b00      	cmp	r3, #0
 801a73e:	d004      	beq.n	801a74a <LPM_GetMode+0x26>
  {
    mode_selected = LPM_SleepMode;
 801a740:	230f      	movs	r3, #15
 801a742:	18fb      	adds	r3, r7, r3
 801a744:	2200      	movs	r2, #0
 801a746:	701a      	strb	r2, [r3, #0]
 801a748:	e00c      	b.n	801a764 <LPM_GetMode+0x40>
  }
  else
  {
    if(OffModeDisable)
 801a74a:	4b0e      	ldr	r3, [pc, #56]	; (801a784 <LPM_GetMode+0x60>)
 801a74c:	681b      	ldr	r3, [r3, #0]
 801a74e:	2b00      	cmp	r3, #0
 801a750:	d004      	beq.n	801a75c <LPM_GetMode+0x38>
    {
      mode_selected = LPM_StopMode;
 801a752:	230f      	movs	r3, #15
 801a754:	18fb      	adds	r3, r7, r3
 801a756:	2201      	movs	r2, #1
 801a758:	701a      	strb	r2, [r3, #0]
 801a75a:	e003      	b.n	801a764 <LPM_GetMode+0x40>
    }
    else
    {
      mode_selected = LPM_OffMode;
 801a75c:	230f      	movs	r3, #15
 801a75e:	18fb      	adds	r3, r7, r3
 801a760:	2202      	movs	r2, #2
 801a762:	701a      	strb	r2, [r3, #0]
 801a764:	68bb      	ldr	r3, [r7, #8]
 801a766:	603b      	str	r3, [r7, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801a768:	683b      	ldr	r3, [r7, #0]
 801a76a:	f383 8810 	msr	PRIMASK, r3
}
 801a76e:	46c0      	nop			; (mov r8, r8)
    }
  }

  RESTORE_PRIMASK( );

  return mode_selected;
 801a770:	230f      	movs	r3, #15
 801a772:	18fb      	adds	r3, r7, r3
 801a774:	781b      	ldrb	r3, [r3, #0]
}
 801a776:	0018      	movs	r0, r3
 801a778:	46bd      	mov	sp, r7
 801a77a:	b004      	add	sp, #16
 801a77c:	bd80      	pop	{r7, pc}
 801a77e:	46c0      	nop			; (mov r8, r8)
 801a780:	20001348 	.word	0x20001348
 801a784:	2000134c 	.word	0x2000134c

0801a788 <circular_queue_init>:
static int16_t circular_queue_get_free_size(queue_param_t* queue);
static void add_elementSize_and_inc_writeIdx(queue_param_t* queue,uint16_t element_size);

/* Public functions ----------------------------------------------------------*/
void circular_queue_init(queue_param_t* queue, uint8_t* queue_buff, uint16_t queue_size)
{
 801a788:	b580      	push	{r7, lr}
 801a78a:	b084      	sub	sp, #16
 801a78c:	af00      	add	r7, sp, #0
 801a78e:	60f8      	str	r0, [r7, #12]
 801a790:	60b9      	str	r1, [r7, #8]
 801a792:	1dbb      	adds	r3, r7, #6
 801a794:	801a      	strh	r2, [r3, #0]
  queue->queue_read_idx=0;
 801a796:	68fb      	ldr	r3, [r7, #12]
 801a798:	2200      	movs	r2, #0
 801a79a:	801a      	strh	r2, [r3, #0]
  queue->queue_write_idx=0;
 801a79c:	68fb      	ldr	r3, [r7, #12]
 801a79e:	2200      	movs	r2, #0
 801a7a0:	805a      	strh	r2, [r3, #2]
  queue->queue_nb_element=0;
 801a7a2:	68fb      	ldr	r3, [r7, #12]
 801a7a4:	2200      	movs	r2, #0
 801a7a6:	809a      	strh	r2, [r3, #4]
  queue->queue_buff=queue_buff;
 801a7a8:	68fb      	ldr	r3, [r7, #12]
 801a7aa:	68ba      	ldr	r2, [r7, #8]
 801a7ac:	609a      	str	r2, [r3, #8]
  queue->queue_size=queue_size;
 801a7ae:	68fb      	ldr	r3, [r7, #12]
 801a7b0:	1dba      	adds	r2, r7, #6
 801a7b2:	8812      	ldrh	r2, [r2, #0]
 801a7b4:	80da      	strh	r2, [r3, #6]
  queue->queue_full=0;
 801a7b6:	68fb      	ldr	r3, [r7, #12]
 801a7b8:	2200      	movs	r2, #0
 801a7ba:	731a      	strb	r2, [r3, #12]
}
 801a7bc:	46c0      	nop			; (mov r8, r8)
 801a7be:	46bd      	mov	sp, r7
 801a7c0:	b004      	add	sp, #16
 801a7c2:	bd80      	pop	{r7, pc}

0801a7c4 <circular_queue_add>:

int circular_queue_add(queue_param_t* queue, uint8_t* buff, uint16_t buff_size)
{
 801a7c4:	b5b0      	push	{r4, r5, r7, lr}
 801a7c6:	b086      	sub	sp, #24
 801a7c8:	af00      	add	r7, sp, #0
 801a7ca:	60f8      	str	r0, [r7, #12]
 801a7cc:	60b9      	str	r1, [r7, #8]
 801a7ce:	1dbb      	adds	r3, r7, #6
 801a7d0:	801a      	strh	r2, [r3, #0]
  int status;  
  int16_t free_buff_len=circular_queue_get_free_size(queue);
 801a7d2:	2512      	movs	r5, #18
 801a7d4:	197c      	adds	r4, r7, r5
 801a7d6:	68fb      	ldr	r3, [r7, #12]
 801a7d8:	0018      	movs	r0, r3
 801a7da:	f000 f983 	bl	801aae4 <circular_queue_get_free_size>
 801a7de:	0003      	movs	r3, r0
 801a7e0:	8023      	strh	r3, [r4, #0]
  
  if ((buff_size+ELEMENT_SIZE_LEN<=free_buff_len)&& 
 801a7e2:	1dbb      	adds	r3, r7, #6
 801a7e4:	881b      	ldrh	r3, [r3, #0]
 801a7e6:	1c5a      	adds	r2, r3, #1
 801a7e8:	197b      	adds	r3, r7, r5
 801a7ea:	2100      	movs	r1, #0
 801a7ec:	5e5b      	ldrsh	r3, [r3, r1]
 801a7ee:	429a      	cmp	r2, r3
 801a7f0:	da47      	bge.n	801a882 <circular_queue_add+0xbe>
      ((queue->queue_write_idx+buff_size+ELEMENT_SIZE_LEN<=queue->queue_size) 
 801a7f2:	68fb      	ldr	r3, [r7, #12]
 801a7f4:	885b      	ldrh	r3, [r3, #2]
 801a7f6:	001a      	movs	r2, r3
 801a7f8:	1dbb      	adds	r3, r7, #6
 801a7fa:	881b      	ldrh	r3, [r3, #0]
 801a7fc:	18d3      	adds	r3, r2, r3
 801a7fe:	3301      	adds	r3, #1
 801a800:	68fa      	ldr	r2, [r7, #12]
 801a802:	88d2      	ldrh	r2, [r2, #6]
  if ((buff_size+ELEMENT_SIZE_LEN<=free_buff_len)&& 
 801a804:	4293      	cmp	r3, r2
 801a806:	db07      	blt.n	801a818 <circular_queue_add+0x54>
        || (queue->queue_write_idx>=queue->queue_size-ELEMENT_SIZE_LEN))) /*elementSize cut in 2 or elementSize at Top*/
 801a808:	68fb      	ldr	r3, [r7, #12]
 801a80a:	885b      	ldrh	r3, [r3, #2]
 801a80c:	001a      	movs	r2, r3
 801a80e:	68fb      	ldr	r3, [r7, #12]
 801a810:	88db      	ldrh	r3, [r3, #6]
 801a812:	3b02      	subs	r3, #2
 801a814:	429a      	cmp	r2, r3
 801a816:	db34      	blt.n	801a882 <circular_queue_add+0xbe>
  {
    //add in one element
    add_elementSize_and_inc_writeIdx(queue, buff_size);
 801a818:	1dbb      	adds	r3, r7, #6
 801a81a:	881a      	ldrh	r2, [r3, #0]
 801a81c:	68fb      	ldr	r3, [r7, #12]
 801a81e:	0011      	movs	r1, r2
 801a820:	0018      	movs	r0, r3
 801a822:	f000 f9ac 	bl	801ab7e <add_elementSize_and_inc_writeIdx>
    queue_copy(queue->queue_buff+queue->queue_write_idx,buff,buff_size);
 801a826:	68fb      	ldr	r3, [r7, #12]
 801a828:	689b      	ldr	r3, [r3, #8]
 801a82a:	68fa      	ldr	r2, [r7, #12]
 801a82c:	8852      	ldrh	r2, [r2, #2]
 801a82e:	1898      	adds	r0, r3, r2
 801a830:	1dbb      	adds	r3, r7, #6
 801a832:	881a      	ldrh	r2, [r3, #0]
 801a834:	68bb      	ldr	r3, [r7, #8]
 801a836:	0019      	movs	r1, r3
 801a838:	f000 f985 	bl	801ab46 <queue_copy>
    queue->queue_write_idx+=buff_size;
 801a83c:	68fb      	ldr	r3, [r7, #12]
 801a83e:	885a      	ldrh	r2, [r3, #2]
 801a840:	1dbb      	adds	r3, r7, #6
 801a842:	881b      	ldrh	r3, [r3, #0]
 801a844:	18d3      	adds	r3, r2, r3
 801a846:	b29a      	uxth	r2, r3
 801a848:	68fb      	ldr	r3, [r7, #12]
 801a84a:	805a      	strh	r2, [r3, #2]
    /*modulo queue_size*/
    if (queue->queue_write_idx==queue->queue_size)
 801a84c:	68fb      	ldr	r3, [r7, #12]
 801a84e:	885a      	ldrh	r2, [r3, #2]
 801a850:	68fb      	ldr	r3, [r7, #12]
 801a852:	88db      	ldrh	r3, [r3, #6]
 801a854:	429a      	cmp	r2, r3
 801a856:	d102      	bne.n	801a85e <circular_queue_add+0x9a>
    {
        queue->queue_write_idx=0;
 801a858:	68fb      	ldr	r3, [r7, #12]
 801a85a:	2200      	movs	r2, #0
 801a85c:	805a      	strh	r2, [r3, #2]
    }
    //add one element
    queue->queue_nb_element++; 
 801a85e:	68fb      	ldr	r3, [r7, #12]
 801a860:	889b      	ldrh	r3, [r3, #4]
 801a862:	3301      	adds	r3, #1
 801a864:	b29a      	uxth	r2, r3
 801a866:	68fb      	ldr	r3, [r7, #12]
 801a868:	809a      	strh	r2, [r3, #4]
    /*in case que is full*/
    if (queue->queue_write_idx== queue->queue_read_idx)
 801a86a:	68fb      	ldr	r3, [r7, #12]
 801a86c:	885a      	ldrh	r2, [r3, #2]
 801a86e:	68fb      	ldr	r3, [r7, #12]
 801a870:	881b      	ldrh	r3, [r3, #0]
 801a872:	429a      	cmp	r2, r3
 801a874:	d102      	bne.n	801a87c <circular_queue_add+0xb8>
    {
      queue->queue_full=1;
 801a876:	68fb      	ldr	r3, [r7, #12]
 801a878:	2201      	movs	r2, #1
 801a87a:	731a      	strb	r2, [r3, #12]
    }
    status=0;
 801a87c:	2300      	movs	r3, #0
 801a87e:	617b      	str	r3, [r7, #20]
 801a880:	e060      	b.n	801a944 <circular_queue_add+0x180>
  }
  else if (buff_size+2*ELEMENT_SIZE_LEN<=free_buff_len)
 801a882:	1dbb      	adds	r3, r7, #6
 801a884:	881b      	ldrh	r3, [r3, #0]
 801a886:	1cda      	adds	r2, r3, #3
 801a888:	2312      	movs	r3, #18
 801a88a:	18fb      	adds	r3, r7, r3
 801a88c:	2100      	movs	r1, #0
 801a88e:	5e5b      	ldrsh	r3, [r3, r1]
 801a890:	429a      	cmp	r2, r3
 801a892:	da54      	bge.n	801a93e <circular_queue_add+0x17a>
  {
    //split buffer in two elements
    /*fill top of queue with first element of size top_size*/
    uint16_t top_size = queue->queue_size-(queue->queue_write_idx+ELEMENT_SIZE_LEN);
 801a894:	68fb      	ldr	r3, [r7, #12]
 801a896:	88da      	ldrh	r2, [r3, #6]
 801a898:	68fb      	ldr	r3, [r7, #12]
 801a89a:	885b      	ldrh	r3, [r3, #2]
 801a89c:	1ad3      	subs	r3, r2, r3
 801a89e:	b29a      	uxth	r2, r3
 801a8a0:	2410      	movs	r4, #16
 801a8a2:	193b      	adds	r3, r7, r4
 801a8a4:	3a02      	subs	r2, #2
 801a8a6:	801a      	strh	r2, [r3, #0]
    add_elementSize_and_inc_writeIdx(queue,top_size);
 801a8a8:	193b      	adds	r3, r7, r4
 801a8aa:	881a      	ldrh	r2, [r3, #0]
 801a8ac:	68fb      	ldr	r3, [r7, #12]
 801a8ae:	0011      	movs	r1, r2
 801a8b0:	0018      	movs	r0, r3
 801a8b2:	f000 f964 	bl	801ab7e <add_elementSize_and_inc_writeIdx>
    queue_copy(queue->queue_buff+queue->queue_write_idx,buff,top_size);
 801a8b6:	68fb      	ldr	r3, [r7, #12]
 801a8b8:	689b      	ldr	r3, [r3, #8]
 801a8ba:	68fa      	ldr	r2, [r7, #12]
 801a8bc:	8852      	ldrh	r2, [r2, #2]
 801a8be:	1898      	adds	r0, r3, r2
 801a8c0:	193b      	adds	r3, r7, r4
 801a8c2:	881a      	ldrh	r2, [r3, #0]
 801a8c4:	68bb      	ldr	r3, [r7, #8]
 801a8c6:	0019      	movs	r1, r3
 801a8c8:	f000 f93d 	bl	801ab46 <queue_copy>
    queue->queue_write_idx=0;
 801a8cc:	68fb      	ldr	r3, [r7, #12]
 801a8ce:	2200      	movs	r2, #0
 801a8d0:	805a      	strh	r2, [r3, #2]

    /*fill bottom of queue with second element of size buff_size-top_size*/
    buff_size-=top_size;
 801a8d2:	1dbb      	adds	r3, r7, #6
 801a8d4:	1db9      	adds	r1, r7, #6
 801a8d6:	193a      	adds	r2, r7, r4
 801a8d8:	8809      	ldrh	r1, [r1, #0]
 801a8da:	8812      	ldrh	r2, [r2, #0]
 801a8dc:	1a8a      	subs	r2, r1, r2
 801a8de:	801a      	strh	r2, [r3, #0]
    add_elementSize_and_inc_writeIdx(queue, buff_size);
 801a8e0:	1dbb      	adds	r3, r7, #6
 801a8e2:	881a      	ldrh	r2, [r3, #0]
 801a8e4:	68fb      	ldr	r3, [r7, #12]
 801a8e6:	0011      	movs	r1, r2
 801a8e8:	0018      	movs	r0, r3
 801a8ea:	f000 f948 	bl	801ab7e <add_elementSize_and_inc_writeIdx>
    queue_copy(queue->queue_buff+queue->queue_write_idx,buff+top_size,buff_size);
 801a8ee:	68fb      	ldr	r3, [r7, #12]
 801a8f0:	689b      	ldr	r3, [r3, #8]
 801a8f2:	68fa      	ldr	r2, [r7, #12]
 801a8f4:	8852      	ldrh	r2, [r2, #2]
 801a8f6:	1898      	adds	r0, r3, r2
 801a8f8:	193b      	adds	r3, r7, r4
 801a8fa:	881b      	ldrh	r3, [r3, #0]
 801a8fc:	68ba      	ldr	r2, [r7, #8]
 801a8fe:	18d1      	adds	r1, r2, r3
 801a900:	1dbb      	adds	r3, r7, #6
 801a902:	881b      	ldrh	r3, [r3, #0]
 801a904:	001a      	movs	r2, r3
 801a906:	f000 f91e 	bl	801ab46 <queue_copy>
    queue->queue_write_idx+=buff_size;
 801a90a:	68fb      	ldr	r3, [r7, #12]
 801a90c:	885a      	ldrh	r2, [r3, #2]
 801a90e:	1dbb      	adds	r3, r7, #6
 801a910:	881b      	ldrh	r3, [r3, #0]
 801a912:	18d3      	adds	r3, r2, r3
 801a914:	b29a      	uxth	r2, r3
 801a916:	68fb      	ldr	r3, [r7, #12]
 801a918:	805a      	strh	r2, [r3, #2]
    // add two elements
    queue->queue_nb_element+=2;
 801a91a:	68fb      	ldr	r3, [r7, #12]
 801a91c:	889b      	ldrh	r3, [r3, #4]
 801a91e:	3302      	adds	r3, #2
 801a920:	b29a      	uxth	r2, r3
 801a922:	68fb      	ldr	r3, [r7, #12]
 801a924:	809a      	strh	r2, [r3, #4]
    /*in case que is full*/
    if (queue->queue_write_idx== queue->queue_read_idx)
 801a926:	68fb      	ldr	r3, [r7, #12]
 801a928:	885a      	ldrh	r2, [r3, #2]
 801a92a:	68fb      	ldr	r3, [r7, #12]
 801a92c:	881b      	ldrh	r3, [r3, #0]
 801a92e:	429a      	cmp	r2, r3
 801a930:	d102      	bne.n	801a938 <circular_queue_add+0x174>
    {
      queue->queue_full=1;
 801a932:	68fb      	ldr	r3, [r7, #12]
 801a934:	2201      	movs	r2, #1
 801a936:	731a      	strb	r2, [r3, #12]
    }    
    status =0;
 801a938:	2300      	movs	r3, #0
 801a93a:	617b      	str	r3, [r7, #20]
 801a93c:	e002      	b.n	801a944 <circular_queue_add+0x180>
  }
  else
  {
    status=-1;
 801a93e:	2301      	movs	r3, #1
 801a940:	425b      	negs	r3, r3
 801a942:	617b      	str	r3, [r7, #20]
  }
  return status;
 801a944:	697b      	ldr	r3, [r7, #20]
}
 801a946:	0018      	movs	r0, r3
 801a948:	46bd      	mov	sp, r7
 801a94a:	b006      	add	sp, #24
 801a94c:	bdb0      	pop	{r4, r5, r7, pc}

0801a94e <circular_queue_get>:

int circular_queue_get(queue_param_t* queue, uint8_t** buff, uint16_t* buff_size)
{
 801a94e:	b590      	push	{r4, r7, lr}
 801a950:	b087      	sub	sp, #28
 801a952:	af00      	add	r7, sp, #0
 801a954:	60f8      	str	r0, [r7, #12]
 801a956:	60b9      	str	r1, [r7, #8]
 801a958:	607a      	str	r2, [r7, #4]
  int status;
  if (queue->queue_nb_element==0)
 801a95a:	68fb      	ldr	r3, [r7, #12]
 801a95c:	889b      	ldrh	r3, [r3, #4]
 801a95e:	2b00      	cmp	r3, #0
 801a960:	d103      	bne.n	801a96a <circular_queue_get+0x1c>
  {
    status=-1;
 801a962:	2301      	movs	r3, #1
 801a964:	425b      	negs	r3, r3
 801a966:	617b      	str	r3, [r7, #20]
 801a968:	e044      	b.n	801a9f4 <circular_queue_get+0xa6>
  }
  else
  {
    uint16_t size;
    uint16_t read_idx=queue->queue_read_idx;
 801a96a:	2412      	movs	r4, #18
 801a96c:	193b      	adds	r3, r7, r4
 801a96e:	68fa      	ldr	r2, [r7, #12]
 801a970:	8812      	ldrh	r2, [r2, #0]
 801a972:	801a      	strh	r2, [r3, #0]
    /*retreive and remove 1st element' size and content*/
    size=(uint16_t) queue->queue_buff[read_idx++]<<8;
 801a974:	68fb      	ldr	r3, [r7, #12]
 801a976:	689a      	ldr	r2, [r3, #8]
 801a978:	193b      	adds	r3, r7, r4
 801a97a:	881b      	ldrh	r3, [r3, #0]
 801a97c:	1939      	adds	r1, r7, r4
 801a97e:	1c58      	adds	r0, r3, #1
 801a980:	8008      	strh	r0, [r1, #0]
 801a982:	18d3      	adds	r3, r2, r3
 801a984:	781b      	ldrb	r3, [r3, #0]
 801a986:	b29a      	uxth	r2, r3
 801a988:	2310      	movs	r3, #16
 801a98a:	18fb      	adds	r3, r7, r3
 801a98c:	0212      	lsls	r2, r2, #8
 801a98e:	801a      	strh	r2, [r3, #0]
    /*wrap if needed*/
    if (read_idx==queue->queue_size)
 801a990:	68fb      	ldr	r3, [r7, #12]
 801a992:	88db      	ldrh	r3, [r3, #6]
 801a994:	193a      	adds	r2, r7, r4
 801a996:	8812      	ldrh	r2, [r2, #0]
 801a998:	429a      	cmp	r2, r3
 801a99a:	d102      	bne.n	801a9a2 <circular_queue_get+0x54>
    {
      read_idx=0;
 801a99c:	193b      	adds	r3, r7, r4
 801a99e:	2200      	movs	r2, #0
 801a9a0:	801a      	strh	r2, [r3, #0]
    }
    size|=(uint16_t) queue->queue_buff[read_idx++];
 801a9a2:	68fb      	ldr	r3, [r7, #12]
 801a9a4:	689a      	ldr	r2, [r3, #8]
 801a9a6:	2412      	movs	r4, #18
 801a9a8:	193b      	adds	r3, r7, r4
 801a9aa:	881b      	ldrh	r3, [r3, #0]
 801a9ac:	1939      	adds	r1, r7, r4
 801a9ae:	1c58      	adds	r0, r3, #1
 801a9b0:	8008      	strh	r0, [r1, #0]
 801a9b2:	18d3      	adds	r3, r2, r3
 801a9b4:	781b      	ldrb	r3, [r3, #0]
 801a9b6:	b299      	uxth	r1, r3
 801a9b8:	2210      	movs	r2, #16
 801a9ba:	18bb      	adds	r3, r7, r2
 801a9bc:	18ba      	adds	r2, r7, r2
 801a9be:	8812      	ldrh	r2, [r2, #0]
 801a9c0:	430a      	orrs	r2, r1
 801a9c2:	801a      	strh	r2, [r3, #0]
    /*wrap if needed*/
    if (read_idx==queue->queue_size)
 801a9c4:	68fb      	ldr	r3, [r7, #12]
 801a9c6:	88db      	ldrh	r3, [r3, #6]
 801a9c8:	193a      	adds	r2, r7, r4
 801a9ca:	8812      	ldrh	r2, [r2, #0]
 801a9cc:	429a      	cmp	r2, r3
 801a9ce:	d102      	bne.n	801a9d6 <circular_queue_get+0x88>
    {
      read_idx=0;
 801a9d0:	193b      	adds	r3, r7, r4
 801a9d2:	2200      	movs	r2, #0
 801a9d4:	801a      	strh	r2, [r3, #0]
    }
    *buff= queue->queue_buff+read_idx;
 801a9d6:	68fb      	ldr	r3, [r7, #12]
 801a9d8:	689a      	ldr	r2, [r3, #8]
 801a9da:	2312      	movs	r3, #18
 801a9dc:	18fb      	adds	r3, r7, r3
 801a9de:	881b      	ldrh	r3, [r3, #0]
 801a9e0:	18d2      	adds	r2, r2, r3
 801a9e2:	68bb      	ldr	r3, [r7, #8]
 801a9e4:	601a      	str	r2, [r3, #0]

    * buff_size=size;
 801a9e6:	687b      	ldr	r3, [r7, #4]
 801a9e8:	2210      	movs	r2, #16
 801a9ea:	18ba      	adds	r2, r7, r2
 801a9ec:	8812      	ldrh	r2, [r2, #0]
 801a9ee:	801a      	strh	r2, [r3, #0]
    status=0;
 801a9f0:	2300      	movs	r3, #0
 801a9f2:	617b      	str	r3, [r7, #20]
  }
  return status;
 801a9f4:	697b      	ldr	r3, [r7, #20]
}
 801a9f6:	0018      	movs	r0, r3
 801a9f8:	46bd      	mov	sp, r7
 801a9fa:	b007      	add	sp, #28
 801a9fc:	bd90      	pop	{r4, r7, pc}

0801a9fe <circular_queue_remove>:

int circular_queue_remove(queue_param_t* queue)
{
 801a9fe:	b580      	push	{r7, lr}
 801aa00:	b084      	sub	sp, #16
 801aa02:	af00      	add	r7, sp, #0
 801aa04:	6078      	str	r0, [r7, #4]
  int status;
  if (queue->queue_nb_element==0)
 801aa06:	687b      	ldr	r3, [r7, #4]
 801aa08:	889b      	ldrh	r3, [r3, #4]
 801aa0a:	2b00      	cmp	r3, #0
 801aa0c:	d103      	bne.n	801aa16 <circular_queue_remove+0x18>
  {
      status=-1;
 801aa0e:	2301      	movs	r3, #1
 801aa10:	425b      	negs	r3, r3
 801aa12:	60fb      	str	r3, [r7, #12]
 801aa14:	e04e      	b.n	801aab4 <circular_queue_remove+0xb6>
  }
  else
  {
    uint16_t size;
    /*retreive and remove 1st element' size and content*/
    size=(uint16_t) queue->queue_buff[queue->queue_read_idx++]<<8;
 801aa16:	687b      	ldr	r3, [r7, #4]
 801aa18:	689a      	ldr	r2, [r3, #8]
 801aa1a:	687b      	ldr	r3, [r7, #4]
 801aa1c:	881b      	ldrh	r3, [r3, #0]
 801aa1e:	1c59      	adds	r1, r3, #1
 801aa20:	b288      	uxth	r0, r1
 801aa22:	6879      	ldr	r1, [r7, #4]
 801aa24:	8008      	strh	r0, [r1, #0]
 801aa26:	18d3      	adds	r3, r2, r3
 801aa28:	781b      	ldrb	r3, [r3, #0]
 801aa2a:	b29a      	uxth	r2, r3
 801aa2c:	230a      	movs	r3, #10
 801aa2e:	18fb      	adds	r3, r7, r3
 801aa30:	0212      	lsls	r2, r2, #8
 801aa32:	801a      	strh	r2, [r3, #0]
    if (queue->queue_read_idx==queue->queue_size)
 801aa34:	687b      	ldr	r3, [r7, #4]
 801aa36:	881a      	ldrh	r2, [r3, #0]
 801aa38:	687b      	ldr	r3, [r7, #4]
 801aa3a:	88db      	ldrh	r3, [r3, #6]
 801aa3c:	429a      	cmp	r2, r3
 801aa3e:	d102      	bne.n	801aa46 <circular_queue_remove+0x48>
    {
      queue->queue_read_idx=0;
 801aa40:	687b      	ldr	r3, [r7, #4]
 801aa42:	2200      	movs	r2, #0
 801aa44:	801a      	strh	r2, [r3, #0]
    }
    size|=(uint16_t) queue->queue_buff[queue->queue_read_idx++];
 801aa46:	687b      	ldr	r3, [r7, #4]
 801aa48:	689a      	ldr	r2, [r3, #8]
 801aa4a:	687b      	ldr	r3, [r7, #4]
 801aa4c:	881b      	ldrh	r3, [r3, #0]
 801aa4e:	1c59      	adds	r1, r3, #1
 801aa50:	b288      	uxth	r0, r1
 801aa52:	6879      	ldr	r1, [r7, #4]
 801aa54:	8008      	strh	r0, [r1, #0]
 801aa56:	18d3      	adds	r3, r2, r3
 801aa58:	781b      	ldrb	r3, [r3, #0]
 801aa5a:	b299      	uxth	r1, r3
 801aa5c:	220a      	movs	r2, #10
 801aa5e:	18bb      	adds	r3, r7, r2
 801aa60:	18ba      	adds	r2, r7, r2
 801aa62:	8812      	ldrh	r2, [r2, #0]
 801aa64:	430a      	orrs	r2, r1
 801aa66:	801a      	strh	r2, [r3, #0]
    if (queue->queue_read_idx==queue->queue_size)
 801aa68:	687b      	ldr	r3, [r7, #4]
 801aa6a:	881a      	ldrh	r2, [r3, #0]
 801aa6c:	687b      	ldr	r3, [r7, #4]
 801aa6e:	88db      	ldrh	r3, [r3, #6]
 801aa70:	429a      	cmp	r2, r3
 801aa72:	d102      	bne.n	801aa7a <circular_queue_remove+0x7c>
    {
      queue->queue_read_idx=0;
 801aa74:	687b      	ldr	r3, [r7, #4]
 801aa76:	2200      	movs	r2, #0
 801aa78:	801a      	strh	r2, [r3, #0]
    }
    /* increment read index*/
    queue->queue_read_idx+=size;
 801aa7a:	687b      	ldr	r3, [r7, #4]
 801aa7c:	881a      	ldrh	r2, [r3, #0]
 801aa7e:	230a      	movs	r3, #10
 801aa80:	18fb      	adds	r3, r7, r3
 801aa82:	881b      	ldrh	r3, [r3, #0]
 801aa84:	18d3      	adds	r3, r2, r3
 801aa86:	b29a      	uxth	r2, r3
 801aa88:	687b      	ldr	r3, [r7, #4]
 801aa8a:	801a      	strh	r2, [r3, #0]
    /*modulo queue_size*/
    if (queue->queue_read_idx==queue->queue_size)
 801aa8c:	687b      	ldr	r3, [r7, #4]
 801aa8e:	881a      	ldrh	r2, [r3, #0]
 801aa90:	687b      	ldr	r3, [r7, #4]
 801aa92:	88db      	ldrh	r3, [r3, #6]
 801aa94:	429a      	cmp	r2, r3
 801aa96:	d102      	bne.n	801aa9e <circular_queue_remove+0xa0>
    {
        queue->queue_read_idx=0;
 801aa98:	687b      	ldr	r3, [r7, #4]
 801aa9a:	2200      	movs	r2, #0
 801aa9c:	801a      	strh	r2, [r3, #0]
    }
    /* decrement number of element*/
    queue->queue_nb_element--;
 801aa9e:	687b      	ldr	r3, [r7, #4]
 801aaa0:	889b      	ldrh	r3, [r3, #4]
 801aaa2:	3b01      	subs	r3, #1
 801aaa4:	b29a      	uxth	r2, r3
 801aaa6:	687b      	ldr	r3, [r7, #4]
 801aaa8:	809a      	strh	r2, [r3, #4]
    queue->queue_full=0;
 801aaaa:	687b      	ldr	r3, [r7, #4]
 801aaac:	2200      	movs	r2, #0
 801aaae:	731a      	strb	r2, [r3, #12]
    status=0;
 801aab0:	2300      	movs	r3, #0
 801aab2:	60fb      	str	r3, [r7, #12]
  }
  return status;
 801aab4:	68fb      	ldr	r3, [r7, #12]
}
 801aab6:	0018      	movs	r0, r3
 801aab8:	46bd      	mov	sp, r7
 801aaba:	b004      	add	sp, #16
 801aabc:	bd80      	pop	{r7, pc}

0801aabe <circular_queue_sense>:

int circular_queue_sense(queue_param_t* queue)
{
 801aabe:	b580      	push	{r7, lr}
 801aac0:	b084      	sub	sp, #16
 801aac2:	af00      	add	r7, sp, #0
 801aac4:	6078      	str	r0, [r7, #4]
  int status;
  if (queue->queue_nb_element==0)
 801aac6:	687b      	ldr	r3, [r7, #4]
 801aac8:	889b      	ldrh	r3, [r3, #4]
 801aaca:	2b00      	cmp	r3, #0
 801aacc:	d103      	bne.n	801aad6 <circular_queue_sense+0x18>
  {
    status=-1;
 801aace:	2301      	movs	r3, #1
 801aad0:	425b      	negs	r3, r3
 801aad2:	60fb      	str	r3, [r7, #12]
 801aad4:	e001      	b.n	801aada <circular_queue_sense+0x1c>
  }
  else
  {
    status=0;
 801aad6:	2300      	movs	r3, #0
 801aad8:	60fb      	str	r3, [r7, #12]
  }
  return status;
 801aada:	68fb      	ldr	r3, [r7, #12]
}
 801aadc:	0018      	movs	r0, r3
 801aade:	46bd      	mov	sp, r7
 801aae0:	b004      	add	sp, #16
 801aae2:	bd80      	pop	{r7, pc}

0801aae4 <circular_queue_get_free_size>:

/* Private functions ---------------------------------------------------------*/
static int16_t circular_queue_get_free_size(queue_param_t* queue)
{
 801aae4:	b580      	push	{r7, lr}
 801aae6:	b084      	sub	sp, #16
 801aae8:	af00      	add	r7, sp, #0
 801aaea:	6078      	str	r0, [r7, #4]
  int16_t free_size;
  if (queue->queue_write_idx>=queue->queue_read_idx)
 801aaec:	687b      	ldr	r3, [r7, #4]
 801aaee:	885a      	ldrh	r2, [r3, #2]
 801aaf0:	687b      	ldr	r3, [r7, #4]
 801aaf2:	881b      	ldrh	r3, [r3, #0]
 801aaf4:	429a      	cmp	r2, r3
 801aaf6:	d30d      	bcc.n	801ab14 <circular_queue_get_free_size+0x30>
  {
    free_size=queue->queue_size-(queue->queue_write_idx-queue->queue_read_idx); 
 801aaf8:	687b      	ldr	r3, [r7, #4]
 801aafa:	88da      	ldrh	r2, [r3, #6]
 801aafc:	687b      	ldr	r3, [r7, #4]
 801aafe:	8819      	ldrh	r1, [r3, #0]
 801ab00:	687b      	ldr	r3, [r7, #4]
 801ab02:	885b      	ldrh	r3, [r3, #2]
 801ab04:	1acb      	subs	r3, r1, r3
 801ab06:	b29b      	uxth	r3, r3
 801ab08:	18d3      	adds	r3, r2, r3
 801ab0a:	b29a      	uxth	r2, r3
 801ab0c:	230e      	movs	r3, #14
 801ab0e:	18fb      	adds	r3, r7, r3
 801ab10:	801a      	strh	r2, [r3, #0]
 801ab12:	e008      	b.n	801ab26 <circular_queue_get_free_size+0x42>
  }
  else
  {
    free_size=(queue->queue_read_idx-queue->queue_write_idx); 
 801ab14:	687b      	ldr	r3, [r7, #4]
 801ab16:	881a      	ldrh	r2, [r3, #0]
 801ab18:	687b      	ldr	r3, [r7, #4]
 801ab1a:	885b      	ldrh	r3, [r3, #2]
 801ab1c:	1ad3      	subs	r3, r2, r3
 801ab1e:	b29a      	uxth	r2, r3
 801ab20:	230e      	movs	r3, #14
 801ab22:	18fb      	adds	r3, r7, r3
 801ab24:	801a      	strh	r2, [r3, #0]
  }
  if ( queue->queue_full==1)
 801ab26:	687b      	ldr	r3, [r7, #4]
 801ab28:	7b1b      	ldrb	r3, [r3, #12]
 801ab2a:	2b01      	cmp	r3, #1
 801ab2c:	d103      	bne.n	801ab36 <circular_queue_get_free_size+0x52>
  {
    free_size=0;
 801ab2e:	230e      	movs	r3, #14
 801ab30:	18fb      	adds	r3, r7, r3
 801ab32:	2200      	movs	r2, #0
 801ab34:	801a      	strh	r2, [r3, #0]
  }
  return free_size;
 801ab36:	230e      	movs	r3, #14
 801ab38:	18fb      	adds	r3, r7, r3
 801ab3a:	2200      	movs	r2, #0
 801ab3c:	5e9b      	ldrsh	r3, [r3, r2]
}
 801ab3e:	0018      	movs	r0, r3
 801ab40:	46bd      	mov	sp, r7
 801ab42:	b004      	add	sp, #16
 801ab44:	bd80      	pop	{r7, pc}

0801ab46 <queue_copy>:

static void queue_copy(uint8_t* out, const uint8_t* in, uint16_t size)
{
 801ab46:	b580      	push	{r7, lr}
 801ab48:	b084      	sub	sp, #16
 801ab4a:	af00      	add	r7, sp, #0
 801ab4c:	60f8      	str	r0, [r7, #12]
 801ab4e:	60b9      	str	r1, [r7, #8]
 801ab50:	1dbb      	adds	r3, r7, #6
 801ab52:	801a      	strh	r2, [r3, #0]
  while(size--)
 801ab54:	e007      	b.n	801ab66 <queue_copy+0x20>
  {
    *out++= *in++;
 801ab56:	68ba      	ldr	r2, [r7, #8]
 801ab58:	1c53      	adds	r3, r2, #1
 801ab5a:	60bb      	str	r3, [r7, #8]
 801ab5c:	68fb      	ldr	r3, [r7, #12]
 801ab5e:	1c59      	adds	r1, r3, #1
 801ab60:	60f9      	str	r1, [r7, #12]
 801ab62:	7812      	ldrb	r2, [r2, #0]
 801ab64:	701a      	strb	r2, [r3, #0]
  while(size--)
 801ab66:	1dbb      	adds	r3, r7, #6
 801ab68:	881b      	ldrh	r3, [r3, #0]
 801ab6a:	1dba      	adds	r2, r7, #6
 801ab6c:	1e59      	subs	r1, r3, #1
 801ab6e:	8011      	strh	r1, [r2, #0]
 801ab70:	2b00      	cmp	r3, #0
 801ab72:	d1f0      	bne.n	801ab56 <queue_copy+0x10>
  }
}
 801ab74:	46c0      	nop			; (mov r8, r8)
 801ab76:	46c0      	nop			; (mov r8, r8)
 801ab78:	46bd      	mov	sp, r7
 801ab7a:	b004      	add	sp, #16
 801ab7c:	bd80      	pop	{r7, pc}

0801ab7e <add_elementSize_and_inc_writeIdx>:

static void add_elementSize_and_inc_writeIdx(queue_param_t* queue,uint16_t element_size)
{
 801ab7e:	b590      	push	{r4, r7, lr}
 801ab80:	b083      	sub	sp, #12
 801ab82:	af00      	add	r7, sp, #0
 801ab84:	6078      	str	r0, [r7, #4]
 801ab86:	000a      	movs	r2, r1
 801ab88:	1cbb      	adds	r3, r7, #2
 801ab8a:	801a      	strh	r2, [r3, #0]
  queue->queue_buff[queue->queue_write_idx++]=(uint8_t) (element_size>>8);
 801ab8c:	1cbb      	adds	r3, r7, #2
 801ab8e:	881b      	ldrh	r3, [r3, #0]
 801ab90:	0a1b      	lsrs	r3, r3, #8
 801ab92:	b298      	uxth	r0, r3
 801ab94:	687b      	ldr	r3, [r7, #4]
 801ab96:	689a      	ldr	r2, [r3, #8]
 801ab98:	687b      	ldr	r3, [r7, #4]
 801ab9a:	885b      	ldrh	r3, [r3, #2]
 801ab9c:	1c59      	adds	r1, r3, #1
 801ab9e:	b28c      	uxth	r4, r1
 801aba0:	6879      	ldr	r1, [r7, #4]
 801aba2:	804c      	strh	r4, [r1, #2]
 801aba4:	18d3      	adds	r3, r2, r3
 801aba6:	b2c2      	uxtb	r2, r0
 801aba8:	701a      	strb	r2, [r3, #0]
  /*wrap if needed*/
  if ( queue->queue_write_idx == queue->queue_size)
 801abaa:	687b      	ldr	r3, [r7, #4]
 801abac:	885a      	ldrh	r2, [r3, #2]
 801abae:	687b      	ldr	r3, [r7, #4]
 801abb0:	88db      	ldrh	r3, [r3, #6]
 801abb2:	429a      	cmp	r2, r3
 801abb4:	d102      	bne.n	801abbc <add_elementSize_and_inc_writeIdx+0x3e>
  {
    queue->queue_write_idx=0;
 801abb6:	687b      	ldr	r3, [r7, #4]
 801abb8:	2200      	movs	r2, #0
 801abba:	805a      	strh	r2, [r3, #2]
  }
  queue->queue_buff[queue->queue_write_idx++]=(uint8_t) (element_size);
 801abbc:	687b      	ldr	r3, [r7, #4]
 801abbe:	689a      	ldr	r2, [r3, #8]
 801abc0:	687b      	ldr	r3, [r7, #4]
 801abc2:	885b      	ldrh	r3, [r3, #2]
 801abc4:	1c59      	adds	r1, r3, #1
 801abc6:	b288      	uxth	r0, r1
 801abc8:	6879      	ldr	r1, [r7, #4]
 801abca:	8048      	strh	r0, [r1, #2]
 801abcc:	18d3      	adds	r3, r2, r3
 801abce:	1cba      	adds	r2, r7, #2
 801abd0:	8812      	ldrh	r2, [r2, #0]
 801abd2:	b2d2      	uxtb	r2, r2
 801abd4:	701a      	strb	r2, [r3, #0]
  /*wrap if needed*/
  if ( queue->queue_write_idx == queue->queue_size)
 801abd6:	687b      	ldr	r3, [r7, #4]
 801abd8:	885a      	ldrh	r2, [r3, #2]
 801abda:	687b      	ldr	r3, [r7, #4]
 801abdc:	88db      	ldrh	r3, [r3, #6]
 801abde:	429a      	cmp	r2, r3
 801abe0:	d102      	bne.n	801abe8 <add_elementSize_and_inc_writeIdx+0x6a>
  {
    queue->queue_write_idx=0;
 801abe2:	687b      	ldr	r3, [r7, #4]
 801abe4:	2200      	movs	r2, #0
 801abe6:	805a      	strh	r2, [r3, #2]
  }
}
 801abe8:	46c0      	nop			; (mov r8, r8)
 801abea:	46bd      	mov	sp, r7
 801abec:	b003      	add	sp, #12
 801abee:	bd90      	pop	{r4, r7, pc}

0801abf0 <SysTimeAdd>:
static void CalendarDiv60( uint32_t in, uint32_t* out, uint32_t* remainder );

const char *WeekDayString[]={ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };

SysTime_t SysTimeAdd( SysTime_t a, SysTime_t b )
{
 801abf0:	b082      	sub	sp, #8
 801abf2:	b580      	push	{r7, lr}
 801abf4:	b086      	sub	sp, #24
 801abf6:	af00      	add	r7, sp, #0
 801abf8:	60f8      	str	r0, [r7, #12]
 801abfa:	1d38      	adds	r0, r7, #4
 801abfc:	6001      	str	r1, [r0, #0]
 801abfe:	6042      	str	r2, [r0, #4]
 801ac00:	2204      	movs	r2, #4
 801ac02:	2120      	movs	r1, #32
 801ac04:	468c      	mov	ip, r1
 801ac06:	44bc      	add	ip, r7
 801ac08:	4462      	add	r2, ip
 801ac0a:	6013      	str	r3, [r2, #0]
    SysTime_t c =  { .Seconds = 0, .SubSeconds = 0 };
 801ac0c:	2110      	movs	r1, #16
 801ac0e:	187b      	adds	r3, r7, r1
 801ac10:	2200      	movs	r2, #0
 801ac12:	601a      	str	r2, [r3, #0]
 801ac14:	187b      	adds	r3, r7, r1
 801ac16:	2200      	movs	r2, #0
 801ac18:	809a      	strh	r2, [r3, #4]

    c.Seconds = a.Seconds + b.Seconds;
 801ac1a:	1d3b      	adds	r3, r7, #4
 801ac1c:	681a      	ldr	r2, [r3, #0]
 801ac1e:	2304      	movs	r3, #4
 801ac20:	2020      	movs	r0, #32
 801ac22:	4684      	mov	ip, r0
 801ac24:	44bc      	add	ip, r7
 801ac26:	4463      	add	r3, ip
 801ac28:	681b      	ldr	r3, [r3, #0]
 801ac2a:	18d2      	adds	r2, r2, r3
 801ac2c:	187b      	adds	r3, r7, r1
 801ac2e:	601a      	str	r2, [r3, #0]
    c.SubSeconds = a.SubSeconds + b.SubSeconds;
 801ac30:	1d3b      	adds	r3, r7, #4
 801ac32:	2204      	movs	r2, #4
 801ac34:	5e9b      	ldrsh	r3, [r3, r2]
 801ac36:	b29a      	uxth	r2, r3
 801ac38:	2304      	movs	r3, #4
 801ac3a:	2020      	movs	r0, #32
 801ac3c:	4684      	mov	ip, r0
 801ac3e:	44bc      	add	ip, r7
 801ac40:	4463      	add	r3, ip
 801ac42:	2004      	movs	r0, #4
 801ac44:	5e1b      	ldrsh	r3, [r3, r0]
 801ac46:	b29b      	uxth	r3, r3
 801ac48:	18d3      	adds	r3, r2, r3
 801ac4a:	b29b      	uxth	r3, r3
 801ac4c:	b21a      	sxth	r2, r3
 801ac4e:	187b      	adds	r3, r7, r1
 801ac50:	809a      	strh	r2, [r3, #4]
    if( c.SubSeconds >= 1000 )
 801ac52:	187b      	adds	r3, r7, r1
 801ac54:	2204      	movs	r2, #4
 801ac56:	5e9a      	ldrsh	r2, [r3, r2]
 801ac58:	23fa      	movs	r3, #250	; 0xfa
 801ac5a:	009b      	lsls	r3, r3, #2
 801ac5c:	429a      	cmp	r2, r3
 801ac5e:	db0f      	blt.n	801ac80 <SysTimeAdd+0x90>
    {
        c.Seconds++;
 801ac60:	187b      	adds	r3, r7, r1
 801ac62:	681b      	ldr	r3, [r3, #0]
 801ac64:	1c5a      	adds	r2, r3, #1
 801ac66:	187b      	adds	r3, r7, r1
 801ac68:	601a      	str	r2, [r3, #0]
        c.SubSeconds -= 1000;
 801ac6a:	187b      	adds	r3, r7, r1
 801ac6c:	2204      	movs	r2, #4
 801ac6e:	5e9b      	ldrsh	r3, [r3, r2]
 801ac70:	b29b      	uxth	r3, r3
 801ac72:	4a09      	ldr	r2, [pc, #36]	; (801ac98 <SysTimeAdd+0xa8>)
 801ac74:	4694      	mov	ip, r2
 801ac76:	4463      	add	r3, ip
 801ac78:	b29b      	uxth	r3, r3
 801ac7a:	b21a      	sxth	r2, r3
 801ac7c:	187b      	adds	r3, r7, r1
 801ac7e:	809a      	strh	r2, [r3, #4]
    }
    return c;
 801ac80:	68fb      	ldr	r3, [r7, #12]
 801ac82:	2210      	movs	r2, #16
 801ac84:	18ba      	adds	r2, r7, r2
 801ac86:	ca03      	ldmia	r2!, {r0, r1}
 801ac88:	c303      	stmia	r3!, {r0, r1}
}
 801ac8a:	68f8      	ldr	r0, [r7, #12]
 801ac8c:	46bd      	mov	sp, r7
 801ac8e:	b006      	add	sp, #24
 801ac90:	bc80      	pop	{r7}
 801ac92:	bc08      	pop	{r3}
 801ac94:	b002      	add	sp, #8
 801ac96:	4718      	bx	r3
 801ac98:	fffffc18 	.word	0xfffffc18

0801ac9c <SysTimeSub>:

SysTime_t SysTimeSub( SysTime_t a, SysTime_t b )
{
 801ac9c:	b082      	sub	sp, #8
 801ac9e:	b580      	push	{r7, lr}
 801aca0:	b086      	sub	sp, #24
 801aca2:	af00      	add	r7, sp, #0
 801aca4:	60f8      	str	r0, [r7, #12]
 801aca6:	1d38      	adds	r0, r7, #4
 801aca8:	6001      	str	r1, [r0, #0]
 801acaa:	6042      	str	r2, [r0, #4]
 801acac:	2204      	movs	r2, #4
 801acae:	2120      	movs	r1, #32
 801acb0:	468c      	mov	ip, r1
 801acb2:	44bc      	add	ip, r7
 801acb4:	4462      	add	r2, ip
 801acb6:	6013      	str	r3, [r2, #0]
    SysTime_t c = { .Seconds = 0, .SubSeconds = 0 };
 801acb8:	2110      	movs	r1, #16
 801acba:	187b      	adds	r3, r7, r1
 801acbc:	2200      	movs	r2, #0
 801acbe:	601a      	str	r2, [r3, #0]
 801acc0:	187b      	adds	r3, r7, r1
 801acc2:	2200      	movs	r2, #0
 801acc4:	809a      	strh	r2, [r3, #4]

    c.Seconds = a.Seconds - b.Seconds;
 801acc6:	1d3b      	adds	r3, r7, #4
 801acc8:	681a      	ldr	r2, [r3, #0]
 801acca:	2304      	movs	r3, #4
 801accc:	2020      	movs	r0, #32
 801acce:	4684      	mov	ip, r0
 801acd0:	44bc      	add	ip, r7
 801acd2:	4463      	add	r3, ip
 801acd4:	681b      	ldr	r3, [r3, #0]
 801acd6:	1ad2      	subs	r2, r2, r3
 801acd8:	187b      	adds	r3, r7, r1
 801acda:	601a      	str	r2, [r3, #0]
    c.SubSeconds = a.SubSeconds - b.SubSeconds;
 801acdc:	1d3b      	adds	r3, r7, #4
 801acde:	2204      	movs	r2, #4
 801ace0:	5e9b      	ldrsh	r3, [r3, r2]
 801ace2:	b29a      	uxth	r2, r3
 801ace4:	2304      	movs	r3, #4
 801ace6:	2020      	movs	r0, #32
 801ace8:	4684      	mov	ip, r0
 801acea:	44bc      	add	ip, r7
 801acec:	4463      	add	r3, ip
 801acee:	2004      	movs	r0, #4
 801acf0:	5e1b      	ldrsh	r3, [r3, r0]
 801acf2:	b29b      	uxth	r3, r3
 801acf4:	1ad3      	subs	r3, r2, r3
 801acf6:	b29b      	uxth	r3, r3
 801acf8:	b21a      	sxth	r2, r3
 801acfa:	187b      	adds	r3, r7, r1
 801acfc:	809a      	strh	r2, [r3, #4]
    if( c.SubSeconds < 0 )
 801acfe:	187b      	adds	r3, r7, r1
 801ad00:	2204      	movs	r2, #4
 801ad02:	5e9b      	ldrsh	r3, [r3, r2]
 801ad04:	2b00      	cmp	r3, #0
 801ad06:	da10      	bge.n	801ad2a <SysTimeSub+0x8e>
    {
        c.Seconds--;
 801ad08:	187b      	adds	r3, r7, r1
 801ad0a:	681b      	ldr	r3, [r3, #0]
 801ad0c:	1e5a      	subs	r2, r3, #1
 801ad0e:	187b      	adds	r3, r7, r1
 801ad10:	601a      	str	r2, [r3, #0]
        c.SubSeconds += 1000;
 801ad12:	187b      	adds	r3, r7, r1
 801ad14:	2204      	movs	r2, #4
 801ad16:	5e9b      	ldrsh	r3, [r3, r2]
 801ad18:	b29b      	uxth	r3, r3
 801ad1a:	22fa      	movs	r2, #250	; 0xfa
 801ad1c:	0092      	lsls	r2, r2, #2
 801ad1e:	4694      	mov	ip, r2
 801ad20:	4463      	add	r3, ip
 801ad22:	b29b      	uxth	r3, r3
 801ad24:	b21a      	sxth	r2, r3
 801ad26:	187b      	adds	r3, r7, r1
 801ad28:	809a      	strh	r2, [r3, #4]
    }
    return c;
 801ad2a:	68fb      	ldr	r3, [r7, #12]
 801ad2c:	2210      	movs	r2, #16
 801ad2e:	18ba      	adds	r2, r7, r2
 801ad30:	ca03      	ldmia	r2!, {r0, r1}
 801ad32:	c303      	stmia	r3!, {r0, r1}
}
 801ad34:	68f8      	ldr	r0, [r7, #12]
 801ad36:	46bd      	mov	sp, r7
 801ad38:	b006      	add	sp, #24
 801ad3a:	bc80      	pop	{r7}
 801ad3c:	bc08      	pop	{r3}
 801ad3e:	b002      	add	sp, #8
 801ad40:	4718      	bx	r3

0801ad42 <SysTimeSet>:

void SysTimeSet( SysTime_t sysTime )
{
 801ad42:	b5b0      	push	{r4, r5, r7, lr}
 801ad44:	b088      	sub	sp, #32
 801ad46:	af02      	add	r7, sp, #8
 801ad48:	003b      	movs	r3, r7
 801ad4a:	6018      	str	r0, [r3, #0]
 801ad4c:	6059      	str	r1, [r3, #4]
    SysTime_t DeltaTime;
  
    SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 801ad4e:	2408      	movs	r4, #8
 801ad50:	193b      	adds	r3, r7, r4
 801ad52:	2200      	movs	r2, #0
 801ad54:	601a      	str	r2, [r3, #0]
 801ad56:	193b      	adds	r3, r7, r4
 801ad58:	2200      	movs	r2, #0
 801ad5a:	809a      	strh	r2, [r3, #4]

    calendarTime.Seconds = HW_RTC_GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 801ad5c:	193b      	adds	r3, r7, r4
 801ad5e:	3304      	adds	r3, #4
 801ad60:	0018      	movs	r0, r3
 801ad62:	f001 fa1f 	bl	801c1a4 <HW_RTC_GetCalendarTime>
 801ad66:	0002      	movs	r2, r0
 801ad68:	0021      	movs	r1, r4
 801ad6a:	187b      	adds	r3, r7, r1
 801ad6c:	601a      	str	r2, [r3, #0]

    // sysTime is epoch
    DeltaTime = SysTimeSub( sysTime, calendarTime );
 801ad6e:	2510      	movs	r5, #16
 801ad70:	197c      	adds	r4, r7, r5
 801ad72:	187b      	adds	r3, r7, r1
 801ad74:	003a      	movs	r2, r7
 801ad76:	4669      	mov	r1, sp
 801ad78:	6858      	ldr	r0, [r3, #4]
 801ad7a:	6008      	str	r0, [r1, #0]
 801ad7c:	681b      	ldr	r3, [r3, #0]
 801ad7e:	6811      	ldr	r1, [r2, #0]
 801ad80:	6852      	ldr	r2, [r2, #4]
 801ad82:	0020      	movs	r0, r4
 801ad84:	f7ff ff8a 	bl	801ac9c <SysTimeSub>

    HW_RTC_BKUPWrite( DeltaTime.Seconds, ( uint32_t )DeltaTime.SubSeconds );
 801ad88:	197b      	adds	r3, r7, r5
 801ad8a:	681a      	ldr	r2, [r3, #0]
 801ad8c:	197b      	adds	r3, r7, r5
 801ad8e:	2104      	movs	r1, #4
 801ad90:	5e5b      	ldrsh	r3, [r3, r1]
 801ad92:	0019      	movs	r1, r3
 801ad94:	0010      	movs	r0, r2
 801ad96:	f001 fa2f 	bl	801c1f8 <HW_RTC_BKUPWrite>
}
 801ad9a:	46c0      	nop			; (mov r8, r8)
 801ad9c:	46bd      	mov	sp, r7
 801ad9e:	b006      	add	sp, #24
 801ada0:	bdb0      	pop	{r4, r5, r7, pc}

0801ada2 <SysTimeGet>:

SysTime_t SysTimeGet( void )
{
 801ada2:	b5f0      	push	{r4, r5, r6, r7, lr}
 801ada4:	b08b      	sub	sp, #44	; 0x2c
 801ada6:	af02      	add	r7, sp, #8
 801ada8:	6078      	str	r0, [r7, #4]
    SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 801adaa:	2518      	movs	r5, #24
 801adac:	197b      	adds	r3, r7, r5
 801adae:	2200      	movs	r2, #0
 801adb0:	601a      	str	r2, [r3, #0]
 801adb2:	197b      	adds	r3, r7, r5
 801adb4:	2200      	movs	r2, #0
 801adb6:	809a      	strh	r2, [r3, #4]
    SysTime_t sysTime = { .Seconds = 0, .SubSeconds = 0 };
 801adb8:	2410      	movs	r4, #16
 801adba:	193b      	adds	r3, r7, r4
 801adbc:	2200      	movs	r2, #0
 801adbe:	601a      	str	r2, [r3, #0]
 801adc0:	193b      	adds	r3, r7, r4
 801adc2:	2200      	movs	r2, #0
 801adc4:	809a      	strh	r2, [r3, #4]
    SysTime_t DeltaTime;

    calendarTime.Seconds = HW_RTC_GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 801adc6:	197b      	adds	r3, r7, r5
 801adc8:	3304      	adds	r3, #4
 801adca:	0018      	movs	r0, r3
 801adcc:	f001 f9ea 	bl	801c1a4 <HW_RTC_GetCalendarTime>
 801add0:	0002      	movs	r2, r0
 801add2:	197b      	adds	r3, r7, r5
 801add4:	601a      	str	r2, [r3, #0]

    HW_RTC_BKUPRead( &DeltaTime.Seconds, ( uint32_t* )&DeltaTime.SubSeconds );
 801add6:	2108      	movs	r1, #8
 801add8:	187b      	adds	r3, r7, r1
 801adda:	1d1a      	adds	r2, r3, #4
 801addc:	187b      	adds	r3, r7, r1
 801adde:	0011      	movs	r1, r2
 801ade0:	0018      	movs	r0, r3
 801ade2:	f001 fa21 	bl	801c228 <HW_RTC_BKUPRead>

    sysTime = SysTimeAdd( DeltaTime, calendarTime );
 801ade6:	0026      	movs	r6, r4
 801ade8:	193c      	adds	r4, r7, r4
 801adea:	197b      	adds	r3, r7, r5
 801adec:	2108      	movs	r1, #8
 801adee:	187a      	adds	r2, r7, r1
 801adf0:	4669      	mov	r1, sp
 801adf2:	6858      	ldr	r0, [r3, #4]
 801adf4:	6008      	str	r0, [r1, #0]
 801adf6:	681b      	ldr	r3, [r3, #0]
 801adf8:	6811      	ldr	r1, [r2, #0]
 801adfa:	6852      	ldr	r2, [r2, #4]
 801adfc:	0020      	movs	r0, r4
 801adfe:	f7ff fef7 	bl	801abf0 <SysTimeAdd>

    return sysTime;
 801ae02:	687b      	ldr	r3, [r7, #4]
 801ae04:	19ba      	adds	r2, r7, r6
 801ae06:	ca03      	ldmia	r2!, {r0, r1}
 801ae08:	c303      	stmia	r3!, {r0, r1}
}
 801ae0a:	6878      	ldr	r0, [r7, #4]
 801ae0c:	46bd      	mov	sp, r7
 801ae0e:	b009      	add	sp, #36	; 0x24
 801ae10:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801ae12 <SysTimeGetMcuTime>:


SysTime_t SysTimeGetMcuTime( void )
{
 801ae12:	b590      	push	{r4, r7, lr}
 801ae14:	b085      	sub	sp, #20
 801ae16:	af00      	add	r7, sp, #0
 801ae18:	6078      	str	r0, [r7, #4]
    SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 801ae1a:	2408      	movs	r4, #8
 801ae1c:	193b      	adds	r3, r7, r4
 801ae1e:	2200      	movs	r2, #0
 801ae20:	601a      	str	r2, [r3, #0]
 801ae22:	193b      	adds	r3, r7, r4
 801ae24:	2200      	movs	r2, #0
 801ae26:	809a      	strh	r2, [r3, #4]

    calendarTime.Seconds = HW_RTC_GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 801ae28:	193b      	adds	r3, r7, r4
 801ae2a:	3304      	adds	r3, #4
 801ae2c:	0018      	movs	r0, r3
 801ae2e:	f001 f9b9 	bl	801c1a4 <HW_RTC_GetCalendarTime>
 801ae32:	0002      	movs	r2, r0
 801ae34:	193b      	adds	r3, r7, r4
 801ae36:	601a      	str	r2, [r3, #0]
    
    return calendarTime;
 801ae38:	687b      	ldr	r3, [r7, #4]
 801ae3a:	193a      	adds	r2, r7, r4
 801ae3c:	ca03      	ldmia	r2!, {r0, r1}
 801ae3e:	c303      	stmia	r3!, {r0, r1}
}
 801ae40:	6878      	ldr	r0, [r7, #4]
 801ae42:	46bd      	mov	sp, r7
 801ae44:	b005      	add	sp, #20
 801ae46:	bd90      	pop	{r4, r7, pc}

0801ae48 <TimerInit>:
 * \retval true (the object is already in the list) or false
 */
static bool TimerExists( TimerEvent_t *obj );

void TimerInit( TimerEvent_t *obj, void ( *callback )( void *context ) )
{
 801ae48:	b580      	push	{r7, lr}
 801ae4a:	b082      	sub	sp, #8
 801ae4c:	af00      	add	r7, sp, #0
 801ae4e:	6078      	str	r0, [r7, #4]
 801ae50:	6039      	str	r1, [r7, #0]
  obj->Timestamp = 0;
 801ae52:	687b      	ldr	r3, [r7, #4]
 801ae54:	2200      	movs	r2, #0
 801ae56:	601a      	str	r2, [r3, #0]
  obj->ReloadValue = 0;
 801ae58:	687b      	ldr	r3, [r7, #4]
 801ae5a:	2200      	movs	r2, #0
 801ae5c:	605a      	str	r2, [r3, #4]
  obj->IsStarted = false;
 801ae5e:	687b      	ldr	r3, [r7, #4]
 801ae60:	2200      	movs	r2, #0
 801ae62:	721a      	strb	r2, [r3, #8]
  obj->IsNext2Expire = false;
 801ae64:	687b      	ldr	r3, [r7, #4]
 801ae66:	2200      	movs	r2, #0
 801ae68:	725a      	strb	r2, [r3, #9]
  obj->Callback = callback;
 801ae6a:	687b      	ldr	r3, [r7, #4]
 801ae6c:	683a      	ldr	r2, [r7, #0]
 801ae6e:	60da      	str	r2, [r3, #12]
  obj->Context = NULL;
 801ae70:	687b      	ldr	r3, [r7, #4]
 801ae72:	2200      	movs	r2, #0
 801ae74:	611a      	str	r2, [r3, #16]
  obj->Next = NULL;
 801ae76:	687b      	ldr	r3, [r7, #4]
 801ae78:	2200      	movs	r2, #0
 801ae7a:	615a      	str	r2, [r3, #20]
}
 801ae7c:	46c0      	nop			; (mov r8, r8)
 801ae7e:	46bd      	mov	sp, r7
 801ae80:	b002      	add	sp, #8
 801ae82:	bd80      	pop	{r7, pc}

0801ae84 <TimerStart>:
{
  obj->Context = context;
}

void TimerStart( TimerEvent_t *obj )
{
 801ae84:	b580      	push	{r7, lr}
 801ae86:	b088      	sub	sp, #32
 801ae88:	af00      	add	r7, sp, #0
 801ae8a:	6078      	str	r0, [r7, #4]
  uint32_t elapsedTime = 0;
 801ae8c:	2300      	movs	r3, #0
 801ae8e:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801ae90:	f3ef 8310 	mrs	r3, PRIMASK
 801ae94:	617b      	str	r3, [r7, #20]
  return(result);
 801ae96:	697b      	ldr	r3, [r7, #20]
  
  BACKUP_PRIMASK();
 801ae98:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("cpsid i" : : : "memory");
 801ae9a:	b672      	cpsid	i
}
 801ae9c:	46c0      	nop			; (mov r8, r8)
  
  DISABLE_IRQ( );
  

  if( ( obj == NULL ) || ( TimerExists( obj ) == true ) )
 801ae9e:	687b      	ldr	r3, [r7, #4]
 801aea0:	2b00      	cmp	r3, #0
 801aea2:	d005      	beq.n	801aeb0 <TimerStart+0x2c>
 801aea4:	687b      	ldr	r3, [r7, #4]
 801aea6:	0018      	movs	r0, r3
 801aea8:	f000 f99a 	bl	801b1e0 <TimerExists>
 801aeac:	1e03      	subs	r3, r0, #0
 801aeae:	d006      	beq.n	801aebe <TimerStart+0x3a>
 801aeb0:	69bb      	ldr	r3, [r7, #24]
 801aeb2:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801aeb4:	693b      	ldr	r3, [r7, #16]
 801aeb6:	f383 8810 	msr	PRIMASK, r3
}
 801aeba:	46c0      	nop			; (mov r8, r8)
  {
    RESTORE_PRIMASK( );
    return;
 801aebc:	e034      	b.n	801af28 <TimerStart+0xa4>
  }
  obj->Timestamp = obj->ReloadValue;
 801aebe:	687b      	ldr	r3, [r7, #4]
 801aec0:	685a      	ldr	r2, [r3, #4]
 801aec2:	687b      	ldr	r3, [r7, #4]
 801aec4:	601a      	str	r2, [r3, #0]
  obj->IsStarted = true;
 801aec6:	687b      	ldr	r3, [r7, #4]
 801aec8:	2201      	movs	r2, #1
 801aeca:	721a      	strb	r2, [r3, #8]
  obj->IsNext2Expire = false;
 801aecc:	687b      	ldr	r3, [r7, #4]
 801aece:	2200      	movs	r2, #0
 801aed0:	725a      	strb	r2, [r3, #9]

  if( TimerListHead == NULL )
 801aed2:	4b17      	ldr	r3, [pc, #92]	; (801af30 <TimerStart+0xac>)
 801aed4:	681b      	ldr	r3, [r3, #0]
 801aed6:	2b00      	cmp	r3, #0
 801aed8:	d106      	bne.n	801aee8 <TimerStart+0x64>
  {
    HW_RTC_SetTimerContext( );
 801aeda:	f000 ff21 	bl	801bd20 <HW_RTC_SetTimerContext>
    TimerInsertNewHeadTimer( obj ); // insert a timeout at now+obj->Timestamp
 801aede:	687b      	ldr	r3, [r7, #4]
 801aee0:	0018      	movs	r0, r3
 801aee2:	f000 f9eb 	bl	801b2bc <TimerInsertNewHeadTimer>
 801aee6:	e019      	b.n	801af1c <TimerStart+0x98>
  }
  else 
  {
    elapsedTime = HW_RTC_GetTimerElapsedTime( );
 801aee8:	f000 fe78 	bl	801bbdc <HW_RTC_GetTimerElapsedTime>
 801aeec:	0003      	movs	r3, r0
 801aeee:	61fb      	str	r3, [r7, #28]
    obj->Timestamp += elapsedTime;
 801aef0:	687b      	ldr	r3, [r7, #4]
 801aef2:	681a      	ldr	r2, [r3, #0]
 801aef4:	69fb      	ldr	r3, [r7, #28]
 801aef6:	18d2      	adds	r2, r2, r3
 801aef8:	687b      	ldr	r3, [r7, #4]
 801aefa:	601a      	str	r2, [r3, #0]
  
    if( obj->Timestamp < TimerListHead->Timestamp )
 801aefc:	687b      	ldr	r3, [r7, #4]
 801aefe:	681a      	ldr	r2, [r3, #0]
 801af00:	4b0b      	ldr	r3, [pc, #44]	; (801af30 <TimerStart+0xac>)
 801af02:	681b      	ldr	r3, [r3, #0]
 801af04:	681b      	ldr	r3, [r3, #0]
 801af06:	429a      	cmp	r2, r3
 801af08:	d204      	bcs.n	801af14 <TimerStart+0x90>
    {
      TimerInsertNewHeadTimer( obj);
 801af0a:	687b      	ldr	r3, [r7, #4]
 801af0c:	0018      	movs	r0, r3
 801af0e:	f000 f9d5 	bl	801b2bc <TimerInsertNewHeadTimer>
 801af12:	e003      	b.n	801af1c <TimerStart+0x98>
    }
    else
    {
      TimerInsertTimer( obj);
 801af14:	687b      	ldr	r3, [r7, #4]
 801af16:	0018      	movs	r0, r3
 801af18:	f000 f9a2 	bl	801b260 <TimerInsertTimer>
 801af1c:	69bb      	ldr	r3, [r7, #24]
 801af1e:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801af20:	68fb      	ldr	r3, [r7, #12]
 801af22:	f383 8810 	msr	PRIMASK, r3
}
 801af26:	46c0      	nop			; (mov r8, r8)
    }
  }
  RESTORE_PRIMASK( );
}
 801af28:	46bd      	mov	sp, r7
 801af2a:	b008      	add	sp, #32
 801af2c:	bd80      	pop	{r7, pc}
 801af2e:	46c0      	nop			; (mov r8, r8)
 801af30:	20001350 	.word	0x20001350

0801af34 <TimerIrqHandler>:
{
  return obj->IsStarted;
}

void TimerIrqHandler( void )
{
 801af34:	b590      	push	{r4, r7, lr}
 801af36:	b087      	sub	sp, #28
 801af38:	af00      	add	r7, sp, #0
  TimerEvent_t* cur;
  TimerEvent_t* next;
  

  
  uint32_t old =  HW_RTC_GetTimerContext( );
 801af3a:	f000 ff09 	bl	801bd50 <HW_RTC_GetTimerContext>
 801af3e:	0003      	movs	r3, r0
 801af40:	613b      	str	r3, [r7, #16]
  uint32_t now =  HW_RTC_SetTimerContext( );
 801af42:	f000 feed 	bl	801bd20 <HW_RTC_SetTimerContext>
 801af46:	0003      	movs	r3, r0
 801af48:	60fb      	str	r3, [r7, #12]
  uint32_t DeltaContext = now - old; //intentionnal wrap around
 801af4a:	68fa      	ldr	r2, [r7, #12]
 801af4c:	693b      	ldr	r3, [r7, #16]
 801af4e:	1ad3      	subs	r3, r2, r3
 801af50:	60bb      	str	r3, [r7, #8]
  
  /* Update timeStamp based upon new Time Reference*/
  /* because delta context should never exceed 2^32*/
  if ( TimerListHead != NULL )
 801af52:	4b39      	ldr	r3, [pc, #228]	; (801b038 <TimerIrqHandler+0x104>)
 801af54:	681b      	ldr	r3, [r3, #0]
 801af56:	2b00      	cmp	r3, #0
 801af58:	d01c      	beq.n	801af94 <TimerIrqHandler+0x60>
  {
    for (cur=TimerListHead; cur->Next != NULL; cur= cur->Next)
 801af5a:	4b37      	ldr	r3, [pc, #220]	; (801b038 <TimerIrqHandler+0x104>)
 801af5c:	681b      	ldr	r3, [r3, #0]
 801af5e:	617b      	str	r3, [r7, #20]
 801af60:	e014      	b.n	801af8c <TimerIrqHandler+0x58>
    {
      next =cur->Next;
 801af62:	697b      	ldr	r3, [r7, #20]
 801af64:	695b      	ldr	r3, [r3, #20]
 801af66:	607b      	str	r3, [r7, #4]
      if (next->Timestamp > DeltaContext)
 801af68:	687b      	ldr	r3, [r7, #4]
 801af6a:	681b      	ldr	r3, [r3, #0]
 801af6c:	68ba      	ldr	r2, [r7, #8]
 801af6e:	429a      	cmp	r2, r3
 801af70:	d206      	bcs.n	801af80 <TimerIrqHandler+0x4c>
      {
        next->Timestamp -= DeltaContext;
 801af72:	687b      	ldr	r3, [r7, #4]
 801af74:	681a      	ldr	r2, [r3, #0]
 801af76:	68bb      	ldr	r3, [r7, #8]
 801af78:	1ad2      	subs	r2, r2, r3
 801af7a:	687b      	ldr	r3, [r7, #4]
 801af7c:	601a      	str	r2, [r3, #0]
 801af7e:	e002      	b.n	801af86 <TimerIrqHandler+0x52>
      }
      else
      {
        next->Timestamp = 0 ;
 801af80:	687b      	ldr	r3, [r7, #4]
 801af82:	2200      	movs	r2, #0
 801af84:	601a      	str	r2, [r3, #0]
    for (cur=TimerListHead; cur->Next != NULL; cur= cur->Next)
 801af86:	697b      	ldr	r3, [r7, #20]
 801af88:	695b      	ldr	r3, [r3, #20]
 801af8a:	617b      	str	r3, [r7, #20]
 801af8c:	697b      	ldr	r3, [r7, #20]
 801af8e:	695b      	ldr	r3, [r3, #20]
 801af90:	2b00      	cmp	r3, #0
 801af92:	d1e6      	bne.n	801af62 <TimerIrqHandler+0x2e>
      }
    }
  }
  
  /* execute imediately the alarm callback */
  if ( TimerListHead != NULL )
 801af94:	4b28      	ldr	r3, [pc, #160]	; (801b038 <TimerIrqHandler+0x104>)
 801af96:	681b      	ldr	r3, [r3, #0]
 801af98:	2b00      	cmp	r3, #0
 801af9a:	d02c      	beq.n	801aff6 <TimerIrqHandler+0xc2>
  {
    cur = TimerListHead;
 801af9c:	4b26      	ldr	r3, [pc, #152]	; (801b038 <TimerIrqHandler+0x104>)
 801af9e:	681b      	ldr	r3, [r3, #0]
 801afa0:	617b      	str	r3, [r7, #20]
    TimerListHead = TimerListHead->Next;
 801afa2:	4b25      	ldr	r3, [pc, #148]	; (801b038 <TimerIrqHandler+0x104>)
 801afa4:	681b      	ldr	r3, [r3, #0]
 801afa6:	695a      	ldr	r2, [r3, #20]
 801afa8:	4b23      	ldr	r3, [pc, #140]	; (801b038 <TimerIrqHandler+0x104>)
 801afaa:	601a      	str	r2, [r3, #0]
    cur->IsStarted = false;
 801afac:	697b      	ldr	r3, [r7, #20]
 801afae:	2200      	movs	r2, #0
 801afb0:	721a      	strb	r2, [r3, #8]
    exec_cb( cur->Callback, cur->Context );
 801afb2:	697b      	ldr	r3, [r7, #20]
 801afb4:	68db      	ldr	r3, [r3, #12]
 801afb6:	2b00      	cmp	r3, #0
 801afb8:	d100      	bne.n	801afbc <TimerIrqHandler+0x88>
 801afba:	e7fe      	b.n	801afba <TimerIrqHandler+0x86>
 801afbc:	697b      	ldr	r3, [r7, #20]
 801afbe:	68da      	ldr	r2, [r3, #12]
 801afc0:	697b      	ldr	r3, [r7, #20]
 801afc2:	691b      	ldr	r3, [r3, #16]
 801afc4:	0018      	movs	r0, r3
 801afc6:	4790      	blx	r2
  }


  // remove all the expired object from the list
  while( ( TimerListHead != NULL ) && ( TimerListHead->Timestamp < HW_RTC_GetTimerElapsedTime(  )  ))
 801afc8:	e015      	b.n	801aff6 <TimerIrqHandler+0xc2>
  {
   cur = TimerListHead;
 801afca:	4b1b      	ldr	r3, [pc, #108]	; (801b038 <TimerIrqHandler+0x104>)
 801afcc:	681b      	ldr	r3, [r3, #0]
 801afce:	617b      	str	r3, [r7, #20]
   TimerListHead = TimerListHead->Next;
 801afd0:	4b19      	ldr	r3, [pc, #100]	; (801b038 <TimerIrqHandler+0x104>)
 801afd2:	681b      	ldr	r3, [r3, #0]
 801afd4:	695a      	ldr	r2, [r3, #20]
 801afd6:	4b18      	ldr	r3, [pc, #96]	; (801b038 <TimerIrqHandler+0x104>)
 801afd8:	601a      	str	r2, [r3, #0]
   cur->IsStarted = false;
 801afda:	697b      	ldr	r3, [r7, #20]
 801afdc:	2200      	movs	r2, #0
 801afde:	721a      	strb	r2, [r3, #8]
   exec_cb( cur->Callback, cur->Context );
 801afe0:	697b      	ldr	r3, [r7, #20]
 801afe2:	68db      	ldr	r3, [r3, #12]
 801afe4:	2b00      	cmp	r3, #0
 801afe6:	d100      	bne.n	801afea <TimerIrqHandler+0xb6>
 801afe8:	e7fe      	b.n	801afe8 <TimerIrqHandler+0xb4>
 801afea:	697b      	ldr	r3, [r7, #20]
 801afec:	68da      	ldr	r2, [r3, #12]
 801afee:	697b      	ldr	r3, [r7, #20]
 801aff0:	691b      	ldr	r3, [r3, #16]
 801aff2:	0018      	movs	r0, r3
 801aff4:	4790      	blx	r2
  while( ( TimerListHead != NULL ) && ( TimerListHead->Timestamp < HW_RTC_GetTimerElapsedTime(  )  ))
 801aff6:	4b10      	ldr	r3, [pc, #64]	; (801b038 <TimerIrqHandler+0x104>)
 801aff8:	681b      	ldr	r3, [r3, #0]
 801affa:	2b00      	cmp	r3, #0
 801affc:	d007      	beq.n	801b00e <TimerIrqHandler+0xda>
 801affe:	4b0e      	ldr	r3, [pc, #56]	; (801b038 <TimerIrqHandler+0x104>)
 801b000:	681b      	ldr	r3, [r3, #0]
 801b002:	681c      	ldr	r4, [r3, #0]
 801b004:	f000 fdea 	bl	801bbdc <HW_RTC_GetTimerElapsedTime>
 801b008:	0003      	movs	r3, r0
 801b00a:	429c      	cmp	r4, r3
 801b00c:	d3dd      	bcc.n	801afca <TimerIrqHandler+0x96>
  }

  /* start the next TimerListHead if it exists AND NOT running */
  if( ( TimerListHead != NULL ) && ( TimerListHead->IsNext2Expire == false ) )
 801b00e:	4b0a      	ldr	r3, [pc, #40]	; (801b038 <TimerIrqHandler+0x104>)
 801b010:	681b      	ldr	r3, [r3, #0]
 801b012:	2b00      	cmp	r3, #0
 801b014:	d00c      	beq.n	801b030 <TimerIrqHandler+0xfc>
 801b016:	4b08      	ldr	r3, [pc, #32]	; (801b038 <TimerIrqHandler+0x104>)
 801b018:	681b      	ldr	r3, [r3, #0]
 801b01a:	7a5b      	ldrb	r3, [r3, #9]
 801b01c:	2201      	movs	r2, #1
 801b01e:	4053      	eors	r3, r2
 801b020:	b2db      	uxtb	r3, r3
 801b022:	2b00      	cmp	r3, #0
 801b024:	d004      	beq.n	801b030 <TimerIrqHandler+0xfc>
  {
    TimerSetTimeout( TimerListHead );
 801b026:	4b04      	ldr	r3, [pc, #16]	; (801b038 <TimerIrqHandler+0x104>)
 801b028:	681b      	ldr	r3, [r3, #0]
 801b02a:	0018      	movs	r0, r3
 801b02c:	f000 f8f4 	bl	801b218 <TimerSetTimeout>
  }
}
 801b030:	46c0      	nop			; (mov r8, r8)
 801b032:	46bd      	mov	sp, r7
 801b034:	b007      	add	sp, #28
 801b036:	bd90      	pop	{r4, r7, pc}
 801b038:	20001350 	.word	0x20001350

0801b03c <TimerStop>:

void TimerStop( TimerEvent_t *obj ) 
{
 801b03c:	b580      	push	{r7, lr}
 801b03e:	b088      	sub	sp, #32
 801b040:	af00      	add	r7, sp, #0
 801b042:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801b044:	f3ef 8310 	mrs	r3, PRIMASK
 801b048:	613b      	str	r3, [r7, #16]
  return(result);
 801b04a:	693b      	ldr	r3, [r7, #16]
  BACKUP_PRIMASK();
 801b04c:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801b04e:	b672      	cpsid	i
}
 801b050:	46c0      	nop			; (mov r8, r8)
  
  DISABLE_IRQ( );
  
  TimerEvent_t* prev = TimerListHead;
 801b052:	4b38      	ldr	r3, [pc, #224]	; (801b134 <TimerStop+0xf8>)
 801b054:	681b      	ldr	r3, [r3, #0]
 801b056:	61fb      	str	r3, [r7, #28]
  TimerEvent_t* cur = TimerListHead;
 801b058:	4b36      	ldr	r3, [pc, #216]	; (801b134 <TimerStop+0xf8>)
 801b05a:	681b      	ldr	r3, [r3, #0]
 801b05c:	61bb      	str	r3, [r7, #24]

  // List is empty or the Obj to stop does not exist 
  if( ( TimerListHead == NULL ) || ( obj == NULL ) )
 801b05e:	4b35      	ldr	r3, [pc, #212]	; (801b134 <TimerStop+0xf8>)
 801b060:	681b      	ldr	r3, [r3, #0]
 801b062:	2b00      	cmp	r3, #0
 801b064:	d002      	beq.n	801b06c <TimerStop+0x30>
 801b066:	687b      	ldr	r3, [r7, #4]
 801b068:	2b00      	cmp	r3, #0
 801b06a:	d106      	bne.n	801b07a <TimerStop+0x3e>
 801b06c:	697b      	ldr	r3, [r7, #20]
 801b06e:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b070:	68fb      	ldr	r3, [r7, #12]
 801b072:	f383 8810 	msr	PRIMASK, r3
}
 801b076:	46c0      	nop			; (mov r8, r8)
  {
    RESTORE_PRIMASK( );
    return;
 801b078:	e058      	b.n	801b12c <TimerStop+0xf0>
  }

  obj->IsStarted = false;
 801b07a:	687b      	ldr	r3, [r7, #4]
 801b07c:	2200      	movs	r2, #0
 801b07e:	721a      	strb	r2, [r3, #8]

  if( TimerListHead == obj ) // Stop the Head                  
 801b080:	4b2c      	ldr	r3, [pc, #176]	; (801b134 <TimerStop+0xf8>)
 801b082:	681b      	ldr	r3, [r3, #0]
 801b084:	687a      	ldr	r2, [r7, #4]
 801b086:	429a      	cmp	r2, r3
 801b088:	d147      	bne.n	801b11a <TimerStop+0xde>
  {
    if( TimerListHead->IsNext2Expire == true ) // The head is already running 
 801b08a:	4b2a      	ldr	r3, [pc, #168]	; (801b134 <TimerStop+0xf8>)
 801b08c:	681b      	ldr	r3, [r3, #0]
 801b08e:	7a5b      	ldrb	r3, [r3, #9]
 801b090:	2b00      	cmp	r3, #0
 801b092:	d019      	beq.n	801b0c8 <TimerStop+0x8c>
    {  
	  
      TimerListHead->IsNext2Expire = false;
 801b094:	4b27      	ldr	r3, [pc, #156]	; (801b134 <TimerStop+0xf8>)
 801b096:	681b      	ldr	r3, [r3, #0]
 801b098:	2200      	movs	r2, #0
 801b09a:	725a      	strb	r2, [r3, #9]
      if( TimerListHead->Next != NULL )
 801b09c:	4b25      	ldr	r3, [pc, #148]	; (801b134 <TimerStop+0xf8>)
 801b09e:	681b      	ldr	r3, [r3, #0]
 801b0a0:	695b      	ldr	r3, [r3, #20]
 801b0a2:	2b00      	cmp	r3, #0
 801b0a4:	d00a      	beq.n	801b0bc <TimerStop+0x80>
      {
        TimerListHead = TimerListHead->Next;
 801b0a6:	4b23      	ldr	r3, [pc, #140]	; (801b134 <TimerStop+0xf8>)
 801b0a8:	681b      	ldr	r3, [r3, #0]
 801b0aa:	695a      	ldr	r2, [r3, #20]
 801b0ac:	4b21      	ldr	r3, [pc, #132]	; (801b134 <TimerStop+0xf8>)
 801b0ae:	601a      	str	r2, [r3, #0]
        TimerSetTimeout( TimerListHead );
 801b0b0:	4b20      	ldr	r3, [pc, #128]	; (801b134 <TimerStop+0xf8>)
 801b0b2:	681b      	ldr	r3, [r3, #0]
 801b0b4:	0018      	movs	r0, r3
 801b0b6:	f000 f8af 	bl	801b218 <TimerSetTimeout>
 801b0ba:	e031      	b.n	801b120 <TimerStop+0xe4>
      }
      else
      {
        HW_RTC_StopAlarm( );
 801b0bc:	f000 fdba 	bl	801bc34 <HW_RTC_StopAlarm>
        TimerListHead = NULL;
 801b0c0:	4b1c      	ldr	r3, [pc, #112]	; (801b134 <TimerStop+0xf8>)
 801b0c2:	2200      	movs	r2, #0
 801b0c4:	601a      	str	r2, [r3, #0]
 801b0c6:	e02b      	b.n	801b120 <TimerStop+0xe4>
      }
    }
    else // Stop the head before it is started
    {   
      if( TimerListHead->Next != NULL )   
 801b0c8:	4b1a      	ldr	r3, [pc, #104]	; (801b134 <TimerStop+0xf8>)
 801b0ca:	681b      	ldr	r3, [r3, #0]
 801b0cc:	695b      	ldr	r3, [r3, #20]
 801b0ce:	2b00      	cmp	r3, #0
 801b0d0:	d005      	beq.n	801b0de <TimerStop+0xa2>
      {
        TimerListHead = TimerListHead->Next;
 801b0d2:	4b18      	ldr	r3, [pc, #96]	; (801b134 <TimerStop+0xf8>)
 801b0d4:	681b      	ldr	r3, [r3, #0]
 801b0d6:	695a      	ldr	r2, [r3, #20]
 801b0d8:	4b16      	ldr	r3, [pc, #88]	; (801b134 <TimerStop+0xf8>)
 801b0da:	601a      	str	r2, [r3, #0]
 801b0dc:	e020      	b.n	801b120 <TimerStop+0xe4>
      }
      else
      {
        TimerListHead = NULL;
 801b0de:	4b15      	ldr	r3, [pc, #84]	; (801b134 <TimerStop+0xf8>)
 801b0e0:	2200      	movs	r2, #0
 801b0e2:	601a      	str	r2, [r3, #0]
 801b0e4:	e01c      	b.n	801b120 <TimerStop+0xe4>
  }
  else // Stop an object within the list
  {      
    while( cur != NULL )
    {
      if( cur == obj )
 801b0e6:	69ba      	ldr	r2, [r7, #24]
 801b0e8:	687b      	ldr	r3, [r7, #4]
 801b0ea:	429a      	cmp	r2, r3
 801b0ec:	d110      	bne.n	801b110 <TimerStop+0xd4>
      {
        if( cur->Next != NULL )
 801b0ee:	69bb      	ldr	r3, [r7, #24]
 801b0f0:	695b      	ldr	r3, [r3, #20]
 801b0f2:	2b00      	cmp	r3, #0
 801b0f4:	d006      	beq.n	801b104 <TimerStop+0xc8>
        {
          cur = cur->Next;
 801b0f6:	69bb      	ldr	r3, [r7, #24]
 801b0f8:	695b      	ldr	r3, [r3, #20]
 801b0fa:	61bb      	str	r3, [r7, #24]
          prev->Next = cur;
 801b0fc:	69fb      	ldr	r3, [r7, #28]
 801b0fe:	69ba      	ldr	r2, [r7, #24]
 801b100:	615a      	str	r2, [r3, #20]
        else
        {
          cur = NULL;
          prev->Next = cur;
        }
        break;
 801b102:	e00d      	b.n	801b120 <TimerStop+0xe4>
          cur = NULL;
 801b104:	2300      	movs	r3, #0
 801b106:	61bb      	str	r3, [r7, #24]
          prev->Next = cur;
 801b108:	69fb      	ldr	r3, [r7, #28]
 801b10a:	69ba      	ldr	r2, [r7, #24]
 801b10c:	615a      	str	r2, [r3, #20]
        break;
 801b10e:	e007      	b.n	801b120 <TimerStop+0xe4>
      }
      else
      {
        prev = cur;
 801b110:	69bb      	ldr	r3, [r7, #24]
 801b112:	61fb      	str	r3, [r7, #28]
        cur = cur->Next;
 801b114:	69bb      	ldr	r3, [r7, #24]
 801b116:	695b      	ldr	r3, [r3, #20]
 801b118:	61bb      	str	r3, [r7, #24]
    while( cur != NULL )
 801b11a:	69bb      	ldr	r3, [r7, #24]
 801b11c:	2b00      	cmp	r3, #0
 801b11e:	d1e2      	bne.n	801b0e6 <TimerStop+0xaa>
 801b120:	697b      	ldr	r3, [r7, #20]
 801b122:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b124:	68bb      	ldr	r3, [r7, #8]
 801b126:	f383 8810 	msr	PRIMASK, r3
}
 801b12a:	46c0      	nop			; (mov r8, r8)
      }
    }   
  }
  
  RESTORE_PRIMASK( );
}  
 801b12c:	46bd      	mov	sp, r7
 801b12e:	b008      	add	sp, #32
 801b130:	bd80      	pop	{r7, pc}
 801b132:	46c0      	nop			; (mov r8, r8)
 801b134:	20001350 	.word	0x20001350

0801b138 <TimerSetValue>:
  TimerStop( obj );
  TimerStart( obj );
}

void TimerSetValue( TimerEvent_t *obj, uint32_t value )
{
 801b138:	b580      	push	{r7, lr}
 801b13a:	b084      	sub	sp, #16
 801b13c:	af00      	add	r7, sp, #0
 801b13e:	6078      	str	r0, [r7, #4]
 801b140:	6039      	str	r1, [r7, #0]
  uint32_t minValue = 0;
 801b142:	2300      	movs	r3, #0
 801b144:	60bb      	str	r3, [r7, #8]
  uint32_t ticks = HW_RTC_ms2Tick( value );
 801b146:	683b      	ldr	r3, [r7, #0]
 801b148:	0018      	movs	r0, r3
 801b14a:	f000 fcdd 	bl	801bb08 <HW_RTC_ms2Tick>
 801b14e:	0003      	movs	r3, r0
 801b150:	60fb      	str	r3, [r7, #12]

  TimerStop( obj );
 801b152:	687b      	ldr	r3, [r7, #4]
 801b154:	0018      	movs	r0, r3
 801b156:	f7ff ff71 	bl	801b03c <TimerStop>

  minValue = HW_RTC_GetMinimumTimeout( );
 801b15a:	f000 fccf 	bl	801bafc <HW_RTC_GetMinimumTimeout>
 801b15e:	0003      	movs	r3, r0
 801b160:	60bb      	str	r3, [r7, #8]
  
  if( ticks < minValue )
 801b162:	68fa      	ldr	r2, [r7, #12]
 801b164:	68bb      	ldr	r3, [r7, #8]
 801b166:	429a      	cmp	r2, r3
 801b168:	d201      	bcs.n	801b16e <TimerSetValue+0x36>
  {
    ticks = minValue;
 801b16a:	68bb      	ldr	r3, [r7, #8]
 801b16c:	60fb      	str	r3, [r7, #12]
  }

  obj->Timestamp = ticks;
 801b16e:	687b      	ldr	r3, [r7, #4]
 801b170:	68fa      	ldr	r2, [r7, #12]
 801b172:	601a      	str	r2, [r3, #0]
  obj->ReloadValue = ticks;
 801b174:	687b      	ldr	r3, [r7, #4]
 801b176:	68fa      	ldr	r2, [r7, #12]
 801b178:	605a      	str	r2, [r3, #4]
}
 801b17a:	46c0      	nop			; (mov r8, r8)
 801b17c:	46bd      	mov	sp, r7
 801b17e:	b004      	add	sp, #16
 801b180:	bd80      	pop	{r7, pc}

0801b182 <TimerGetCurrentTime>:

TimerTime_t TimerGetCurrentTime( void )
{
 801b182:	b580      	push	{r7, lr}
 801b184:	b082      	sub	sp, #8
 801b186:	af00      	add	r7, sp, #0
  uint32_t now = HW_RTC_GetTimerValue( );
 801b188:	f000 fd40 	bl	801bc0c <HW_RTC_GetTimerValue>
 801b18c:	0003      	movs	r3, r0
 801b18e:	607b      	str	r3, [r7, #4]
  return  HW_RTC_Tick2ms(now);
 801b190:	687b      	ldr	r3, [r7, #4]
 801b192:	0018      	movs	r0, r3
 801b194:	f000 fcd1 	bl	801bb3a <HW_RTC_Tick2ms>
 801b198:	0003      	movs	r3, r0
}
 801b19a:	0018      	movs	r0, r3
 801b19c:	46bd      	mov	sp, r7
 801b19e:	b002      	add	sp, #8
 801b1a0:	bd80      	pop	{r7, pc}

0801b1a2 <TimerGetElapsedTime>:

TimerTime_t TimerGetElapsedTime( TimerTime_t past )
{
 801b1a2:	b580      	push	{r7, lr}
 801b1a4:	b084      	sub	sp, #16
 801b1a6:	af00      	add	r7, sp, #0
 801b1a8:	6078      	str	r0, [r7, #4]
  if ( past == 0 )
 801b1aa:	687b      	ldr	r3, [r7, #4]
 801b1ac:	2b00      	cmp	r3, #0
 801b1ae:	d101      	bne.n	801b1b4 <TimerGetElapsedTime+0x12>
  {
    return 0;
 801b1b0:	2300      	movs	r3, #0
 801b1b2:	e010      	b.n	801b1d6 <TimerGetElapsedTime+0x34>
  }
  uint32_t nowInTicks = HW_RTC_GetTimerValue( );
 801b1b4:	f000 fd2a 	bl	801bc0c <HW_RTC_GetTimerValue>
 801b1b8:	0003      	movs	r3, r0
 801b1ba:	60fb      	str	r3, [r7, #12]
  uint32_t pastInTicks = HW_RTC_ms2Tick( past );
 801b1bc:	687b      	ldr	r3, [r7, #4]
 801b1be:	0018      	movs	r0, r3
 801b1c0:	f000 fca2 	bl	801bb08 <HW_RTC_ms2Tick>
 801b1c4:	0003      	movs	r3, r0
 801b1c6:	60bb      	str	r3, [r7, #8]
  /* intentional wrap around. Works Ok if tick duation below 1ms */
  return HW_RTC_Tick2ms( nowInTicks- pastInTicks );
 801b1c8:	68fa      	ldr	r2, [r7, #12]
 801b1ca:	68bb      	ldr	r3, [r7, #8]
 801b1cc:	1ad3      	subs	r3, r2, r3
 801b1ce:	0018      	movs	r0, r3
 801b1d0:	f000 fcb3 	bl	801bb3a <HW_RTC_Tick2ms>
 801b1d4:	0003      	movs	r3, r0
}
 801b1d6:	0018      	movs	r0, r3
 801b1d8:	46bd      	mov	sp, r7
 801b1da:	b004      	add	sp, #16
 801b1dc:	bd80      	pop	{r7, pc}
	...

0801b1e0 <TimerExists>:

static bool TimerExists( TimerEvent_t *obj )
{
 801b1e0:	b580      	push	{r7, lr}
 801b1e2:	b084      	sub	sp, #16
 801b1e4:	af00      	add	r7, sp, #0
 801b1e6:	6078      	str	r0, [r7, #4]
  TimerEvent_t* cur = TimerListHead;
 801b1e8:	4b0a      	ldr	r3, [pc, #40]	; (801b214 <TimerExists+0x34>)
 801b1ea:	681b      	ldr	r3, [r3, #0]
 801b1ec:	60fb      	str	r3, [r7, #12]

  while( cur != NULL )
 801b1ee:	e008      	b.n	801b202 <TimerExists+0x22>
  {
    if( cur == obj )
 801b1f0:	68fa      	ldr	r2, [r7, #12]
 801b1f2:	687b      	ldr	r3, [r7, #4]
 801b1f4:	429a      	cmp	r2, r3
 801b1f6:	d101      	bne.n	801b1fc <TimerExists+0x1c>
    {
      return true;
 801b1f8:	2301      	movs	r3, #1
 801b1fa:	e006      	b.n	801b20a <TimerExists+0x2a>
    }
    cur = cur->Next;
 801b1fc:	68fb      	ldr	r3, [r7, #12]
 801b1fe:	695b      	ldr	r3, [r3, #20]
 801b200:	60fb      	str	r3, [r7, #12]
  while( cur != NULL )
 801b202:	68fb      	ldr	r3, [r7, #12]
 801b204:	2b00      	cmp	r3, #0
 801b206:	d1f3      	bne.n	801b1f0 <TimerExists+0x10>
  }
  return false;
 801b208:	2300      	movs	r3, #0
}
 801b20a:	0018      	movs	r0, r3
 801b20c:	46bd      	mov	sp, r7
 801b20e:	b004      	add	sp, #16
 801b210:	bd80      	pop	{r7, pc}
 801b212:	46c0      	nop			; (mov r8, r8)
 801b214:	20001350 	.word	0x20001350

0801b218 <TimerSetTimeout>:
static void TimerSetTimeout( TimerEvent_t *obj )
{
 801b218:	b590      	push	{r4, r7, lr}
 801b21a:	b085      	sub	sp, #20
 801b21c:	af00      	add	r7, sp, #0
 801b21e:	6078      	str	r0, [r7, #4]
  int32_t minTicks= HW_RTC_GetMinimumTimeout( );
 801b220:	f000 fc6c 	bl	801bafc <HW_RTC_GetMinimumTimeout>
 801b224:	0003      	movs	r3, r0
 801b226:	60fb      	str	r3, [r7, #12]
  obj->IsNext2Expire = true; 
 801b228:	687b      	ldr	r3, [r7, #4]
 801b22a:	2201      	movs	r2, #1
 801b22c:	725a      	strb	r2, [r3, #9]

  // In case deadline too soon
  if(obj->Timestamp  < (HW_RTC_GetTimerElapsedTime(  ) + minTicks) )
 801b22e:	687b      	ldr	r3, [r7, #4]
 801b230:	681c      	ldr	r4, [r3, #0]
 801b232:	f000 fcd3 	bl	801bbdc <HW_RTC_GetTimerElapsedTime>
 801b236:	0002      	movs	r2, r0
 801b238:	68fb      	ldr	r3, [r7, #12]
 801b23a:	18d3      	adds	r3, r2, r3
 801b23c:	429c      	cmp	r4, r3
 801b23e:	d206      	bcs.n	801b24e <TimerSetTimeout+0x36>
  {
    obj->Timestamp = HW_RTC_GetTimerElapsedTime(  ) + minTicks;
 801b240:	f000 fccc 	bl	801bbdc <HW_RTC_GetTimerElapsedTime>
 801b244:	0002      	movs	r2, r0
 801b246:	68fb      	ldr	r3, [r7, #12]
 801b248:	18d2      	adds	r2, r2, r3
 801b24a:	687b      	ldr	r3, [r7, #4]
 801b24c:	601a      	str	r2, [r3, #0]
  }
  HW_RTC_SetAlarm( obj->Timestamp );
 801b24e:	687b      	ldr	r3, [r7, #4]
 801b250:	681b      	ldr	r3, [r3, #0]
 801b252:	0018      	movs	r0, r3
 801b254:	f000 fc92 	bl	801bb7c <HW_RTC_SetAlarm>
}
 801b258:	46c0      	nop			; (mov r8, r8)
 801b25a:	46bd      	mov	sp, r7
 801b25c:	b005      	add	sp, #20
 801b25e:	bd90      	pop	{r4, r7, pc}

0801b260 <TimerInsertTimer>:
    return RtcTempCompensation( period, temperature );
}


static void TimerInsertTimer( TimerEvent_t *obj)
{
 801b260:	b580      	push	{r7, lr}
 801b262:	b084      	sub	sp, #16
 801b264:	af00      	add	r7, sp, #0
 801b266:	6078      	str	r0, [r7, #4]
  TimerEvent_t* cur = TimerListHead;
 801b268:	4b13      	ldr	r3, [pc, #76]	; (801b2b8 <TimerInsertTimer+0x58>)
 801b26a:	681b      	ldr	r3, [r3, #0]
 801b26c:	60fb      	str	r3, [r7, #12]
  TimerEvent_t* next = TimerListHead->Next;
 801b26e:	4b12      	ldr	r3, [pc, #72]	; (801b2b8 <TimerInsertTimer+0x58>)
 801b270:	681b      	ldr	r3, [r3, #0]
 801b272:	695b      	ldr	r3, [r3, #20]
 801b274:	60bb      	str	r3, [r7, #8]

  while (cur->Next != NULL )
 801b276:	e012      	b.n	801b29e <TimerInsertTimer+0x3e>
  {  
    if( obj->Timestamp  > next->Timestamp )
 801b278:	687b      	ldr	r3, [r7, #4]
 801b27a:	681a      	ldr	r2, [r3, #0]
 801b27c:	68bb      	ldr	r3, [r7, #8]
 801b27e:	681b      	ldr	r3, [r3, #0]
 801b280:	429a      	cmp	r2, r3
 801b282:	d905      	bls.n	801b290 <TimerInsertTimer+0x30>
    {
        cur = next;
 801b284:	68bb      	ldr	r3, [r7, #8]
 801b286:	60fb      	str	r3, [r7, #12]
        next = next->Next;
 801b288:	68bb      	ldr	r3, [r7, #8]
 801b28a:	695b      	ldr	r3, [r3, #20]
 801b28c:	60bb      	str	r3, [r7, #8]
 801b28e:	e006      	b.n	801b29e <TimerInsertTimer+0x3e>
    }
    else
    {
        cur->Next = obj;
 801b290:	68fb      	ldr	r3, [r7, #12]
 801b292:	687a      	ldr	r2, [r7, #4]
 801b294:	615a      	str	r2, [r3, #20]
        obj->Next = next;
 801b296:	687b      	ldr	r3, [r7, #4]
 801b298:	68ba      	ldr	r2, [r7, #8]
 801b29a:	615a      	str	r2, [r3, #20]
        return;
 801b29c:	e009      	b.n	801b2b2 <TimerInsertTimer+0x52>
  while (cur->Next != NULL )
 801b29e:	68fb      	ldr	r3, [r7, #12]
 801b2a0:	695b      	ldr	r3, [r3, #20]
 801b2a2:	2b00      	cmp	r3, #0
 801b2a4:	d1e8      	bne.n	801b278 <TimerInsertTimer+0x18>

    }
  }
  cur->Next = obj;
 801b2a6:	68fb      	ldr	r3, [r7, #12]
 801b2a8:	687a      	ldr	r2, [r7, #4]
 801b2aa:	615a      	str	r2, [r3, #20]
  obj->Next = NULL;
 801b2ac:	687b      	ldr	r3, [r7, #4]
 801b2ae:	2200      	movs	r2, #0
 801b2b0:	615a      	str	r2, [r3, #20]
}
 801b2b2:	46bd      	mov	sp, r7
 801b2b4:	b004      	add	sp, #16
 801b2b6:	bd80      	pop	{r7, pc}
 801b2b8:	20001350 	.word	0x20001350

0801b2bc <TimerInsertNewHeadTimer>:

static void TimerInsertNewHeadTimer( TimerEvent_t *obj )
{
 801b2bc:	b580      	push	{r7, lr}
 801b2be:	b084      	sub	sp, #16
 801b2c0:	af00      	add	r7, sp, #0
 801b2c2:	6078      	str	r0, [r7, #4]
  TimerEvent_t* cur = TimerListHead;
 801b2c4:	4b0b      	ldr	r3, [pc, #44]	; (801b2f4 <TimerInsertNewHeadTimer+0x38>)
 801b2c6:	681b      	ldr	r3, [r3, #0]
 801b2c8:	60fb      	str	r3, [r7, #12]

  if( cur != NULL )
 801b2ca:	68fb      	ldr	r3, [r7, #12]
 801b2cc:	2b00      	cmp	r3, #0
 801b2ce:	d002      	beq.n	801b2d6 <TimerInsertNewHeadTimer+0x1a>
  {
    cur->IsNext2Expire = false;
 801b2d0:	68fb      	ldr	r3, [r7, #12]
 801b2d2:	2200      	movs	r2, #0
 801b2d4:	725a      	strb	r2, [r3, #9]
  }

  obj->Next = cur;
 801b2d6:	687b      	ldr	r3, [r7, #4]
 801b2d8:	68fa      	ldr	r2, [r7, #12]
 801b2da:	615a      	str	r2, [r3, #20]
  TimerListHead = obj;
 801b2dc:	4b05      	ldr	r3, [pc, #20]	; (801b2f4 <TimerInsertNewHeadTimer+0x38>)
 801b2de:	687a      	ldr	r2, [r7, #4]
 801b2e0:	601a      	str	r2, [r3, #0]
  TimerSetTimeout( TimerListHead );
 801b2e2:	4b04      	ldr	r3, [pc, #16]	; (801b2f4 <TimerInsertNewHeadTimer+0x38>)
 801b2e4:	681b      	ldr	r3, [r3, #0]
 801b2e6:	0018      	movs	r0, r3
 801b2e8:	f7ff ff96 	bl	801b218 <TimerSetTimeout>
}
 801b2ec:	46c0      	nop			; (mov r8, r8)
 801b2ee:	46bd      	mov	sp, r7
 801b2f0:	b004      	add	sp, #16
 801b2f2:	bd80      	pop	{r7, pc}
 801b2f4:	20001350 	.word	0x20001350

0801b2f8 <TraceInit>:
 */
static void Trace_TxCpltCallback(void);

/* Functions Definition ------------------------------------------------------*/
void TraceInit( void )
{
 801b2f8:	b580      	push	{r7, lr}
 801b2fa:	af00      	add	r7, sp, #0
  OutputInit(Trace_TxCpltCallback);
 801b2fc:	4b06      	ldr	r3, [pc, #24]	; (801b318 <TraceInit+0x20>)
 801b2fe:	0018      	movs	r0, r3
 801b300:	f001 ffe0 	bl	801d2c4 <vcom_Init>

  circular_queue_init(&MsgTraceQueue, MsgTraceQueueBuff, DBG_TRACE_MSG_QUEUE_SIZE);
 801b304:	2380      	movs	r3, #128	; 0x80
 801b306:	005a      	lsls	r2, r3, #1
 801b308:	4904      	ldr	r1, [pc, #16]	; (801b31c <TraceInit+0x24>)
 801b30a:	4b05      	ldr	r3, [pc, #20]	; (801b320 <TraceInit+0x28>)
 801b30c:	0018      	movs	r0, r3
 801b30e:	f7ff fa3b 	bl	801a788 <circular_queue_init>

  return;
 801b312:	46c0      	nop			; (mov r8, r8)
}
 801b314:	46bd      	mov	sp, r7
 801b316:	bd80      	pop	{r7, pc}
 801b318:	0801b445 	.word	0x0801b445
 801b31c:	20001364 	.word	0x20001364
 801b320:	20001354 	.word	0x20001354

0801b324 <TraceSend>:

int32_t TraceSend( const char *strFormat, ...)
{
 801b324:	b40f      	push	{r0, r1, r2, r3}
 801b326:	b5f0      	push	{r4, r5, r6, r7, lr}
 801b328:	b0c9      	sub	sp, #292	; 0x124
 801b32a:	af00      	add	r7, sp, #0
  char buf[TEMPBUFSIZE];
  va_list vaArgs;
  uint8_t* buffer;
  va_start( vaArgs, strFormat);
 801b32c:	2396      	movs	r3, #150	; 0x96
 801b32e:	005b      	lsls	r3, r3, #1
 801b330:	2210      	movs	r2, #16
 801b332:	4694      	mov	ip, r2
 801b334:	44bc      	add	ip, r7
 801b336:	4463      	add	r3, ip
 801b338:	60bb      	str	r3, [r7, #8]
  uint16_t bufSize=vsnprintf(buf,TEMPBUFSIZE,strFormat, vaArgs);
 801b33a:	68bb      	ldr	r3, [r7, #8]
 801b33c:	2294      	movs	r2, #148	; 0x94
 801b33e:	0052      	lsls	r2, r2, #1
 801b340:	2110      	movs	r1, #16
 801b342:	468c      	mov	ip, r1
 801b344:	44bc      	add	ip, r7
 801b346:	4462      	add	r2, ip
 801b348:	6812      	ldr	r2, [r2, #0]
 801b34a:	2180      	movs	r1, #128	; 0x80
 801b34c:	0049      	lsls	r1, r1, #1
 801b34e:	250c      	movs	r5, #12
 801b350:	1978      	adds	r0, r7, r5
 801b352:	f002 f94d 	bl	801d5f0 <vsniprintf>
 801b356:	0003      	movs	r3, r0
 801b358:	b29a      	uxth	r2, r3
 801b35a:	4b37      	ldr	r3, [pc, #220]	; (801b438 <TraceSend+0x114>)
 801b35c:	2190      	movs	r1, #144	; 0x90
 801b35e:	0049      	lsls	r1, r1, #1
 801b360:	468c      	mov	ip, r1
 801b362:	44bc      	add	ip, r7
 801b364:	4463      	add	r3, ip
 801b366:	801a      	strh	r2, [r3, #0]
  va_end(vaArgs);
  int status=0;
 801b368:	2300      	movs	r3, #0
 801b36a:	248e      	movs	r4, #142	; 0x8e
 801b36c:	0064      	lsls	r4, r4, #1
 801b36e:	193a      	adds	r2, r7, r4
 801b370:	6013      	str	r3, [r2, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801b372:	f3ef 8310 	mrs	r3, PRIMASK
 801b376:	228a      	movs	r2, #138	; 0x8a
 801b378:	0052      	lsls	r2, r2, #1
 801b37a:	18b9      	adds	r1, r7, r2
 801b37c:	600b      	str	r3, [r1, #0]
  return(result);
 801b37e:	18bb      	adds	r3, r7, r2
 801b380:	681b      	ldr	r3, [r3, #0]
  
  BACKUP_PRIMASK();
 801b382:	268c      	movs	r6, #140	; 0x8c
 801b384:	0076      	lsls	r6, r6, #1
 801b386:	19ba      	adds	r2, r7, r6
 801b388:	6013      	str	r3, [r2, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 801b38a:	b672      	cpsid	i
}
 801b38c:	46c0      	nop			; (mov r8, r8)
  
  DISABLE_IRQ(); /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  //DBG_GPIO_SET(GPIOB, GPIO_PIN_15);
  //DBG_GPIO_RST(GPIOB, GPIO_PIN_15);
  status =circular_queue_add(&MsgTraceQueue,(uint8_t*)buf, bufSize);
 801b38e:	4b2a      	ldr	r3, [pc, #168]	; (801b438 <TraceSend+0x114>)
 801b390:	2290      	movs	r2, #144	; 0x90
 801b392:	0052      	lsls	r2, r2, #1
 801b394:	4694      	mov	ip, r2
 801b396:	44bc      	add	ip, r7
 801b398:	4463      	add	r3, ip
 801b39a:	881a      	ldrh	r2, [r3, #0]
 801b39c:	1979      	adds	r1, r7, r5
 801b39e:	4b27      	ldr	r3, [pc, #156]	; (801b43c <TraceSend+0x118>)
 801b3a0:	0018      	movs	r0, r3
 801b3a2:	f7ff fa0f 	bl	801a7c4 <circular_queue_add>
 801b3a6:	0003      	movs	r3, r0
 801b3a8:	193a      	adds	r2, r7, r4
 801b3aa:	6013      	str	r3, [r2, #0]
  
  if ((status==0 ) && (TracePeripheralReady==SET))
 801b3ac:	193b      	adds	r3, r7, r4
 801b3ae:	681b      	ldr	r3, [r3, #0]
 801b3b0:	2b00      	cmp	r3, #0
 801b3b2:	d129      	bne.n	801b408 <TraceSend+0xe4>
 801b3b4:	4b22      	ldr	r3, [pc, #136]	; (801b440 <TraceSend+0x11c>)
 801b3b6:	781b      	ldrb	r3, [r3, #0]
 801b3b8:	b2db      	uxtb	r3, r3
 801b3ba:	2b01      	cmp	r3, #1
 801b3bc:	d124      	bne.n	801b408 <TraceSend+0xe4>
  {
    circular_queue_get(&MsgTraceQueue,&buffer,&bufSize);
 801b3be:	1cba      	adds	r2, r7, #2
 801b3c0:	1d39      	adds	r1, r7, #4
 801b3c2:	4b1e      	ldr	r3, [pc, #120]	; (801b43c <TraceSend+0x118>)
 801b3c4:	0018      	movs	r0, r3
 801b3c6:	f7ff fac2 	bl	801a94e <circular_queue_get>
    TracePeripheralReady = RESET;
 801b3ca:	4b1d      	ldr	r3, [pc, #116]	; (801b440 <TraceSend+0x11c>)
 801b3cc:	2200      	movs	r2, #0
 801b3ce:	701a      	strb	r2, [r3, #0]
    //DBG_GPIO_RST(GPIOB, GPIO_PIN_12);
    LPM_SetStopMode(LPM_UART_TX_Id , LPM_Disable );
 801b3d0:	2101      	movs	r1, #1
 801b3d2:	2020      	movs	r0, #32
 801b3d4:	f7ff f972 	bl	801a6bc <LPM_SetStopMode>
 801b3d8:	19bb      	adds	r3, r7, r6
 801b3da:	681b      	ldr	r3, [r3, #0]
 801b3dc:	2288      	movs	r2, #136	; 0x88
 801b3de:	0052      	lsls	r2, r2, #1
 801b3e0:	18b9      	adds	r1, r7, r2
 801b3e2:	600b      	str	r3, [r1, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b3e4:	18bb      	adds	r3, r7, r2
 801b3e6:	681b      	ldr	r3, [r3, #0]
 801b3e8:	f383 8810 	msr	PRIMASK, r3
}
 801b3ec:	46c0      	nop			; (mov r8, r8)

    RESTORE_PRIMASK();
    OutputTrace(buffer, bufSize);
 801b3ee:	687a      	ldr	r2, [r7, #4]
 801b3f0:	4b11      	ldr	r3, [pc, #68]	; (801b438 <TraceSend+0x114>)
 801b3f2:	2190      	movs	r1, #144	; 0x90
 801b3f4:	0049      	lsls	r1, r1, #1
 801b3f6:	468c      	mov	ip, r1
 801b3f8:	44bc      	add	ip, r7
 801b3fa:	4463      	add	r3, ip
 801b3fc:	881b      	ldrh	r3, [r3, #0]
 801b3fe:	0019      	movs	r1, r3
 801b400:	0010      	movs	r0, r2
 801b402:	f001 ff8f 	bl	801d324 <vcom_Trace>
 801b406:	e00c      	b.n	801b422 <TraceSend+0xfe>
 801b408:	238c      	movs	r3, #140	; 0x8c
 801b40a:	005b      	lsls	r3, r3, #1
 801b40c:	18fb      	adds	r3, r7, r3
 801b40e:	681b      	ldr	r3, [r3, #0]
 801b410:	2286      	movs	r2, #134	; 0x86
 801b412:	0052      	lsls	r2, r2, #1
 801b414:	18b9      	adds	r1, r7, r2
 801b416:	600b      	str	r3, [r1, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b418:	18bb      	adds	r3, r7, r2
 801b41a:	681b      	ldr	r3, [r3, #0]
 801b41c:	f383 8810 	msr	PRIMASK, r3
}
 801b420:	46c0      	nop			; (mov r8, r8)
  else
  {
    RESTORE_PRIMASK();
  }
  
  return status;
 801b422:	238e      	movs	r3, #142	; 0x8e
 801b424:	005b      	lsls	r3, r3, #1
 801b426:	18fb      	adds	r3, r7, r3
 801b428:	681b      	ldr	r3, [r3, #0]
}
 801b42a:	0018      	movs	r0, r3
 801b42c:	46bd      	mov	sp, r7
 801b42e:	b049      	add	sp, #292	; 0x124
 801b430:	bcf0      	pop	{r4, r5, r6, r7}
 801b432:	bc08      	pop	{r3}
 801b434:	b004      	add	sp, #16
 801b436:	4718      	bx	r3
 801b438:	fffffee2 	.word	0xfffffee2
 801b43c:	20001354 	.word	0x20001354
 801b440:	20000298 	.word	0x20000298

0801b444 <Trace_TxCpltCallback>:
}

/* Private Functions Definition ------------------------------------------------------*/

static void Trace_TxCpltCallback(void)
{
 801b444:	b580      	push	{r7, lr}
 801b446:	b088      	sub	sp, #32
 801b448:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801b44a:	f3ef 8310 	mrs	r3, PRIMASK
 801b44e:	617b      	str	r3, [r7, #20]
  return(result);
 801b450:	697b      	ldr	r3, [r7, #20]
  int status;
  uint8_t* buffer;
  uint16_t bufSize;

  BACKUP_PRIMASK();
 801b452:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("cpsid i" : : : "memory");
 801b454:	b672      	cpsid	i
}
 801b456:	46c0      	nop			; (mov r8, r8)

  DISABLE_IRQ(); /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  /* Remove element just sent to UART */
  circular_queue_remove(&MsgTraceQueue);
 801b458:	4b19      	ldr	r3, [pc, #100]	; (801b4c0 <Trace_TxCpltCallback+0x7c>)
 801b45a:	0018      	movs	r0, r3
 801b45c:	f7ff facf 	bl	801a9fe <circular_queue_remove>
  //DBG_GPIO_SET(GPIOB, GPIO_PIN_13);
  //DBG_GPIO_RST(GPIOB, GPIO_PIN_13);
  /* Sense if new data to be sent */
  status=circular_queue_sense(&MsgTraceQueue);
 801b460:	4b17      	ldr	r3, [pc, #92]	; (801b4c0 <Trace_TxCpltCallback+0x7c>)
 801b462:	0018      	movs	r0, r3
 801b464:	f7ff fb2b 	bl	801aabe <circular_queue_sense>
 801b468:	0003      	movs	r3, r0
 801b46a:	61bb      	str	r3, [r7, #24]

  if ( status == 0) 
 801b46c:	69bb      	ldr	r3, [r7, #24]
 801b46e:	2b00      	cmp	r3, #0
 801b470:	d114      	bne.n	801b49c <Trace_TxCpltCallback+0x58>
  {
    circular_queue_get(&MsgTraceQueue,&buffer,&bufSize);
 801b472:	1dba      	adds	r2, r7, #6
 801b474:	2308      	movs	r3, #8
 801b476:	18f9      	adds	r1, r7, r3
 801b478:	4b11      	ldr	r3, [pc, #68]	; (801b4c0 <Trace_TxCpltCallback+0x7c>)
 801b47a:	0018      	movs	r0, r3
 801b47c:	f7ff fa67 	bl	801a94e <circular_queue_get>
 801b480:	69fb      	ldr	r3, [r7, #28]
 801b482:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b484:	693b      	ldr	r3, [r7, #16]
 801b486:	f383 8810 	msr	PRIMASK, r3
}
 801b48a:	46c0      	nop			; (mov r8, r8)
    RESTORE_PRIMASK();
    //DBG_GPIO_SET(GPIOB, GPIO_PIN_14);
    //DBG_GPIO_RST(GPIOB, GPIO_PIN_14);
    OutputTrace(buffer, bufSize);
 801b48c:	68ba      	ldr	r2, [r7, #8]
 801b48e:	1dbb      	adds	r3, r7, #6
 801b490:	881b      	ldrh	r3, [r3, #0]
 801b492:	0019      	movs	r1, r3
 801b494:	0010      	movs	r0, r2
 801b496:	f001 ff45 	bl	801d324 <vcom_Trace>

    LPM_SetStopMode(LPM_UART_TX_Id , LPM_Enable );
    TracePeripheralReady = SET;
    RESTORE_PRIMASK();
  }
}
 801b49a:	e00c      	b.n	801b4b6 <Trace_TxCpltCallback+0x72>
    LPM_SetStopMode(LPM_UART_TX_Id , LPM_Enable );
 801b49c:	2100      	movs	r1, #0
 801b49e:	2020      	movs	r0, #32
 801b4a0:	f7ff f90c 	bl	801a6bc <LPM_SetStopMode>
    TracePeripheralReady = SET;
 801b4a4:	4b07      	ldr	r3, [pc, #28]	; (801b4c4 <Trace_TxCpltCallback+0x80>)
 801b4a6:	2201      	movs	r2, #1
 801b4a8:	701a      	strb	r2, [r3, #0]
 801b4aa:	69fb      	ldr	r3, [r7, #28]
 801b4ac:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801b4ae:	68fb      	ldr	r3, [r7, #12]
 801b4b0:	f383 8810 	msr	PRIMASK, r3
}
 801b4b4:	46c0      	nop			; (mov r8, r8)
}
 801b4b6:	46c0      	nop			; (mov r8, r8)
 801b4b8:	46bd      	mov	sp, r7
 801b4ba:	b008      	add	sp, #32
 801b4bc:	bd80      	pop	{r7, pc}
 801b4be:	46c0      	nop			; (mov r8, r8)
 801b4c0:	20001354 	.word	0x20001354
 801b4c4:	20000298 	.word	0x20000298

0801b4c8 <rand1>:
#define RAND_LOCAL_MAX 2147483647L

static uint32_t next = 1;

int32_t rand1( void )
{
 801b4c8:	b580      	push	{r7, lr}
 801b4ca:	af00      	add	r7, sp, #0
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 801b4cc:	4b08      	ldr	r3, [pc, #32]	; (801b4f0 <rand1+0x28>)
 801b4ce:	681b      	ldr	r3, [r3, #0]
 801b4d0:	4a08      	ldr	r2, [pc, #32]	; (801b4f4 <rand1+0x2c>)
 801b4d2:	4353      	muls	r3, r2
 801b4d4:	4a08      	ldr	r2, [pc, #32]	; (801b4f8 <rand1+0x30>)
 801b4d6:	189a      	adds	r2, r3, r2
 801b4d8:	4b05      	ldr	r3, [pc, #20]	; (801b4f0 <rand1+0x28>)
 801b4da:	601a      	str	r2, [r3, #0]
 801b4dc:	4b04      	ldr	r3, [pc, #16]	; (801b4f0 <rand1+0x28>)
 801b4de:	681b      	ldr	r3, [r3, #0]
 801b4e0:	4906      	ldr	r1, [pc, #24]	; (801b4fc <rand1+0x34>)
 801b4e2:	0018      	movs	r0, r3
 801b4e4:	f7e4 fea0 	bl	8000228 <__aeabi_uidivmod>
 801b4e8:	000b      	movs	r3, r1
}
 801b4ea:	0018      	movs	r0, r3
 801b4ec:	46bd      	mov	sp, r7
 801b4ee:	bd80      	pop	{r7, pc}
 801b4f0:	2000029c 	.word	0x2000029c
 801b4f4:	41c64e6d 	.word	0x41c64e6d
 801b4f8:	00003039 	.word	0x00003039
 801b4fc:	7fffffff 	.word	0x7fffffff

0801b500 <srand1>:

void srand1( uint32_t seed )
{
 801b500:	b580      	push	{r7, lr}
 801b502:	b082      	sub	sp, #8
 801b504:	af00      	add	r7, sp, #0
 801b506:	6078      	str	r0, [r7, #4]
    next = seed;
 801b508:	4b03      	ldr	r3, [pc, #12]	; (801b518 <srand1+0x18>)
 801b50a:	687a      	ldr	r2, [r7, #4]
 801b50c:	601a      	str	r2, [r3, #0]
}
 801b50e:	46c0      	nop			; (mov r8, r8)
 801b510:	46bd      	mov	sp, r7
 801b512:	b002      	add	sp, #8
 801b514:	bd80      	pop	{r7, pc}
 801b516:	46c0      	nop			; (mov r8, r8)
 801b518:	2000029c 	.word	0x2000029c

0801b51c <randr>:
// Standard random functions redefinition end

int32_t randr( int32_t min, int32_t max )
{
 801b51c:	b580      	push	{r7, lr}
 801b51e:	b082      	sub	sp, #8
 801b520:	af00      	add	r7, sp, #0
 801b522:	6078      	str	r0, [r7, #4]
 801b524:	6039      	str	r1, [r7, #0]
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 801b526:	f7ff ffcf 	bl	801b4c8 <rand1>
 801b52a:	683a      	ldr	r2, [r7, #0]
 801b52c:	687b      	ldr	r3, [r7, #4]
 801b52e:	1ad3      	subs	r3, r2, r3
 801b530:	3301      	adds	r3, #1
 801b532:	0019      	movs	r1, r3
 801b534:	f7e4 ff62 	bl	80003fc <__aeabi_idivmod>
 801b538:	000b      	movs	r3, r1
 801b53a:	001a      	movs	r2, r3
 801b53c:	687b      	ldr	r3, [r7, #4]
 801b53e:	18d3      	adds	r3, r2, r3
}
 801b540:	0018      	movs	r0, r3
 801b542:	46bd      	mov	sp, r7
 801b544:	b002      	add	sp, #8
 801b546:	bd80      	pop	{r7, pc}

0801b548 <memcpy1>:

void memcpy1( uint8_t *dst, const uint8_t *src, uint16_t size )
{
 801b548:	b580      	push	{r7, lr}
 801b54a:	b084      	sub	sp, #16
 801b54c:	af00      	add	r7, sp, #0
 801b54e:	60f8      	str	r0, [r7, #12]
 801b550:	60b9      	str	r1, [r7, #8]
 801b552:	1dbb      	adds	r3, r7, #6
 801b554:	801a      	strh	r2, [r3, #0]
    while( size-- )
 801b556:	e007      	b.n	801b568 <memcpy1+0x20>
    {
        *dst++ = *src++;
 801b558:	68ba      	ldr	r2, [r7, #8]
 801b55a:	1c53      	adds	r3, r2, #1
 801b55c:	60bb      	str	r3, [r7, #8]
 801b55e:	68fb      	ldr	r3, [r7, #12]
 801b560:	1c59      	adds	r1, r3, #1
 801b562:	60f9      	str	r1, [r7, #12]
 801b564:	7812      	ldrb	r2, [r2, #0]
 801b566:	701a      	strb	r2, [r3, #0]
    while( size-- )
 801b568:	1dbb      	adds	r3, r7, #6
 801b56a:	881b      	ldrh	r3, [r3, #0]
 801b56c:	1dba      	adds	r2, r7, #6
 801b56e:	1e59      	subs	r1, r3, #1
 801b570:	8011      	strh	r1, [r2, #0]
 801b572:	2b00      	cmp	r3, #0
 801b574:	d1f0      	bne.n	801b558 <memcpy1+0x10>
    }
}
 801b576:	46c0      	nop			; (mov r8, r8)
 801b578:	46c0      	nop			; (mov r8, r8)
 801b57a:	46bd      	mov	sp, r7
 801b57c:	b004      	add	sp, #16
 801b57e:	bd80      	pop	{r7, pc}

0801b580 <memcpyr>:

void memcpyr( uint8_t *dst, const uint8_t *src, uint16_t size )
{
 801b580:	b580      	push	{r7, lr}
 801b582:	b084      	sub	sp, #16
 801b584:	af00      	add	r7, sp, #0
 801b586:	60f8      	str	r0, [r7, #12]
 801b588:	60b9      	str	r1, [r7, #8]
 801b58a:	1dbb      	adds	r3, r7, #6
 801b58c:	801a      	strh	r2, [r3, #0]
    dst = dst + ( size - 1 );
 801b58e:	1dbb      	adds	r3, r7, #6
 801b590:	881b      	ldrh	r3, [r3, #0]
 801b592:	3b01      	subs	r3, #1
 801b594:	68fa      	ldr	r2, [r7, #12]
 801b596:	18d3      	adds	r3, r2, r3
 801b598:	60fb      	str	r3, [r7, #12]
    while( size-- )
 801b59a:	e007      	b.n	801b5ac <memcpyr+0x2c>
    {
        *dst-- = *src++;
 801b59c:	68ba      	ldr	r2, [r7, #8]
 801b59e:	1c53      	adds	r3, r2, #1
 801b5a0:	60bb      	str	r3, [r7, #8]
 801b5a2:	68fb      	ldr	r3, [r7, #12]
 801b5a4:	1e59      	subs	r1, r3, #1
 801b5a6:	60f9      	str	r1, [r7, #12]
 801b5a8:	7812      	ldrb	r2, [r2, #0]
 801b5aa:	701a      	strb	r2, [r3, #0]
    while( size-- )
 801b5ac:	1dbb      	adds	r3, r7, #6
 801b5ae:	881b      	ldrh	r3, [r3, #0]
 801b5b0:	1dba      	adds	r2, r7, #6
 801b5b2:	1e59      	subs	r1, r3, #1
 801b5b4:	8011      	strh	r1, [r2, #0]
 801b5b6:	2b00      	cmp	r3, #0
 801b5b8:	d1f0      	bne.n	801b59c <memcpyr+0x1c>
    }
}
 801b5ba:	46c0      	nop			; (mov r8, r8)
 801b5bc:	46c0      	nop			; (mov r8, r8)
 801b5be:	46bd      	mov	sp, r7
 801b5c0:	b004      	add	sp, #16
 801b5c2:	bd80      	pop	{r7, pc}

0801b5c4 <memset1>:

void memset1( uint8_t *dst, uint8_t value, uint16_t size )
{
 801b5c4:	b580      	push	{r7, lr}
 801b5c6:	b082      	sub	sp, #8
 801b5c8:	af00      	add	r7, sp, #0
 801b5ca:	6078      	str	r0, [r7, #4]
 801b5cc:	0008      	movs	r0, r1
 801b5ce:	0011      	movs	r1, r2
 801b5d0:	1cfb      	adds	r3, r7, #3
 801b5d2:	1c02      	adds	r2, r0, #0
 801b5d4:	701a      	strb	r2, [r3, #0]
 801b5d6:	003b      	movs	r3, r7
 801b5d8:	1c0a      	adds	r2, r1, #0
 801b5da:	801a      	strh	r2, [r3, #0]
    while( size-- )
 801b5dc:	e005      	b.n	801b5ea <memset1+0x26>
    {
        *dst++ = value;
 801b5de:	687b      	ldr	r3, [r7, #4]
 801b5e0:	1c5a      	adds	r2, r3, #1
 801b5e2:	607a      	str	r2, [r7, #4]
 801b5e4:	1cfa      	adds	r2, r7, #3
 801b5e6:	7812      	ldrb	r2, [r2, #0]
 801b5e8:	701a      	strb	r2, [r3, #0]
    while( size-- )
 801b5ea:	003b      	movs	r3, r7
 801b5ec:	881b      	ldrh	r3, [r3, #0]
 801b5ee:	003a      	movs	r2, r7
 801b5f0:	1e59      	subs	r1, r3, #1
 801b5f2:	8011      	strh	r1, [r2, #0]
 801b5f4:	2b00      	cmp	r3, #0
 801b5f6:	d1f2      	bne.n	801b5de <memset1+0x1a>
    }
}
 801b5f8:	46c0      	nop			; (mov r8, r8)
 801b5fa:	46c0      	nop			; (mov r8, r8)
 801b5fc:	46bd      	mov	sp, r7
 801b5fe:	b002      	add	sp, #8
 801b600:	bd80      	pop	{r7, pc}
	...

0801b604 <BSP_sensor_Read>:
void *TEMPERATURE_handle = NULL;
void *PRESSURE_handle = NULL;
#endif

void BSP_sensor_Read(sensor_t *sensor_data)
{
 801b604:	b580      	push	{r7, lr}
 801b606:	b086      	sub	sp, #24
 801b608:	af00      	add	r7, sp, #0
 801b60a:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 5 */
  float HUMIDITY_Value = 0;
 801b60c:	2300      	movs	r3, #0
 801b60e:	617b      	str	r3, [r7, #20]
  float TEMPERATURE_Value = 0;
 801b610:	2300      	movs	r3, #0
 801b612:	613b      	str	r3, [r7, #16]
  float PRESSURE_Value = 0;
 801b614:	2300      	movs	r3, #0
 801b616:	60fb      	str	r3, [r7, #12]

#if defined(SENSOR_ENABLED) || defined (LRWAN_NS1)
  BSP_HUMIDITY_Get_Hum(HUMIDITY_handle, &HUMIDITY_Value);
 801b618:	4b15      	ldr	r3, [pc, #84]	; (801b670 <BSP_sensor_Read+0x6c>)
 801b61a:	681b      	ldr	r3, [r3, #0]
 801b61c:	2214      	movs	r2, #20
 801b61e:	18ba      	adds	r2, r7, r2
 801b620:	0011      	movs	r1, r2
 801b622:	0018      	movs	r0, r3
 801b624:	f7ed fa8b 	bl	8008b3e <BSP_HUMIDITY_Get_Hum>
  BSP_TEMPERATURE_Get_Temp(TEMPERATURE_handle, &TEMPERATURE_Value);
 801b628:	4b12      	ldr	r3, [pc, #72]	; (801b674 <BSP_sensor_Read+0x70>)
 801b62a:	681b      	ldr	r3, [r3, #0]
 801b62c:	2210      	movs	r2, #16
 801b62e:	18ba      	adds	r2, r7, r2
 801b630:	0011      	movs	r1, r2
 801b632:	0018      	movs	r0, r3
 801b634:	f7ed fced 	bl	8009012 <BSP_TEMPERATURE_Get_Temp>
  BSP_PRESSURE_Get_Press(PRESSURE_handle, &PRESSURE_Value);
 801b638:	4b0f      	ldr	r3, [pc, #60]	; (801b678 <BSP_sensor_Read+0x74>)
 801b63a:	681b      	ldr	r3, [r3, #0]
 801b63c:	220c      	movs	r2, #12
 801b63e:	18ba      	adds	r2, r7, r2
 801b640:	0011      	movs	r1, r2
 801b642:	0018      	movs	r0, r3
 801b644:	f7ed fb6b 	bl	8008d1e <BSP_PRESSURE_Get_Press>
#endif
  sensor_data->humidity    = HUMIDITY_Value;
 801b648:	697a      	ldr	r2, [r7, #20]
 801b64a:	687b      	ldr	r3, [r7, #4]
 801b64c:	609a      	str	r2, [r3, #8]
  sensor_data->temperature = TEMPERATURE_Value;
 801b64e:	693a      	ldr	r2, [r7, #16]
 801b650:	687b      	ldr	r3, [r7, #4]
 801b652:	605a      	str	r2, [r3, #4]
  sensor_data->pressure    = PRESSURE_Value;
 801b654:	68fa      	ldr	r2, [r7, #12]
 801b656:	687b      	ldr	r3, [r7, #4]
 801b658:	601a      	str	r2, [r3, #0]

  sensor_data->latitude  = (int32_t)((STSOP_LATTITUDE  * MAX_GPS_POS) / 90);
 801b65a:	687b      	ldr	r3, [r7, #4]
 801b65c:	4a07      	ldr	r2, [pc, #28]	; (801b67c <BSP_sensor_Read+0x78>)
 801b65e:	60da      	str	r2, [r3, #12]
  sensor_data->longitude = (int32_t)((STSOP_LONGITUDE  * MAX_GPS_POS) / 180);
 801b660:	687b      	ldr	r3, [r7, #4]
 801b662:	4a07      	ldr	r2, [pc, #28]	; (801b680 <BSP_sensor_Read+0x7c>)
 801b664:	611a      	str	r2, [r3, #16]
  /* USER CODE END 5 */
}
 801b666:	46c0      	nop			; (mov r8, r8)
 801b668:	46bd      	mov	sp, r7
 801b66a:	b006      	add	sp, #24
 801b66c:	bd80      	pop	{r7, pc}
 801b66e:	46c0      	nop			; (mov r8, r8)
 801b670:	20001464 	.word	0x20001464
 801b674:	20001468 	.word	0x20001468
 801b678:	2000146c 	.word	0x2000146c
 801b67c:	003e090d 	.word	0x003e090d
 801b680:	000503ab 	.word	0x000503ab

0801b684 <BSP_sensor_Init>:

void  BSP_sensor_Init(void)
{
 801b684:	b580      	push	{r7, lr}
 801b686:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 6 */

#if defined(SENSOR_ENABLED) || defined (LRWAN_NS1)
  /* Initialize sensors */
  BSP_HUMIDITY_Init(HTS221_H_0, &HUMIDITY_handle);
 801b688:	4b11      	ldr	r3, [pc, #68]	; (801b6d0 <BSP_sensor_Init+0x4c>)
 801b68a:	0019      	movs	r1, r3
 801b68c:	2000      	movs	r0, #0
 801b68e:	f7ed f995 	bl	80089bc <BSP_HUMIDITY_Init>
  BSP_TEMPERATURE_Init(HTS221_T_0, &TEMPERATURE_handle);
 801b692:	4b10      	ldr	r3, [pc, #64]	; (801b6d4 <BSP_sensor_Init+0x50>)
 801b694:	0019      	movs	r1, r3
 801b696:	2000      	movs	r0, #0
 801b698:	f7ed fb6d 	bl	8008d76 <BSP_TEMPERATURE_Init>
  BSP_PRESSURE_Init(PRESSURE_SENSORS_AUTO, &PRESSURE_handle);
 801b69c:	4a0e      	ldr	r2, [pc, #56]	; (801b6d8 <BSP_sensor_Init+0x54>)
 801b69e:	2301      	movs	r3, #1
 801b6a0:	425b      	negs	r3, r3
 801b6a2:	0011      	movs	r1, r2
 801b6a4:	0018      	movs	r0, r3
 801b6a6:	f7ed fa76 	bl	8008b96 <BSP_PRESSURE_Init>

  /* Enable sensors */
  BSP_HUMIDITY_Sensor_Enable(HUMIDITY_handle);
 801b6aa:	4b09      	ldr	r3, [pc, #36]	; (801b6d0 <BSP_sensor_Init+0x4c>)
 801b6ac:	681b      	ldr	r3, [r3, #0]
 801b6ae:	0018      	movs	r0, r3
 801b6b0:	f7ed fa20 	bl	8008af4 <BSP_HUMIDITY_Sensor_Enable>
  BSP_TEMPERATURE_Sensor_Enable(TEMPERATURE_handle);
 801b6b4:	4b07      	ldr	r3, [pc, #28]	; (801b6d4 <BSP_sensor_Init+0x50>)
 801b6b6:	681b      	ldr	r3, [r3, #0]
 801b6b8:	0018      	movs	r0, r3
 801b6ba:	f7ed fc85 	bl	8008fc8 <BSP_TEMPERATURE_Sensor_Enable>
  BSP_PRESSURE_Sensor_Enable(PRESSURE_handle);
 801b6be:	4b06      	ldr	r3, [pc, #24]	; (801b6d8 <BSP_sensor_Init+0x54>)
 801b6c0:	681b      	ldr	r3, [r3, #0]
 801b6c2:	0018      	movs	r0, r3
 801b6c4:	f7ed fb06 	bl	8008cd4 <BSP_PRESSURE_Sensor_Enable>
#endif
  /* USER CODE END 6 */
}
 801b6c8:	46c0      	nop			; (mov r8, r8)
 801b6ca:	46bd      	mov	sp, r7
 801b6cc:	bd80      	pop	{r7, pc}
 801b6ce:	46c0      	nop			; (mov r8, r8)
 801b6d0:	20001464 	.word	0x20001464
 801b6d4:	20001468 	.word	0x20001468
 801b6d8:	2000146c 	.word	0x2000146c

0801b6dc <DBG_Init>:
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Exported functions ------------------------------------------------------- */

void DBG_Init(void)
{
 801b6dc:	b580      	push	{r7, lr}
 801b6de:	b086      	sub	sp, #24
 801b6e0:	af00      	add	r7, sp, #0
#ifdef DEBUG
  GPIO_InitTypeDef  gpioinitstruct = {0};
 801b6e2:	1d3b      	adds	r3, r7, #4
 801b6e4:	0018      	movs	r0, r3
 801b6e6:	2314      	movs	r3, #20
 801b6e8:	001a      	movs	r2, r3
 801b6ea:	2100      	movs	r1, #0
 801b6ec:	f001 ff32 	bl	801d554 <memset>

  /* Enable the GPIO_B Clock */
  __HAL_RCC_GPIOB_CLK_ENABLE();
 801b6f0:	4b25      	ldr	r3, [pc, #148]	; (801b788 <DBG_Init+0xac>)
 801b6f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b6f4:	4b24      	ldr	r3, [pc, #144]	; (801b788 <DBG_Init+0xac>)
 801b6f6:	2102      	movs	r1, #2
 801b6f8:	430a      	orrs	r2, r1
 801b6fa:	62da      	str	r2, [r3, #44]	; 0x2c
 801b6fc:	4b22      	ldr	r3, [pc, #136]	; (801b788 <DBG_Init+0xac>)
 801b6fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b700:	2202      	movs	r2, #2
 801b702:	4013      	ands	r3, r2
 801b704:	603b      	str	r3, [r7, #0]
 801b706:	683b      	ldr	r3, [r7, #0]

  /* Configure the GPIO pin */
  gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
 801b708:	1d3b      	adds	r3, r7, #4
 801b70a:	2201      	movs	r2, #1
 801b70c:	605a      	str	r2, [r3, #4]
  gpioinitstruct.Pull   = GPIO_PULLUP;
 801b70e:	1d3b      	adds	r3, r7, #4
 801b710:	2201      	movs	r2, #1
 801b712:	609a      	str	r2, [r3, #8]
  gpioinitstruct.Speed  = GPIO_SPEED_HIGH;
 801b714:	1d3b      	adds	r3, r7, #4
 801b716:	2203      	movs	r2, #3
 801b718:	60da      	str	r2, [r3, #12]

  gpioinitstruct.Pin    = (GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15);
 801b71a:	1d3b      	adds	r3, r7, #4
 801b71c:	22f0      	movs	r2, #240	; 0xf0
 801b71e:	0212      	lsls	r2, r2, #8
 801b720:	601a      	str	r2, [r3, #0]
  HAL_GPIO_Init(GPIOB, &gpioinitstruct);
 801b722:	1d3b      	adds	r3, r7, #4
 801b724:	4a19      	ldr	r2, [pc, #100]	; (801b78c <DBG_Init+0xb0>)
 801b726:	0019      	movs	r1, r3
 801b728:	0010      	movs	r0, r2
 801b72a:	f7ee fbfb 	bl	8009f24 <HAL_GPIO_Init>

  /* Reset debug Pins */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);
 801b72e:	2380      	movs	r3, #128	; 0x80
 801b730:	015b      	lsls	r3, r3, #5
 801b732:	4816      	ldr	r0, [pc, #88]	; (801b78c <DBG_Init+0xb0>)
 801b734:	2200      	movs	r2, #0
 801b736:	0019      	movs	r1, r3
 801b738:	f7ee fd72 	bl	800a220 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET);
 801b73c:	2380      	movs	r3, #128	; 0x80
 801b73e:	019b      	lsls	r3, r3, #6
 801b740:	4812      	ldr	r0, [pc, #72]	; (801b78c <DBG_Init+0xb0>)
 801b742:	2200      	movs	r2, #0
 801b744:	0019      	movs	r1, r3
 801b746:	f7ee fd6b 	bl	800a220 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);
 801b74a:	2380      	movs	r3, #128	; 0x80
 801b74c:	01db      	lsls	r3, r3, #7
 801b74e:	480f      	ldr	r0, [pc, #60]	; (801b78c <DBG_Init+0xb0>)
 801b750:	2200      	movs	r2, #0
 801b752:	0019      	movs	r1, r3
 801b754:	f7ee fd64 	bl	800a220 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_RESET);
 801b758:	2380      	movs	r3, #128	; 0x80
 801b75a:	021b      	lsls	r3, r3, #8
 801b75c:	480b      	ldr	r0, [pc, #44]	; (801b78c <DBG_Init+0xb0>)
 801b75e:	2200      	movs	r2, #0
 801b760:	0019      	movs	r1, r3
 801b762:	f7ee fd5d 	bl	800a220 <HAL_GPIO_WritePin>

  __HAL_RCC_DBGMCU_CLK_ENABLE();
 801b766:	4b08      	ldr	r3, [pc, #32]	; (801b788 <DBG_Init+0xac>)
 801b768:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801b76a:	4b07      	ldr	r3, [pc, #28]	; (801b788 <DBG_Init+0xac>)
 801b76c:	2180      	movs	r1, #128	; 0x80
 801b76e:	03c9      	lsls	r1, r1, #15
 801b770:	430a      	orrs	r2, r1
 801b772:	635a      	str	r2, [r3, #52]	; 0x34

  HAL_DBGMCU_EnableDBGSleepMode();
 801b774:	f7ed fcee 	bl	8009154 <HAL_DBGMCU_EnableDBGSleepMode>
  HAL_DBGMCU_EnableDBGStopMode();
 801b778:	f7ed fcfa 	bl	8009170 <HAL_DBGMCU_EnableDBGStopMode>
  HAL_DBGMCU_EnableDBGStandbyMode();
 801b77c:	f7ed fd06 	bl	800918c <HAL_DBGMCU_EnableDBGStandbyMode>
  HAL_DBGMCU_DisableDBGSleepMode();
  HAL_DBGMCU_DisableDBGStopMode();
  HAL_DBGMCU_DisableDBGStandbyMode();
  __HAL_RCC_DBGMCU_CLK_DISABLE();
#endif
}
 801b780:	46c0      	nop			; (mov r8, r8)
 801b782:	46bd      	mov	sp, r7
 801b784:	b006      	add	sp, #24
 801b786:	bd80      	pop	{r7, pc}
 801b788:	40021000 	.word	0x40021000
 801b78c:	50000400 	.word	0x50000400

0801b790 <Error_Handler>:

void Error_Handler(void)
{
 801b790:	b580      	push	{r7, lr}
 801b792:	af00      	add	r7, sp, #0
  PRINTF("Error_Handler\n\r");
 801b794:	4b02      	ldr	r3, [pc, #8]	; (801b7a0 <Error_Handler+0x10>)
 801b796:	0018      	movs	r0, r3
 801b798:	f7ff fdc4 	bl	801b324 <TraceSend>
  while (1)
 801b79c:	e7fe      	b.n	801b79c <Error_Handler+0xc>
 801b79e:	46c0      	nop			; (mov r8, r8)
 801b7a0:	0801fb50 	.word	0x0801fb50

0801b7a4 <HW_GPIO_Init>:
 *                   All port bits are not necessarily available on all GPIOs.
 * @param [IN] initStruct  GPIO_InitTypeDef intit structure
 * @retval none
 */
void HW_GPIO_Init(GPIO_TypeDef *port, uint16_t GPIO_Pin, GPIO_InitTypeDef *initStruct)
{
 801b7a4:	b580      	push	{r7, lr}
 801b7a6:	b08a      	sub	sp, #40	; 0x28
 801b7a8:	af00      	add	r7, sp, #0
 801b7aa:	60f8      	str	r0, [r7, #12]
 801b7ac:	607a      	str	r2, [r7, #4]
 801b7ae:	230a      	movs	r3, #10
 801b7b0:	18fb      	adds	r3, r7, r3
 801b7b2:	1c0a      	adds	r2, r1, #0
 801b7b4:	801a      	strh	r2, [r3, #0]

  RCC_GPIO_CLK_ENABLE((uint32_t) port);
 801b7b6:	68fb      	ldr	r3, [r7, #12]
 801b7b8:	4a31      	ldr	r2, [pc, #196]	; (801b880 <HW_GPIO_Init+0xdc>)
 801b7ba:	4293      	cmp	r3, r2
 801b7bc:	d037      	beq.n	801b82e <HW_GPIO_Init+0x8a>
 801b7be:	4a30      	ldr	r2, [pc, #192]	; (801b880 <HW_GPIO_Init+0xdc>)
 801b7c0:	4293      	cmp	r3, r2
 801b7c2:	d841      	bhi.n	801b848 <HW_GPIO_Init+0xa4>
 801b7c4:	4a2f      	ldr	r2, [pc, #188]	; (801b884 <HW_GPIO_Init+0xe0>)
 801b7c6:	4293      	cmp	r3, r2
 801b7c8:	d024      	beq.n	801b814 <HW_GPIO_Init+0x70>
 801b7ca:	4a2e      	ldr	r2, [pc, #184]	; (801b884 <HW_GPIO_Init+0xe0>)
 801b7cc:	4293      	cmp	r3, r2
 801b7ce:	d83b      	bhi.n	801b848 <HW_GPIO_Init+0xa4>
 801b7d0:	22a0      	movs	r2, #160	; 0xa0
 801b7d2:	05d2      	lsls	r2, r2, #23
 801b7d4:	4293      	cmp	r3, r2
 801b7d6:	d003      	beq.n	801b7e0 <HW_GPIO_Init+0x3c>
 801b7d8:	4a2b      	ldr	r2, [pc, #172]	; (801b888 <HW_GPIO_Init+0xe4>)
 801b7da:	4293      	cmp	r3, r2
 801b7dc:	d00d      	beq.n	801b7fa <HW_GPIO_Init+0x56>
 801b7de:	e033      	b.n	801b848 <HW_GPIO_Init+0xa4>
 801b7e0:	4b2a      	ldr	r3, [pc, #168]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b7e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b7e4:	4b29      	ldr	r3, [pc, #164]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b7e6:	2101      	movs	r1, #1
 801b7e8:	430a      	orrs	r2, r1
 801b7ea:	62da      	str	r2, [r3, #44]	; 0x2c
 801b7ec:	4b27      	ldr	r3, [pc, #156]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b7ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b7f0:	2201      	movs	r2, #1
 801b7f2:	4013      	ands	r3, r2
 801b7f4:	627b      	str	r3, [r7, #36]	; 0x24
 801b7f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b7f8:	e032      	b.n	801b860 <HW_GPIO_Init+0xbc>
 801b7fa:	4b24      	ldr	r3, [pc, #144]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b7fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b7fe:	4b23      	ldr	r3, [pc, #140]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b800:	2102      	movs	r1, #2
 801b802:	430a      	orrs	r2, r1
 801b804:	62da      	str	r2, [r3, #44]	; 0x2c
 801b806:	4b21      	ldr	r3, [pc, #132]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b808:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b80a:	2202      	movs	r2, #2
 801b80c:	4013      	ands	r3, r2
 801b80e:	623b      	str	r3, [r7, #32]
 801b810:	6a3b      	ldr	r3, [r7, #32]
 801b812:	e025      	b.n	801b860 <HW_GPIO_Init+0xbc>
 801b814:	4b1d      	ldr	r3, [pc, #116]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b816:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b818:	4b1c      	ldr	r3, [pc, #112]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b81a:	2104      	movs	r1, #4
 801b81c:	430a      	orrs	r2, r1
 801b81e:	62da      	str	r2, [r3, #44]	; 0x2c
 801b820:	4b1a      	ldr	r3, [pc, #104]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b822:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b824:	2204      	movs	r2, #4
 801b826:	4013      	ands	r3, r2
 801b828:	61fb      	str	r3, [r7, #28]
 801b82a:	69fb      	ldr	r3, [r7, #28]
 801b82c:	e018      	b.n	801b860 <HW_GPIO_Init+0xbc>
 801b82e:	4b17      	ldr	r3, [pc, #92]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b830:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b832:	4b16      	ldr	r3, [pc, #88]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b834:	2108      	movs	r1, #8
 801b836:	430a      	orrs	r2, r1
 801b838:	62da      	str	r2, [r3, #44]	; 0x2c
 801b83a:	4b14      	ldr	r3, [pc, #80]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b83c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b83e:	2208      	movs	r2, #8
 801b840:	4013      	ands	r3, r2
 801b842:	61bb      	str	r3, [r7, #24]
 801b844:	69bb      	ldr	r3, [r7, #24]
 801b846:	e00b      	b.n	801b860 <HW_GPIO_Init+0xbc>
 801b848:	4b10      	ldr	r3, [pc, #64]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b84a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801b84c:	4b0f      	ldr	r3, [pc, #60]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b84e:	2180      	movs	r1, #128	; 0x80
 801b850:	430a      	orrs	r2, r1
 801b852:	62da      	str	r2, [r3, #44]	; 0x2c
 801b854:	4b0d      	ldr	r3, [pc, #52]	; (801b88c <HW_GPIO_Init+0xe8>)
 801b856:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b858:	2280      	movs	r2, #128	; 0x80
 801b85a:	4013      	ands	r3, r2
 801b85c:	617b      	str	r3, [r7, #20]
 801b85e:	697b      	ldr	r3, [r7, #20]

  initStruct->Pin = GPIO_Pin ;
 801b860:	230a      	movs	r3, #10
 801b862:	18fb      	adds	r3, r7, r3
 801b864:	881a      	ldrh	r2, [r3, #0]
 801b866:	687b      	ldr	r3, [r7, #4]
 801b868:	601a      	str	r2, [r3, #0]

  HAL_GPIO_Init(port, initStruct);
 801b86a:	687a      	ldr	r2, [r7, #4]
 801b86c:	68fb      	ldr	r3, [r7, #12]
 801b86e:	0011      	movs	r1, r2
 801b870:	0018      	movs	r0, r3
 801b872:	f7ee fb57 	bl	8009f24 <HAL_GPIO_Init>
}
 801b876:	46c0      	nop			; (mov r8, r8)
 801b878:	46bd      	mov	sp, r7
 801b87a:	b00a      	add	sp, #40	; 0x28
 801b87c:	bd80      	pop	{r7, pc}
 801b87e:	46c0      	nop			; (mov r8, r8)
 801b880:	50000c00 	.word	0x50000c00
 801b884:	50000800 	.word	0x50000800
 801b888:	50000400 	.word	0x50000400
 801b88c:	40021000 	.word	0x40021000

0801b890 <HW_GPIO_SetIrq>:
 * @param [IN] prio       NVIC priority (0 is highest)
 * @param [IN] irqHandler  points to the  function to execute
 * @retval none
 */
void HW_GPIO_SetIrq(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t prio,  GpioIrqHandler *irqHandler)
{
 801b890:	b5f0      	push	{r4, r5, r6, r7, lr}
 801b892:	b087      	sub	sp, #28
 801b894:	af00      	add	r7, sp, #0
 801b896:	60f8      	str	r0, [r7, #12]
 801b898:	607a      	str	r2, [r7, #4]
 801b89a:	603b      	str	r3, [r7, #0]
 801b89c:	250a      	movs	r5, #10
 801b89e:	197b      	adds	r3, r7, r5
 801b8a0:	1c0a      	adds	r2, r1, #0
 801b8a2:	801a      	strh	r2, [r3, #0]
  IRQn_Type IRQnb;

  uint32_t BitPos = HW_GPIO_GetBitPos(GPIO_Pin) ;
 801b8a4:	197b      	adds	r3, r7, r5
 801b8a6:	881b      	ldrh	r3, [r3, #0]
 801b8a8:	0018      	movs	r0, r3
 801b8aa:	f000 f863 	bl	801b974 <HW_GPIO_GetBitPos>
 801b8ae:	0003      	movs	r3, r0
 801b8b0:	617b      	str	r3, [r7, #20]

  if (irqHandler != NULL)
 801b8b2:	683b      	ldr	r3, [r7, #0]
 801b8b4:	2b00      	cmp	r3, #0
 801b8b6:	d01c      	beq.n	801b8f2 <HW_GPIO_SetIrq+0x62>
  {
    GpioIrq[ BitPos ] = irqHandler;
 801b8b8:	4b12      	ldr	r3, [pc, #72]	; (801b904 <HW_GPIO_SetIrq+0x74>)
 801b8ba:	697a      	ldr	r2, [r7, #20]
 801b8bc:	0092      	lsls	r2, r2, #2
 801b8be:	6839      	ldr	r1, [r7, #0]
 801b8c0:	50d1      	str	r1, [r2, r3]

    IRQnb = MSP_GetIRQn(GPIO_Pin);
 801b8c2:	2613      	movs	r6, #19
 801b8c4:	19bc      	adds	r4, r7, r6
 801b8c6:	197b      	adds	r3, r7, r5
 801b8c8:	881b      	ldrh	r3, [r3, #0]
 801b8ca:	0018      	movs	r0, r3
 801b8cc:	f001 f979 	bl	801cbc2 <MSP_GetIRQn>
 801b8d0:	0003      	movs	r3, r0
 801b8d2:	7023      	strb	r3, [r4, #0]

    HAL_NVIC_SetPriority(IRQnb, prio, 0);
 801b8d4:	6879      	ldr	r1, [r7, #4]
 801b8d6:	19bb      	adds	r3, r7, r6
 801b8d8:	781b      	ldrb	r3, [r3, #0]
 801b8da:	b25b      	sxtb	r3, r3
 801b8dc:	2200      	movs	r2, #0
 801b8de:	0018      	movs	r0, r3
 801b8e0:	f7ee f8f8 	bl	8009ad4 <HAL_NVIC_SetPriority>

    HAL_NVIC_EnableIRQ(IRQnb);
 801b8e4:	19bb      	adds	r3, r7, r6
 801b8e6:	781b      	ldrb	r3, [r3, #0]
 801b8e8:	b25b      	sxtb	r3, r3
 801b8ea:	0018      	movs	r0, r3
 801b8ec:	f7ee f907 	bl	8009afe <HAL_NVIC_EnableIRQ>
  }
  else
  {
    GpioIrq[ BitPos ] = NULL;
  }
}
 801b8f0:	e004      	b.n	801b8fc <HW_GPIO_SetIrq+0x6c>
    GpioIrq[ BitPos ] = NULL;
 801b8f2:	4b04      	ldr	r3, [pc, #16]	; (801b904 <HW_GPIO_SetIrq+0x74>)
 801b8f4:	697a      	ldr	r2, [r7, #20]
 801b8f6:	0092      	lsls	r2, r2, #2
 801b8f8:	2100      	movs	r1, #0
 801b8fa:	50d1      	str	r1, [r2, r3]
}
 801b8fc:	46c0      	nop			; (mov r8, r8)
 801b8fe:	46bd      	mov	sp, r7
 801b900:	b007      	add	sp, #28
 801b902:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801b904:	20001470 	.word	0x20001470

0801b908 <HW_GPIO_IrqHandler>:
 *                   This parameter can be one of GPIO_PIN_x where x can be (0..15).
 *                   All port bits are not necessarily available on all GPIOs.
 * @retval none
 */
void HW_GPIO_IrqHandler(uint16_t GPIO_Pin)
{
 801b908:	b580      	push	{r7, lr}
 801b90a:	b084      	sub	sp, #16
 801b90c:	af00      	add	r7, sp, #0
 801b90e:	0002      	movs	r2, r0
 801b910:	1dbb      	adds	r3, r7, #6
 801b912:	801a      	strh	r2, [r3, #0]
  uint32_t BitPos = HW_GPIO_GetBitPos(GPIO_Pin);
 801b914:	1dbb      	adds	r3, r7, #6
 801b916:	881b      	ldrh	r3, [r3, #0]
 801b918:	0018      	movs	r0, r3
 801b91a:	f000 f82b 	bl	801b974 <HW_GPIO_GetBitPos>
 801b91e:	0003      	movs	r3, r0
 801b920:	60fb      	str	r3, [r7, #12]

  if (GpioIrq[ BitPos ]  != NULL)
 801b922:	4b08      	ldr	r3, [pc, #32]	; (801b944 <HW_GPIO_IrqHandler+0x3c>)
 801b924:	68fa      	ldr	r2, [r7, #12]
 801b926:	0092      	lsls	r2, r2, #2
 801b928:	58d3      	ldr	r3, [r2, r3]
 801b92a:	2b00      	cmp	r3, #0
 801b92c:	d005      	beq.n	801b93a <HW_GPIO_IrqHandler+0x32>
  {
    GpioIrq[ BitPos ](NULL);
 801b92e:	4b05      	ldr	r3, [pc, #20]	; (801b944 <HW_GPIO_IrqHandler+0x3c>)
 801b930:	68fa      	ldr	r2, [r7, #12]
 801b932:	0092      	lsls	r2, r2, #2
 801b934:	58d3      	ldr	r3, [r2, r3]
 801b936:	2000      	movs	r0, #0
 801b938:	4798      	blx	r3
  }
}
 801b93a:	46c0      	nop			; (mov r8, r8)
 801b93c:	46bd      	mov	sp, r7
 801b93e:	b004      	add	sp, #16
 801b940:	bd80      	pop	{r7, pc}
 801b942:	46c0      	nop			; (mov r8, r8)
 801b944:	20001470 	.word	0x20001470

0801b948 <HW_GPIO_Write>:
 *                   All port bits are not necessarily available on all GPIOs.
 * @param [IN] value New GPIO output value
 * @retval none
 */
void HW_GPIO_Write(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin,  uint32_t value)
{
 801b948:	b580      	push	{r7, lr}
 801b94a:	b084      	sub	sp, #16
 801b94c:	af00      	add	r7, sp, #0
 801b94e:	60f8      	str	r0, [r7, #12]
 801b950:	607a      	str	r2, [r7, #4]
 801b952:	200a      	movs	r0, #10
 801b954:	183b      	adds	r3, r7, r0
 801b956:	1c0a      	adds	r2, r1, #0
 801b958:	801a      	strh	r2, [r3, #0]
  HAL_GPIO_WritePin(GPIOx, GPIO_Pin, (GPIO_PinState) value);
 801b95a:	687b      	ldr	r3, [r7, #4]
 801b95c:	b2da      	uxtb	r2, r3
 801b95e:	183b      	adds	r3, r7, r0
 801b960:	8819      	ldrh	r1, [r3, #0]
 801b962:	68fb      	ldr	r3, [r7, #12]
 801b964:	0018      	movs	r0, r3
 801b966:	f7ee fc5b 	bl	800a220 <HAL_GPIO_WritePin>
}
 801b96a:	46c0      	nop			; (mov r8, r8)
 801b96c:	46bd      	mov	sp, r7
 801b96e:	b004      	add	sp, #16
 801b970:	bd80      	pop	{r7, pc}
	...

0801b974 <HW_GPIO_GetBitPos>:
 *                   This parameter can be one of GPIO_PIN_x where x can be (0..15).
 *                   All port bits are not necessarily available on all GPIOs.
 * @retval the position of the bit
 */
static uint8_t HW_GPIO_GetBitPos(uint16_t GPIO_Pin)
{
 801b974:	b580      	push	{r7, lr}
 801b976:	b084      	sub	sp, #16
 801b978:	af00      	add	r7, sp, #0
 801b97a:	0002      	movs	r2, r0
 801b97c:	1dbb      	adds	r3, r7, #6
 801b97e:	801a      	strh	r2, [r3, #0]
  uint8_t PinPos = 0;
 801b980:	210f      	movs	r1, #15
 801b982:	187b      	adds	r3, r7, r1
 801b984:	2200      	movs	r2, #0
 801b986:	701a      	strb	r2, [r3, #0]

  if ((GPIO_Pin & 0xFF00) != 0)
 801b988:	1dbb      	adds	r3, r7, #6
 801b98a:	881a      	ldrh	r2, [r3, #0]
 801b98c:	23ff      	movs	r3, #255	; 0xff
 801b98e:	021b      	lsls	r3, r3, #8
 801b990:	4013      	ands	r3, r2
 801b992:	d005      	beq.n	801b9a0 <HW_GPIO_GetBitPos+0x2c>
  {
    PinPos |= 0x8;
 801b994:	187b      	adds	r3, r7, r1
 801b996:	187a      	adds	r2, r7, r1
 801b998:	7812      	ldrb	r2, [r2, #0]
 801b99a:	2108      	movs	r1, #8
 801b99c:	430a      	orrs	r2, r1
 801b99e:	701a      	strb	r2, [r3, #0]
  }
  if ((GPIO_Pin & 0xF0F0) != 0)
 801b9a0:	1dbb      	adds	r3, r7, #6
 801b9a2:	881b      	ldrh	r3, [r3, #0]
 801b9a4:	4a14      	ldr	r2, [pc, #80]	; (801b9f8 <HW_GPIO_GetBitPos+0x84>)
 801b9a6:	4013      	ands	r3, r2
 801b9a8:	d006      	beq.n	801b9b8 <HW_GPIO_GetBitPos+0x44>
  {
    PinPos |= 0x4;
 801b9aa:	220f      	movs	r2, #15
 801b9ac:	18bb      	adds	r3, r7, r2
 801b9ae:	18ba      	adds	r2, r7, r2
 801b9b0:	7812      	ldrb	r2, [r2, #0]
 801b9b2:	2104      	movs	r1, #4
 801b9b4:	430a      	orrs	r2, r1
 801b9b6:	701a      	strb	r2, [r3, #0]
  }
  if ((GPIO_Pin & 0xCCCC) != 0)
 801b9b8:	1dbb      	adds	r3, r7, #6
 801b9ba:	881b      	ldrh	r3, [r3, #0]
 801b9bc:	4a0f      	ldr	r2, [pc, #60]	; (801b9fc <HW_GPIO_GetBitPos+0x88>)
 801b9be:	4013      	ands	r3, r2
 801b9c0:	d006      	beq.n	801b9d0 <HW_GPIO_GetBitPos+0x5c>
  {
    PinPos |= 0x2;
 801b9c2:	220f      	movs	r2, #15
 801b9c4:	18bb      	adds	r3, r7, r2
 801b9c6:	18ba      	adds	r2, r7, r2
 801b9c8:	7812      	ldrb	r2, [r2, #0]
 801b9ca:	2102      	movs	r1, #2
 801b9cc:	430a      	orrs	r2, r1
 801b9ce:	701a      	strb	r2, [r3, #0]
  }
  if ((GPIO_Pin & 0xAAAA) != 0)
 801b9d0:	1dbb      	adds	r3, r7, #6
 801b9d2:	881b      	ldrh	r3, [r3, #0]
 801b9d4:	4a0a      	ldr	r2, [pc, #40]	; (801ba00 <HW_GPIO_GetBitPos+0x8c>)
 801b9d6:	4013      	ands	r3, r2
 801b9d8:	d006      	beq.n	801b9e8 <HW_GPIO_GetBitPos+0x74>
  {
    PinPos |= 0x1;
 801b9da:	220f      	movs	r2, #15
 801b9dc:	18bb      	adds	r3, r7, r2
 801b9de:	18ba      	adds	r2, r7, r2
 801b9e0:	7812      	ldrb	r2, [r2, #0]
 801b9e2:	2101      	movs	r1, #1
 801b9e4:	430a      	orrs	r2, r1
 801b9e6:	701a      	strb	r2, [r3, #0]
  }

  return PinPos;
 801b9e8:	230f      	movs	r3, #15
 801b9ea:	18fb      	adds	r3, r7, r3
 801b9ec:	781b      	ldrb	r3, [r3, #0]
}
 801b9ee:	0018      	movs	r0, r3
 801b9f0:	46bd      	mov	sp, r7
 801b9f2:	b004      	add	sp, #16
 801b9f4:	bd80      	pop	{r7, pc}
 801b9f6:	46c0      	nop			; (mov r8, r8)
 801b9f8:	0000f0f0 	.word	0x0000f0f0
 801b9fc:	0000cccc 	.word	0x0000cccc
 801ba00:	0000aaaa 	.word	0x0000aaaa

0801ba04 <LL_RTC_TIME_GetSubSecond>:
  * @rmtoll SSR          SS            LL_RTC_TIME_GetSubSecond
  * @param  RTCx RTC Instance
  * @retval Sub second value (number between 0 and 65535)
  */
__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
{
 801ba04:	b580      	push	{r7, lr}
 801ba06:	b082      	sub	sp, #8
 801ba08:	af00      	add	r7, sp, #0
 801ba0a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
 801ba0c:	687b      	ldr	r3, [r7, #4]
 801ba0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ba10:	041b      	lsls	r3, r3, #16
 801ba12:	0c1b      	lsrs	r3, r3, #16
}
 801ba14:	0018      	movs	r0, r3
 801ba16:	46bd      	mov	sp, r7
 801ba18:	b002      	add	sp, #8
 801ba1a:	bd80      	pop	{r7, pc}

0801ba1c <HW_RTC_Init>:
 * @note The timer is based on the RTC
 * @param none
 * @retval none
 */
void HW_RTC_Init(void)
{
 801ba1c:	b580      	push	{r7, lr}
 801ba1e:	af00      	add	r7, sp, #0
  if (HW_RTC_Initalized == false)
 801ba20:	4b09      	ldr	r3, [pc, #36]	; (801ba48 <HW_RTC_Init+0x2c>)
 801ba22:	781b      	ldrb	r3, [r3, #0]
 801ba24:	2201      	movs	r2, #1
 801ba26:	4053      	eors	r3, r2
 801ba28:	b2db      	uxtb	r3, r3
 801ba2a:	2b00      	cmp	r3, #0
 801ba2c:	d008      	beq.n	801ba40 <HW_RTC_Init+0x24>
  {
    HW_RTC_SetConfig();
 801ba2e:	f000 f80d 	bl	801ba4c <HW_RTC_SetConfig>
    HW_RTC_SetAlarmConfig();
 801ba32:	f000 f997 	bl	801bd64 <HW_RTC_SetAlarmConfig>
    HW_RTC_SetTimerContext();
 801ba36:	f000 f973 	bl	801bd20 <HW_RTC_SetTimerContext>
    HW_RTC_Initalized = true;
 801ba3a:	4b03      	ldr	r3, [pc, #12]	; (801ba48 <HW_RTC_Init+0x2c>)
 801ba3c:	2201      	movs	r2, #1
 801ba3e:	701a      	strb	r2, [r3, #0]
  }
}
 801ba40:	46c0      	nop			; (mov r8, r8)
 801ba42:	46bd      	mov	sp, r7
 801ba44:	bd80      	pop	{r7, pc}
 801ba46:	46c0      	nop			; (mov r8, r8)
 801ba48:	200014b0 	.word	0x200014b0

0801ba4c <HW_RTC_SetConfig>:
 * @note The timer is based on the RTC
 * @param none
 * @retval none
 */
static void HW_RTC_SetConfig(void)
{
 801ba4c:	b580      	push	{r7, lr}
 801ba4e:	b086      	sub	sp, #24
 801ba50:	af00      	add	r7, sp, #0
  RTC_TimeTypeDef RTC_TimeStruct;
  RTC_DateTypeDef RTC_DateStruct;

  RtcHandle.Instance = RTC;
 801ba52:	4b27      	ldr	r3, [pc, #156]	; (801baf0 <HW_RTC_SetConfig+0xa4>)
 801ba54:	4a27      	ldr	r2, [pc, #156]	; (801baf4 <HW_RTC_SetConfig+0xa8>)
 801ba56:	601a      	str	r2, [r3, #0]

  RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24;
 801ba58:	4b25      	ldr	r3, [pc, #148]	; (801baf0 <HW_RTC_SetConfig+0xa4>)
 801ba5a:	2200      	movs	r2, #0
 801ba5c:	605a      	str	r2, [r3, #4]
  RtcHandle.Init.AsynchPrediv = PREDIV_A; /* RTC_ASYNCH_PREDIV; */
 801ba5e:	4b24      	ldr	r3, [pc, #144]	; (801baf0 <HW_RTC_SetConfig+0xa4>)
 801ba60:	221f      	movs	r2, #31
 801ba62:	609a      	str	r2, [r3, #8]
  RtcHandle.Init.SynchPrediv = PREDIV_S; /* RTC_SYNCH_PREDIV; */
 801ba64:	4b22      	ldr	r3, [pc, #136]	; (801baf0 <HW_RTC_SetConfig+0xa4>)
 801ba66:	4a24      	ldr	r2, [pc, #144]	; (801baf8 <HW_RTC_SetConfig+0xac>)
 801ba68:	60da      	str	r2, [r3, #12]
  RtcHandle.Init.OutPut = RTC_OUTPUT;
 801ba6a:	4b21      	ldr	r3, [pc, #132]	; (801baf0 <HW_RTC_SetConfig+0xa4>)
 801ba6c:	2200      	movs	r2, #0
 801ba6e:	611a      	str	r2, [r3, #16]
  RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 801ba70:	4b1f      	ldr	r3, [pc, #124]	; (801baf0 <HW_RTC_SetConfig+0xa4>)
 801ba72:	2200      	movs	r2, #0
 801ba74:	619a      	str	r2, [r3, #24]
  RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 801ba76:	4b1e      	ldr	r3, [pc, #120]	; (801baf0 <HW_RTC_SetConfig+0xa4>)
 801ba78:	2200      	movs	r2, #0
 801ba7a:	61da      	str	r2, [r3, #28]

  HAL_RTC_Init(&RtcHandle);
 801ba7c:	4b1c      	ldr	r3, [pc, #112]	; (801baf0 <HW_RTC_SetConfig+0xa4>)
 801ba7e:	0018      	movs	r0, r3
 801ba80:	f7f0 f8c0 	bl	800bc04 <HAL_RTC_Init>

  /*Monday 1st January 2016*/
  RTC_DateStruct.Year = 0;
 801ba84:	003b      	movs	r3, r7
 801ba86:	2200      	movs	r2, #0
 801ba88:	70da      	strb	r2, [r3, #3]
  RTC_DateStruct.Month = RTC_MONTH_JANUARY;
 801ba8a:	003b      	movs	r3, r7
 801ba8c:	2201      	movs	r2, #1
 801ba8e:	705a      	strb	r2, [r3, #1]
  RTC_DateStruct.Date = 1;
 801ba90:	003b      	movs	r3, r7
 801ba92:	2201      	movs	r2, #1
 801ba94:	709a      	strb	r2, [r3, #2]
  RTC_DateStruct.WeekDay = RTC_WEEKDAY_MONDAY;
 801ba96:	003b      	movs	r3, r7
 801ba98:	2201      	movs	r2, #1
 801ba9a:	701a      	strb	r2, [r3, #0]
  HAL_RTC_SetDate(&RtcHandle, &RTC_DateStruct, RTC_FORMAT_BIN);
 801ba9c:	0039      	movs	r1, r7
 801ba9e:	4b14      	ldr	r3, [pc, #80]	; (801baf0 <HW_RTC_SetConfig+0xa4>)
 801baa0:	2200      	movs	r2, #0
 801baa2:	0018      	movs	r0, r3
 801baa4:	f7f0 fa6c 	bl	800bf80 <HAL_RTC_SetDate>

  /*at 0:0:0*/
  RTC_TimeStruct.Hours = 0;
 801baa8:	1d3b      	adds	r3, r7, #4
 801baaa:	2200      	movs	r2, #0
 801baac:	701a      	strb	r2, [r3, #0]
  RTC_TimeStruct.Minutes = 0;
 801baae:	1d3b      	adds	r3, r7, #4
 801bab0:	2200      	movs	r2, #0
 801bab2:	705a      	strb	r2, [r3, #1]

  RTC_TimeStruct.Seconds = 0;
 801bab4:	1d3b      	adds	r3, r7, #4
 801bab6:	2200      	movs	r2, #0
 801bab8:	709a      	strb	r2, [r3, #2]
  RTC_TimeStruct.TimeFormat = 0;
 801baba:	1d3b      	adds	r3, r7, #4
 801babc:	2200      	movs	r2, #0
 801babe:	70da      	strb	r2, [r3, #3]
  RTC_TimeStruct.SubSeconds = 0;
 801bac0:	1d3b      	adds	r3, r7, #4
 801bac2:	2200      	movs	r2, #0
 801bac4:	605a      	str	r2, [r3, #4]
  RTC_TimeStruct.StoreOperation = RTC_DAYLIGHTSAVING_NONE;
 801bac6:	1d3b      	adds	r3, r7, #4
 801bac8:	2200      	movs	r2, #0
 801baca:	611a      	str	r2, [r3, #16]
  RTC_TimeStruct.DayLightSaving = RTC_STOREOPERATION_RESET;
 801bacc:	1d3b      	adds	r3, r7, #4
 801bace:	2200      	movs	r2, #0
 801bad0:	60da      	str	r2, [r3, #12]

  HAL_RTC_SetTime(&RtcHandle, &RTC_TimeStruct, RTC_FORMAT_BIN);
 801bad2:	1d39      	adds	r1, r7, #4
 801bad4:	4b06      	ldr	r3, [pc, #24]	; (801baf0 <HW_RTC_SetConfig+0xa4>)
 801bad6:	2200      	movs	r2, #0
 801bad8:	0018      	movs	r0, r3
 801bada:	f7f0 f931 	bl	800bd40 <HAL_RTC_SetTime>

  /*Enable Direct Read of the calendar registers (not through Shadow) */
  HAL_RTCEx_EnableBypassShadow(&RtcHandle);
 801bade:	4b04      	ldr	r3, [pc, #16]	; (801baf0 <HW_RTC_SetConfig+0xa4>)
 801bae0:	0018      	movs	r0, r3
 801bae2:	f7f0 fdf5 	bl	800c6d0 <HAL_RTCEx_EnableBypassShadow>
}
 801bae6:	46c0      	nop			; (mov r8, r8)
 801bae8:	46bd      	mov	sp, r7
 801baea:	b006      	add	sp, #24
 801baec:	bd80      	pop	{r7, pc}
 801baee:	46c0      	nop			; (mov r8, r8)
 801baf0:	200014b4 	.word	0x200014b4
 801baf4:	40002800 	.word	0x40002800
 801baf8:	000003ff 	.word	0x000003ff

0801bafc <HW_RTC_GetMinimumTimeout>:
 * @brief returns the wake up time in ticks
 * @param none
 * @retval wake up time in ticks
 */
uint32_t HW_RTC_GetMinimumTimeout(void)
{
 801bafc:	b580      	push	{r7, lr}
 801bafe:	af00      	add	r7, sp, #0
  return (MIN_ALARM_DELAY);
 801bb00:	2303      	movs	r3, #3
}
 801bb02:	0018      	movs	r0, r3
 801bb04:	46bd      	mov	sp, r7
 801bb06:	bd80      	pop	{r7, pc}

0801bb08 <HW_RTC_ms2Tick>:
 * @brief converts time in ms to time in ticks
 * @param [IN] time in milliseconds
 * @retval returns time in timer ticks
 */
uint32_t HW_RTC_ms2Tick(TimerTime_t timeMilliSec)
{
 801bb08:	b5b0      	push	{r4, r5, r7, lr}
 801bb0a:	b082      	sub	sp, #8
 801bb0c:	af00      	add	r7, sp, #0
 801bb0e:	6078      	str	r0, [r7, #4]
  /*return( ( timeMicroSec / RTC_ALARM_TIME_BASE ) ); */
  return (uint32_t)((((uint64_t)timeMilliSec) * CONV_DENOM) / CONV_NUMER);
 801bb10:	6879      	ldr	r1, [r7, #4]
 801bb12:	000a      	movs	r2, r1
 801bb14:	2100      	movs	r1, #0
 801bb16:	000b      	movs	r3, r1
 801bb18:	0e51      	lsrs	r1, r2, #25
 801bb1a:	01dd      	lsls	r5, r3, #7
 801bb1c:	430d      	orrs	r5, r1
 801bb1e:	01d4      	lsls	r4, r2, #7
 801bb20:	227d      	movs	r2, #125	; 0x7d
 801bb22:	2300      	movs	r3, #0
 801bb24:	0020      	movs	r0, r4
 801bb26:	0029      	movs	r1, r5
 801bb28:	f7e4 fce6 	bl	80004f8 <__aeabi_uldivmod>
 801bb2c:	0002      	movs	r2, r0
 801bb2e:	000b      	movs	r3, r1
 801bb30:	0013      	movs	r3, r2
}
 801bb32:	0018      	movs	r0, r3
 801bb34:	46bd      	mov	sp, r7
 801bb36:	b002      	add	sp, #8
 801bb38:	bdb0      	pop	{r4, r5, r7, pc}

0801bb3a <HW_RTC_Tick2ms>:
 * @brief converts time in ticks to time in ms
 * @param [IN] time in timer ticks
 * @retval returns time in milliseconds
 */
TimerTime_t HW_RTC_Tick2ms(uint32_t tick)
{
 801bb3a:	b580      	push	{r7, lr}
 801bb3c:	b084      	sub	sp, #16
 801bb3e:	af00      	add	r7, sp, #0
 801bb40:	6078      	str	r0, [r7, #4]
  /*return( ( timeMicroSec * RTC_ALARM_TIME_BASE ) ); */
  uint32_t seconds = tick >> N_PREDIV_S;
 801bb42:	687b      	ldr	r3, [r7, #4]
 801bb44:	0a9b      	lsrs	r3, r3, #10
 801bb46:	60fb      	str	r3, [r7, #12]
  tick = tick & PREDIV_S;
 801bb48:	687b      	ldr	r3, [r7, #4]
 801bb4a:	059b      	lsls	r3, r3, #22
 801bb4c:	0d9b      	lsrs	r3, r3, #22
 801bb4e:	607b      	str	r3, [r7, #4]
  return ((seconds * 1000) + ((tick * 1000) >> N_PREDIV_S));
 801bb50:	68fa      	ldr	r2, [r7, #12]
 801bb52:	0013      	movs	r3, r2
 801bb54:	015b      	lsls	r3, r3, #5
 801bb56:	1a9b      	subs	r3, r3, r2
 801bb58:	009b      	lsls	r3, r3, #2
 801bb5a:	189b      	adds	r3, r3, r2
 801bb5c:	00db      	lsls	r3, r3, #3
 801bb5e:	0019      	movs	r1, r3
 801bb60:	687a      	ldr	r2, [r7, #4]
 801bb62:	0013      	movs	r3, r2
 801bb64:	015b      	lsls	r3, r3, #5
 801bb66:	1a9b      	subs	r3, r3, r2
 801bb68:	009b      	lsls	r3, r3, #2
 801bb6a:	189b      	adds	r3, r3, r2
 801bb6c:	00db      	lsls	r3, r3, #3
 801bb6e:	0a9b      	lsrs	r3, r3, #10
 801bb70:	18cb      	adds	r3, r1, r3
}
 801bb72:	0018      	movs	r0, r3
 801bb74:	46bd      	mov	sp, r7
 801bb76:	b004      	add	sp, #16
 801bb78:	bd80      	pop	{r7, pc}
	...

0801bb7c <HW_RTC_SetAlarm>:
 * @brief Set the alarm
 * @note The alarm is set at now (read in this funtion) + timeout
 * @param timeout Duration of the Timer ticks
 */
void HW_RTC_SetAlarm(uint32_t timeout)
{
 801bb7c:	b590      	push	{r4, r7, lr}
 801bb7e:	b083      	sub	sp, #12
 801bb80:	af00      	add	r7, sp, #0
 801bb82:	6078      	str	r0, [r7, #4]
  /* we don't go in Low Power mode for timeout below MIN_ALARM_DELAY */
  if ((MIN_ALARM_DELAY + McuWakeUpTimeCal) < ((timeout - HW_RTC_GetTimerElapsedTime())))
 801bb84:	4b14      	ldr	r3, [pc, #80]	; (801bbd8 <HW_RTC_SetAlarm+0x5c>)
 801bb86:	2200      	movs	r2, #0
 801bb88:	5e9b      	ldrsh	r3, [r3, r2]
 801bb8a:	3303      	adds	r3, #3
 801bb8c:	001c      	movs	r4, r3
 801bb8e:	f000 f825 	bl	801bbdc <HW_RTC_GetTimerElapsedTime>
 801bb92:	0002      	movs	r2, r0
 801bb94:	687b      	ldr	r3, [r7, #4]
 801bb96:	1a9b      	subs	r3, r3, r2
 801bb98:	429c      	cmp	r4, r3
 801bb9a:	d204      	bcs.n	801bba6 <HW_RTC_SetAlarm+0x2a>
  {
    LPM_SetStopMode(LPM_RTC_Id, LPM_Enable);
 801bb9c:	2100      	movs	r1, #0
 801bb9e:	2004      	movs	r0, #4
 801bba0:	f7fe fd8c 	bl	801a6bc <LPM_SetStopMode>
 801bba4:	e003      	b.n	801bbae <HW_RTC_SetAlarm+0x32>
  }
  else
  {
    LPM_SetStopMode(LPM_RTC_Id, LPM_Disable);
 801bba6:	2101      	movs	r1, #1
 801bba8:	2004      	movs	r0, #4
 801bbaa:	f7fe fd87 	bl	801a6bc <LPM_SetStopMode>
  }

  /*In case stop mode is required */
  if (LPM_GetMode() == LPM_StopMode)
 801bbae:	f7fe fdb9 	bl	801a724 <LPM_GetMode>
 801bbb2:	0003      	movs	r3, r0
 801bbb4:	2b01      	cmp	r3, #1
 801bbb6:	d106      	bne.n	801bbc6 <HW_RTC_SetAlarm+0x4a>
  {
    timeout = timeout -  McuWakeUpTimeCal;
 801bbb8:	4b07      	ldr	r3, [pc, #28]	; (801bbd8 <HW_RTC_SetAlarm+0x5c>)
 801bbba:	2200      	movs	r2, #0
 801bbbc:	5e9b      	ldrsh	r3, [r3, r2]
 801bbbe:	001a      	movs	r2, r3
 801bbc0:	687b      	ldr	r3, [r7, #4]
 801bbc2:	1a9b      	subs	r3, r3, r2
 801bbc4:	607b      	str	r3, [r7, #4]
  }

  HW_RTC_StartWakeUpAlarm(timeout);
 801bbc6:	687b      	ldr	r3, [r7, #4]
 801bbc8:	0018      	movs	r0, r3
 801bbca:	f000 f8d9 	bl	801bd80 <HW_RTC_StartWakeUpAlarm>
}
 801bbce:	46c0      	nop			; (mov r8, r8)
 801bbd0:	46bd      	mov	sp, r7
 801bbd2:	b003      	add	sp, #12
 801bbd4:	bd90      	pop	{r4, r7, pc}
 801bbd6:	46c0      	nop			; (mov r8, r8)
 801bbd8:	200014b2 	.word	0x200014b2

0801bbdc <HW_RTC_GetTimerElapsedTime>:
 * @brief Get the RTC timer elapsed time since the last Alarm was set
 * @param none
 * @retval RTC Elapsed time in ticks
 */
uint32_t HW_RTC_GetTimerElapsedTime(void)
{
 801bbdc:	b580      	push	{r7, lr}
 801bbde:	b088      	sub	sp, #32
 801bbe0:	af00      	add	r7, sp, #0
  RTC_TimeTypeDef RTC_TimeStruct;
  RTC_DateTypeDef RTC_DateStruct;

  uint32_t CalendarValue = (uint32_t) HW_RTC_GetCalendarValue(&RTC_DateStruct, &RTC_TimeStruct);
 801bbe2:	2308      	movs	r3, #8
 801bbe4:	18fa      	adds	r2, r7, r3
 801bbe6:	1d3b      	adds	r3, r7, #4
 801bbe8:	0011      	movs	r1, r2
 801bbea:	0018      	movs	r0, r3
 801bbec:	f000 fa2e 	bl	801c04c <HW_RTC_GetCalendarValue>
 801bbf0:	0002      	movs	r2, r0
 801bbf2:	000b      	movs	r3, r1
 801bbf4:	0013      	movs	r3, r2
 801bbf6:	61fb      	str	r3, [r7, #28]

  return ((uint32_t)(CalendarValue - RtcTimerContext.Rtc_Time));
 801bbf8:	4b03      	ldr	r3, [pc, #12]	; (801bc08 <HW_RTC_GetTimerElapsedTime+0x2c>)
 801bbfa:	681b      	ldr	r3, [r3, #0]
 801bbfc:	69fa      	ldr	r2, [r7, #28]
 801bbfe:	1ad3      	subs	r3, r2, r3
}
 801bc00:	0018      	movs	r0, r3
 801bc02:	46bd      	mov	sp, r7
 801bc04:	b008      	add	sp, #32
 801bc06:	bd80      	pop	{r7, pc}
 801bc08:	20001500 	.word	0x20001500

0801bc0c <HW_RTC_GetTimerValue>:
 * @brief Get the RTC timer value
 * @param none
 * @retval RTC Timer value in ticks
 */
uint32_t HW_RTC_GetTimerValue(void)
{
 801bc0c:	b580      	push	{r7, lr}
 801bc0e:	b088      	sub	sp, #32
 801bc10:	af00      	add	r7, sp, #0
  RTC_TimeTypeDef RTC_TimeStruct;
  RTC_DateTypeDef RTC_DateStruct;

  uint32_t CalendarValue = (uint32_t) HW_RTC_GetCalendarValue(&RTC_DateStruct, &RTC_TimeStruct);
 801bc12:	2308      	movs	r3, #8
 801bc14:	18fa      	adds	r2, r7, r3
 801bc16:	1d3b      	adds	r3, r7, #4
 801bc18:	0011      	movs	r1, r2
 801bc1a:	0018      	movs	r0, r3
 801bc1c:	f000 fa16 	bl	801c04c <HW_RTC_GetCalendarValue>
 801bc20:	0002      	movs	r2, r0
 801bc22:	000b      	movs	r3, r1
 801bc24:	0013      	movs	r3, r2
 801bc26:	61fb      	str	r3, [r7, #28]

  return (CalendarValue);
 801bc28:	69fb      	ldr	r3, [r7, #28]
}
 801bc2a:	0018      	movs	r0, r3
 801bc2c:	46bd      	mov	sp, r7
 801bc2e:	b008      	add	sp, #32
 801bc30:	bd80      	pop	{r7, pc}
	...

0801bc34 <HW_RTC_StopAlarm>:
 * @brief Stop the Alarm
 * @param none
 * @retval none
 */
void HW_RTC_StopAlarm(void)
{
 801bc34:	b580      	push	{r7, lr}
 801bc36:	af00      	add	r7, sp, #0
  /* Disable the Alarm A interrupt */
  HAL_RTC_DeactivateAlarm(&RtcHandle, RTC_ALARM_A);
 801bc38:	2380      	movs	r3, #128	; 0x80
 801bc3a:	005a      	lsls	r2, r3, #1
 801bc3c:	4b0a      	ldr	r3, [pc, #40]	; (801bc68 <HW_RTC_StopAlarm+0x34>)
 801bc3e:	0011      	movs	r1, r2
 801bc40:	0018      	movs	r0, r3
 801bc42:	f7f0 fbe5 	bl	800c410 <HAL_RTC_DeactivateAlarm>
  /* Clear RTC Alarm Flag */
  __HAL_RTC_ALARM_CLEAR_FLAG(&RtcHandle, RTC_FLAG_ALRAF);
 801bc46:	4b08      	ldr	r3, [pc, #32]	; (801bc68 <HW_RTC_StopAlarm+0x34>)
 801bc48:	681b      	ldr	r3, [r3, #0]
 801bc4a:	68db      	ldr	r3, [r3, #12]
 801bc4c:	22ff      	movs	r2, #255	; 0xff
 801bc4e:	401a      	ands	r2, r3
 801bc50:	4b05      	ldr	r3, [pc, #20]	; (801bc68 <HW_RTC_StopAlarm+0x34>)
 801bc52:	681b      	ldr	r3, [r3, #0]
 801bc54:	4905      	ldr	r1, [pc, #20]	; (801bc6c <HW_RTC_StopAlarm+0x38>)
 801bc56:	430a      	orrs	r2, r1
 801bc58:	60da      	str	r2, [r3, #12]
  /* Clear the EXTI's line Flag for RTC Alarm */
  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
 801bc5a:	4b05      	ldr	r3, [pc, #20]	; (801bc70 <HW_RTC_StopAlarm+0x3c>)
 801bc5c:	2280      	movs	r2, #128	; 0x80
 801bc5e:	0292      	lsls	r2, r2, #10
 801bc60:	615a      	str	r2, [r3, #20]
}
 801bc62:	46c0      	nop			; (mov r8, r8)
 801bc64:	46bd      	mov	sp, r7
 801bc66:	bd80      	pop	{r7, pc}
 801bc68:	200014b4 	.word	0x200014b4
 801bc6c:	fffffe7f 	.word	0xfffffe7f
 801bc70:	40010400 	.word	0x40010400

0801bc74 <HW_RTC_IrqHandler>:
 * @brief RTC IRQ Handler on the RTC Alarm
 * @param none
 * @retval none
 */
void HW_RTC_IrqHandler(void)
{
 801bc74:	b580      	push	{r7, lr}
 801bc76:	b082      	sub	sp, #8
 801bc78:	af00      	add	r7, sp, #0
  RTC_HandleTypeDef *hrtc = &RtcHandle;
 801bc7a:	4b15      	ldr	r3, [pc, #84]	; (801bcd0 <HW_RTC_IrqHandler+0x5c>)
 801bc7c:	607b      	str	r3, [r7, #4]
  /* enable low power at irq*/
  LPM_SetStopMode(LPM_RTC_Id, LPM_Enable);
 801bc7e:	2100      	movs	r1, #0
 801bc80:	2004      	movs	r0, #4
 801bc82:	f7fe fd1b 	bl	801a6bc <LPM_SetStopMode>

  /* Clear the EXTI's line Flag for RTC Alarm */
  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
 801bc86:	4b13      	ldr	r3, [pc, #76]	; (801bcd4 <HW_RTC_IrqHandler+0x60>)
 801bc88:	2280      	movs	r2, #128	; 0x80
 801bc8a:	0292      	lsls	r2, r2, #10
 801bc8c:	615a      	str	r2, [r3, #20]

  /* Get the AlarmA interrupt source enable status */
  if (__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != RESET)
 801bc8e:	687b      	ldr	r3, [r7, #4]
 801bc90:	681b      	ldr	r3, [r3, #0]
 801bc92:	689a      	ldr	r2, [r3, #8]
 801bc94:	2380      	movs	r3, #128	; 0x80
 801bc96:	015b      	lsls	r3, r3, #5
 801bc98:	4013      	ands	r3, r2
 801bc9a:	d014      	beq.n	801bcc6 <HW_RTC_IrqHandler+0x52>
  {
    /* Get the pending status of the AlarmA Interrupt */
    if (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != RESET)
 801bc9c:	687b      	ldr	r3, [r7, #4]
 801bc9e:	681b      	ldr	r3, [r3, #0]
 801bca0:	68da      	ldr	r2, [r3, #12]
 801bca2:	2380      	movs	r3, #128	; 0x80
 801bca4:	005b      	lsls	r3, r3, #1
 801bca6:	4013      	ands	r3, r2
 801bca8:	d00d      	beq.n	801bcc6 <HW_RTC_IrqHandler+0x52>
    {
      /* Clear the AlarmA interrupt pending bit */
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 801bcaa:	687b      	ldr	r3, [r7, #4]
 801bcac:	681b      	ldr	r3, [r3, #0]
 801bcae:	68db      	ldr	r3, [r3, #12]
 801bcb0:	22ff      	movs	r2, #255	; 0xff
 801bcb2:	401a      	ands	r2, r3
 801bcb4:	687b      	ldr	r3, [r7, #4]
 801bcb6:	681b      	ldr	r3, [r3, #0]
 801bcb8:	4907      	ldr	r1, [pc, #28]	; (801bcd8 <HW_RTC_IrqHandler+0x64>)
 801bcba:	430a      	orrs	r2, r1
 801bcbc:	60da      	str	r2, [r3, #12]
      /* AlarmA callback */
      HAL_RTC_AlarmAEventCallback(hrtc);
 801bcbe:	687b      	ldr	r3, [r7, #4]
 801bcc0:	0018      	movs	r0, r3
 801bcc2:	f000 ff65 	bl	801cb90 <HAL_RTC_AlarmAEventCallback>
    }
  }
}
 801bcc6:	46c0      	nop			; (mov r8, r8)
 801bcc8:	46bd      	mov	sp, r7
 801bcca:	b002      	add	sp, #8
 801bccc:	bd80      	pop	{r7, pc}
 801bcce:	46c0      	nop			; (mov r8, r8)
 801bcd0:	200014b4 	.word	0x200014b4
 801bcd4:	40010400 	.word	0x40010400
 801bcd8:	fffffe7f 	.word	0xfffffe7f

0801bcdc <HW_RTC_DelayMs>:
 * @brief a delay of delay ms by polling RTC
 * @param delay in ms
 * @retval none
 */
void HW_RTC_DelayMs(uint32_t delay)
{
 801bcdc:	b580      	push	{r7, lr}
 801bcde:	b084      	sub	sp, #16
 801bce0:	af00      	add	r7, sp, #0
 801bce2:	6078      	str	r0, [r7, #4]
  TimerTime_t delayValue = 0;
 801bce4:	2300      	movs	r3, #0
 801bce6:	60fb      	str	r3, [r7, #12]
  TimerTime_t timeout = 0;
 801bce8:	2300      	movs	r3, #0
 801bcea:	60bb      	str	r3, [r7, #8]

  delayValue = HW_RTC_ms2Tick(delay);
 801bcec:	687b      	ldr	r3, [r7, #4]
 801bcee:	0018      	movs	r0, r3
 801bcf0:	f7ff ff0a 	bl	801bb08 <HW_RTC_ms2Tick>
 801bcf4:	0003      	movs	r3, r0
 801bcf6:	60fb      	str	r3, [r7, #12]

  /* Wait delay ms */
  timeout = HW_RTC_GetTimerValue();
 801bcf8:	f7ff ff88 	bl	801bc0c <HW_RTC_GetTimerValue>
 801bcfc:	0003      	movs	r3, r0
 801bcfe:	60bb      	str	r3, [r7, #8]
  while (((HW_RTC_GetTimerValue() - timeout)) < delayValue)
 801bd00:	e000      	b.n	801bd04 <HW_RTC_DelayMs+0x28>
  {
    __NOP();
 801bd02:	46c0      	nop			; (mov r8, r8)
  while (((HW_RTC_GetTimerValue() - timeout)) < delayValue)
 801bd04:	f7ff ff82 	bl	801bc0c <HW_RTC_GetTimerValue>
 801bd08:	0002      	movs	r2, r0
 801bd0a:	68bb      	ldr	r3, [r7, #8]
 801bd0c:	1ad3      	subs	r3, r2, r3
 801bd0e:	68fa      	ldr	r2, [r7, #12]
 801bd10:	429a      	cmp	r2, r3
 801bd12:	d8f6      	bhi.n	801bd02 <HW_RTC_DelayMs+0x26>
  }
}
 801bd14:	46c0      	nop			; (mov r8, r8)
 801bd16:	46c0      	nop			; (mov r8, r8)
 801bd18:	46bd      	mov	sp, r7
 801bd1a:	b004      	add	sp, #16
 801bd1c:	bd80      	pop	{r7, pc}
	...

0801bd20 <HW_RTC_SetTimerContext>:
 * @brief set Time Reference set also the RTC_DateStruct and RTC_TimeStruct
 * @param none
 * @retval Timer Value
 */
uint32_t HW_RTC_SetTimerContext(void)
{
 801bd20:	b580      	push	{r7, lr}
 801bd22:	af00      	add	r7, sp, #0
  RtcTimerContext.Rtc_Time = (uint32_t) HW_RTC_GetCalendarValue(&RtcTimerContext.RTC_Calndr_Date, &RtcTimerContext.RTC_Calndr_Time);
 801bd24:	4a07      	ldr	r2, [pc, #28]	; (801bd44 <HW_RTC_SetTimerContext+0x24>)
 801bd26:	4b08      	ldr	r3, [pc, #32]	; (801bd48 <HW_RTC_SetTimerContext+0x28>)
 801bd28:	0011      	movs	r1, r2
 801bd2a:	0018      	movs	r0, r3
 801bd2c:	f000 f98e 	bl	801c04c <HW_RTC_GetCalendarValue>
 801bd30:	0002      	movs	r2, r0
 801bd32:	000b      	movs	r3, r1
 801bd34:	4b05      	ldr	r3, [pc, #20]	; (801bd4c <HW_RTC_SetTimerContext+0x2c>)
 801bd36:	601a      	str	r2, [r3, #0]
  return (uint32_t) RtcTimerContext.Rtc_Time;
 801bd38:	4b04      	ldr	r3, [pc, #16]	; (801bd4c <HW_RTC_SetTimerContext+0x2c>)
 801bd3a:	681b      	ldr	r3, [r3, #0]
}
 801bd3c:	0018      	movs	r0, r3
 801bd3e:	46bd      	mov	sp, r7
 801bd40:	bd80      	pop	{r7, pc}
 801bd42:	46c0      	nop			; (mov r8, r8)
 801bd44:	20001504 	.word	0x20001504
 801bd48:	20001518 	.word	0x20001518
 801bd4c:	20001500 	.word	0x20001500

0801bd50 <HW_RTC_GetTimerContext>:
 * @brief Get the RTC timer Reference
 * @param none
 * @retval Timer Value in  Ticks
 */
uint32_t HW_RTC_GetTimerContext(void)
{
 801bd50:	b580      	push	{r7, lr}
 801bd52:	af00      	add	r7, sp, #0
  return RtcTimerContext.Rtc_Time;
 801bd54:	4b02      	ldr	r3, [pc, #8]	; (801bd60 <HW_RTC_GetTimerContext+0x10>)
 801bd56:	681b      	ldr	r3, [r3, #0]
}
 801bd58:	0018      	movs	r0, r3
 801bd5a:	46bd      	mov	sp, r7
 801bd5c:	bd80      	pop	{r7, pc}
 801bd5e:	46c0      	nop			; (mov r8, r8)
 801bd60:	20001500 	.word	0x20001500

0801bd64 <HW_RTC_SetAlarmConfig>:
 * @brief configure alarm at init
 * @param none
 * @retval none
 */
static void HW_RTC_SetAlarmConfig(void)
{
 801bd64:	b580      	push	{r7, lr}
 801bd66:	af00      	add	r7, sp, #0
  HAL_RTC_DeactivateAlarm(&RtcHandle, RTC_ALARM_A);
 801bd68:	2380      	movs	r3, #128	; 0x80
 801bd6a:	005a      	lsls	r2, r3, #1
 801bd6c:	4b03      	ldr	r3, [pc, #12]	; (801bd7c <HW_RTC_SetAlarmConfig+0x18>)
 801bd6e:	0011      	movs	r1, r2
 801bd70:	0018      	movs	r0, r3
 801bd72:	f7f0 fb4d 	bl	800c410 <HAL_RTC_DeactivateAlarm>
}
 801bd76:	46c0      	nop			; (mov r8, r8)
 801bd78:	46bd      	mov	sp, r7
 801bd7a:	bd80      	pop	{r7, pc}
 801bd7c:	200014b4 	.word	0x200014b4

0801bd80 <HW_RTC_StartWakeUpAlarm>:
 * @note  alarm in RtcTimerContext.Rtc_Time + timeoutValue
 * @param timeoutValue in ticks
 * @retval none
 */
static void HW_RTC_StartWakeUpAlarm(uint32_t timeoutValue)
{
 801bd80:	b5f0      	push	{r4, r5, r6, r7, lr}
 801bd82:	b08d      	sub	sp, #52	; 0x34
 801bd84:	af00      	add	r7, sp, #0
 801bd86:	6078      	str	r0, [r7, #4]
  uint16_t rtcAlarmSubSeconds = 0;
 801bd88:	242e      	movs	r4, #46	; 0x2e
 801bd8a:	193b      	adds	r3, r7, r4
 801bd8c:	2200      	movs	r2, #0
 801bd8e:	801a      	strh	r2, [r3, #0]
  uint16_t rtcAlarmSeconds = 0;
 801bd90:	232c      	movs	r3, #44	; 0x2c
 801bd92:	18fb      	adds	r3, r7, r3
 801bd94:	2200      	movs	r2, #0
 801bd96:	801a      	strh	r2, [r3, #0]
  uint16_t rtcAlarmMinutes = 0;
 801bd98:	232a      	movs	r3, #42	; 0x2a
 801bd9a:	18fb      	adds	r3, r7, r3
 801bd9c:	2200      	movs	r2, #0
 801bd9e:	801a      	strh	r2, [r3, #0]
  uint16_t rtcAlarmHours = 0;
 801bda0:	2328      	movs	r3, #40	; 0x28
 801bda2:	18fb      	adds	r3, r7, r3
 801bda4:	2200      	movs	r2, #0
 801bda6:	801a      	strh	r2, [r3, #0]
  uint16_t rtcAlarmDays = 0;
 801bda8:	2526      	movs	r5, #38	; 0x26
 801bdaa:	197b      	adds	r3, r7, r5
 801bdac:	2200      	movs	r2, #0
 801bdae:	801a      	strh	r2, [r3, #0]
  RTC_TimeTypeDef RTC_TimeStruct = RtcTimerContext.RTC_Calndr_Time;
 801bdb0:	2610      	movs	r6, #16
 801bdb2:	19ba      	adds	r2, r7, r6
 801bdb4:	4b9b      	ldr	r3, [pc, #620]	; (801c024 <HW_RTC_StartWakeUpAlarm+0x2a4>)
 801bdb6:	3304      	adds	r3, #4
 801bdb8:	cb23      	ldmia	r3!, {r0, r1, r5}
 801bdba:	c223      	stmia	r2!, {r0, r1, r5}
 801bdbc:	cb03      	ldmia	r3!, {r0, r1}
 801bdbe:	c203      	stmia	r2!, {r0, r1}
  RTC_DateTypeDef RTC_DateStruct = RtcTimerContext.RTC_Calndr_Date;
 801bdc0:	230c      	movs	r3, #12
 801bdc2:	001d      	movs	r5, r3
 801bdc4:	18fb      	adds	r3, r7, r3
 801bdc6:	4a97      	ldr	r2, [pc, #604]	; (801c024 <HW_RTC_StartWakeUpAlarm+0x2a4>)
 801bdc8:	6992      	ldr	r2, [r2, #24]
 801bdca:	601a      	str	r2, [r3, #0]

  HW_RTC_StopAlarm();
 801bdcc:	f7ff ff32 	bl	801bc34 <HW_RTC_StopAlarm>

  /*reverse counter */
  rtcAlarmSubSeconds =  PREDIV_S - RTC_TimeStruct.SubSeconds;
 801bdd0:	19bb      	adds	r3, r7, r6
 801bdd2:	685b      	ldr	r3, [r3, #4]
 801bdd4:	b29a      	uxth	r2, r3
 801bdd6:	193b      	adds	r3, r7, r4
 801bdd8:	4993      	ldr	r1, [pc, #588]	; (801c028 <HW_RTC_StartWakeUpAlarm+0x2a8>)
 801bdda:	1a8a      	subs	r2, r1, r2
 801bddc:	801a      	strh	r2, [r3, #0]
  rtcAlarmSubSeconds += (timeoutValue & PREDIV_S);
 801bdde:	687b      	ldr	r3, [r7, #4]
 801bde0:	b29b      	uxth	r3, r3
 801bde2:	059b      	lsls	r3, r3, #22
 801bde4:	0d9b      	lsrs	r3, r3, #22
 801bde6:	b299      	uxth	r1, r3
 801bde8:	193b      	adds	r3, r7, r4
 801bdea:	193a      	adds	r2, r7, r4
 801bdec:	8812      	ldrh	r2, [r2, #0]
 801bdee:	188a      	adds	r2, r1, r2
 801bdf0:	801a      	strh	r2, [r3, #0]
  /* convert timeout  to seconds */
  timeoutValue >>= N_PREDIV_S;  /* convert timeout  in seconds */
 801bdf2:	687b      	ldr	r3, [r7, #4]
 801bdf4:	0a9b      	lsrs	r3, r3, #10
 801bdf6:	607b      	str	r3, [r7, #4]

  /*convert microsecs to RTC format and add to 'Now' */
  rtcAlarmDays =  RTC_DateStruct.Date;
 801bdf8:	002b      	movs	r3, r5
 801bdfa:	18fb      	adds	r3, r7, r3
 801bdfc:	789a      	ldrb	r2, [r3, #2]
 801bdfe:	2526      	movs	r5, #38	; 0x26
 801be00:	197b      	adds	r3, r7, r5
 801be02:	801a      	strh	r2, [r3, #0]
  while (timeoutValue >= SECONDS_IN_1DAY)
 801be04:	e00a      	b.n	801be1c <HW_RTC_StartWakeUpAlarm+0x9c>
  {
    timeoutValue -= SECONDS_IN_1DAY;
 801be06:	687b      	ldr	r3, [r7, #4]
 801be08:	4a88      	ldr	r2, [pc, #544]	; (801c02c <HW_RTC_StartWakeUpAlarm+0x2ac>)
 801be0a:	4694      	mov	ip, r2
 801be0c:	4463      	add	r3, ip
 801be0e:	607b      	str	r3, [r7, #4]
    rtcAlarmDays++;
 801be10:	2126      	movs	r1, #38	; 0x26
 801be12:	187b      	adds	r3, r7, r1
 801be14:	881a      	ldrh	r2, [r3, #0]
 801be16:	187b      	adds	r3, r7, r1
 801be18:	3201      	adds	r2, #1
 801be1a:	801a      	strh	r2, [r3, #0]
  while (timeoutValue >= SECONDS_IN_1DAY)
 801be1c:	687b      	ldr	r3, [r7, #4]
 801be1e:	4a84      	ldr	r2, [pc, #528]	; (801c030 <HW_RTC_StartWakeUpAlarm+0x2b0>)
 801be20:	4293      	cmp	r3, r2
 801be22:	d8f0      	bhi.n	801be06 <HW_RTC_StartWakeUpAlarm+0x86>
  }

  /* calc hours */
  rtcAlarmHours = RTC_TimeStruct.Hours;
 801be24:	2310      	movs	r3, #16
 801be26:	18fb      	adds	r3, r7, r3
 801be28:	781a      	ldrb	r2, [r3, #0]
 801be2a:	2328      	movs	r3, #40	; 0x28
 801be2c:	18fb      	adds	r3, r7, r3
 801be2e:	801a      	strh	r2, [r3, #0]
  while (timeoutValue >= SECONDS_IN_1HOUR)
 801be30:	e00a      	b.n	801be48 <HW_RTC_StartWakeUpAlarm+0xc8>
  {
    timeoutValue -= SECONDS_IN_1HOUR;
 801be32:	687b      	ldr	r3, [r7, #4]
 801be34:	4a7f      	ldr	r2, [pc, #508]	; (801c034 <HW_RTC_StartWakeUpAlarm+0x2b4>)
 801be36:	4694      	mov	ip, r2
 801be38:	4463      	add	r3, ip
 801be3a:	607b      	str	r3, [r7, #4]
    rtcAlarmHours++;
 801be3c:	2128      	movs	r1, #40	; 0x28
 801be3e:	187b      	adds	r3, r7, r1
 801be40:	881a      	ldrh	r2, [r3, #0]
 801be42:	187b      	adds	r3, r7, r1
 801be44:	3201      	adds	r2, #1
 801be46:	801a      	strh	r2, [r3, #0]
  while (timeoutValue >= SECONDS_IN_1HOUR)
 801be48:	687a      	ldr	r2, [r7, #4]
 801be4a:	23e1      	movs	r3, #225	; 0xe1
 801be4c:	011b      	lsls	r3, r3, #4
 801be4e:	429a      	cmp	r2, r3
 801be50:	d2ef      	bcs.n	801be32 <HW_RTC_StartWakeUpAlarm+0xb2>
  }

  /* calc minutes */
  rtcAlarmMinutes = RTC_TimeStruct.Minutes;
 801be52:	2310      	movs	r3, #16
 801be54:	18fb      	adds	r3, r7, r3
 801be56:	785a      	ldrb	r2, [r3, #1]
 801be58:	232a      	movs	r3, #42	; 0x2a
 801be5a:	18fb      	adds	r3, r7, r3
 801be5c:	801a      	strh	r2, [r3, #0]
  while (timeoutValue >= SECONDS_IN_1MINUTE)
 801be5e:	e008      	b.n	801be72 <HW_RTC_StartWakeUpAlarm+0xf2>
  {
    timeoutValue -= SECONDS_IN_1MINUTE;
 801be60:	687b      	ldr	r3, [r7, #4]
 801be62:	3b3c      	subs	r3, #60	; 0x3c
 801be64:	607b      	str	r3, [r7, #4]
    rtcAlarmMinutes++;
 801be66:	212a      	movs	r1, #42	; 0x2a
 801be68:	187b      	adds	r3, r7, r1
 801be6a:	881a      	ldrh	r2, [r3, #0]
 801be6c:	187b      	adds	r3, r7, r1
 801be6e:	3201      	adds	r2, #1
 801be70:	801a      	strh	r2, [r3, #0]
  while (timeoutValue >= SECONDS_IN_1MINUTE)
 801be72:	687b      	ldr	r3, [r7, #4]
 801be74:	2b3b      	cmp	r3, #59	; 0x3b
 801be76:	d8f3      	bhi.n	801be60 <HW_RTC_StartWakeUpAlarm+0xe0>
  }

  /* calc seconds */
  rtcAlarmSeconds =  RTC_TimeStruct.Seconds + timeoutValue;
 801be78:	2310      	movs	r3, #16
 801be7a:	18fb      	adds	r3, r7, r3
 801be7c:	789b      	ldrb	r3, [r3, #2]
 801be7e:	b299      	uxth	r1, r3
 801be80:	687b      	ldr	r3, [r7, #4]
 801be82:	b29a      	uxth	r2, r3
 801be84:	232c      	movs	r3, #44	; 0x2c
 801be86:	18fb      	adds	r3, r7, r3
 801be88:	188a      	adds	r2, r1, r2
 801be8a:	801a      	strh	r2, [r3, #0]

  /***** correct for modulo********/
  while (rtcAlarmSubSeconds >= (PREDIV_S + 1))
 801be8c:	e00d      	b.n	801beaa <HW_RTC_StartWakeUpAlarm+0x12a>
  {
    rtcAlarmSubSeconds -= (PREDIV_S + 1);
 801be8e:	222e      	movs	r2, #46	; 0x2e
 801be90:	18bb      	adds	r3, r7, r2
 801be92:	18ba      	adds	r2, r7, r2
 801be94:	8812      	ldrh	r2, [r2, #0]
 801be96:	4968      	ldr	r1, [pc, #416]	; (801c038 <HW_RTC_StartWakeUpAlarm+0x2b8>)
 801be98:	468c      	mov	ip, r1
 801be9a:	4462      	add	r2, ip
 801be9c:	801a      	strh	r2, [r3, #0]
    rtcAlarmSeconds++;
 801be9e:	212c      	movs	r1, #44	; 0x2c
 801bea0:	187b      	adds	r3, r7, r1
 801bea2:	881a      	ldrh	r2, [r3, #0]
 801bea4:	187b      	adds	r3, r7, r1
 801bea6:	3201      	adds	r2, #1
 801bea8:	801a      	strh	r2, [r3, #0]
  while (rtcAlarmSubSeconds >= (PREDIV_S + 1))
 801beaa:	232e      	movs	r3, #46	; 0x2e
 801beac:	18fb      	adds	r3, r7, r3
 801beae:	881a      	ldrh	r2, [r3, #0]
 801beb0:	2380      	movs	r3, #128	; 0x80
 801beb2:	00db      	lsls	r3, r3, #3
 801beb4:	429a      	cmp	r2, r3
 801beb6:	d2ea      	bcs.n	801be8e <HW_RTC_StartWakeUpAlarm+0x10e>
  }

  while (rtcAlarmSeconds >= SECONDS_IN_1MINUTE)
 801beb8:	e00b      	b.n	801bed2 <HW_RTC_StartWakeUpAlarm+0x152>
  {
    rtcAlarmSeconds -= SECONDS_IN_1MINUTE;
 801beba:	222c      	movs	r2, #44	; 0x2c
 801bebc:	18bb      	adds	r3, r7, r2
 801bebe:	18ba      	adds	r2, r7, r2
 801bec0:	8812      	ldrh	r2, [r2, #0]
 801bec2:	3a3c      	subs	r2, #60	; 0x3c
 801bec4:	801a      	strh	r2, [r3, #0]
    rtcAlarmMinutes++;
 801bec6:	212a      	movs	r1, #42	; 0x2a
 801bec8:	187b      	adds	r3, r7, r1
 801beca:	881a      	ldrh	r2, [r3, #0]
 801becc:	187b      	adds	r3, r7, r1
 801bece:	3201      	adds	r2, #1
 801bed0:	801a      	strh	r2, [r3, #0]
  while (rtcAlarmSeconds >= SECONDS_IN_1MINUTE)
 801bed2:	232c      	movs	r3, #44	; 0x2c
 801bed4:	18fb      	adds	r3, r7, r3
 801bed6:	881b      	ldrh	r3, [r3, #0]
 801bed8:	2b3b      	cmp	r3, #59	; 0x3b
 801beda:	d8ee      	bhi.n	801beba <HW_RTC_StartWakeUpAlarm+0x13a>
  }

  while (rtcAlarmMinutes >= MINUTES_IN_1HOUR)
 801bedc:	e00b      	b.n	801bef6 <HW_RTC_StartWakeUpAlarm+0x176>
  {
    rtcAlarmMinutes -= MINUTES_IN_1HOUR;
 801bede:	222a      	movs	r2, #42	; 0x2a
 801bee0:	18bb      	adds	r3, r7, r2
 801bee2:	18ba      	adds	r2, r7, r2
 801bee4:	8812      	ldrh	r2, [r2, #0]
 801bee6:	3a3c      	subs	r2, #60	; 0x3c
 801bee8:	801a      	strh	r2, [r3, #0]
    rtcAlarmHours++;
 801beea:	2128      	movs	r1, #40	; 0x28
 801beec:	187b      	adds	r3, r7, r1
 801beee:	881a      	ldrh	r2, [r3, #0]
 801bef0:	187b      	adds	r3, r7, r1
 801bef2:	3201      	adds	r2, #1
 801bef4:	801a      	strh	r2, [r3, #0]
  while (rtcAlarmMinutes >= MINUTES_IN_1HOUR)
 801bef6:	232a      	movs	r3, #42	; 0x2a
 801bef8:	18fb      	adds	r3, r7, r3
 801befa:	881b      	ldrh	r3, [r3, #0]
 801befc:	2b3b      	cmp	r3, #59	; 0x3b
 801befe:	d8ee      	bhi.n	801bede <HW_RTC_StartWakeUpAlarm+0x15e>
  }

  while (rtcAlarmHours >= HOURS_IN_1DAY)
 801bf00:	e00b      	b.n	801bf1a <HW_RTC_StartWakeUpAlarm+0x19a>
  {
    rtcAlarmHours -= HOURS_IN_1DAY;
 801bf02:	2228      	movs	r2, #40	; 0x28
 801bf04:	18bb      	adds	r3, r7, r2
 801bf06:	18ba      	adds	r2, r7, r2
 801bf08:	8812      	ldrh	r2, [r2, #0]
 801bf0a:	3a18      	subs	r2, #24
 801bf0c:	801a      	strh	r2, [r3, #0]
    rtcAlarmDays++;
 801bf0e:	2126      	movs	r1, #38	; 0x26
 801bf10:	187b      	adds	r3, r7, r1
 801bf12:	881a      	ldrh	r2, [r3, #0]
 801bf14:	187b      	adds	r3, r7, r1
 801bf16:	3201      	adds	r2, #1
 801bf18:	801a      	strh	r2, [r3, #0]
  while (rtcAlarmHours >= HOURS_IN_1DAY)
 801bf1a:	2328      	movs	r3, #40	; 0x28
 801bf1c:	18fb      	adds	r3, r7, r3
 801bf1e:	881b      	ldrh	r3, [r3, #0]
 801bf20:	2b17      	cmp	r3, #23
 801bf22:	d8ee      	bhi.n	801bf02 <HW_RTC_StartWakeUpAlarm+0x182>
  }

  if (RTC_DateStruct.Year % 4 == 0)
 801bf24:	210c      	movs	r1, #12
 801bf26:	187b      	adds	r3, r7, r1
 801bf28:	78db      	ldrb	r3, [r3, #3]
 801bf2a:	2203      	movs	r2, #3
 801bf2c:	4013      	ands	r3, r2
 801bf2e:	b2db      	uxtb	r3, r3
 801bf30:	2b00      	cmp	r3, #0
 801bf32:	d119      	bne.n	801bf68 <HW_RTC_StartWakeUpAlarm+0x1e8>
  {
    if (rtcAlarmDays > DaysInMonthLeapYear[ RTC_DateStruct.Month - 1 ])
 801bf34:	187b      	adds	r3, r7, r1
 801bf36:	785b      	ldrb	r3, [r3, #1]
 801bf38:	3b01      	subs	r3, #1
 801bf3a:	4a40      	ldr	r2, [pc, #256]	; (801c03c <HW_RTC_StartWakeUpAlarm+0x2bc>)
 801bf3c:	5cd3      	ldrb	r3, [r2, r3]
 801bf3e:	b29b      	uxth	r3, r3
 801bf40:	2426      	movs	r4, #38	; 0x26
 801bf42:	193a      	adds	r2, r7, r4
 801bf44:	8812      	ldrh	r2, [r2, #0]
 801bf46:	429a      	cmp	r2, r3
 801bf48:	d928      	bls.n	801bf9c <HW_RTC_StartWakeUpAlarm+0x21c>
    {
      rtcAlarmDays = rtcAlarmDays % DaysInMonthLeapYear[ RTC_DateStruct.Month - 1 ];
 801bf4a:	193b      	adds	r3, r7, r4
 801bf4c:	8818      	ldrh	r0, [r3, #0]
 801bf4e:	187b      	adds	r3, r7, r1
 801bf50:	785b      	ldrb	r3, [r3, #1]
 801bf52:	3b01      	subs	r3, #1
 801bf54:	4a39      	ldr	r2, [pc, #228]	; (801c03c <HW_RTC_StartWakeUpAlarm+0x2bc>)
 801bf56:	5cd3      	ldrb	r3, [r2, r3]
 801bf58:	0019      	movs	r1, r3
 801bf5a:	f7e4 fa4f 	bl	80003fc <__aeabi_idivmod>
 801bf5e:	000b      	movs	r3, r1
 801bf60:	001a      	movs	r2, r3
 801bf62:	193b      	adds	r3, r7, r4
 801bf64:	801a      	strh	r2, [r3, #0]
 801bf66:	e019      	b.n	801bf9c <HW_RTC_StartWakeUpAlarm+0x21c>
    }
  }
  else
  {
    if (rtcAlarmDays > DaysInMonth[ RTC_DateStruct.Month - 1 ])
 801bf68:	210c      	movs	r1, #12
 801bf6a:	187b      	adds	r3, r7, r1
 801bf6c:	785b      	ldrb	r3, [r3, #1]
 801bf6e:	3b01      	subs	r3, #1
 801bf70:	4a33      	ldr	r2, [pc, #204]	; (801c040 <HW_RTC_StartWakeUpAlarm+0x2c0>)
 801bf72:	5cd3      	ldrb	r3, [r2, r3]
 801bf74:	b29b      	uxth	r3, r3
 801bf76:	2426      	movs	r4, #38	; 0x26
 801bf78:	193a      	adds	r2, r7, r4
 801bf7a:	8812      	ldrh	r2, [r2, #0]
 801bf7c:	429a      	cmp	r2, r3
 801bf7e:	d90d      	bls.n	801bf9c <HW_RTC_StartWakeUpAlarm+0x21c>
    {
      rtcAlarmDays = rtcAlarmDays % DaysInMonth[ RTC_DateStruct.Month - 1 ];
 801bf80:	193b      	adds	r3, r7, r4
 801bf82:	8818      	ldrh	r0, [r3, #0]
 801bf84:	187b      	adds	r3, r7, r1
 801bf86:	785b      	ldrb	r3, [r3, #1]
 801bf88:	3b01      	subs	r3, #1
 801bf8a:	4a2d      	ldr	r2, [pc, #180]	; (801c040 <HW_RTC_StartWakeUpAlarm+0x2c0>)
 801bf8c:	5cd3      	ldrb	r3, [r2, r3]
 801bf8e:	0019      	movs	r1, r3
 801bf90:	f7e4 fa34 	bl	80003fc <__aeabi_idivmod>
 801bf94:	000b      	movs	r3, r1
 801bf96:	001a      	movs	r2, r3
 801bf98:	193b      	adds	r3, r7, r4
 801bf9a:	801a      	strh	r2, [r3, #0]
    }
  }

  /* Set RTC_AlarmStructure with calculated values*/
  RTC_AlarmStructure.AlarmTime.SubSeconds = PREDIV_S - rtcAlarmSubSeconds;
 801bf9c:	232e      	movs	r3, #46	; 0x2e
 801bf9e:	18fb      	adds	r3, r7, r3
 801bfa0:	881b      	ldrh	r3, [r3, #0]
 801bfa2:	4a21      	ldr	r2, [pc, #132]	; (801c028 <HW_RTC_StartWakeUpAlarm+0x2a8>)
 801bfa4:	1ad3      	subs	r3, r2, r3
 801bfa6:	001a      	movs	r2, r3
 801bfa8:	4b26      	ldr	r3, [pc, #152]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801bfaa:	605a      	str	r2, [r3, #4]
  RTC_AlarmStructure.AlarmSubSecondMask  = HW_RTC_ALARMSUBSECONDMASK;
 801bfac:	4b25      	ldr	r3, [pc, #148]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801bfae:	22a0      	movs	r2, #160	; 0xa0
 801bfb0:	0512      	lsls	r2, r2, #20
 801bfb2:	619a      	str	r2, [r3, #24]
  RTC_AlarmStructure.AlarmTime.Seconds = rtcAlarmSeconds;
 801bfb4:	232c      	movs	r3, #44	; 0x2c
 801bfb6:	18fb      	adds	r3, r7, r3
 801bfb8:	881b      	ldrh	r3, [r3, #0]
 801bfba:	b2da      	uxtb	r2, r3
 801bfbc:	4b21      	ldr	r3, [pc, #132]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801bfbe:	709a      	strb	r2, [r3, #2]
  RTC_AlarmStructure.AlarmTime.Minutes = rtcAlarmMinutes;
 801bfc0:	232a      	movs	r3, #42	; 0x2a
 801bfc2:	18fb      	adds	r3, r7, r3
 801bfc4:	881b      	ldrh	r3, [r3, #0]
 801bfc6:	b2da      	uxtb	r2, r3
 801bfc8:	4b1e      	ldr	r3, [pc, #120]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801bfca:	705a      	strb	r2, [r3, #1]
  RTC_AlarmStructure.AlarmTime.Hours   = rtcAlarmHours;
 801bfcc:	2328      	movs	r3, #40	; 0x28
 801bfce:	18fb      	adds	r3, r7, r3
 801bfd0:	881b      	ldrh	r3, [r3, #0]
 801bfd2:	b2da      	uxtb	r2, r3
 801bfd4:	4b1b      	ldr	r3, [pc, #108]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801bfd6:	701a      	strb	r2, [r3, #0]
  RTC_AlarmStructure.AlarmDateWeekDay    = (uint8_t)rtcAlarmDays;
 801bfd8:	2326      	movs	r3, #38	; 0x26
 801bfda:	18fb      	adds	r3, r7, r3
 801bfdc:	881b      	ldrh	r3, [r3, #0]
 801bfde:	b2d9      	uxtb	r1, r3
 801bfe0:	4b18      	ldr	r3, [pc, #96]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801bfe2:	2220      	movs	r2, #32
 801bfe4:	5499      	strb	r1, [r3, r2]
  RTC_AlarmStructure.AlarmTime.TimeFormat   = RTC_TimeStruct.TimeFormat;
 801bfe6:	2310      	movs	r3, #16
 801bfe8:	18fb      	adds	r3, r7, r3
 801bfea:	78da      	ldrb	r2, [r3, #3]
 801bfec:	4b15      	ldr	r3, [pc, #84]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801bfee:	70da      	strb	r2, [r3, #3]
  RTC_AlarmStructure.AlarmDateWeekDaySel   = RTC_ALARMDATEWEEKDAYSEL_DATE;
 801bff0:	4b14      	ldr	r3, [pc, #80]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801bff2:	2200      	movs	r2, #0
 801bff4:	61da      	str	r2, [r3, #28]
  RTC_AlarmStructure.AlarmMask       = RTC_ALARMMASK_NONE;
 801bff6:	4b13      	ldr	r3, [pc, #76]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801bff8:	2200      	movs	r2, #0
 801bffa:	615a      	str	r2, [r3, #20]
  RTC_AlarmStructure.Alarm = RTC_ALARM_A;
 801bffc:	4b11      	ldr	r3, [pc, #68]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801bffe:	2280      	movs	r2, #128	; 0x80
 801c000:	0052      	lsls	r2, r2, #1
 801c002:	625a      	str	r2, [r3, #36]	; 0x24
  RTC_AlarmStructure.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 801c004:	4b0f      	ldr	r3, [pc, #60]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801c006:	2200      	movs	r2, #0
 801c008:	60da      	str	r2, [r3, #12]
  RTC_AlarmStructure.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 801c00a:	4b0e      	ldr	r3, [pc, #56]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801c00c:	2200      	movs	r2, #0
 801c00e:	611a      	str	r2, [r3, #16]

  /* Set RTC_Alarm */
  HAL_RTC_SetAlarm_IT(&RtcHandle, &RTC_AlarmStructure, RTC_FORMAT_BIN);
 801c010:	490c      	ldr	r1, [pc, #48]	; (801c044 <HW_RTC_StartWakeUpAlarm+0x2c4>)
 801c012:	4b0d      	ldr	r3, [pc, #52]	; (801c048 <HW_RTC_StartWakeUpAlarm+0x2c8>)
 801c014:	2200      	movs	r2, #0
 801c016:	0018      	movs	r0, r3
 801c018:	f7f0 f8ae 	bl	800c178 <HAL_RTC_SetAlarm_IT>
}
 801c01c:	46c0      	nop			; (mov r8, r8)
 801c01e:	46bd      	mov	sp, r7
 801c020:	b00d      	add	sp, #52	; 0x34
 801c022:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801c024:	20001500 	.word	0x20001500
 801c028:	000003ff 	.word	0x000003ff
 801c02c:	fffeae80 	.word	0xfffeae80
 801c030:	0001517f 	.word	0x0001517f
 801c034:	fffff1f0 	.word	0xfffff1f0
 801c038:	fffffc00 	.word	0xfffffc00
 801c03c:	0801fb6c 	.word	0x0801fb6c
 801c040:	0801fb60 	.word	0x0801fb60
 801c044:	200014d8 	.word	0x200014d8
 801c048:	200014b4 	.word	0x200014b4

0801c04c <HW_RTC_GetCalendarValue>:
 * @param pointer to RTC_DateStruct
 * @param pointer to RTC_TimeStruct
 * @retval time in ticks
 */
static uint64_t HW_RTC_GetCalendarValue(RTC_DateTypeDef *RTC_DateStruct, RTC_TimeTypeDef *RTC_TimeStruct)
{
 801c04c:	b5b0      	push	{r4, r5, r7, lr}
 801c04e:	b08c      	sub	sp, #48	; 0x30
 801c050:	af00      	add	r7, sp, #0
 801c052:	6178      	str	r0, [r7, #20]
 801c054:	6139      	str	r1, [r7, #16]
  uint64_t calendarValue = 0;
 801c056:	2200      	movs	r2, #0
 801c058:	2300      	movs	r3, #0
 801c05a:	62ba      	str	r2, [r7, #40]	; 0x28
 801c05c:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t first_read;
  uint32_t correction;
  uint32_t seconds;

  /* Get Time and Date*/
  HAL_RTC_GetTime(&RtcHandle, RTC_TimeStruct, RTC_FORMAT_BIN);
 801c05e:	6939      	ldr	r1, [r7, #16]
 801c060:	4b4a      	ldr	r3, [pc, #296]	; (801c18c <HW_RTC_GetCalendarValue+0x140>)
 801c062:	2200      	movs	r2, #0
 801c064:	0018      	movs	r0, r3
 801c066:	f7ef ff2f 	bl	800bec8 <HAL_RTC_GetTime>

  /* make sure it is correct due to asynchronus nature of RTC*/
  do
  {
    first_read = LL_RTC_TIME_GetSubSecond(RTC);
 801c06a:	4b49      	ldr	r3, [pc, #292]	; (801c190 <HW_RTC_GetCalendarValue+0x144>)
 801c06c:	0018      	movs	r0, r3
 801c06e:	f7ff fcc9 	bl	801ba04 <LL_RTC_TIME_GetSubSecond>
 801c072:	0003      	movs	r3, r0
 801c074:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_RTC_GetDate(&RtcHandle, RTC_DateStruct, RTC_FORMAT_BIN);
 801c076:	6979      	ldr	r1, [r7, #20]
 801c078:	4b44      	ldr	r3, [pc, #272]	; (801c18c <HW_RTC_GetCalendarValue+0x140>)
 801c07a:	2200      	movs	r2, #0
 801c07c:	0018      	movs	r0, r3
 801c07e:	f7f0 f82d 	bl	800c0dc <HAL_RTC_GetDate>
    HAL_RTC_GetTime(&RtcHandle, RTC_TimeStruct, RTC_FORMAT_BIN);
 801c082:	6939      	ldr	r1, [r7, #16]
 801c084:	4b41      	ldr	r3, [pc, #260]	; (801c18c <HW_RTC_GetCalendarValue+0x140>)
 801c086:	2200      	movs	r2, #0
 801c088:	0018      	movs	r0, r3
 801c08a:	f7ef ff1d 	bl	800bec8 <HAL_RTC_GetTime>

  }
  while (first_read != LL_RTC_TIME_GetSubSecond(RTC));
 801c08e:	4b40      	ldr	r3, [pc, #256]	; (801c190 <HW_RTC_GetCalendarValue+0x144>)
 801c090:	0018      	movs	r0, r3
 801c092:	f7ff fcb7 	bl	801ba04 <LL_RTC_TIME_GetSubSecond>
 801c096:	0002      	movs	r2, r0
 801c098:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c09a:	4293      	cmp	r3, r2
 801c09c:	d1e5      	bne.n	801c06a <HW_RTC_GetCalendarValue+0x1e>

  /* calculte amount of elapsed days since 01/01/2000 */
  seconds = DIVC((DAYS_IN_YEAR * 3 + DAYS_IN_LEAP_YEAR) * RTC_DateStruct->Year, 4);
 801c09e:	697b      	ldr	r3, [r7, #20]
 801c0a0:	78db      	ldrb	r3, [r3, #3]
 801c0a2:	001a      	movs	r2, r3
 801c0a4:	4b3b      	ldr	r3, [pc, #236]	; (801c194 <HW_RTC_GetCalendarValue+0x148>)
 801c0a6:	4353      	muls	r3, r2
 801c0a8:	3303      	adds	r3, #3
 801c0aa:	089b      	lsrs	r3, r3, #2
 801c0ac:	623b      	str	r3, [r7, #32]

  correction = ((RTC_DateStruct->Year % 4) == 0) ? DAYS_IN_MONTH_CORRECTION_LEAP : DAYS_IN_MONTH_CORRECTION_NORM ;
 801c0ae:	697b      	ldr	r3, [r7, #20]
 801c0b0:	78db      	ldrb	r3, [r3, #3]
 801c0b2:	2203      	movs	r2, #3
 801c0b4:	4013      	ands	r3, r2
 801c0b6:	b2db      	uxtb	r3, r3
 801c0b8:	2b00      	cmp	r3, #0
 801c0ba:	d101      	bne.n	801c0c0 <HW_RTC_GetCalendarValue+0x74>
 801c0bc:	4b36      	ldr	r3, [pc, #216]	; (801c198 <HW_RTC_GetCalendarValue+0x14c>)
 801c0be:	e000      	b.n	801c0c2 <HW_RTC_GetCalendarValue+0x76>
 801c0c0:	4b36      	ldr	r3, [pc, #216]	; (801c19c <HW_RTC_GetCalendarValue+0x150>)
 801c0c2:	61fb      	str	r3, [r7, #28]

  seconds += (DIVC((RTC_DateStruct->Month - 1) * (30 + 31), 2) - (((correction >> ((RTC_DateStruct->Month - 1) * 2)) & 0x3)));
 801c0c4:	697b      	ldr	r3, [r7, #20]
 801c0c6:	785b      	ldrb	r3, [r3, #1]
 801c0c8:	1e5a      	subs	r2, r3, #1
 801c0ca:	0013      	movs	r3, r2
 801c0cc:	011b      	lsls	r3, r3, #4
 801c0ce:	1a9b      	subs	r3, r3, r2
 801c0d0:	009b      	lsls	r3, r3, #2
 801c0d2:	189b      	adds	r3, r3, r2
 801c0d4:	3301      	adds	r3, #1
 801c0d6:	2b00      	cmp	r3, #0
 801c0d8:	da00      	bge.n	801c0dc <HW_RTC_GetCalendarValue+0x90>
 801c0da:	3301      	adds	r3, #1
 801c0dc:	105b      	asrs	r3, r3, #1
 801c0de:	0019      	movs	r1, r3
 801c0e0:	697b      	ldr	r3, [r7, #20]
 801c0e2:	785b      	ldrb	r3, [r3, #1]
 801c0e4:	3b01      	subs	r3, #1
 801c0e6:	005b      	lsls	r3, r3, #1
 801c0e8:	69fa      	ldr	r2, [r7, #28]
 801c0ea:	40da      	lsrs	r2, r3
 801c0ec:	0013      	movs	r3, r2
 801c0ee:	2203      	movs	r2, #3
 801c0f0:	4013      	ands	r3, r2
 801c0f2:	1acb      	subs	r3, r1, r3
 801c0f4:	6a3a      	ldr	r2, [r7, #32]
 801c0f6:	18d3      	adds	r3, r2, r3
 801c0f8:	623b      	str	r3, [r7, #32]

  seconds += (RTC_DateStruct->Date - 1);
 801c0fa:	697b      	ldr	r3, [r7, #20]
 801c0fc:	789b      	ldrb	r3, [r3, #2]
 801c0fe:	001a      	movs	r2, r3
 801c100:	6a3b      	ldr	r3, [r7, #32]
 801c102:	18d3      	adds	r3, r2, r3
 801c104:	3b01      	subs	r3, #1
 801c106:	623b      	str	r3, [r7, #32]

  /* convert from days to seconds */
  seconds *= SECONDS_IN_1DAY;
 801c108:	6a3a      	ldr	r2, [r7, #32]
 801c10a:	0013      	movs	r3, r2
 801c10c:	005b      	lsls	r3, r3, #1
 801c10e:	189b      	adds	r3, r3, r2
 801c110:	011a      	lsls	r2, r3, #4
 801c112:	1ad2      	subs	r2, r2, r3
 801c114:	0113      	lsls	r3, r2, #4
 801c116:	1a9b      	subs	r3, r3, r2
 801c118:	01db      	lsls	r3, r3, #7
 801c11a:	623b      	str	r3, [r7, #32]

  seconds += ((uint32_t)RTC_TimeStruct->Seconds +
 801c11c:	693b      	ldr	r3, [r7, #16]
 801c11e:	789b      	ldrb	r3, [r3, #2]
 801c120:	0019      	movs	r1, r3
              ((uint32_t)RTC_TimeStruct->Minutes * SECONDS_IN_1MINUTE) +
              ((uint32_t)RTC_TimeStruct->Hours * SECONDS_IN_1HOUR)) ;
 801c122:	693b      	ldr	r3, [r7, #16]
 801c124:	781b      	ldrb	r3, [r3, #0]
 801c126:	001a      	movs	r2, r3
 801c128:	0013      	movs	r3, r2
 801c12a:	011b      	lsls	r3, r3, #4
 801c12c:	1a9b      	subs	r3, r3, r2
 801c12e:	011a      	lsls	r2, r3, #4
 801c130:	1ad2      	subs	r2, r2, r3
 801c132:	0113      	lsls	r3, r2, #4
 801c134:	001a      	movs	r2, r3
 801c136:	0010      	movs	r0, r2
              ((uint32_t)RTC_TimeStruct->Minutes * SECONDS_IN_1MINUTE) +
 801c138:	693b      	ldr	r3, [r7, #16]
 801c13a:	785b      	ldrb	r3, [r3, #1]
 801c13c:	001a      	movs	r2, r3
 801c13e:	0013      	movs	r3, r2
 801c140:	011b      	lsls	r3, r3, #4
 801c142:	1a9b      	subs	r3, r3, r2
 801c144:	009b      	lsls	r3, r3, #2
 801c146:	18c3      	adds	r3, r0, r3
 801c148:	18cb      	adds	r3, r1, r3
  seconds += ((uint32_t)RTC_TimeStruct->Seconds +
 801c14a:	6a3a      	ldr	r2, [r7, #32]
 801c14c:	18d3      	adds	r3, r2, r3
 801c14e:	623b      	str	r3, [r7, #32]



  calendarValue = (((uint64_t) seconds) << N_PREDIV_S) + (PREDIV_S - RTC_TimeStruct->SubSeconds);
 801c150:	6a3b      	ldr	r3, [r7, #32]
 801c152:	60bb      	str	r3, [r7, #8]
 801c154:	2300      	movs	r3, #0
 801c156:	60fb      	str	r3, [r7, #12]
 801c158:	68ba      	ldr	r2, [r7, #8]
 801c15a:	68fb      	ldr	r3, [r7, #12]
 801c15c:	0011      	movs	r1, r2
 801c15e:	0d8d      	lsrs	r5, r1, #22
 801c160:	0013      	movs	r3, r2
 801c162:	029c      	lsls	r4, r3, #10
 801c164:	693b      	ldr	r3, [r7, #16]
 801c166:	685b      	ldr	r3, [r3, #4]
 801c168:	4a0d      	ldr	r2, [pc, #52]	; (801c1a0 <HW_RTC_GetCalendarValue+0x154>)
 801c16a:	1ad3      	subs	r3, r2, r3
 801c16c:	603b      	str	r3, [r7, #0]
 801c16e:	2300      	movs	r3, #0
 801c170:	607b      	str	r3, [r7, #4]
 801c172:	683a      	ldr	r2, [r7, #0]
 801c174:	687b      	ldr	r3, [r7, #4]
 801c176:	1912      	adds	r2, r2, r4
 801c178:	416b      	adcs	r3, r5
 801c17a:	62ba      	str	r2, [r7, #40]	; 0x28
 801c17c:	62fb      	str	r3, [r7, #44]	; 0x2c

  return (calendarValue);
 801c17e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801c180:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 801c182:	0010      	movs	r0, r2
 801c184:	0019      	movs	r1, r3
 801c186:	46bd      	mov	sp, r7
 801c188:	b00c      	add	sp, #48	; 0x30
 801c18a:	bdb0      	pop	{r4, r5, r7, pc}
 801c18c:	200014b4 	.word	0x200014b4
 801c190:	40002800 	.word	0x40002800
 801c194:	000005b5 	.word	0x000005b5
 801c198:	00445550 	.word	0x00445550
 801c19c:	0099aaa0 	.word	0x0099aaa0
 801c1a0:	000003ff 	.word	0x000003ff

0801c1a4 <HW_RTC_GetCalendarTime>:
 * \param [IN]   pointer to ms
 *
 * \return uint32_t seconds
 */
uint32_t HW_RTC_GetCalendarTime(uint16_t *mSeconds)
{
 801c1a4:	b5b0      	push	{r4, r5, r7, lr}
 801c1a6:	b08c      	sub	sp, #48	; 0x30
 801c1a8:	af00      	add	r7, sp, #0
 801c1aa:	6078      	str	r0, [r7, #4]
  RTC_TimeTypeDef RTC_TimeStruct ;
  RTC_DateTypeDef RTC_DateStruct;
  uint32_t ticks;

  uint64_t calendarValue = HW_RTC_GetCalendarValue(&RTC_DateStruct, &RTC_TimeStruct);
 801c1ac:	230c      	movs	r3, #12
 801c1ae:	18fa      	adds	r2, r7, r3
 801c1b0:	2308      	movs	r3, #8
 801c1b2:	18fb      	adds	r3, r7, r3
 801c1b4:	0011      	movs	r1, r2
 801c1b6:	0018      	movs	r0, r3
 801c1b8:	f7ff ff48 	bl	801c04c <HW_RTC_GetCalendarValue>
 801c1bc:	0002      	movs	r2, r0
 801c1be:	000b      	movs	r3, r1
 801c1c0:	62ba      	str	r2, [r7, #40]	; 0x28
 801c1c2:	62fb      	str	r3, [r7, #44]	; 0x2c

  uint32_t seconds = (uint32_t)(calendarValue >> N_PREDIV_S);
 801c1c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c1c6:	059b      	lsls	r3, r3, #22
 801c1c8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801c1ca:	0a94      	lsrs	r4, r2, #10
 801c1cc:	431c      	orrs	r4, r3
 801c1ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c1d0:	0a9d      	lsrs	r5, r3, #10
 801c1d2:	0023      	movs	r3, r4
 801c1d4:	627b      	str	r3, [r7, #36]	; 0x24

  ticks = (uint32_t) calendarValue & PREDIV_S;
 801c1d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c1d8:	059b      	lsls	r3, r3, #22
 801c1da:	0d9b      	lsrs	r3, r3, #22
 801c1dc:	623b      	str	r3, [r7, #32]

  *mSeconds = HW_RTC_Tick2ms(ticks);
 801c1de:	6a3b      	ldr	r3, [r7, #32]
 801c1e0:	0018      	movs	r0, r3
 801c1e2:	f7ff fcaa 	bl	801bb3a <HW_RTC_Tick2ms>
 801c1e6:	0003      	movs	r3, r0
 801c1e8:	b29a      	uxth	r2, r3
 801c1ea:	687b      	ldr	r3, [r7, #4]
 801c1ec:	801a      	strh	r2, [r3, #0]

  return seconds;
 801c1ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 801c1f0:	0018      	movs	r0, r3
 801c1f2:	46bd      	mov	sp, r7
 801c1f4:	b00c      	add	sp, #48	; 0x30
 801c1f6:	bdb0      	pop	{r4, r5, r7, pc}

0801c1f8 <HW_RTC_BKUPWrite>:

void HW_RTC_BKUPWrite(uint32_t Data0, uint32_t Data1)
{
 801c1f8:	b580      	push	{r7, lr}
 801c1fa:	b082      	sub	sp, #8
 801c1fc:	af00      	add	r7, sp, #0
 801c1fe:	6078      	str	r0, [r7, #4]
 801c200:	6039      	str	r1, [r7, #0]
  HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR0, Data0);
 801c202:	687a      	ldr	r2, [r7, #4]
 801c204:	4b07      	ldr	r3, [pc, #28]	; (801c224 <HW_RTC_BKUPWrite+0x2c>)
 801c206:	2100      	movs	r1, #0
 801c208:	0018      	movs	r0, r3
 801c20a:	f7f0 fa37 	bl	800c67c <HAL_RTCEx_BKUPWrite>
  HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, Data1);
 801c20e:	683a      	ldr	r2, [r7, #0]
 801c210:	4b04      	ldr	r3, [pc, #16]	; (801c224 <HW_RTC_BKUPWrite+0x2c>)
 801c212:	2101      	movs	r1, #1
 801c214:	0018      	movs	r0, r3
 801c216:	f7f0 fa31 	bl	800c67c <HAL_RTCEx_BKUPWrite>
}
 801c21a:	46c0      	nop			; (mov r8, r8)
 801c21c:	46bd      	mov	sp, r7
 801c21e:	b002      	add	sp, #8
 801c220:	bd80      	pop	{r7, pc}
 801c222:	46c0      	nop			; (mov r8, r8)
 801c224:	200014b4 	.word	0x200014b4

0801c228 <HW_RTC_BKUPRead>:

void HW_RTC_BKUPRead(uint32_t *Data0, uint32_t *Data1)
{
 801c228:	b580      	push	{r7, lr}
 801c22a:	b082      	sub	sp, #8
 801c22c:	af00      	add	r7, sp, #0
 801c22e:	6078      	str	r0, [r7, #4]
 801c230:	6039      	str	r1, [r7, #0]
  *Data0 = HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR0);
 801c232:	4b0a      	ldr	r3, [pc, #40]	; (801c25c <HW_RTC_BKUPRead+0x34>)
 801c234:	2100      	movs	r1, #0
 801c236:	0018      	movs	r0, r3
 801c238:	f7f0 fa36 	bl	800c6a8 <HAL_RTCEx_BKUPRead>
 801c23c:	0002      	movs	r2, r0
 801c23e:	687b      	ldr	r3, [r7, #4]
 801c240:	601a      	str	r2, [r3, #0]
  *Data1 = HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR1);
 801c242:	4b06      	ldr	r3, [pc, #24]	; (801c25c <HW_RTC_BKUPRead+0x34>)
 801c244:	2101      	movs	r1, #1
 801c246:	0018      	movs	r0, r3
 801c248:	f7f0 fa2e 	bl	800c6a8 <HAL_RTCEx_BKUPRead>
 801c24c:	0002      	movs	r2, r0
 801c24e:	683b      	ldr	r3, [r7, #0]
 801c250:	601a      	str	r2, [r3, #0]
}
 801c252:	46c0      	nop			; (mov r8, r8)
 801c254:	46bd      	mov	sp, r7
 801c256:	b002      	add	sp, #8
 801c258:	bd80      	pop	{r7, pc}
 801c25a:	46c0      	nop			; (mov r8, r8)
 801c25c:	200014b4 	.word	0x200014b4

0801c260 <HW_SPI_Init>:
 * @brief Initializes the SPI object and MCU peripheral
 *
 * @param [IN] none
 */
void HW_SPI_Init(void)
{
 801c260:	b580      	push	{r7, lr}
 801c262:	af00      	add	r7, sp, #0

  /*##-1- Configure the SPI peripheral */
  /* Set the SPI parameters */

  hspi.Instance = SPI1;
 801c264:	4b1d      	ldr	r3, [pc, #116]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c266:	4a1e      	ldr	r2, [pc, #120]	; (801c2e0 <HW_SPI_Init+0x80>)
 801c268:	601a      	str	r2, [r3, #0]

  hspi.Init.BaudRatePrescaler = SpiFrequency(10000000);
 801c26a:	4b1e      	ldr	r3, [pc, #120]	; (801c2e4 <HW_SPI_Init+0x84>)
 801c26c:	0018      	movs	r0, r3
 801c26e:	f000 f89b 	bl	801c3a8 <SpiFrequency>
 801c272:	0002      	movs	r2, r0
 801c274:	4b19      	ldr	r3, [pc, #100]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c276:	61da      	str	r2, [r3, #28]
  hspi.Init.Direction      = SPI_DIRECTION_2LINES;
 801c278:	4b18      	ldr	r3, [pc, #96]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c27a:	2200      	movs	r2, #0
 801c27c:	609a      	str	r2, [r3, #8]
  hspi.Init.Mode           = SPI_MODE_MASTER;
 801c27e:	4b17      	ldr	r3, [pc, #92]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c280:	2282      	movs	r2, #130	; 0x82
 801c282:	0052      	lsls	r2, r2, #1
 801c284:	605a      	str	r2, [r3, #4]
  hspi.Init.CLKPolarity    = SPI_POLARITY_LOW;
 801c286:	4b15      	ldr	r3, [pc, #84]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c288:	2200      	movs	r2, #0
 801c28a:	611a      	str	r2, [r3, #16]
  hspi.Init.CLKPhase       = SPI_PHASE_1EDGE;
 801c28c:	4b13      	ldr	r3, [pc, #76]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c28e:	2200      	movs	r2, #0
 801c290:	615a      	str	r2, [r3, #20]
  hspi.Init.DataSize       = SPI_DATASIZE_8BIT;
 801c292:	4b12      	ldr	r3, [pc, #72]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c294:	2200      	movs	r2, #0
 801c296:	60da      	str	r2, [r3, #12]
  hspi.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 801c298:	4b10      	ldr	r3, [pc, #64]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c29a:	2200      	movs	r2, #0
 801c29c:	629a      	str	r2, [r3, #40]	; 0x28
  hspi.Init.FirstBit       = SPI_FIRSTBIT_MSB;
 801c29e:	4b0f      	ldr	r3, [pc, #60]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c2a0:	2200      	movs	r2, #0
 801c2a2:	621a      	str	r2, [r3, #32]
  hspi.Init.NSS            = SPI_NSS_SOFT;
 801c2a4:	4b0d      	ldr	r3, [pc, #52]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c2a6:	2280      	movs	r2, #128	; 0x80
 801c2a8:	0092      	lsls	r2, r2, #2
 801c2aa:	619a      	str	r2, [r3, #24]
  hspi.Init.TIMode         = SPI_TIMODE_DISABLE;
 801c2ac:	4b0b      	ldr	r3, [pc, #44]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c2ae:	2200      	movs	r2, #0
 801c2b0:	625a      	str	r2, [r3, #36]	; 0x24


  SPI_CLK_ENABLE();
 801c2b2:	4b0d      	ldr	r3, [pc, #52]	; (801c2e8 <HW_SPI_Init+0x88>)
 801c2b4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801c2b6:	4b0c      	ldr	r3, [pc, #48]	; (801c2e8 <HW_SPI_Init+0x88>)
 801c2b8:	2180      	movs	r1, #128	; 0x80
 801c2ba:	0149      	lsls	r1, r1, #5
 801c2bc:	430a      	orrs	r2, r1
 801c2be:	635a      	str	r2, [r3, #52]	; 0x34


  if (HAL_SPI_Init(&hspi) != HAL_OK)
 801c2c0:	4b06      	ldr	r3, [pc, #24]	; (801c2dc <HW_SPI_Init+0x7c>)
 801c2c2:	0018      	movs	r0, r3
 801c2c4:	f7f0 fa38 	bl	800c738 <HAL_SPI_Init>
 801c2c8:	1e03      	subs	r3, r0, #0
 801c2ca:	d001      	beq.n	801c2d0 <HW_SPI_Init+0x70>
  {
    /* Initialization Error */
    Error_Handler();
 801c2cc:	f7ff fa60 	bl	801b790 <Error_Handler>
  }

  /*##-2- Configure the SPI GPIOs */
  HW_SPI_IoInit();
 801c2d0:	f000 f80c 	bl	801c2ec <HW_SPI_IoInit>
}
 801c2d4:	46c0      	nop			; (mov r8, r8)
 801c2d6:	46bd      	mov	sp, r7
 801c2d8:	bd80      	pop	{r7, pc}
 801c2da:	46c0      	nop			; (mov r8, r8)
 801c2dc:	2000151c 	.word	0x2000151c
 801c2e0:	40013000 	.word	0x40013000
 801c2e4:	00989680 	.word	0x00989680
 801c2e8:	40021000 	.word	0x40021000

0801c2ec <HW_SPI_IoInit>:
  /*##-2- Configure the SPI GPIOs */
  HW_SPI_IoDeInit();
}

void HW_SPI_IoInit(void)
{
 801c2ec:	b580      	push	{r7, lr}
 801c2ee:	b086      	sub	sp, #24
 801c2f0:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef initStruct = {0};
 801c2f2:	1d3b      	adds	r3, r7, #4
 801c2f4:	0018      	movs	r0, r3
 801c2f6:	2314      	movs	r3, #20
 801c2f8:	001a      	movs	r2, r3
 801c2fa:	2100      	movs	r1, #0
 801c2fc:	f001 f92a 	bl	801d554 <memset>


  initStruct.Mode = GPIO_MODE_AF_PP;
 801c300:	1d3b      	adds	r3, r7, #4
 801c302:	2202      	movs	r2, #2
 801c304:	605a      	str	r2, [r3, #4]
  initStruct.Pull = GPIO_NOPULL  ;
 801c306:	1d3b      	adds	r3, r7, #4
 801c308:	2200      	movs	r2, #0
 801c30a:	609a      	str	r2, [r3, #8]
  initStruct.Speed = GPIO_SPEED_HIGH;
 801c30c:	1d3b      	adds	r3, r7, #4
 801c30e:	2203      	movs	r2, #3
 801c310:	60da      	str	r2, [r3, #12]
  initStruct.Alternate = SPI1_AF ;
 801c312:	1d3b      	adds	r3, r7, #4
 801c314:	2200      	movs	r2, #0
 801c316:	611a      	str	r2, [r3, #16]

  HW_GPIO_Init(RADIO_SCLK_PORT, RADIO_SCLK_PIN, &initStruct);
 801c318:	1d3b      	adds	r3, r7, #4
 801c31a:	4816      	ldr	r0, [pc, #88]	; (801c374 <HW_SPI_IoInit+0x88>)
 801c31c:	001a      	movs	r2, r3
 801c31e:	2108      	movs	r1, #8
 801c320:	f7ff fa40 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Init(RADIO_MISO_PORT, RADIO_MISO_PIN, &initStruct);
 801c324:	1d3a      	adds	r2, r7, #4
 801c326:	23a0      	movs	r3, #160	; 0xa0
 801c328:	05db      	lsls	r3, r3, #23
 801c32a:	2140      	movs	r1, #64	; 0x40
 801c32c:	0018      	movs	r0, r3
 801c32e:	f7ff fa39 	bl	801b7a4 <HW_GPIO_Init>
  HW_GPIO_Init(RADIO_MOSI_PORT, RADIO_MOSI_PIN, &initStruct);
 801c332:	1d3a      	adds	r2, r7, #4
 801c334:	23a0      	movs	r3, #160	; 0xa0
 801c336:	05db      	lsls	r3, r3, #23
 801c338:	2180      	movs	r1, #128	; 0x80
 801c33a:	0018      	movs	r0, r3
 801c33c:	f7ff fa32 	bl	801b7a4 <HW_GPIO_Init>

  initStruct.Mode = GPIO_MODE_OUTPUT_PP;
 801c340:	1d3b      	adds	r3, r7, #4
 801c342:	2201      	movs	r2, #1
 801c344:	605a      	str	r2, [r3, #4]
  initStruct.Pull = GPIO_NOPULL;
 801c346:	1d3b      	adds	r3, r7, #4
 801c348:	2200      	movs	r2, #0
 801c34a:	609a      	str	r2, [r3, #8]

  HW_GPIO_Init(RADIO_NSS_PORT, RADIO_NSS_PIN, &initStruct);
 801c34c:	1d3a      	adds	r2, r7, #4
 801c34e:	2380      	movs	r3, #128	; 0x80
 801c350:	0219      	lsls	r1, r3, #8
 801c352:	23a0      	movs	r3, #160	; 0xa0
 801c354:	05db      	lsls	r3, r3, #23
 801c356:	0018      	movs	r0, r3
 801c358:	f7ff fa24 	bl	801b7a4 <HW_GPIO_Init>

  HW_GPIO_Write(RADIO_NSS_PORT, RADIO_NSS_PIN, 1);
 801c35c:	2380      	movs	r3, #128	; 0x80
 801c35e:	0219      	lsls	r1, r3, #8
 801c360:	23a0      	movs	r3, #160	; 0xa0
 801c362:	05db      	lsls	r3, r3, #23
 801c364:	2201      	movs	r2, #1
 801c366:	0018      	movs	r0, r3
 801c368:	f7ff faee 	bl	801b948 <HW_GPIO_Write>
}
 801c36c:	46c0      	nop			; (mov r8, r8)
 801c36e:	46bd      	mov	sp, r7
 801c370:	b006      	add	sp, #24
 801c372:	bd80      	pop	{r7, pc}
 801c374:	50000400 	.word	0x50000400

0801c378 <HW_SPI_InOut>:
 *
 * @param [IN] outData Byte to be sent
 * @retval inData      Received byte.
 */
uint16_t HW_SPI_InOut(uint16_t txData)
{
 801c378:	b590      	push	{r4, r7, lr}
 801c37a:	b087      	sub	sp, #28
 801c37c:	af02      	add	r7, sp, #8
 801c37e:	0002      	movs	r2, r0
 801c380:	1dbb      	adds	r3, r7, #6
 801c382:	801a      	strh	r2, [r3, #0]
  uint16_t rxData ;

  HAL_SPI_TransmitReceive(&hspi, (uint8_t *) &txData, (uint8_t *) &rxData, 1, HAL_MAX_DELAY);
 801c384:	240e      	movs	r4, #14
 801c386:	193a      	adds	r2, r7, r4
 801c388:	1db9      	adds	r1, r7, #6
 801c38a:	4806      	ldr	r0, [pc, #24]	; (801c3a4 <HW_SPI_InOut+0x2c>)
 801c38c:	2301      	movs	r3, #1
 801c38e:	425b      	negs	r3, r3
 801c390:	9300      	str	r3, [sp, #0]
 801c392:	2301      	movs	r3, #1
 801c394:	f7f0 fa42 	bl	800c81c <HAL_SPI_TransmitReceive>

  return rxData;
 801c398:	193b      	adds	r3, r7, r4
 801c39a:	881b      	ldrh	r3, [r3, #0]
}
 801c39c:	0018      	movs	r0, r3
 801c39e:	46bd      	mov	sp, r7
 801c3a0:	b005      	add	sp, #20
 801c3a2:	bd90      	pop	{r4, r7, pc}
 801c3a4:	2000151c 	.word	0x2000151c

0801c3a8 <SpiFrequency>:

/* Private functions ---------------------------------------------------------*/

static uint32_t SpiFrequency(uint32_t hz)
{
 801c3a8:	b580      	push	{r7, lr}
 801c3aa:	b086      	sub	sp, #24
 801c3ac:	af00      	add	r7, sp, #0
 801c3ae:	6078      	str	r0, [r7, #4]
  uint32_t divisor = 0;
 801c3b0:	2300      	movs	r3, #0
 801c3b2:	617b      	str	r3, [r7, #20]
  uint32_t SysClkTmp = SystemCoreClock;
 801c3b4:	4b17      	ldr	r3, [pc, #92]	; (801c414 <SpiFrequency+0x6c>)
 801c3b6:	681b      	ldr	r3, [r3, #0]
 801c3b8:	613b      	str	r3, [r7, #16]
  uint32_t baudRate;

  while (SysClkTmp > hz)
 801c3ba:	e008      	b.n	801c3ce <SpiFrequency+0x26>
  {
    divisor++;
 801c3bc:	697b      	ldr	r3, [r7, #20]
 801c3be:	3301      	adds	r3, #1
 801c3c0:	617b      	str	r3, [r7, #20]
    SysClkTmp = (SysClkTmp >> 1);
 801c3c2:	693b      	ldr	r3, [r7, #16]
 801c3c4:	085b      	lsrs	r3, r3, #1
 801c3c6:	613b      	str	r3, [r7, #16]

    if (divisor >= 7)
 801c3c8:	697b      	ldr	r3, [r7, #20]
 801c3ca:	2b06      	cmp	r3, #6
 801c3cc:	d804      	bhi.n	801c3d8 <SpiFrequency+0x30>
  while (SysClkTmp > hz)
 801c3ce:	693a      	ldr	r2, [r7, #16]
 801c3d0:	687b      	ldr	r3, [r7, #4]
 801c3d2:	429a      	cmp	r2, r3
 801c3d4:	d8f2      	bhi.n	801c3bc <SpiFrequency+0x14>
 801c3d6:	e000      	b.n	801c3da <SpiFrequency+0x32>
    {
      break;
 801c3d8:	46c0      	nop			; (mov r8, r8)
    }
  }

  baudRate = (((divisor & 0x4) == 0) ? 0x0 : SPI_CR1_BR_2) |
 801c3da:	697b      	ldr	r3, [r7, #20]
 801c3dc:	2204      	movs	r2, #4
 801c3de:	4013      	ands	r3, r2
 801c3e0:	d101      	bne.n	801c3e6 <SpiFrequency+0x3e>
 801c3e2:	2200      	movs	r2, #0
 801c3e4:	e000      	b.n	801c3e8 <SpiFrequency+0x40>
 801c3e6:	2220      	movs	r2, #32
             (((divisor & 0x2) == 0) ? 0x0 : SPI_CR1_BR_1) |
 801c3e8:	697b      	ldr	r3, [r7, #20]
 801c3ea:	2102      	movs	r1, #2
 801c3ec:	400b      	ands	r3, r1
 801c3ee:	d101      	bne.n	801c3f4 <SpiFrequency+0x4c>
 801c3f0:	2300      	movs	r3, #0
 801c3f2:	e000      	b.n	801c3f6 <SpiFrequency+0x4e>
 801c3f4:	2310      	movs	r3, #16
  baudRate = (((divisor & 0x4) == 0) ? 0x0 : SPI_CR1_BR_2) |
 801c3f6:	431a      	orrs	r2, r3
             (((divisor & 0x1) == 0) ? 0x0 : SPI_CR1_BR_0);
 801c3f8:	697b      	ldr	r3, [r7, #20]
 801c3fa:	2101      	movs	r1, #1
 801c3fc:	400b      	ands	r3, r1
 801c3fe:	d101      	bne.n	801c404 <SpiFrequency+0x5c>
 801c400:	2300      	movs	r3, #0
 801c402:	e000      	b.n	801c406 <SpiFrequency+0x5e>
 801c404:	2308      	movs	r3, #8
  baudRate = (((divisor & 0x4) == 0) ? 0x0 : SPI_CR1_BR_2) |
 801c406:	4313      	orrs	r3, r2
 801c408:	60fb      	str	r3, [r7, #12]

  return baudRate;
 801c40a:	68fb      	ldr	r3, [r7, #12]
}
 801c40c:	0018      	movs	r0, r3
 801c40e:	46bd      	mov	sp, r7
 801c410:	b006      	add	sp, #24
 801c412:	bd80      	pop	{r7, pc}
 801c414:	20000188 	.word	0x20000188

0801c418 <main>:
 * @brief  Main program
 * @param  None
 * @retval None
 */
int main(void)
{
 801c418:	b580      	push	{r7, lr}
 801c41a:	b082      	sub	sp, #8
 801c41c:	af02      	add	r7, sp, #8
    /* STM32 HAL library initialization*/
    HAL_Init();
 801c41e:	f7ec fe63 	bl	80090e8 <HAL_Init>

    /* Configure the system clock*/
    SystemClock_Config();
 801c422:	f000 fc9f 	bl	801cd64 <SystemClock_Config>

    /* Configure the debug mode*/
    DBG_Init();
 801c426:	f7ff f959 	bl	801b6dc <DBG_Init>

    /* Configure the hardware*/
    HW_Init();
 801c42a:	f000 fbe7 	bl	801cbfc <HW_Init>

    /* USER CODE BEGIN 1 */
    /* USER CODE END 1 */

    /*Disbale Stand-by mode*/
    LPM_SetOffMode(LPM_APPLI_Id, LPM_Disable);
 801c42e:	2101      	movs	r1, #1
 801c430:	2001      	movs	r0, #1
 801c432:	f7fe f90f 	bl	801a654 <LPM_SetOffMode>

    PRINTF("\r\n*********************************\r\n");
 801c436:	4b28      	ldr	r3, [pc, #160]	; (801c4d8 <main+0xc0>)
 801c438:	0018      	movs	r0, r3
 801c43a:	f7fe ff73 	bl	801b324 <TraceSend>
    PRINTF("SensiLoRa 2.0\r\n");
 801c43e:	4b27      	ldr	r3, [pc, #156]	; (801c4dc <main+0xc4>)
 801c440:	0018      	movs	r0, r3
 801c442:	f7fe ff6f 	bl	801b324 <TraceSend>
//    PRINTF("Project configuration: %s\r\n", PROJECT_CONFIGURATION);
    PRINTF("Hardware ver. %s\r\n", HARDWARE_VERSION);
 801c446:	4a26      	ldr	r2, [pc, #152]	; (801c4e0 <main+0xc8>)
 801c448:	4b26      	ldr	r3, [pc, #152]	; (801c4e4 <main+0xcc>)
 801c44a:	0011      	movs	r1, r2
 801c44c:	0018      	movs	r0, r3
 801c44e:	f7fe ff69 	bl	801b324 <TraceSend>
    PRINTF("Firmware ver. %s\r\n", FIRMWARE_VERSION);
 801c452:	4a25      	ldr	r2, [pc, #148]	; (801c4e8 <main+0xd0>)
 801c454:	4b25      	ldr	r3, [pc, #148]	; (801c4ec <main+0xd4>)
 801c456:	0011      	movs	r1, r2
 801c458:	0018      	movs	r0, r3
 801c45a:	f7fe ff63 	bl	801b324 <TraceSend>
    PRINTF("Compiled %s %s\r\n", __DATE__, __TIME__);
 801c45e:	4a24      	ldr	r2, [pc, #144]	; (801c4f0 <main+0xd8>)
 801c460:	4924      	ldr	r1, [pc, #144]	; (801c4f4 <main+0xdc>)
 801c462:	4b25      	ldr	r3, [pc, #148]	; (801c4f8 <main+0xe0>)
 801c464:	0018      	movs	r0, r3
 801c466:	f7fe ff5d 	bl	801b324 <TraceSend>
    PRINTF("*********************************\r\n");
 801c46a:	4b24      	ldr	r3, [pc, #144]	; (801c4fc <main+0xe4>)
 801c46c:	0018      	movs	r0, r3
 801c46e:	f7fe ff59 	bl	801b324 <TraceSend>

    PRINTF("Lib ver. %02X.%02X.%02X.%02X\r\n",
 801c472:	4823      	ldr	r0, [pc, #140]	; (801c500 <main+0xe8>)
 801c474:	2300      	movs	r3, #0
 801c476:	9300      	str	r3, [sp, #0]
 801c478:	2300      	movs	r3, #0
 801c47a:	2203      	movs	r2, #3
 801c47c:	2101      	movs	r1, #1
 801c47e:	f7fe ff51 	bl	801b324 <TraceSend>
           (uint8_t)(__APP_VERSION >> 24), (uint8_t)(__APP_VERSION >> 16),
           (uint8_t)(__APP_VERSION >> 8), (uint8_t)__APP_VERSION);
    PRINTF("MAC ver. %02X.%02X.%02X.%02X\r\n",
 801c482:	4820      	ldr	r0, [pc, #128]	; (801c504 <main+0xec>)
 801c484:	2300      	movs	r3, #0
 801c486:	9300      	str	r3, [sp, #0]
 801c488:	2302      	movs	r3, #2
 801c48a:	2204      	movs	r2, #4
 801c48c:	2104      	movs	r1, #4
 801c48e:	f7fe ff49 	bl	801b324 <TraceSend>
           (uint8_t)(__LORA_MAC_VERSION >> 24),
           (uint8_t)(__LORA_MAC_VERSION >> 16),
           (uint8_t)(__LORA_MAC_VERSION >> 8), (uint8_t)__LORA_MAC_VERSION);

    /* Configure the Lora Stack*/
    LORA_Init(&LoRaMainCallbacks, &LoRaParamInit);
 801c492:	4a1d      	ldr	r2, [pc, #116]	; (801c508 <main+0xf0>)
 801c494:	4b1d      	ldr	r3, [pc, #116]	; (801c50c <main+0xf4>)
 801c496:	0011      	movs	r1, r2
 801c498:	0018      	movs	r0, r3
 801c49a:	f7fd fe13 	bl	801a0c4 <LORA_Init>

    LORA_Join();
 801c49e:	f7fd ff8d 	bl	801a3bc <LORA_Join>

    LoraStartTx(TX_ON_TIMER);
 801c4a2:	2000      	movs	r0, #0
 801c4a4:	f000 fa28 	bl	801c8f8 <LoraStartTx>

    while (1)
    {
        if (AppProcessRequest == LORA_SET)
 801c4a8:	4b19      	ldr	r3, [pc, #100]	; (801c510 <main+0xf8>)
 801c4aa:	781b      	ldrb	r3, [r3, #0]
 801c4ac:	2b01      	cmp	r3, #1
 801c4ae:	d105      	bne.n	801c4bc <main+0xa4>
        {
            /*reset notification flag*/
            AppProcessRequest = LORA_RESET;
 801c4b0:	4b17      	ldr	r3, [pc, #92]	; (801c510 <main+0xf8>)
 801c4b2:	2200      	movs	r2, #0
 801c4b4:	701a      	strb	r2, [r3, #0]
            /*Send*/
            Send(NULL);
 801c4b6:	2000      	movs	r0, #0
 801c4b8:	f000 f846 	bl	801c548 <Send>
        }
        if (LoraMacProcessRequest == LORA_SET)
 801c4bc:	4b15      	ldr	r3, [pc, #84]	; (801c514 <main+0xfc>)
 801c4be:	781b      	ldrb	r3, [r3, #0]
 801c4c0:	2b01      	cmp	r3, #1
 801c4c2:	d104      	bne.n	801c4ce <main+0xb6>
        {
            /*reset notification flag*/
            LoraMacProcessRequest = LORA_RESET;
 801c4c4:	4b13      	ldr	r3, [pc, #76]	; (801c514 <main+0xfc>)
 801c4c6:	2200      	movs	r2, #0
 801c4c8:	701a      	strb	r2, [r3, #0]
            LoRaMacProcess();
 801c4ca:	f7f4 fb27 	bl	8010b1c <LoRaMacProcess>
  __ASM volatile ("cpsid i" : : : "memory");
 801c4ce:	b672      	cpsid	i
}
 801c4d0:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("cpsie i" : : : "memory");
 801c4d2:	b662      	cpsie	i
}
 801c4d4:	46c0      	nop			; (mov r8, r8)
        if (AppProcessRequest == LORA_SET)
 801c4d6:	e7e7      	b.n	801c4a8 <main+0x90>
 801c4d8:	0801fb88 	.word	0x0801fb88
 801c4dc:	0801fbb0 	.word	0x0801fbb0
 801c4e0:	0801fbc0 	.word	0x0801fbc0
 801c4e4:	0801fbcc 	.word	0x0801fbcc
 801c4e8:	0801fbe0 	.word	0x0801fbe0
 801c4ec:	0801fbec 	.word	0x0801fbec
 801c4f0:	0801fc00 	.word	0x0801fc00
 801c4f4:	0801fc0c 	.word	0x0801fc0c
 801c4f8:	0801fc18 	.word	0x0801fc18
 801c4fc:	0801fc2c 	.word	0x0801fc2c
 801c500:	0801fc50 	.word	0x0801fc50
 801c504:	0801fc70 	.word	0x0801fc70
 801c508:	200002cc 	.word	0x200002cc
 801c50c:	200002a8 	.word	0x200002a8
 801c510:	200015b5 	.word	0x200015b5
 801c514:	200015b4 	.word	0x200015b4

0801c518 <LoraMacProcessNotify>:
        /* USER CODE END 2 */
    }
}

void LoraMacProcessNotify(void)
{
 801c518:	b580      	push	{r7, lr}
 801c51a:	af00      	add	r7, sp, #0
    LoraMacProcessRequest = LORA_SET;
 801c51c:	4b02      	ldr	r3, [pc, #8]	; (801c528 <LoraMacProcessNotify+0x10>)
 801c51e:	2201      	movs	r2, #1
 801c520:	701a      	strb	r2, [r3, #0]
}
 801c522:	46c0      	nop			; (mov r8, r8)
 801c524:	46bd      	mov	sp, r7
 801c526:	bd80      	pop	{r7, pc}
 801c528:	200015b4 	.word	0x200015b4

0801c52c <LORA_HasJoined>:

static void LORA_HasJoined(void)
{
 801c52c:	b580      	push	{r7, lr}
 801c52e:	af00      	add	r7, sp, #0
#if( OVER_THE_AIR_ACTIVATION != 0 )
    PRINTF("JOINED\n\r");
 801c530:	4b04      	ldr	r3, [pc, #16]	; (801c544 <LORA_HasJoined+0x18>)
 801c532:	0018      	movs	r0, r3
 801c534:	f7fe fef6 	bl	801b324 <TraceSend>
#endif
    LORA_RequestClass(LORAWAN_DEFAULT_CLASS);
 801c538:	2000      	movs	r0, #0
 801c53a:	f7fd ffe1 	bl	801a500 <LORA_RequestClass>
}
 801c53e:	46c0      	nop			; (mov r8, r8)
 801c540:	46bd      	mov	sp, r7
 801c542:	bd80      	pop	{r7, pc}
 801c544:	0801fc90 	.word	0x0801fc90

0801c548 <Send>:

static void Send(void* context)
{
 801c548:	b5f0      	push	{r4, r5, r6, r7, lr}
 801c54a:	b08d      	sub	sp, #52	; 0x34
 801c54c:	af00      	add	r7, sp, #0
 801c54e:	6078      	str	r0, [r7, #4]
    /* USER CODE BEGIN 3 */
    uint16_t pressure = 0;
 801c550:	232e      	movs	r3, #46	; 0x2e
 801c552:	18fb      	adds	r3, r7, r3
 801c554:	2200      	movs	r2, #0
 801c556:	801a      	strh	r2, [r3, #0]
    int16_t temperature = 0;
 801c558:	232c      	movs	r3, #44	; 0x2c
 801c55a:	18fb      	adds	r3, r7, r3
 801c55c:	2200      	movs	r2, #0
 801c55e:	801a      	strh	r2, [r3, #0]
    uint16_t humidity = 0;
 801c560:	232a      	movs	r3, #42	; 0x2a
 801c562:	18fb      	adds	r3, r7, r3
 801c564:	2200      	movs	r2, #0
 801c566:	801a      	strh	r2, [r3, #0]
    uint8_t batteryLevel;
    sensor_t sensor_data;

    if (LORA_JoinStatus() != LORA_SET)
 801c568:	f7fd ff46 	bl	801a3f8 <LORA_JoinStatus>
 801c56c:	0003      	movs	r3, r0
 801c56e:	2b01      	cmp	r3, #1
 801c570:	d002      	beq.n	801c578 <Send+0x30>
    {
        /*Not joined, try again later*/
        LORA_Join();
 801c572:	f7fd ff23 	bl	801a3bc <LORA_Join>
 801c576:	e118      	b.n	801c7aa <Send+0x262>
  int32_t latitude, longitude = 0;
  uint16_t altitudeGps = 0;
#endif

#ifdef USE_B_L072Z_LRWAN1
    TimerInit(&TxLedTimer, OnTimerLedEvent);
 801c578:	4a8d      	ldr	r2, [pc, #564]	; (801c7b0 <Send+0x268>)
 801c57a:	4b8e      	ldr	r3, [pc, #568]	; (801c7b4 <Send+0x26c>)
 801c57c:	0011      	movs	r1, r2
 801c57e:	0018      	movs	r0, r3
 801c580:	f7fe fc62 	bl	801ae48 <TimerInit>

    TimerSetValue(&TxLedTimer, 200);
 801c584:	4b8b      	ldr	r3, [pc, #556]	; (801c7b4 <Send+0x26c>)
 801c586:	21c8      	movs	r1, #200	; 0xc8
 801c588:	0018      	movs	r0, r3
 801c58a:	f7fe fdd5 	bl	801b138 <TimerSetValue>

    LED_On(LED_RED1);
 801c58e:	2001      	movs	r0, #1
 801c590:	f7e6 fec2 	bl	8003318 <BSP_LED_On>

    TimerStart(&TxLedTimer);
 801c594:	4b87      	ldr	r3, [pc, #540]	; (801c7b4 <Send+0x26c>)
 801c596:	0018      	movs	r0, r3
 801c598:	f7fe fc74 	bl	801ae84 <TimerStart>
#endif

    BSP_sensor_Read(&sensor_data);
 801c59c:	2608      	movs	r6, #8
 801c59e:	19bb      	adds	r3, r7, r6
 801c5a0:	0018      	movs	r0, r3
 801c5a2:	f7ff f82f 	bl	801b604 <BSP_sensor_Read>

#ifdef CAYENNE_LPP
    uint8_t cchannel = 0;
 801c5a6:	2529      	movs	r5, #41	; 0x29
 801c5a8:	197b      	adds	r3, r7, r5
 801c5aa:	2200      	movs	r2, #0
 801c5ac:	701a      	strb	r2, [r3, #0]
    temperature = (int16_t) (sensor_data.temperature * 10); /* in C * 10 */
 801c5ae:	19bb      	adds	r3, r7, r6
 801c5b0:	685b      	ldr	r3, [r3, #4]
 801c5b2:	4981      	ldr	r1, [pc, #516]	; (801c7b8 <Send+0x270>)
 801c5b4:	1c18      	adds	r0, r3, #0
 801c5b6:	f7e4 fc27 	bl	8000e08 <__aeabi_fmul>
 801c5ba:	1c03      	adds	r3, r0, #0
 801c5bc:	222c      	movs	r2, #44	; 0x2c
 801c5be:	18bc      	adds	r4, r7, r2
 801c5c0:	1c18      	adds	r0, r3, #0
 801c5c2:	f7e4 ff03 	bl	80013cc <__aeabi_f2iz>
 801c5c6:	0003      	movs	r3, r0
 801c5c8:	8023      	strh	r3, [r4, #0]
    pressure = (uint16_t) (sensor_data.pressure * 100 / 10); /* in hPa / 10 */
 801c5ca:	19bb      	adds	r3, r7, r6
 801c5cc:	681b      	ldr	r3, [r3, #0]
 801c5ce:	497b      	ldr	r1, [pc, #492]	; (801c7bc <Send+0x274>)
 801c5d0:	1c18      	adds	r0, r3, #0
 801c5d2:	f7e4 fc19 	bl	8000e08 <__aeabi_fmul>
 801c5d6:	1c03      	adds	r3, r0, #0
 801c5d8:	4977      	ldr	r1, [pc, #476]	; (801c7b8 <Send+0x270>)
 801c5da:	1c18      	adds	r0, r3, #0
 801c5dc:	f7e4 fa4a 	bl	8000a74 <__aeabi_fdiv>
 801c5e0:	1c03      	adds	r3, r0, #0
 801c5e2:	212e      	movs	r1, #46	; 0x2e
 801c5e4:	187c      	adds	r4, r7, r1
 801c5e6:	1c18      	adds	r0, r3, #0
 801c5e8:	f7e3 ffa6 	bl	8000538 <__aeabi_f2uiz>
 801c5ec:	0003      	movs	r3, r0
 801c5ee:	8023      	strh	r3, [r4, #0]
    humidity = (uint16_t) (sensor_data.humidity * 2); /* in %*2     */
 801c5f0:	19bb      	adds	r3, r7, r6
 801c5f2:	689b      	ldr	r3, [r3, #8]
 801c5f4:	1c19      	adds	r1, r3, #0
 801c5f6:	1c18      	adds	r0, r3, #0
 801c5f8:	f7e4 f8a0 	bl	800073c <__aeabi_fadd>
 801c5fc:	1c03      	adds	r3, r0, #0
 801c5fe:	202a      	movs	r0, #42	; 0x2a
 801c600:	183c      	adds	r4, r7, r0
 801c602:	1c18      	adds	r0, r3, #0
 801c604:	f7e3 ff98 	bl	8000538 <__aeabi_f2uiz>
 801c608:	0003      	movs	r3, r0
 801c60a:	8023      	strh	r3, [r4, #0]
    uint32_t i = 0;
 801c60c:	2300      	movs	r3, #0
 801c60e:	627b      	str	r3, [r7, #36]	; 0x24

    batteryLevel = LORA_GetBatteryLevel(); /* 1 (very low) to 254 (fully charged) */
 801c610:	2323      	movs	r3, #35	; 0x23
 801c612:	18fc      	adds	r4, r7, r3
 801c614:	f000 f9f0 	bl	801c9f8 <LORA_GetBatteryLevel>
 801c618:	0003      	movs	r3, r0
 801c61a:	7023      	strb	r3, [r4, #0]

    AppData.Port = LPP_APP_PORT;
 801c61c:	4b68      	ldr	r3, [pc, #416]	; (801c7c0 <Send+0x278>)
 801c61e:	2263      	movs	r2, #99	; 0x63
 801c620:	715a      	strb	r2, [r3, #5]

    AppData.Buff[i++] = cchannel++;
 801c622:	002c      	movs	r4, r5
 801c624:	193b      	adds	r3, r7, r4
 801c626:	781a      	ldrb	r2, [r3, #0]
 801c628:	193b      	adds	r3, r7, r4
 801c62a:	1c51      	adds	r1, r2, #1
 801c62c:	7019      	strb	r1, [r3, #0]
 801c62e:	4b64      	ldr	r3, [pc, #400]	; (801c7c0 <Send+0x278>)
 801c630:	6819      	ldr	r1, [r3, #0]
 801c632:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c634:	1c58      	adds	r0, r3, #1
 801c636:	6278      	str	r0, [r7, #36]	; 0x24
 801c638:	18cb      	adds	r3, r1, r3
 801c63a:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = LPP_DATATYPE_BAROMETER;
 801c63c:	4b60      	ldr	r3, [pc, #384]	; (801c7c0 <Send+0x278>)
 801c63e:	681a      	ldr	r2, [r3, #0]
 801c640:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c642:	1c59      	adds	r1, r3, #1
 801c644:	6279      	str	r1, [r7, #36]	; 0x24
 801c646:	18d3      	adds	r3, r2, r3
 801c648:	2273      	movs	r2, #115	; 0x73
 801c64a:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = (pressure >> 8) & 0xFF;
 801c64c:	262e      	movs	r6, #46	; 0x2e
 801c64e:	19bb      	adds	r3, r7, r6
 801c650:	881b      	ldrh	r3, [r3, #0]
 801c652:	0a1b      	lsrs	r3, r3, #8
 801c654:	b298      	uxth	r0, r3
 801c656:	4b5a      	ldr	r3, [pc, #360]	; (801c7c0 <Send+0x278>)
 801c658:	681a      	ldr	r2, [r3, #0]
 801c65a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c65c:	1c59      	adds	r1, r3, #1
 801c65e:	6279      	str	r1, [r7, #36]	; 0x24
 801c660:	18d3      	adds	r3, r2, r3
 801c662:	b2c2      	uxtb	r2, r0
 801c664:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = pressure & 0xFF;
 801c666:	4b56      	ldr	r3, [pc, #344]	; (801c7c0 <Send+0x278>)
 801c668:	681a      	ldr	r2, [r3, #0]
 801c66a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c66c:	1c59      	adds	r1, r3, #1
 801c66e:	6279      	str	r1, [r7, #36]	; 0x24
 801c670:	18d3      	adds	r3, r2, r3
 801c672:	19ba      	adds	r2, r7, r6
 801c674:	8812      	ldrh	r2, [r2, #0]
 801c676:	b2d2      	uxtb	r2, r2
 801c678:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = cchannel++;
 801c67a:	193b      	adds	r3, r7, r4
 801c67c:	781a      	ldrb	r2, [r3, #0]
 801c67e:	193b      	adds	r3, r7, r4
 801c680:	1c51      	adds	r1, r2, #1
 801c682:	7019      	strb	r1, [r3, #0]
 801c684:	4b4e      	ldr	r3, [pc, #312]	; (801c7c0 <Send+0x278>)
 801c686:	6819      	ldr	r1, [r3, #0]
 801c688:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c68a:	1c58      	adds	r0, r3, #1
 801c68c:	6278      	str	r0, [r7, #36]	; 0x24
 801c68e:	18cb      	adds	r3, r1, r3
 801c690:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = LPP_DATATYPE_TEMPERATURE;
 801c692:	4b4b      	ldr	r3, [pc, #300]	; (801c7c0 <Send+0x278>)
 801c694:	681a      	ldr	r2, [r3, #0]
 801c696:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c698:	1c59      	adds	r1, r3, #1
 801c69a:	6279      	str	r1, [r7, #36]	; 0x24
 801c69c:	18d3      	adds	r3, r2, r3
 801c69e:	2267      	movs	r2, #103	; 0x67
 801c6a0:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = (temperature >> 8) & 0xFF;
 801c6a2:	252c      	movs	r5, #44	; 0x2c
 801c6a4:	197b      	adds	r3, r7, r5
 801c6a6:	2200      	movs	r2, #0
 801c6a8:	5e9b      	ldrsh	r3, [r3, r2]
 801c6aa:	121b      	asrs	r3, r3, #8
 801c6ac:	b218      	sxth	r0, r3
 801c6ae:	4b44      	ldr	r3, [pc, #272]	; (801c7c0 <Send+0x278>)
 801c6b0:	681a      	ldr	r2, [r3, #0]
 801c6b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c6b4:	1c59      	adds	r1, r3, #1
 801c6b6:	6279      	str	r1, [r7, #36]	; 0x24
 801c6b8:	18d3      	adds	r3, r2, r3
 801c6ba:	b2c2      	uxtb	r2, r0
 801c6bc:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = temperature & 0xFF;
 801c6be:	4b40      	ldr	r3, [pc, #256]	; (801c7c0 <Send+0x278>)
 801c6c0:	681a      	ldr	r2, [r3, #0]
 801c6c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c6c4:	1c59      	adds	r1, r3, #1
 801c6c6:	6279      	str	r1, [r7, #36]	; 0x24
 801c6c8:	18d3      	adds	r3, r2, r3
 801c6ca:	197a      	adds	r2, r7, r5
 801c6cc:	8812      	ldrh	r2, [r2, #0]
 801c6ce:	b2d2      	uxtb	r2, r2
 801c6d0:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = cchannel++;
 801c6d2:	193b      	adds	r3, r7, r4
 801c6d4:	781a      	ldrb	r2, [r3, #0]
 801c6d6:	193b      	adds	r3, r7, r4
 801c6d8:	1c51      	adds	r1, r2, #1
 801c6da:	7019      	strb	r1, [r3, #0]
 801c6dc:	4b38      	ldr	r3, [pc, #224]	; (801c7c0 <Send+0x278>)
 801c6de:	6819      	ldr	r1, [r3, #0]
 801c6e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c6e2:	1c58      	adds	r0, r3, #1
 801c6e4:	6278      	str	r0, [r7, #36]	; 0x24
 801c6e6:	18cb      	adds	r3, r1, r3
 801c6e8:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = LPP_DATATYPE_HUMIDITY;
 801c6ea:	4b35      	ldr	r3, [pc, #212]	; (801c7c0 <Send+0x278>)
 801c6ec:	681a      	ldr	r2, [r3, #0]
 801c6ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c6f0:	1c59      	adds	r1, r3, #1
 801c6f2:	6279      	str	r1, [r7, #36]	; 0x24
 801c6f4:	18d3      	adds	r3, r2, r3
 801c6f6:	2268      	movs	r2, #104	; 0x68
 801c6f8:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = humidity & 0xFF;
 801c6fa:	4b31      	ldr	r3, [pc, #196]	; (801c7c0 <Send+0x278>)
 801c6fc:	681a      	ldr	r2, [r3, #0]
 801c6fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c700:	1c59      	adds	r1, r3, #1
 801c702:	6279      	str	r1, [r7, #36]	; 0x24
 801c704:	18d3      	adds	r3, r2, r3
 801c706:	202a      	movs	r0, #42	; 0x2a
 801c708:	183a      	adds	r2, r7, r0
 801c70a:	8812      	ldrh	r2, [r2, #0]
 801c70c:	b2d2      	uxtb	r2, r2
 801c70e:	701a      	strb	r2, [r3, #0]
#if defined( REGION_US915 ) || defined ( REGION_AU915 ) || defined ( REGION_AS923 )
  /* The maximum payload size does not allow to send more data for lowest DRs */
#else
    AppData.Buff[i++] = cchannel++;
 801c710:	193b      	adds	r3, r7, r4
 801c712:	781a      	ldrb	r2, [r3, #0]
 801c714:	193b      	adds	r3, r7, r4
 801c716:	1c51      	adds	r1, r2, #1
 801c718:	7019      	strb	r1, [r3, #0]
 801c71a:	4b29      	ldr	r3, [pc, #164]	; (801c7c0 <Send+0x278>)
 801c71c:	6819      	ldr	r1, [r3, #0]
 801c71e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c720:	1c58      	adds	r0, r3, #1
 801c722:	6278      	str	r0, [r7, #36]	; 0x24
 801c724:	18cb      	adds	r3, r1, r3
 801c726:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = LPP_DATATYPE_DIGITAL_INPUT;
 801c728:	4b25      	ldr	r3, [pc, #148]	; (801c7c0 <Send+0x278>)
 801c72a:	681a      	ldr	r2, [r3, #0]
 801c72c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c72e:	1c59      	adds	r1, r3, #1
 801c730:	6279      	str	r1, [r7, #36]	; 0x24
 801c732:	18d3      	adds	r3, r2, r3
 801c734:	2200      	movs	r2, #0
 801c736:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = batteryLevel * 100 / 254;
 801c738:	2323      	movs	r3, #35	; 0x23
 801c73a:	18fb      	adds	r3, r7, r3
 801c73c:	781b      	ldrb	r3, [r3, #0]
 801c73e:	2264      	movs	r2, #100	; 0x64
 801c740:	4353      	muls	r3, r2
 801c742:	21fe      	movs	r1, #254	; 0xfe
 801c744:	0018      	movs	r0, r3
 801c746:	f7e3 fd73 	bl	8000230 <__divsi3>
 801c74a:	0003      	movs	r3, r0
 801c74c:	0018      	movs	r0, r3
 801c74e:	4b1c      	ldr	r3, [pc, #112]	; (801c7c0 <Send+0x278>)
 801c750:	681a      	ldr	r2, [r3, #0]
 801c752:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c754:	1c59      	adds	r1, r3, #1
 801c756:	6279      	str	r1, [r7, #36]	; 0x24
 801c758:	18d3      	adds	r3, r2, r3
 801c75a:	b2c2      	uxtb	r2, r0
 801c75c:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = cchannel++;
 801c75e:	193b      	adds	r3, r7, r4
 801c760:	781a      	ldrb	r2, [r3, #0]
 801c762:	193b      	adds	r3, r7, r4
 801c764:	1c51      	adds	r1, r2, #1
 801c766:	7019      	strb	r1, [r3, #0]
 801c768:	4b15      	ldr	r3, [pc, #84]	; (801c7c0 <Send+0x278>)
 801c76a:	6819      	ldr	r1, [r3, #0]
 801c76c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c76e:	1c58      	adds	r0, r3, #1
 801c770:	6278      	str	r0, [r7, #36]	; 0x24
 801c772:	18cb      	adds	r3, r1, r3
 801c774:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = LPP_DATATYPE_DIGITAL_OUTPUT;
 801c776:	4b12      	ldr	r3, [pc, #72]	; (801c7c0 <Send+0x278>)
 801c778:	681a      	ldr	r2, [r3, #0]
 801c77a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c77c:	1c59      	adds	r1, r3, #1
 801c77e:	6279      	str	r1, [r7, #36]	; 0x24
 801c780:	18d3      	adds	r3, r2, r3
 801c782:	2201      	movs	r2, #1
 801c784:	701a      	strb	r2, [r3, #0]
    AppData.Buff[i++] = AppLedStateOn;
 801c786:	4b0e      	ldr	r3, [pc, #56]	; (801c7c0 <Send+0x278>)
 801c788:	681a      	ldr	r2, [r3, #0]
 801c78a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c78c:	1c59      	adds	r1, r3, #1
 801c78e:	6279      	str	r1, [r7, #36]	; 0x24
 801c790:	18d3      	adds	r3, r2, r3
 801c792:	4a0c      	ldr	r2, [pc, #48]	; (801c7c4 <Send+0x27c>)
 801c794:	7812      	ldrb	r2, [r2, #0]
 801c796:	701a      	strb	r2, [r3, #0]
  AppData.Buff[i++] = longitude & 0xFF;
  AppData.Buff[i++] = (altitudeGps >> 8) & 0xFF;
  AppData.Buff[i++] = altitudeGps & 0xFF;
#endif  /* REGION_XX915 */
#endif  /* CAYENNE_LPP */
    AppData.BuffSize = i;
 801c798:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c79a:	b2da      	uxtb	r2, r3
 801c79c:	4b08      	ldr	r3, [pc, #32]	; (801c7c0 <Send+0x278>)
 801c79e:	711a      	strb	r2, [r3, #4]

    LORA_send(&AppData, LORAWAN_DEFAULT_CONFIRM_MSG_STATE);
 801c7a0:	4b07      	ldr	r3, [pc, #28]	; (801c7c0 <Send+0x278>)
 801c7a2:	2100      	movs	r1, #0
 801c7a4:	0018      	movs	r0, r3
 801c7a6:	f7fd fe3d 	bl	801a424 <LORA_send>

    /* USER CODE END 3 */
}
 801c7aa:	46bd      	mov	sp, r7
 801c7ac:	b00d      	add	sp, #52	; 0x34
 801c7ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801c7b0:	0801ca71 	.word	0x0801ca71
 801c7b4:	200015d0 	.word	0x200015d0
 801c7b8:	41200000 	.word	0x41200000
 801c7bc:	42c80000 	.word	0x42c80000
 801c7c0:	200002a0 	.word	0x200002a0
 801c7c4:	200015b6 	.word	0x200015b6

0801c7c8 <LORA_RxData>:

static void LORA_RxData(lora_AppData_t* AppData)
{
 801c7c8:	b580      	push	{r7, lr}
 801c7ca:	b082      	sub	sp, #8
 801c7cc:	af00      	add	r7, sp, #0
 801c7ce:	6078      	str	r0, [r7, #4]
    /* USER CODE BEGIN 4 */
    PRINTF("PACKET RECEIVED ON PORT %d\n\r", AppData->Port);
 801c7d0:	687b      	ldr	r3, [r7, #4]
 801c7d2:	795b      	ldrb	r3, [r3, #5]
 801c7d4:	001a      	movs	r2, r3
 801c7d6:	4b3a      	ldr	r3, [pc, #232]	; (801c8c0 <LORA_RxData+0xf8>)
 801c7d8:	0011      	movs	r1, r2
 801c7da:	0018      	movs	r0, r3
 801c7dc:	f7fe fda2 	bl	801b324 <TraceSend>

    switch (AppData->Port)
 801c7e0:	687b      	ldr	r3, [r7, #4]
 801c7e2:	795b      	ldrb	r3, [r3, #5]
 801c7e4:	2b63      	cmp	r3, #99	; 0x63
 801c7e6:	d044      	beq.n	801c872 <LORA_RxData+0xaa>
 801c7e8:	dd00      	ble.n	801c7ec <LORA_RxData+0x24>
 801c7ea:	e061      	b.n	801c8b0 <LORA_RxData+0xe8>
 801c7ec:	2b02      	cmp	r3, #2
 801c7ee:	d020      	beq.n	801c832 <LORA_RxData+0x6a>
 801c7f0:	2b03      	cmp	r3, #3
 801c7f2:	d15d      	bne.n	801c8b0 <LORA_RxData+0xe8>
    {
    case 3:
        /*this port switches the class*/
        if (AppData->BuffSize == 1)
 801c7f4:	687b      	ldr	r3, [r7, #4]
 801c7f6:	791b      	ldrb	r3, [r3, #4]
 801c7f8:	2b01      	cmp	r3, #1
 801c7fa:	d116      	bne.n	801c82a <LORA_RxData+0x62>
        {
            switch (AppData->Buff[0])
 801c7fc:	687b      	ldr	r3, [r7, #4]
 801c7fe:	681b      	ldr	r3, [r3, #0]
 801c800:	781b      	ldrb	r3, [r3, #0]
 801c802:	2b02      	cmp	r3, #2
 801c804:	d00d      	beq.n	801c822 <LORA_RxData+0x5a>
 801c806:	dc12      	bgt.n	801c82e <LORA_RxData+0x66>
 801c808:	2b00      	cmp	r3, #0
 801c80a:	d002      	beq.n	801c812 <LORA_RxData+0x4a>
 801c80c:	2b01      	cmp	r3, #1
 801c80e:	d004      	beq.n	801c81a <LORA_RxData+0x52>
            {
                LORA_RequestClass(CLASS_C);
                break;
            }
            default:
                break;
 801c810:	e00d      	b.n	801c82e <LORA_RxData+0x66>
                LORA_RequestClass(CLASS_A);
 801c812:	2000      	movs	r0, #0
 801c814:	f7fd fe74 	bl	801a500 <LORA_RequestClass>
                break;
 801c818:	e00a      	b.n	801c830 <LORA_RxData+0x68>
                LORA_RequestClass(CLASS_B);
 801c81a:	2001      	movs	r0, #1
 801c81c:	f7fd fe70 	bl	801a500 <LORA_RequestClass>
                break;
 801c820:	e006      	b.n	801c830 <LORA_RxData+0x68>
                LORA_RequestClass(CLASS_C);
 801c822:	2002      	movs	r0, #2
 801c824:	f7fd fe6c 	bl	801a500 <LORA_RequestClass>
                break;
 801c828:	e002      	b.n	801c830 <LORA_RxData+0x68>
            }
        }
 801c82a:	46c0      	nop			; (mov r8, r8)
 801c82c:	e043      	b.n	801c8b6 <LORA_RxData+0xee>
                break;
 801c82e:	46c0      	nop			; (mov r8, r8)
        break;
 801c830:	e041      	b.n	801c8b6 <LORA_RxData+0xee>
    case LORAWAN_APP_PORT:
        if (AppData->BuffSize == 1)
 801c832:	687b      	ldr	r3, [r7, #4]
 801c834:	791b      	ldrb	r3, [r3, #4]
 801c836:	2b01      	cmp	r3, #1
 801c838:	d13c      	bne.n	801c8b4 <LORA_RxData+0xec>
        {
            AppLedStateOn = AppData->Buff[0] & 0x01;
 801c83a:	687b      	ldr	r3, [r7, #4]
 801c83c:	681b      	ldr	r3, [r3, #0]
 801c83e:	781b      	ldrb	r3, [r3, #0]
 801c840:	2201      	movs	r2, #1
 801c842:	4013      	ands	r3, r2
 801c844:	b2da      	uxtb	r2, r3
 801c846:	4b1f      	ldr	r3, [pc, #124]	; (801c8c4 <LORA_RxData+0xfc>)
 801c848:	701a      	strb	r2, [r3, #0]
            if (AppLedStateOn == RESET)
 801c84a:	4b1e      	ldr	r3, [pc, #120]	; (801c8c4 <LORA_RxData+0xfc>)
 801c84c:	781b      	ldrb	r3, [r3, #0]
 801c84e:	2b00      	cmp	r3, #0
 801c850:	d107      	bne.n	801c862 <LORA_RxData+0x9a>
            {
                PRINTF("LED OFF\n\r");
 801c852:	4b1d      	ldr	r3, [pc, #116]	; (801c8c8 <LORA_RxData+0x100>)
 801c854:	0018      	movs	r0, r3
 801c856:	f7fe fd65 	bl	801b324 <TraceSend>
                LED_Off(LED_BLUE);
 801c85a:	2002      	movs	r0, #2
 801c85c:	f7e6 fd78 	bl	8003350 <BSP_LED_Off>
            {
                PRINTF("LED ON\n\r");
                LED_On(LED_BLUE);
            }
        }
        break;
 801c860:	e028      	b.n	801c8b4 <LORA_RxData+0xec>
                PRINTF("LED ON\n\r");
 801c862:	4b1a      	ldr	r3, [pc, #104]	; (801c8cc <LORA_RxData+0x104>)
 801c864:	0018      	movs	r0, r3
 801c866:	f7fe fd5d 	bl	801b324 <TraceSend>
                LED_On(LED_BLUE);
 801c86a:	2002      	movs	r0, #2
 801c86c:	f7e6 fd54 	bl	8003318 <BSP_LED_On>
        break;
 801c870:	e020      	b.n	801c8b4 <LORA_RxData+0xec>
    case LPP_APP_PORT:
    {
        AppLedStateOn = (AppData->Buff[2] == 100) ? 0x01 : 0x00;
 801c872:	687b      	ldr	r3, [r7, #4]
 801c874:	681b      	ldr	r3, [r3, #0]
 801c876:	3302      	adds	r3, #2
 801c878:	781b      	ldrb	r3, [r3, #0]
 801c87a:	3b64      	subs	r3, #100	; 0x64
 801c87c:	425a      	negs	r2, r3
 801c87e:	4153      	adcs	r3, r2
 801c880:	b2db      	uxtb	r3, r3
 801c882:	001a      	movs	r2, r3
 801c884:	4b0f      	ldr	r3, [pc, #60]	; (801c8c4 <LORA_RxData+0xfc>)
 801c886:	701a      	strb	r2, [r3, #0]
        if (AppLedStateOn == RESET)
 801c888:	4b0e      	ldr	r3, [pc, #56]	; (801c8c4 <LORA_RxData+0xfc>)
 801c88a:	781b      	ldrb	r3, [r3, #0]
 801c88c:	2b00      	cmp	r3, #0
 801c88e:	d107      	bne.n	801c8a0 <LORA_RxData+0xd8>
        {
            PRINTF("LED OFF\n\r");
 801c890:	4b0d      	ldr	r3, [pc, #52]	; (801c8c8 <LORA_RxData+0x100>)
 801c892:	0018      	movs	r0, r3
 801c894:	f7fe fd46 	bl	801b324 <TraceSend>
            LED_Off(LED_BLUE);
 801c898:	2002      	movs	r0, #2
 801c89a:	f7e6 fd59 	bl	8003350 <BSP_LED_Off>
        } else
        {
            PRINTF("LED ON\n\r");
            LED_On(LED_BLUE);
        }
        break;
 801c89e:	e00a      	b.n	801c8b6 <LORA_RxData+0xee>
            PRINTF("LED ON\n\r");
 801c8a0:	4b0a      	ldr	r3, [pc, #40]	; (801c8cc <LORA_RxData+0x104>)
 801c8a2:	0018      	movs	r0, r3
 801c8a4:	f7fe fd3e 	bl	801b324 <TraceSend>
            LED_On(LED_BLUE);
 801c8a8:	2002      	movs	r0, #2
 801c8aa:	f7e6 fd35 	bl	8003318 <BSP_LED_On>
        break;
 801c8ae:	e002      	b.n	801c8b6 <LORA_RxData+0xee>
    }
    default:
        break;
 801c8b0:	46c0      	nop			; (mov r8, r8)
 801c8b2:	e000      	b.n	801c8b6 <LORA_RxData+0xee>
        break;
 801c8b4:	46c0      	nop			; (mov r8, r8)
    }
    /* USER CODE END 4 */
}
 801c8b6:	46c0      	nop			; (mov r8, r8)
 801c8b8:	46bd      	mov	sp, r7
 801c8ba:	b002      	add	sp, #8
 801c8bc:	bd80      	pop	{r7, pc}
 801c8be:	46c0      	nop			; (mov r8, r8)
 801c8c0:	0801fc9c 	.word	0x0801fc9c
 801c8c4:	200015b6 	.word	0x200015b6
 801c8c8:	0801fcbc 	.word	0x0801fcbc
 801c8cc:	0801fcc8 	.word	0x0801fcc8

0801c8d0 <OnTxTimerEvent>:

static void OnTxTimerEvent(void* context)
{
 801c8d0:	b580      	push	{r7, lr}
 801c8d2:	b082      	sub	sp, #8
 801c8d4:	af00      	add	r7, sp, #0
 801c8d6:	6078      	str	r0, [r7, #4]
    /*Wait for next tx slot*/
    TimerStart(&TxTimer);
 801c8d8:	4b05      	ldr	r3, [pc, #20]	; (801c8f0 <OnTxTimerEvent+0x20>)
 801c8da:	0018      	movs	r0, r3
 801c8dc:	f7fe fad2 	bl	801ae84 <TimerStart>

    AppProcessRequest = LORA_SET;
 801c8e0:	4b04      	ldr	r3, [pc, #16]	; (801c8f4 <OnTxTimerEvent+0x24>)
 801c8e2:	2201      	movs	r2, #1
 801c8e4:	701a      	strb	r2, [r3, #0]
}
 801c8e6:	46c0      	nop			; (mov r8, r8)
 801c8e8:	46bd      	mov	sp, r7
 801c8ea:	b002      	add	sp, #8
 801c8ec:	bd80      	pop	{r7, pc}
 801c8ee:	46c0      	nop			; (mov r8, r8)
 801c8f0:	200015b8 	.word	0x200015b8
 801c8f4:	200015b5 	.word	0x200015b5

0801c8f8 <LoraStartTx>:

static void LoraStartTx(TxEventType_t EventType)
{
 801c8f8:	b590      	push	{r4, r7, lr}
 801c8fa:	b089      	sub	sp, #36	; 0x24
 801c8fc:	af00      	add	r7, sp, #0
 801c8fe:	0002      	movs	r2, r0
 801c900:	1dfb      	adds	r3, r7, #7
 801c902:	701a      	strb	r2, [r3, #0]
    if (EventType == TX_ON_TIMER)
 801c904:	1dfb      	adds	r3, r7, #7
 801c906:	781b      	ldrb	r3, [r3, #0]
 801c908:	2b00      	cmp	r3, #0
 801c90a:	d10f      	bne.n	801c92c <LoraStartTx+0x34>
    {
        /* send everytime timer elapses */
        TimerInit(&TxTimer, OnTxTimerEvent);
 801c90c:	4a18      	ldr	r2, [pc, #96]	; (801c970 <LoraStartTx+0x78>)
 801c90e:	4b19      	ldr	r3, [pc, #100]	; (801c974 <LoraStartTx+0x7c>)
 801c910:	0011      	movs	r1, r2
 801c912:	0018      	movs	r0, r3
 801c914:	f7fe fa98 	bl	801ae48 <TimerInit>
        TimerSetValue(&TxTimer, APP_TX_DUTYCYCLE);
 801c918:	4a17      	ldr	r2, [pc, #92]	; (801c978 <LoraStartTx+0x80>)
 801c91a:	4b16      	ldr	r3, [pc, #88]	; (801c974 <LoraStartTx+0x7c>)
 801c91c:	0011      	movs	r1, r2
 801c91e:	0018      	movs	r0, r3
 801c920:	f7fe fc0a 	bl	801b138 <TimerSetValue>
        OnTxTimerEvent(NULL);
 801c924:	2000      	movs	r0, #0
 801c926:	f7ff ffd3 	bl	801c8d0 <OnTxTimerEvent>
        initStruct.Speed = GPIO_SPEED_HIGH;

        HW_GPIO_Init(USER_BUTTON_GPIO_PORT, USER_BUTTON_PIN, &initStruct);
        HW_GPIO_SetIrq(USER_BUTTON_GPIO_PORT, USER_BUTTON_PIN, 0, Send);
    }
}
 801c92a:	e01c      	b.n	801c966 <LoraStartTx+0x6e>
        GPIO_InitTypeDef initStruct = { 0 };
 801c92c:	240c      	movs	r4, #12
 801c92e:	193b      	adds	r3, r7, r4
 801c930:	0018      	movs	r0, r3
 801c932:	2314      	movs	r3, #20
 801c934:	001a      	movs	r2, r3
 801c936:	2100      	movs	r1, #0
 801c938:	f000 fe0c 	bl	801d554 <memset>
        initStruct.Mode = GPIO_MODE_IT_RISING;
 801c93c:	193b      	adds	r3, r7, r4
 801c93e:	4a0f      	ldr	r2, [pc, #60]	; (801c97c <LoraStartTx+0x84>)
 801c940:	605a      	str	r2, [r3, #4]
        initStruct.Pull = GPIO_PULLUP;
 801c942:	193b      	adds	r3, r7, r4
 801c944:	2201      	movs	r2, #1
 801c946:	609a      	str	r2, [r3, #8]
        initStruct.Speed = GPIO_SPEED_HIGH;
 801c948:	193b      	adds	r3, r7, r4
 801c94a:	2203      	movs	r2, #3
 801c94c:	60da      	str	r2, [r3, #12]
        HW_GPIO_Init(USER_BUTTON_GPIO_PORT, USER_BUTTON_PIN, &initStruct);
 801c94e:	193b      	adds	r3, r7, r4
 801c950:	480b      	ldr	r0, [pc, #44]	; (801c980 <LoraStartTx+0x88>)
 801c952:	001a      	movs	r2, r3
 801c954:	2104      	movs	r1, #4
 801c956:	f7fe ff25 	bl	801b7a4 <HW_GPIO_Init>
        HW_GPIO_SetIrq(USER_BUTTON_GPIO_PORT, USER_BUTTON_PIN, 0, Send);
 801c95a:	4b0a      	ldr	r3, [pc, #40]	; (801c984 <LoraStartTx+0x8c>)
 801c95c:	4808      	ldr	r0, [pc, #32]	; (801c980 <LoraStartTx+0x88>)
 801c95e:	2200      	movs	r2, #0
 801c960:	2104      	movs	r1, #4
 801c962:	f7fe ff95 	bl	801b890 <HW_GPIO_SetIrq>
}
 801c966:	46c0      	nop			; (mov r8, r8)
 801c968:	46bd      	mov	sp, r7
 801c96a:	b009      	add	sp, #36	; 0x24
 801c96c:	bd90      	pop	{r4, r7, pc}
 801c96e:	46c0      	nop			; (mov r8, r8)
 801c970:	0801c8d1 	.word	0x0801c8d1
 801c974:	200015b8 	.word	0x200015b8
 801c978:	00002710 	.word	0x00002710
 801c97c:	10110000 	.word	0x10110000
 801c980:	50000400 	.word	0x50000400
 801c984:	0801c549 	.word	0x0801c549

0801c988 <LORA_ConfirmClass>:

static void LORA_ConfirmClass(DeviceClass_t Class)
{
 801c988:	b580      	push	{r7, lr}
 801c98a:	b082      	sub	sp, #8
 801c98c:	af00      	add	r7, sp, #0
 801c98e:	0002      	movs	r2, r0
 801c990:	1dfb      	adds	r3, r7, #7
 801c992:	701a      	strb	r2, [r3, #0]
    PRINTF("switch to class %c done\n\r", "ABC"[Class]);
 801c994:	1dfb      	adds	r3, r7, #7
 801c996:	781b      	ldrb	r3, [r3, #0]
 801c998:	4a0b      	ldr	r2, [pc, #44]	; (801c9c8 <LORA_ConfirmClass+0x40>)
 801c99a:	5cd3      	ldrb	r3, [r2, r3]
 801c99c:	001a      	movs	r2, r3
 801c99e:	4b0b      	ldr	r3, [pc, #44]	; (801c9cc <LORA_ConfirmClass+0x44>)
 801c9a0:	0011      	movs	r1, r2
 801c9a2:	0018      	movs	r0, r3
 801c9a4:	f7fe fcbe 	bl	801b324 <TraceSend>

    /*Optionnal*/
    /*informs the server that switch has occurred ASAP*/
    AppData.BuffSize = 0;
 801c9a8:	4b09      	ldr	r3, [pc, #36]	; (801c9d0 <LORA_ConfirmClass+0x48>)
 801c9aa:	2200      	movs	r2, #0
 801c9ac:	711a      	strb	r2, [r3, #4]
    AppData.Port = LORAWAN_APP_PORT;
 801c9ae:	4b08      	ldr	r3, [pc, #32]	; (801c9d0 <LORA_ConfirmClass+0x48>)
 801c9b0:	2202      	movs	r2, #2
 801c9b2:	715a      	strb	r2, [r3, #5]

    LORA_send(&AppData, LORAWAN_UNCONFIRMED_MSG);
 801c9b4:	4b06      	ldr	r3, [pc, #24]	; (801c9d0 <LORA_ConfirmClass+0x48>)
 801c9b6:	2100      	movs	r1, #0
 801c9b8:	0018      	movs	r0, r3
 801c9ba:	f7fd fd33 	bl	801a424 <LORA_send>
}
 801c9be:	46c0      	nop			; (mov r8, r8)
 801c9c0:	46bd      	mov	sp, r7
 801c9c2:	b002      	add	sp, #8
 801c9c4:	bd80      	pop	{r7, pc}
 801c9c6:	46c0      	nop			; (mov r8, r8)
 801c9c8:	0801fcf0 	.word	0x0801fcf0
 801c9cc:	0801fcd4 	.word	0x0801fcd4
 801c9d0:	200002a0 	.word	0x200002a0

0801c9d4 <LORA_TxNeeded>:

static void LORA_TxNeeded(void)
{
 801c9d4:	b580      	push	{r7, lr}
 801c9d6:	af00      	add	r7, sp, #0
    AppData.BuffSize = 0;
 801c9d8:	4b06      	ldr	r3, [pc, #24]	; (801c9f4 <LORA_TxNeeded+0x20>)
 801c9da:	2200      	movs	r2, #0
 801c9dc:	711a      	strb	r2, [r3, #4]
    AppData.Port = LORAWAN_APP_PORT;
 801c9de:	4b05      	ldr	r3, [pc, #20]	; (801c9f4 <LORA_TxNeeded+0x20>)
 801c9e0:	2202      	movs	r2, #2
 801c9e2:	715a      	strb	r2, [r3, #5]

    LORA_send(&AppData, LORAWAN_UNCONFIRMED_MSG);
 801c9e4:	4b03      	ldr	r3, [pc, #12]	; (801c9f4 <LORA_TxNeeded+0x20>)
 801c9e6:	2100      	movs	r1, #0
 801c9e8:	0018      	movs	r0, r3
 801c9ea:	f7fd fd1b 	bl	801a424 <LORA_send>
}
 801c9ee:	46c0      	nop			; (mov r8, r8)
 801c9f0:	46bd      	mov	sp, r7
 801c9f2:	bd80      	pop	{r7, pc}
 801c9f4:	200002a0 	.word	0x200002a0

0801c9f8 <LORA_GetBatteryLevel>:
 * @brief This function return the battery level
 * @param none
 * @retval the battery level  1 (very low) to 254 (fully charged)
 */
uint8_t LORA_GetBatteryLevel(void)
{
 801c9f8:	b590      	push	{r4, r7, lr}
 801c9fa:	b083      	sub	sp, #12
 801c9fc:	af00      	add	r7, sp, #0
    uint16_t batteryLevelmV;
    uint8_t batteryLevel = 0;
 801c9fe:	1dfb      	adds	r3, r7, #7
 801ca00:	2200      	movs	r2, #0
 801ca02:	701a      	strb	r2, [r3, #0]

    batteryLevelmV = HW_GetBatteryLevel();
 801ca04:	1d3c      	adds	r4, r7, #4
 801ca06:	f000 fadf 	bl	801cfc8 <HW_GetBatteryLevel>
 801ca0a:	0003      	movs	r3, r0
 801ca0c:	8023      	strh	r3, [r4, #0]

    /* Convert batterey level from mV to linea scale: 1 (very low) to 254 (fully charged) */
    if (batteryLevelmV > VDD_BAT)
 801ca0e:	1d3b      	adds	r3, r7, #4
 801ca10:	881b      	ldrh	r3, [r3, #0]
 801ca12:	4a15      	ldr	r2, [pc, #84]	; (801ca68 <LORA_GetBatteryLevel+0x70>)
 801ca14:	4293      	cmp	r3, r2
 801ca16:	d903      	bls.n	801ca20 <LORA_GetBatteryLevel+0x28>
    {
        batteryLevel = LORAWAN_MAX_BAT;
 801ca18:	1dfb      	adds	r3, r7, #7
 801ca1a:	22fe      	movs	r2, #254	; 0xfe
 801ca1c:	701a      	strb	r2, [r3, #0]
 801ca1e:	e01d      	b.n	801ca5c <LORA_GetBatteryLevel+0x64>
    } else if (batteryLevelmV < VDD_MIN)
 801ca20:	1d3b      	adds	r3, r7, #4
 801ca22:	881a      	ldrh	r2, [r3, #0]
 801ca24:	23e1      	movs	r3, #225	; 0xe1
 801ca26:	00db      	lsls	r3, r3, #3
 801ca28:	429a      	cmp	r2, r3
 801ca2a:	d203      	bcs.n	801ca34 <LORA_GetBatteryLevel+0x3c>
    {
        batteryLevel = 0;
 801ca2c:	1dfb      	adds	r3, r7, #7
 801ca2e:	2200      	movs	r2, #0
 801ca30:	701a      	strb	r2, [r3, #0]
 801ca32:	e013      	b.n	801ca5c <LORA_GetBatteryLevel+0x64>
    } else
    {
        batteryLevel =
                (((uint32_t) (batteryLevelmV - VDD_MIN) * LORAWAN_MAX_BAT) / (VDD_BAT
 801ca34:	1d3b      	adds	r3, r7, #4
 801ca36:	881b      	ldrh	r3, [r3, #0]
 801ca38:	4a0c      	ldr	r2, [pc, #48]	; (801ca6c <LORA_GetBatteryLevel+0x74>)
 801ca3a:	4694      	mov	ip, r2
 801ca3c:	4463      	add	r3, ip
 801ca3e:	001a      	movs	r2, r3
 801ca40:	0013      	movs	r3, r2
 801ca42:	01db      	lsls	r3, r3, #7
 801ca44:	1a9b      	subs	r3, r3, r2
 801ca46:	005b      	lsls	r3, r3, #1
 801ca48:	001a      	movs	r2, r3
 801ca4a:	2396      	movs	r3, #150	; 0x96
 801ca4c:	00d9      	lsls	r1, r3, #3
 801ca4e:	0010      	movs	r0, r2
 801ca50:	f7e3 fb64 	bl	800011c <__udivsi3>
 801ca54:	0003      	movs	r3, r0
 801ca56:	001a      	movs	r2, r3
        batteryLevel =
 801ca58:	1dfb      	adds	r3, r7, #7
 801ca5a:	701a      	strb	r2, [r3, #0]
                        - VDD_MIN));
    }

    return batteryLevel;
 801ca5c:	1dfb      	adds	r3, r7, #7
 801ca5e:	781b      	ldrb	r3, [r3, #0]
}
 801ca60:	0018      	movs	r0, r3
 801ca62:	46bd      	mov	sp, r7
 801ca64:	b003      	add	sp, #12
 801ca66:	bd90      	pop	{r4, r7, pc}
 801ca68:	00000bb8 	.word	0x00000bb8
 801ca6c:	fffff8f8 	.word	0xfffff8f8

0801ca70 <OnTimerLedEvent>:

#ifdef USE_B_L072Z_LRWAN1
static void OnTimerLedEvent(void* context)
{
 801ca70:	b580      	push	{r7, lr}
 801ca72:	b082      	sub	sp, #8
 801ca74:	af00      	add	r7, sp, #0
 801ca76:	6078      	str	r0, [r7, #4]
    LED_Off(LED_RED1);
 801ca78:	2001      	movs	r0, #1
 801ca7a:	f7e6 fc69 	bl	8003350 <BSP_LED_Off>
}
 801ca7e:	46c0      	nop			; (mov r8, r8)
 801ca80:	46bd      	mov	sp, r7
 801ca82:	b002      	add	sp, #8
 801ca84:	bd80      	pop	{r7, pc}

0801ca86 <HAL_InitTick>:
  * @brief  don't enable systick
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 801ca86:	b580      	push	{r7, lr}
 801ca88:	b082      	sub	sp, #8
 801ca8a:	af00      	add	r7, sp, #0
 801ca8c:	6078      	str	r0, [r7, #4]
  /* Return function status */
  return HAL_OK;
 801ca8e:	2300      	movs	r3, #0
}
 801ca90:	0018      	movs	r0, r3
 801ca92:	46bd      	mov	sp, r7
 801ca94:	b002      	add	sp, #8
 801ca96:	bd80      	pop	{r7, pc}

0801ca98 <HAL_Delay>:
  * @brief This function provides delay (in ms)
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
void HAL_Delay(__IO uint32_t Delay)
{
 801ca98:	b580      	push	{r7, lr}
 801ca9a:	b082      	sub	sp, #8
 801ca9c:	af00      	add	r7, sp, #0
 801ca9e:	6078      	str	r0, [r7, #4]
  HW_RTC_DelayMs(Delay);   /* based on RTC */
 801caa0:	687b      	ldr	r3, [r7, #4]
 801caa2:	0018      	movs	r0, r3
 801caa4:	f7ff f91a 	bl	801bcdc <HW_RTC_DelayMs>
}
 801caa8:	46c0      	nop			; (mov r8, r8)
 801caaa:	46bd      	mov	sp, r7
 801caac:	b002      	add	sp, #8
 801caae:	bd80      	pop	{r7, pc}

0801cab0 <HAL_MspInit>:
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
void HAL_MspInit(void)
{
 801cab0:	b580      	push	{r7, lr}
 801cab2:	af00      	add	r7, sp, #0
  __HAL_RCC_PWR_CLK_ENABLE();
 801cab4:	4b0e      	ldr	r3, [pc, #56]	; (801caf0 <HAL_MspInit+0x40>)
 801cab6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 801cab8:	4b0d      	ldr	r3, [pc, #52]	; (801caf0 <HAL_MspInit+0x40>)
 801caba:	2180      	movs	r1, #128	; 0x80
 801cabc:	0549      	lsls	r1, r1, #21
 801cabe:	430a      	orrs	r2, r1
 801cac0:	639a      	str	r2, [r3, #56]	; 0x38

  /* Disable the Power Voltage Detector */
  HAL_PWR_DisablePVD();
 801cac2:	f7ee f969 	bl	800ad98 <HAL_PWR_DisablePVD>

  /* Enables the Ultra Low Power mode */
  HAL_PWREx_EnableUltraLowPower();
 801cac6:	f7ee f983 	bl	800add0 <HAL_PWREx_EnableUltraLowPower>

  __HAL_FLASH_SLEEP_POWERDOWN_ENABLE();
 801caca:	4b0a      	ldr	r3, [pc, #40]	; (801caf4 <HAL_MspInit+0x44>)
 801cacc:	681a      	ldr	r2, [r3, #0]
 801cace:	4b09      	ldr	r3, [pc, #36]	; (801caf4 <HAL_MspInit+0x44>)
 801cad0:	2108      	movs	r1, #8
 801cad2:	430a      	orrs	r2, r1
 801cad4:	601a      	str	r2, [r3, #0]

  /*In debug mode, e.g. when DBGMCU is activated, Arm core has always clocks
   * And will not wait that the FLACH is ready to be read. It can miss in this
   * case the first instruction. To overcome this issue, the flash remain clcoked during sleep mode
   */
  DBG(__HAL_FLASH_SLEEP_POWERDOWN_DISABLE(););
 801cad6:	4b07      	ldr	r3, [pc, #28]	; (801caf4 <HAL_MspInit+0x44>)
 801cad8:	681a      	ldr	r2, [r3, #0]
 801cada:	4b06      	ldr	r3, [pc, #24]	; (801caf4 <HAL_MspInit+0x44>)
 801cadc:	2108      	movs	r1, #8
 801cade:	438a      	bics	r2, r1
 801cae0:	601a      	str	r2, [r3, #0]

#ifdef ENABLE_FAST_WAKEUP
  /*Enable fast wakeUp*/
  HAL_PWREx_EnableFastWakeUp();
 801cae2:	f7ee f967 	bl	800adb4 <HAL_PWREx_EnableFastWakeUp>
#else
  HAL_PWREx_DisableFastWakeUp();
#endif

  HW_GpioInit();
 801cae6:	f000 f8b5 	bl	801cc54 <HW_GpioInit>
}
 801caea:	46c0      	nop			; (mov r8, r8)
 801caec:	46bd      	mov	sp, r7
 801caee:	bd80      	pop	{r7, pc}
 801caf0:	40021000 	.word	0x40021000
 801caf4:	40022000 	.word	0x40022000

0801caf8 <HAL_RTC_MspInit>:
  *        order to modify the RTC Clock source, as consequence RTC registers (including
  *        the backup registers) and RCC_CSR register are set to their reset values.
  * @retval None
  */
void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
{
 801caf8:	b590      	push	{r4, r7, lr}
 801cafa:	b09b      	sub	sp, #108	; 0x6c
 801cafc:	af00      	add	r7, sp, #0
 801cafe:	6078      	str	r0, [r7, #4]
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 801cb00:	2430      	movs	r4, #48	; 0x30
 801cb02:	193b      	adds	r3, r7, r4
 801cb04:	0018      	movs	r0, r3
 801cb06:	2338      	movs	r3, #56	; 0x38
 801cb08:	001a      	movs	r2, r3
 801cb0a:	2100      	movs	r1, #0
 801cb0c:	f000 fd22 	bl	801d554 <memset>
  RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct = {0};
 801cb10:	230c      	movs	r3, #12
 801cb12:	18fb      	adds	r3, r7, r3
 801cb14:	0018      	movs	r0, r3
 801cb16:	2324      	movs	r3, #36	; 0x24
 801cb18:	001a      	movs	r2, r3
 801cb1a:	2100      	movs	r1, #0
 801cb1c:	f000 fd1a 	bl	801d554 <memset>

  /*##-1- Configue the RTC clock soucre ######################################*/
  /* -a- Enable LSE Oscillator */
  RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSE;
 801cb20:	193b      	adds	r3, r7, r4
 801cb22:	2204      	movs	r2, #4
 801cb24:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 801cb26:	193b      	adds	r3, r7, r4
 801cb28:	2200      	movs	r2, #0
 801cb2a:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 801cb2c:	193b      	adds	r3, r7, r4
 801cb2e:	2280      	movs	r2, #128	; 0x80
 801cb30:	0052      	lsls	r2, r2, #1
 801cb32:	609a      	str	r2, [r3, #8]
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 801cb34:	193b      	adds	r3, r7, r4
 801cb36:	0018      	movs	r0, r3
 801cb38:	f7ee f958 	bl	800adec <HAL_RCC_OscConfig>
 801cb3c:	1e03      	subs	r3, r0, #0
 801cb3e:	d001      	beq.n	801cb44 <HAL_RTC_MspInit+0x4c>
  {
    Error_Handler();
 801cb40:	f7fe fe26 	bl	801b790 <Error_Handler>
  }

  /* -b- Select LSI as RTC clock source */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 801cb44:	210c      	movs	r1, #12
 801cb46:	187b      	adds	r3, r7, r1
 801cb48:	2220      	movs	r2, #32
 801cb4a:	601a      	str	r2, [r3, #0]
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 801cb4c:	187b      	adds	r3, r7, r1
 801cb4e:	2280      	movs	r2, #128	; 0x80
 801cb50:	0252      	lsls	r2, r2, #9
 801cb52:	605a      	str	r2, [r3, #4]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801cb54:	187b      	adds	r3, r7, r1
 801cb56:	0018      	movs	r0, r3
 801cb58:	f7ee fefe 	bl	800b958 <HAL_RCCEx_PeriphCLKConfig>
 801cb5c:	1e03      	subs	r3, r0, #0
 801cb5e:	d001      	beq.n	801cb64 <HAL_RTC_MspInit+0x6c>
  {
    Error_Handler();
 801cb60:	f7fe fe16 	bl	801b790 <Error_Handler>
  }

  /*##-2- Enable the RTC peripheral Clock ####################################*/
  /* Enable RTC Clock */
  __HAL_RCC_RTC_ENABLE();
 801cb64:	4b09      	ldr	r3, [pc, #36]	; (801cb8c <HAL_RTC_MspInit+0x94>)
 801cb66:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801cb68:	4b08      	ldr	r3, [pc, #32]	; (801cb8c <HAL_RTC_MspInit+0x94>)
 801cb6a:	2180      	movs	r1, #128	; 0x80
 801cb6c:	02c9      	lsls	r1, r1, #11
 801cb6e:	430a      	orrs	r2, r1
 801cb70:	651a      	str	r2, [r3, #80]	; 0x50

  /*##-3- Configure the NVIC for RTC Alarm ###################################*/
  HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0x0, 0);
 801cb72:	2200      	movs	r2, #0
 801cb74:	2100      	movs	r1, #0
 801cb76:	2002      	movs	r0, #2
 801cb78:	f7ec ffac 	bl	8009ad4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 801cb7c:	2002      	movs	r0, #2
 801cb7e:	f7ec ffbe 	bl	8009afe <HAL_NVIC_EnableIRQ>
}
 801cb82:	46c0      	nop			; (mov r8, r8)
 801cb84:	46bd      	mov	sp, r7
 801cb86:	b01b      	add	sp, #108	; 0x6c
 801cb88:	bd90      	pop	{r4, r7, pc}
 801cb8a:	46c0      	nop			; (mov r8, r8)
 801cb8c:	40021000 	.word	0x40021000

0801cb90 <HAL_RTC_AlarmAEventCallback>:
  * @brief  Alarm A callback.
  * @param  hrtc: RTC handle
  * @retval None
  */
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
{
 801cb90:	b580      	push	{r7, lr}
 801cb92:	b082      	sub	sp, #8
 801cb94:	af00      	add	r7, sp, #0
 801cb96:	6078      	str	r0, [r7, #4]
  TimerIrqHandler();
 801cb98:	f7fe f9cc 	bl	801af34 <TimerIrqHandler>
}
 801cb9c:	46c0      	nop			; (mov r8, r8)
 801cb9e:	46bd      	mov	sp, r7
 801cba0:	b002      	add	sp, #8
 801cba2:	bd80      	pop	{r7, pc}

0801cba4 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callbacks.
  * @param  GPIO_Pin: Specifies the pins connected to the EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 801cba4:	b580      	push	{r7, lr}
 801cba6:	b082      	sub	sp, #8
 801cba8:	af00      	add	r7, sp, #0
 801cbaa:	0002      	movs	r2, r0
 801cbac:	1dbb      	adds	r3, r7, #6
 801cbae:	801a      	strh	r2, [r3, #0]
  HW_GPIO_IrqHandler(GPIO_Pin);
 801cbb0:	1dbb      	adds	r3, r7, #6
 801cbb2:	881b      	ldrh	r3, [r3, #0]
 801cbb4:	0018      	movs	r0, r3
 801cbb6:	f7fe fea7 	bl	801b908 <HW_GPIO_IrqHandler>
}
 801cbba:	46c0      	nop			; (mov r8, r8)
 801cbbc:	46bd      	mov	sp, r7
 801cbbe:	b002      	add	sp, #8
 801cbc0:	bd80      	pop	{r7, pc}

0801cbc2 <MSP_GetIRQn>:
  * @brief  Gets IRQ number as a function of the GPIO_Pin.
  * @param  GPIO_Pin: Specifies the pins connected to the EXTI line.
  * @retval IRQ number
  */
IRQn_Type MSP_GetIRQn(uint16_t GPIO_Pin)
{
 801cbc2:	b580      	push	{r7, lr}
 801cbc4:	b082      	sub	sp, #8
 801cbc6:	af00      	add	r7, sp, #0
 801cbc8:	0002      	movs	r2, r0
 801cbca:	1dbb      	adds	r3, r7, #6
 801cbcc:	801a      	strh	r2, [r3, #0]
  switch (GPIO_Pin)
 801cbce:	1dbb      	adds	r3, r7, #6
 801cbd0:	881b      	ldrh	r3, [r3, #0]
 801cbd2:	2b08      	cmp	r3, #8
 801cbd4:	d00a      	beq.n	801cbec <MSP_GetIRQn+0x2a>
 801cbd6:	dc0b      	bgt.n	801cbf0 <MSP_GetIRQn+0x2e>
 801cbd8:	2b02      	cmp	r3, #2
 801cbda:	dc02      	bgt.n	801cbe2 <MSP_GetIRQn+0x20>
 801cbdc:	2b00      	cmp	r3, #0
 801cbde:	dc03      	bgt.n	801cbe8 <MSP_GetIRQn+0x26>
 801cbe0:	e006      	b.n	801cbf0 <MSP_GetIRQn+0x2e>
 801cbe2:	2b04      	cmp	r3, #4
 801cbe4:	d002      	beq.n	801cbec <MSP_GetIRQn+0x2a>
 801cbe6:	e003      	b.n	801cbf0 <MSP_GetIRQn+0x2e>
  {
    case GPIO_PIN_0:
    case GPIO_PIN_1:
      return EXTI0_1_IRQn;
 801cbe8:	2305      	movs	r3, #5
 801cbea:	e002      	b.n	801cbf2 <MSP_GetIRQn+0x30>
    case GPIO_PIN_2:
    case GPIO_PIN_3:
      return EXTI2_3_IRQn;
 801cbec:	2306      	movs	r3, #6
 801cbee:	e000      	b.n	801cbf2 <MSP_GetIRQn+0x30>
    case GPIO_PIN_12:
    case GPIO_PIN_13:
    case GPIO_PIN_14:
    case GPIO_PIN_15:
    default:
      return EXTI4_15_IRQn;
 801cbf0:	2307      	movs	r3, #7
  }
}
 801cbf2:	0018      	movs	r0, r3
 801cbf4:	46bd      	mov	sp, r7
 801cbf6:	b002      	add	sp, #8
 801cbf8:	bd80      	pop	{r7, pc}
	...

0801cbfc <HW_Init>:
  * @brief This function initializes the hardware
  * @param None
  * @retval None
  */
void HW_Init(void)
{
 801cbfc:	b580      	push	{r7, lr}
 801cbfe:	af00      	add	r7, sp, #0
  if (McuInitialized == false)
 801cc00:	4b12      	ldr	r3, [pc, #72]	; (801cc4c <HW_Init+0x50>)
 801cc02:	781b      	ldrb	r3, [r3, #0]
 801cc04:	2201      	movs	r2, #1
 801cc06:	4053      	eors	r3, r2
 801cc08:	b2db      	uxtb	r3, r3
 801cc0a:	2b00      	cmp	r3, #0
 801cc0c:	d01b      	beq.n	801cc46 <HW_Init+0x4a>
#if defined( USE_BOOTLOADER )
    /* Set the Vector Table base location at 0x3000 */
    NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x3000);
#endif

    HW_AdcInit();
 801cc0e:	f000 fa09 	bl	801d024 <HW_AdcInit>

    Radio.IoInit();
 801cc12:	4b0f      	ldr	r3, [pc, #60]	; (801cc50 <HW_Init+0x54>)
 801cc14:	681b      	ldr	r3, [r3, #0]
 801cc16:	4798      	blx	r3

    HW_SPI_Init();
 801cc18:	f7ff fb22 	bl	801c260 <HW_SPI_Init>

    HW_RTC_Init();
 801cc1c:	f7fe fefe 	bl	801ba1c <HW_RTC_Init>

    TraceInit();
 801cc20:	f7fe fb6a 	bl	801b2f8 <TraceInit>

    BSP_sensor_Init();
 801cc24:	f7fe fd2e 	bl	801b684 <BSP_sensor_Init>

    BSP_LED_Init(LED1);
 801cc28:	2000      	movs	r0, #0
 801cc2a:	f7e6 fb07 	bl	800323c <BSP_LED_Init>
    BSP_LED_Init(LED2);
 801cc2e:	2001      	movs	r0, #1
 801cc30:	f7e6 fb04 	bl	800323c <BSP_LED_Init>
    BSP_LED_Init(LED3);
 801cc34:	2002      	movs	r0, #2
 801cc36:	f7e6 fb01 	bl	800323c <BSP_LED_Init>
    BSP_LED_Init(LED4);
 801cc3a:	2003      	movs	r0, #3
 801cc3c:	f7e6 fafe 	bl	800323c <BSP_LED_Init>

    McuInitialized = true;
 801cc40:	4b02      	ldr	r3, [pc, #8]	; (801cc4c <HW_Init+0x50>)
 801cc42:	2201      	movs	r2, #1
 801cc44:	701a      	strb	r2, [r3, #0]
  }
}
 801cc46:	46c0      	nop			; (mov r8, r8)
 801cc48:	46bd      	mov	sp, r7
 801cc4a:	bd80      	pop	{r7, pc}
 801cc4c:	20001645 	.word	0x20001645
 801cc50:	0801ebd0 	.word	0x0801ebd0

0801cc54 <HW_GpioInit>:
  vcom_IoDeInit();
}


void HW_GpioInit(void)
{
 801cc54:	b590      	push	{r4, r7, lr}
 801cc56:	b08b      	sub	sp, #44	; 0x2c
 801cc58:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801cc5a:	2414      	movs	r4, #20
 801cc5c:	193b      	adds	r3, r7, r4
 801cc5e:	0018      	movs	r0, r3
 801cc60:	2314      	movs	r3, #20
 801cc62:	001a      	movs	r2, r3
 801cc64:	2100      	movs	r1, #0
 801cc66:	f000 fc75 	bl	801d554 <memset>

  /* Configure all GPIO as analog to reduce current consumption on non used IOs */
  /* Enable GPIOs clock */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 801cc6a:	4b38      	ldr	r3, [pc, #224]	; (801cd4c <HW_GpioInit+0xf8>)
 801cc6c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801cc6e:	4b37      	ldr	r3, [pc, #220]	; (801cd4c <HW_GpioInit+0xf8>)
 801cc70:	2101      	movs	r1, #1
 801cc72:	430a      	orrs	r2, r1
 801cc74:	62da      	str	r2, [r3, #44]	; 0x2c
 801cc76:	4b35      	ldr	r3, [pc, #212]	; (801cd4c <HW_GpioInit+0xf8>)
 801cc78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801cc7a:	2201      	movs	r2, #1
 801cc7c:	4013      	ands	r3, r2
 801cc7e:	613b      	str	r3, [r7, #16]
 801cc80:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 801cc82:	4b32      	ldr	r3, [pc, #200]	; (801cd4c <HW_GpioInit+0xf8>)
 801cc84:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801cc86:	4b31      	ldr	r3, [pc, #196]	; (801cd4c <HW_GpioInit+0xf8>)
 801cc88:	2102      	movs	r1, #2
 801cc8a:	430a      	orrs	r2, r1
 801cc8c:	62da      	str	r2, [r3, #44]	; 0x2c
 801cc8e:	4b2f      	ldr	r3, [pc, #188]	; (801cd4c <HW_GpioInit+0xf8>)
 801cc90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801cc92:	2202      	movs	r2, #2
 801cc94:	4013      	ands	r3, r2
 801cc96:	60fb      	str	r3, [r7, #12]
 801cc98:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 801cc9a:	4b2c      	ldr	r3, [pc, #176]	; (801cd4c <HW_GpioInit+0xf8>)
 801cc9c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801cc9e:	4b2b      	ldr	r3, [pc, #172]	; (801cd4c <HW_GpioInit+0xf8>)
 801cca0:	2104      	movs	r1, #4
 801cca2:	430a      	orrs	r2, r1
 801cca4:	62da      	str	r2, [r3, #44]	; 0x2c
 801cca6:	4b29      	ldr	r3, [pc, #164]	; (801cd4c <HW_GpioInit+0xf8>)
 801cca8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ccaa:	2204      	movs	r2, #4
 801ccac:	4013      	ands	r3, r2
 801ccae:	60bb      	str	r3, [r7, #8]
 801ccb0:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 801ccb2:	4b26      	ldr	r3, [pc, #152]	; (801cd4c <HW_GpioInit+0xf8>)
 801ccb4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801ccb6:	4b25      	ldr	r3, [pc, #148]	; (801cd4c <HW_GpioInit+0xf8>)
 801ccb8:	2180      	movs	r1, #128	; 0x80
 801ccba:	430a      	orrs	r2, r1
 801ccbc:	62da      	str	r2, [r3, #44]	; 0x2c
 801ccbe:	4b23      	ldr	r3, [pc, #140]	; (801cd4c <HW_GpioInit+0xf8>)
 801ccc0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ccc2:	2280      	movs	r2, #128	; 0x80
 801ccc4:	4013      	ands	r3, r2
 801ccc6:	607b      	str	r3, [r7, #4]
 801ccc8:	687b      	ldr	r3, [r7, #4]

  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 801ccca:	193b      	adds	r3, r7, r4
 801cccc:	2203      	movs	r2, #3
 801ccce:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801ccd0:	193b      	adds	r3, r7, r4
 801ccd2:	2200      	movs	r2, #0
 801ccd4:	609a      	str	r2, [r3, #8]
  /* All GPIOs except debug pins (SWCLK and SWD) */
  GPIO_InitStruct.Pin = GPIO_PIN_All & (~(GPIO_PIN_13 | GPIO_PIN_14));
 801ccd6:	193b      	adds	r3, r7, r4
 801ccd8:	4a1d      	ldr	r2, [pc, #116]	; (801cd50 <HW_GpioInit+0xfc>)
 801ccda:	601a      	str	r2, [r3, #0]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801ccdc:	193a      	adds	r2, r7, r4
 801ccde:	23a0      	movs	r3, #160	; 0xa0
 801cce0:	05db      	lsls	r3, r3, #23
 801cce2:	0011      	movs	r1, r2
 801cce4:	0018      	movs	r0, r3
 801cce6:	f7ed f91d 	bl	8009f24 <HAL_GPIO_Init>

  /* All GPIOs */
  GPIO_InitStruct.Pin = GPIO_PIN_All;
 801ccea:	193b      	adds	r3, r7, r4
 801ccec:	4a19      	ldr	r2, [pc, #100]	; (801cd54 <HW_GpioInit+0x100>)
 801ccee:	601a      	str	r2, [r3, #0]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801ccf0:	193b      	adds	r3, r7, r4
 801ccf2:	4a19      	ldr	r2, [pc, #100]	; (801cd58 <HW_GpioInit+0x104>)
 801ccf4:	0019      	movs	r1, r3
 801ccf6:	0010      	movs	r0, r2
 801ccf8:	f7ed f914 	bl	8009f24 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801ccfc:	193b      	adds	r3, r7, r4
 801ccfe:	4a17      	ldr	r2, [pc, #92]	; (801cd5c <HW_GpioInit+0x108>)
 801cd00:	0019      	movs	r1, r3
 801cd02:	0010      	movs	r0, r2
 801cd04:	f7ed f90e 	bl	8009f24 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 801cd08:	193b      	adds	r3, r7, r4
 801cd0a:	4a15      	ldr	r2, [pc, #84]	; (801cd60 <HW_GpioInit+0x10c>)
 801cd0c:	0019      	movs	r1, r3
 801cd0e:	0010      	movs	r0, r2
 801cd10:	f7ed f908 	bl	8009f24 <HAL_GPIO_Init>

  /* Disable GPIOs clock */
  __HAL_RCC_GPIOA_CLK_DISABLE();
 801cd14:	4b0d      	ldr	r3, [pc, #52]	; (801cd4c <HW_GpioInit+0xf8>)
 801cd16:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801cd18:	4b0c      	ldr	r3, [pc, #48]	; (801cd4c <HW_GpioInit+0xf8>)
 801cd1a:	2101      	movs	r1, #1
 801cd1c:	438a      	bics	r2, r1
 801cd1e:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_RCC_GPIOB_CLK_DISABLE();
 801cd20:	4b0a      	ldr	r3, [pc, #40]	; (801cd4c <HW_GpioInit+0xf8>)
 801cd22:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801cd24:	4b09      	ldr	r3, [pc, #36]	; (801cd4c <HW_GpioInit+0xf8>)
 801cd26:	2102      	movs	r1, #2
 801cd28:	438a      	bics	r2, r1
 801cd2a:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_RCC_GPIOC_CLK_DISABLE();
 801cd2c:	4b07      	ldr	r3, [pc, #28]	; (801cd4c <HW_GpioInit+0xf8>)
 801cd2e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801cd30:	4b06      	ldr	r3, [pc, #24]	; (801cd4c <HW_GpioInit+0xf8>)
 801cd32:	2104      	movs	r1, #4
 801cd34:	438a      	bics	r2, r1
 801cd36:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_RCC_GPIOH_CLK_DISABLE();
 801cd38:	4b04      	ldr	r3, [pc, #16]	; (801cd4c <HW_GpioInit+0xf8>)
 801cd3a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801cd3c:	4b03      	ldr	r3, [pc, #12]	; (801cd4c <HW_GpioInit+0xf8>)
 801cd3e:	2180      	movs	r1, #128	; 0x80
 801cd40:	438a      	bics	r2, r1
 801cd42:	62da      	str	r2, [r3, #44]	; 0x2c
}
 801cd44:	46c0      	nop			; (mov r8, r8)
 801cd46:	46bd      	mov	sp, r7
 801cd48:	b00b      	add	sp, #44	; 0x2c
 801cd4a:	bd90      	pop	{r4, r7, pc}
 801cd4c:	40021000 	.word	0x40021000
 801cd50:	00009fff 	.word	0x00009fff
 801cd54:	0000ffff 	.word	0x0000ffff
 801cd58:	50000400 	.word	0x50000400
 801cd5c:	50000800 	.word	0x50000800
 801cd60:	50001c00 	.word	0x50001c00

0801cd64 <SystemClock_Config>:
  *            Flash Latency(WS)              = 1
  * @retval None
  */

void SystemClock_Config(void)
{
 801cd64:	b580      	push	{r7, lr}
 801cd66:	b094      	sub	sp, #80	; 0x50
 801cd68:	af00      	add	r7, sp, #0
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 801cd6a:	233c      	movs	r3, #60	; 0x3c
 801cd6c:	18fb      	adds	r3, r7, r3
 801cd6e:	0018      	movs	r0, r3
 801cd70:	2314      	movs	r3, #20
 801cd72:	001a      	movs	r2, r3
 801cd74:	2100      	movs	r1, #0
 801cd76:	f000 fbed 	bl	801d554 <memset>
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 801cd7a:	1d3b      	adds	r3, r7, #4
 801cd7c:	0018      	movs	r0, r3
 801cd7e:	2338      	movs	r3, #56	; 0x38
 801cd80:	001a      	movs	r2, r3
 801cd82:	2100      	movs	r1, #0
 801cd84:	f000 fbe6 	bl	801d554 <memset>

  /* Enable HSE Oscillator and Activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
 801cd88:	1d3b      	adds	r3, r7, #4
 801cd8a:	2202      	movs	r2, #2
 801cd8c:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.HSEState            = RCC_HSE_OFF;
 801cd8e:	1d3b      	adds	r3, r7, #4
 801cd90:	2200      	movs	r2, #0
 801cd92:	605a      	str	r2, [r3, #4]
  RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
 801cd94:	1d3b      	adds	r3, r7, #4
 801cd96:	2201      	movs	r2, #1
 801cd98:	60da      	str	r2, [r3, #12]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 801cd9a:	1d3b      	adds	r3, r7, #4
 801cd9c:	2210      	movs	r2, #16
 801cd9e:	611a      	str	r2, [r3, #16]
  RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
 801cda0:	1d3b      	adds	r3, r7, #4
 801cda2:	2202      	movs	r2, #2
 801cda4:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
 801cda6:	1d3b      	adds	r3, r7, #4
 801cda8:	2200      	movs	r2, #0
 801cdaa:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLMUL          = RCC_PLLMUL_6;
 801cdac:	1d3b      	adds	r3, r7, #4
 801cdae:	2280      	movs	r2, #128	; 0x80
 801cdb0:	0312      	lsls	r2, r2, #12
 801cdb2:	631a      	str	r2, [r3, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLDIV          = RCC_PLLDIV_3;
 801cdb4:	1d3b      	adds	r3, r7, #4
 801cdb6:	2280      	movs	r2, #128	; 0x80
 801cdb8:	0412      	lsls	r2, r2, #16
 801cdba:	635a      	str	r2, [r3, #52]	; 0x34

  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 801cdbc:	1d3b      	adds	r3, r7, #4
 801cdbe:	0018      	movs	r0, r3
 801cdc0:	f7ee f814 	bl	800adec <HAL_RCC_OscConfig>
 801cdc4:	1e03      	subs	r3, r0, #0
 801cdc6:	d001      	beq.n	801cdcc <SystemClock_Config+0x68>
  {
    Error_Handler();
 801cdc8:	f7fe fce2 	bl	801b790 <Error_Handler>
  }

  /* Set Voltage scale1 as MCU will run at 32MHz */
  __HAL_RCC_PWR_CLK_ENABLE();
 801cdcc:	4b19      	ldr	r3, [pc, #100]	; (801ce34 <SystemClock_Config+0xd0>)
 801cdce:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 801cdd0:	4b18      	ldr	r3, [pc, #96]	; (801ce34 <SystemClock_Config+0xd0>)
 801cdd2:	2180      	movs	r1, #128	; 0x80
 801cdd4:	0549      	lsls	r1, r1, #21
 801cdd6:	430a      	orrs	r2, r1
 801cdd8:	639a      	str	r2, [r3, #56]	; 0x38
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 801cdda:	4b17      	ldr	r3, [pc, #92]	; (801ce38 <SystemClock_Config+0xd4>)
 801cddc:	681b      	ldr	r3, [r3, #0]
 801cdde:	4a17      	ldr	r2, [pc, #92]	; (801ce3c <SystemClock_Config+0xd8>)
 801cde0:	401a      	ands	r2, r3
 801cde2:	4b15      	ldr	r3, [pc, #84]	; (801ce38 <SystemClock_Config+0xd4>)
 801cde4:	2180      	movs	r1, #128	; 0x80
 801cde6:	0109      	lsls	r1, r1, #4
 801cde8:	430a      	orrs	r2, r1
 801cdea:	601a      	str	r2, [r3, #0]

  /* Poll VOSF bit of in PWR_CSR. Wait until it is reset to 0 */
  while (__HAL_PWR_GET_FLAG(PWR_FLAG_VOS) != RESET) {};
 801cdec:	46c0      	nop			; (mov r8, r8)
 801cdee:	4b12      	ldr	r3, [pc, #72]	; (801ce38 <SystemClock_Config+0xd4>)
 801cdf0:	685b      	ldr	r3, [r3, #4]
 801cdf2:	2210      	movs	r2, #16
 801cdf4:	4013      	ands	r3, r2
 801cdf6:	2b10      	cmp	r3, #16
 801cdf8:	d0f9      	beq.n	801cdee <SystemClock_Config+0x8a>

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
  clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 801cdfa:	213c      	movs	r1, #60	; 0x3c
 801cdfc:	187b      	adds	r3, r7, r1
 801cdfe:	220f      	movs	r2, #15
 801ce00:	601a      	str	r2, [r3, #0]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 801ce02:	187b      	adds	r3, r7, r1
 801ce04:	2203      	movs	r2, #3
 801ce06:	605a      	str	r2, [r3, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 801ce08:	187b      	adds	r3, r7, r1
 801ce0a:	2200      	movs	r2, #0
 801ce0c:	609a      	str	r2, [r3, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 801ce0e:	187b      	adds	r3, r7, r1
 801ce10:	2200      	movs	r2, #0
 801ce12:	60da      	str	r2, [r3, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 801ce14:	187b      	adds	r3, r7, r1
 801ce16:	2200      	movs	r2, #0
 801ce18:	611a      	str	r2, [r3, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 801ce1a:	187b      	adds	r3, r7, r1
 801ce1c:	2101      	movs	r1, #1
 801ce1e:	0018      	movs	r0, r3
 801ce20:	f7ee fbb4 	bl	800b58c <HAL_RCC_ClockConfig>
 801ce24:	1e03      	subs	r3, r0, #0
 801ce26:	d001      	beq.n	801ce2c <SystemClock_Config+0xc8>
  {
    Error_Handler();
 801ce28:	f7fe fcb2 	bl	801b790 <Error_Handler>
  }
}
 801ce2c:	46c0      	nop			; (mov r8, r8)
 801ce2e:	46bd      	mov	sp, r7
 801ce30:	b014      	add	sp, #80	; 0x50
 801ce32:	bd80      	pop	{r7, pc}
 801ce34:	40021000 	.word	0x40021000
 801ce38:	40007000 	.word	0x40007000
 801ce3c:	ffffe7ff 	.word	0xffffe7ff

0801ce40 <HW_GetRandomSeed>:
  * @note based on the device unique ID
  * @param None
  * @retval see
  */
uint32_t HW_GetRandomSeed(void)
{
 801ce40:	b580      	push	{r7, lr}
 801ce42:	af00      	add	r7, sp, #0
  return ((*(uint32_t *)ID1) ^ (*(uint32_t *)ID2) ^ (*(uint32_t *)ID3));
 801ce44:	4b05      	ldr	r3, [pc, #20]	; (801ce5c <HW_GetRandomSeed+0x1c>)
 801ce46:	681a      	ldr	r2, [r3, #0]
 801ce48:	4b05      	ldr	r3, [pc, #20]	; (801ce60 <HW_GetRandomSeed+0x20>)
 801ce4a:	681b      	ldr	r3, [r3, #0]
 801ce4c:	405a      	eors	r2, r3
 801ce4e:	4b05      	ldr	r3, [pc, #20]	; (801ce64 <HW_GetRandomSeed+0x24>)
 801ce50:	681b      	ldr	r3, [r3, #0]
 801ce52:	4053      	eors	r3, r2
}
 801ce54:	0018      	movs	r0, r3
 801ce56:	46bd      	mov	sp, r7
 801ce58:	bd80      	pop	{r7, pc}
 801ce5a:	46c0      	nop			; (mov r8, r8)
 801ce5c:	1ff80050 	.word	0x1ff80050
 801ce60:	1ff80054 	.word	0x1ff80054
 801ce64:	1ff80064 	.word	0x1ff80064

0801ce68 <HW_GetUniqueId>:
  * @brief This function return a unique ID
  * @param unique ID
  * @retval none
  */
void HW_GetUniqueId(uint8_t *id)
{
 801ce68:	b580      	push	{r7, lr}
 801ce6a:	b082      	sub	sp, #8
 801ce6c:	af00      	add	r7, sp, #0
 801ce6e:	6078      	str	r0, [r7, #4]
  id[7] = ((*(uint32_t *)ID1) + (*(uint32_t *)ID3)) >> 24;
 801ce70:	4b23      	ldr	r3, [pc, #140]	; (801cf00 <HW_GetUniqueId+0x98>)
 801ce72:	681a      	ldr	r2, [r3, #0]
 801ce74:	4b23      	ldr	r3, [pc, #140]	; (801cf04 <HW_GetUniqueId+0x9c>)
 801ce76:	681b      	ldr	r3, [r3, #0]
 801ce78:	18d3      	adds	r3, r2, r3
 801ce7a:	0e1a      	lsrs	r2, r3, #24
 801ce7c:	687b      	ldr	r3, [r7, #4]
 801ce7e:	3307      	adds	r3, #7
 801ce80:	b2d2      	uxtb	r2, r2
 801ce82:	701a      	strb	r2, [r3, #0]
  id[6] = ((*(uint32_t *)ID1) + (*(uint32_t *)ID3)) >> 16;
 801ce84:	4b1e      	ldr	r3, [pc, #120]	; (801cf00 <HW_GetUniqueId+0x98>)
 801ce86:	681a      	ldr	r2, [r3, #0]
 801ce88:	4b1e      	ldr	r3, [pc, #120]	; (801cf04 <HW_GetUniqueId+0x9c>)
 801ce8a:	681b      	ldr	r3, [r3, #0]
 801ce8c:	18d3      	adds	r3, r2, r3
 801ce8e:	0c1a      	lsrs	r2, r3, #16
 801ce90:	687b      	ldr	r3, [r7, #4]
 801ce92:	3306      	adds	r3, #6
 801ce94:	b2d2      	uxtb	r2, r2
 801ce96:	701a      	strb	r2, [r3, #0]
  id[5] = ((*(uint32_t *)ID1) + (*(uint32_t *)ID3)) >> 8;
 801ce98:	4b19      	ldr	r3, [pc, #100]	; (801cf00 <HW_GetUniqueId+0x98>)
 801ce9a:	681a      	ldr	r2, [r3, #0]
 801ce9c:	4b19      	ldr	r3, [pc, #100]	; (801cf04 <HW_GetUniqueId+0x9c>)
 801ce9e:	681b      	ldr	r3, [r3, #0]
 801cea0:	18d3      	adds	r3, r2, r3
 801cea2:	0a1a      	lsrs	r2, r3, #8
 801cea4:	687b      	ldr	r3, [r7, #4]
 801cea6:	3305      	adds	r3, #5
 801cea8:	b2d2      	uxtb	r2, r2
 801ceaa:	701a      	strb	r2, [r3, #0]
  id[4] = ((*(uint32_t *)ID1) + (*(uint32_t *)ID3));
 801ceac:	4b14      	ldr	r3, [pc, #80]	; (801cf00 <HW_GetUniqueId+0x98>)
 801ceae:	681b      	ldr	r3, [r3, #0]
 801ceb0:	b2d9      	uxtb	r1, r3
 801ceb2:	4b14      	ldr	r3, [pc, #80]	; (801cf04 <HW_GetUniqueId+0x9c>)
 801ceb4:	681b      	ldr	r3, [r3, #0]
 801ceb6:	b2da      	uxtb	r2, r3
 801ceb8:	687b      	ldr	r3, [r7, #4]
 801ceba:	3304      	adds	r3, #4
 801cebc:	188a      	adds	r2, r1, r2
 801cebe:	b2d2      	uxtb	r2, r2
 801cec0:	701a      	strb	r2, [r3, #0]
  id[3] = ((*(uint32_t *)ID2)) >> 24;
 801cec2:	4b11      	ldr	r3, [pc, #68]	; (801cf08 <HW_GetUniqueId+0xa0>)
 801cec4:	681b      	ldr	r3, [r3, #0]
 801cec6:	0e1a      	lsrs	r2, r3, #24
 801cec8:	687b      	ldr	r3, [r7, #4]
 801ceca:	3303      	adds	r3, #3
 801cecc:	b2d2      	uxtb	r2, r2
 801cece:	701a      	strb	r2, [r3, #0]
  id[2] = ((*(uint32_t *)ID2)) >> 16;
 801ced0:	4b0d      	ldr	r3, [pc, #52]	; (801cf08 <HW_GetUniqueId+0xa0>)
 801ced2:	681b      	ldr	r3, [r3, #0]
 801ced4:	0c1a      	lsrs	r2, r3, #16
 801ced6:	687b      	ldr	r3, [r7, #4]
 801ced8:	3302      	adds	r3, #2
 801ceda:	b2d2      	uxtb	r2, r2
 801cedc:	701a      	strb	r2, [r3, #0]
  id[1] = ((*(uint32_t *)ID2)) >> 8;
 801cede:	4b0a      	ldr	r3, [pc, #40]	; (801cf08 <HW_GetUniqueId+0xa0>)
 801cee0:	681b      	ldr	r3, [r3, #0]
 801cee2:	0a1a      	lsrs	r2, r3, #8
 801cee4:	687b      	ldr	r3, [r7, #4]
 801cee6:	3301      	adds	r3, #1
 801cee8:	b2d2      	uxtb	r2, r2
 801ceea:	701a      	strb	r2, [r3, #0]
  id[0] = ((*(uint32_t *)ID2));
 801ceec:	4b06      	ldr	r3, [pc, #24]	; (801cf08 <HW_GetUniqueId+0xa0>)
 801ceee:	681b      	ldr	r3, [r3, #0]
 801cef0:	b2da      	uxtb	r2, r3
 801cef2:	687b      	ldr	r3, [r7, #4]
 801cef4:	701a      	strb	r2, [r3, #0]
}
 801cef6:	46c0      	nop			; (mov r8, r8)
 801cef8:	46bd      	mov	sp, r7
 801cefa:	b002      	add	sp, #8
 801cefc:	bd80      	pop	{r7, pc}
 801cefe:	46c0      	nop			; (mov r8, r8)
 801cf00:	1ff80050 	.word	0x1ff80050
 801cf04:	1ff80064 	.word	0x1ff80064
 801cf08:	1ff80054 	.word	0x1ff80054

0801cf0c <HW_GetTemperatureLevel>:

uint16_t HW_GetTemperatureLevel(void)
{
 801cf0c:	b590      	push	{r4, r7, lr}
 801cf0e:	b083      	sub	sp, #12
 801cf10:	af00      	add	r7, sp, #0
  uint16_t measuredLevel = 0;
 801cf12:	1cbb      	adds	r3, r7, #2
 801cf14:	2200      	movs	r2, #0
 801cf16:	801a      	strh	r2, [r3, #0]
  uint32_t batteryLevelmV;
  uint16_t temperatureDegreeC;

  measuredLevel = HW_AdcReadChannel(ADC_CHANNEL_VREFINT);
 801cf18:	1cbc      	adds	r4, r7, #2
 801cf1a:	4b25      	ldr	r3, [pc, #148]	; (801cfb0 <HW_GetTemperatureLevel+0xa4>)
 801cf1c:	0018      	movs	r0, r3
 801cf1e:	f000 f8d5 	bl	801d0cc <HW_AdcReadChannel>
 801cf22:	0003      	movs	r3, r0
 801cf24:	8023      	strh	r3, [r4, #0]

  if (measuredLevel == 0)
 801cf26:	1cbb      	adds	r3, r7, #2
 801cf28:	881b      	ldrh	r3, [r3, #0]
 801cf2a:	2b00      	cmp	r3, #0
 801cf2c:	d102      	bne.n	801cf34 <HW_GetTemperatureLevel+0x28>
  {
    batteryLevelmV = 0;
 801cf2e:	2300      	movs	r3, #0
 801cf30:	607b      	str	r3, [r7, #4]
 801cf32:	e00c      	b.n	801cf4e <HW_GetTemperatureLevel+0x42>
  }
  else
  {
    batteryLevelmV = (((uint32_t) VDDA_VREFINT_CAL * (*VREFINT_CAL)) / measuredLevel);
 801cf34:	4b1f      	ldr	r3, [pc, #124]	; (801cfb4 <HW_GetTemperatureLevel+0xa8>)
 801cf36:	881b      	ldrh	r3, [r3, #0]
 801cf38:	001a      	movs	r2, r3
 801cf3a:	4b1f      	ldr	r3, [pc, #124]	; (801cfb8 <HW_GetTemperatureLevel+0xac>)
 801cf3c:	435a      	muls	r2, r3
 801cf3e:	1cbb      	adds	r3, r7, #2
 801cf40:	881b      	ldrh	r3, [r3, #0]
 801cf42:	0019      	movs	r1, r3
 801cf44:	0010      	movs	r0, r2
 801cf46:	f7e3 f8e9 	bl	800011c <__udivsi3>
 801cf4a:	0003      	movs	r3, r0
 801cf4c:	607b      	str	r3, [r7, #4]
  }
#if 0
  PRINTF("VDDA= %d\n\r", batteryLevelmV);
#endif

  measuredLevel = HW_AdcReadChannel(ADC_CHANNEL_TEMPSENSOR);
 801cf4e:	1cbc      	adds	r4, r7, #2
 801cf50:	4b1a      	ldr	r3, [pc, #104]	; (801cfbc <HW_GetTemperatureLevel+0xb0>)
 801cf52:	0018      	movs	r0, r3
 801cf54:	f000 f8ba 	bl	801d0cc <HW_AdcReadChannel>
 801cf58:	0003      	movs	r3, r0
 801cf5a:	8023      	strh	r3, [r4, #0]

  temperatureDegreeC = COMPUTE_TEMPERATURE(measuredLevel, batteryLevelmV);
 801cf5c:	1cbb      	adds	r3, r7, #2
 801cf5e:	881b      	ldrh	r3, [r3, #0]
 801cf60:	687a      	ldr	r2, [r7, #4]
 801cf62:	4353      	muls	r3, r2
 801cf64:	4914      	ldr	r1, [pc, #80]	; (801cfb8 <HW_GetTemperatureLevel+0xac>)
 801cf66:	0018      	movs	r0, r3
 801cf68:	f7e3 f8d8 	bl	800011c <__udivsi3>
 801cf6c:	0003      	movs	r3, r0
 801cf6e:	001a      	movs	r2, r3
 801cf70:	4b13      	ldr	r3, [pc, #76]	; (801cfc0 <HW_GetTemperatureLevel+0xb4>)
 801cf72:	881b      	ldrh	r3, [r3, #0]
 801cf74:	1ad2      	subs	r2, r2, r3
 801cf76:	0013      	movs	r3, r2
 801cf78:	009b      	lsls	r3, r3, #2
 801cf7a:	189b      	adds	r3, r3, r2
 801cf7c:	011b      	lsls	r3, r3, #4
 801cf7e:	021b      	lsls	r3, r3, #8
 801cf80:	4a10      	ldr	r2, [pc, #64]	; (801cfc4 <HW_GetTemperatureLevel+0xb8>)
 801cf82:	8812      	ldrh	r2, [r2, #0]
 801cf84:	0011      	movs	r1, r2
 801cf86:	4a0e      	ldr	r2, [pc, #56]	; (801cfc0 <HW_GetTemperatureLevel+0xb4>)
 801cf88:	8812      	ldrh	r2, [r2, #0]
 801cf8a:	1a8a      	subs	r2, r1, r2
 801cf8c:	0011      	movs	r1, r2
 801cf8e:	0018      	movs	r0, r3
 801cf90:	f7e3 f94e 	bl	8000230 <__divsi3>
 801cf94:	0003      	movs	r3, r0
 801cf96:	b29a      	uxth	r2, r3
 801cf98:	003b      	movs	r3, r7
 801cf9a:	21f0      	movs	r1, #240	; 0xf0
 801cf9c:	0149      	lsls	r1, r1, #5
 801cf9e:	468c      	mov	ip, r1
 801cfa0:	4462      	add	r2, ip
 801cfa2:	801a      	strh	r2, [r3, #0]
    uint16_t temperatureDegreeC_Frac = ((temperatureDegreeC - (temperatureDegreeC_Int << 8)) * 100) >> 8;
    PRINTF("temp= %d, %d,%d\n\r", temperatureDegreeC, temperatureDegreeC_Int, temperatureDegreeC_Frac);
  }
#endif

  return (uint16_t) temperatureDegreeC;
 801cfa4:	003b      	movs	r3, r7
 801cfa6:	881b      	ldrh	r3, [r3, #0]
}
 801cfa8:	0018      	movs	r0, r3
 801cfaa:	46bd      	mov	sp, r7
 801cfac:	b003      	add	sp, #12
 801cfae:	bd90      	pop	{r4, r7, pc}
 801cfb0:	44020000 	.word	0x44020000
 801cfb4:	1ff80078 	.word	0x1ff80078
 801cfb8:	00000bb8 	.word	0x00000bb8
 801cfbc:	48040000 	.word	0x48040000
 801cfc0:	1ff8007a 	.word	0x1ff8007a
 801cfc4:	1ff8007e 	.word	0x1ff8007e

0801cfc8 <HW_GetBatteryLevel>:
  * @brief This function return the battery level
  * @param none
  * @retval the battery level in mV
  */
uint16_t HW_GetBatteryLevel(void)
{
 801cfc8:	b590      	push	{r4, r7, lr}
 801cfca:	b083      	sub	sp, #12
 801cfcc:	af00      	add	r7, sp, #0
  uint16_t measuredLevel = 0;
 801cfce:	1cbb      	adds	r3, r7, #2
 801cfd0:	2200      	movs	r2, #0
 801cfd2:	801a      	strh	r2, [r3, #0]
  uint32_t batteryLevelmV;

  measuredLevel = HW_AdcReadChannel(ADC_CHANNEL_VREFINT);
 801cfd4:	1cbc      	adds	r4, r7, #2
 801cfd6:	4b10      	ldr	r3, [pc, #64]	; (801d018 <HW_GetBatteryLevel+0x50>)
 801cfd8:	0018      	movs	r0, r3
 801cfda:	f000 f877 	bl	801d0cc <HW_AdcReadChannel>
 801cfde:	0003      	movs	r3, r0
 801cfe0:	8023      	strh	r3, [r4, #0]

  if (measuredLevel == 0)
 801cfe2:	1cbb      	adds	r3, r7, #2
 801cfe4:	881b      	ldrh	r3, [r3, #0]
 801cfe6:	2b00      	cmp	r3, #0
 801cfe8:	d102      	bne.n	801cff0 <HW_GetBatteryLevel+0x28>
  {
    batteryLevelmV = 0;
 801cfea:	2300      	movs	r3, #0
 801cfec:	607b      	str	r3, [r7, #4]
 801cfee:	e00c      	b.n	801d00a <HW_GetBatteryLevel+0x42>
  }
  else
  {
    batteryLevelmV = (((uint32_t) VDDA_VREFINT_CAL * (*VREFINT_CAL)) / measuredLevel);
 801cff0:	4b0a      	ldr	r3, [pc, #40]	; (801d01c <HW_GetBatteryLevel+0x54>)
 801cff2:	881b      	ldrh	r3, [r3, #0]
 801cff4:	001a      	movs	r2, r3
 801cff6:	4b0a      	ldr	r3, [pc, #40]	; (801d020 <HW_GetBatteryLevel+0x58>)
 801cff8:	435a      	muls	r2, r3
 801cffa:	1cbb      	adds	r3, r7, #2
 801cffc:	881b      	ldrh	r3, [r3, #0]
 801cffe:	0019      	movs	r1, r3
 801d000:	0010      	movs	r0, r2
 801d002:	f7e3 f88b 	bl	800011c <__udivsi3>
 801d006:	0003      	movs	r3, r0
 801d008:	607b      	str	r3, [r7, #4]
  }

  return batteryLevelmV;
 801d00a:	687b      	ldr	r3, [r7, #4]
 801d00c:	b29b      	uxth	r3, r3
}
 801d00e:	0018      	movs	r0, r3
 801d010:	46bd      	mov	sp, r7
 801d012:	b003      	add	sp, #12
 801d014:	bd90      	pop	{r4, r7, pc}
 801d016:	46c0      	nop			; (mov r8, r8)
 801d018:	44020000 	.word	0x44020000
 801d01c:	1ff80078 	.word	0x1ff80078
 801d020:	00000bb8 	.word	0x00000bb8

0801d024 <HW_AdcInit>:
  * @brief This function initializes the ADC
  * @param none
  * @retval none
  */
void HW_AdcInit(void)
{
 801d024:	b580      	push	{r7, lr}
 801d026:	af00      	add	r7, sp, #0
  if (AdcInitialized == false)
 801d028:	4b24      	ldr	r3, [pc, #144]	; (801d0bc <HW_AdcInit+0x98>)
 801d02a:	781b      	ldrb	r3, [r3, #0]
 801d02c:	2201      	movs	r2, #1
 801d02e:	4053      	eors	r3, r2
 801d030:	b2db      	uxtb	r3, r3
 801d032:	2b00      	cmp	r3, #0
 801d034:	d03e      	beq.n	801d0b4 <HW_AdcInit+0x90>
  {
    AdcInitialized = true;
 801d036:	4b21      	ldr	r3, [pc, #132]	; (801d0bc <HW_AdcInit+0x98>)
 801d038:	2201      	movs	r2, #1
 801d03a:	701a      	strb	r2, [r3, #0]


    hadc.Instance  = ADC1;
 801d03c:	4b20      	ldr	r3, [pc, #128]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d03e:	4a21      	ldr	r2, [pc, #132]	; (801d0c4 <HW_AdcInit+0xa0>)
 801d040:	601a      	str	r2, [r3, #0]

    hadc.Init.OversamplingMode      = DISABLE;
 801d042:	4b1f      	ldr	r3, [pc, #124]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d044:	2200      	movs	r2, #0
 801d046:	63da      	str	r2, [r3, #60]	; 0x3c

    hadc.Init.ClockPrescaler        = ADC_CLOCK_SYNC_PCLK_DIV4;
 801d048:	4b1d      	ldr	r3, [pc, #116]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d04a:	2280      	movs	r2, #128	; 0x80
 801d04c:	0612      	lsls	r2, r2, #24
 801d04e:	605a      	str	r2, [r3, #4]
    hadc.Init.LowPowerAutoPowerOff  = DISABLE;
 801d050:	4b1b      	ldr	r3, [pc, #108]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d052:	2200      	movs	r2, #0
 801d054:	61da      	str	r2, [r3, #28]
    hadc.Init.LowPowerFrequencyMode = ENABLE;
 801d056:	4b1a      	ldr	r3, [pc, #104]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d058:	2201      	movs	r2, #1
 801d05a:	635a      	str	r2, [r3, #52]	; 0x34
    hadc.Init.LowPowerAutoWait      = DISABLE;
 801d05c:	4b18      	ldr	r3, [pc, #96]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d05e:	2200      	movs	r2, #0
 801d060:	619a      	str	r2, [r3, #24]

    hadc.Init.Resolution            = ADC_RESOLUTION_12B;
 801d062:	4b17      	ldr	r3, [pc, #92]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d064:	2200      	movs	r2, #0
 801d066:	609a      	str	r2, [r3, #8]
    hadc.Init.SamplingTime          = ADC_SAMPLETIME_160CYCLES_5;
 801d068:	4b15      	ldr	r3, [pc, #84]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d06a:	2207      	movs	r2, #7
 801d06c:	639a      	str	r2, [r3, #56]	; 0x38
    hadc.Init.ScanConvMode          = ADC_SCAN_DIRECTION_FORWARD;
 801d06e:	4b14      	ldr	r3, [pc, #80]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d070:	2201      	movs	r2, #1
 801d072:	611a      	str	r2, [r3, #16]
    hadc.Init.DataAlign             = ADC_DATAALIGN_RIGHT;
 801d074:	4b12      	ldr	r3, [pc, #72]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d076:	2200      	movs	r2, #0
 801d078:	60da      	str	r2, [r3, #12]
    hadc.Init.ContinuousConvMode    = DISABLE;
 801d07a:	4b11      	ldr	r3, [pc, #68]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d07c:	2220      	movs	r2, #32
 801d07e:	2100      	movs	r1, #0
 801d080:	5499      	strb	r1, [r3, r2]
    hadc.Init.DiscontinuousConvMode = DISABLE;
 801d082:	4b0f      	ldr	r3, [pc, #60]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d084:	2221      	movs	r2, #33	; 0x21
 801d086:	2100      	movs	r1, #0
 801d088:	5499      	strb	r1, [r3, r2]
    hadc.Init.ExternalTrigConvEdge  = ADC_EXTERNALTRIGCONVEDGE_NONE;
 801d08a:	4b0d      	ldr	r3, [pc, #52]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d08c:	2200      	movs	r2, #0
 801d08e:	629a      	str	r2, [r3, #40]	; 0x28
    hadc.Init.EOCSelection          = ADC_EOC_SINGLE_CONV;
 801d090:	4b0b      	ldr	r3, [pc, #44]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d092:	2204      	movs	r2, #4
 801d094:	615a      	str	r2, [r3, #20]
    hadc.Init.DMAContinuousRequests = DISABLE;
 801d096:	4b0a      	ldr	r3, [pc, #40]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d098:	222c      	movs	r2, #44	; 0x2c
 801d09a:	2100      	movs	r1, #0
 801d09c:	5499      	strb	r1, [r3, r2]

    ADCCLK_ENABLE();
 801d09e:	4b0a      	ldr	r3, [pc, #40]	; (801d0c8 <HW_AdcInit+0xa4>)
 801d0a0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801d0a2:	4b09      	ldr	r3, [pc, #36]	; (801d0c8 <HW_AdcInit+0xa4>)
 801d0a4:	2180      	movs	r1, #128	; 0x80
 801d0a6:	0089      	lsls	r1, r1, #2
 801d0a8:	430a      	orrs	r2, r1
 801d0aa:	635a      	str	r2, [r3, #52]	; 0x34


    HAL_ADC_Init(&hadc);
 801d0ac:	4b04      	ldr	r3, [pc, #16]	; (801d0c0 <HW_AdcInit+0x9c>)
 801d0ae:	0018      	movs	r0, r3
 801d0b0:	f7ec f87a 	bl	80091a8 <HAL_ADC_Init>

  }
}
 801d0b4:	46c0      	nop			; (mov r8, r8)
 801d0b6:	46bd      	mov	sp, r7
 801d0b8:	bd80      	pop	{r7, pc}
 801d0ba:	46c0      	nop			; (mov r8, r8)
 801d0bc:	20001644 	.word	0x20001644
 801d0c0:	200015e8 	.word	0x200015e8
 801d0c4:	40012400 	.word	0x40012400
 801d0c8:	40021000 	.word	0x40021000

0801d0cc <HW_AdcReadChannel>:
  * @brief This function De-initializes the ADC
  * @param Channel
  * @retval Value
  */
uint16_t HW_AdcReadChannel(uint32_t Channel)
{
 801d0cc:	b590      	push	{r4, r7, lr}
 801d0ce:	b087      	sub	sp, #28
 801d0d0:	af00      	add	r7, sp, #0
 801d0d2:	6078      	str	r0, [r7, #4]

  ADC_ChannelConfTypeDef adcConf = {0};
 801d0d4:	230c      	movs	r3, #12
 801d0d6:	18fb      	adds	r3, r7, r3
 801d0d8:	0018      	movs	r0, r3
 801d0da:	2308      	movs	r3, #8
 801d0dc:	001a      	movs	r2, r3
 801d0de:	2100      	movs	r1, #0
 801d0e0:	f000 fa38 	bl	801d554 <memset>

  uint16_t adcData = 0;
 801d0e4:	2316      	movs	r3, #22
 801d0e6:	18fb      	adds	r3, r7, r3
 801d0e8:	2200      	movs	r2, #0
 801d0ea:	801a      	strh	r2, [r3, #0]

  HW_AdcInit();
 801d0ec:	f7ff ff9a 	bl	801d024 <HW_AdcInit>

  if (AdcInitialized == true)
 801d0f0:	4b2e      	ldr	r3, [pc, #184]	; (801d1ac <HW_AdcReadChannel+0xe0>)
 801d0f2:	781b      	ldrb	r3, [r3, #0]
 801d0f4:	2b00      	cmp	r3, #0
 801d0f6:	d052      	beq.n	801d19e <HW_AdcReadChannel+0xd2>
  {
    /* wait the the Vrefint used by adc is set */
    while (__HAL_PWR_GET_FLAG(PWR_FLAG_VREFINTRDY) == RESET) {};
 801d0f8:	46c0      	nop			; (mov r8, r8)
 801d0fa:	4b2d      	ldr	r3, [pc, #180]	; (801d1b0 <HW_AdcReadChannel+0xe4>)
 801d0fc:	685b      	ldr	r3, [r3, #4]
 801d0fe:	2208      	movs	r2, #8
 801d100:	4013      	ands	r3, r2
 801d102:	2b08      	cmp	r3, #8
 801d104:	d1f9      	bne.n	801d0fa <HW_AdcReadChannel+0x2e>

    ADCCLK_ENABLE();
 801d106:	4b2b      	ldr	r3, [pc, #172]	; (801d1b4 <HW_AdcReadChannel+0xe8>)
 801d108:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801d10a:	4b2a      	ldr	r3, [pc, #168]	; (801d1b4 <HW_AdcReadChannel+0xe8>)
 801d10c:	2180      	movs	r1, #128	; 0x80
 801d10e:	0089      	lsls	r1, r1, #2
 801d110:	430a      	orrs	r2, r1
 801d112:	635a      	str	r2, [r3, #52]	; 0x34

    /*calibrate ADC if any calibraiton hardware*/
    HAL_ADCEx_Calibration_Start(&hadc, ADC_SINGLE_ENDED);
 801d114:	4b28      	ldr	r3, [pc, #160]	; (801d1b8 <HW_AdcReadChannel+0xec>)
 801d116:	2100      	movs	r1, #0
 801d118:	0018      	movs	r0, r3
 801d11a:	f7ec fbbd 	bl	8009898 <HAL_ADCEx_Calibration_Start>

    /* Deselects all channels*/
    adcConf.Channel = ADC_CHANNEL_MASK;
 801d11e:	240c      	movs	r4, #12
 801d120:	193b      	adds	r3, r7, r4
 801d122:	4a26      	ldr	r2, [pc, #152]	; (801d1bc <HW_AdcReadChannel+0xf0>)
 801d124:	601a      	str	r2, [r3, #0]
    adcConf.Rank = ADC_RANK_NONE;
 801d126:	193b      	adds	r3, r7, r4
 801d128:	4a25      	ldr	r2, [pc, #148]	; (801d1c0 <HW_AdcReadChannel+0xf4>)
 801d12a:	605a      	str	r2, [r3, #4]
    HAL_ADC_ConfigChannel(&hadc, &adcConf);
 801d12c:	193a      	adds	r2, r7, r4
 801d12e:	4b22      	ldr	r3, [pc, #136]	; (801d1b8 <HW_AdcReadChannel+0xec>)
 801d130:	0011      	movs	r1, r2
 801d132:	0018      	movs	r0, r3
 801d134:	f7ec faaa 	bl	800968c <HAL_ADC_ConfigChannel>

    /* configure adc channel */
    adcConf.Channel = Channel;
 801d138:	0021      	movs	r1, r4
 801d13a:	187b      	adds	r3, r7, r1
 801d13c:	687a      	ldr	r2, [r7, #4]
 801d13e:	601a      	str	r2, [r3, #0]
    adcConf.Rank = ADC_RANK_CHANNEL_NUMBER;
 801d140:	187b      	adds	r3, r7, r1
 801d142:	2280      	movs	r2, #128	; 0x80
 801d144:	0152      	lsls	r2, r2, #5
 801d146:	605a      	str	r2, [r3, #4]
    HAL_ADC_ConfigChannel(&hadc, &adcConf);
 801d148:	187a      	adds	r2, r7, r1
 801d14a:	4b1b      	ldr	r3, [pc, #108]	; (801d1b8 <HW_AdcReadChannel+0xec>)
 801d14c:	0011      	movs	r1, r2
 801d14e:	0018      	movs	r0, r3
 801d150:	f7ec fa9c 	bl	800968c <HAL_ADC_ConfigChannel>

    /* Start the conversion process */
    HAL_ADC_Start(&hadc);
 801d154:	4b18      	ldr	r3, [pc, #96]	; (801d1b8 <HW_AdcReadChannel+0xec>)
 801d156:	0018      	movs	r0, r3
 801d158:	f7ec f9a2 	bl	80094a0 <HAL_ADC_Start>

    /* Wait for the end of conversion */
    HAL_ADC_PollForConversion(&hadc, HAL_MAX_DELAY);
 801d15c:	2301      	movs	r3, #1
 801d15e:	425a      	negs	r2, r3
 801d160:	4b15      	ldr	r3, [pc, #84]	; (801d1b8 <HW_AdcReadChannel+0xec>)
 801d162:	0011      	movs	r1, r2
 801d164:	0018      	movs	r0, r3
 801d166:	f7ec f9ef 	bl	8009548 <HAL_ADC_PollForConversion>

    /* Get the converted value of regular channel */
    adcData = HAL_ADC_GetValue(&hadc);
 801d16a:	4b13      	ldr	r3, [pc, #76]	; (801d1b8 <HW_AdcReadChannel+0xec>)
 801d16c:	0018      	movs	r0, r3
 801d16e:	f7ec fa81 	bl	8009674 <HAL_ADC_GetValue>
 801d172:	0002      	movs	r2, r0
 801d174:	2316      	movs	r3, #22
 801d176:	18fb      	adds	r3, r7, r3
 801d178:	801a      	strh	r2, [r3, #0]

    __HAL_ADC_DISABLE(&hadc) ;
 801d17a:	4b0f      	ldr	r3, [pc, #60]	; (801d1b8 <HW_AdcReadChannel+0xec>)
 801d17c:	681b      	ldr	r3, [r3, #0]
 801d17e:	689a      	ldr	r2, [r3, #8]
 801d180:	4b0d      	ldr	r3, [pc, #52]	; (801d1b8 <HW_AdcReadChannel+0xec>)
 801d182:	681b      	ldr	r3, [r3, #0]
 801d184:	2102      	movs	r1, #2
 801d186:	430a      	orrs	r2, r1
 801d188:	609a      	str	r2, [r3, #8]
 801d18a:	4b0b      	ldr	r3, [pc, #44]	; (801d1b8 <HW_AdcReadChannel+0xec>)
 801d18c:	681b      	ldr	r3, [r3, #0]
 801d18e:	2203      	movs	r2, #3
 801d190:	601a      	str	r2, [r3, #0]

    ADCCLK_DISABLE();
 801d192:	4b08      	ldr	r3, [pc, #32]	; (801d1b4 <HW_AdcReadChannel+0xe8>)
 801d194:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801d196:	4b07      	ldr	r3, [pc, #28]	; (801d1b4 <HW_AdcReadChannel+0xe8>)
 801d198:	490a      	ldr	r1, [pc, #40]	; (801d1c4 <HW_AdcReadChannel+0xf8>)
 801d19a:	400a      	ands	r2, r1
 801d19c:	635a      	str	r2, [r3, #52]	; 0x34
  }
  return adcData;
 801d19e:	2316      	movs	r3, #22
 801d1a0:	18fb      	adds	r3, r7, r3
 801d1a2:	881b      	ldrh	r3, [r3, #0]
}
 801d1a4:	0018      	movs	r0, r3
 801d1a6:	46bd      	mov	sp, r7
 801d1a8:	b007      	add	sp, #28
 801d1aa:	bd90      	pop	{r4, r7, pc}
 801d1ac:	20001644 	.word	0x20001644
 801d1b0:	40007000 	.word	0x40007000
 801d1b4:	40021000 	.word	0x40021000
 801d1b8:	200015e8 	.word	0x200015e8
 801d1bc:	0007ffff 	.word	0x0007ffff
 801d1c0:	00001001 	.word	0x00001001
 801d1c4:	fffffdff 	.word	0xfffffdff

0801d1c8 <NMI_Handler>:
  * @param  None
  * @retval None
  */

void NMI_Handler(void)
{
 801d1c8:	b580      	push	{r7, lr}
 801d1ca:	af00      	add	r7, sp, #0
}
 801d1cc:	46c0      	nop			; (mov r8, r8)
 801d1ce:	46bd      	mov	sp, r7
 801d1d0:	bd80      	pop	{r7, pc}

0801d1d2 <HardFault_Handler>:
  * @retval None
  */


void HardFault_Handler(void)
{
 801d1d2:	b580      	push	{r7, lr}
 801d1d4:	af00      	add	r7, sp, #0
  while (1)
  {
    __NOP();
 801d1d6:	46c0      	nop			; (mov r8, r8)
 801d1d8:	e7fd      	b.n	801d1d6 <HardFault_Handler+0x4>

0801d1da <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 801d1da:	b580      	push	{r7, lr}
 801d1dc:	af00      	add	r7, sp, #0
}
 801d1de:	46c0      	nop			; (mov r8, r8)
 801d1e0:	46bd      	mov	sp, r7
 801d1e2:	bd80      	pop	{r7, pc}

0801d1e4 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 801d1e4:	b580      	push	{r7, lr}
 801d1e6:	af00      	add	r7, sp, #0
}
 801d1e8:	46c0      	nop			; (mov r8, r8)
 801d1ea:	46bd      	mov	sp, r7
 801d1ec:	bd80      	pop	{r7, pc}

0801d1ee <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 801d1ee:	b580      	push	{r7, lr}
 801d1f0:	af00      	add	r7, sp, #0
  HAL_IncTick();
 801d1f2:	f7eb ff99 	bl	8009128 <HAL_IncTick>
}
 801d1f6:	46c0      	nop			; (mov r8, r8)
 801d1f8:	46bd      	mov	sp, r7
 801d1fa:	bd80      	pop	{r7, pc}

0801d1fc <USART1_IRQHandler>:
  */
/*void PPP_IRQHandler(void)
{
}*/
void USARTx_IRQHandler(void)
{
 801d1fc:	b580      	push	{r7, lr}
 801d1fe:	af00      	add	r7, sp, #0
  vcom_IRQHandler();
 801d200:	f000 f8be 	bl	801d380 <vcom_IRQHandler>
}
 801d204:	46c0      	nop			; (mov r8, r8)
 801d206:	46bd      	mov	sp, r7
 801d208:	bd80      	pop	{r7, pc}

0801d20a <DMA1_Channel4_5_6_7_IRQHandler>:

void USARTx_DMA_TX_IRQHandler(void)
{
 801d20a:	b580      	push	{r7, lr}
 801d20c:	af00      	add	r7, sp, #0
  vcom_DMA_TX_IRQHandler();
 801d20e:	f000 f8ab 	bl	801d368 <vcom_DMA_TX_IRQHandler>
}
 801d212:	46c0      	nop			; (mov r8, r8)
 801d214:	46bd      	mov	sp, r7
 801d216:	bd80      	pop	{r7, pc}

0801d218 <RTC_IRQHandler>:

void RTC_IRQHandler(void)
{
 801d218:	b580      	push	{r7, lr}
 801d21a:	af00      	add	r7, sp, #0
  HW_RTC_IrqHandler();
 801d21c:	f7fe fd2a 	bl	801bc74 <HW_RTC_IrqHandler>
}
 801d220:	46c0      	nop			; (mov r8, r8)
 801d222:	46bd      	mov	sp, r7
 801d224:	bd80      	pop	{r7, pc}

0801d226 <EXTI0_1_IRQHandler>:

void EXTI0_1_IRQHandler(void)
{
 801d226:	b580      	push	{r7, lr}
 801d228:	af00      	add	r7, sp, #0
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 801d22a:	2001      	movs	r0, #1
 801d22c:	f7ed f816 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
 801d230:	2002      	movs	r0, #2
 801d232:	f7ed f813 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>
}
 801d236:	46c0      	nop			; (mov r8, r8)
 801d238:	46bd      	mov	sp, r7
 801d23a:	bd80      	pop	{r7, pc}

0801d23c <EXTI2_3_IRQHandler>:

void EXTI2_3_IRQHandler(void)
{
 801d23c:	b580      	push	{r7, lr}
 801d23e:	af00      	add	r7, sp, #0
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);
 801d240:	2004      	movs	r0, #4
 801d242:	f7ed f80b 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);
 801d246:	2008      	movs	r0, #8
 801d248:	f7ed f808 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>
}
 801d24c:	46c0      	nop			; (mov r8, r8)
 801d24e:	46bd      	mov	sp, r7
 801d250:	bd80      	pop	{r7, pc}

0801d252 <EXTI4_15_IRQHandler>:


void EXTI4_15_IRQHandler(void)
{
 801d252:	b580      	push	{r7, lr}
 801d254:	af00      	add	r7, sp, #0
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);
 801d256:	2010      	movs	r0, #16
 801d258:	f7ed f800 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_5);
 801d25c:	2020      	movs	r0, #32
 801d25e:	f7ec fffd 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_6);
 801d262:	2040      	movs	r0, #64	; 0x40
 801d264:	f7ec fffa 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_7);
 801d268:	2080      	movs	r0, #128	; 0x80
 801d26a:	f7ec fff7 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_8);
 801d26e:	2380      	movs	r3, #128	; 0x80
 801d270:	005b      	lsls	r3, r3, #1
 801d272:	0018      	movs	r0, r3
 801d274:	f7ec fff2 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_9);
 801d278:	2380      	movs	r3, #128	; 0x80
 801d27a:	009b      	lsls	r3, r3, #2
 801d27c:	0018      	movs	r0, r3
 801d27e:	f7ec ffed 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_10);
 801d282:	2380      	movs	r3, #128	; 0x80
 801d284:	00db      	lsls	r3, r3, #3
 801d286:	0018      	movs	r0, r3
 801d288:	f7ec ffe8 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_11);
 801d28c:	2380      	movs	r3, #128	; 0x80
 801d28e:	011b      	lsls	r3, r3, #4
 801d290:	0018      	movs	r0, r3
 801d292:	f7ec ffe3 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_12);
 801d296:	2380      	movs	r3, #128	; 0x80
 801d298:	015b      	lsls	r3, r3, #5
 801d29a:	0018      	movs	r0, r3
 801d29c:	f7ec ffde 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
 801d2a0:	2380      	movs	r3, #128	; 0x80
 801d2a2:	019b      	lsls	r3, r3, #6
 801d2a4:	0018      	movs	r0, r3
 801d2a6:	f7ec ffd9 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_14);
 801d2aa:	2380      	movs	r3, #128	; 0x80
 801d2ac:	01db      	lsls	r3, r3, #7
 801d2ae:	0018      	movs	r0, r3
 801d2b0:	f7ec ffd4 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_15);
 801d2b4:	2380      	movs	r3, #128	; 0x80
 801d2b6:	021b      	lsls	r3, r3, #8
 801d2b8:	0018      	movs	r0, r3
 801d2ba:	f7ec ffcf 	bl	800a25c <HAL_GPIO_EXTI_IRQHandler>
}
 801d2be:	46c0      	nop			; (mov r8, r8)
 801d2c0:	46bd      	mov	sp, r7
 801d2c2:	bd80      	pop	{r7, pc}

0801d2c4 <vcom_Init>:

static void (*TxCpltCallback)(void);
/* Private function prototypes -----------------------------------------------*/
/* Functions Definition ------------------------------------------------------*/
void vcom_Init(void (*TxCb)(void))
{
 801d2c4:	b580      	push	{r7, lr}
 801d2c6:	b082      	sub	sp, #8
 801d2c8:	af00      	add	r7, sp, #0
 801d2ca:	6078      	str	r0, [r7, #4]

  /*Record Tx complete for DMA*/
  TxCpltCallback = TxCb;
 801d2cc:	4b12      	ldr	r3, [pc, #72]	; (801d318 <vcom_Init+0x54>)
 801d2ce:	687a      	ldr	r2, [r7, #4]
 801d2d0:	601a      	str	r2, [r3, #0]
      - Word Length = 8 Bits
      - Stop Bit = One Stop bit
      - Parity = ODD parity
      - BaudRate = 921600 baud
      - Hardware flow control disabled (RTS and CTS signals) */
  UartHandle.Instance        = USARTx;
 801d2d2:	4b12      	ldr	r3, [pc, #72]	; (801d31c <vcom_Init+0x58>)
 801d2d4:	4a12      	ldr	r2, [pc, #72]	; (801d320 <vcom_Init+0x5c>)
 801d2d6:	601a      	str	r2, [r3, #0]

  UartHandle.Init.BaudRate   = 115200;
 801d2d8:	4b10      	ldr	r3, [pc, #64]	; (801d31c <vcom_Init+0x58>)
 801d2da:	22e1      	movs	r2, #225	; 0xe1
 801d2dc:	0252      	lsls	r2, r2, #9
 801d2de:	605a      	str	r2, [r3, #4]
  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 801d2e0:	4b0e      	ldr	r3, [pc, #56]	; (801d31c <vcom_Init+0x58>)
 801d2e2:	2200      	movs	r2, #0
 801d2e4:	609a      	str	r2, [r3, #8]
  UartHandle.Init.StopBits   = UART_STOPBITS_1;
 801d2e6:	4b0d      	ldr	r3, [pc, #52]	; (801d31c <vcom_Init+0x58>)
 801d2e8:	2200      	movs	r2, #0
 801d2ea:	60da      	str	r2, [r3, #12]
  UartHandle.Init.Parity     = UART_PARITY_NONE;
 801d2ec:	4b0b      	ldr	r3, [pc, #44]	; (801d31c <vcom_Init+0x58>)
 801d2ee:	2200      	movs	r2, #0
 801d2f0:	611a      	str	r2, [r3, #16]
  UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 801d2f2:	4b0a      	ldr	r3, [pc, #40]	; (801d31c <vcom_Init+0x58>)
 801d2f4:	2200      	movs	r2, #0
 801d2f6:	619a      	str	r2, [r3, #24]
  UartHandle.Init.Mode       = UART_MODE_TX;
 801d2f8:	4b08      	ldr	r3, [pc, #32]	; (801d31c <vcom_Init+0x58>)
 801d2fa:	2208      	movs	r2, #8
 801d2fc:	615a      	str	r2, [r3, #20]

  if (HAL_UART_Init(&UartHandle) != HAL_OK)
 801d2fe:	4b07      	ldr	r3, [pc, #28]	; (801d31c <vcom_Init+0x58>)
 801d300:	0018      	movs	r0, r3
 801d302:	f7ef fcf5 	bl	800ccf0 <HAL_UART_Init>
 801d306:	1e03      	subs	r3, r0, #0
 801d308:	d001      	beq.n	801d30e <vcom_Init+0x4a>
  {
    /* Initialization Error */
    Error_Handler();
 801d30a:	f7fe fa41 	bl	801b790 <Error_Handler>
  }
}
 801d30e:	46c0      	nop			; (mov r8, r8)
 801d310:	46bd      	mov	sp, r7
 801d312:	b002      	add	sp, #8
 801d314:	bd80      	pop	{r7, pc}
 801d316:	46c0      	nop			; (mov r8, r8)
 801d318:	200016c8 	.word	0x200016c8
 801d31c:	20001648 	.word	0x20001648
 801d320:	40013800 	.word	0x40013800

0801d324 <vcom_Trace>:

void vcom_Trace(uint8_t *p_data, uint16_t size)
{
 801d324:	b580      	push	{r7, lr}
 801d326:	b082      	sub	sp, #8
 801d328:	af00      	add	r7, sp, #0
 801d32a:	6078      	str	r0, [r7, #4]
 801d32c:	000a      	movs	r2, r1
 801d32e:	1cbb      	adds	r3, r7, #2
 801d330:	801a      	strh	r2, [r3, #0]
  HAL_UART_Transmit_DMA(&UartHandle, p_data, size);
 801d332:	1cbb      	adds	r3, r7, #2
 801d334:	881a      	ldrh	r2, [r3, #0]
 801d336:	6879      	ldr	r1, [r7, #4]
 801d338:	4b03      	ldr	r3, [pc, #12]	; (801d348 <vcom_Trace+0x24>)
 801d33a:	0018      	movs	r0, r3
 801d33c:	f7ef fd2c 	bl	800cd98 <HAL_UART_Transmit_DMA>
}
 801d340:	46c0      	nop			; (mov r8, r8)
 801d342:	46bd      	mov	sp, r7
 801d344:	b002      	add	sp, #8
 801d346:	bd80      	pop	{r7, pc}
 801d348:	20001648 	.word	0x20001648

0801d34c <HAL_UART_TxCpltCallback>:

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *UartHandle)
{
 801d34c:	b580      	push	{r7, lr}
 801d34e:	b082      	sub	sp, #8
 801d350:	af00      	add	r7, sp, #0
 801d352:	6078      	str	r0, [r7, #4]
  /* buffer transmission complete*/
  TxCpltCallback();
 801d354:	4b03      	ldr	r3, [pc, #12]	; (801d364 <HAL_UART_TxCpltCallback+0x18>)
 801d356:	681b      	ldr	r3, [r3, #0]
 801d358:	4798      	blx	r3
}
 801d35a:	46c0      	nop			; (mov r8, r8)
 801d35c:	46bd      	mov	sp, r7
 801d35e:	b002      	add	sp, #8
 801d360:	bd80      	pop	{r7, pc}
 801d362:	46c0      	nop			; (mov r8, r8)
 801d364:	200016c8 	.word	0x200016c8

0801d368 <vcom_DMA_TX_IRQHandler>:

void vcom_DMA_TX_IRQHandler(void)
{
 801d368:	b580      	push	{r7, lr}
 801d36a:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(UartHandle.hdmatx);
 801d36c:	4b03      	ldr	r3, [pc, #12]	; (801d37c <vcom_DMA_TX_IRQHandler+0x14>)
 801d36e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801d370:	0018      	movs	r0, r3
 801d372:	f7ec fcfa 	bl	8009d6a <HAL_DMA_IRQHandler>
}
 801d376:	46c0      	nop			; (mov r8, r8)
 801d378:	46bd      	mov	sp, r7
 801d37a:	bd80      	pop	{r7, pc}
 801d37c:	20001648 	.word	0x20001648

0801d380 <vcom_IRQHandler>:

void vcom_IRQHandler(void)
{
 801d380:	b580      	push	{r7, lr}
 801d382:	af00      	add	r7, sp, #0
  HAL_UART_IRQHandler(&UartHandle);
 801d384:	4b03      	ldr	r3, [pc, #12]	; (801d394 <vcom_IRQHandler+0x14>)
 801d386:	0018      	movs	r0, r3
 801d388:	f7ef fd96 	bl	800ceb8 <HAL_UART_IRQHandler>
}
 801d38c:	46c0      	nop			; (mov r8, r8)
 801d38e:	46bd      	mov	sp, r7
 801d390:	bd80      	pop	{r7, pc}
 801d392:	46c0      	nop			; (mov r8, r8)
 801d394:	20001648 	.word	0x20001648

0801d398 <HAL_UART_MspInit>:
{
  HAL_UART_DeInit(&UartHandle);
}

void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 801d398:	b580      	push	{r7, lr}
 801d39a:	b086      	sub	sp, #24
 801d39c:	af00      	add	r7, sp, #0
 801d39e:	6078      	str	r0, [r7, #4]
  if (huart->Instance == USARTx)
 801d3a0:	687b      	ldr	r3, [r7, #4]
 801d3a2:	681b      	ldr	r3, [r3, #0]
 801d3a4:	4a34      	ldr	r2, [pc, #208]	; (801d478 <HAL_UART_MspInit+0xe0>)
 801d3a6:	4293      	cmp	r3, r2
 801d3a8:	d161      	bne.n	801d46e <HAL_UART_MspInit+0xd6>
    static DMA_HandleTypeDef hdma_tx;


    /*##-1- Enable peripherals and GPIO Clocks #################################*/
    /* Enable GPIO TX/RX clock */
    USARTx_TX_GPIO_CLK_ENABLE();
 801d3aa:	4b34      	ldr	r3, [pc, #208]	; (801d47c <HAL_UART_MspInit+0xe4>)
 801d3ac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801d3ae:	4b33      	ldr	r3, [pc, #204]	; (801d47c <HAL_UART_MspInit+0xe4>)
 801d3b0:	2101      	movs	r1, #1
 801d3b2:	430a      	orrs	r2, r1
 801d3b4:	62da      	str	r2, [r3, #44]	; 0x2c
 801d3b6:	4b31      	ldr	r3, [pc, #196]	; (801d47c <HAL_UART_MspInit+0xe4>)
 801d3b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801d3ba:	2201      	movs	r2, #1
 801d3bc:	4013      	ands	r3, r2
 801d3be:	617b      	str	r3, [r7, #20]
 801d3c0:	697b      	ldr	r3, [r7, #20]
    USARTx_RX_GPIO_CLK_ENABLE();
 801d3c2:	4b2e      	ldr	r3, [pc, #184]	; (801d47c <HAL_UART_MspInit+0xe4>)
 801d3c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801d3c6:	4b2d      	ldr	r3, [pc, #180]	; (801d47c <HAL_UART_MspInit+0xe4>)
 801d3c8:	2101      	movs	r1, #1
 801d3ca:	430a      	orrs	r2, r1
 801d3cc:	62da      	str	r2, [r3, #44]	; 0x2c
 801d3ce:	4b2b      	ldr	r3, [pc, #172]	; (801d47c <HAL_UART_MspInit+0xe4>)
 801d3d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801d3d2:	2201      	movs	r2, #1
 801d3d4:	4013      	ands	r3, r2
 801d3d6:	613b      	str	r3, [r7, #16]
 801d3d8:	693b      	ldr	r3, [r7, #16]

    /* Enable USARTx clock */
    USARTx_CLK_ENABLE();
 801d3da:	4b28      	ldr	r3, [pc, #160]	; (801d47c <HAL_UART_MspInit+0xe4>)
 801d3dc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 801d3de:	4b27      	ldr	r3, [pc, #156]	; (801d47c <HAL_UART_MspInit+0xe4>)
 801d3e0:	2180      	movs	r1, #128	; 0x80
 801d3e2:	01c9      	lsls	r1, r1, #7
 801d3e4:	430a      	orrs	r2, r1
 801d3e6:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable DMA clock */
    DMAx_CLK_ENABLE();
 801d3e8:	4b24      	ldr	r3, [pc, #144]	; (801d47c <HAL_UART_MspInit+0xe4>)
 801d3ea:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801d3ec:	4b23      	ldr	r3, [pc, #140]	; (801d47c <HAL_UART_MspInit+0xe4>)
 801d3ee:	2101      	movs	r1, #1
 801d3f0:	430a      	orrs	r2, r1
 801d3f2:	631a      	str	r2, [r3, #48]	; 0x30
 801d3f4:	4b21      	ldr	r3, [pc, #132]	; (801d47c <HAL_UART_MspInit+0xe4>)
 801d3f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801d3f8:	2201      	movs	r2, #1
 801d3fa:	4013      	ands	r3, r2
 801d3fc:	60fb      	str	r3, [r7, #12]
 801d3fe:	68fb      	ldr	r3, [r7, #12]

    /*##-2- Configure peripheral GPIO ##########################################*/
    /* UART  pin configuration  */
    vcom_IoInit();
 801d400:	f000 f842 	bl	801d488 <vcom_IoInit>

    /*##-3- Configure the DMA ##################################################*/
    /* Configure the DMA handler for Transmission process */
    hdma_tx.Instance                 = USARTx_TX_DMA_CHANNEL;
 801d404:	4b1e      	ldr	r3, [pc, #120]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d406:	4a1f      	ldr	r2, [pc, #124]	; (801d484 <HAL_UART_MspInit+0xec>)
 801d408:	601a      	str	r2, [r3, #0]
    hdma_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
 801d40a:	4b1d      	ldr	r3, [pc, #116]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d40c:	2210      	movs	r2, #16
 801d40e:	609a      	str	r2, [r3, #8]
    hdma_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
 801d410:	4b1b      	ldr	r3, [pc, #108]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d412:	2200      	movs	r2, #0
 801d414:	60da      	str	r2, [r3, #12]
    hdma_tx.Init.MemInc              = DMA_MINC_ENABLE;
 801d416:	4b1a      	ldr	r3, [pc, #104]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d418:	2280      	movs	r2, #128	; 0x80
 801d41a:	611a      	str	r2, [r3, #16]
    hdma_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 801d41c:	4b18      	ldr	r3, [pc, #96]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d41e:	2200      	movs	r2, #0
 801d420:	615a      	str	r2, [r3, #20]
    hdma_tx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
 801d422:	4b17      	ldr	r3, [pc, #92]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d424:	2200      	movs	r2, #0
 801d426:	619a      	str	r2, [r3, #24]
    hdma_tx.Init.Mode                = DMA_NORMAL;
 801d428:	4b15      	ldr	r3, [pc, #84]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d42a:	2200      	movs	r2, #0
 801d42c:	61da      	str	r2, [r3, #28]
    hdma_tx.Init.Priority            = DMA_PRIORITY_LOW;
 801d42e:	4b14      	ldr	r3, [pc, #80]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d430:	2200      	movs	r2, #0
 801d432:	621a      	str	r2, [r3, #32]
#ifndef STM32L152xE
    hdma_tx.Init.Request             = USARTx_TX_DMA_REQUEST;
 801d434:	4b12      	ldr	r3, [pc, #72]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d436:	2203      	movs	r2, #3
 801d438:	605a      	str	r2, [r3, #4]
#endif
    HAL_DMA_Init(&hdma_tx);
 801d43a:	4b11      	ldr	r3, [pc, #68]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d43c:	0018      	movs	r0, r3
 801d43e:	f7ec fb6f 	bl	8009b20 <HAL_DMA_Init>

    /* Associate the initialized DMA handle to the UART handle */
    __HAL_LINKDMA(huart, hdmatx, hdma_tx);
 801d442:	687b      	ldr	r3, [r7, #4]
 801d444:	4a0e      	ldr	r2, [pc, #56]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d446:	669a      	str	r2, [r3, #104]	; 0x68
 801d448:	4b0d      	ldr	r3, [pc, #52]	; (801d480 <HAL_UART_MspInit+0xe8>)
 801d44a:	687a      	ldr	r2, [r7, #4]
 801d44c:	629a      	str	r2, [r3, #40]	; 0x28

    /*##-4- Configure the NVIC for DMA #########################################*/
    /* NVIC configuration for DMA transfer complete interrupt (USART1_TX) */
    HAL_NVIC_SetPriority(USARTx_DMA_TX_IRQn, USARTx_Priority, 1);
 801d44e:	2201      	movs	r2, #1
 801d450:	2100      	movs	r1, #0
 801d452:	200b      	movs	r0, #11
 801d454:	f7ec fb3e 	bl	8009ad4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USARTx_DMA_TX_IRQn);
 801d458:	200b      	movs	r0, #11
 801d45a:	f7ec fb50 	bl	8009afe <HAL_NVIC_EnableIRQ>

    /* NVIC for USART, to catch the TX complete */
    HAL_NVIC_SetPriority(USARTx_IRQn, USARTx_DMA_Priority, 1);
 801d45e:	2201      	movs	r2, #1
 801d460:	2100      	movs	r1, #0
 801d462:	201b      	movs	r0, #27
 801d464:	f7ec fb36 	bl	8009ad4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USARTx_IRQn);
 801d468:	201b      	movs	r0, #27
 801d46a:	f7ec fb48 	bl	8009afe <HAL_NVIC_EnableIRQ>
  }
}
 801d46e:	46c0      	nop			; (mov r8, r8)
 801d470:	46bd      	mov	sp, r7
 801d472:	b006      	add	sp, #24
 801d474:	bd80      	pop	{r7, pc}
 801d476:	46c0      	nop			; (mov r8, r8)
 801d478:	40013800 	.word	0x40013800
 801d47c:	40021000 	.word	0x40021000
 801d480:	200016cc 	.word	0x200016cc
 801d484:	40020044 	.word	0x40020044

0801d488 <vcom_IoInit>:
  /*##-4- Disable the NVIC for DMA ###########################################*/
  HAL_NVIC_DisableIRQ(USARTx_DMA_TX_IRQn);
}

void vcom_IoInit(void)
{
 801d488:	b590      	push	{r4, r7, lr}
 801d48a:	b089      	sub	sp, #36	; 0x24
 801d48c:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef  GPIO_InitStruct = {0};
 801d48e:	240c      	movs	r4, #12
 801d490:	193b      	adds	r3, r7, r4
 801d492:	0018      	movs	r0, r3
 801d494:	2314      	movs	r3, #20
 801d496:	001a      	movs	r2, r3
 801d498:	2100      	movs	r1, #0
 801d49a:	f000 f85b 	bl	801d554 <memset>
  /* Enable GPIO TX/RX clock */
  USARTx_TX_GPIO_CLK_ENABLE();
 801d49e:	4b1a      	ldr	r3, [pc, #104]	; (801d508 <vcom_IoInit+0x80>)
 801d4a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801d4a2:	4b19      	ldr	r3, [pc, #100]	; (801d508 <vcom_IoInit+0x80>)
 801d4a4:	2101      	movs	r1, #1
 801d4a6:	430a      	orrs	r2, r1
 801d4a8:	62da      	str	r2, [r3, #44]	; 0x2c
 801d4aa:	4b17      	ldr	r3, [pc, #92]	; (801d508 <vcom_IoInit+0x80>)
 801d4ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801d4ae:	2201      	movs	r2, #1
 801d4b0:	4013      	ands	r3, r2
 801d4b2:	60bb      	str	r3, [r7, #8]
 801d4b4:	68bb      	ldr	r3, [r7, #8]
  USARTx_RX_GPIO_CLK_ENABLE();
 801d4b6:	4b14      	ldr	r3, [pc, #80]	; (801d508 <vcom_IoInit+0x80>)
 801d4b8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801d4ba:	4b13      	ldr	r3, [pc, #76]	; (801d508 <vcom_IoInit+0x80>)
 801d4bc:	2101      	movs	r1, #1
 801d4be:	430a      	orrs	r2, r1
 801d4c0:	62da      	str	r2, [r3, #44]	; 0x2c
 801d4c2:	4b11      	ldr	r3, [pc, #68]	; (801d508 <vcom_IoInit+0x80>)
 801d4c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801d4c6:	2201      	movs	r2, #1
 801d4c8:	4013      	ands	r3, r2
 801d4ca:	607b      	str	r3, [r7, #4]
 801d4cc:	687b      	ldr	r3, [r7, #4]
  /* UART TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = USARTx_TX_PIN;
 801d4ce:	193b      	adds	r3, r7, r4
 801d4d0:	2280      	movs	r2, #128	; 0x80
 801d4d2:	0092      	lsls	r2, r2, #2
 801d4d4:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 801d4d6:	0021      	movs	r1, r4
 801d4d8:	187b      	adds	r3, r7, r1
 801d4da:	2202      	movs	r2, #2
 801d4dc:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
 801d4de:	187b      	adds	r3, r7, r1
 801d4e0:	2200      	movs	r2, #0
 801d4e2:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
 801d4e4:	187b      	adds	r3, r7, r1
 801d4e6:	2203      	movs	r2, #3
 801d4e8:	60da      	str	r2, [r3, #12]
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
 801d4ea:	187b      	adds	r3, r7, r1
 801d4ec:	2204      	movs	r2, #4
 801d4ee:	611a      	str	r2, [r3, #16]

  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 801d4f0:	187a      	adds	r2, r7, r1
 801d4f2:	23a0      	movs	r3, #160	; 0xa0
 801d4f4:	05db      	lsls	r3, r3, #23
 801d4f6:	0011      	movs	r1, r2
 801d4f8:	0018      	movs	r0, r3
 801d4fa:	f7ec fd13 	bl	8009f24 <HAL_GPIO_Init>
  /* UART RX GPIO pin configuration  */
//  GPIO_InitStruct.Pin = USARTx_RX_PIN;
//  GPIO_InitStruct.Alternate = USARTx_RX_AF;
//
//  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
}
 801d4fe:	46c0      	nop			; (mov r8, r8)
 801d500:	46bd      	mov	sp, r7
 801d502:	b009      	add	sp, #36	; 0x24
 801d504:	bd90      	pop	{r4, r7, pc}
 801d506:	46c0      	nop			; (mov r8, r8)
 801d508:	40021000 	.word	0x40021000

0801d50c <__libc_init_array>:
 801d50c:	b570      	push	{r4, r5, r6, lr}
 801d50e:	2600      	movs	r6, #0
 801d510:	4d0c      	ldr	r5, [pc, #48]	; (801d544 <__libc_init_array+0x38>)
 801d512:	4c0d      	ldr	r4, [pc, #52]	; (801d548 <__libc_init_array+0x3c>)
 801d514:	1b64      	subs	r4, r4, r5
 801d516:	10a4      	asrs	r4, r4, #2
 801d518:	42a6      	cmp	r6, r4
 801d51a:	d109      	bne.n	801d530 <__libc_init_array+0x24>
 801d51c:	2600      	movs	r6, #0
 801d51e:	f001 fb45 	bl	801ebac <_init>
 801d522:	4d0a      	ldr	r5, [pc, #40]	; (801d54c <__libc_init_array+0x40>)
 801d524:	4c0a      	ldr	r4, [pc, #40]	; (801d550 <__libc_init_array+0x44>)
 801d526:	1b64      	subs	r4, r4, r5
 801d528:	10a4      	asrs	r4, r4, #2
 801d52a:	42a6      	cmp	r6, r4
 801d52c:	d105      	bne.n	801d53a <__libc_init_array+0x2e>
 801d52e:	bd70      	pop	{r4, r5, r6, pc}
 801d530:	00b3      	lsls	r3, r6, #2
 801d532:	58eb      	ldr	r3, [r5, r3]
 801d534:	4798      	blx	r3
 801d536:	3601      	adds	r6, #1
 801d538:	e7ee      	b.n	801d518 <__libc_init_array+0xc>
 801d53a:	00b3      	lsls	r3, r6, #2
 801d53c:	58eb      	ldr	r3, [r5, r3]
 801d53e:	4798      	blx	r3
 801d540:	3601      	adds	r6, #1
 801d542:	e7f2      	b.n	801d52a <__libc_init_array+0x1e>
 801d544:	0801fed4 	.word	0x0801fed4
 801d548:	0801fed4 	.word	0x0801fed4
 801d54c:	0801fed4 	.word	0x0801fed4
 801d550:	0801fed8 	.word	0x0801fed8

0801d554 <memset>:
 801d554:	0003      	movs	r3, r0
 801d556:	1882      	adds	r2, r0, r2
 801d558:	4293      	cmp	r3, r2
 801d55a:	d100      	bne.n	801d55e <memset+0xa>
 801d55c:	4770      	bx	lr
 801d55e:	7019      	strb	r1, [r3, #0]
 801d560:	3301      	adds	r3, #1
 801d562:	e7f9      	b.n	801d558 <memset+0x4>

0801d564 <iprintf>:
 801d564:	b40f      	push	{r0, r1, r2, r3}
 801d566:	4b0b      	ldr	r3, [pc, #44]	; (801d594 <iprintf+0x30>)
 801d568:	b513      	push	{r0, r1, r4, lr}
 801d56a:	681c      	ldr	r4, [r3, #0]
 801d56c:	2c00      	cmp	r4, #0
 801d56e:	d005      	beq.n	801d57c <iprintf+0x18>
 801d570:	69a3      	ldr	r3, [r4, #24]
 801d572:	2b00      	cmp	r3, #0
 801d574:	d102      	bne.n	801d57c <iprintf+0x18>
 801d576:	0020      	movs	r0, r4
 801d578:	f000 f8a8 	bl	801d6cc <__sinit>
 801d57c:	ab05      	add	r3, sp, #20
 801d57e:	0020      	movs	r0, r4
 801d580:	9a04      	ldr	r2, [sp, #16]
 801d582:	68a1      	ldr	r1, [r4, #8]
 801d584:	9301      	str	r3, [sp, #4]
 801d586:	f000 fb2d 	bl	801dbe4 <_vfiprintf_r>
 801d58a:	bc16      	pop	{r1, r2, r4}
 801d58c:	bc08      	pop	{r3}
 801d58e:	b004      	add	sp, #16
 801d590:	4718      	bx	r3
 801d592:	46c0      	nop			; (mov r8, r8)
 801d594:	200002d0 	.word	0x200002d0

0801d598 <_vsniprintf_r>:
 801d598:	b530      	push	{r4, r5, lr}
 801d59a:	0014      	movs	r4, r2
 801d59c:	0005      	movs	r5, r0
 801d59e:	001a      	movs	r2, r3
 801d5a0:	b09b      	sub	sp, #108	; 0x6c
 801d5a2:	2c00      	cmp	r4, #0
 801d5a4:	da05      	bge.n	801d5b2 <_vsniprintf_r+0x1a>
 801d5a6:	238b      	movs	r3, #139	; 0x8b
 801d5a8:	6003      	str	r3, [r0, #0]
 801d5aa:	2001      	movs	r0, #1
 801d5ac:	4240      	negs	r0, r0
 801d5ae:	b01b      	add	sp, #108	; 0x6c
 801d5b0:	bd30      	pop	{r4, r5, pc}
 801d5b2:	2382      	movs	r3, #130	; 0x82
 801d5b4:	4668      	mov	r0, sp
 801d5b6:	009b      	lsls	r3, r3, #2
 801d5b8:	8183      	strh	r3, [r0, #12]
 801d5ba:	2300      	movs	r3, #0
 801d5bc:	9100      	str	r1, [sp, #0]
 801d5be:	9104      	str	r1, [sp, #16]
 801d5c0:	429c      	cmp	r4, r3
 801d5c2:	d000      	beq.n	801d5c6 <_vsniprintf_r+0x2e>
 801d5c4:	1e63      	subs	r3, r4, #1
 801d5c6:	9302      	str	r3, [sp, #8]
 801d5c8:	9305      	str	r3, [sp, #20]
 801d5ca:	2301      	movs	r3, #1
 801d5cc:	4669      	mov	r1, sp
 801d5ce:	425b      	negs	r3, r3
 801d5d0:	81cb      	strh	r3, [r1, #14]
 801d5d2:	0028      	movs	r0, r5
 801d5d4:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 801d5d6:	f000 f9dd 	bl	801d994 <_svfiprintf_r>
 801d5da:	1c43      	adds	r3, r0, #1
 801d5dc:	da01      	bge.n	801d5e2 <_vsniprintf_r+0x4a>
 801d5de:	238b      	movs	r3, #139	; 0x8b
 801d5e0:	602b      	str	r3, [r5, #0]
 801d5e2:	2c00      	cmp	r4, #0
 801d5e4:	d0e3      	beq.n	801d5ae <_vsniprintf_r+0x16>
 801d5e6:	2300      	movs	r3, #0
 801d5e8:	9a00      	ldr	r2, [sp, #0]
 801d5ea:	7013      	strb	r3, [r2, #0]
 801d5ec:	e7df      	b.n	801d5ae <_vsniprintf_r+0x16>
	...

0801d5f0 <vsniprintf>:
 801d5f0:	b507      	push	{r0, r1, r2, lr}
 801d5f2:	9300      	str	r3, [sp, #0]
 801d5f4:	0013      	movs	r3, r2
 801d5f6:	000a      	movs	r2, r1
 801d5f8:	0001      	movs	r1, r0
 801d5fa:	4802      	ldr	r0, [pc, #8]	; (801d604 <vsniprintf+0x14>)
 801d5fc:	6800      	ldr	r0, [r0, #0]
 801d5fe:	f7ff ffcb 	bl	801d598 <_vsniprintf_r>
 801d602:	bd0e      	pop	{r1, r2, r3, pc}
 801d604:	200002d0 	.word	0x200002d0

0801d608 <std>:
 801d608:	2300      	movs	r3, #0
 801d60a:	b510      	push	{r4, lr}
 801d60c:	0004      	movs	r4, r0
 801d60e:	6003      	str	r3, [r0, #0]
 801d610:	6043      	str	r3, [r0, #4]
 801d612:	6083      	str	r3, [r0, #8]
 801d614:	8181      	strh	r1, [r0, #12]
 801d616:	6643      	str	r3, [r0, #100]	; 0x64
 801d618:	0019      	movs	r1, r3
 801d61a:	81c2      	strh	r2, [r0, #14]
 801d61c:	6103      	str	r3, [r0, #16]
 801d61e:	6143      	str	r3, [r0, #20]
 801d620:	6183      	str	r3, [r0, #24]
 801d622:	2208      	movs	r2, #8
 801d624:	305c      	adds	r0, #92	; 0x5c
 801d626:	f7ff ff95 	bl	801d554 <memset>
 801d62a:	4b05      	ldr	r3, [pc, #20]	; (801d640 <std+0x38>)
 801d62c:	6263      	str	r3, [r4, #36]	; 0x24
 801d62e:	4b05      	ldr	r3, [pc, #20]	; (801d644 <std+0x3c>)
 801d630:	6224      	str	r4, [r4, #32]
 801d632:	62a3      	str	r3, [r4, #40]	; 0x28
 801d634:	4b04      	ldr	r3, [pc, #16]	; (801d648 <std+0x40>)
 801d636:	62e3      	str	r3, [r4, #44]	; 0x2c
 801d638:	4b04      	ldr	r3, [pc, #16]	; (801d64c <std+0x44>)
 801d63a:	6323      	str	r3, [r4, #48]	; 0x30
 801d63c:	bd10      	pop	{r4, pc}
 801d63e:	46c0      	nop			; (mov r8, r8)
 801d640:	0801e181 	.word	0x0801e181
 801d644:	0801e1a9 	.word	0x0801e1a9
 801d648:	0801e1e1 	.word	0x0801e1e1
 801d64c:	0801e20d 	.word	0x0801e20d

0801d650 <_cleanup_r>:
 801d650:	b510      	push	{r4, lr}
 801d652:	4902      	ldr	r1, [pc, #8]	; (801d65c <_cleanup_r+0xc>)
 801d654:	f000 f8ba 	bl	801d7cc <_fwalk_reent>
 801d658:	bd10      	pop	{r4, pc}
 801d65a:	46c0      	nop			; (mov r8, r8)
 801d65c:	0801e519 	.word	0x0801e519

0801d660 <__sfmoreglue>:
 801d660:	b570      	push	{r4, r5, r6, lr}
 801d662:	2568      	movs	r5, #104	; 0x68
 801d664:	1e4a      	subs	r2, r1, #1
 801d666:	4355      	muls	r5, r2
 801d668:	000e      	movs	r6, r1
 801d66a:	0029      	movs	r1, r5
 801d66c:	3174      	adds	r1, #116	; 0x74
 801d66e:	f000 f8d1 	bl	801d814 <_malloc_r>
 801d672:	1e04      	subs	r4, r0, #0
 801d674:	d008      	beq.n	801d688 <__sfmoreglue+0x28>
 801d676:	2100      	movs	r1, #0
 801d678:	002a      	movs	r2, r5
 801d67a:	6001      	str	r1, [r0, #0]
 801d67c:	6046      	str	r6, [r0, #4]
 801d67e:	300c      	adds	r0, #12
 801d680:	60a0      	str	r0, [r4, #8]
 801d682:	3268      	adds	r2, #104	; 0x68
 801d684:	f7ff ff66 	bl	801d554 <memset>
 801d688:	0020      	movs	r0, r4
 801d68a:	bd70      	pop	{r4, r5, r6, pc}

0801d68c <__sfp_lock_acquire>:
 801d68c:	b510      	push	{r4, lr}
 801d68e:	4802      	ldr	r0, [pc, #8]	; (801d698 <__sfp_lock_acquire+0xc>)
 801d690:	f000 f8bd 	bl	801d80e <__retarget_lock_acquire_recursive>
 801d694:	bd10      	pop	{r4, pc}
 801d696:	46c0      	nop			; (mov r8, r8)
 801d698:	20001834 	.word	0x20001834

0801d69c <__sfp_lock_release>:
 801d69c:	b510      	push	{r4, lr}
 801d69e:	4802      	ldr	r0, [pc, #8]	; (801d6a8 <__sfp_lock_release+0xc>)
 801d6a0:	f000 f8b6 	bl	801d810 <__retarget_lock_release_recursive>
 801d6a4:	bd10      	pop	{r4, pc}
 801d6a6:	46c0      	nop			; (mov r8, r8)
 801d6a8:	20001834 	.word	0x20001834

0801d6ac <__sinit_lock_acquire>:
 801d6ac:	b510      	push	{r4, lr}
 801d6ae:	4802      	ldr	r0, [pc, #8]	; (801d6b8 <__sinit_lock_acquire+0xc>)
 801d6b0:	f000 f8ad 	bl	801d80e <__retarget_lock_acquire_recursive>
 801d6b4:	bd10      	pop	{r4, pc}
 801d6b6:	46c0      	nop			; (mov r8, r8)
 801d6b8:	2000182f 	.word	0x2000182f

0801d6bc <__sinit_lock_release>:
 801d6bc:	b510      	push	{r4, lr}
 801d6be:	4802      	ldr	r0, [pc, #8]	; (801d6c8 <__sinit_lock_release+0xc>)
 801d6c0:	f000 f8a6 	bl	801d810 <__retarget_lock_release_recursive>
 801d6c4:	bd10      	pop	{r4, pc}
 801d6c6:	46c0      	nop			; (mov r8, r8)
 801d6c8:	2000182f 	.word	0x2000182f

0801d6cc <__sinit>:
 801d6cc:	b513      	push	{r0, r1, r4, lr}
 801d6ce:	0004      	movs	r4, r0
 801d6d0:	f7ff ffec 	bl	801d6ac <__sinit_lock_acquire>
 801d6d4:	69a3      	ldr	r3, [r4, #24]
 801d6d6:	2b00      	cmp	r3, #0
 801d6d8:	d002      	beq.n	801d6e0 <__sinit+0x14>
 801d6da:	f7ff ffef 	bl	801d6bc <__sinit_lock_release>
 801d6de:	bd13      	pop	{r0, r1, r4, pc}
 801d6e0:	64a3      	str	r3, [r4, #72]	; 0x48
 801d6e2:	64e3      	str	r3, [r4, #76]	; 0x4c
 801d6e4:	6523      	str	r3, [r4, #80]	; 0x50
 801d6e6:	4b13      	ldr	r3, [pc, #76]	; (801d734 <__sinit+0x68>)
 801d6e8:	4a13      	ldr	r2, [pc, #76]	; (801d738 <__sinit+0x6c>)
 801d6ea:	681b      	ldr	r3, [r3, #0]
 801d6ec:	62a2      	str	r2, [r4, #40]	; 0x28
 801d6ee:	9301      	str	r3, [sp, #4]
 801d6f0:	42a3      	cmp	r3, r4
 801d6f2:	d101      	bne.n	801d6f8 <__sinit+0x2c>
 801d6f4:	2301      	movs	r3, #1
 801d6f6:	61a3      	str	r3, [r4, #24]
 801d6f8:	0020      	movs	r0, r4
 801d6fa:	f000 f81f 	bl	801d73c <__sfp>
 801d6fe:	6060      	str	r0, [r4, #4]
 801d700:	0020      	movs	r0, r4
 801d702:	f000 f81b 	bl	801d73c <__sfp>
 801d706:	60a0      	str	r0, [r4, #8]
 801d708:	0020      	movs	r0, r4
 801d70a:	f000 f817 	bl	801d73c <__sfp>
 801d70e:	2200      	movs	r2, #0
 801d710:	2104      	movs	r1, #4
 801d712:	60e0      	str	r0, [r4, #12]
 801d714:	6860      	ldr	r0, [r4, #4]
 801d716:	f7ff ff77 	bl	801d608 <std>
 801d71a:	2201      	movs	r2, #1
 801d71c:	2109      	movs	r1, #9
 801d71e:	68a0      	ldr	r0, [r4, #8]
 801d720:	f7ff ff72 	bl	801d608 <std>
 801d724:	2202      	movs	r2, #2
 801d726:	2112      	movs	r1, #18
 801d728:	68e0      	ldr	r0, [r4, #12]
 801d72a:	f7ff ff6d 	bl	801d608 <std>
 801d72e:	2301      	movs	r3, #1
 801d730:	61a3      	str	r3, [r4, #24]
 801d732:	e7d2      	b.n	801d6da <__sinit+0xe>
 801d734:	0801fe34 	.word	0x0801fe34
 801d738:	0801d651 	.word	0x0801d651

0801d73c <__sfp>:
 801d73c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d73e:	0007      	movs	r7, r0
 801d740:	f7ff ffa4 	bl	801d68c <__sfp_lock_acquire>
 801d744:	4b1f      	ldr	r3, [pc, #124]	; (801d7c4 <__sfp+0x88>)
 801d746:	681e      	ldr	r6, [r3, #0]
 801d748:	69b3      	ldr	r3, [r6, #24]
 801d74a:	2b00      	cmp	r3, #0
 801d74c:	d102      	bne.n	801d754 <__sfp+0x18>
 801d74e:	0030      	movs	r0, r6
 801d750:	f7ff ffbc 	bl	801d6cc <__sinit>
 801d754:	3648      	adds	r6, #72	; 0x48
 801d756:	68b4      	ldr	r4, [r6, #8]
 801d758:	6873      	ldr	r3, [r6, #4]
 801d75a:	3b01      	subs	r3, #1
 801d75c:	d504      	bpl.n	801d768 <__sfp+0x2c>
 801d75e:	6833      	ldr	r3, [r6, #0]
 801d760:	2b00      	cmp	r3, #0
 801d762:	d022      	beq.n	801d7aa <__sfp+0x6e>
 801d764:	6836      	ldr	r6, [r6, #0]
 801d766:	e7f6      	b.n	801d756 <__sfp+0x1a>
 801d768:	220c      	movs	r2, #12
 801d76a:	5ea5      	ldrsh	r5, [r4, r2]
 801d76c:	2d00      	cmp	r5, #0
 801d76e:	d11a      	bne.n	801d7a6 <__sfp+0x6a>
 801d770:	0020      	movs	r0, r4
 801d772:	4b15      	ldr	r3, [pc, #84]	; (801d7c8 <__sfp+0x8c>)
 801d774:	3058      	adds	r0, #88	; 0x58
 801d776:	60e3      	str	r3, [r4, #12]
 801d778:	6665      	str	r5, [r4, #100]	; 0x64
 801d77a:	f000 f847 	bl	801d80c <__retarget_lock_init_recursive>
 801d77e:	f7ff ff8d 	bl	801d69c <__sfp_lock_release>
 801d782:	0020      	movs	r0, r4
 801d784:	2208      	movs	r2, #8
 801d786:	0029      	movs	r1, r5
 801d788:	6025      	str	r5, [r4, #0]
 801d78a:	60a5      	str	r5, [r4, #8]
 801d78c:	6065      	str	r5, [r4, #4]
 801d78e:	6125      	str	r5, [r4, #16]
 801d790:	6165      	str	r5, [r4, #20]
 801d792:	61a5      	str	r5, [r4, #24]
 801d794:	305c      	adds	r0, #92	; 0x5c
 801d796:	f7ff fedd 	bl	801d554 <memset>
 801d79a:	6365      	str	r5, [r4, #52]	; 0x34
 801d79c:	63a5      	str	r5, [r4, #56]	; 0x38
 801d79e:	64a5      	str	r5, [r4, #72]	; 0x48
 801d7a0:	64e5      	str	r5, [r4, #76]	; 0x4c
 801d7a2:	0020      	movs	r0, r4
 801d7a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801d7a6:	3468      	adds	r4, #104	; 0x68
 801d7a8:	e7d7      	b.n	801d75a <__sfp+0x1e>
 801d7aa:	2104      	movs	r1, #4
 801d7ac:	0038      	movs	r0, r7
 801d7ae:	f7ff ff57 	bl	801d660 <__sfmoreglue>
 801d7b2:	1e04      	subs	r4, r0, #0
 801d7b4:	6030      	str	r0, [r6, #0]
 801d7b6:	d1d5      	bne.n	801d764 <__sfp+0x28>
 801d7b8:	f7ff ff70 	bl	801d69c <__sfp_lock_release>
 801d7bc:	230c      	movs	r3, #12
 801d7be:	603b      	str	r3, [r7, #0]
 801d7c0:	e7ef      	b.n	801d7a2 <__sfp+0x66>
 801d7c2:	46c0      	nop			; (mov r8, r8)
 801d7c4:	0801fe34 	.word	0x0801fe34
 801d7c8:	ffff0001 	.word	0xffff0001

0801d7cc <_fwalk_reent>:
 801d7cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801d7ce:	0004      	movs	r4, r0
 801d7d0:	0006      	movs	r6, r0
 801d7d2:	2700      	movs	r7, #0
 801d7d4:	9101      	str	r1, [sp, #4]
 801d7d6:	3448      	adds	r4, #72	; 0x48
 801d7d8:	6863      	ldr	r3, [r4, #4]
 801d7da:	68a5      	ldr	r5, [r4, #8]
 801d7dc:	9300      	str	r3, [sp, #0]
 801d7de:	9b00      	ldr	r3, [sp, #0]
 801d7e0:	3b01      	subs	r3, #1
 801d7e2:	9300      	str	r3, [sp, #0]
 801d7e4:	d504      	bpl.n	801d7f0 <_fwalk_reent+0x24>
 801d7e6:	6824      	ldr	r4, [r4, #0]
 801d7e8:	2c00      	cmp	r4, #0
 801d7ea:	d1f5      	bne.n	801d7d8 <_fwalk_reent+0xc>
 801d7ec:	0038      	movs	r0, r7
 801d7ee:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 801d7f0:	89ab      	ldrh	r3, [r5, #12]
 801d7f2:	2b01      	cmp	r3, #1
 801d7f4:	d908      	bls.n	801d808 <_fwalk_reent+0x3c>
 801d7f6:	220e      	movs	r2, #14
 801d7f8:	5eab      	ldrsh	r3, [r5, r2]
 801d7fa:	3301      	adds	r3, #1
 801d7fc:	d004      	beq.n	801d808 <_fwalk_reent+0x3c>
 801d7fe:	0029      	movs	r1, r5
 801d800:	0030      	movs	r0, r6
 801d802:	9b01      	ldr	r3, [sp, #4]
 801d804:	4798      	blx	r3
 801d806:	4307      	orrs	r7, r0
 801d808:	3568      	adds	r5, #104	; 0x68
 801d80a:	e7e8      	b.n	801d7de <_fwalk_reent+0x12>

0801d80c <__retarget_lock_init_recursive>:
 801d80c:	4770      	bx	lr

0801d80e <__retarget_lock_acquire_recursive>:
 801d80e:	4770      	bx	lr

0801d810 <__retarget_lock_release_recursive>:
 801d810:	4770      	bx	lr
	...

0801d814 <_malloc_r>:
 801d814:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d816:	2303      	movs	r3, #3
 801d818:	1ccd      	adds	r5, r1, #3
 801d81a:	439d      	bics	r5, r3
 801d81c:	3508      	adds	r5, #8
 801d81e:	0006      	movs	r6, r0
 801d820:	2d0c      	cmp	r5, #12
 801d822:	d21f      	bcs.n	801d864 <_malloc_r+0x50>
 801d824:	250c      	movs	r5, #12
 801d826:	42a9      	cmp	r1, r5
 801d828:	d81e      	bhi.n	801d868 <_malloc_r+0x54>
 801d82a:	0030      	movs	r0, r6
 801d82c:	f000 ff5c 	bl	801e6e8 <__malloc_lock>
 801d830:	4925      	ldr	r1, [pc, #148]	; (801d8c8 <_malloc_r+0xb4>)
 801d832:	680a      	ldr	r2, [r1, #0]
 801d834:	0014      	movs	r4, r2
 801d836:	2c00      	cmp	r4, #0
 801d838:	d11a      	bne.n	801d870 <_malloc_r+0x5c>
 801d83a:	4f24      	ldr	r7, [pc, #144]	; (801d8cc <_malloc_r+0xb8>)
 801d83c:	683b      	ldr	r3, [r7, #0]
 801d83e:	2b00      	cmp	r3, #0
 801d840:	d104      	bne.n	801d84c <_malloc_r+0x38>
 801d842:	0021      	movs	r1, r4
 801d844:	0030      	movs	r0, r6
 801d846:	f000 fc89 	bl	801e15c <_sbrk_r>
 801d84a:	6038      	str	r0, [r7, #0]
 801d84c:	0029      	movs	r1, r5
 801d84e:	0030      	movs	r0, r6
 801d850:	f000 fc84 	bl	801e15c <_sbrk_r>
 801d854:	1c43      	adds	r3, r0, #1
 801d856:	d12b      	bne.n	801d8b0 <_malloc_r+0x9c>
 801d858:	230c      	movs	r3, #12
 801d85a:	0030      	movs	r0, r6
 801d85c:	6033      	str	r3, [r6, #0]
 801d85e:	f000 ff4b 	bl	801e6f8 <__malloc_unlock>
 801d862:	e003      	b.n	801d86c <_malloc_r+0x58>
 801d864:	2d00      	cmp	r5, #0
 801d866:	dade      	bge.n	801d826 <_malloc_r+0x12>
 801d868:	230c      	movs	r3, #12
 801d86a:	6033      	str	r3, [r6, #0]
 801d86c:	2000      	movs	r0, #0
 801d86e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801d870:	6823      	ldr	r3, [r4, #0]
 801d872:	1b5b      	subs	r3, r3, r5
 801d874:	d419      	bmi.n	801d8aa <_malloc_r+0x96>
 801d876:	2b0b      	cmp	r3, #11
 801d878:	d903      	bls.n	801d882 <_malloc_r+0x6e>
 801d87a:	6023      	str	r3, [r4, #0]
 801d87c:	18e4      	adds	r4, r4, r3
 801d87e:	6025      	str	r5, [r4, #0]
 801d880:	e003      	b.n	801d88a <_malloc_r+0x76>
 801d882:	6863      	ldr	r3, [r4, #4]
 801d884:	42a2      	cmp	r2, r4
 801d886:	d10e      	bne.n	801d8a6 <_malloc_r+0x92>
 801d888:	600b      	str	r3, [r1, #0]
 801d88a:	0030      	movs	r0, r6
 801d88c:	f000 ff34 	bl	801e6f8 <__malloc_unlock>
 801d890:	0020      	movs	r0, r4
 801d892:	2207      	movs	r2, #7
 801d894:	300b      	adds	r0, #11
 801d896:	1d23      	adds	r3, r4, #4
 801d898:	4390      	bics	r0, r2
 801d89a:	1ac2      	subs	r2, r0, r3
 801d89c:	4298      	cmp	r0, r3
 801d89e:	d0e6      	beq.n	801d86e <_malloc_r+0x5a>
 801d8a0:	1a1b      	subs	r3, r3, r0
 801d8a2:	50a3      	str	r3, [r4, r2]
 801d8a4:	e7e3      	b.n	801d86e <_malloc_r+0x5a>
 801d8a6:	6053      	str	r3, [r2, #4]
 801d8a8:	e7ef      	b.n	801d88a <_malloc_r+0x76>
 801d8aa:	0022      	movs	r2, r4
 801d8ac:	6864      	ldr	r4, [r4, #4]
 801d8ae:	e7c2      	b.n	801d836 <_malloc_r+0x22>
 801d8b0:	2303      	movs	r3, #3
 801d8b2:	1cc4      	adds	r4, r0, #3
 801d8b4:	439c      	bics	r4, r3
 801d8b6:	42a0      	cmp	r0, r4
 801d8b8:	d0e1      	beq.n	801d87e <_malloc_r+0x6a>
 801d8ba:	1a21      	subs	r1, r4, r0
 801d8bc:	0030      	movs	r0, r6
 801d8be:	f000 fc4d 	bl	801e15c <_sbrk_r>
 801d8c2:	1c43      	adds	r3, r0, #1
 801d8c4:	d1db      	bne.n	801d87e <_malloc_r+0x6a>
 801d8c6:	e7c7      	b.n	801d858 <_malloc_r+0x44>
 801d8c8:	20001714 	.word	0x20001714
 801d8cc:	20001718 	.word	0x20001718

0801d8d0 <__ssputs_r>:
 801d8d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d8d2:	688e      	ldr	r6, [r1, #8]
 801d8d4:	b085      	sub	sp, #20
 801d8d6:	0007      	movs	r7, r0
 801d8d8:	000c      	movs	r4, r1
 801d8da:	9203      	str	r2, [sp, #12]
 801d8dc:	9301      	str	r3, [sp, #4]
 801d8de:	429e      	cmp	r6, r3
 801d8e0:	d83c      	bhi.n	801d95c <__ssputs_r+0x8c>
 801d8e2:	2390      	movs	r3, #144	; 0x90
 801d8e4:	898a      	ldrh	r2, [r1, #12]
 801d8e6:	00db      	lsls	r3, r3, #3
 801d8e8:	421a      	tst	r2, r3
 801d8ea:	d034      	beq.n	801d956 <__ssputs_r+0x86>
 801d8ec:	2503      	movs	r5, #3
 801d8ee:	6909      	ldr	r1, [r1, #16]
 801d8f0:	6823      	ldr	r3, [r4, #0]
 801d8f2:	1a5b      	subs	r3, r3, r1
 801d8f4:	9302      	str	r3, [sp, #8]
 801d8f6:	6963      	ldr	r3, [r4, #20]
 801d8f8:	9802      	ldr	r0, [sp, #8]
 801d8fa:	435d      	muls	r5, r3
 801d8fc:	0feb      	lsrs	r3, r5, #31
 801d8fe:	195d      	adds	r5, r3, r5
 801d900:	9b01      	ldr	r3, [sp, #4]
 801d902:	106d      	asrs	r5, r5, #1
 801d904:	3301      	adds	r3, #1
 801d906:	181b      	adds	r3, r3, r0
 801d908:	42ab      	cmp	r3, r5
 801d90a:	d900      	bls.n	801d90e <__ssputs_r+0x3e>
 801d90c:	001d      	movs	r5, r3
 801d90e:	0553      	lsls	r3, r2, #21
 801d910:	d532      	bpl.n	801d978 <__ssputs_r+0xa8>
 801d912:	0029      	movs	r1, r5
 801d914:	0038      	movs	r0, r7
 801d916:	f7ff ff7d 	bl	801d814 <_malloc_r>
 801d91a:	1e06      	subs	r6, r0, #0
 801d91c:	d109      	bne.n	801d932 <__ssputs_r+0x62>
 801d91e:	230c      	movs	r3, #12
 801d920:	603b      	str	r3, [r7, #0]
 801d922:	2340      	movs	r3, #64	; 0x40
 801d924:	2001      	movs	r0, #1
 801d926:	89a2      	ldrh	r2, [r4, #12]
 801d928:	4240      	negs	r0, r0
 801d92a:	4313      	orrs	r3, r2
 801d92c:	81a3      	strh	r3, [r4, #12]
 801d92e:	b005      	add	sp, #20
 801d930:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d932:	9a02      	ldr	r2, [sp, #8]
 801d934:	6921      	ldr	r1, [r4, #16]
 801d936:	f000 feba 	bl	801e6ae <memcpy>
 801d93a:	89a3      	ldrh	r3, [r4, #12]
 801d93c:	4a14      	ldr	r2, [pc, #80]	; (801d990 <__ssputs_r+0xc0>)
 801d93e:	401a      	ands	r2, r3
 801d940:	2380      	movs	r3, #128	; 0x80
 801d942:	4313      	orrs	r3, r2
 801d944:	81a3      	strh	r3, [r4, #12]
 801d946:	9b02      	ldr	r3, [sp, #8]
 801d948:	6126      	str	r6, [r4, #16]
 801d94a:	18f6      	adds	r6, r6, r3
 801d94c:	6026      	str	r6, [r4, #0]
 801d94e:	6165      	str	r5, [r4, #20]
 801d950:	9e01      	ldr	r6, [sp, #4]
 801d952:	1aed      	subs	r5, r5, r3
 801d954:	60a5      	str	r5, [r4, #8]
 801d956:	9b01      	ldr	r3, [sp, #4]
 801d958:	429e      	cmp	r6, r3
 801d95a:	d900      	bls.n	801d95e <__ssputs_r+0x8e>
 801d95c:	9e01      	ldr	r6, [sp, #4]
 801d95e:	0032      	movs	r2, r6
 801d960:	9903      	ldr	r1, [sp, #12]
 801d962:	6820      	ldr	r0, [r4, #0]
 801d964:	f000 feac 	bl	801e6c0 <memmove>
 801d968:	68a3      	ldr	r3, [r4, #8]
 801d96a:	2000      	movs	r0, #0
 801d96c:	1b9b      	subs	r3, r3, r6
 801d96e:	60a3      	str	r3, [r4, #8]
 801d970:	6823      	ldr	r3, [r4, #0]
 801d972:	199e      	adds	r6, r3, r6
 801d974:	6026      	str	r6, [r4, #0]
 801d976:	e7da      	b.n	801d92e <__ssputs_r+0x5e>
 801d978:	002a      	movs	r2, r5
 801d97a:	0038      	movs	r0, r7
 801d97c:	f000 ff0e 	bl	801e79c <_realloc_r>
 801d980:	1e06      	subs	r6, r0, #0
 801d982:	d1e0      	bne.n	801d946 <__ssputs_r+0x76>
 801d984:	0038      	movs	r0, r7
 801d986:	6921      	ldr	r1, [r4, #16]
 801d988:	f000 febe 	bl	801e708 <_free_r>
 801d98c:	e7c7      	b.n	801d91e <__ssputs_r+0x4e>
 801d98e:	46c0      	nop			; (mov r8, r8)
 801d990:	fffffb7f 	.word	0xfffffb7f

0801d994 <_svfiprintf_r>:
 801d994:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d996:	b0a1      	sub	sp, #132	; 0x84
 801d998:	9003      	str	r0, [sp, #12]
 801d99a:	001d      	movs	r5, r3
 801d99c:	898b      	ldrh	r3, [r1, #12]
 801d99e:	000f      	movs	r7, r1
 801d9a0:	0016      	movs	r6, r2
 801d9a2:	061b      	lsls	r3, r3, #24
 801d9a4:	d511      	bpl.n	801d9ca <_svfiprintf_r+0x36>
 801d9a6:	690b      	ldr	r3, [r1, #16]
 801d9a8:	2b00      	cmp	r3, #0
 801d9aa:	d10e      	bne.n	801d9ca <_svfiprintf_r+0x36>
 801d9ac:	2140      	movs	r1, #64	; 0x40
 801d9ae:	f7ff ff31 	bl	801d814 <_malloc_r>
 801d9b2:	6038      	str	r0, [r7, #0]
 801d9b4:	6138      	str	r0, [r7, #16]
 801d9b6:	2800      	cmp	r0, #0
 801d9b8:	d105      	bne.n	801d9c6 <_svfiprintf_r+0x32>
 801d9ba:	230c      	movs	r3, #12
 801d9bc:	9a03      	ldr	r2, [sp, #12]
 801d9be:	3801      	subs	r0, #1
 801d9c0:	6013      	str	r3, [r2, #0]
 801d9c2:	b021      	add	sp, #132	; 0x84
 801d9c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d9c6:	2340      	movs	r3, #64	; 0x40
 801d9c8:	617b      	str	r3, [r7, #20]
 801d9ca:	2300      	movs	r3, #0
 801d9cc:	ac08      	add	r4, sp, #32
 801d9ce:	6163      	str	r3, [r4, #20]
 801d9d0:	3320      	adds	r3, #32
 801d9d2:	7663      	strb	r3, [r4, #25]
 801d9d4:	3310      	adds	r3, #16
 801d9d6:	76a3      	strb	r3, [r4, #26]
 801d9d8:	9507      	str	r5, [sp, #28]
 801d9da:	0035      	movs	r5, r6
 801d9dc:	782b      	ldrb	r3, [r5, #0]
 801d9de:	2b00      	cmp	r3, #0
 801d9e0:	d001      	beq.n	801d9e6 <_svfiprintf_r+0x52>
 801d9e2:	2b25      	cmp	r3, #37	; 0x25
 801d9e4:	d147      	bne.n	801da76 <_svfiprintf_r+0xe2>
 801d9e6:	1bab      	subs	r3, r5, r6
 801d9e8:	9305      	str	r3, [sp, #20]
 801d9ea:	42b5      	cmp	r5, r6
 801d9ec:	d00c      	beq.n	801da08 <_svfiprintf_r+0x74>
 801d9ee:	0032      	movs	r2, r6
 801d9f0:	0039      	movs	r1, r7
 801d9f2:	9803      	ldr	r0, [sp, #12]
 801d9f4:	f7ff ff6c 	bl	801d8d0 <__ssputs_r>
 801d9f8:	1c43      	adds	r3, r0, #1
 801d9fa:	d100      	bne.n	801d9fe <_svfiprintf_r+0x6a>
 801d9fc:	e0ae      	b.n	801db5c <_svfiprintf_r+0x1c8>
 801d9fe:	6962      	ldr	r2, [r4, #20]
 801da00:	9b05      	ldr	r3, [sp, #20]
 801da02:	4694      	mov	ip, r2
 801da04:	4463      	add	r3, ip
 801da06:	6163      	str	r3, [r4, #20]
 801da08:	782b      	ldrb	r3, [r5, #0]
 801da0a:	2b00      	cmp	r3, #0
 801da0c:	d100      	bne.n	801da10 <_svfiprintf_r+0x7c>
 801da0e:	e0a5      	b.n	801db5c <_svfiprintf_r+0x1c8>
 801da10:	2201      	movs	r2, #1
 801da12:	2300      	movs	r3, #0
 801da14:	4252      	negs	r2, r2
 801da16:	6062      	str	r2, [r4, #4]
 801da18:	a904      	add	r1, sp, #16
 801da1a:	3254      	adds	r2, #84	; 0x54
 801da1c:	1852      	adds	r2, r2, r1
 801da1e:	1c6e      	adds	r6, r5, #1
 801da20:	6023      	str	r3, [r4, #0]
 801da22:	60e3      	str	r3, [r4, #12]
 801da24:	60a3      	str	r3, [r4, #8]
 801da26:	7013      	strb	r3, [r2, #0]
 801da28:	65a3      	str	r3, [r4, #88]	; 0x58
 801da2a:	2205      	movs	r2, #5
 801da2c:	7831      	ldrb	r1, [r6, #0]
 801da2e:	4854      	ldr	r0, [pc, #336]	; (801db80 <_svfiprintf_r+0x1ec>)
 801da30:	f000 fe32 	bl	801e698 <memchr>
 801da34:	1c75      	adds	r5, r6, #1
 801da36:	2800      	cmp	r0, #0
 801da38:	d11f      	bne.n	801da7a <_svfiprintf_r+0xe6>
 801da3a:	6822      	ldr	r2, [r4, #0]
 801da3c:	06d3      	lsls	r3, r2, #27
 801da3e:	d504      	bpl.n	801da4a <_svfiprintf_r+0xb6>
 801da40:	2353      	movs	r3, #83	; 0x53
 801da42:	a904      	add	r1, sp, #16
 801da44:	185b      	adds	r3, r3, r1
 801da46:	2120      	movs	r1, #32
 801da48:	7019      	strb	r1, [r3, #0]
 801da4a:	0713      	lsls	r3, r2, #28
 801da4c:	d504      	bpl.n	801da58 <_svfiprintf_r+0xc4>
 801da4e:	2353      	movs	r3, #83	; 0x53
 801da50:	a904      	add	r1, sp, #16
 801da52:	185b      	adds	r3, r3, r1
 801da54:	212b      	movs	r1, #43	; 0x2b
 801da56:	7019      	strb	r1, [r3, #0]
 801da58:	7833      	ldrb	r3, [r6, #0]
 801da5a:	2b2a      	cmp	r3, #42	; 0x2a
 801da5c:	d016      	beq.n	801da8c <_svfiprintf_r+0xf8>
 801da5e:	0035      	movs	r5, r6
 801da60:	2100      	movs	r1, #0
 801da62:	200a      	movs	r0, #10
 801da64:	68e3      	ldr	r3, [r4, #12]
 801da66:	782a      	ldrb	r2, [r5, #0]
 801da68:	1c6e      	adds	r6, r5, #1
 801da6a:	3a30      	subs	r2, #48	; 0x30
 801da6c:	2a09      	cmp	r2, #9
 801da6e:	d94e      	bls.n	801db0e <_svfiprintf_r+0x17a>
 801da70:	2900      	cmp	r1, #0
 801da72:	d111      	bne.n	801da98 <_svfiprintf_r+0x104>
 801da74:	e017      	b.n	801daa6 <_svfiprintf_r+0x112>
 801da76:	3501      	adds	r5, #1
 801da78:	e7b0      	b.n	801d9dc <_svfiprintf_r+0x48>
 801da7a:	4b41      	ldr	r3, [pc, #260]	; (801db80 <_svfiprintf_r+0x1ec>)
 801da7c:	6822      	ldr	r2, [r4, #0]
 801da7e:	1ac0      	subs	r0, r0, r3
 801da80:	2301      	movs	r3, #1
 801da82:	4083      	lsls	r3, r0
 801da84:	4313      	orrs	r3, r2
 801da86:	002e      	movs	r6, r5
 801da88:	6023      	str	r3, [r4, #0]
 801da8a:	e7ce      	b.n	801da2a <_svfiprintf_r+0x96>
 801da8c:	9b07      	ldr	r3, [sp, #28]
 801da8e:	1d19      	adds	r1, r3, #4
 801da90:	681b      	ldr	r3, [r3, #0]
 801da92:	9107      	str	r1, [sp, #28]
 801da94:	2b00      	cmp	r3, #0
 801da96:	db01      	blt.n	801da9c <_svfiprintf_r+0x108>
 801da98:	930b      	str	r3, [sp, #44]	; 0x2c
 801da9a:	e004      	b.n	801daa6 <_svfiprintf_r+0x112>
 801da9c:	425b      	negs	r3, r3
 801da9e:	60e3      	str	r3, [r4, #12]
 801daa0:	2302      	movs	r3, #2
 801daa2:	4313      	orrs	r3, r2
 801daa4:	6023      	str	r3, [r4, #0]
 801daa6:	782b      	ldrb	r3, [r5, #0]
 801daa8:	2b2e      	cmp	r3, #46	; 0x2e
 801daaa:	d10a      	bne.n	801dac2 <_svfiprintf_r+0x12e>
 801daac:	786b      	ldrb	r3, [r5, #1]
 801daae:	2b2a      	cmp	r3, #42	; 0x2a
 801dab0:	d135      	bne.n	801db1e <_svfiprintf_r+0x18a>
 801dab2:	9b07      	ldr	r3, [sp, #28]
 801dab4:	3502      	adds	r5, #2
 801dab6:	1d1a      	adds	r2, r3, #4
 801dab8:	681b      	ldr	r3, [r3, #0]
 801daba:	9207      	str	r2, [sp, #28]
 801dabc:	2b00      	cmp	r3, #0
 801dabe:	db2b      	blt.n	801db18 <_svfiprintf_r+0x184>
 801dac0:	9309      	str	r3, [sp, #36]	; 0x24
 801dac2:	4e30      	ldr	r6, [pc, #192]	; (801db84 <_svfiprintf_r+0x1f0>)
 801dac4:	2203      	movs	r2, #3
 801dac6:	0030      	movs	r0, r6
 801dac8:	7829      	ldrb	r1, [r5, #0]
 801daca:	f000 fde5 	bl	801e698 <memchr>
 801dace:	2800      	cmp	r0, #0
 801dad0:	d006      	beq.n	801dae0 <_svfiprintf_r+0x14c>
 801dad2:	2340      	movs	r3, #64	; 0x40
 801dad4:	1b80      	subs	r0, r0, r6
 801dad6:	4083      	lsls	r3, r0
 801dad8:	6822      	ldr	r2, [r4, #0]
 801dada:	3501      	adds	r5, #1
 801dadc:	4313      	orrs	r3, r2
 801dade:	6023      	str	r3, [r4, #0]
 801dae0:	7829      	ldrb	r1, [r5, #0]
 801dae2:	2206      	movs	r2, #6
 801dae4:	4828      	ldr	r0, [pc, #160]	; (801db88 <_svfiprintf_r+0x1f4>)
 801dae6:	1c6e      	adds	r6, r5, #1
 801dae8:	7621      	strb	r1, [r4, #24]
 801daea:	f000 fdd5 	bl	801e698 <memchr>
 801daee:	2800      	cmp	r0, #0
 801daf0:	d03c      	beq.n	801db6c <_svfiprintf_r+0x1d8>
 801daf2:	4b26      	ldr	r3, [pc, #152]	; (801db8c <_svfiprintf_r+0x1f8>)
 801daf4:	2b00      	cmp	r3, #0
 801daf6:	d125      	bne.n	801db44 <_svfiprintf_r+0x1b0>
 801daf8:	2207      	movs	r2, #7
 801dafa:	9b07      	ldr	r3, [sp, #28]
 801dafc:	3307      	adds	r3, #7
 801dafe:	4393      	bics	r3, r2
 801db00:	3308      	adds	r3, #8
 801db02:	9307      	str	r3, [sp, #28]
 801db04:	6963      	ldr	r3, [r4, #20]
 801db06:	9a04      	ldr	r2, [sp, #16]
 801db08:	189b      	adds	r3, r3, r2
 801db0a:	6163      	str	r3, [r4, #20]
 801db0c:	e765      	b.n	801d9da <_svfiprintf_r+0x46>
 801db0e:	4343      	muls	r3, r0
 801db10:	0035      	movs	r5, r6
 801db12:	2101      	movs	r1, #1
 801db14:	189b      	adds	r3, r3, r2
 801db16:	e7a6      	b.n	801da66 <_svfiprintf_r+0xd2>
 801db18:	2301      	movs	r3, #1
 801db1a:	425b      	negs	r3, r3
 801db1c:	e7d0      	b.n	801dac0 <_svfiprintf_r+0x12c>
 801db1e:	2300      	movs	r3, #0
 801db20:	200a      	movs	r0, #10
 801db22:	001a      	movs	r2, r3
 801db24:	3501      	adds	r5, #1
 801db26:	6063      	str	r3, [r4, #4]
 801db28:	7829      	ldrb	r1, [r5, #0]
 801db2a:	1c6e      	adds	r6, r5, #1
 801db2c:	3930      	subs	r1, #48	; 0x30
 801db2e:	2909      	cmp	r1, #9
 801db30:	d903      	bls.n	801db3a <_svfiprintf_r+0x1a6>
 801db32:	2b00      	cmp	r3, #0
 801db34:	d0c5      	beq.n	801dac2 <_svfiprintf_r+0x12e>
 801db36:	9209      	str	r2, [sp, #36]	; 0x24
 801db38:	e7c3      	b.n	801dac2 <_svfiprintf_r+0x12e>
 801db3a:	4342      	muls	r2, r0
 801db3c:	0035      	movs	r5, r6
 801db3e:	2301      	movs	r3, #1
 801db40:	1852      	adds	r2, r2, r1
 801db42:	e7f1      	b.n	801db28 <_svfiprintf_r+0x194>
 801db44:	ab07      	add	r3, sp, #28
 801db46:	9300      	str	r3, [sp, #0]
 801db48:	003a      	movs	r2, r7
 801db4a:	0021      	movs	r1, r4
 801db4c:	4b10      	ldr	r3, [pc, #64]	; (801db90 <_svfiprintf_r+0x1fc>)
 801db4e:	9803      	ldr	r0, [sp, #12]
 801db50:	e000      	b.n	801db54 <_svfiprintf_r+0x1c0>
 801db52:	bf00      	nop
 801db54:	9004      	str	r0, [sp, #16]
 801db56:	9b04      	ldr	r3, [sp, #16]
 801db58:	3301      	adds	r3, #1
 801db5a:	d1d3      	bne.n	801db04 <_svfiprintf_r+0x170>
 801db5c:	89bb      	ldrh	r3, [r7, #12]
 801db5e:	980d      	ldr	r0, [sp, #52]	; 0x34
 801db60:	065b      	lsls	r3, r3, #25
 801db62:	d400      	bmi.n	801db66 <_svfiprintf_r+0x1d2>
 801db64:	e72d      	b.n	801d9c2 <_svfiprintf_r+0x2e>
 801db66:	2001      	movs	r0, #1
 801db68:	4240      	negs	r0, r0
 801db6a:	e72a      	b.n	801d9c2 <_svfiprintf_r+0x2e>
 801db6c:	ab07      	add	r3, sp, #28
 801db6e:	9300      	str	r3, [sp, #0]
 801db70:	003a      	movs	r2, r7
 801db72:	0021      	movs	r1, r4
 801db74:	4b06      	ldr	r3, [pc, #24]	; (801db90 <_svfiprintf_r+0x1fc>)
 801db76:	9803      	ldr	r0, [sp, #12]
 801db78:	f000 f9de 	bl	801df38 <_printf_i>
 801db7c:	e7ea      	b.n	801db54 <_svfiprintf_r+0x1c0>
 801db7e:	46c0      	nop			; (mov r8, r8)
 801db80:	0801fe98 	.word	0x0801fe98
 801db84:	0801fe9e 	.word	0x0801fe9e
 801db88:	0801fea2 	.word	0x0801fea2
 801db8c:	00000000 	.word	0x00000000
 801db90:	0801d8d1 	.word	0x0801d8d1

0801db94 <__sfputc_r>:
 801db94:	6893      	ldr	r3, [r2, #8]
 801db96:	b510      	push	{r4, lr}
 801db98:	3b01      	subs	r3, #1
 801db9a:	6093      	str	r3, [r2, #8]
 801db9c:	2b00      	cmp	r3, #0
 801db9e:	da04      	bge.n	801dbaa <__sfputc_r+0x16>
 801dba0:	6994      	ldr	r4, [r2, #24]
 801dba2:	42a3      	cmp	r3, r4
 801dba4:	db07      	blt.n	801dbb6 <__sfputc_r+0x22>
 801dba6:	290a      	cmp	r1, #10
 801dba8:	d005      	beq.n	801dbb6 <__sfputc_r+0x22>
 801dbaa:	6813      	ldr	r3, [r2, #0]
 801dbac:	1c58      	adds	r0, r3, #1
 801dbae:	6010      	str	r0, [r2, #0]
 801dbb0:	7019      	strb	r1, [r3, #0]
 801dbb2:	0008      	movs	r0, r1
 801dbb4:	bd10      	pop	{r4, pc}
 801dbb6:	f000 fb2f 	bl	801e218 <__swbuf_r>
 801dbba:	0001      	movs	r1, r0
 801dbbc:	e7f9      	b.n	801dbb2 <__sfputc_r+0x1e>

0801dbbe <__sfputs_r>:
 801dbbe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801dbc0:	0006      	movs	r6, r0
 801dbc2:	000f      	movs	r7, r1
 801dbc4:	0014      	movs	r4, r2
 801dbc6:	18d5      	adds	r5, r2, r3
 801dbc8:	42ac      	cmp	r4, r5
 801dbca:	d101      	bne.n	801dbd0 <__sfputs_r+0x12>
 801dbcc:	2000      	movs	r0, #0
 801dbce:	e007      	b.n	801dbe0 <__sfputs_r+0x22>
 801dbd0:	7821      	ldrb	r1, [r4, #0]
 801dbd2:	003a      	movs	r2, r7
 801dbd4:	0030      	movs	r0, r6
 801dbd6:	f7ff ffdd 	bl	801db94 <__sfputc_r>
 801dbda:	3401      	adds	r4, #1
 801dbdc:	1c43      	adds	r3, r0, #1
 801dbde:	d1f3      	bne.n	801dbc8 <__sfputs_r+0xa>
 801dbe0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0801dbe4 <_vfiprintf_r>:
 801dbe4:	b5f0      	push	{r4, r5, r6, r7, lr}
 801dbe6:	b0a1      	sub	sp, #132	; 0x84
 801dbe8:	0006      	movs	r6, r0
 801dbea:	000c      	movs	r4, r1
 801dbec:	001f      	movs	r7, r3
 801dbee:	9203      	str	r2, [sp, #12]
 801dbf0:	2800      	cmp	r0, #0
 801dbf2:	d004      	beq.n	801dbfe <_vfiprintf_r+0x1a>
 801dbf4:	6983      	ldr	r3, [r0, #24]
 801dbf6:	2b00      	cmp	r3, #0
 801dbf8:	d101      	bne.n	801dbfe <_vfiprintf_r+0x1a>
 801dbfa:	f7ff fd67 	bl	801d6cc <__sinit>
 801dbfe:	4b8e      	ldr	r3, [pc, #568]	; (801de38 <_vfiprintf_r+0x254>)
 801dc00:	429c      	cmp	r4, r3
 801dc02:	d11c      	bne.n	801dc3e <_vfiprintf_r+0x5a>
 801dc04:	6874      	ldr	r4, [r6, #4]
 801dc06:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801dc08:	07db      	lsls	r3, r3, #31
 801dc0a:	d405      	bmi.n	801dc18 <_vfiprintf_r+0x34>
 801dc0c:	89a3      	ldrh	r3, [r4, #12]
 801dc0e:	059b      	lsls	r3, r3, #22
 801dc10:	d402      	bmi.n	801dc18 <_vfiprintf_r+0x34>
 801dc12:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801dc14:	f7ff fdfb 	bl	801d80e <__retarget_lock_acquire_recursive>
 801dc18:	89a3      	ldrh	r3, [r4, #12]
 801dc1a:	071b      	lsls	r3, r3, #28
 801dc1c:	d502      	bpl.n	801dc24 <_vfiprintf_r+0x40>
 801dc1e:	6923      	ldr	r3, [r4, #16]
 801dc20:	2b00      	cmp	r3, #0
 801dc22:	d11d      	bne.n	801dc60 <_vfiprintf_r+0x7c>
 801dc24:	0021      	movs	r1, r4
 801dc26:	0030      	movs	r0, r6
 801dc28:	f000 fb60 	bl	801e2ec <__swsetup_r>
 801dc2c:	2800      	cmp	r0, #0
 801dc2e:	d017      	beq.n	801dc60 <_vfiprintf_r+0x7c>
 801dc30:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801dc32:	07db      	lsls	r3, r3, #31
 801dc34:	d50d      	bpl.n	801dc52 <_vfiprintf_r+0x6e>
 801dc36:	2001      	movs	r0, #1
 801dc38:	4240      	negs	r0, r0
 801dc3a:	b021      	add	sp, #132	; 0x84
 801dc3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801dc3e:	4b7f      	ldr	r3, [pc, #508]	; (801de3c <_vfiprintf_r+0x258>)
 801dc40:	429c      	cmp	r4, r3
 801dc42:	d101      	bne.n	801dc48 <_vfiprintf_r+0x64>
 801dc44:	68b4      	ldr	r4, [r6, #8]
 801dc46:	e7de      	b.n	801dc06 <_vfiprintf_r+0x22>
 801dc48:	4b7d      	ldr	r3, [pc, #500]	; (801de40 <_vfiprintf_r+0x25c>)
 801dc4a:	429c      	cmp	r4, r3
 801dc4c:	d1db      	bne.n	801dc06 <_vfiprintf_r+0x22>
 801dc4e:	68f4      	ldr	r4, [r6, #12]
 801dc50:	e7d9      	b.n	801dc06 <_vfiprintf_r+0x22>
 801dc52:	89a3      	ldrh	r3, [r4, #12]
 801dc54:	059b      	lsls	r3, r3, #22
 801dc56:	d4ee      	bmi.n	801dc36 <_vfiprintf_r+0x52>
 801dc58:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801dc5a:	f7ff fdd9 	bl	801d810 <__retarget_lock_release_recursive>
 801dc5e:	e7ea      	b.n	801dc36 <_vfiprintf_r+0x52>
 801dc60:	2300      	movs	r3, #0
 801dc62:	ad08      	add	r5, sp, #32
 801dc64:	616b      	str	r3, [r5, #20]
 801dc66:	3320      	adds	r3, #32
 801dc68:	766b      	strb	r3, [r5, #25]
 801dc6a:	3310      	adds	r3, #16
 801dc6c:	76ab      	strb	r3, [r5, #26]
 801dc6e:	9707      	str	r7, [sp, #28]
 801dc70:	9f03      	ldr	r7, [sp, #12]
 801dc72:	783b      	ldrb	r3, [r7, #0]
 801dc74:	2b00      	cmp	r3, #0
 801dc76:	d001      	beq.n	801dc7c <_vfiprintf_r+0x98>
 801dc78:	2b25      	cmp	r3, #37	; 0x25
 801dc7a:	d14e      	bne.n	801dd1a <_vfiprintf_r+0x136>
 801dc7c:	9b03      	ldr	r3, [sp, #12]
 801dc7e:	1afb      	subs	r3, r7, r3
 801dc80:	9305      	str	r3, [sp, #20]
 801dc82:	9b03      	ldr	r3, [sp, #12]
 801dc84:	429f      	cmp	r7, r3
 801dc86:	d00d      	beq.n	801dca4 <_vfiprintf_r+0xc0>
 801dc88:	9b05      	ldr	r3, [sp, #20]
 801dc8a:	0021      	movs	r1, r4
 801dc8c:	0030      	movs	r0, r6
 801dc8e:	9a03      	ldr	r2, [sp, #12]
 801dc90:	f7ff ff95 	bl	801dbbe <__sfputs_r>
 801dc94:	1c43      	adds	r3, r0, #1
 801dc96:	d100      	bne.n	801dc9a <_vfiprintf_r+0xb6>
 801dc98:	e0b5      	b.n	801de06 <_vfiprintf_r+0x222>
 801dc9a:	696a      	ldr	r2, [r5, #20]
 801dc9c:	9b05      	ldr	r3, [sp, #20]
 801dc9e:	4694      	mov	ip, r2
 801dca0:	4463      	add	r3, ip
 801dca2:	616b      	str	r3, [r5, #20]
 801dca4:	783b      	ldrb	r3, [r7, #0]
 801dca6:	2b00      	cmp	r3, #0
 801dca8:	d100      	bne.n	801dcac <_vfiprintf_r+0xc8>
 801dcaa:	e0ac      	b.n	801de06 <_vfiprintf_r+0x222>
 801dcac:	2201      	movs	r2, #1
 801dcae:	1c7b      	adds	r3, r7, #1
 801dcb0:	9303      	str	r3, [sp, #12]
 801dcb2:	2300      	movs	r3, #0
 801dcb4:	4252      	negs	r2, r2
 801dcb6:	606a      	str	r2, [r5, #4]
 801dcb8:	a904      	add	r1, sp, #16
 801dcba:	3254      	adds	r2, #84	; 0x54
 801dcbc:	1852      	adds	r2, r2, r1
 801dcbe:	602b      	str	r3, [r5, #0]
 801dcc0:	60eb      	str	r3, [r5, #12]
 801dcc2:	60ab      	str	r3, [r5, #8]
 801dcc4:	7013      	strb	r3, [r2, #0]
 801dcc6:	65ab      	str	r3, [r5, #88]	; 0x58
 801dcc8:	9b03      	ldr	r3, [sp, #12]
 801dcca:	2205      	movs	r2, #5
 801dccc:	7819      	ldrb	r1, [r3, #0]
 801dcce:	485d      	ldr	r0, [pc, #372]	; (801de44 <_vfiprintf_r+0x260>)
 801dcd0:	f000 fce2 	bl	801e698 <memchr>
 801dcd4:	9b03      	ldr	r3, [sp, #12]
 801dcd6:	1c5f      	adds	r7, r3, #1
 801dcd8:	2800      	cmp	r0, #0
 801dcda:	d120      	bne.n	801dd1e <_vfiprintf_r+0x13a>
 801dcdc:	682a      	ldr	r2, [r5, #0]
 801dcde:	06d3      	lsls	r3, r2, #27
 801dce0:	d504      	bpl.n	801dcec <_vfiprintf_r+0x108>
 801dce2:	2353      	movs	r3, #83	; 0x53
 801dce4:	a904      	add	r1, sp, #16
 801dce6:	185b      	adds	r3, r3, r1
 801dce8:	2120      	movs	r1, #32
 801dcea:	7019      	strb	r1, [r3, #0]
 801dcec:	0713      	lsls	r3, r2, #28
 801dcee:	d504      	bpl.n	801dcfa <_vfiprintf_r+0x116>
 801dcf0:	2353      	movs	r3, #83	; 0x53
 801dcf2:	a904      	add	r1, sp, #16
 801dcf4:	185b      	adds	r3, r3, r1
 801dcf6:	212b      	movs	r1, #43	; 0x2b
 801dcf8:	7019      	strb	r1, [r3, #0]
 801dcfa:	9b03      	ldr	r3, [sp, #12]
 801dcfc:	781b      	ldrb	r3, [r3, #0]
 801dcfe:	2b2a      	cmp	r3, #42	; 0x2a
 801dd00:	d016      	beq.n	801dd30 <_vfiprintf_r+0x14c>
 801dd02:	2100      	movs	r1, #0
 801dd04:	68eb      	ldr	r3, [r5, #12]
 801dd06:	9f03      	ldr	r7, [sp, #12]
 801dd08:	783a      	ldrb	r2, [r7, #0]
 801dd0a:	1c78      	adds	r0, r7, #1
 801dd0c:	3a30      	subs	r2, #48	; 0x30
 801dd0e:	4684      	mov	ip, r0
 801dd10:	2a09      	cmp	r2, #9
 801dd12:	d94f      	bls.n	801ddb4 <_vfiprintf_r+0x1d0>
 801dd14:	2900      	cmp	r1, #0
 801dd16:	d111      	bne.n	801dd3c <_vfiprintf_r+0x158>
 801dd18:	e017      	b.n	801dd4a <_vfiprintf_r+0x166>
 801dd1a:	3701      	adds	r7, #1
 801dd1c:	e7a9      	b.n	801dc72 <_vfiprintf_r+0x8e>
 801dd1e:	4b49      	ldr	r3, [pc, #292]	; (801de44 <_vfiprintf_r+0x260>)
 801dd20:	682a      	ldr	r2, [r5, #0]
 801dd22:	1ac0      	subs	r0, r0, r3
 801dd24:	2301      	movs	r3, #1
 801dd26:	4083      	lsls	r3, r0
 801dd28:	4313      	orrs	r3, r2
 801dd2a:	602b      	str	r3, [r5, #0]
 801dd2c:	9703      	str	r7, [sp, #12]
 801dd2e:	e7cb      	b.n	801dcc8 <_vfiprintf_r+0xe4>
 801dd30:	9b07      	ldr	r3, [sp, #28]
 801dd32:	1d19      	adds	r1, r3, #4
 801dd34:	681b      	ldr	r3, [r3, #0]
 801dd36:	9107      	str	r1, [sp, #28]
 801dd38:	2b00      	cmp	r3, #0
 801dd3a:	db01      	blt.n	801dd40 <_vfiprintf_r+0x15c>
 801dd3c:	930b      	str	r3, [sp, #44]	; 0x2c
 801dd3e:	e004      	b.n	801dd4a <_vfiprintf_r+0x166>
 801dd40:	425b      	negs	r3, r3
 801dd42:	60eb      	str	r3, [r5, #12]
 801dd44:	2302      	movs	r3, #2
 801dd46:	4313      	orrs	r3, r2
 801dd48:	602b      	str	r3, [r5, #0]
 801dd4a:	783b      	ldrb	r3, [r7, #0]
 801dd4c:	2b2e      	cmp	r3, #46	; 0x2e
 801dd4e:	d10a      	bne.n	801dd66 <_vfiprintf_r+0x182>
 801dd50:	787b      	ldrb	r3, [r7, #1]
 801dd52:	2b2a      	cmp	r3, #42	; 0x2a
 801dd54:	d137      	bne.n	801ddc6 <_vfiprintf_r+0x1e2>
 801dd56:	9b07      	ldr	r3, [sp, #28]
 801dd58:	3702      	adds	r7, #2
 801dd5a:	1d1a      	adds	r2, r3, #4
 801dd5c:	681b      	ldr	r3, [r3, #0]
 801dd5e:	9207      	str	r2, [sp, #28]
 801dd60:	2b00      	cmp	r3, #0
 801dd62:	db2d      	blt.n	801ddc0 <_vfiprintf_r+0x1dc>
 801dd64:	9309      	str	r3, [sp, #36]	; 0x24
 801dd66:	2203      	movs	r2, #3
 801dd68:	7839      	ldrb	r1, [r7, #0]
 801dd6a:	4837      	ldr	r0, [pc, #220]	; (801de48 <_vfiprintf_r+0x264>)
 801dd6c:	f000 fc94 	bl	801e698 <memchr>
 801dd70:	2800      	cmp	r0, #0
 801dd72:	d007      	beq.n	801dd84 <_vfiprintf_r+0x1a0>
 801dd74:	4b34      	ldr	r3, [pc, #208]	; (801de48 <_vfiprintf_r+0x264>)
 801dd76:	682a      	ldr	r2, [r5, #0]
 801dd78:	1ac0      	subs	r0, r0, r3
 801dd7a:	2340      	movs	r3, #64	; 0x40
 801dd7c:	4083      	lsls	r3, r0
 801dd7e:	4313      	orrs	r3, r2
 801dd80:	3701      	adds	r7, #1
 801dd82:	602b      	str	r3, [r5, #0]
 801dd84:	7839      	ldrb	r1, [r7, #0]
 801dd86:	1c7b      	adds	r3, r7, #1
 801dd88:	2206      	movs	r2, #6
 801dd8a:	4830      	ldr	r0, [pc, #192]	; (801de4c <_vfiprintf_r+0x268>)
 801dd8c:	9303      	str	r3, [sp, #12]
 801dd8e:	7629      	strb	r1, [r5, #24]
 801dd90:	f000 fc82 	bl	801e698 <memchr>
 801dd94:	2800      	cmp	r0, #0
 801dd96:	d045      	beq.n	801de24 <_vfiprintf_r+0x240>
 801dd98:	4b2d      	ldr	r3, [pc, #180]	; (801de50 <_vfiprintf_r+0x26c>)
 801dd9a:	2b00      	cmp	r3, #0
 801dd9c:	d127      	bne.n	801ddee <_vfiprintf_r+0x20a>
 801dd9e:	2207      	movs	r2, #7
 801dda0:	9b07      	ldr	r3, [sp, #28]
 801dda2:	3307      	adds	r3, #7
 801dda4:	4393      	bics	r3, r2
 801dda6:	3308      	adds	r3, #8
 801dda8:	9307      	str	r3, [sp, #28]
 801ddaa:	696b      	ldr	r3, [r5, #20]
 801ddac:	9a04      	ldr	r2, [sp, #16]
 801ddae:	189b      	adds	r3, r3, r2
 801ddb0:	616b      	str	r3, [r5, #20]
 801ddb2:	e75d      	b.n	801dc70 <_vfiprintf_r+0x8c>
 801ddb4:	210a      	movs	r1, #10
 801ddb6:	434b      	muls	r3, r1
 801ddb8:	4667      	mov	r7, ip
 801ddba:	189b      	adds	r3, r3, r2
 801ddbc:	3909      	subs	r1, #9
 801ddbe:	e7a3      	b.n	801dd08 <_vfiprintf_r+0x124>
 801ddc0:	2301      	movs	r3, #1
 801ddc2:	425b      	negs	r3, r3
 801ddc4:	e7ce      	b.n	801dd64 <_vfiprintf_r+0x180>
 801ddc6:	2300      	movs	r3, #0
 801ddc8:	001a      	movs	r2, r3
 801ddca:	3701      	adds	r7, #1
 801ddcc:	606b      	str	r3, [r5, #4]
 801ddce:	7839      	ldrb	r1, [r7, #0]
 801ddd0:	1c78      	adds	r0, r7, #1
 801ddd2:	3930      	subs	r1, #48	; 0x30
 801ddd4:	4684      	mov	ip, r0
 801ddd6:	2909      	cmp	r1, #9
 801ddd8:	d903      	bls.n	801dde2 <_vfiprintf_r+0x1fe>
 801ddda:	2b00      	cmp	r3, #0
 801dddc:	d0c3      	beq.n	801dd66 <_vfiprintf_r+0x182>
 801ddde:	9209      	str	r2, [sp, #36]	; 0x24
 801dde0:	e7c1      	b.n	801dd66 <_vfiprintf_r+0x182>
 801dde2:	230a      	movs	r3, #10
 801dde4:	435a      	muls	r2, r3
 801dde6:	4667      	mov	r7, ip
 801dde8:	1852      	adds	r2, r2, r1
 801ddea:	3b09      	subs	r3, #9
 801ddec:	e7ef      	b.n	801ddce <_vfiprintf_r+0x1ea>
 801ddee:	ab07      	add	r3, sp, #28
 801ddf0:	9300      	str	r3, [sp, #0]
 801ddf2:	0022      	movs	r2, r4
 801ddf4:	0029      	movs	r1, r5
 801ddf6:	0030      	movs	r0, r6
 801ddf8:	4b16      	ldr	r3, [pc, #88]	; (801de54 <_vfiprintf_r+0x270>)
 801ddfa:	e000      	b.n	801ddfe <_vfiprintf_r+0x21a>
 801ddfc:	bf00      	nop
 801ddfe:	9004      	str	r0, [sp, #16]
 801de00:	9b04      	ldr	r3, [sp, #16]
 801de02:	3301      	adds	r3, #1
 801de04:	d1d1      	bne.n	801ddaa <_vfiprintf_r+0x1c6>
 801de06:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801de08:	07db      	lsls	r3, r3, #31
 801de0a:	d405      	bmi.n	801de18 <_vfiprintf_r+0x234>
 801de0c:	89a3      	ldrh	r3, [r4, #12]
 801de0e:	059b      	lsls	r3, r3, #22
 801de10:	d402      	bmi.n	801de18 <_vfiprintf_r+0x234>
 801de12:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801de14:	f7ff fcfc 	bl	801d810 <__retarget_lock_release_recursive>
 801de18:	89a3      	ldrh	r3, [r4, #12]
 801de1a:	065b      	lsls	r3, r3, #25
 801de1c:	d500      	bpl.n	801de20 <_vfiprintf_r+0x23c>
 801de1e:	e70a      	b.n	801dc36 <_vfiprintf_r+0x52>
 801de20:	980d      	ldr	r0, [sp, #52]	; 0x34
 801de22:	e70a      	b.n	801dc3a <_vfiprintf_r+0x56>
 801de24:	ab07      	add	r3, sp, #28
 801de26:	9300      	str	r3, [sp, #0]
 801de28:	0022      	movs	r2, r4
 801de2a:	0029      	movs	r1, r5
 801de2c:	0030      	movs	r0, r6
 801de2e:	4b09      	ldr	r3, [pc, #36]	; (801de54 <_vfiprintf_r+0x270>)
 801de30:	f000 f882 	bl	801df38 <_printf_i>
 801de34:	e7e3      	b.n	801ddfe <_vfiprintf_r+0x21a>
 801de36:	46c0      	nop			; (mov r8, r8)
 801de38:	0801fe58 	.word	0x0801fe58
 801de3c:	0801fe78 	.word	0x0801fe78
 801de40:	0801fe38 	.word	0x0801fe38
 801de44:	0801fe98 	.word	0x0801fe98
 801de48:	0801fe9e 	.word	0x0801fe9e
 801de4c:	0801fea2 	.word	0x0801fea2
 801de50:	00000000 	.word	0x00000000
 801de54:	0801dbbf 	.word	0x0801dbbf

0801de58 <_printf_common>:
 801de58:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801de5a:	0015      	movs	r5, r2
 801de5c:	9301      	str	r3, [sp, #4]
 801de5e:	688a      	ldr	r2, [r1, #8]
 801de60:	690b      	ldr	r3, [r1, #16]
 801de62:	000c      	movs	r4, r1
 801de64:	9000      	str	r0, [sp, #0]
 801de66:	4293      	cmp	r3, r2
 801de68:	da00      	bge.n	801de6c <_printf_common+0x14>
 801de6a:	0013      	movs	r3, r2
 801de6c:	0022      	movs	r2, r4
 801de6e:	602b      	str	r3, [r5, #0]
 801de70:	3243      	adds	r2, #67	; 0x43
 801de72:	7812      	ldrb	r2, [r2, #0]
 801de74:	2a00      	cmp	r2, #0
 801de76:	d001      	beq.n	801de7c <_printf_common+0x24>
 801de78:	3301      	adds	r3, #1
 801de7a:	602b      	str	r3, [r5, #0]
 801de7c:	6823      	ldr	r3, [r4, #0]
 801de7e:	069b      	lsls	r3, r3, #26
 801de80:	d502      	bpl.n	801de88 <_printf_common+0x30>
 801de82:	682b      	ldr	r3, [r5, #0]
 801de84:	3302      	adds	r3, #2
 801de86:	602b      	str	r3, [r5, #0]
 801de88:	6822      	ldr	r2, [r4, #0]
 801de8a:	2306      	movs	r3, #6
 801de8c:	0017      	movs	r7, r2
 801de8e:	401f      	ands	r7, r3
 801de90:	421a      	tst	r2, r3
 801de92:	d027      	beq.n	801dee4 <_printf_common+0x8c>
 801de94:	0023      	movs	r3, r4
 801de96:	3343      	adds	r3, #67	; 0x43
 801de98:	781b      	ldrb	r3, [r3, #0]
 801de9a:	1e5a      	subs	r2, r3, #1
 801de9c:	4193      	sbcs	r3, r2
 801de9e:	6822      	ldr	r2, [r4, #0]
 801dea0:	0692      	lsls	r2, r2, #26
 801dea2:	d430      	bmi.n	801df06 <_printf_common+0xae>
 801dea4:	0022      	movs	r2, r4
 801dea6:	9901      	ldr	r1, [sp, #4]
 801dea8:	9800      	ldr	r0, [sp, #0]
 801deaa:	9e08      	ldr	r6, [sp, #32]
 801deac:	3243      	adds	r2, #67	; 0x43
 801deae:	47b0      	blx	r6
 801deb0:	1c43      	adds	r3, r0, #1
 801deb2:	d025      	beq.n	801df00 <_printf_common+0xa8>
 801deb4:	2306      	movs	r3, #6
 801deb6:	6820      	ldr	r0, [r4, #0]
 801deb8:	682a      	ldr	r2, [r5, #0]
 801deba:	68e1      	ldr	r1, [r4, #12]
 801debc:	2500      	movs	r5, #0
 801debe:	4003      	ands	r3, r0
 801dec0:	2b04      	cmp	r3, #4
 801dec2:	d103      	bne.n	801decc <_printf_common+0x74>
 801dec4:	1a8d      	subs	r5, r1, r2
 801dec6:	43eb      	mvns	r3, r5
 801dec8:	17db      	asrs	r3, r3, #31
 801deca:	401d      	ands	r5, r3
 801decc:	68a3      	ldr	r3, [r4, #8]
 801dece:	6922      	ldr	r2, [r4, #16]
 801ded0:	4293      	cmp	r3, r2
 801ded2:	dd01      	ble.n	801ded8 <_printf_common+0x80>
 801ded4:	1a9b      	subs	r3, r3, r2
 801ded6:	18ed      	adds	r5, r5, r3
 801ded8:	2700      	movs	r7, #0
 801deda:	42bd      	cmp	r5, r7
 801dedc:	d120      	bne.n	801df20 <_printf_common+0xc8>
 801dede:	2000      	movs	r0, #0
 801dee0:	e010      	b.n	801df04 <_printf_common+0xac>
 801dee2:	3701      	adds	r7, #1
 801dee4:	68e3      	ldr	r3, [r4, #12]
 801dee6:	682a      	ldr	r2, [r5, #0]
 801dee8:	1a9b      	subs	r3, r3, r2
 801deea:	42bb      	cmp	r3, r7
 801deec:	ddd2      	ble.n	801de94 <_printf_common+0x3c>
 801deee:	0022      	movs	r2, r4
 801def0:	2301      	movs	r3, #1
 801def2:	9901      	ldr	r1, [sp, #4]
 801def4:	9800      	ldr	r0, [sp, #0]
 801def6:	9e08      	ldr	r6, [sp, #32]
 801def8:	3219      	adds	r2, #25
 801defa:	47b0      	blx	r6
 801defc:	1c43      	adds	r3, r0, #1
 801defe:	d1f0      	bne.n	801dee2 <_printf_common+0x8a>
 801df00:	2001      	movs	r0, #1
 801df02:	4240      	negs	r0, r0
 801df04:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 801df06:	2030      	movs	r0, #48	; 0x30
 801df08:	18e1      	adds	r1, r4, r3
 801df0a:	3143      	adds	r1, #67	; 0x43
 801df0c:	7008      	strb	r0, [r1, #0]
 801df0e:	0021      	movs	r1, r4
 801df10:	1c5a      	adds	r2, r3, #1
 801df12:	3145      	adds	r1, #69	; 0x45
 801df14:	7809      	ldrb	r1, [r1, #0]
 801df16:	18a2      	adds	r2, r4, r2
 801df18:	3243      	adds	r2, #67	; 0x43
 801df1a:	3302      	adds	r3, #2
 801df1c:	7011      	strb	r1, [r2, #0]
 801df1e:	e7c1      	b.n	801dea4 <_printf_common+0x4c>
 801df20:	0022      	movs	r2, r4
 801df22:	2301      	movs	r3, #1
 801df24:	9901      	ldr	r1, [sp, #4]
 801df26:	9800      	ldr	r0, [sp, #0]
 801df28:	9e08      	ldr	r6, [sp, #32]
 801df2a:	321a      	adds	r2, #26
 801df2c:	47b0      	blx	r6
 801df2e:	1c43      	adds	r3, r0, #1
 801df30:	d0e6      	beq.n	801df00 <_printf_common+0xa8>
 801df32:	3701      	adds	r7, #1
 801df34:	e7d1      	b.n	801deda <_printf_common+0x82>
	...

0801df38 <_printf_i>:
 801df38:	b5f0      	push	{r4, r5, r6, r7, lr}
 801df3a:	b08b      	sub	sp, #44	; 0x2c
 801df3c:	9206      	str	r2, [sp, #24]
 801df3e:	000a      	movs	r2, r1
 801df40:	3243      	adds	r2, #67	; 0x43
 801df42:	9307      	str	r3, [sp, #28]
 801df44:	9005      	str	r0, [sp, #20]
 801df46:	9204      	str	r2, [sp, #16]
 801df48:	7e0a      	ldrb	r2, [r1, #24]
 801df4a:	000c      	movs	r4, r1
 801df4c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801df4e:	2a78      	cmp	r2, #120	; 0x78
 801df50:	d806      	bhi.n	801df60 <_printf_i+0x28>
 801df52:	2a62      	cmp	r2, #98	; 0x62
 801df54:	d808      	bhi.n	801df68 <_printf_i+0x30>
 801df56:	2a00      	cmp	r2, #0
 801df58:	d100      	bne.n	801df5c <_printf_i+0x24>
 801df5a:	e0c0      	b.n	801e0de <_printf_i+0x1a6>
 801df5c:	2a58      	cmp	r2, #88	; 0x58
 801df5e:	d052      	beq.n	801e006 <_printf_i+0xce>
 801df60:	0026      	movs	r6, r4
 801df62:	3642      	adds	r6, #66	; 0x42
 801df64:	7032      	strb	r2, [r6, #0]
 801df66:	e022      	b.n	801dfae <_printf_i+0x76>
 801df68:	0010      	movs	r0, r2
 801df6a:	3863      	subs	r0, #99	; 0x63
 801df6c:	2815      	cmp	r0, #21
 801df6e:	d8f7      	bhi.n	801df60 <_printf_i+0x28>
 801df70:	f7e2 f8ca 	bl	8000108 <__gnu_thumb1_case_shi>
 801df74:	001f0016 	.word	0x001f0016
 801df78:	fff6fff6 	.word	0xfff6fff6
 801df7c:	fff6fff6 	.word	0xfff6fff6
 801df80:	fff6001f 	.word	0xfff6001f
 801df84:	fff6fff6 	.word	0xfff6fff6
 801df88:	00a8fff6 	.word	0x00a8fff6
 801df8c:	009a0036 	.word	0x009a0036
 801df90:	fff6fff6 	.word	0xfff6fff6
 801df94:	fff600b9 	.word	0xfff600b9
 801df98:	fff60036 	.word	0xfff60036
 801df9c:	009efff6 	.word	0x009efff6
 801dfa0:	0026      	movs	r6, r4
 801dfa2:	681a      	ldr	r2, [r3, #0]
 801dfa4:	3642      	adds	r6, #66	; 0x42
 801dfa6:	1d11      	adds	r1, r2, #4
 801dfa8:	6019      	str	r1, [r3, #0]
 801dfaa:	6813      	ldr	r3, [r2, #0]
 801dfac:	7033      	strb	r3, [r6, #0]
 801dfae:	2301      	movs	r3, #1
 801dfb0:	e0a7      	b.n	801e102 <_printf_i+0x1ca>
 801dfb2:	6808      	ldr	r0, [r1, #0]
 801dfb4:	6819      	ldr	r1, [r3, #0]
 801dfb6:	1d0a      	adds	r2, r1, #4
 801dfb8:	0605      	lsls	r5, r0, #24
 801dfba:	d50b      	bpl.n	801dfd4 <_printf_i+0x9c>
 801dfbc:	680d      	ldr	r5, [r1, #0]
 801dfbe:	601a      	str	r2, [r3, #0]
 801dfc0:	2d00      	cmp	r5, #0
 801dfc2:	da03      	bge.n	801dfcc <_printf_i+0x94>
 801dfc4:	232d      	movs	r3, #45	; 0x2d
 801dfc6:	9a04      	ldr	r2, [sp, #16]
 801dfc8:	426d      	negs	r5, r5
 801dfca:	7013      	strb	r3, [r2, #0]
 801dfcc:	4b61      	ldr	r3, [pc, #388]	; (801e154 <_printf_i+0x21c>)
 801dfce:	270a      	movs	r7, #10
 801dfd0:	9303      	str	r3, [sp, #12]
 801dfd2:	e032      	b.n	801e03a <_printf_i+0x102>
 801dfd4:	680d      	ldr	r5, [r1, #0]
 801dfd6:	601a      	str	r2, [r3, #0]
 801dfd8:	0641      	lsls	r1, r0, #25
 801dfda:	d5f1      	bpl.n	801dfc0 <_printf_i+0x88>
 801dfdc:	b22d      	sxth	r5, r5
 801dfde:	e7ef      	b.n	801dfc0 <_printf_i+0x88>
 801dfe0:	680d      	ldr	r5, [r1, #0]
 801dfe2:	6819      	ldr	r1, [r3, #0]
 801dfe4:	1d08      	adds	r0, r1, #4
 801dfe6:	6018      	str	r0, [r3, #0]
 801dfe8:	062e      	lsls	r6, r5, #24
 801dfea:	d501      	bpl.n	801dff0 <_printf_i+0xb8>
 801dfec:	680d      	ldr	r5, [r1, #0]
 801dfee:	e003      	b.n	801dff8 <_printf_i+0xc0>
 801dff0:	066d      	lsls	r5, r5, #25
 801dff2:	d5fb      	bpl.n	801dfec <_printf_i+0xb4>
 801dff4:	680d      	ldr	r5, [r1, #0]
 801dff6:	b2ad      	uxth	r5, r5
 801dff8:	4b56      	ldr	r3, [pc, #344]	; (801e154 <_printf_i+0x21c>)
 801dffa:	270a      	movs	r7, #10
 801dffc:	9303      	str	r3, [sp, #12]
 801dffe:	2a6f      	cmp	r2, #111	; 0x6f
 801e000:	d117      	bne.n	801e032 <_printf_i+0xfa>
 801e002:	2708      	movs	r7, #8
 801e004:	e015      	b.n	801e032 <_printf_i+0xfa>
 801e006:	3145      	adds	r1, #69	; 0x45
 801e008:	700a      	strb	r2, [r1, #0]
 801e00a:	4a52      	ldr	r2, [pc, #328]	; (801e154 <_printf_i+0x21c>)
 801e00c:	9203      	str	r2, [sp, #12]
 801e00e:	681a      	ldr	r2, [r3, #0]
 801e010:	6821      	ldr	r1, [r4, #0]
 801e012:	ca20      	ldmia	r2!, {r5}
 801e014:	601a      	str	r2, [r3, #0]
 801e016:	0608      	lsls	r0, r1, #24
 801e018:	d550      	bpl.n	801e0bc <_printf_i+0x184>
 801e01a:	07cb      	lsls	r3, r1, #31
 801e01c:	d502      	bpl.n	801e024 <_printf_i+0xec>
 801e01e:	2320      	movs	r3, #32
 801e020:	4319      	orrs	r1, r3
 801e022:	6021      	str	r1, [r4, #0]
 801e024:	2710      	movs	r7, #16
 801e026:	2d00      	cmp	r5, #0
 801e028:	d103      	bne.n	801e032 <_printf_i+0xfa>
 801e02a:	2320      	movs	r3, #32
 801e02c:	6822      	ldr	r2, [r4, #0]
 801e02e:	439a      	bics	r2, r3
 801e030:	6022      	str	r2, [r4, #0]
 801e032:	0023      	movs	r3, r4
 801e034:	2200      	movs	r2, #0
 801e036:	3343      	adds	r3, #67	; 0x43
 801e038:	701a      	strb	r2, [r3, #0]
 801e03a:	6863      	ldr	r3, [r4, #4]
 801e03c:	60a3      	str	r3, [r4, #8]
 801e03e:	2b00      	cmp	r3, #0
 801e040:	db03      	blt.n	801e04a <_printf_i+0x112>
 801e042:	2204      	movs	r2, #4
 801e044:	6821      	ldr	r1, [r4, #0]
 801e046:	4391      	bics	r1, r2
 801e048:	6021      	str	r1, [r4, #0]
 801e04a:	2d00      	cmp	r5, #0
 801e04c:	d102      	bne.n	801e054 <_printf_i+0x11c>
 801e04e:	9e04      	ldr	r6, [sp, #16]
 801e050:	2b00      	cmp	r3, #0
 801e052:	d00c      	beq.n	801e06e <_printf_i+0x136>
 801e054:	9e04      	ldr	r6, [sp, #16]
 801e056:	0028      	movs	r0, r5
 801e058:	0039      	movs	r1, r7
 801e05a:	f7e2 f8e5 	bl	8000228 <__aeabi_uidivmod>
 801e05e:	9b03      	ldr	r3, [sp, #12]
 801e060:	3e01      	subs	r6, #1
 801e062:	5c5b      	ldrb	r3, [r3, r1]
 801e064:	7033      	strb	r3, [r6, #0]
 801e066:	002b      	movs	r3, r5
 801e068:	0005      	movs	r5, r0
 801e06a:	429f      	cmp	r7, r3
 801e06c:	d9f3      	bls.n	801e056 <_printf_i+0x11e>
 801e06e:	2f08      	cmp	r7, #8
 801e070:	d109      	bne.n	801e086 <_printf_i+0x14e>
 801e072:	6823      	ldr	r3, [r4, #0]
 801e074:	07db      	lsls	r3, r3, #31
 801e076:	d506      	bpl.n	801e086 <_printf_i+0x14e>
 801e078:	6863      	ldr	r3, [r4, #4]
 801e07a:	6922      	ldr	r2, [r4, #16]
 801e07c:	4293      	cmp	r3, r2
 801e07e:	dc02      	bgt.n	801e086 <_printf_i+0x14e>
 801e080:	2330      	movs	r3, #48	; 0x30
 801e082:	3e01      	subs	r6, #1
 801e084:	7033      	strb	r3, [r6, #0]
 801e086:	9b04      	ldr	r3, [sp, #16]
 801e088:	1b9b      	subs	r3, r3, r6
 801e08a:	6123      	str	r3, [r4, #16]
 801e08c:	9b07      	ldr	r3, [sp, #28]
 801e08e:	0021      	movs	r1, r4
 801e090:	9300      	str	r3, [sp, #0]
 801e092:	9805      	ldr	r0, [sp, #20]
 801e094:	9b06      	ldr	r3, [sp, #24]
 801e096:	aa09      	add	r2, sp, #36	; 0x24
 801e098:	f7ff fede 	bl	801de58 <_printf_common>
 801e09c:	1c43      	adds	r3, r0, #1
 801e09e:	d135      	bne.n	801e10c <_printf_i+0x1d4>
 801e0a0:	2001      	movs	r0, #1
 801e0a2:	4240      	negs	r0, r0
 801e0a4:	b00b      	add	sp, #44	; 0x2c
 801e0a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e0a8:	2220      	movs	r2, #32
 801e0aa:	6809      	ldr	r1, [r1, #0]
 801e0ac:	430a      	orrs	r2, r1
 801e0ae:	6022      	str	r2, [r4, #0]
 801e0b0:	0022      	movs	r2, r4
 801e0b2:	2178      	movs	r1, #120	; 0x78
 801e0b4:	3245      	adds	r2, #69	; 0x45
 801e0b6:	7011      	strb	r1, [r2, #0]
 801e0b8:	4a27      	ldr	r2, [pc, #156]	; (801e158 <_printf_i+0x220>)
 801e0ba:	e7a7      	b.n	801e00c <_printf_i+0xd4>
 801e0bc:	0648      	lsls	r0, r1, #25
 801e0be:	d5ac      	bpl.n	801e01a <_printf_i+0xe2>
 801e0c0:	b2ad      	uxth	r5, r5
 801e0c2:	e7aa      	b.n	801e01a <_printf_i+0xe2>
 801e0c4:	681a      	ldr	r2, [r3, #0]
 801e0c6:	680d      	ldr	r5, [r1, #0]
 801e0c8:	1d10      	adds	r0, r2, #4
 801e0ca:	6949      	ldr	r1, [r1, #20]
 801e0cc:	6018      	str	r0, [r3, #0]
 801e0ce:	6813      	ldr	r3, [r2, #0]
 801e0d0:	062e      	lsls	r6, r5, #24
 801e0d2:	d501      	bpl.n	801e0d8 <_printf_i+0x1a0>
 801e0d4:	6019      	str	r1, [r3, #0]
 801e0d6:	e002      	b.n	801e0de <_printf_i+0x1a6>
 801e0d8:	066d      	lsls	r5, r5, #25
 801e0da:	d5fb      	bpl.n	801e0d4 <_printf_i+0x19c>
 801e0dc:	8019      	strh	r1, [r3, #0]
 801e0de:	2300      	movs	r3, #0
 801e0e0:	9e04      	ldr	r6, [sp, #16]
 801e0e2:	6123      	str	r3, [r4, #16]
 801e0e4:	e7d2      	b.n	801e08c <_printf_i+0x154>
 801e0e6:	681a      	ldr	r2, [r3, #0]
 801e0e8:	1d11      	adds	r1, r2, #4
 801e0ea:	6019      	str	r1, [r3, #0]
 801e0ec:	6816      	ldr	r6, [r2, #0]
 801e0ee:	2100      	movs	r1, #0
 801e0f0:	0030      	movs	r0, r6
 801e0f2:	6862      	ldr	r2, [r4, #4]
 801e0f4:	f000 fad0 	bl	801e698 <memchr>
 801e0f8:	2800      	cmp	r0, #0
 801e0fa:	d001      	beq.n	801e100 <_printf_i+0x1c8>
 801e0fc:	1b80      	subs	r0, r0, r6
 801e0fe:	6060      	str	r0, [r4, #4]
 801e100:	6863      	ldr	r3, [r4, #4]
 801e102:	6123      	str	r3, [r4, #16]
 801e104:	2300      	movs	r3, #0
 801e106:	9a04      	ldr	r2, [sp, #16]
 801e108:	7013      	strb	r3, [r2, #0]
 801e10a:	e7bf      	b.n	801e08c <_printf_i+0x154>
 801e10c:	6923      	ldr	r3, [r4, #16]
 801e10e:	0032      	movs	r2, r6
 801e110:	9906      	ldr	r1, [sp, #24]
 801e112:	9805      	ldr	r0, [sp, #20]
 801e114:	9d07      	ldr	r5, [sp, #28]
 801e116:	47a8      	blx	r5
 801e118:	1c43      	adds	r3, r0, #1
 801e11a:	d0c1      	beq.n	801e0a0 <_printf_i+0x168>
 801e11c:	6823      	ldr	r3, [r4, #0]
 801e11e:	079b      	lsls	r3, r3, #30
 801e120:	d415      	bmi.n	801e14e <_printf_i+0x216>
 801e122:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801e124:	68e0      	ldr	r0, [r4, #12]
 801e126:	4298      	cmp	r0, r3
 801e128:	dabc      	bge.n	801e0a4 <_printf_i+0x16c>
 801e12a:	0018      	movs	r0, r3
 801e12c:	e7ba      	b.n	801e0a4 <_printf_i+0x16c>
 801e12e:	0022      	movs	r2, r4
 801e130:	2301      	movs	r3, #1
 801e132:	9906      	ldr	r1, [sp, #24]
 801e134:	9805      	ldr	r0, [sp, #20]
 801e136:	9e07      	ldr	r6, [sp, #28]
 801e138:	3219      	adds	r2, #25
 801e13a:	47b0      	blx	r6
 801e13c:	1c43      	adds	r3, r0, #1
 801e13e:	d0af      	beq.n	801e0a0 <_printf_i+0x168>
 801e140:	3501      	adds	r5, #1
 801e142:	68e3      	ldr	r3, [r4, #12]
 801e144:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801e146:	1a9b      	subs	r3, r3, r2
 801e148:	42ab      	cmp	r3, r5
 801e14a:	dcf0      	bgt.n	801e12e <_printf_i+0x1f6>
 801e14c:	e7e9      	b.n	801e122 <_printf_i+0x1ea>
 801e14e:	2500      	movs	r5, #0
 801e150:	e7f7      	b.n	801e142 <_printf_i+0x20a>
 801e152:	46c0      	nop			; (mov r8, r8)
 801e154:	0801fea9 	.word	0x0801fea9
 801e158:	0801feba 	.word	0x0801feba

0801e15c <_sbrk_r>:
 801e15c:	2300      	movs	r3, #0
 801e15e:	b570      	push	{r4, r5, r6, lr}
 801e160:	4d06      	ldr	r5, [pc, #24]	; (801e17c <_sbrk_r+0x20>)
 801e162:	0004      	movs	r4, r0
 801e164:	0008      	movs	r0, r1
 801e166:	602b      	str	r3, [r5, #0]
 801e168:	f000 fd08 	bl	801eb7c <_sbrk>
 801e16c:	1c43      	adds	r3, r0, #1
 801e16e:	d103      	bne.n	801e178 <_sbrk_r+0x1c>
 801e170:	682b      	ldr	r3, [r5, #0]
 801e172:	2b00      	cmp	r3, #0
 801e174:	d000      	beq.n	801e178 <_sbrk_r+0x1c>
 801e176:	6023      	str	r3, [r4, #0]
 801e178:	bd70      	pop	{r4, r5, r6, pc}
 801e17a:	46c0      	nop			; (mov r8, r8)
 801e17c:	20001838 	.word	0x20001838

0801e180 <__sread>:
 801e180:	b570      	push	{r4, r5, r6, lr}
 801e182:	000c      	movs	r4, r1
 801e184:	250e      	movs	r5, #14
 801e186:	5f49      	ldrsh	r1, [r1, r5]
 801e188:	f000 fb2e 	bl	801e7e8 <_read_r>
 801e18c:	2800      	cmp	r0, #0
 801e18e:	db03      	blt.n	801e198 <__sread+0x18>
 801e190:	6d63      	ldr	r3, [r4, #84]	; 0x54
 801e192:	181b      	adds	r3, r3, r0
 801e194:	6563      	str	r3, [r4, #84]	; 0x54
 801e196:	bd70      	pop	{r4, r5, r6, pc}
 801e198:	89a3      	ldrh	r3, [r4, #12]
 801e19a:	4a02      	ldr	r2, [pc, #8]	; (801e1a4 <__sread+0x24>)
 801e19c:	4013      	ands	r3, r2
 801e19e:	81a3      	strh	r3, [r4, #12]
 801e1a0:	e7f9      	b.n	801e196 <__sread+0x16>
 801e1a2:	46c0      	nop			; (mov r8, r8)
 801e1a4:	ffffefff 	.word	0xffffefff

0801e1a8 <__swrite>:
 801e1a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e1aa:	001f      	movs	r7, r3
 801e1ac:	898b      	ldrh	r3, [r1, #12]
 801e1ae:	0005      	movs	r5, r0
 801e1b0:	000c      	movs	r4, r1
 801e1b2:	0016      	movs	r6, r2
 801e1b4:	05db      	lsls	r3, r3, #23
 801e1b6:	d505      	bpl.n	801e1c4 <__swrite+0x1c>
 801e1b8:	230e      	movs	r3, #14
 801e1ba:	5ec9      	ldrsh	r1, [r1, r3]
 801e1bc:	2200      	movs	r2, #0
 801e1be:	2302      	movs	r3, #2
 801e1c0:	f000 f9ea 	bl	801e598 <_lseek_r>
 801e1c4:	89a3      	ldrh	r3, [r4, #12]
 801e1c6:	4a05      	ldr	r2, [pc, #20]	; (801e1dc <__swrite+0x34>)
 801e1c8:	0028      	movs	r0, r5
 801e1ca:	4013      	ands	r3, r2
 801e1cc:	81a3      	strh	r3, [r4, #12]
 801e1ce:	0032      	movs	r2, r6
 801e1d0:	230e      	movs	r3, #14
 801e1d2:	5ee1      	ldrsh	r1, [r4, r3]
 801e1d4:	003b      	movs	r3, r7
 801e1d6:	f000 f875 	bl	801e2c4 <_write_r>
 801e1da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801e1dc:	ffffefff 	.word	0xffffefff

0801e1e0 <__sseek>:
 801e1e0:	b570      	push	{r4, r5, r6, lr}
 801e1e2:	000c      	movs	r4, r1
 801e1e4:	250e      	movs	r5, #14
 801e1e6:	5f49      	ldrsh	r1, [r1, r5]
 801e1e8:	f000 f9d6 	bl	801e598 <_lseek_r>
 801e1ec:	89a3      	ldrh	r3, [r4, #12]
 801e1ee:	1c42      	adds	r2, r0, #1
 801e1f0:	d103      	bne.n	801e1fa <__sseek+0x1a>
 801e1f2:	4a05      	ldr	r2, [pc, #20]	; (801e208 <__sseek+0x28>)
 801e1f4:	4013      	ands	r3, r2
 801e1f6:	81a3      	strh	r3, [r4, #12]
 801e1f8:	bd70      	pop	{r4, r5, r6, pc}
 801e1fa:	2280      	movs	r2, #128	; 0x80
 801e1fc:	0152      	lsls	r2, r2, #5
 801e1fe:	4313      	orrs	r3, r2
 801e200:	81a3      	strh	r3, [r4, #12]
 801e202:	6560      	str	r0, [r4, #84]	; 0x54
 801e204:	e7f8      	b.n	801e1f8 <__sseek+0x18>
 801e206:	46c0      	nop			; (mov r8, r8)
 801e208:	ffffefff 	.word	0xffffefff

0801e20c <__sclose>:
 801e20c:	b510      	push	{r4, lr}
 801e20e:	230e      	movs	r3, #14
 801e210:	5ec9      	ldrsh	r1, [r1, r3]
 801e212:	f000 f8e3 	bl	801e3dc <_close_r>
 801e216:	bd10      	pop	{r4, pc}

0801e218 <__swbuf_r>:
 801e218:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e21a:	0005      	movs	r5, r0
 801e21c:	000e      	movs	r6, r1
 801e21e:	0014      	movs	r4, r2
 801e220:	2800      	cmp	r0, #0
 801e222:	d004      	beq.n	801e22e <__swbuf_r+0x16>
 801e224:	6983      	ldr	r3, [r0, #24]
 801e226:	2b00      	cmp	r3, #0
 801e228:	d101      	bne.n	801e22e <__swbuf_r+0x16>
 801e22a:	f7ff fa4f 	bl	801d6cc <__sinit>
 801e22e:	4b22      	ldr	r3, [pc, #136]	; (801e2b8 <__swbuf_r+0xa0>)
 801e230:	429c      	cmp	r4, r3
 801e232:	d12e      	bne.n	801e292 <__swbuf_r+0x7a>
 801e234:	686c      	ldr	r4, [r5, #4]
 801e236:	69a3      	ldr	r3, [r4, #24]
 801e238:	60a3      	str	r3, [r4, #8]
 801e23a:	89a3      	ldrh	r3, [r4, #12]
 801e23c:	071b      	lsls	r3, r3, #28
 801e23e:	d532      	bpl.n	801e2a6 <__swbuf_r+0x8e>
 801e240:	6923      	ldr	r3, [r4, #16]
 801e242:	2b00      	cmp	r3, #0
 801e244:	d02f      	beq.n	801e2a6 <__swbuf_r+0x8e>
 801e246:	6823      	ldr	r3, [r4, #0]
 801e248:	6922      	ldr	r2, [r4, #16]
 801e24a:	b2f7      	uxtb	r7, r6
 801e24c:	1a98      	subs	r0, r3, r2
 801e24e:	6963      	ldr	r3, [r4, #20]
 801e250:	b2f6      	uxtb	r6, r6
 801e252:	4283      	cmp	r3, r0
 801e254:	dc05      	bgt.n	801e262 <__swbuf_r+0x4a>
 801e256:	0021      	movs	r1, r4
 801e258:	0028      	movs	r0, r5
 801e25a:	f000 f95d 	bl	801e518 <_fflush_r>
 801e25e:	2800      	cmp	r0, #0
 801e260:	d127      	bne.n	801e2b2 <__swbuf_r+0x9a>
 801e262:	68a3      	ldr	r3, [r4, #8]
 801e264:	3001      	adds	r0, #1
 801e266:	3b01      	subs	r3, #1
 801e268:	60a3      	str	r3, [r4, #8]
 801e26a:	6823      	ldr	r3, [r4, #0]
 801e26c:	1c5a      	adds	r2, r3, #1
 801e26e:	6022      	str	r2, [r4, #0]
 801e270:	701f      	strb	r7, [r3, #0]
 801e272:	6963      	ldr	r3, [r4, #20]
 801e274:	4283      	cmp	r3, r0
 801e276:	d004      	beq.n	801e282 <__swbuf_r+0x6a>
 801e278:	89a3      	ldrh	r3, [r4, #12]
 801e27a:	07db      	lsls	r3, r3, #31
 801e27c:	d507      	bpl.n	801e28e <__swbuf_r+0x76>
 801e27e:	2e0a      	cmp	r6, #10
 801e280:	d105      	bne.n	801e28e <__swbuf_r+0x76>
 801e282:	0021      	movs	r1, r4
 801e284:	0028      	movs	r0, r5
 801e286:	f000 f947 	bl	801e518 <_fflush_r>
 801e28a:	2800      	cmp	r0, #0
 801e28c:	d111      	bne.n	801e2b2 <__swbuf_r+0x9a>
 801e28e:	0030      	movs	r0, r6
 801e290:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801e292:	4b0a      	ldr	r3, [pc, #40]	; (801e2bc <__swbuf_r+0xa4>)
 801e294:	429c      	cmp	r4, r3
 801e296:	d101      	bne.n	801e29c <__swbuf_r+0x84>
 801e298:	68ac      	ldr	r4, [r5, #8]
 801e29a:	e7cc      	b.n	801e236 <__swbuf_r+0x1e>
 801e29c:	4b08      	ldr	r3, [pc, #32]	; (801e2c0 <__swbuf_r+0xa8>)
 801e29e:	429c      	cmp	r4, r3
 801e2a0:	d1c9      	bne.n	801e236 <__swbuf_r+0x1e>
 801e2a2:	68ec      	ldr	r4, [r5, #12]
 801e2a4:	e7c7      	b.n	801e236 <__swbuf_r+0x1e>
 801e2a6:	0021      	movs	r1, r4
 801e2a8:	0028      	movs	r0, r5
 801e2aa:	f000 f81f 	bl	801e2ec <__swsetup_r>
 801e2ae:	2800      	cmp	r0, #0
 801e2b0:	d0c9      	beq.n	801e246 <__swbuf_r+0x2e>
 801e2b2:	2601      	movs	r6, #1
 801e2b4:	4276      	negs	r6, r6
 801e2b6:	e7ea      	b.n	801e28e <__swbuf_r+0x76>
 801e2b8:	0801fe58 	.word	0x0801fe58
 801e2bc:	0801fe78 	.word	0x0801fe78
 801e2c0:	0801fe38 	.word	0x0801fe38

0801e2c4 <_write_r>:
 801e2c4:	b570      	push	{r4, r5, r6, lr}
 801e2c6:	0004      	movs	r4, r0
 801e2c8:	0008      	movs	r0, r1
 801e2ca:	0011      	movs	r1, r2
 801e2cc:	001a      	movs	r2, r3
 801e2ce:	2300      	movs	r3, #0
 801e2d0:	4d05      	ldr	r5, [pc, #20]	; (801e2e8 <_write_r+0x24>)
 801e2d2:	602b      	str	r3, [r5, #0]
 801e2d4:	f000 fc62 	bl	801eb9c <_write>
 801e2d8:	1c43      	adds	r3, r0, #1
 801e2da:	d103      	bne.n	801e2e4 <_write_r+0x20>
 801e2dc:	682b      	ldr	r3, [r5, #0]
 801e2de:	2b00      	cmp	r3, #0
 801e2e0:	d000      	beq.n	801e2e4 <_write_r+0x20>
 801e2e2:	6023      	str	r3, [r4, #0]
 801e2e4:	bd70      	pop	{r4, r5, r6, pc}
 801e2e6:	46c0      	nop			; (mov r8, r8)
 801e2e8:	20001838 	.word	0x20001838

0801e2ec <__swsetup_r>:
 801e2ec:	4b37      	ldr	r3, [pc, #220]	; (801e3cc <__swsetup_r+0xe0>)
 801e2ee:	b570      	push	{r4, r5, r6, lr}
 801e2f0:	681d      	ldr	r5, [r3, #0]
 801e2f2:	0006      	movs	r6, r0
 801e2f4:	000c      	movs	r4, r1
 801e2f6:	2d00      	cmp	r5, #0
 801e2f8:	d005      	beq.n	801e306 <__swsetup_r+0x1a>
 801e2fa:	69ab      	ldr	r3, [r5, #24]
 801e2fc:	2b00      	cmp	r3, #0
 801e2fe:	d102      	bne.n	801e306 <__swsetup_r+0x1a>
 801e300:	0028      	movs	r0, r5
 801e302:	f7ff f9e3 	bl	801d6cc <__sinit>
 801e306:	4b32      	ldr	r3, [pc, #200]	; (801e3d0 <__swsetup_r+0xe4>)
 801e308:	429c      	cmp	r4, r3
 801e30a:	d10f      	bne.n	801e32c <__swsetup_r+0x40>
 801e30c:	686c      	ldr	r4, [r5, #4]
 801e30e:	230c      	movs	r3, #12
 801e310:	5ee2      	ldrsh	r2, [r4, r3]
 801e312:	b293      	uxth	r3, r2
 801e314:	0711      	lsls	r1, r2, #28
 801e316:	d42d      	bmi.n	801e374 <__swsetup_r+0x88>
 801e318:	06d9      	lsls	r1, r3, #27
 801e31a:	d411      	bmi.n	801e340 <__swsetup_r+0x54>
 801e31c:	2309      	movs	r3, #9
 801e31e:	2001      	movs	r0, #1
 801e320:	6033      	str	r3, [r6, #0]
 801e322:	3337      	adds	r3, #55	; 0x37
 801e324:	4313      	orrs	r3, r2
 801e326:	81a3      	strh	r3, [r4, #12]
 801e328:	4240      	negs	r0, r0
 801e32a:	bd70      	pop	{r4, r5, r6, pc}
 801e32c:	4b29      	ldr	r3, [pc, #164]	; (801e3d4 <__swsetup_r+0xe8>)
 801e32e:	429c      	cmp	r4, r3
 801e330:	d101      	bne.n	801e336 <__swsetup_r+0x4a>
 801e332:	68ac      	ldr	r4, [r5, #8]
 801e334:	e7eb      	b.n	801e30e <__swsetup_r+0x22>
 801e336:	4b28      	ldr	r3, [pc, #160]	; (801e3d8 <__swsetup_r+0xec>)
 801e338:	429c      	cmp	r4, r3
 801e33a:	d1e8      	bne.n	801e30e <__swsetup_r+0x22>
 801e33c:	68ec      	ldr	r4, [r5, #12]
 801e33e:	e7e6      	b.n	801e30e <__swsetup_r+0x22>
 801e340:	075b      	lsls	r3, r3, #29
 801e342:	d513      	bpl.n	801e36c <__swsetup_r+0x80>
 801e344:	6b61      	ldr	r1, [r4, #52]	; 0x34
 801e346:	2900      	cmp	r1, #0
 801e348:	d008      	beq.n	801e35c <__swsetup_r+0x70>
 801e34a:	0023      	movs	r3, r4
 801e34c:	3344      	adds	r3, #68	; 0x44
 801e34e:	4299      	cmp	r1, r3
 801e350:	d002      	beq.n	801e358 <__swsetup_r+0x6c>
 801e352:	0030      	movs	r0, r6
 801e354:	f000 f9d8 	bl	801e708 <_free_r>
 801e358:	2300      	movs	r3, #0
 801e35a:	6363      	str	r3, [r4, #52]	; 0x34
 801e35c:	2224      	movs	r2, #36	; 0x24
 801e35e:	89a3      	ldrh	r3, [r4, #12]
 801e360:	4393      	bics	r3, r2
 801e362:	81a3      	strh	r3, [r4, #12]
 801e364:	2300      	movs	r3, #0
 801e366:	6063      	str	r3, [r4, #4]
 801e368:	6923      	ldr	r3, [r4, #16]
 801e36a:	6023      	str	r3, [r4, #0]
 801e36c:	2308      	movs	r3, #8
 801e36e:	89a2      	ldrh	r2, [r4, #12]
 801e370:	4313      	orrs	r3, r2
 801e372:	81a3      	strh	r3, [r4, #12]
 801e374:	6923      	ldr	r3, [r4, #16]
 801e376:	2b00      	cmp	r3, #0
 801e378:	d10b      	bne.n	801e392 <__swsetup_r+0xa6>
 801e37a:	21a0      	movs	r1, #160	; 0xa0
 801e37c:	2280      	movs	r2, #128	; 0x80
 801e37e:	89a3      	ldrh	r3, [r4, #12]
 801e380:	0089      	lsls	r1, r1, #2
 801e382:	0092      	lsls	r2, r2, #2
 801e384:	400b      	ands	r3, r1
 801e386:	4293      	cmp	r3, r2
 801e388:	d003      	beq.n	801e392 <__swsetup_r+0xa6>
 801e38a:	0021      	movs	r1, r4
 801e38c:	0030      	movs	r0, r6
 801e38e:	f000 f93f 	bl	801e610 <__smakebuf_r>
 801e392:	220c      	movs	r2, #12
 801e394:	5ea3      	ldrsh	r3, [r4, r2]
 801e396:	2001      	movs	r0, #1
 801e398:	001a      	movs	r2, r3
 801e39a:	b299      	uxth	r1, r3
 801e39c:	4002      	ands	r2, r0
 801e39e:	4203      	tst	r3, r0
 801e3a0:	d00f      	beq.n	801e3c2 <__swsetup_r+0xd6>
 801e3a2:	2200      	movs	r2, #0
 801e3a4:	60a2      	str	r2, [r4, #8]
 801e3a6:	6962      	ldr	r2, [r4, #20]
 801e3a8:	4252      	negs	r2, r2
 801e3aa:	61a2      	str	r2, [r4, #24]
 801e3ac:	2000      	movs	r0, #0
 801e3ae:	6922      	ldr	r2, [r4, #16]
 801e3b0:	4282      	cmp	r2, r0
 801e3b2:	d1ba      	bne.n	801e32a <__swsetup_r+0x3e>
 801e3b4:	060a      	lsls	r2, r1, #24
 801e3b6:	d5b8      	bpl.n	801e32a <__swsetup_r+0x3e>
 801e3b8:	2240      	movs	r2, #64	; 0x40
 801e3ba:	4313      	orrs	r3, r2
 801e3bc:	81a3      	strh	r3, [r4, #12]
 801e3be:	3801      	subs	r0, #1
 801e3c0:	e7b3      	b.n	801e32a <__swsetup_r+0x3e>
 801e3c2:	0788      	lsls	r0, r1, #30
 801e3c4:	d400      	bmi.n	801e3c8 <__swsetup_r+0xdc>
 801e3c6:	6962      	ldr	r2, [r4, #20]
 801e3c8:	60a2      	str	r2, [r4, #8]
 801e3ca:	e7ef      	b.n	801e3ac <__swsetup_r+0xc0>
 801e3cc:	200002d0 	.word	0x200002d0
 801e3d0:	0801fe58 	.word	0x0801fe58
 801e3d4:	0801fe78 	.word	0x0801fe78
 801e3d8:	0801fe38 	.word	0x0801fe38

0801e3dc <_close_r>:
 801e3dc:	2300      	movs	r3, #0
 801e3de:	b570      	push	{r4, r5, r6, lr}
 801e3e0:	4d06      	ldr	r5, [pc, #24]	; (801e3fc <_close_r+0x20>)
 801e3e2:	0004      	movs	r4, r0
 801e3e4:	0008      	movs	r0, r1
 801e3e6:	602b      	str	r3, [r5, #0]
 801e3e8:	f000 fba0 	bl	801eb2c <_close>
 801e3ec:	1c43      	adds	r3, r0, #1
 801e3ee:	d103      	bne.n	801e3f8 <_close_r+0x1c>
 801e3f0:	682b      	ldr	r3, [r5, #0]
 801e3f2:	2b00      	cmp	r3, #0
 801e3f4:	d000      	beq.n	801e3f8 <_close_r+0x1c>
 801e3f6:	6023      	str	r3, [r4, #0]
 801e3f8:	bd70      	pop	{r4, r5, r6, pc}
 801e3fa:	46c0      	nop			; (mov r8, r8)
 801e3fc:	20001838 	.word	0x20001838

0801e400 <__sflush_r>:
 801e400:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801e402:	898b      	ldrh	r3, [r1, #12]
 801e404:	0005      	movs	r5, r0
 801e406:	000c      	movs	r4, r1
 801e408:	071a      	lsls	r2, r3, #28
 801e40a:	d45f      	bmi.n	801e4cc <__sflush_r+0xcc>
 801e40c:	684a      	ldr	r2, [r1, #4]
 801e40e:	2a00      	cmp	r2, #0
 801e410:	dc04      	bgt.n	801e41c <__sflush_r+0x1c>
 801e412:	6c0a      	ldr	r2, [r1, #64]	; 0x40
 801e414:	2a00      	cmp	r2, #0
 801e416:	dc01      	bgt.n	801e41c <__sflush_r+0x1c>
 801e418:	2000      	movs	r0, #0
 801e41a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 801e41c:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 801e41e:	2f00      	cmp	r7, #0
 801e420:	d0fa      	beq.n	801e418 <__sflush_r+0x18>
 801e422:	2200      	movs	r2, #0
 801e424:	2180      	movs	r1, #128	; 0x80
 801e426:	682e      	ldr	r6, [r5, #0]
 801e428:	602a      	str	r2, [r5, #0]
 801e42a:	001a      	movs	r2, r3
 801e42c:	0149      	lsls	r1, r1, #5
 801e42e:	400a      	ands	r2, r1
 801e430:	420b      	tst	r3, r1
 801e432:	d034      	beq.n	801e49e <__sflush_r+0x9e>
 801e434:	6d60      	ldr	r0, [r4, #84]	; 0x54
 801e436:	89a3      	ldrh	r3, [r4, #12]
 801e438:	075b      	lsls	r3, r3, #29
 801e43a:	d506      	bpl.n	801e44a <__sflush_r+0x4a>
 801e43c:	6863      	ldr	r3, [r4, #4]
 801e43e:	1ac0      	subs	r0, r0, r3
 801e440:	6b63      	ldr	r3, [r4, #52]	; 0x34
 801e442:	2b00      	cmp	r3, #0
 801e444:	d001      	beq.n	801e44a <__sflush_r+0x4a>
 801e446:	6c23      	ldr	r3, [r4, #64]	; 0x40
 801e448:	1ac0      	subs	r0, r0, r3
 801e44a:	0002      	movs	r2, r0
 801e44c:	6a21      	ldr	r1, [r4, #32]
 801e44e:	2300      	movs	r3, #0
 801e450:	0028      	movs	r0, r5
 801e452:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 801e454:	47b8      	blx	r7
 801e456:	89a1      	ldrh	r1, [r4, #12]
 801e458:	1c43      	adds	r3, r0, #1
 801e45a:	d106      	bne.n	801e46a <__sflush_r+0x6a>
 801e45c:	682b      	ldr	r3, [r5, #0]
 801e45e:	2b1d      	cmp	r3, #29
 801e460:	d831      	bhi.n	801e4c6 <__sflush_r+0xc6>
 801e462:	4a2c      	ldr	r2, [pc, #176]	; (801e514 <__sflush_r+0x114>)
 801e464:	40da      	lsrs	r2, r3
 801e466:	07d3      	lsls	r3, r2, #31
 801e468:	d52d      	bpl.n	801e4c6 <__sflush_r+0xc6>
 801e46a:	2300      	movs	r3, #0
 801e46c:	6063      	str	r3, [r4, #4]
 801e46e:	6923      	ldr	r3, [r4, #16]
 801e470:	6023      	str	r3, [r4, #0]
 801e472:	04cb      	lsls	r3, r1, #19
 801e474:	d505      	bpl.n	801e482 <__sflush_r+0x82>
 801e476:	1c43      	adds	r3, r0, #1
 801e478:	d102      	bne.n	801e480 <__sflush_r+0x80>
 801e47a:	682b      	ldr	r3, [r5, #0]
 801e47c:	2b00      	cmp	r3, #0
 801e47e:	d100      	bne.n	801e482 <__sflush_r+0x82>
 801e480:	6560      	str	r0, [r4, #84]	; 0x54
 801e482:	6b61      	ldr	r1, [r4, #52]	; 0x34
 801e484:	602e      	str	r6, [r5, #0]
 801e486:	2900      	cmp	r1, #0
 801e488:	d0c6      	beq.n	801e418 <__sflush_r+0x18>
 801e48a:	0023      	movs	r3, r4
 801e48c:	3344      	adds	r3, #68	; 0x44
 801e48e:	4299      	cmp	r1, r3
 801e490:	d002      	beq.n	801e498 <__sflush_r+0x98>
 801e492:	0028      	movs	r0, r5
 801e494:	f000 f938 	bl	801e708 <_free_r>
 801e498:	2000      	movs	r0, #0
 801e49a:	6360      	str	r0, [r4, #52]	; 0x34
 801e49c:	e7bd      	b.n	801e41a <__sflush_r+0x1a>
 801e49e:	2301      	movs	r3, #1
 801e4a0:	0028      	movs	r0, r5
 801e4a2:	6a21      	ldr	r1, [r4, #32]
 801e4a4:	47b8      	blx	r7
 801e4a6:	1c43      	adds	r3, r0, #1
 801e4a8:	d1c5      	bne.n	801e436 <__sflush_r+0x36>
 801e4aa:	682b      	ldr	r3, [r5, #0]
 801e4ac:	2b00      	cmp	r3, #0
 801e4ae:	d0c2      	beq.n	801e436 <__sflush_r+0x36>
 801e4b0:	2b1d      	cmp	r3, #29
 801e4b2:	d001      	beq.n	801e4b8 <__sflush_r+0xb8>
 801e4b4:	2b16      	cmp	r3, #22
 801e4b6:	d101      	bne.n	801e4bc <__sflush_r+0xbc>
 801e4b8:	602e      	str	r6, [r5, #0]
 801e4ba:	e7ad      	b.n	801e418 <__sflush_r+0x18>
 801e4bc:	2340      	movs	r3, #64	; 0x40
 801e4be:	89a2      	ldrh	r2, [r4, #12]
 801e4c0:	4313      	orrs	r3, r2
 801e4c2:	81a3      	strh	r3, [r4, #12]
 801e4c4:	e7a9      	b.n	801e41a <__sflush_r+0x1a>
 801e4c6:	2340      	movs	r3, #64	; 0x40
 801e4c8:	430b      	orrs	r3, r1
 801e4ca:	e7fa      	b.n	801e4c2 <__sflush_r+0xc2>
 801e4cc:	690f      	ldr	r7, [r1, #16]
 801e4ce:	2f00      	cmp	r7, #0
 801e4d0:	d0a2      	beq.n	801e418 <__sflush_r+0x18>
 801e4d2:	680a      	ldr	r2, [r1, #0]
 801e4d4:	600f      	str	r7, [r1, #0]
 801e4d6:	1bd2      	subs	r2, r2, r7
 801e4d8:	9201      	str	r2, [sp, #4]
 801e4da:	2200      	movs	r2, #0
 801e4dc:	079b      	lsls	r3, r3, #30
 801e4de:	d100      	bne.n	801e4e2 <__sflush_r+0xe2>
 801e4e0:	694a      	ldr	r2, [r1, #20]
 801e4e2:	60a2      	str	r2, [r4, #8]
 801e4e4:	9b01      	ldr	r3, [sp, #4]
 801e4e6:	2b00      	cmp	r3, #0
 801e4e8:	dc00      	bgt.n	801e4ec <__sflush_r+0xec>
 801e4ea:	e795      	b.n	801e418 <__sflush_r+0x18>
 801e4ec:	003a      	movs	r2, r7
 801e4ee:	0028      	movs	r0, r5
 801e4f0:	9b01      	ldr	r3, [sp, #4]
 801e4f2:	6a21      	ldr	r1, [r4, #32]
 801e4f4:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 801e4f6:	47b0      	blx	r6
 801e4f8:	2800      	cmp	r0, #0
 801e4fa:	dc06      	bgt.n	801e50a <__sflush_r+0x10a>
 801e4fc:	2340      	movs	r3, #64	; 0x40
 801e4fe:	2001      	movs	r0, #1
 801e500:	89a2      	ldrh	r2, [r4, #12]
 801e502:	4240      	negs	r0, r0
 801e504:	4313      	orrs	r3, r2
 801e506:	81a3      	strh	r3, [r4, #12]
 801e508:	e787      	b.n	801e41a <__sflush_r+0x1a>
 801e50a:	9b01      	ldr	r3, [sp, #4]
 801e50c:	183f      	adds	r7, r7, r0
 801e50e:	1a1b      	subs	r3, r3, r0
 801e510:	9301      	str	r3, [sp, #4]
 801e512:	e7e7      	b.n	801e4e4 <__sflush_r+0xe4>
 801e514:	20400001 	.word	0x20400001

0801e518 <_fflush_r>:
 801e518:	690b      	ldr	r3, [r1, #16]
 801e51a:	b570      	push	{r4, r5, r6, lr}
 801e51c:	0005      	movs	r5, r0
 801e51e:	000c      	movs	r4, r1
 801e520:	2b00      	cmp	r3, #0
 801e522:	d102      	bne.n	801e52a <_fflush_r+0x12>
 801e524:	2500      	movs	r5, #0
 801e526:	0028      	movs	r0, r5
 801e528:	bd70      	pop	{r4, r5, r6, pc}
 801e52a:	2800      	cmp	r0, #0
 801e52c:	d004      	beq.n	801e538 <_fflush_r+0x20>
 801e52e:	6983      	ldr	r3, [r0, #24]
 801e530:	2b00      	cmp	r3, #0
 801e532:	d101      	bne.n	801e538 <_fflush_r+0x20>
 801e534:	f7ff f8ca 	bl	801d6cc <__sinit>
 801e538:	4b14      	ldr	r3, [pc, #80]	; (801e58c <_fflush_r+0x74>)
 801e53a:	429c      	cmp	r4, r3
 801e53c:	d11b      	bne.n	801e576 <_fflush_r+0x5e>
 801e53e:	686c      	ldr	r4, [r5, #4]
 801e540:	220c      	movs	r2, #12
 801e542:	5ea3      	ldrsh	r3, [r4, r2]
 801e544:	2b00      	cmp	r3, #0
 801e546:	d0ed      	beq.n	801e524 <_fflush_r+0xc>
 801e548:	6e62      	ldr	r2, [r4, #100]	; 0x64
 801e54a:	07d2      	lsls	r2, r2, #31
 801e54c:	d404      	bmi.n	801e558 <_fflush_r+0x40>
 801e54e:	059b      	lsls	r3, r3, #22
 801e550:	d402      	bmi.n	801e558 <_fflush_r+0x40>
 801e552:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801e554:	f7ff f95b 	bl	801d80e <__retarget_lock_acquire_recursive>
 801e558:	0028      	movs	r0, r5
 801e55a:	0021      	movs	r1, r4
 801e55c:	f7ff ff50 	bl	801e400 <__sflush_r>
 801e560:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801e562:	0005      	movs	r5, r0
 801e564:	07db      	lsls	r3, r3, #31
 801e566:	d4de      	bmi.n	801e526 <_fflush_r+0xe>
 801e568:	89a3      	ldrh	r3, [r4, #12]
 801e56a:	059b      	lsls	r3, r3, #22
 801e56c:	d4db      	bmi.n	801e526 <_fflush_r+0xe>
 801e56e:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801e570:	f7ff f94e 	bl	801d810 <__retarget_lock_release_recursive>
 801e574:	e7d7      	b.n	801e526 <_fflush_r+0xe>
 801e576:	4b06      	ldr	r3, [pc, #24]	; (801e590 <_fflush_r+0x78>)
 801e578:	429c      	cmp	r4, r3
 801e57a:	d101      	bne.n	801e580 <_fflush_r+0x68>
 801e57c:	68ac      	ldr	r4, [r5, #8]
 801e57e:	e7df      	b.n	801e540 <_fflush_r+0x28>
 801e580:	4b04      	ldr	r3, [pc, #16]	; (801e594 <_fflush_r+0x7c>)
 801e582:	429c      	cmp	r4, r3
 801e584:	d1dc      	bne.n	801e540 <_fflush_r+0x28>
 801e586:	68ec      	ldr	r4, [r5, #12]
 801e588:	e7da      	b.n	801e540 <_fflush_r+0x28>
 801e58a:	46c0      	nop			; (mov r8, r8)
 801e58c:	0801fe58 	.word	0x0801fe58
 801e590:	0801fe78 	.word	0x0801fe78
 801e594:	0801fe38 	.word	0x0801fe38

0801e598 <_lseek_r>:
 801e598:	b570      	push	{r4, r5, r6, lr}
 801e59a:	0004      	movs	r4, r0
 801e59c:	0008      	movs	r0, r1
 801e59e:	0011      	movs	r1, r2
 801e5a0:	001a      	movs	r2, r3
 801e5a2:	2300      	movs	r3, #0
 801e5a4:	4d05      	ldr	r5, [pc, #20]	; (801e5bc <_lseek_r+0x24>)
 801e5a6:	602b      	str	r3, [r5, #0]
 801e5a8:	f000 fad8 	bl	801eb5c <_lseek>
 801e5ac:	1c43      	adds	r3, r0, #1
 801e5ae:	d103      	bne.n	801e5b8 <_lseek_r+0x20>
 801e5b0:	682b      	ldr	r3, [r5, #0]
 801e5b2:	2b00      	cmp	r3, #0
 801e5b4:	d000      	beq.n	801e5b8 <_lseek_r+0x20>
 801e5b6:	6023      	str	r3, [r4, #0]
 801e5b8:	bd70      	pop	{r4, r5, r6, pc}
 801e5ba:	46c0      	nop			; (mov r8, r8)
 801e5bc:	20001838 	.word	0x20001838

0801e5c0 <__swhatbuf_r>:
 801e5c0:	b570      	push	{r4, r5, r6, lr}
 801e5c2:	000e      	movs	r6, r1
 801e5c4:	001d      	movs	r5, r3
 801e5c6:	230e      	movs	r3, #14
 801e5c8:	5ec9      	ldrsh	r1, [r1, r3]
 801e5ca:	0014      	movs	r4, r2
 801e5cc:	b096      	sub	sp, #88	; 0x58
 801e5ce:	2900      	cmp	r1, #0
 801e5d0:	da07      	bge.n	801e5e2 <__swhatbuf_r+0x22>
 801e5d2:	2300      	movs	r3, #0
 801e5d4:	602b      	str	r3, [r5, #0]
 801e5d6:	89b3      	ldrh	r3, [r6, #12]
 801e5d8:	061b      	lsls	r3, r3, #24
 801e5da:	d411      	bmi.n	801e600 <__swhatbuf_r+0x40>
 801e5dc:	2380      	movs	r3, #128	; 0x80
 801e5de:	00db      	lsls	r3, r3, #3
 801e5e0:	e00f      	b.n	801e602 <__swhatbuf_r+0x42>
 801e5e2:	466a      	mov	r2, sp
 801e5e4:	f000 f914 	bl	801e810 <_fstat_r>
 801e5e8:	2800      	cmp	r0, #0
 801e5ea:	dbf2      	blt.n	801e5d2 <__swhatbuf_r+0x12>
 801e5ec:	23f0      	movs	r3, #240	; 0xf0
 801e5ee:	9901      	ldr	r1, [sp, #4]
 801e5f0:	021b      	lsls	r3, r3, #8
 801e5f2:	4019      	ands	r1, r3
 801e5f4:	4b05      	ldr	r3, [pc, #20]	; (801e60c <__swhatbuf_r+0x4c>)
 801e5f6:	18c9      	adds	r1, r1, r3
 801e5f8:	424b      	negs	r3, r1
 801e5fa:	4159      	adcs	r1, r3
 801e5fc:	6029      	str	r1, [r5, #0]
 801e5fe:	e7ed      	b.n	801e5dc <__swhatbuf_r+0x1c>
 801e600:	2340      	movs	r3, #64	; 0x40
 801e602:	2000      	movs	r0, #0
 801e604:	6023      	str	r3, [r4, #0]
 801e606:	b016      	add	sp, #88	; 0x58
 801e608:	bd70      	pop	{r4, r5, r6, pc}
 801e60a:	46c0      	nop			; (mov r8, r8)
 801e60c:	ffffe000 	.word	0xffffe000

0801e610 <__smakebuf_r>:
 801e610:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801e612:	2602      	movs	r6, #2
 801e614:	898b      	ldrh	r3, [r1, #12]
 801e616:	0005      	movs	r5, r0
 801e618:	000c      	movs	r4, r1
 801e61a:	4233      	tst	r3, r6
 801e61c:	d006      	beq.n	801e62c <__smakebuf_r+0x1c>
 801e61e:	0023      	movs	r3, r4
 801e620:	3347      	adds	r3, #71	; 0x47
 801e622:	6023      	str	r3, [r4, #0]
 801e624:	6123      	str	r3, [r4, #16]
 801e626:	2301      	movs	r3, #1
 801e628:	6163      	str	r3, [r4, #20]
 801e62a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 801e62c:	466a      	mov	r2, sp
 801e62e:	ab01      	add	r3, sp, #4
 801e630:	f7ff ffc6 	bl	801e5c0 <__swhatbuf_r>
 801e634:	9900      	ldr	r1, [sp, #0]
 801e636:	0007      	movs	r7, r0
 801e638:	0028      	movs	r0, r5
 801e63a:	f7ff f8eb 	bl	801d814 <_malloc_r>
 801e63e:	2800      	cmp	r0, #0
 801e640:	d108      	bne.n	801e654 <__smakebuf_r+0x44>
 801e642:	220c      	movs	r2, #12
 801e644:	5ea3      	ldrsh	r3, [r4, r2]
 801e646:	059a      	lsls	r2, r3, #22
 801e648:	d4ef      	bmi.n	801e62a <__smakebuf_r+0x1a>
 801e64a:	2203      	movs	r2, #3
 801e64c:	4393      	bics	r3, r2
 801e64e:	431e      	orrs	r6, r3
 801e650:	81a6      	strh	r6, [r4, #12]
 801e652:	e7e4      	b.n	801e61e <__smakebuf_r+0xe>
 801e654:	4b0f      	ldr	r3, [pc, #60]	; (801e694 <__smakebuf_r+0x84>)
 801e656:	62ab      	str	r3, [r5, #40]	; 0x28
 801e658:	2380      	movs	r3, #128	; 0x80
 801e65a:	89a2      	ldrh	r2, [r4, #12]
 801e65c:	6020      	str	r0, [r4, #0]
 801e65e:	4313      	orrs	r3, r2
 801e660:	81a3      	strh	r3, [r4, #12]
 801e662:	9b00      	ldr	r3, [sp, #0]
 801e664:	6120      	str	r0, [r4, #16]
 801e666:	6163      	str	r3, [r4, #20]
 801e668:	9b01      	ldr	r3, [sp, #4]
 801e66a:	2b00      	cmp	r3, #0
 801e66c:	d00d      	beq.n	801e68a <__smakebuf_r+0x7a>
 801e66e:	0028      	movs	r0, r5
 801e670:	230e      	movs	r3, #14
 801e672:	5ee1      	ldrsh	r1, [r4, r3]
 801e674:	f000 f8de 	bl	801e834 <_isatty_r>
 801e678:	2800      	cmp	r0, #0
 801e67a:	d006      	beq.n	801e68a <__smakebuf_r+0x7a>
 801e67c:	2203      	movs	r2, #3
 801e67e:	89a3      	ldrh	r3, [r4, #12]
 801e680:	4393      	bics	r3, r2
 801e682:	001a      	movs	r2, r3
 801e684:	2301      	movs	r3, #1
 801e686:	4313      	orrs	r3, r2
 801e688:	81a3      	strh	r3, [r4, #12]
 801e68a:	89a0      	ldrh	r0, [r4, #12]
 801e68c:	4307      	orrs	r7, r0
 801e68e:	81a7      	strh	r7, [r4, #12]
 801e690:	e7cb      	b.n	801e62a <__smakebuf_r+0x1a>
 801e692:	46c0      	nop			; (mov r8, r8)
 801e694:	0801d651 	.word	0x0801d651

0801e698 <memchr>:
 801e698:	b2c9      	uxtb	r1, r1
 801e69a:	1882      	adds	r2, r0, r2
 801e69c:	4290      	cmp	r0, r2
 801e69e:	d101      	bne.n	801e6a4 <memchr+0xc>
 801e6a0:	2000      	movs	r0, #0
 801e6a2:	4770      	bx	lr
 801e6a4:	7803      	ldrb	r3, [r0, #0]
 801e6a6:	428b      	cmp	r3, r1
 801e6a8:	d0fb      	beq.n	801e6a2 <memchr+0xa>
 801e6aa:	3001      	adds	r0, #1
 801e6ac:	e7f6      	b.n	801e69c <memchr+0x4>

0801e6ae <memcpy>:
 801e6ae:	2300      	movs	r3, #0
 801e6b0:	b510      	push	{r4, lr}
 801e6b2:	429a      	cmp	r2, r3
 801e6b4:	d100      	bne.n	801e6b8 <memcpy+0xa>
 801e6b6:	bd10      	pop	{r4, pc}
 801e6b8:	5ccc      	ldrb	r4, [r1, r3]
 801e6ba:	54c4      	strb	r4, [r0, r3]
 801e6bc:	3301      	adds	r3, #1
 801e6be:	e7f8      	b.n	801e6b2 <memcpy+0x4>

0801e6c0 <memmove>:
 801e6c0:	b510      	push	{r4, lr}
 801e6c2:	4288      	cmp	r0, r1
 801e6c4:	d902      	bls.n	801e6cc <memmove+0xc>
 801e6c6:	188b      	adds	r3, r1, r2
 801e6c8:	4298      	cmp	r0, r3
 801e6ca:	d303      	bcc.n	801e6d4 <memmove+0x14>
 801e6cc:	2300      	movs	r3, #0
 801e6ce:	e007      	b.n	801e6e0 <memmove+0x20>
 801e6d0:	5c8b      	ldrb	r3, [r1, r2]
 801e6d2:	5483      	strb	r3, [r0, r2]
 801e6d4:	3a01      	subs	r2, #1
 801e6d6:	d2fb      	bcs.n	801e6d0 <memmove+0x10>
 801e6d8:	bd10      	pop	{r4, pc}
 801e6da:	5ccc      	ldrb	r4, [r1, r3]
 801e6dc:	54c4      	strb	r4, [r0, r3]
 801e6de:	3301      	adds	r3, #1
 801e6e0:	429a      	cmp	r2, r3
 801e6e2:	d1fa      	bne.n	801e6da <memmove+0x1a>
 801e6e4:	e7f8      	b.n	801e6d8 <memmove+0x18>
	...

0801e6e8 <__malloc_lock>:
 801e6e8:	b510      	push	{r4, lr}
 801e6ea:	4802      	ldr	r0, [pc, #8]	; (801e6f4 <__malloc_lock+0xc>)
 801e6ec:	f7ff f88f 	bl	801d80e <__retarget_lock_acquire_recursive>
 801e6f0:	bd10      	pop	{r4, pc}
 801e6f2:	46c0      	nop			; (mov r8, r8)
 801e6f4:	20001830 	.word	0x20001830

0801e6f8 <__malloc_unlock>:
 801e6f8:	b510      	push	{r4, lr}
 801e6fa:	4802      	ldr	r0, [pc, #8]	; (801e704 <__malloc_unlock+0xc>)
 801e6fc:	f7ff f888 	bl	801d810 <__retarget_lock_release_recursive>
 801e700:	bd10      	pop	{r4, pc}
 801e702:	46c0      	nop			; (mov r8, r8)
 801e704:	20001830 	.word	0x20001830

0801e708 <_free_r>:
 801e708:	b570      	push	{r4, r5, r6, lr}
 801e70a:	0005      	movs	r5, r0
 801e70c:	2900      	cmp	r1, #0
 801e70e:	d010      	beq.n	801e732 <_free_r+0x2a>
 801e710:	1f0c      	subs	r4, r1, #4
 801e712:	6823      	ldr	r3, [r4, #0]
 801e714:	2b00      	cmp	r3, #0
 801e716:	da00      	bge.n	801e71a <_free_r+0x12>
 801e718:	18e4      	adds	r4, r4, r3
 801e71a:	0028      	movs	r0, r5
 801e71c:	f7ff ffe4 	bl	801e6e8 <__malloc_lock>
 801e720:	4a1d      	ldr	r2, [pc, #116]	; (801e798 <_free_r+0x90>)
 801e722:	6813      	ldr	r3, [r2, #0]
 801e724:	2b00      	cmp	r3, #0
 801e726:	d105      	bne.n	801e734 <_free_r+0x2c>
 801e728:	6063      	str	r3, [r4, #4]
 801e72a:	6014      	str	r4, [r2, #0]
 801e72c:	0028      	movs	r0, r5
 801e72e:	f7ff ffe3 	bl	801e6f8 <__malloc_unlock>
 801e732:	bd70      	pop	{r4, r5, r6, pc}
 801e734:	42a3      	cmp	r3, r4
 801e736:	d908      	bls.n	801e74a <_free_r+0x42>
 801e738:	6821      	ldr	r1, [r4, #0]
 801e73a:	1860      	adds	r0, r4, r1
 801e73c:	4283      	cmp	r3, r0
 801e73e:	d1f3      	bne.n	801e728 <_free_r+0x20>
 801e740:	6818      	ldr	r0, [r3, #0]
 801e742:	685b      	ldr	r3, [r3, #4]
 801e744:	1841      	adds	r1, r0, r1
 801e746:	6021      	str	r1, [r4, #0]
 801e748:	e7ee      	b.n	801e728 <_free_r+0x20>
 801e74a:	001a      	movs	r2, r3
 801e74c:	685b      	ldr	r3, [r3, #4]
 801e74e:	2b00      	cmp	r3, #0
 801e750:	d001      	beq.n	801e756 <_free_r+0x4e>
 801e752:	42a3      	cmp	r3, r4
 801e754:	d9f9      	bls.n	801e74a <_free_r+0x42>
 801e756:	6811      	ldr	r1, [r2, #0]
 801e758:	1850      	adds	r0, r2, r1
 801e75a:	42a0      	cmp	r0, r4
 801e75c:	d10b      	bne.n	801e776 <_free_r+0x6e>
 801e75e:	6820      	ldr	r0, [r4, #0]
 801e760:	1809      	adds	r1, r1, r0
 801e762:	1850      	adds	r0, r2, r1
 801e764:	6011      	str	r1, [r2, #0]
 801e766:	4283      	cmp	r3, r0
 801e768:	d1e0      	bne.n	801e72c <_free_r+0x24>
 801e76a:	6818      	ldr	r0, [r3, #0]
 801e76c:	685b      	ldr	r3, [r3, #4]
 801e76e:	1841      	adds	r1, r0, r1
 801e770:	6011      	str	r1, [r2, #0]
 801e772:	6053      	str	r3, [r2, #4]
 801e774:	e7da      	b.n	801e72c <_free_r+0x24>
 801e776:	42a0      	cmp	r0, r4
 801e778:	d902      	bls.n	801e780 <_free_r+0x78>
 801e77a:	230c      	movs	r3, #12
 801e77c:	602b      	str	r3, [r5, #0]
 801e77e:	e7d5      	b.n	801e72c <_free_r+0x24>
 801e780:	6821      	ldr	r1, [r4, #0]
 801e782:	1860      	adds	r0, r4, r1
 801e784:	4283      	cmp	r3, r0
 801e786:	d103      	bne.n	801e790 <_free_r+0x88>
 801e788:	6818      	ldr	r0, [r3, #0]
 801e78a:	685b      	ldr	r3, [r3, #4]
 801e78c:	1841      	adds	r1, r0, r1
 801e78e:	6021      	str	r1, [r4, #0]
 801e790:	6063      	str	r3, [r4, #4]
 801e792:	6054      	str	r4, [r2, #4]
 801e794:	e7ca      	b.n	801e72c <_free_r+0x24>
 801e796:	46c0      	nop			; (mov r8, r8)
 801e798:	20001714 	.word	0x20001714

0801e79c <_realloc_r>:
 801e79c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e79e:	0007      	movs	r7, r0
 801e7a0:	000d      	movs	r5, r1
 801e7a2:	0016      	movs	r6, r2
 801e7a4:	2900      	cmp	r1, #0
 801e7a6:	d105      	bne.n	801e7b4 <_realloc_r+0x18>
 801e7a8:	0011      	movs	r1, r2
 801e7aa:	f7ff f833 	bl	801d814 <_malloc_r>
 801e7ae:	0004      	movs	r4, r0
 801e7b0:	0020      	movs	r0, r4
 801e7b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801e7b4:	2a00      	cmp	r2, #0
 801e7b6:	d103      	bne.n	801e7c0 <_realloc_r+0x24>
 801e7b8:	f7ff ffa6 	bl	801e708 <_free_r>
 801e7bc:	0034      	movs	r4, r6
 801e7be:	e7f7      	b.n	801e7b0 <_realloc_r+0x14>
 801e7c0:	f000 f84a 	bl	801e858 <_malloc_usable_size_r>
 801e7c4:	002c      	movs	r4, r5
 801e7c6:	42b0      	cmp	r0, r6
 801e7c8:	d2f2      	bcs.n	801e7b0 <_realloc_r+0x14>
 801e7ca:	0031      	movs	r1, r6
 801e7cc:	0038      	movs	r0, r7
 801e7ce:	f7ff f821 	bl	801d814 <_malloc_r>
 801e7d2:	1e04      	subs	r4, r0, #0
 801e7d4:	d0ec      	beq.n	801e7b0 <_realloc_r+0x14>
 801e7d6:	0029      	movs	r1, r5
 801e7d8:	0032      	movs	r2, r6
 801e7da:	f7ff ff68 	bl	801e6ae <memcpy>
 801e7de:	0029      	movs	r1, r5
 801e7e0:	0038      	movs	r0, r7
 801e7e2:	f7ff ff91 	bl	801e708 <_free_r>
 801e7e6:	e7e3      	b.n	801e7b0 <_realloc_r+0x14>

0801e7e8 <_read_r>:
 801e7e8:	b570      	push	{r4, r5, r6, lr}
 801e7ea:	0004      	movs	r4, r0
 801e7ec:	0008      	movs	r0, r1
 801e7ee:	0011      	movs	r1, r2
 801e7f0:	001a      	movs	r2, r3
 801e7f2:	2300      	movs	r3, #0
 801e7f4:	4d05      	ldr	r5, [pc, #20]	; (801e80c <_read_r+0x24>)
 801e7f6:	602b      	str	r3, [r5, #0]
 801e7f8:	f000 f9b8 	bl	801eb6c <_read>
 801e7fc:	1c43      	adds	r3, r0, #1
 801e7fe:	d103      	bne.n	801e808 <_read_r+0x20>
 801e800:	682b      	ldr	r3, [r5, #0]
 801e802:	2b00      	cmp	r3, #0
 801e804:	d000      	beq.n	801e808 <_read_r+0x20>
 801e806:	6023      	str	r3, [r4, #0]
 801e808:	bd70      	pop	{r4, r5, r6, pc}
 801e80a:	46c0      	nop			; (mov r8, r8)
 801e80c:	20001838 	.word	0x20001838

0801e810 <_fstat_r>:
 801e810:	2300      	movs	r3, #0
 801e812:	b570      	push	{r4, r5, r6, lr}
 801e814:	4d06      	ldr	r5, [pc, #24]	; (801e830 <_fstat_r+0x20>)
 801e816:	0004      	movs	r4, r0
 801e818:	0008      	movs	r0, r1
 801e81a:	0011      	movs	r1, r2
 801e81c:	602b      	str	r3, [r5, #0]
 801e81e:	f000 f98d 	bl	801eb3c <_fstat>
 801e822:	1c43      	adds	r3, r0, #1
 801e824:	d103      	bne.n	801e82e <_fstat_r+0x1e>
 801e826:	682b      	ldr	r3, [r5, #0]
 801e828:	2b00      	cmp	r3, #0
 801e82a:	d000      	beq.n	801e82e <_fstat_r+0x1e>
 801e82c:	6023      	str	r3, [r4, #0]
 801e82e:	bd70      	pop	{r4, r5, r6, pc}
 801e830:	20001838 	.word	0x20001838

0801e834 <_isatty_r>:
 801e834:	2300      	movs	r3, #0
 801e836:	b570      	push	{r4, r5, r6, lr}
 801e838:	4d06      	ldr	r5, [pc, #24]	; (801e854 <_isatty_r+0x20>)
 801e83a:	0004      	movs	r4, r0
 801e83c:	0008      	movs	r0, r1
 801e83e:	602b      	str	r3, [r5, #0]
 801e840:	f000 f984 	bl	801eb4c <_isatty>
 801e844:	1c43      	adds	r3, r0, #1
 801e846:	d103      	bne.n	801e850 <_isatty_r+0x1c>
 801e848:	682b      	ldr	r3, [r5, #0]
 801e84a:	2b00      	cmp	r3, #0
 801e84c:	d000      	beq.n	801e850 <_isatty_r+0x1c>
 801e84e:	6023      	str	r3, [r4, #0]
 801e850:	bd70      	pop	{r4, r5, r6, pc}
 801e852:	46c0      	nop			; (mov r8, r8)
 801e854:	20001838 	.word	0x20001838

0801e858 <_malloc_usable_size_r>:
 801e858:	1f0b      	subs	r3, r1, #4
 801e85a:	681b      	ldr	r3, [r3, #0]
 801e85c:	1f18      	subs	r0, r3, #4
 801e85e:	2b00      	cmp	r3, #0
 801e860:	da01      	bge.n	801e866 <_malloc_usable_size_r+0xe>
 801e862:	580b      	ldr	r3, [r1, r0]
 801e864:	18c0      	adds	r0, r0, r3
 801e866:	4770      	bx	lr

0801e868 <ceil>:
 801e868:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801e86a:	004b      	lsls	r3, r1, #1
 801e86c:	4a3d      	ldr	r2, [pc, #244]	; (801e964 <ceil+0xfc>)
 801e86e:	0d5b      	lsrs	r3, r3, #21
 801e870:	189f      	adds	r7, r3, r2
 801e872:	4684      	mov	ip, r0
 801e874:	000e      	movs	r6, r1
 801e876:	000c      	movs	r4, r1
 801e878:	0005      	movs	r5, r0
 801e87a:	9001      	str	r0, [sp, #4]
 801e87c:	2f13      	cmp	r7, #19
 801e87e:	dc33      	bgt.n	801e8e8 <ceil+0x80>
 801e880:	2f00      	cmp	r7, #0
 801e882:	da15      	bge.n	801e8b0 <ceil+0x48>
 801e884:	4a38      	ldr	r2, [pc, #224]	; (801e968 <ceil+0x100>)
 801e886:	4b39      	ldr	r3, [pc, #228]	; (801e96c <ceil+0x104>)
 801e888:	4660      	mov	r0, ip
 801e88a:	0031      	movs	r1, r6
 801e88c:	f7e2 fe40 	bl	8001510 <__aeabi_dadd>
 801e890:	2200      	movs	r2, #0
 801e892:	2300      	movs	r3, #0
 801e894:	f7e1 fde2 	bl	800045c <__aeabi_dcmpgt>
 801e898:	2800      	cmp	r0, #0
 801e89a:	d006      	beq.n	801e8aa <ceil+0x42>
 801e89c:	2e00      	cmp	r6, #0
 801e89e:	db5c      	blt.n	801e95a <ceil+0xf2>
 801e8a0:	432c      	orrs	r4, r5
 801e8a2:	2500      	movs	r5, #0
 801e8a4:	42ac      	cmp	r4, r5
 801e8a6:	d000      	beq.n	801e8aa <ceil+0x42>
 801e8a8:	4c31      	ldr	r4, [pc, #196]	; (801e970 <ceil+0x108>)
 801e8aa:	46ac      	mov	ip, r5
 801e8ac:	0026      	movs	r6, r4
 801e8ae:	e029      	b.n	801e904 <ceil+0x9c>
 801e8b0:	4b30      	ldr	r3, [pc, #192]	; (801e974 <ceil+0x10c>)
 801e8b2:	413b      	asrs	r3, r7
 801e8b4:	9300      	str	r3, [sp, #0]
 801e8b6:	400b      	ands	r3, r1
 801e8b8:	4303      	orrs	r3, r0
 801e8ba:	d023      	beq.n	801e904 <ceil+0x9c>
 801e8bc:	4a2a      	ldr	r2, [pc, #168]	; (801e968 <ceil+0x100>)
 801e8be:	4b2b      	ldr	r3, [pc, #172]	; (801e96c <ceil+0x104>)
 801e8c0:	4660      	mov	r0, ip
 801e8c2:	0031      	movs	r1, r6
 801e8c4:	f7e2 fe24 	bl	8001510 <__aeabi_dadd>
 801e8c8:	2200      	movs	r2, #0
 801e8ca:	2300      	movs	r3, #0
 801e8cc:	f7e1 fdc6 	bl	800045c <__aeabi_dcmpgt>
 801e8d0:	2800      	cmp	r0, #0
 801e8d2:	d0ea      	beq.n	801e8aa <ceil+0x42>
 801e8d4:	2e00      	cmp	r6, #0
 801e8d6:	dd03      	ble.n	801e8e0 <ceil+0x78>
 801e8d8:	2380      	movs	r3, #128	; 0x80
 801e8da:	035b      	lsls	r3, r3, #13
 801e8dc:	413b      	asrs	r3, r7
 801e8de:	18f4      	adds	r4, r6, r3
 801e8e0:	9b00      	ldr	r3, [sp, #0]
 801e8e2:	2500      	movs	r5, #0
 801e8e4:	439c      	bics	r4, r3
 801e8e6:	e7e0      	b.n	801e8aa <ceil+0x42>
 801e8e8:	2f33      	cmp	r7, #51	; 0x33
 801e8ea:	dd0f      	ble.n	801e90c <ceil+0xa4>
 801e8ec:	2380      	movs	r3, #128	; 0x80
 801e8ee:	00db      	lsls	r3, r3, #3
 801e8f0:	429f      	cmp	r7, r3
 801e8f2:	d107      	bne.n	801e904 <ceil+0x9c>
 801e8f4:	0002      	movs	r2, r0
 801e8f6:	000b      	movs	r3, r1
 801e8f8:	4660      	mov	r0, ip
 801e8fa:	0031      	movs	r1, r6
 801e8fc:	f7e2 fe08 	bl	8001510 <__aeabi_dadd>
 801e900:	4684      	mov	ip, r0
 801e902:	000e      	movs	r6, r1
 801e904:	4660      	mov	r0, ip
 801e906:	0031      	movs	r1, r6
 801e908:	b003      	add	sp, #12
 801e90a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e90c:	4a1a      	ldr	r2, [pc, #104]	; (801e978 <ceil+0x110>)
 801e90e:	189b      	adds	r3, r3, r2
 801e910:	2201      	movs	r2, #1
 801e912:	4252      	negs	r2, r2
 801e914:	40da      	lsrs	r2, r3
 801e916:	9200      	str	r2, [sp, #0]
 801e918:	4210      	tst	r0, r2
 801e91a:	d0f3      	beq.n	801e904 <ceil+0x9c>
 801e91c:	4a12      	ldr	r2, [pc, #72]	; (801e968 <ceil+0x100>)
 801e91e:	4b13      	ldr	r3, [pc, #76]	; (801e96c <ceil+0x104>)
 801e920:	4660      	mov	r0, ip
 801e922:	0031      	movs	r1, r6
 801e924:	f7e2 fdf4 	bl	8001510 <__aeabi_dadd>
 801e928:	2200      	movs	r2, #0
 801e92a:	2300      	movs	r3, #0
 801e92c:	f7e1 fd96 	bl	800045c <__aeabi_dcmpgt>
 801e930:	2800      	cmp	r0, #0
 801e932:	d0ba      	beq.n	801e8aa <ceil+0x42>
 801e934:	2e00      	cmp	r6, #0
 801e936:	dd02      	ble.n	801e93e <ceil+0xd6>
 801e938:	2f14      	cmp	r7, #20
 801e93a:	d103      	bne.n	801e944 <ceil+0xdc>
 801e93c:	3401      	adds	r4, #1
 801e93e:	9b00      	ldr	r3, [sp, #0]
 801e940:	439d      	bics	r5, r3
 801e942:	e7b2      	b.n	801e8aa <ceil+0x42>
 801e944:	2334      	movs	r3, #52	; 0x34
 801e946:	1bdf      	subs	r7, r3, r7
 801e948:	3b33      	subs	r3, #51	; 0x33
 801e94a:	40bb      	lsls	r3, r7
 801e94c:	18ed      	adds	r5, r5, r3
 801e94e:	9b01      	ldr	r3, [sp, #4]
 801e950:	429d      	cmp	r5, r3
 801e952:	419b      	sbcs	r3, r3
 801e954:	425b      	negs	r3, r3
 801e956:	18f4      	adds	r4, r6, r3
 801e958:	e7f1      	b.n	801e93e <ceil+0xd6>
 801e95a:	2480      	movs	r4, #128	; 0x80
 801e95c:	2500      	movs	r5, #0
 801e95e:	0624      	lsls	r4, r4, #24
 801e960:	e7a3      	b.n	801e8aa <ceil+0x42>
 801e962:	46c0      	nop			; (mov r8, r8)
 801e964:	fffffc01 	.word	0xfffffc01
 801e968:	8800759c 	.word	0x8800759c
 801e96c:	7e37e43c 	.word	0x7e37e43c
 801e970:	3ff00000 	.word	0x3ff00000
 801e974:	000fffff 	.word	0x000fffff
 801e978:	fffffbed 	.word	0xfffffbed

0801e97c <floor>:
 801e97c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801e97e:	004b      	lsls	r3, r1, #1
 801e980:	4a3d      	ldr	r2, [pc, #244]	; (801ea78 <floor+0xfc>)
 801e982:	0d5b      	lsrs	r3, r3, #21
 801e984:	189f      	adds	r7, r3, r2
 801e986:	4684      	mov	ip, r0
 801e988:	000e      	movs	r6, r1
 801e98a:	000d      	movs	r5, r1
 801e98c:	0004      	movs	r4, r0
 801e98e:	9001      	str	r0, [sp, #4]
 801e990:	2f13      	cmp	r7, #19
 801e992:	dc34      	bgt.n	801e9fe <floor+0x82>
 801e994:	2f00      	cmp	r7, #0
 801e996:	da16      	bge.n	801e9c6 <floor+0x4a>
 801e998:	4a38      	ldr	r2, [pc, #224]	; (801ea7c <floor+0x100>)
 801e99a:	4b39      	ldr	r3, [pc, #228]	; (801ea80 <floor+0x104>)
 801e99c:	4660      	mov	r0, ip
 801e99e:	0031      	movs	r1, r6
 801e9a0:	f7e2 fdb6 	bl	8001510 <__aeabi_dadd>
 801e9a4:	2200      	movs	r2, #0
 801e9a6:	2300      	movs	r3, #0
 801e9a8:	f7e1 fd58 	bl	800045c <__aeabi_dcmpgt>
 801e9ac:	2800      	cmp	r0, #0
 801e9ae:	d007      	beq.n	801e9c0 <floor+0x44>
 801e9b0:	2e00      	cmp	r6, #0
 801e9b2:	da5d      	bge.n	801ea70 <floor+0xf4>
 801e9b4:	0073      	lsls	r3, r6, #1
 801e9b6:	085b      	lsrs	r3, r3, #1
 801e9b8:	431c      	orrs	r4, r3
 801e9ba:	d001      	beq.n	801e9c0 <floor+0x44>
 801e9bc:	2400      	movs	r4, #0
 801e9be:	4d31      	ldr	r5, [pc, #196]	; (801ea84 <floor+0x108>)
 801e9c0:	46a4      	mov	ip, r4
 801e9c2:	002e      	movs	r6, r5
 801e9c4:	e029      	b.n	801ea1a <floor+0x9e>
 801e9c6:	4b30      	ldr	r3, [pc, #192]	; (801ea88 <floor+0x10c>)
 801e9c8:	413b      	asrs	r3, r7
 801e9ca:	9300      	str	r3, [sp, #0]
 801e9cc:	400b      	ands	r3, r1
 801e9ce:	4303      	orrs	r3, r0
 801e9d0:	d023      	beq.n	801ea1a <floor+0x9e>
 801e9d2:	4a2a      	ldr	r2, [pc, #168]	; (801ea7c <floor+0x100>)
 801e9d4:	4b2a      	ldr	r3, [pc, #168]	; (801ea80 <floor+0x104>)
 801e9d6:	4660      	mov	r0, ip
 801e9d8:	0031      	movs	r1, r6
 801e9da:	f7e2 fd99 	bl	8001510 <__aeabi_dadd>
 801e9de:	2200      	movs	r2, #0
 801e9e0:	2300      	movs	r3, #0
 801e9e2:	f7e1 fd3b 	bl	800045c <__aeabi_dcmpgt>
 801e9e6:	2800      	cmp	r0, #0
 801e9e8:	d0ea      	beq.n	801e9c0 <floor+0x44>
 801e9ea:	2e00      	cmp	r6, #0
 801e9ec:	da03      	bge.n	801e9f6 <floor+0x7a>
 801e9ee:	2380      	movs	r3, #128	; 0x80
 801e9f0:	035b      	lsls	r3, r3, #13
 801e9f2:	413b      	asrs	r3, r7
 801e9f4:	18f5      	adds	r5, r6, r3
 801e9f6:	9b00      	ldr	r3, [sp, #0]
 801e9f8:	2400      	movs	r4, #0
 801e9fa:	439d      	bics	r5, r3
 801e9fc:	e7e0      	b.n	801e9c0 <floor+0x44>
 801e9fe:	2f33      	cmp	r7, #51	; 0x33
 801ea00:	dd0f      	ble.n	801ea22 <floor+0xa6>
 801ea02:	2380      	movs	r3, #128	; 0x80
 801ea04:	00db      	lsls	r3, r3, #3
 801ea06:	429f      	cmp	r7, r3
 801ea08:	d107      	bne.n	801ea1a <floor+0x9e>
 801ea0a:	0002      	movs	r2, r0
 801ea0c:	000b      	movs	r3, r1
 801ea0e:	4660      	mov	r0, ip
 801ea10:	0031      	movs	r1, r6
 801ea12:	f7e2 fd7d 	bl	8001510 <__aeabi_dadd>
 801ea16:	4684      	mov	ip, r0
 801ea18:	000e      	movs	r6, r1
 801ea1a:	4660      	mov	r0, ip
 801ea1c:	0031      	movs	r1, r6
 801ea1e:	b003      	add	sp, #12
 801ea20:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801ea22:	4a1a      	ldr	r2, [pc, #104]	; (801ea8c <floor+0x110>)
 801ea24:	189b      	adds	r3, r3, r2
 801ea26:	2201      	movs	r2, #1
 801ea28:	4252      	negs	r2, r2
 801ea2a:	40da      	lsrs	r2, r3
 801ea2c:	9200      	str	r2, [sp, #0]
 801ea2e:	4210      	tst	r0, r2
 801ea30:	d0f3      	beq.n	801ea1a <floor+0x9e>
 801ea32:	4a12      	ldr	r2, [pc, #72]	; (801ea7c <floor+0x100>)
 801ea34:	4b12      	ldr	r3, [pc, #72]	; (801ea80 <floor+0x104>)
 801ea36:	4660      	mov	r0, ip
 801ea38:	0031      	movs	r1, r6
 801ea3a:	f7e2 fd69 	bl	8001510 <__aeabi_dadd>
 801ea3e:	2200      	movs	r2, #0
 801ea40:	2300      	movs	r3, #0
 801ea42:	f7e1 fd0b 	bl	800045c <__aeabi_dcmpgt>
 801ea46:	2800      	cmp	r0, #0
 801ea48:	d0ba      	beq.n	801e9c0 <floor+0x44>
 801ea4a:	2e00      	cmp	r6, #0
 801ea4c:	da02      	bge.n	801ea54 <floor+0xd8>
 801ea4e:	2f14      	cmp	r7, #20
 801ea50:	d103      	bne.n	801ea5a <floor+0xde>
 801ea52:	3501      	adds	r5, #1
 801ea54:	9b00      	ldr	r3, [sp, #0]
 801ea56:	439c      	bics	r4, r3
 801ea58:	e7b2      	b.n	801e9c0 <floor+0x44>
 801ea5a:	2334      	movs	r3, #52	; 0x34
 801ea5c:	1bdf      	subs	r7, r3, r7
 801ea5e:	3b33      	subs	r3, #51	; 0x33
 801ea60:	40bb      	lsls	r3, r7
 801ea62:	18e4      	adds	r4, r4, r3
 801ea64:	9b01      	ldr	r3, [sp, #4]
 801ea66:	429c      	cmp	r4, r3
 801ea68:	419b      	sbcs	r3, r3
 801ea6a:	425b      	negs	r3, r3
 801ea6c:	18f5      	adds	r5, r6, r3
 801ea6e:	e7f1      	b.n	801ea54 <floor+0xd8>
 801ea70:	2400      	movs	r4, #0
 801ea72:	0025      	movs	r5, r4
 801ea74:	e7a4      	b.n	801e9c0 <floor+0x44>
 801ea76:	46c0      	nop			; (mov r8, r8)
 801ea78:	fffffc01 	.word	0xfffffc01
 801ea7c:	8800759c 	.word	0x8800759c
 801ea80:	7e37e43c 	.word	0x7e37e43c
 801ea84:	bff00000 	.word	0xbff00000
 801ea88:	000fffff 	.word	0x000fffff
 801ea8c:	fffffbed 	.word	0xfffffbed

0801ea90 <round>:
 801ea90:	b570      	push	{r4, r5, r6, lr}
 801ea92:	000d      	movs	r5, r1
 801ea94:	0006      	movs	r6, r0
 801ea96:	0001      	movs	r1, r0
 801ea98:	006a      	lsls	r2, r5, #1
 801ea9a:	4820      	ldr	r0, [pc, #128]	; (801eb1c <round+0x8c>)
 801ea9c:	0d52      	lsrs	r2, r2, #21
 801ea9e:	1810      	adds	r0, r2, r0
 801eaa0:	2813      	cmp	r0, #19
 801eaa2:	dc18      	bgt.n	801ead6 <round+0x46>
 801eaa4:	2800      	cmp	r0, #0
 801eaa6:	da09      	bge.n	801eabc <round+0x2c>
 801eaa8:	0feb      	lsrs	r3, r5, #31
 801eaaa:	2200      	movs	r2, #0
 801eaac:	07db      	lsls	r3, r3, #31
 801eaae:	1c41      	adds	r1, r0, #1
 801eab0:	d101      	bne.n	801eab6 <round+0x26>
 801eab2:	491b      	ldr	r1, [pc, #108]	; (801eb20 <round+0x90>)
 801eab4:	430b      	orrs	r3, r1
 801eab6:	0019      	movs	r1, r3
 801eab8:	0010      	movs	r0, r2
 801eaba:	e018      	b.n	801eaee <round+0x5e>
 801eabc:	4c19      	ldr	r4, [pc, #100]	; (801eb24 <round+0x94>)
 801eabe:	4104      	asrs	r4, r0
 801eac0:	0022      	movs	r2, r4
 801eac2:	402a      	ands	r2, r5
 801eac4:	4311      	orrs	r1, r2
 801eac6:	d014      	beq.n	801eaf2 <round+0x62>
 801eac8:	2280      	movs	r2, #128	; 0x80
 801eaca:	0312      	lsls	r2, r2, #12
 801eacc:	4102      	asrs	r2, r0
 801eace:	1953      	adds	r3, r2, r5
 801ead0:	43a3      	bics	r3, r4
 801ead2:	2200      	movs	r2, #0
 801ead4:	e7ef      	b.n	801eab6 <round+0x26>
 801ead6:	2833      	cmp	r0, #51	; 0x33
 801ead8:	dd0e      	ble.n	801eaf8 <round+0x68>
 801eada:	2380      	movs	r3, #128	; 0x80
 801eadc:	00db      	lsls	r3, r3, #3
 801eade:	4298      	cmp	r0, r3
 801eae0:	d107      	bne.n	801eaf2 <round+0x62>
 801eae2:	0032      	movs	r2, r6
 801eae4:	002b      	movs	r3, r5
 801eae6:	0030      	movs	r0, r6
 801eae8:	0029      	movs	r1, r5
 801eaea:	f7e2 fd11 	bl	8001510 <__aeabi_dadd>
 801eaee:	0006      	movs	r6, r0
 801eaf0:	000d      	movs	r5, r1
 801eaf2:	0030      	movs	r0, r6
 801eaf4:	0029      	movs	r1, r5
 801eaf6:	bd70      	pop	{r4, r5, r6, pc}
 801eaf8:	4c0b      	ldr	r4, [pc, #44]	; (801eb28 <round+0x98>)
 801eafa:	1912      	adds	r2, r2, r4
 801eafc:	2401      	movs	r4, #1
 801eafe:	4264      	negs	r4, r4
 801eb00:	40d4      	lsrs	r4, r2
 801eb02:	4234      	tst	r4, r6
 801eb04:	d0f5      	beq.n	801eaf2 <round+0x62>
 801eb06:	2233      	movs	r2, #51	; 0x33
 801eb08:	1a10      	subs	r0, r2, r0
 801eb0a:	3a32      	subs	r2, #50	; 0x32
 801eb0c:	4082      	lsls	r2, r0
 801eb0e:	1992      	adds	r2, r2, r6
 801eb10:	42b2      	cmp	r2, r6
 801eb12:	4189      	sbcs	r1, r1
 801eb14:	4249      	negs	r1, r1
 801eb16:	186b      	adds	r3, r5, r1
 801eb18:	43a2      	bics	r2, r4
 801eb1a:	e7cc      	b.n	801eab6 <round+0x26>
 801eb1c:	fffffc01 	.word	0xfffffc01
 801eb20:	3ff00000 	.word	0x3ff00000
 801eb24:	000fffff 	.word	0x000fffff
 801eb28:	fffffbed 	.word	0xfffffbed

0801eb2c <_close>:
 801eb2c:	2258      	movs	r2, #88	; 0x58
 801eb2e:	2001      	movs	r0, #1
 801eb30:	4b01      	ldr	r3, [pc, #4]	; (801eb38 <_close+0xc>)
 801eb32:	4240      	negs	r0, r0
 801eb34:	601a      	str	r2, [r3, #0]
 801eb36:	4770      	bx	lr
 801eb38:	20001838 	.word	0x20001838

0801eb3c <_fstat>:
 801eb3c:	2258      	movs	r2, #88	; 0x58
 801eb3e:	2001      	movs	r0, #1
 801eb40:	4b01      	ldr	r3, [pc, #4]	; (801eb48 <_fstat+0xc>)
 801eb42:	4240      	negs	r0, r0
 801eb44:	601a      	str	r2, [r3, #0]
 801eb46:	4770      	bx	lr
 801eb48:	20001838 	.word	0x20001838

0801eb4c <_isatty>:
 801eb4c:	2258      	movs	r2, #88	; 0x58
 801eb4e:	4b02      	ldr	r3, [pc, #8]	; (801eb58 <_isatty+0xc>)
 801eb50:	2000      	movs	r0, #0
 801eb52:	601a      	str	r2, [r3, #0]
 801eb54:	4770      	bx	lr
 801eb56:	46c0      	nop			; (mov r8, r8)
 801eb58:	20001838 	.word	0x20001838

0801eb5c <_lseek>:
 801eb5c:	2258      	movs	r2, #88	; 0x58
 801eb5e:	2001      	movs	r0, #1
 801eb60:	4b01      	ldr	r3, [pc, #4]	; (801eb68 <_lseek+0xc>)
 801eb62:	4240      	negs	r0, r0
 801eb64:	601a      	str	r2, [r3, #0]
 801eb66:	4770      	bx	lr
 801eb68:	20001838 	.word	0x20001838

0801eb6c <_read>:
 801eb6c:	2258      	movs	r2, #88	; 0x58
 801eb6e:	2001      	movs	r0, #1
 801eb70:	4b01      	ldr	r3, [pc, #4]	; (801eb78 <_read+0xc>)
 801eb72:	4240      	negs	r0, r0
 801eb74:	601a      	str	r2, [r3, #0]
 801eb76:	4770      	bx	lr
 801eb78:	20001838 	.word	0x20001838

0801eb7c <_sbrk>:
 801eb7c:	4a05      	ldr	r2, [pc, #20]	; (801eb94 <_sbrk+0x18>)
 801eb7e:	0003      	movs	r3, r0
 801eb80:	6811      	ldr	r1, [r2, #0]
 801eb82:	2900      	cmp	r1, #0
 801eb84:	d101      	bne.n	801eb8a <_sbrk+0xe>
 801eb86:	4904      	ldr	r1, [pc, #16]	; (801eb98 <_sbrk+0x1c>)
 801eb88:	6011      	str	r1, [r2, #0]
 801eb8a:	6810      	ldr	r0, [r2, #0]
 801eb8c:	18c3      	adds	r3, r0, r3
 801eb8e:	6013      	str	r3, [r2, #0]
 801eb90:	4770      	bx	lr
 801eb92:	46c0      	nop			; (mov r8, r8)
 801eb94:	2000171c 	.word	0x2000171c
 801eb98:	20001840 	.word	0x20001840

0801eb9c <_write>:
 801eb9c:	2258      	movs	r2, #88	; 0x58
 801eb9e:	2001      	movs	r0, #1
 801eba0:	4b01      	ldr	r3, [pc, #4]	; (801eba8 <_write+0xc>)
 801eba2:	4240      	negs	r0, r0
 801eba4:	601a      	str	r2, [r3, #0]
 801eba6:	4770      	bx	lr
 801eba8:	20001838 	.word	0x20001838

0801ebac <_init>:
 801ebac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ebae:	46c0      	nop			; (mov r8, r8)
 801ebb0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801ebb2:	bc08      	pop	{r3}
 801ebb4:	469e      	mov	lr, r3
 801ebb6:	4770      	bx	lr

0801ebb8 <_fini>:
 801ebb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ebba:	46c0      	nop			; (mov r8, r8)
 801ebbc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801ebbe:	bc08      	pop	{r3}
 801ebc0:	469e      	mov	lr, r3
 801ebc2:	4770      	bx	lr
